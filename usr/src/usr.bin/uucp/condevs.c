begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)condevs.c	5.6 (Berkeley) 8/12/83"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Here are various dialers to establish the machine-machine connection.  * conn.c/condevs.c was glued together by Mike Mitchell.  * The dialers were supplied by many people, to whom we are grateful.  *  * ---------------------------------------------------------------------  * NOTE:  * There is a bug that occurs at least on PDP11s due to a limitation of  * setjmp/longjmp.   If the routine that does a setjmp is interrupted  * and longjmp-ed to,  it loses its register variables (on a pdp11).  * What works is if the routine that does the setjmp  * calls a routine and it is the *subroutine* that is interrupted.  *   * Anyway, in conclusion, condevs.c is plagued with register variables  * that are used inside  * 	if (setjmp(...)) {  * 		....  * 	}  *   * THE FIX: In dnopn(), for example, delete the 'register' Devices *dev.  * (That was causing a core dump; deleting register fixed it.)  * Also for dnopn delete 'register' int dnf... .  * In pkopn, delete 'register' flds... .  * There may be others, especially mcm's version of hysopen.  * You could just delete all references to register, that is safest.  * This problem might not occur on 4.1bsd, I am not sure.  * 	Tom Truscott  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_decl_stmt
specifier|extern
name|char
name|devSel
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name to pass to delock() in close */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|,
name|next_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|jmp_buf
name|Sjbuf
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|alarmtr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|nulldev
argument_list|()
decl_stmt|,
name|nodev
argument_list|()
decl_stmt|,
name|Acuopn
argument_list|()
decl_stmt|,
name|diropn
argument_list|()
decl_stmt|,
name|dircls
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DATAKIT
end_ifdef

begin_function_decl
name|int
name|dkopn
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DN11
end_ifdef

begin_decl_stmt
name|int
name|dnopn
argument_list|()
decl_stmt|,
name|dncls
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAYES
end_ifdef

begin_decl_stmt
name|int
name|hysopn
argument_list|()
decl_stmt|,
name|hyscls
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAYESQ
end_ifdef

begin_decl_stmt
name|int
name|hysqopn
argument_list|()
decl_stmt|,
name|hysqcls
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a version of hayes that doesn't use ret codes */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DF02
end_ifdef

begin_decl_stmt
name|int
name|df2opn
argument_list|()
decl_stmt|,
name|df2cls
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PNET
end_ifdef

begin_function_decl
name|int
name|pnetopn
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VENTEL
end_ifdef

begin_decl_stmt
name|int
name|ventopn
argument_list|()
decl_stmt|,
name|ventcls
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UNET
end_ifdef

begin_include
include|#
directive|include
file|<UNET/unetio.h>
end_include

begin_include
include|#
directive|include
file|<UNET/tcp.h>
end_include

begin_decl_stmt
name|int
name|unetopn
argument_list|()
decl_stmt|,
name|unetcls
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|UNET
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VADIC
end_ifdef

begin_decl_stmt
name|int
name|vadopn
argument_list|()
decl_stmt|,
name|vadcls
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|VADIC
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RVMACS
end_ifdef

begin_decl_stmt
name|int
name|rvmacsopn
argument_list|()
decl_stmt|,
name|rvmacscls
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MICOM
end_ifdef

begin_decl_stmt
name|int
name|micopn
argument_list|()
decl_stmt|,
name|miccls
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|MICOM
end_endif

begin_decl_stmt
name|struct
name|condev
name|condevs
index|[]
init|=
block|{
block|{
literal|"DIR"
block|,
literal|"direct"
block|,
name|diropn
block|,
name|nulldev
block|,
name|dircls
block|}
block|,
ifdef|#
directive|ifdef
name|DATAKIT
block|{
literal|"DK"
block|,
literal|"datakit"
block|,
name|dkopn
block|,
name|nulldev
block|,
name|nulldev
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PNET
block|{
literal|"PNET"
block|,
literal|"pnet"
block|,
name|pnetopn
block|,
name|nulldev
block|,
name|nulldev
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UNET
block|{
literal|"UNET"
block|,
literal|"UNET"
block|,
name|unetopn
block|,
name|nulldev
block|,
name|unetcls
block|}
block|,
endif|#
directive|endif
endif|UNET
ifdef|#
directive|ifdef
name|MICOM
block|{
literal|"MICOM"
block|,
literal|"micom"
block|,
name|micopn
block|,
name|nulldev
block|,
name|miccls
block|}
block|,
endif|#
directive|endif
endif|MICOM
ifdef|#
directive|ifdef
name|DN11
block|{
literal|"ACU"
block|,
literal|"dn11"
block|,
name|Acuopn
block|,
name|dnopn
block|,
name|dncls
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAYES
block|{
literal|"ACU"
block|,
literal|"hayes"
block|,
name|Acuopn
block|,
name|hysopn
block|,
name|hyscls
block|}
block|,
endif|#
directive|endif
endif|HAYES
ifdef|#
directive|ifdef
name|HAYESQ
comment|/* a version of hayes that doesn't use result codes */
block|{
literal|"ACU"
block|,
literal|"hayesq"
block|,
name|Acuopn
block|,
name|hysqopn
block|,
name|hysqcls
block|}
block|,
endif|#
directive|endif
endif|HATESQ
ifdef|#
directive|ifdef
name|DF02
block|{
literal|"ACU"
block|,
literal|"DF02"
block|,
name|Acuopn
block|,
name|df2opn
block|,
name|df2cls
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VENTEL
block|{
literal|"ACU"
block|,
literal|"ventel"
block|,
name|Acuopn
block|,
name|ventopn
block|,
name|ventcls
block|}
block|,
endif|#
directive|endif
endif|VENTEL
ifdef|#
directive|ifdef
name|VADIC
block|{
literal|"ACU"
block|,
literal|"vadic"
block|,
name|Acuopn
block|,
name|vadopn
block|,
name|vadcls
block|}
block|,
endif|#
directive|endif
endif|VADIC
ifdef|#
directive|ifdef
name|RVMACS
block|{
literal|"ACU"
block|,
literal|"rvmacs"
block|,
name|Acuopn
block|,
name|rvmacsopn
block|,
name|rvmacscls
block|}
block|,
endif|#
directive|endif
endif|RVMACS
comment|/* Insert new entries before this line */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***  *	nulldev		a null device (returns CF_DIAL)  */
end_comment

begin_function
name|int
name|nulldev
parameter_list|()
block|{
return|return
operator|(
name|CF_DIAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/***  *	nodev		a null device (returns CF_NODEV)  */
end_comment

begin_function
name|int
name|nodev
parameter_list|()
block|{
return|return
operator|(
name|CF_NODEV
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The first things in this file are the generic devices.   * Generic devices look through L-devices and call the CU_open routines for  * appropriate devices.  Some things, like the Unet interface, or direct  * connect, do not use the CU_open entry.  ACUs must search to find the'  * right routine to call.  */
end_comment

begin_comment
comment|/***  *	diropn(flds)	connect to hardware line  *	char *flds[];  *  *	return codes:  *>0  -  file number  -  ok  *		FAIL  -  failed  */
end_comment

begin_expr_stmt
name|diropn
argument_list|(
name|flds
argument_list|)
specifier|register
name|char
operator|*
name|flds
index|[]
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|dcr
decl_stmt|,
name|status
decl_stmt|;
name|struct
name|Devices
name|dev
decl_stmt|;
name|char
name|dcname
index|[
literal|20
index|]
decl_stmt|;
name|FILE
modifier|*
name|dfp
decl_stmt|;
name|dfp
operator|=
name|fopen
argument_list|(
name|DEVFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dfp
operator|!=
name|NULL
argument_list|,
literal|"CAN'T OPEN"
argument_list|,
name|DEVFILE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|status
operator|=
name|rddev
argument_list|(
name|dfp
argument_list|,
operator|&
name|dev
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|flds
index|[
name|F_CLASS
index|]
argument_list|,
name|dev
operator|.
name|D_class
argument_list|)
operator|!=
name|SAME
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|flds
index|[
name|F_PHONE
index|]
argument_list|,
name|dev
operator|.
name|D_line
argument_list|)
operator|!=
name|SAME
condition|)
continue|continue;
if|if
condition|(
name|mlock
argument_list|(
name|dev
operator|.
name|D_line
argument_list|)
operator|!=
name|FAIL
condition|)
break|break;
block|}
name|fclose
argument_list|(
name|dfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|FAIL
condition|)
block|{
name|logent
argument_list|(
literal|"DEVICE"
argument_list|,
literal|"NO"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CF_NODEV
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|dcname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|dev
operator|.
name|D_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
block|{
name|delock
argument_list|(
name|dev
operator|.
name|D_line
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|getnextfd
argument_list|()
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|dcr
operator|=
name|open
argument_list|(
name|dcname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* read/write */
name|next_fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dcr
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EACCES
condition|)
name|logent
argument_list|(
name|dcname
argument_list|,
literal|"CAN'T OPEN"
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcr
operator|<
literal|0
condition|)
block|{
name|delock
argument_list|(
name|dev
operator|.
name|D_line
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fixline
argument_list|(
name|dcr
argument_list|,
name|dev
operator|.
name|D_speed
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|devSel
argument_list|,
name|dev
operator|.
name|D_line
argument_list|)
expr_stmt|;
comment|/* for latter unlock */
name|CU_end
operator|=
name|dircls
expr_stmt|;
return|return
operator|(
name|dcr
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|dircls
argument_list|(
name|fd
argument_list|)
specifier|register
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|fd
operator|>
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|devSel
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DATAKIT
end_ifdef

begin_include
include|#
directive|include
file|<dk.h>
end_include

begin_define
define|#
directive|define
name|DKTRIES
value|2
end_define

begin_comment
comment|/***  *	dkopn(flds)	make datakit connection  *  *	return codes:  *>0 - file number - ok  *		FAIL - failed  */
end_comment

begin_macro
name|dkopn
argument_list|(
argument|flds
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|flds
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|dkphone
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|ret
operator|,
name|i
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
name|dkphone
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|flds
index|[
name|F_PHONE
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|dkphone
operator|=
literal|10
operator|*
name|dkphone
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"dkphone (%d) "
argument_list|,
name|dkphone
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DKTRIES
condition|;
name|i
operator|++
control|)
block|{
name|getnextfd
argument_list|()
expr_stmt|;
name|ret
operator|=
name|dkdial
argument_list|(
name|D_SH
argument_list|,
name|dkphone
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|next_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"dkdial (%d)\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
operator|-
literal|1
condition|)
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PNET
end_ifdef

begin_comment
comment|/***  *	pnetopn(flds)  *  *	call remote machine via Purdue network  *	use dial string as host name, speed as socket number  * Author: Steve Bellovin  */
end_comment

begin_macro
name|pnetopn
argument_list|(
argument|flds
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|flds
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|int
name|socket
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|fd
operator|=
name|pnetfile
argument_list|()
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"pnet fd - %d\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|logent
argument_list|(
literal|"AVAILABLE DEVICE"
argument_list|,
literal|"NO"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CF_NODEV
operator|)
return|;
block|}
name|socket
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|flds
index|[
name|F_CLASS
index|]
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|socket
operator|=
literal|10
operator|*
name|socket
operator|+
operator|(
operator|*
name|cp
operator|-
literal|'0'
operator|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"socket - %d\n"
argument_list|,
name|socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"pnet timeout  - %s\n"
argument_list|,
name|flds
index|[
name|F_PHONE
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"host - %s\n"
argument_list|,
name|flds
index|[
name|F_PHONE
index|]
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnetscon
argument_list|(
name|fd
argument_list|,
name|flds
index|[
name|F_PHONE
index|]
argument_list|,
name|socket
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"pnet connect failed - %s\n"
argument_list|,
name|flds
index|[
name|F_PHONE
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|PNET
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UNET
end_ifdef

begin_comment
comment|/***  *	unetopn -- make UNET (tcp-ip) connection  *  *	return codes:  *>0 - file number - ok  *		FAIL - failed  */
end_comment

begin_comment
comment|/* Default port of uucico server */
end_comment

begin_define
define|#
directive|define
name|DFLTPORT
value|33
end_define

begin_expr_stmt
name|unetopn
argument_list|(
name|flds
argument_list|)
specifier|register
name|char
operator|*
name|flds
index|[]
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|ret
decl_stmt|,
name|port
decl_stmt|;
name|int
name|unetcls
parameter_list|()
function_decl|;
name|port
operator|=
name|atoi
argument_list|(
name|flds
index|[
name|F_PHONE
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|<=
literal|0
operator|||
name|port
operator|>
literal|255
condition|)
name|port
operator|=
name|DFLTPORT
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"unetopn host %s, "
argument_list|,
name|flds
index|[
name|F_NAME
index|]
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"port %d\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
block|{
name|logent
argument_list|(
literal|"tcpopen"
argument_list|,
literal|"TIMEOUT"
argument_list|)
expr_stmt|;
name|endhnent
argument_list|()
expr_stmt|;
comment|/* see below */
return|return
operator|(
name|CF_DIAL
operator|)
return|;
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|ret
operator|=
name|tcpopen
argument_list|(
name|flds
index|[
name|F_NAME
index|]
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|TO_ACTIVE
argument_list|,
literal|"rw"
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|endhnent
argument_list|()
expr_stmt|;
comment|/* wave magic wand at 3com and incant "eat it, bruce" */
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"tcpopen failed: errno %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"tcpopen"
argument_list|,
literal|"FAILED"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CF_DIAL
operator|)
return|;
block|}
name|CU_end
operator|=
name|unetcls
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * unetcls -- close UNET connection.  */
end_comment

begin_expr_stmt
name|unetcls
argument_list|(
name|fd
argument_list|)
specifier|register
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"UNET CLOSE called\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>
literal|0
condition|)
block|{
comment|/* disable this until a timeout is put in 		if (ioctl(fd, UIOCCLOSE, STBNULL)) 			logent("UNET CLOSE", "FAILED"); 		 */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"closed fd %d\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|UNET
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MICOM
end_ifdef

begin_comment
comment|/*  *	micopn: establish connection through a micom.  *	Returns descriptor open to tty for reading and writing.  *	Negative values (-1...-7) denote errors in connmsg.  *	Be sure to disconnect tty when done, via HUPCL or stty 0.  */
end_comment

begin_expr_stmt
name|micopn
argument_list|(
name|flds
argument_list|)
specifier|register
name|char
operator|*
name|flds
index|[]
expr_stmt|;
end_expr_stmt

begin_block
block|{
extern|extern errno;
name|char
modifier|*
name|rindex
argument_list|()
decl_stmt|,
modifier|*
name|fdig
argument_list|()
decl_stmt|,
name|dcname
index|[
literal|20
index|]
decl_stmt|;
name|int
name|dh
decl_stmt|,
name|ok
init|=
literal|0
decl_stmt|,
name|speed
decl_stmt|;
specifier|register
name|struct
name|condev
modifier|*
name|cd
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|dfp
decl_stmt|;
name|struct
name|Devices
name|dev
decl_stmt|;
name|dfp
operator|=
name|fopen
argument_list|(
name|DEVFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dfp
operator|!=
name|NULL
argument_list|,
literal|"Can't open"
argument_list|,
name|DEVFILE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
name|dh
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|cd
operator|=
name|condevs
init|;
operator|(
operator|(
name|cd
operator|->
name|CU_meth
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|dh
operator|<
literal|0
operator|)
operator|)
condition|;
name|cd
operator|++
control|)
block|{
if|if
condition|(
name|snccmp
argument_list|(
name|flds
index|[
name|F_LINE
index|]
argument_list|,
name|cd
operator|->
name|CU_meth
argument_list|)
operator|==
name|SAME
condition|)
block|{
name|fseek
argument_list|(
name|dfp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|rddev
argument_list|(
name|dfp
argument_list|,
operator|&
name|dev
argument_list|)
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|flds
index|[
name|F_CLASS
index|]
argument_list|,
name|dev
operator|.
name|D_class
argument_list|)
operator|!=
name|SAME
condition|)
continue|continue;
if|if
condition|(
name|snccmp
argument_list|(
name|flds
index|[
name|F_LINE
index|]
argument_list|,
name|dev
operator|.
name|D_type
argument_list|)
operator|!=
name|SAME
condition|)
continue|continue;
if|if
condition|(
name|mlock
argument_list|(
name|dev
operator|.
name|D_line
argument_list|)
operator|==
name|FAIL
condition|)
continue|continue;
name|sprintf
argument_list|(
name|dcname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|dev
operator|.
name|D_line
argument_list|)
expr_stmt|;
name|getnextfd
argument_list|()
expr_stmt|;
name|alarm
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
block|{
name|delock
argument_list|(
name|dev
operator|.
name|D_line
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|dev
operator|.
name|D_line
argument_list|,
literal|"micom open TIMEOUT"
argument_list|)
expr_stmt|;
name|dh
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|dh
operator|=
name|open
argument_list|(
name|dcname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|next_fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dh
operator|>
literal|0
condition|)
block|{
break|break;
block|}
name|devSel
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|delock
argument_list|(
name|dev
operator|.
name|D_line
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fclose
argument_list|(
name|dfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|<
literal|0
condition|)
return|return
operator|(
name|CF_NODEV
operator|)
return|;
name|speed
operator|=
name|atoi
argument_list|(
name|fdig
argument_list|(
name|flds
index|[
name|F_CLASS
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|fixline
argument_list|(
name|dh
argument_list|,
name|speed
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* negotiate with micom */
if|if
condition|(
name|speed
operator|!=
literal|4800
condition|)
comment|/* damn their eyes! */
name|write
argument_list|(
name|dh
argument_list|,
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|write
argument_list|(
name|dh
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"wanted %s "
argument_list|,
literal|"NAME"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|expect
argument_list|(
literal|"NAME"
argument_list|,
name|dh
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"got %s\n"
argument_list|,
name|ok
condition|?
literal|"?"
else|:
literal|"that"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
block|{
name|write
argument_list|(
name|dh
argument_list|,
name|flds
index|[
name|F_PHONE
index|]
argument_list|,
name|strlen
argument_list|(
name|flds
index|[
name|F_PHONE
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|dh
argument_list|,
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"wanted %s "
argument_list|,
literal|"GO"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|expect
argument_list|(
literal|"GO"
argument_list|,
name|dh
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"got %s\n"
argument_list|,
name|ok
condition|?
literal|"?"
else|:
literal|"that"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dh
operator|>
literal|2
condition|)
name|close
argument_list|(
name|dh
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"micom failed\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|dev
operator|.
name|D_line
argument_list|)
expr_stmt|;
return|return
operator|(
name|CF_DIAL
operator|)
return|;
block|}
else|else
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"micom ok\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|CU_end
operator|=
name|cd
operator|->
name|CU_clos
expr_stmt|;
name|strcat
argument_list|(
name|devSel
argument_list|,
name|dev
operator|.
name|D_line
argument_list|)
expr_stmt|;
comment|/* for later unlock */
return|return
operator|(
name|dh
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|miccls
argument_list|(
name|fd
argument_list|)
specifier|register
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|fd
operator|>
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|devSel
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|MICOM
end_endif

begin_comment
comment|/***  *	Acuopn - open an ACU and dial the number.  The condevs table  *		will be searched until a dialing unit is found that is  *		free.  *  *	return codes:>0 - file number - o.k.  *			FAIL - failed  */
end_comment

begin_decl_stmt
name|char
name|devSel
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used for later unlock() */
end_comment

begin_expr_stmt
name|Acuopn
argument_list|(
name|flds
argument_list|)
specifier|register
name|char
operator|*
name|flds
index|[]
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|phone
index|[
name|MAXPH
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|struct
name|condev
modifier|*
name|cd
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|dfp
decl_stmt|;
name|struct
name|Devices
name|dev
decl_stmt|;
name|exphone
argument_list|(
name|flds
index|[
name|F_PHONE
index|]
argument_list|,
name|phone
argument_list|)
expr_stmt|;
name|devSel
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Dialing %s\n"
argument_list|,
name|phone
argument_list|)
expr_stmt|;
name|dfp
operator|=
name|fopen
argument_list|(
name|DEVFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dfp
operator|!=
name|NULL
argument_list|,
literal|"Can't open"
argument_list|,
name|DEVFILE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|cd
operator|=
name|condevs
init|;
name|cd
operator|->
name|CU_meth
operator|!=
name|NULL
condition|;
name|cd
operator|++
control|)
block|{
if|if
condition|(
name|snccmp
argument_list|(
name|flds
index|[
name|F_LINE
index|]
argument_list|,
name|cd
operator|->
name|CU_meth
argument_list|)
operator|==
name|SAME
condition|)
block|{
name|fseek
argument_list|(
name|dfp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|rddev
argument_list|(
name|dfp
argument_list|,
operator|&
name|dev
argument_list|)
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|flds
index|[
name|F_CLASS
index|]
argument_list|,
name|dev
operator|.
name|D_class
argument_list|)
operator|!=
name|SAME
condition|)
continue|continue;
if|if
condition|(
name|snccmp
argument_list|(
name|flds
index|[
name|F_LINE
index|]
argument_list|,
name|dev
operator|.
name|D_type
argument_list|)
operator|!=
name|SAME
condition|)
continue|continue;
if|if
condition|(
name|dev
operator|.
name|D_brand
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|logent
argument_list|(
literal|"Acuopn"
argument_list|,
literal|"No 'brand' name on ACU"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|snccmp
argument_list|(
name|dev
operator|.
name|D_brand
argument_list|,
name|cd
operator|->
name|CU_brand
argument_list|)
operator|!=
name|SAME
condition|)
continue|continue;
if|if
condition|(
name|mlock
argument_list|(
name|dev
operator|.
name|D_line
argument_list|)
operator|==
name|FAIL
condition|)
continue|continue;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Using %s\n"
argument_list|,
name|cd
operator|->
name|CU_brand
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|(
operator|*
operator|(
name|cd
operator|->
name|CU_open
operator|)
operator|)
operator|(
name|phone
operator|,
name|flds
operator|,
operator|&
name|dev
operator|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>
literal|0
condition|)
block|{
name|CU_end
operator|=
name|cd
operator|->
name|CU_clos
expr_stmt|;
comment|/* point CU_end at close func */
name|fclose
argument_list|(
name|dfp
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|devSel
argument_list|,
name|dev
operator|.
name|D_line
argument_list|)
expr_stmt|;
comment|/* save for later unlock() */
return|return
operator|(
name|fd
operator|)
return|;
block|}
name|delock
argument_list|(
name|dev
operator|.
name|D_line
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fclose
argument_list|(
name|dfp
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DN11
end_ifdef

begin_comment
comment|/***  *	dnopn(ph, flds, dev)	dial remote machine  *	char *ph;  *	char *flds[];  *	struct Devices *dev;  *  *	return codes:  *		file descriptor  -  succeeded  *		FAIL  -  failed  */
end_comment

begin_macro
name|dnopn
argument_list|(
argument|ph
argument_list|,
argument|flds
argument_list|,
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ph
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|flds
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Devices
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|dcname
index|[
literal|20
index|]
decl_stmt|,
name|dnname
index|[
literal|20
index|]
decl_stmt|,
name|phone
index|[
name|MAXPH
operator|+
literal|2
index|]
decl_stmt|,
name|c
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SYSIII
name|struct
name|termio
name|ttbuf
decl_stmt|;
endif|#
directive|endif
name|int
name|dnf
decl_stmt|,
name|dcf
decl_stmt|;
name|int
name|nw
decl_stmt|,
name|lt
decl_stmt|,
name|pid
decl_stmt|,
name|status
decl_stmt|;
name|unsigned
name|timelim
decl_stmt|;
name|sprintf
argument_list|(
name|dnname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|dev
operator|->
name|D_calldev
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
block|{
name|logent
argument_list|(
name|dnname
argument_list|,
literal|"CAN'T OPEN"
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s Open timed out\n"
argument_list|,
name|dnname
argument_list|)
expr_stmt|;
return|return
operator|(
name|CF_NODEV
operator|)
return|;
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
name|getnextfd
argument_list|()
expr_stmt|;
name|alarm
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|dnf
operator|=
name|open
argument_list|(
name|dnname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|next_fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dnf
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EACCES
condition|)
block|{
name|logent
argument_list|(
name|dnname
argument_list|,
literal|"CAN'T OPEN"
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"DEVICE"
argument_list|,
literal|"NO"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CF_NODEV
operator|)
return|;
block|}
comment|/* rti!trt: avoid passing acu file descriptor to children */
name|fioclex
argument_list|(
name|dnf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|dcname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|phone
argument_list|,
literal|"%s%s"
argument_list|,
name|ph
argument_list|,
name|ACULAST
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"dc - %s, "
argument_list|,
name|dcname
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"acu - %s\n"
argument_list|,
name|dnname
argument_list|)
expr_stmt|;
name|pid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
block|{
name|logent
argument_list|(
literal|"DIALUP DN write"
argument_list|,
literal|"TIMEOUT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
condition|)
name|kill
argument_list|(
name|pid
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnf
condition|)
name|close
argument_list|(
name|dnf
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
name|timelim
operator|=
literal|5
operator|*
name|strlen
argument_list|(
name|phone
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|timelim
operator|<
literal|30
condition|?
literal|30
else|:
name|timelim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCFLUSH
name|ioctl
argument_list|(
name|dnf
argument_list|,
name|TIOCFLUSH
argument_list|,
name|STBNULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nw
operator|=
name|write
argument_list|(
name|dnf
argument_list|,
name|phone
argument_list|,
name|lt
operator|=
name|strlen
argument_list|(
name|phone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nw
operator|!=
name|lt
condition|)
block|{
name|logent
argument_list|(
literal|"DIALUP ACU write"
argument_list|,
literal|"FAILED"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"ACU write ok%s\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*  open line - will return on carrier */
comment|/* RT needs a sleep here because it returns immediately from open */
if|#
directive|if
name|RT
name|sleep
argument_list|(
literal|15
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|getnextfd
argument_list|()
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|dcf
operator|=
name|open
argument_list|(
name|dcname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|next_fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dcf
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EACCES
condition|)
name|logent
argument_list|(
name|dcname
argument_list|,
literal|"CAN'T OPEN"
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"dcf is %d\n"
argument_list|,
name|dcf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcf
operator|<
literal|0
condition|)
block|{
name|logent
argument_list|(
literal|"DIALUP LINE open"
argument_list|,
literal|"FAILED"
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|pid
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dnf
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
comment|/* brl-bmd.351 (Doug Kingston) says the next ioctl is unneeded . */
comment|/*	ioctl(dcf, TIOCHPCL, STBNULL);*/
while|while
condition|(
operator|(
name|nw
operator|=
name|wait
argument_list|(
operator|&
name|lt
argument_list|)
operator|)
operator|!=
name|pid
operator|&&
name|nw
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
ifdef|#
directive|ifdef
name|SYSIII
name|ioctl
argument_list|(
name|dcf
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|ttbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ttbuf
operator|.
name|c_cflag
operator|&
name|HUPCL
operator|)
condition|)
block|{
name|ttbuf
operator|.
name|c_cflag
operator||=
name|HUPCL
expr_stmt|;
name|ioctl
argument_list|(
name|dcf
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|ttbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fixline
argument_list|(
name|dcf
argument_list|,
name|dev
operator|->
name|D_speed
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Fork Stat %o\n"
argument_list|,
name|lt
argument_list|)
expr_stmt|;
if|if
condition|(
name|lt
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
name|dcf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnf
condition|)
name|close
argument_list|(
name|dnf
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
return|return
operator|(
name|dcf
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	dncls()		close dn type call unit  *  *	return codes:	None  */
end_comment

begin_expr_stmt
name|dncls
argument_list|(
name|fd
argument_list|)
specifier|register
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|fd
operator|>
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|devSel
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|DN11
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DF02
end_ifdef

begin_comment
comment|/***  *	df2opn(ph, flds, dev)	dial remote machine  *	char *ph;  *	char *flds[];  *	struct Devices *dev;  *  *	return codes:  *		file descriptor  -  succeeded  *		FAIL  -  failed  *  *	Modified 9/28/81 by Bill Shannon (DEC)  *	Changed to use DEC DF02 or DF03 ACU  */
end_comment

begin_macro
name|df2opn
argument_list|(
argument|ph
argument_list|,
argument|flds
argument_list|,
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ph
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|flds
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Devices
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|dcname
index|[
literal|20
index|]
decl_stmt|,
name|dnname
index|[
literal|20
index|]
decl_stmt|,
name|phone
index|[
name|MAXPH
operator|+
literal|2
index|]
decl_stmt|,
name|c
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SYSIII
name|struct
name|termio
name|ttbuf
decl_stmt|;
endif|#
directive|endif
name|int
name|dcf
decl_stmt|,
name|dnf
decl_stmt|;
name|int
name|nw
decl_stmt|,
name|lt
decl_stmt|,
name|pid
decl_stmt|,
name|st
decl_stmt|,
name|status
decl_stmt|;
name|unsigned
name|timelim
decl_stmt|;
name|sprintf
argument_list|(
name|dnname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|dev
operator|->
name|D_calldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
block|{
name|logent
argument_list|(
name|dnname
argument_list|,
literal|"CAN'T OPEN"
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s Open timed out\n"
argument_list|,
name|dnname
argument_list|)
expr_stmt|;
return|return
operator|(
name|CF_NODEV
operator|)
return|;
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
name|getnextfd
argument_list|()
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|alarm
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|dnf
operator|=
name|open
argument_list|(
name|dnname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|next_fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dnf
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EACCES
condition|)
block|{
name|logent
argument_list|(
name|dnname
argument_list|,
literal|"CAN'T OPEN"
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"DEVICE"
argument_list|,
literal|"NO"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CF_NODEV
operator|)
return|;
block|}
comment|/* rti!trt: avoid passing acu file descriptor to children */
name|fioclex
argument_list|(
name|dnf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|dcname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
name|fixline
argument_list|(
name|dnf
argument_list|,
name|dev
operator|->
name|D_speed
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|phone
argument_list|,
literal|"\02%s"
argument_list|,
name|ph
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"dc - %s, "
argument_list|,
name|dcname
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"acu - %s\n"
argument_list|,
name|dnname
argument_list|)
expr_stmt|;
name|pid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
block|{
name|logent
argument_list|(
literal|"DIALUP DN write"
argument_list|,
literal|"TIMEOUT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
condition|)
name|kill
argument_list|(
name|pid
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnf
condition|)
name|close
argument_list|(
name|dnf
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
name|timelim
operator|=
literal|5
operator|*
name|strlen
argument_list|(
name|phone
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|timelim
operator|<
literal|30
condition|?
literal|30
else|:
name|timelim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCFLUSH
name|ioctl
argument_list|(
name|dnf
argument_list|,
name|TIOCFLUSH
argument_list|,
name|STBNULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|write
argument_list|(
name|dnf
argument_list|,
literal|"\01"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|nw
operator|=
name|write
argument_list|(
name|dnf
argument_list|,
name|phone
argument_list|,
name|lt
operator|=
name|strlen
argument_list|(
name|phone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nw
operator|!=
name|lt
condition|)
block|{
name|logent
argument_list|(
literal|"DIALUP ACU write"
argument_list|,
literal|"FAILED"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"ACU write ok%s\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*  open line - will return on carrier */
comment|/* RT needs a sleep here because it returns immediately from open */
if|#
directive|if
name|RT
name|sleep
argument_list|(
literal|15
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|read
argument_list|(
name|dnf
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
operator|||
name|c
operator|!=
literal|'A'
condition|)
name|dcf
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|dcf
operator|=
literal|0
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"dcf is %d\n"
argument_list|,
name|dcf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcf
operator|<
literal|0
condition|)
block|{
name|logent
argument_list|(
literal|"DIALUP LINE open"
argument_list|,
literal|"FAILED"
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|pid
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dnf
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|dcf
operator|=
name|dnf
expr_stmt|;
name|dnf
operator|=
literal|0
expr_stmt|;
comment|/* brl-bmd.351 (Doug Kingston) says the next ioctl is unneeded . */
comment|/*	ioctl(dcf, TIOCHPCL, STBNULL);*/
while|while
condition|(
operator|(
name|nw
operator|=
name|wait
argument_list|(
operator|&
name|lt
argument_list|)
operator|)
operator|!=
name|pid
operator|&&
name|nw
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
ifdef|#
directive|ifdef
name|SYSIII
name|ioctl
argument_list|(
name|dcf
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|ttbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ttbuf
operator|.
name|c_cflag
operator|&
name|HUPCL
operator|)
condition|)
block|{
name|ttbuf
operator|.
name|c_cflag
operator||=
name|HUPCL
expr_stmt|;
name|ioctl
argument_list|(
name|dcf
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|ttbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fixline
argument_list|(
name|dcf
argument_list|,
name|dev
operator|->
name|D_speed
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Fork Stat %o\n"
argument_list|,
name|lt
argument_list|)
expr_stmt|;
if|if
condition|(
name|lt
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
name|dcf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnf
condition|)
name|close
argument_list|(
name|dnf
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
return|return
operator|(
name|dcf
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * df2cls()	close the DF02/DF03 call unit  *  *	return codes: none  */
end_comment

begin_expr_stmt
name|df2cls
argument_list|(
name|fd
argument_list|)
specifier|register
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|fd
operator|>
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|devSel
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|DF02
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAYES
end_ifdef

begin_comment
comment|/***  *	hysopn(telno, flds, dev) connect to hayes smartmodem  *	char *flds[], *dev[];  *  *	return codes:  *>0  -  file number  -  ok  *		CF_DIAL,CF_DEVICE  -  failed  */
end_comment

begin_comment
comment|/*  * Define HAYSTONE if you have touch tone dialing.  */
end_comment

begin_comment
comment|/*#define HAYSTONE	*/
end_comment

begin_macro
name|hysopn
argument_list|(
argument|telno
argument_list|,
argument|flds
argument_list|,
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|telno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|flds
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Devices
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|dh
init|=
operator|-
literal|1
decl_stmt|;
extern|extern errno;
name|char
name|dcname
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|dcname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"dc - %s\n"
argument_list|,
name|dcname
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
literal|1
argument_list|,
literal|"timeout hayes open %s\n"
argument_list|,
name|dcname
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"hayes open"
argument_list|,
literal|"TIMEOUT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|dh
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
return|return
operator|(
name|CF_DIAL
operator|)
return|;
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
name|getnextfd
argument_list|()
expr_stmt|;
name|alarm
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|dh
operator|=
name|open
argument_list|(
name|dcname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* read/write */
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* modem is open */
name|next_fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dh
operator|>=
literal|0
condition|)
block|{
name|fixline
argument_list|(
name|dh
argument_list|,
name|dev
operator|->
name|D_speed
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAYSTONE
name|write
argument_list|(
name|dh
argument_list|,
literal|"\rATDT"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
else|#
directive|else
name|write
argument_list|(
name|dh
argument_list|,
literal|"\rATDP"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|write
argument_list|(
name|dh
argument_list|,
name|telno
argument_list|,
name|strlen
argument_list|(
name|telno
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|dh
argument_list|,
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|expect
argument_list|(
literal|"CONNECT"
argument_list|,
name|dh
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|logent
argument_list|(
literal|"HSM no carrier"
argument_list|,
literal|"FAILED"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|devSel
argument_list|,
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
name|hyscls
argument_list|(
name|dh
argument_list|)
expr_stmt|;
return|return
operator|(
name|CF_DIAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|dh
operator|<
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"hayes failed\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
block|}
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"hayes ok\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|dh
operator|)
return|;
block|}
end_block

begin_macro
name|hyscls
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|dcname
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|sgttyb
name|hup
decl_stmt|,
name|sav
decl_stmt|;
if|if
condition|(
name|fd
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|dcname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|devSel
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Hanging up fd = %d\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/*  * code to drop DTR -- change to 0 baud then back to default.  */
name|gtty
argument_list|(
name|fd
argument_list|,
operator|&
name|hup
argument_list|)
expr_stmt|;
name|gtty
argument_list|(
name|fd
argument_list|,
operator|&
name|sav
argument_list|)
expr_stmt|;
name|hup
operator|.
name|sg_ispeed
operator|=
name|B0
expr_stmt|;
name|hup
operator|.
name|sg_ospeed
operator|=
name|B0
expr_stmt|;
name|stty
argument_list|(
name|fd
argument_list|,
operator|&
name|hup
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|stty
argument_list|(
name|fd
argument_list|,
operator|&
name|sav
argument_list|)
expr_stmt|;
comment|/*  * now raise DTR -- close the device& open it again.  */
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|dcname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/*  * Since we have a getty sleeping on this line, when it wakes up it sends  * all kinds of garbage to the modem.  Unfortunatly, the modem likes to  * execute the previous command when it sees the garbage.  The previous  * command was to dial the phone, so let's make the last command reset  * the modem.  */
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
literal|"\rATZ\r"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|devSel
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|HAYES
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAYESQ
end_ifdef

begin_comment
comment|/*  * New dialout routine to work with Hayes' SMART MODEM  * 13-JUL-82, Mike Mitchell  * Modified 23-MAR-83 to work with Tom Truscott's (rti!trt)  * version of UUCP	(ncsu!mcm)  *  * The modem should be set to NOT send any result codes to  * the system (switch 3 up, 4 down). This end will figure out  * what is wrong.  *  * I had lots of problems with the modem sending  * result codes since I am using the same modem for both incomming and  * outgoing calls.  I'd occasionally miss the result code (getty would  * grab it), and the connect would fail.  Worse yet, the getty would  * think the result code was a user name, and send garbage to it while  * it was in the command state.  I turned off ALL result codes, and hope  * for the best.  99% of the time the modem is in the correct state.  * Occassionally it doesn't connect, or the phone was busy, etc., and  * uucico sits there trying to log in.  It eventually times out, calling  * clsacu() in the process, so it resets itself for the next attempt.  */
end_comment

begin_comment
comment|/*  * Define HAYSTONE if touch-tone dialing is to be used.  If it is not defined,  * Pulse dialing is assumed.  */
end_comment

begin_comment
comment|/*#define HAYSTONE*/
end_comment

begin_macro
name|hysqopn
argument_list|(
argument|telno
argument_list|,
argument|flds
argument_list|,
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|telno
decl_stmt|,
modifier|*
name|flds
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Devices
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|dcname
index|[
literal|20
index|]
decl_stmt|,
name|phone
index|[
name|MAXPH
operator|+
literal|10
index|]
decl_stmt|,
name|c
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SYSIII
name|struct
name|termio
name|ttbuf
decl_stmt|;
endif|#
directive|endif
name|int
name|status
decl_stmt|,
name|dnf
decl_stmt|;
name|unsigned
name|timelim
decl_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|dcname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
name|getnextfd
argument_list|()
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
block|{
name|delock
argument_list|(
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"DEVICE"
argument_list|,
literal|"NO"
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Open timed out %s"
argument_list|,
name|dcname
argument_list|)
expr_stmt|;
return|return
operator|(
name|CF_NODEV
operator|)
return|;
block|}
name|alarm
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dnf
operator|=
name|open
argument_list|(
name|dcname
argument_list|,
literal|2
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|delock
argument_list|(
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"DEVICE"
argument_list|,
literal|"NO"
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Can't open %s"
argument_list|,
name|dcname
argument_list|)
expr_stmt|;
return|return
operator|(
name|CF_NODEV
operator|)
return|;
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|next_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|fixline
argument_list|(
name|dnf
argument_list|,
name|dev
operator|->
name|D_speed
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Hayes port - %s, "
argument_list|,
name|dcname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAYSTONE
name|sprintf
argument_list|(
name|phone
argument_list|,
literal|"\rATDT%s\r"
argument_list|,
name|telno
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|phone
argument_list|,
literal|"\rATDP%s\r"
argument_list|,
name|telno
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|write
argument_list|(
name|dnf
argument_list|,
name|phone
argument_list|,
name|strlen
argument_list|(
name|phone
argument_list|)
argument_list|)
expr_stmt|;
comment|/* calculate delay time for the other system to answer the phone.  * Default is 15 seconds, add 2 seconds for each comma in the phone  * number.  */
name|timelim
operator|=
literal|150
expr_stmt|;
while|while
condition|(
operator|*
name|telno
condition|)
block|{
name|c
operator|=
operator|*
name|telno
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
name|timelim
operator|+=
literal|20
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|HAYSTONE
name|timelim
operator|+=
literal|2
expr_stmt|;
comment|/* .2 seconds per tone */
block|}
else|#
directive|else
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
name|timelim
operator|+=
literal|10
expr_stmt|;
comment|/* .1 second per digit */
elseif|else
if|if
condition|(
name|c
operator|>
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|timelim
operator|+=
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|alarm
argument_list|(
name|timelim
operator|/
literal|10
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|read
argument_list|(
name|dnf
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_if

begin_return
return|return
operator|(
name|dnf
operator|)
return|;
end_return

begin_expr_stmt
unit|}  hysqcls
operator|(
name|fd
operator|)
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|dcname
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|sgttyb
name|hup
decl_stmt|,
name|sav
decl_stmt|;
if|if
condition|(
name|fd
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|dcname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|devSel
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Hanging up fd = %d\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/*  * code to drop DTR -- change to 0 baud then back to default.  */
name|gtty
argument_list|(
name|fd
argument_list|,
operator|&
name|hup
argument_list|)
expr_stmt|;
name|gtty
argument_list|(
name|fd
argument_list|,
operator|&
name|sav
argument_list|)
expr_stmt|;
name|hup
operator|.
name|sg_ispeed
operator|=
name|B0
expr_stmt|;
name|hup
operator|.
name|sg_ospeed
operator|=
name|B0
expr_stmt|;
name|stty
argument_list|(
name|fd
argument_list|,
operator|&
name|hup
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|stty
argument_list|(
name|fd
argument_list|,
operator|&
name|sav
argument_list|)
expr_stmt|;
comment|/*  * now raise DTR -- close the device& open it again.  */
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|dcname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/*  * Since we have a getty sleeping on this line, when it wakes up it sends  * all kinds of garbage to the modem.  Unfortunatly, the modem likes to  * execute the previous command when it sees the garbage.  The previous  * command was to dial the phone, so let's make the last command reset  * the modem.  */
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
literal|"\rATZ\r"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|devSel
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|HAYESQ
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VENTEL
end_ifdef

begin_macro
name|ventopn
argument_list|(
argument|telno
argument_list|,
argument|flds
argument_list|,
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|flds
index|[]
decl_stmt|,
modifier|*
name|telno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Devices
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|dh
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ok
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|dcname
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|dcname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
literal|1
argument_list|,
literal|"timeout ventel open\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"ventel open"
argument_list|,
literal|"TIMEOUT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|dh
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
return|return
operator|(
name|CF_NODEV
operator|)
return|;
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
name|getnextfd
argument_list|()
expr_stmt|;
name|alarm
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|dh
operator|=
name|open
argument_list|(
name|dcname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|next_fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dh
operator|<
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s\n"
argument_list|,
name|errno
operator|==
literal|4
condition|?
literal|"no carrier"
else|:
literal|"can't open modem"
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|==
literal|4
condition|?
name|CF_DIAL
else|:
name|CF_NODEV
operator|)
return|;
block|}
comment|/* modem is open */
name|fixline
argument_list|(
name|dh
argument_list|,
name|dev
operator|->
name|D_speed
argument_list|)
expr_stmt|;
comment|/* translate - to % and = to& for VenTel */
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"calling %s -> "
argument_list|,
name|telno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|telno
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|telno
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'-'
case|:
comment|/* delay */
name|telno
index|[
name|i
index|]
operator|=
literal|'%'
expr_stmt|;
break|break;
case|case
literal|'='
case|:
comment|/* await dial tone */
name|telno
index|[
name|i
index|]
operator|=
literal|'&'
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|telno
index|[
name|i
index|]
operator|=
literal|'%'
expr_stmt|;
break|break;
block|}
block|}
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s\n"
argument_list|,
name|telno
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
operator|++
name|i
control|)
block|{
comment|/* make up to 5 tries */
name|slowrite
argument_list|(
name|dh
argument_list|,
literal|"\r\r"
argument_list|)
expr_stmt|;
comment|/* awake, thou lowly VenTel! */
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"wanted %s "
argument_list|,
literal|"$"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|expect
argument_list|(
literal|"$"
argument_list|,
name|dh
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"got %s\n"
argument_list|,
name|ok
condition|?
literal|"?"
else|:
literal|"that"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
continue|continue;
name|slowrite
argument_list|(
name|dh
argument_list|,
literal|"K"
argument_list|)
expr_stmt|;
comment|/* "K" (enter number) command */
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"wanted %s "
argument_list|,
literal|"DIAL: "
argument_list|)
expr_stmt|;
name|ok
operator|=
name|expect
argument_list|(
literal|"DIAL: "
argument_list|,
name|dh
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"got %s\n"
argument_list|,
name|ok
condition|?
literal|"?"
else|:
literal|"that"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
block|{
name|slowrite
argument_list|(
name|dh
argument_list|,
name|telno
argument_list|)
expr_stmt|;
comment|/* send telno, send \r */
name|slowrite
argument_list|(
name|dh
argument_list|,
literal|"\r"
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"wanted %s "
argument_list|,
literal|"ONLINE"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|expect
argument_list|(
literal|"ONLINE!"
argument_list|,
name|dh
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"got %s\n"
argument_list|,
name|ok
condition|?
literal|"?"
else|:
literal|"that"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dh
operator|>
literal|2
condition|)
name|close
argument_list|(
name|dh
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"venDial failed\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|CF_DIAL
operator|)
return|;
block|}
else|else
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"venDial ok\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|dh
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * uucpdelay:  delay execution for numerator/denominator seconds.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INTERVALTIMER
end_ifdef

begin_define
define|#
directive|define
name|uucpdelay
parameter_list|(
name|num
parameter_list|,
name|denom
parameter_list|)
value|intervaldelay(1000000*num/denom)
end_define

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_expr_stmt
name|catch
name|alarm
name|sig
name|SIGALRM
expr|struct
name|itimerval
name|itimerval
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|itimerval
operator|.
name|itimer_reload
operator|=
name|itimerval
operator|.
name|rtime
operator|.
name|itimer_interval
operator|=
name|itimerval
operator|.
name|rtime
operator|.
name|itimer_value
operator|=
name|settimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimerval
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pause
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
name|alarm
name|comes
name|in
name|turn
name|off
name|timer
operator|.
endif|#
directive|endif
endif|INTERVALTIMER
ifdef|#
directive|ifdef
name|FASTTIMER
define|#
directive|define
name|uucpdelay
parameter_list|(
name|num
parameter_list|,
name|denom
parameter_list|)
value|nap(60*num/denom)
comment|/*	Sleep in increments of 60ths of second.	*/
name|nap
parameter_list|(
name|time
parameter_list|)
specifier|register
name|int
name|time
decl_stmt|;
block|{
specifier|static
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|fd
operator|==
literal|0
condition|)
name|fd
operator|=
name|open
argument_list|(
name|FASTTIMER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|time
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|FASTTIMER
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FTIME
end_ifdef

begin_define
define|#
directive|define
name|uucpdelay
parameter_list|(
name|num
parameter_list|,
name|denom
parameter_list|)
value|ftimedelay(1000*num/denom)
end_define

begin_include
include|#
directive|include
file|<sys/timeb.h>
end_include

begin_macro
name|ftimedelay
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|struct
name|timeb
name|loctime
decl_stmt|;
name|ftime
argument_list|(
operator|&
name|loctime
argument_list|)
expr_stmt|;
block|{
specifier|register
name|i
operator|=
name|loctime
operator|.
name|millitm
expr_stmt|;
while|while
condition|(
name|abs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|loctime
operator|.
name|millitm
operator|-
name|i
argument_list|)
argument_list|)
operator|<
name|n
condition|)
name|ftime
argument_list|(
operator|&
name|loctime
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|FTIME
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BUSYLOOP
end_ifdef

begin_define
define|#
directive|define
name|uucpdelay
parameter_list|(
name|num
parameter_list|,
name|denom
parameter_list|)
value|busyloop(CPUSPEED*num/denom)
end_define

begin_define
define|#
directive|define
name|CPUSPEED
value|1000000
end_define

begin_comment
comment|/* VAX 780 is 1MIPS */
end_comment

begin_define
define|#
directive|define
name|DELAY
parameter_list|(
name|n
parameter_list|)
value|{ register long N = (n); while (--N> 0); }
end_define

begin_macro
name|busyloop
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
name|DELAY
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|BUSYLOOP
end_endif

begin_expr_stmt
name|slowrite
argument_list|(
name|fd
argument_list|,
name|str
argument_list|)
specifier|register
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|DEBUG
argument_list|(
literal|6
argument_list|,
literal|"slowrite "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
name|DEBUG
argument_list|(
literal|6
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|str
argument_list|)
expr_stmt|;
name|uucpdelay
argument_list|(
literal|1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* delay 1/10 second */
name|write
argument_list|(
name|fd
argument_list|,
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
name|DEBUG
argument_list|(
literal|6
argument_list|,
literal|"\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ventcls
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fd
operator|>
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|devSel
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|VENTEL
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VADIC
end_ifdef

begin_comment
comment|/*  *	vadopn: establish dial-out connection through a Racal-Vadic 3450.  *	Returns descriptor open to tty for reading and writing.  *	Negative values (-1...-7) denote errors in connmsg.  *	Be sure to disconnect tty when done, via HUPCL or stty 0.  */
end_comment

begin_macro
name|vadopn
argument_list|(
argument|telno
argument_list|,
argument|flds
argument_list|,
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|telno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|flds
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Devices
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|dh
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ok
decl_stmt|,
name|er
init|=
literal|0
decl_stmt|,
name|delay
decl_stmt|;
extern|extern errno;
name|char
name|dcname
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|dcname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
literal|1
argument_list|,
literal|"timeout vadic open\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"vadic open"
argument_list|,
literal|"TIMEOUT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|dh
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
return|return
operator|(
name|CF_NODEV
operator|)
return|;
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
name|getnextfd
argument_list|()
expr_stmt|;
name|alarm
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|dh
operator|=
name|open
argument_list|(
name|dcname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* modem is open */
name|next_fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dh
operator|<
literal|0
condition|)
block|{
name|delock
argument_list|(
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
return|return
operator|(
name|CF_NODEV
operator|)
return|;
block|}
name|fixline
argument_list|(
name|dh
argument_list|,
name|dev
operator|->
name|D_speed
argument_list|)
expr_stmt|;
comment|/* translate - to K for Vadic */
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"calling %s -> "
argument_list|,
name|telno
argument_list|)
expr_stmt|;
name|delay
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|telno
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|telno
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'='
case|:
comment|/* await dial tone */
case|case
literal|'-'
case|:
comment|/* delay */
case|case
literal|'<'
case|:
name|telno
index|[
name|i
index|]
operator|=
literal|'K'
expr_stmt|;
name|delay
operator|+=
literal|5
expr_stmt|;
break|break;
block|}
block|}
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s\n"
argument_list|,
name|telno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
operator|++
name|i
control|)
block|{
comment|/* make 5 tries */
comment|/* wake up Vadic */
name|sendthem
argument_list|(
literal|"\005\\d"
argument_list|,
name|dh
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"wanted %s "
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|expect
argument_list|(
literal|"*"
argument_list|,
name|dh
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"got %s\n"
argument_list|,
name|ok
condition|?
literal|"?"
else|:
literal|"that"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
continue|continue;
name|sendthem
argument_list|(
literal|"D\\d"
argument_list|,
name|dh
argument_list|)
expr_stmt|;
comment|/* "D" (enter number) command */
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"wanted %s "
argument_list|,
literal|"NUMBER?\\r\\n"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|expect
argument_list|(
literal|"NUMBER?\r\n"
argument_list|,
name|dh
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"got %s\n"
argument_list|,
name|ok
condition|?
literal|"?"
else|:
literal|"that"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
continue|continue;
comment|/* send telno, send \r */
name|sendthem
argument_list|(
name|telno
argument_list|,
name|dh
argument_list|)
expr_stmt|;
name|ok
operator|=
name|expect
argument_list|(
name|telno
argument_list|,
name|dh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
name|ok
operator|=
name|expect
argument_list|(
literal|"\r\n"
argument_list|,
name|dh
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"got %s\n"
argument_list|,
name|ok
condition|?
literal|"?"
else|:
literal|"that"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
continue|continue;
name|sendthem
argument_list|(
literal|""
argument_list|,
name|dh
argument_list|)
expr_stmt|;
comment|/* confirm number */
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"wanted %s "
argument_list|,
literal|"DIALING: "
argument_list|)
expr_stmt|;
name|ok
operator|=
name|expect
argument_list|(
literal|"DIALING: "
argument_list|,
name|dh
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"got %s\n"
argument_list|,
name|ok
condition|?
literal|"?"
else|:
literal|"that"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
block|{
name|sleep
argument_list|(
literal|10
operator|+
name|delay
argument_list|)
expr_stmt|;
comment|/* give vadic some time */
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"wanted ON LINE\\r\\n "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ok
operator|=
name|expect
argument_list|(
literal|"ON LINE\r\n"
argument_list|,
name|dh
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"got %s\n"
argument_list|,
name|ok
condition|?
literal|"?"
else|:
literal|"that"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
block|{
name|sendthem
argument_list|(
literal|"I\\d"
argument_list|,
name|dh
argument_list|)
expr_stmt|;
comment|/* back to idle */
if|if
condition|(
name|dh
operator|>
literal|2
condition|)
name|close
argument_list|(
name|dh
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"vadDial failed\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
return|return
operator|(
name|CF_DIAL
operator|)
return|;
block|}
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"vadic ok\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|dh
operator|)
return|;
block|}
end_block

begin_macro
name|vadcls
argument_list|(
argument|fd
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|fd
operator|>
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|delock
argument_list|(
name|devSel
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|VADIC
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RVMACS
end_ifdef

begin_comment
comment|/*  * Racal-Vadic 'RV820' MACS system with 831 adaptor.  * A typical 300 baud L-devices entry is  *	ACU /dev/tty10 /dev/tty11,48 300 rvmacs  * where tty10 is the communication line (D_Line),  * tty11 is the dialer line (D_calldev),  * the '4' is the dialer address + modem type (viz. dialer 0, Bell 103),  * and the '8' is the communication port (they are 1-indexed).  * BUGS:  * Only tested with one dialer, one modem  * uses common speed for dialer and communication line.  * UNTESTED  */
end_comment

begin_define
define|#
directive|define
name|STX
value|02
end_define

begin_comment
comment|/* Access Adaptor */
end_comment

begin_define
define|#
directive|define
name|ETX
value|03
end_define

begin_comment
comment|/* Transfer to Dialer */
end_comment

begin_define
define|#
directive|define
name|SI
value|017
end_define

begin_comment
comment|/* Buffer Empty (end of phone number) */
end_comment

begin_define
define|#
directive|define
name|SOH
value|01
end_define

begin_comment
comment|/* Abort */
end_comment

begin_macro
name|rvmacsopn
argument_list|(
argument|ph
argument_list|,
argument|flds
argument_list|,
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ph
decl_stmt|,
modifier|*
name|flds
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Devices
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|va
decl_stmt|,
name|i
decl_stmt|,
name|child
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|,
name|acu
index|[
literal|20
index|]
decl_stmt|,
name|com
index|[
literal|20
index|]
decl_stmt|;
name|child
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|dev
operator|->
name|D_calldev
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
literal|2
argument_list|,
literal|"No dialer/modem specification\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|failret
goto|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
block|{
name|logent
argument_list|(
literal|"rvmacsopn"
argument_list|,
literal|"TIMEOUT"
argument_list|)
expr_stmt|;
name|i
operator|=
name|CF_DIAL
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"STARTING CALL\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|acu
argument_list|,
literal|"/dev/%s"
argument_list|,
name|dev
operator|->
name|D_calldev
argument_list|)
expr_stmt|;
name|getnextfd
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|30
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|va
operator|=
name|open
argument_list|(
name|acu
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|logent
argument_list|(
name|acu
argument_list|,
literal|"CAN'T OPEN"
argument_list|)
expr_stmt|;
name|i
operator|=
name|CF_NODEV
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|fixline
argument_list|(
name|va
argument_list|,
name|dev
operator|->
name|D_speed
argument_list|)
expr_stmt|;
name|p_chwrite
argument_list|(
name|va
argument_list|,
name|STX
argument_list|)
expr_stmt|;
comment|/* access adaptor */
name|i
operator|=
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|7
condition|)
block|{
name|logent
argument_list|(
name|p
operator|-
literal|1
argument_list|,
literal|"Bad dialer address/modem type\n"
argument_list|)
expr_stmt|;
goto|goto
name|failret
goto|;
block|}
name|p_chwrite
argument_list|(
name|va
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Send Dialer Address Digit */
name|i
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>
literal|14
condition|)
block|{
name|logent
argument_list|(
name|p
operator|-
literal|1
argument_list|,
literal|"Bad modem address\n"
argument_list|)
expr_stmt|;
goto|goto
name|failret
goto|;
block|}
name|p_chwrite
argument_list|(
name|va
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Send Modem Address Digit */
name|write
argument_list|(
name|va
argument_list|,
name|ph
argument_list|,
name|strlen
argument_list|(
name|ph
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send Phone Number */
name|p_chwrite
argument_list|(
name|va
argument_list|,
name|SI
argument_list|)
expr_stmt|;
comment|/* Send Buffer Empty */
name|p_chwrite
argument_list|(
name|va
argument_list|,
name|ETX
argument_list|)
expr_stmt|;
comment|/* Initiate Call */
name|sprintf
argument_list|(
name|com
argument_list|,
literal|"/dev/%s"
argument_list|,
name|dev
operator|->
name|D_line
argument_list|)
expr_stmt|;
comment|/* create child to open comm line */
if|if
condition|(
operator|(
name|child
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|open
argument_list|(
name|com
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read
argument_list|(
name|va
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|logent
argument_list|(
literal|"ACU READ"
argument_list|,
literal|"FAILED"
argument_list|)
expr_stmt|;
goto|goto
name|failret
goto|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'A'
case|:
comment|/* Fine! */
break|break;
case|case
literal|'B'
case|:
name|DEBUG
argument_list|(
literal|2
argument_list|,
literal|"CALL ABORTED\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|failret
goto|;
case|case
literal|'D'
case|:
name|DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Dialer format error\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|failret
goto|;
case|case
literal|'E'
case|:
name|DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Dialer parity error\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|failret
goto|;
case|case
literal|'F'
case|:
name|DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Phone number too long\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|failret
goto|;
case|case
literal|'G'
case|:
name|DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Busy signal\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|failret
goto|;
default|default:
name|DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Unknown MACS return code '%c'\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|failret
goto|;
block|}
comment|/* 	 * open line - will return on carrier 	 */
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|com
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EIO
condition|)
name|logent
argument_list|(
literal|"carrier"
argument_list|,
literal|"LOST"
argument_list|)
expr_stmt|;
else|else
name|logent
argument_list|(
literal|"dialup open"
argument_list|,
literal|"FAILED"
argument_list|)
expr_stmt|;
goto|goto
name|failret
goto|;
block|}
name|fixline
argument_list|(
name|i
argument_list|,
name|dev
operator|->
name|D_speed
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
name|failret
label|:
name|i
operator|=
name|CF_DIAL
expr_stmt|;
name|ret
label|:
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|!=
operator|-
literal|1
condition|)
name|kill
argument_list|(
name|child
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|va
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|rvmacscls
argument_list|(
name|fd
argument_list|)
specifier|register
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|DEBUG
argument_list|(
literal|2
argument_list|,
literal|"MACS close %d\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|p_chwrite
argument_list|(
name|fd
argument_list|,
name|SOH
argument_list|)
expr_stmt|;
comment|/*	ioctl(fd, TIOCCDTR, NULL);*/
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

