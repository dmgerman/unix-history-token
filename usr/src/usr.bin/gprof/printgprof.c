begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)printgprof.c	1.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|"dprof.h"
end_include

begin_macro
name|printdprof
argument_list|()
end_macro

begin_block
block|{
name|nltype
modifier|*
modifier|*
name|timesortnlp
decl_stmt|;
name|int
name|index
decl_stmt|;
name|nltype
modifier|*
name|parentp
decl_stmt|;
name|nltype
modifier|*
name|childp
decl_stmt|;
comment|/* 	 *	Now, sort by time + childtime. 	 *	include the cycle headers hiding out past nl[nname]. 	 */
name|timesortnlp
operator|=
operator|(
name|nltype
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|nname
operator|+
literal|1
operator|+
name|cyclemax
argument_list|,
sizeof|sizeof
argument_list|(
name|nltype
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|timesortnlp
operator|==
operator|(
name|nltype
operator|*
operator|*
operator|)
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[doarcs] ran out of memory for sorting\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|nname
operator|+
literal|1
operator|+
name|cyclemax
condition|;
name|index
operator|++
control|)
block|{
name|timesortnlp
index|[
name|index
index|]
operator|=
operator|&
name|nl
index|[
name|index
index|]
expr_stmt|;
block|}
name|qsort
argument_list|(
name|timesortnlp
argument_list|,
name|nname
operator|+
literal|1
operator|+
name|cyclemax
argument_list|,
sizeof|sizeof
argument_list|(
name|nltype
operator|*
argument_list|)
argument_list|,
name|totalcmp
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|nname
operator|+
literal|1
operator|+
name|cyclemax
condition|;
name|index
operator|++
control|)
block|{
name|timesortnlp
index|[
name|index
index|]
operator|->
name|index
operator|=
name|index
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 	 *	Now, print out the structured profiling list 	 */
name|actime
operator|=
literal|0.0
expr_stmt|;
name|printf
argument_list|(
literal|"\f"
argument_list|)
expr_stmt|;
name|putprofheader
argument_list|()
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|nname
operator|+
literal|1
operator|+
name|cyclemax
condition|;
name|index
operator|++
control|)
block|{
name|parentp
operator|=
name|timesortnlp
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|zflg
operator|==
literal|0
operator|&&
name|parentp
operator|->
name|ncall
operator|==
literal|0
operator|&&
name|parentp
operator|->
name|selfcalls
operator|==
literal|0
operator|&&
name|parentp
operator|->
name|time
operator|==
literal|0
operator|&&
name|parentp
operator|->
name|childtime
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|parentp
operator|->
name|name
operator|==
literal|0
operator|&&
name|parentp
operator|->
name|cycleno
operator|!=
literal|0
condition|)
block|{
comment|/* 		 *	cycle header 		 */
name|putprofline
argument_list|(
name|parentp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|childp
operator|=
name|parentp
operator|->
name|cnext
init|;
name|childp
condition|;
name|childp
operator|=
name|childp
operator|->
name|cnext
control|)
block|{
name|putprofline
argument_list|(
name|childp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printparents
argument_list|(
name|parentp
argument_list|)
expr_stmt|;
name|putprofline
argument_list|(
name|parentp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printchildren
argument_list|(
name|parentp
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|actime
operator|=
literal|0.0
expr_stmt|;
block|}
end_block

begin_macro
name|printparents
argument_list|(
argument|childp
argument_list|)
end_macro

begin_decl_stmt
name|nltype
modifier|*
name|childp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|nltype
modifier|*
name|parentp
decl_stmt|;
name|arctype
modifier|*
name|arcp
decl_stmt|;
name|nltype
modifier|*
name|cycleheadp
decl_stmt|;
if|if
condition|(
name|childp
operator|->
name|cyclehead
operator|!=
literal|0
condition|)
block|{
name|cycleheadp
operator|=
name|childp
operator|->
name|cyclehead
expr_stmt|;
block|}
else|else
block|{
name|cycleheadp
operator|=
name|childp
expr_stmt|;
block|}
if|if
condition|(
name|childp
operator|->
name|parents
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\t%5.5s %7.7s %7.7s %7.7s %7.7s %7.7s<spontaneous>\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
name|sortparents
argument_list|(
name|childp
argument_list|)
expr_stmt|;
for|for
control|(
name|arcp
operator|=
name|childp
operator|->
name|parents
init|;
name|arcp
condition|;
name|arcp
operator|=
name|arcp
operator|->
name|arc_parentlist
control|)
block|{
name|parentp
operator|=
name|arcp
operator|->
name|arc_parentp
expr_stmt|;
if|if
condition|(
name|childp
operator|==
name|parentp
operator|||
operator|(
name|childp
operator|->
name|cycleno
operator|!=
literal|0
operator|&&
name|parentp
operator|->
name|cycleno
operator|==
name|childp
operator|->
name|cycleno
operator|)
condition|)
block|{
comment|/* 		 *	selfcall or call amoung siblings 		 */
name|printf
argument_list|(
literal|"\t%5.5s %7.7s %7.7s %7.7s %7d %7.7s      "
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|arcp
operator|->
name|arc_count
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|parentp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 *	regular parent of child 		 */
name|printf
argument_list|(
literal|"\t%5.5s %7.7s %7.1f %7.1f %7d/%-7d      "
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|arcp
operator|->
name|arc_time
operator|/
name|HZ
argument_list|,
name|arcp
operator|->
name|arc_childtime
operator|/
name|HZ
argument_list|,
name|arcp
operator|->
name|arc_count
argument_list|,
name|cycleheadp
operator|->
name|ncall
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|parentp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|printchildren
argument_list|(
argument|parentp
argument_list|)
end_macro

begin_decl_stmt
name|nltype
modifier|*
name|parentp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|nltype
modifier|*
name|childp
decl_stmt|;
name|arctype
modifier|*
name|arcp
decl_stmt|;
name|sortchildren
argument_list|(
name|parentp
argument_list|)
expr_stmt|;
name|arcp
operator|=
name|parentp
operator|->
name|children
expr_stmt|;
for|for
control|(
name|arcp
operator|=
name|parentp
operator|->
name|children
init|;
name|arcp
condition|;
name|arcp
operator|=
name|arcp
operator|->
name|arc_childlist
control|)
block|{
name|childp
operator|=
name|arcp
operator|->
name|arc_childp
expr_stmt|;
if|if
condition|(
name|childp
operator|==
name|parentp
operator|||
operator|(
name|childp
operator|->
name|cycleno
operator|!=
literal|0
operator|&&
name|childp
operator|->
name|cycleno
operator|==
name|parentp
operator|->
name|cycleno
operator|)
condition|)
block|{
comment|/* 		 *	self call or call to sibling 		 */
name|printf
argument_list|(
literal|"\t%5.5s %7.7s %7.7s %7.7s %7d %7.7s      "
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|arcp
operator|->
name|arc_count
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|childp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 *	regular child of parent 		 */
name|printf
argument_list|(
literal|"\t%5.5s %7.7s %7.1f %7.1f %7d/%-7d      "
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|arcp
operator|->
name|arc_time
operator|/
name|HZ
argument_list|,
name|arcp
operator|->
name|arc_childtime
operator|/
name|HZ
argument_list|,
name|arcp
operator|->
name|arc_count
argument_list|,
name|childp
operator|->
name|cyclehead
operator|->
name|ncall
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|childp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|printname
argument_list|(
argument|selfp
argument_list|)
end_macro

begin_decl_stmt
name|nltype
modifier|*
name|selfp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|selfp
operator|->
name|name
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s\t"
argument_list|,
name|selfp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|selfp
operator|->
name|index
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"[%d] "
argument_list|,
name|selfp
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DFNDEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"{%d} "
argument_list|,
name|selfp
operator|->
name|toporder
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
block|}
if|if
condition|(
name|selfp
operator|->
name|cycleno
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"<cycle %d>"
argument_list|,
name|selfp
operator|->
name|cycleno
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|sortchildren
argument_list|(
argument|parentp
argument_list|)
end_macro

begin_decl_stmt
name|nltype
modifier|*
name|parentp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|arctype
modifier|*
name|arcp
decl_stmt|;
name|arctype
modifier|*
name|detachedp
decl_stmt|;
name|arctype
name|sorted
decl_stmt|;
name|arctype
modifier|*
name|prevp
decl_stmt|;
comment|/* 	 *	unlink children from parent, 	 *	then insertion sort back on to sorted's children. 	 *	    *arcp	the arc you have detached and are inserting. 	 *	    *detachedp	the rest of the arcs to be sorted. 	 *	    sorted	arc list onto which you insertion sort. 	 *	    *prevp	arc before the arc you are comparing. 	 */
name|sorted
operator|.
name|arc_childlist
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arcp
operator|=
name|parentp
operator|->
name|children
operator|,
name|detachedp
operator|=
name|arcp
operator|->
name|arc_childlist
init|;
name|arcp
condition|;
name|arcp
operator|=
name|detachedp
operator|,
name|detachedp
operator|=
name|detachedp
operator|->
name|arc_childlist
control|)
block|{
comment|/* 	     *	consider *arcp as disconnected 	     *	insert it into sorted 	     */
for|for
control|(
name|prevp
operator|=
operator|&
name|sorted
init|;
name|prevp
operator|->
name|arc_childlist
condition|;
name|prevp
operator|=
name|prevp
operator|->
name|arc_childlist
control|)
block|{
if|if
condition|(
name|arccmp
argument_list|(
name|arcp
argument_list|,
name|prevp
operator|->
name|arc_childlist
argument_list|)
operator|!=
name|LESSTHAN
condition|)
block|{
break|break;
block|}
block|}
name|arcp
operator|->
name|arc_childlist
operator|=
name|prevp
operator|->
name|arc_childlist
expr_stmt|;
name|prevp
operator|->
name|arc_childlist
operator|=
name|arcp
expr_stmt|;
block|}
comment|/* 	 *	reattach sorted children to parent 	 */
name|parentp
operator|->
name|children
operator|=
name|sorted
operator|.
name|arc_childlist
expr_stmt|;
block|}
end_block

begin_macro
name|sortparents
argument_list|(
argument|childp
argument_list|)
end_macro

begin_decl_stmt
name|nltype
modifier|*
name|childp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|arctype
modifier|*
name|arcp
decl_stmt|;
name|arctype
modifier|*
name|detachedp
decl_stmt|;
name|arctype
name|sorted
decl_stmt|;
name|arctype
modifier|*
name|prevp
decl_stmt|;
comment|/* 	 *	unlink parents from child, 	 *	then insertion sort back on to sorted's parents. 	 *	    *arcp	the arc you have detached and are inserting. 	 *	    *detachedp	the rest of the arcs to be sorted. 	 *	    sorted	arc list onto which you insertion sort. 	 *	    *prevp	arc before the arc you are comparing. 	 */
name|sorted
operator|.
name|arc_parentlist
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|arcp
operator|=
name|childp
operator|->
name|parents
operator|,
name|detachedp
operator|=
name|arcp
operator|->
name|arc_parentlist
init|;
name|arcp
condition|;
name|arcp
operator|=
name|detachedp
operator|,
name|detachedp
operator|=
name|detachedp
operator|->
name|arc_parentlist
control|)
block|{
comment|/* 	     *	consider *arcp as disconnected 	     *	insert it into sorted 	     */
for|for
control|(
name|prevp
operator|=
operator|&
name|sorted
init|;
name|prevp
operator|->
name|arc_parentlist
condition|;
name|prevp
operator|=
name|prevp
operator|->
name|arc_parentlist
control|)
block|{
if|if
condition|(
name|arccmp
argument_list|(
name|arcp
argument_list|,
name|prevp
operator|->
name|arc_parentlist
argument_list|)
operator|!=
name|GREATERTHAN
condition|)
block|{
break|break;
block|}
block|}
name|arcp
operator|->
name|arc_parentlist
operator|=
name|prevp
operator|->
name|arc_parentlist
expr_stmt|;
name|prevp
operator|->
name|arc_parentlist
operator|=
name|arcp
expr_stmt|;
block|}
comment|/* 	 *	reattach sorted arcs to child 	 */
name|childp
operator|->
name|parents
operator|=
name|sorted
operator|.
name|arc_parentlist
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	compare two arcs to/from the same child/parent.      *	- if one arc is a self arc, it's least.      *	- if one arc is within a cycle, it's less than.      *	- if both arcs are within a cycle, compare arc counts.      *	- if neither arc is within a cycle, compare with      *		time + childtime as major key      *		arc count as minor key      */
end_comment

begin_function
name|int
name|arccmp
parameter_list|(
name|thisp
parameter_list|,
name|thatp
parameter_list|)
name|arctype
modifier|*
name|thisp
decl_stmt|;
name|arctype
modifier|*
name|thatp
decl_stmt|;
block|{
name|nltype
modifier|*
name|thisparentp
init|=
name|thisp
operator|->
name|arc_parentp
decl_stmt|;
name|nltype
modifier|*
name|thischildp
init|=
name|thisp
operator|->
name|arc_childp
decl_stmt|;
name|nltype
modifier|*
name|thatparentp
init|=
name|thatp
operator|->
name|arc_parentp
decl_stmt|;
name|nltype
modifier|*
name|thatchildp
init|=
name|thatp
operator|->
name|arc_childp
decl_stmt|;
name|double
name|thistime
decl_stmt|;
name|double
name|thattime
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|TIMEDEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"[arccmp] "
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|thisparentp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" calls "
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|thischildp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %f + %f %d/%d\n"
argument_list|,
name|thisp
operator|->
name|arc_time
argument_list|,
name|thisp
operator|->
name|arc_childtime
argument_list|,
name|thisp
operator|->
name|arc_count
argument_list|,
name|thischildp
operator|->
name|ncall
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[arccmp] "
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|thatparentp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" calls "
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|thatchildp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %f + %f %d/%d\n"
argument_list|,
name|thatp
operator|->
name|arc_time
argument_list|,
name|thatp
operator|->
name|arc_childtime
argument_list|,
name|thatp
operator|->
name|arc_count
argument_list|,
name|thatchildp
operator|->
name|ncall
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|thisparentp
operator|==
name|thischildp
condition|)
block|{
comment|/* this is a self call */
return|return
name|LESSTHAN
return|;
block|}
if|if
condition|(
name|thatparentp
operator|==
name|thatchildp
condition|)
block|{
comment|/* that is a self call */
return|return
name|GREATERTHAN
return|;
block|}
if|if
condition|(
name|thisparentp
operator|->
name|cycleno
operator|!=
literal|0
operator|&&
name|thischildp
operator|->
name|cycleno
operator|!=
literal|0
operator|&&
name|thisparentp
operator|->
name|cycleno
operator|==
name|thischildp
operator|->
name|cycleno
condition|)
block|{
comment|/* this is a call within a cycle */
if|if
condition|(
name|thatparentp
operator|->
name|cycleno
operator|!=
literal|0
operator|&&
name|thatchildp
operator|->
name|cycleno
operator|!=
literal|0
operator|&&
name|thatparentp
operator|->
name|cycleno
operator|==
name|thatchildp
operator|->
name|cycleno
condition|)
block|{
comment|/* that is a call within the cycle, too */
if|if
condition|(
name|thisp
operator|->
name|arc_count
operator|<
name|thatp
operator|->
name|arc_count
condition|)
block|{
return|return
name|LESSTHAN
return|;
block|}
if|if
condition|(
name|thisp
operator|->
name|arc_count
operator|>
name|thatp
operator|->
name|arc_count
condition|)
block|{
return|return
name|GREATERTHAN
return|;
block|}
return|return
name|EQUALTO
return|;
block|}
else|else
block|{
comment|/* that isn't a call within the cycle */
return|return
name|LESSTHAN
return|;
block|}
block|}
else|else
block|{
comment|/* this isn't a call within a cycle */
if|if
condition|(
name|thatparentp
operator|->
name|cycleno
operator|!=
literal|0
operator|&&
name|thatchildp
operator|->
name|cycleno
operator|!=
literal|0
operator|&&
name|thatparentp
operator|->
name|cycleno
operator|==
name|thatchildp
operator|->
name|cycleno
condition|)
block|{
comment|/* that is a call within a cycle */
return|return
name|GREATERTHAN
return|;
block|}
else|else
block|{
comment|/* neither is a call within a cycle */
name|thistime
operator|=
name|thisp
operator|->
name|arc_time
operator|+
name|thisp
operator|->
name|arc_childtime
expr_stmt|;
name|thattime
operator|=
name|thatp
operator|->
name|arc_time
operator|+
name|thatp
operator|->
name|arc_childtime
expr_stmt|;
if|if
condition|(
name|thistime
operator|<
name|thattime
condition|)
return|return
name|LESSTHAN
return|;
if|if
condition|(
name|thistime
operator|>
name|thattime
condition|)
return|return
name|GREATERTHAN
return|;
if|if
condition|(
name|thisp
operator|->
name|arc_count
operator|<
name|thatp
operator|->
name|arc_count
condition|)
return|return
name|LESSTHAN
return|;
if|if
condition|(
name|thisp
operator|->
name|arc_count
operator|>
name|thatp
operator|->
name|arc_count
condition|)
return|return
name|GREATERTHAN
return|;
return|return
name|EQUALTO
return|;
block|}
block|}
block|}
end_function

end_unit

