begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)compress.c	3.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"ww.h"
end_include

begin_include
include|#
directive|include
file|"xx.h"
end_include

begin_include
include|#
directive|include
file|"tt.h"
end_include

begin_comment
comment|/* tunable constants */
end_comment

begin_decl_stmt
name|int
name|xc_token_size
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xc_weight
init|=
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xc_thresh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xc_limit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fundamental constants */
end_comment

begin_define
define|#
directive|define
name|TOKEN_MAX
value|32
end_define

begin_define
define|#
directive|define
name|NTOKEN
value|128
end_define

begin_define
define|#
directive|define
name|NCTOKEN
value|(NTOKEN * 32)
end_define

begin_comment
comment|/* should be at least xxbufsize */
end_comment

begin_define
define|#
directive|define
name|H
value|13
end_define

begin_define
define|#
directive|define
name|HSIZE
value|(1<< H)
end_define

begin_comment
comment|/* at least twice NCTOKEN */
end_comment

begin_struct
struct|struct
name|xc_token
block|{
name|long
name|time
decl_stmt|;
name|long
name|weight
decl_stmt|;
name|char
name|string
index|[
name|TOKEN_MAX
index|]
decl_stmt|;
name|short
name|index
decl_stmt|;
name|struct
name|xc_token
modifier|*
name|forw
decl_stmt|;
name|struct
name|xc_token
modifier|*
name|back
decl_stmt|;
name|struct
name|xc_token
modifier|*
name|hforw
decl_stmt|;
name|struct
name|xc_token
modifier|*
modifier|*
name|hback
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|xc_token
name|xc_q1
decl_stmt|,
name|xc_q2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|xc_token
modifier|*
modifier|*
name|xc_htab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|xc_token
modifier|*
modifier|*
name|xc_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|xc_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|xc_time0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|xc_hs1
value|3
end_define

begin_define
define|#
directive|define
name|xc_hs2
value|(H - 3)
end_define

begin_decl_stmt
name|int
name|xc_uhs1
decl_stmt|,
name|xc_uhs2
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|xchash
parameter_list|(
name|h
parameter_list|,
name|c
parameter_list|)
value|((((h)<< xc_hs1 | (h)>> xc_hs2) ^ (c))& HSIZE - 1)
end_define

begin_define
define|#
directive|define
name|xcunhash
parameter_list|(
name|h
parameter_list|,
name|c
parameter_list|)
value|(((h) ^ (c)<< xc_uhs1 ^ (c)>> xc_uhs2)& HSIZE - 1)
end_define

begin_define
define|#
directive|define
name|xccopy
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|)
value|bcopy(f, t, xc_token_size)
end_define

begin_define
define|#
directive|define
name|xcequal
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|)
value|(bcmp(f, t, xc_token_size) == 0)
end_define

begin_define
define|#
directive|define
name|xcinsert
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
define|\
value|((t1)->back->forw = (t1)->forw, \ 			(t1)->forw->back = (t1)->back, \ 			(t2)->forw->back = (t1), \ 			(t1)->forw = (t2)->forw, \ 			(t2)->forw = (t1), \ 			(t1)->back = (t2))
end_define

begin_macro
name|xcinit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|xc_token
modifier|*
name|tp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|xc_token_size
operator|<
literal|2
condition|)
block|{
name|tt
operator|.
name|tt_ntoken
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|xc_thresh
operator|=
name|xc_weight
operator|*
operator|(
literal|1
operator|+
operator|(
name|tt
operator|.
name|tt_set_token_cost
operator|+
name|tt
operator|.
name|tt_put_token_cost
operator|)
operator|/
name|xc_token_size
operator|)
expr_stmt|;
name|xc_limit
operator|=
name|xc_thresh
operator|+
name|xc_weight
expr_stmt|;
if|if
condition|(
name|tt
operator|.
name|tt_token_max
operator|>
name|TOKEN_MAX
condition|)
name|tt
operator|.
name|tt_token_max
operator|=
name|TOKEN_MAX
expr_stmt|;
name|xc_uhs1
operator|=
operator|(
name|xc_token_size
operator|-
literal|1
operator|)
operator|*
name|xc_hs1
operator|%
name|H
expr_stmt|;
name|xc_uhs2
operator|=
name|H
operator|-
name|xc_uhs1
expr_stmt|;
name|xc_time
operator|=
literal|0
expr_stmt|;
name|xc_htab
operator|=
operator|(
expr|struct
name|xc_token
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|HSIZE
argument_list|,
sizeof|sizeof
expr|*
name|xc_htab
argument_list|)
expr_stmt|;
name|xc_line
operator|=
operator|(
expr|struct
name|xc_token
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|xxbufsize
operator|*
sizeof|sizeof
expr|*
name|xc_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|xc_line
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
name|tp
operator|=
operator|(
expr|struct
name|xc_token
operator|*
operator|)
name|malloc
argument_list|(
name|NCTOKEN
operator|*
sizeof|sizeof
expr|*
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
name|xc_q1
operator|.
name|forw
operator|=
operator|&
name|xc_q1
expr_stmt|;
name|xc_q1
operator|.
name|back
operator|=
operator|&
name|xc_q1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTOKEN
condition|;
name|i
operator|++
operator|,
name|tp
operator|++
control|)
block|{
name|tp
operator|->
name|index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|tp
operator|->
name|weight
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|time
operator|=
operator|-
literal|1
expr_stmt|;
name|xc_q1
operator|.
name|forw
operator|->
name|back
operator|=
name|tp
expr_stmt|;
name|tp
operator|->
name|forw
operator|=
name|xc_q1
operator|.
name|forw
expr_stmt|;
name|xc_q1
operator|.
name|forw
operator|=
name|tp
expr_stmt|;
name|tp
operator|->
name|back
operator|=
operator|&
name|xc_q1
expr_stmt|;
name|tp
operator|->
name|hback
operator|=
literal|0
expr_stmt|;
block|}
name|xc_q2
operator|.
name|forw
operator|=
operator|&
name|xc_q2
expr_stmt|;
name|xc_q2
operator|.
name|back
operator|=
operator|&
name|xc_q2
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|NCTOKEN
condition|;
name|i
operator|++
operator|,
name|tp
operator|++
control|)
block|{
name|tp
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|weight
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|time
operator|=
operator|-
literal|1
expr_stmt|;
name|xc_q2
operator|.
name|forw
operator|->
name|back
operator|=
name|tp
expr_stmt|;
name|tp
operator|->
name|forw
operator|=
name|xc_q2
operator|.
name|forw
expr_stmt|;
name|xc_q2
operator|.
name|forw
operator|=
name|tp
expr_stmt|;
name|tp
operator|->
name|back
operator|=
operator|&
name|xc_q2
expr_stmt|;
name|tp
operator|->
name|hback
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
name|nomem
label|:
name|wwerrno
operator|=
name|WWE_NOMEM
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_macro
name|xcstart
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|xc_token
modifier|*
name|tp
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|xc_q1
operator|.
name|forw
init|;
name|tp
operator|!=
operator|&
name|xc_q1
condition|;
name|tp
operator|=
name|tp
operator|->
name|forw
control|)
if|if
condition|(
name|tp
operator|->
name|index
operator|>
literal|0
condition|)
name|tp
operator|->
name|index
operator|=
operator|-
name|tp
operator|->
name|index
expr_stmt|;
block|}
end_block

begin_macro
name|xcreset
argument_list|()
end_macro

begin_block
block|{
name|xc_time0
operator|=
name|xc_time
expr_stmt|;
block|}
end_block

begin_macro
name|xcscan
argument_list|(
argument|s
argument_list|,
argument|n
argument_list|,
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|h
expr_stmt|;
specifier|register
name|i
expr_stmt|;
specifier|register
name|struct
name|xc_token
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|xc_token
modifier|*
modifier|*
name|lp
init|=
name|xc_line
operator|+
name|x
decl_stmt|;
if|if
condition|(
name|n
operator|<
name|xc_token_size
condition|)
return|return;
name|p
operator|=
name|s
expr_stmt|;
for|for
control|(
name|i
operator|=
name|xc_token_size
operator|-
literal|2
operator|,
name|h
operator|=
name|xchash
argument_list|(
literal|0
argument_list|,
operator|*
name|p
operator|++
argument_list|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|h
operator|=
name|xchash
argument_list|(
name|h
argument_list|,
operator|*
name|p
operator|++
argument_list|)
control|)
empty_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|-
name|xc_token_size
init|;
condition|;
control|)
block|{
name|xc_time
operator|++
expr_stmt|;
name|h
operator|=
name|xchash
argument_list|(
name|h
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|xc_htab
index|[
name|h
index|]
init|;
name|tp
operator|!=
literal|0
operator|&&
operator|!
name|xcequal
argument_list|(
name|tp
operator|->
name|string
argument_list|,
name|p
operator|-
name|xc_token_size
argument_list|)
condition|;
name|tp
operator|=
name|tp
operator|->
name|hforw
control|)
empty_stmt|;
if|if
condition|(
name|tp
operator|==
literal|0
condition|)
block|{
name|tp
operator|=
name|xc_q2
operator|.
name|back
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|time
operator|>=
name|xc_time0
condition|)
block|{
operator|*
name|lp
operator|=
literal|0
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
if|if
condition|(
name|tp
operator|->
name|hback
operator|!=
literal|0
operator|&&
operator|(
operator|*
name|tp
operator|->
name|hback
operator|=
name|tp
operator|->
name|hforw
operator|)
operator|!=
literal|0
condition|)
name|tp
operator|->
name|hforw
operator|->
name|hback
operator|=
name|tp
operator|->
name|hback
expr_stmt|;
name|xccopy
argument_list|(
name|p
operator|-
name|xc_token_size
argument_list|,
name|tp
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|hforw
operator|=
name|xc_htab
index|[
name|h
index|]
operator|)
operator|!=
literal|0
condition|)
name|tp
operator|->
name|hforw
operator|->
name|hback
operator|=
operator|&
name|tp
operator|->
name|hforw
expr_stmt|;
name|tp
operator|->
name|hback
operator|=
name|xc_htab
operator|+
name|h
expr_stmt|;
name|xc_htab
index|[
name|h
index|]
operator|=
name|tp
expr_stmt|;
name|tp
operator|->
name|weight
operator|=
name|xc_weight
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Don't count overlapping tokens as two, 			 * and don't update the time so a token that overlaps 			 * this but not the previous will be counted,. 			 * but do fix up the weight to compensate for 			 * the incorrect time. 			 */
if|if
condition|(
name|tp
operator|->
name|time
operator|>
name|xc_time
operator|-
name|xc_token_size
condition|)
name|tp
operator|->
name|weight
operator|+=
name|xc_time
operator|-
name|tp
operator|->
name|time
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|tp
operator|->
name|weight
operator|+=
name|tp
operator|->
name|time
operator|-
name|xc_time
operator|)
operator|<
literal|0
condition|)
name|tp
operator|->
name|weight
operator|=
name|xc_weight
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|tp
operator|->
name|weight
operator|+=
name|xc_weight
operator|)
operator|>
name|xc_limit
condition|)
name|tp
operator|->
name|weight
operator|=
name|xc_limit
expr_stmt|;
block|}
name|tp
operator|->
name|time
operator|=
name|xc_time
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|index
operator|==
literal|0
condition|)
name|xcinsert
argument_list|(
name|tp
argument_list|,
operator|&
name|xc_q2
argument_list|)
expr_stmt|;
else|else
name|xcinsert
argument_list|(
name|tp
argument_list|,
operator|&
name|xc_q1
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|=
name|tp
expr_stmt|;
name|cont
label|:
name|lp
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
break|break;
name|h
operator|=
name|xcunhash
argument_list|(
name|h
argument_list|,
name|p
index|[
operator|-
name|xc_token_size
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|xc_token_size
operator|-
literal|1
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|xcwrite
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|x
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|struct
name|xc_token
modifier|*
modifier|*
name|lp
init|=
name|xc_line
operator|+
name|x
decl_stmt|;
specifier|register
name|struct
name|xc_token
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|xc_token
modifier|*
name|tq
decl_stmt|;
if|if
condition|(
name|n
operator|<
name|xc_token_size
condition|)
block|{
call|(
modifier|*
name|tt
operator|.
name|tt_write
call|)
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|tp
operator|=
name|lp
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|tt
operator|.
name|tt_putc
call|)
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|index
operator|>
literal|0
condition|)
block|{
name|xcinsert
argument_list|(
name|tp
argument_list|,
operator|&
name|xc_q1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tt
operator|.
name|tt_put_token
call|)
argument_list|(
name|tp
operator|->
name|index
operator|-
literal|1
argument_list|,
name|tp
operator|->
name|string
argument_list|,
name|xc_token_size
argument_list|)
expr_stmt|;
name|wwntokuse
operator|++
expr_stmt|;
name|wwntoksave
operator|+=
name|xc_token_size
operator|-
name|tt
operator|.
name|tt_put_token_cost
expr_stmt|;
name|i
operator|+=
name|xc_token_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|index
operator|<
literal|0
condition|)
block|{
name|tp
operator|->
name|index
operator|=
operator|-
name|tp
operator|->
name|index
expr_stmt|;
name|xcinsert
argument_list|(
name|tp
argument_list|,
operator|&
name|xc_q1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tt
operator|.
name|tt_set_token
call|)
argument_list|(
name|tp
operator|->
name|index
operator|-
literal|1
argument_list|,
name|tp
operator|->
name|string
argument_list|,
name|xc_token_size
argument_list|)
expr_stmt|;
name|wwntokdef
operator|++
expr_stmt|;
name|wwntoksave
operator|-=
name|tt
operator|.
name|tt_set_token_cost
expr_stmt|;
name|i
operator|+=
name|xc_token_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|weight
operator|>
name|xc_thresh
operator|&&
operator|(
operator|(
name|tq
operator|=
name|xc_q1
operator|.
name|back
operator|)
operator|->
name|index
operator|<
literal|0
operator|||
name|tq
operator|->
name|weight
operator|+
operator|(
name|tq
operator|->
name|time
operator|-
name|tp
operator|->
name|time
operator|)
operator|+
name|xc_thresh
operator|<
name|tp
operator|->
name|weight
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|index
operator|=
name|tq
operator|->
name|index
operator|)
operator|<
literal|0
condition|)
name|tp
operator|->
name|index
operator|=
operator|-
name|tp
operator|->
name|index
expr_stmt|;
name|tq
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|xcinsert
argument_list|(
name|tq
argument_list|,
operator|&
name|xc_q2
argument_list|)
expr_stmt|;
name|xcinsert
argument_list|(
name|tp
argument_list|,
operator|&
name|xc_q1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tt
operator|.
name|tt_set_token
call|)
argument_list|(
name|tp
operator|->
name|index
operator|-
literal|1
argument_list|,
name|tp
operator|->
name|string
argument_list|,
name|xc_token_size
argument_list|)
expr_stmt|;
name|wwntokdef
operator|++
expr_stmt|;
name|wwntoksave
operator|-=
name|tt
operator|.
name|tt_set_token_cost
expr_stmt|;
name|i
operator|+=
name|xc_token_size
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|tt
operator|.
name|tt_putc
call|)
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|wwntokc
operator|+=
name|n
expr_stmt|;
block|}
end_block

end_unit

