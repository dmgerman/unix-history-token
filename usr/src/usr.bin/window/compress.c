begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)compress.c	3.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"ww.h"
end_include

begin_include
include|#
directive|include
file|"xx.h"
end_include

begin_include
include|#
directive|include
file|"tt.h"
end_include

begin_comment
comment|/* tunable parameters */
end_comment

begin_decl_stmt
name|int
name|xc_reverse
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xc_sort
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xc_chop
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xc_token_max
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<= TOKEN_MAX */
end_comment

begin_decl_stmt
name|int
name|xc_token_min
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*> tt.tt_put_token_cost */
end_comment

begin_decl_stmt
name|int
name|xc_npass0
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xc_npass1
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xc_bufsize
init|=
literal|1024
operator|*
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX, or 80 * 24 * 2 */
end_comment

begin_decl_stmt
name|int
name|xc_ntoken
init|=
literal|8192
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|xc_weight
value|XXX
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|xc_weight
end_ifndef

begin_decl_stmt
name|int
name|xc_weight
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TOKEN_MAX
value|16
end_define

begin_struct
struct|struct
name|xc
block|{
name|char
name|string
index|[
name|TOKEN_MAX
index|]
decl_stmt|;
name|char
name|length
decl_stmt|;
name|char
name|flag
decl_stmt|;
ifndef|#
directive|ifndef
name|xc_weight
name|short
name|weight
decl_stmt|;
endif|#
directive|endif
name|long
name|time
decl_stmt|;
comment|/* time last seen */
name|short
name|bcount
decl_stmt|;
comment|/* count in this buffer */
name|short
name|ccount
decl_stmt|;
comment|/* count in compression */
name|short
name|places
decl_stmt|;
comment|/* places in the buffer */
name|short
name|code
decl_stmt|;
comment|/* token code */
name|struct
name|xc
modifier|*
name|qforw
decl_stmt|,
modifier|*
name|qback
decl_stmt|;
name|struct
name|xc
modifier|*
name|hforw
decl_stmt|,
modifier|*
modifier|*
name|hback
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|short
name|xc_thresholds
index|[
name|TOKEN_MAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|thresh
parameter_list|(
name|length
parameter_list|)
value|(xc_thresholds[length])
end_define

begin_define
define|#
directive|define
name|threshp
parameter_list|(
name|code
parameter_list|,
name|count
parameter_list|,
name|length
parameter_list|)
define|\
value|((code)>= 0 || (short) (count)>= xc_thresholds[length])
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|xc_weight
end_ifndef

begin_decl_stmt
name|short
name|xc_wthresholds
index|[
name|TOKEN_MAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|wthresh
parameter_list|(
name|length
parameter_list|)
value|(xc_wthresholds[length])
end_define

begin_define
define|#
directive|define
name|wthreshp
parameter_list|(
name|weight
parameter_list|,
name|length
parameter_list|)
value|((short) (weight)>= xc_wthresholds[length])
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|wthreshp
parameter_list|(
name|weight
parameter_list|,
name|length
parameter_list|)
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|xc_weight
end_ifndef

begin_decl_stmt
name|short
name|xc_wlimits
index|[
name|TOKEN_MAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|wlimit
parameter_list|(
name|length
parameter_list|)
value|(xc_wlimits[length])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|put_token_score
parameter_list|(
name|length
parameter_list|)
value|((length) - tt.tt_put_token_cost)
end_define

begin_decl_stmt
name|int
name|xc_score_adjustments
index|[
name|TOKEN_MAX
operator|+
literal|1
index|]
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX, 8> max of xc_thresholds */
end_comment

begin_define
define|#
directive|define
name|score_adjust
parameter_list|(
name|score
parameter_list|,
name|p
parameter_list|)
define|\
value|do { \ 		int length = (p)->length; \ 		int ccount = (p)->ccount; \ 		if (threshp((p)->code, ccount, length) || \ 		    wthreshp((p)->weight, length))
comment|/* XXX */
value|\ 			(score) -= length - tt.tt_put_token_cost; \ 		else \ 			(score) += xc_score_adjustments[length][ccount]; \ 	} while (0)
end_define

begin_decl_stmt
name|int
name|xc_initial_scores
index|[
name|TOKEN_MAX
operator|+
literal|1
index|]
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX, 8> max of xc_thresholds */
end_comment

begin_decl_stmt
name|struct
name|xc
name|xc_q0a
decl_stmt|,
name|xc_q0b
decl_stmt|,
name|xc_q1a
decl_stmt|,
name|xc_q1b
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|qinsert
parameter_list|(
name|x1
parameter_list|,
name|x2
parameter_list|)
define|\
value|do { \ 		register struct xc *forw = (x1)->qforw; \ 		register struct xc *back = (x1)->qback; \ 		back->qforw = forw; \ 		forw->qback = back; \ 		forw = (x2)->qforw; \ 		(x1)->qforw = forw; \ 		forw->qback = (x1); \ 		(x2)->qforw = (x1); \ 		(x1)->qback = (x2); \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|qinsertq
parameter_list|(
name|q
parameter_list|,
name|x
parameter_list|)
define|\
value|((q)->qforw == (q) ? 0 : \ 	 ((q)->qback->qforw = (x)->qforw, \ 	  (x)->qforw->qback = (q)->qback, \ 	  (q)->qforw->qback = (x), \ 	  (x)->qforw = (q)->qforw, \ 	  (q)->qforw = (q), \ 	  (q)->qback = (q)))
end_define

begin_define
define|#
directive|define
name|H
value|(14)
end_define

begin_define
define|#
directive|define
name|HSIZE
value|(1<< H)
end_define

begin_define
define|#
directive|define
name|hash
parameter_list|(
name|h
parameter_list|,
name|c
parameter_list|)
value|((((h)>> H - 8 | (h)<< 8) ^ (unsigned char)(c))& \ 				HSIZE - 1)
end_define

begin_decl_stmt
name|struct
name|xc
modifier|*
modifier|*
name|xc_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the output array */
end_comment

begin_decl_stmt
name|short
modifier|*
name|xc_places
index|[
name|TOKEN_MAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|xc_hashcodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for computing hashcodes */
end_comment

begin_decl_stmt
name|struct
name|xc
modifier|*
modifier|*
name|xc_htab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the hash table */
end_comment

begin_decl_stmt
name|struct
name|xc
modifier|*
modifier|*
name|xc_tokens
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holds all the active tokens */
end_comment

begin_struct
struct|struct
name|xc_undo
block|{
name|struct
name|xc
modifier|*
modifier|*
name|pos
decl_stmt|;
name|struct
name|xc
modifier|*
name|val
decl_stmt|;
block|}
modifier|*
name|xc_undo
struct|;
end_struct

begin_decl_stmt
name|long
name|xc_time
decl_stmt|,
name|xc_time0
decl_stmt|;
end_decl_stmt

begin_macro
name|xcinit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
specifier|register
name|struct
name|xc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|tt
operator|.
name|tt_token_max
operator|>
name|xc_token_max
condition|)
name|tt
operator|.
name|tt_token_max
operator|=
name|xc_token_max
expr_stmt|;
if|if
condition|(
name|tt
operator|.
name|tt_token_min
operator|<
name|xc_token_min
condition|)
name|tt
operator|.
name|tt_token_min
operator|=
name|xc_token_min
expr_stmt|;
if|if
condition|(
name|tt
operator|.
name|tt_token_min
operator|>
name|tt
operator|.
name|tt_token_max
condition|)
block|{
name|tt
operator|.
name|tt_ntoken
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|tt
operator|.
name|tt_ntoken
operator|>
name|xc_ntoken
operator|/
literal|2
condition|)
comment|/* not likely */
name|tt
operator|.
name|tt_ntoken
operator|=
name|xc_ntoken
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|xxbufsize
operator|>
name|xc_bufsize
condition|)
name|xxbufsize
operator|=
name|xc_bufsize
expr_stmt|;
comment|/* XXX */
define|#
directive|define
name|C
parameter_list|(
name|x
parameter_list|)
value|(sizeof (x) / sizeof *(x))
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|C
argument_list|(
name|xc_thresholds
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|h
init|=
name|i
operator|-
name|tt
operator|.
name|tt_put_token_cost
decl_stmt|;
if|if
condition|(
name|h
operator|>
literal|0
condition|)
name|xc_thresholds
index|[
name|i
index|]
operator|=
operator|(
name|tt
operator|.
name|tt_set_token_cost
operator|+
literal|1
operator|+
name|h
operator|-
literal|1
operator|)
operator|/
name|h
operator|+
literal|1
expr_stmt|;
else|else
name|xc_thresholds
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|C
argument_list|(
name|xc_score_adjustments
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|t
init|=
name|xc_thresholds
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|C
argument_list|(
operator|*
name|xc_score_adjustments
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
name|t
condition|)
name|xc_score_adjustments
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|-
operator|(
name|i
operator|-
name|tt
operator|.
name|tt_put_token_cost
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|<
name|t
operator|-
literal|1
condition|)
name|xc_score_adjustments
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
else|else
comment|/* 				 * cost now is 				 *	length * (ccount + 1)		a 				 * cost before was 				 *	set-token-cost + length + 				 *		ccount * put-token-cost	b 				 * the score adjustment is (b - a) 				 */
name|xc_score_adjustments
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|tt
operator|.
name|tt_set_token_cost
operator|+
name|i
operator|+
name|j
operator|*
name|tt
operator|.
name|tt_put_token_cost
operator|-
name|i
operator|*
operator|(
name|j
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|t
condition|)
name|xc_initial_scores
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
else|else
comment|/* 				 * - (set-token-cost + 				 *	(length - put-token-cost) - 				 *	(length - put-token-cost) * ccount) 				 */
name|xc_initial_scores
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|-
operator|(
name|tt
operator|.
name|tt_set_token_cost
operator|+
operator|(
name|i
operator|-
name|tt
operator|.
name|tt_put_token_cost
operator|)
operator|-
operator|(
name|i
operator|-
name|tt
operator|.
name|tt_put_token_cost
operator|)
operator|*
name|j
operator|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|xc_weight
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|C
argument_list|(
name|xc_wthresholds
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|xc_wthresholds
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|tt
operator|.
name|tt_set_token_cost
operator|+
name|tt
operator|.
name|tt_put_token_cost
operator|)
operator|/
name|i
operator|+
name|i
operator|/
literal|5
operator|+
literal|1
operator|)
operator|*
name|xc_weight
operator|+
literal|1
expr_stmt|;
name|xc_wlimits
index|[
name|i
index|]
operator|=
name|xc_wthresholds
index|[
name|i
index|]
operator|+
name|xc_weight
expr_stmt|;
block|}
endif|#
directive|endif
undef|#
directive|undef
name|C
if|if
condition|(
operator|(
name|xc_output
operator|=
operator|(
expr|struct
name|xc
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|xxbufsize
operator|*
sizeof|sizeof
expr|*
name|xc_output
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
if|if
condition|(
operator|(
name|xc_hashcodes
operator|=
operator|(
name|short
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|xxbufsize
operator|*
sizeof|sizeof
expr|*
name|xc_hashcodes
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
if|if
condition|(
operator|(
name|xc_htab
operator|=
operator|(
expr|struct
name|xc
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|HSIZE
operator|*
sizeof|sizeof
expr|*
name|xc_htab
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
if|if
condition|(
operator|(
name|xc_tokens
operator|=
operator|(
expr|struct
name|xc
operator|*
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|xc_ntoken
operator|+
name|tt
operator|.
name|tt_token_max
operator|-
name|tt
operator|.
name|tt_token_min
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
expr|*
name|xc_tokens
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
if|if
condition|(
operator|(
name|xc_undo
operator|=
operator|(
expr|struct
name|xc_undo
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|xxbufsize
operator|*
sizeof|sizeof
expr|*
name|xc_undo
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
for|for
control|(
name|i
operator|=
name|tt
operator|.
name|tt_token_min
init|;
name|i
operator|<=
name|tt
operator|.
name|tt_token_max
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|xc_places
index|[
name|i
index|]
operator|=
operator|(
name|short
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|xxbufsize
operator|*
sizeof|sizeof
expr|*
operator|*
name|xc_places
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
name|xc_q0a
operator|.
name|qforw
operator|=
name|xc_q0a
operator|.
name|qback
operator|=
operator|&
name|xc_q0a
expr_stmt|;
name|xc_q0b
operator|.
name|qforw
operator|=
name|xc_q0b
operator|.
name|qback
operator|=
operator|&
name|xc_q0b
expr_stmt|;
name|xc_q1a
operator|.
name|qforw
operator|=
name|xc_q1a
operator|.
name|qback
operator|=
operator|&
name|xc_q1a
expr_stmt|;
name|xc_q1b
operator|.
name|qforw
operator|=
name|xc_q1b
operator|.
name|qback
operator|=
operator|&
name|xc_q1b
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
expr|struct
name|xc
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|xc_ntoken
operator|*
sizeof|sizeof
expr|*
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|nomem
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tt
operator|.
name|tt_ntoken
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|->
name|code
operator|=
name|i
expr_stmt|;
name|p
operator|->
name|time
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|qback
operator|=
name|xc_q0a
operator|.
name|qback
expr_stmt|;
name|p
operator|->
name|qforw
operator|=
operator|&
name|xc_q0a
expr_stmt|;
name|p
operator|->
name|qback
operator|->
name|qforw
operator|=
name|p
expr_stmt|;
name|xc_q0a
operator|.
name|qback
operator|=
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|xc_ntoken
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|->
name|code
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|time
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|qback
operator|=
name|xc_q1a
operator|.
name|qback
expr_stmt|;
name|p
operator|->
name|qforw
operator|=
operator|&
name|xc_q1a
expr_stmt|;
name|p
operator|->
name|qback
operator|->
name|qforw
operator|=
name|p
expr_stmt|;
name|xc_q1a
operator|.
name|qback
operator|=
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
name|nomem
label|:
name|wwerrno
operator|=
name|WWE_NOMEM
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_macro
name|xcstart
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|xc
modifier|*
name|p
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|xc_htab
argument_list|,
name|HSIZE
operator|*
sizeof|sizeof
expr|*
name|xc_htab
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|xc_q0a
operator|.
name|qforw
init|;
name|p
operator|!=
operator|&
name|xc_q0a
condition|;
name|p
operator|=
name|p
operator|->
name|qforw
control|)
name|p
operator|->
name|hback
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|xc_q1a
operator|.
name|qforw
init|;
name|p
operator|!=
operator|&
name|xc_q1a
condition|;
name|p
operator|=
name|p
operator|->
name|qforw
control|)
name|p
operator|->
name|hback
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|xcscan
argument_list|(
argument|buffer
argument_list|,
argument|bufsize
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|bufsize
operator|<=
name|tt
operator|.
name|tt_token_min
condition|)
comment|/* one more for char_sep */
return|return;
name|xc_time0
operator|=
name|xc_time
expr_stmt|;
name|xc_time
operator|+=
name|bufsize
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|verbose
operator|>=
literal|0
condition|)
name|time_begin
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
name|xc_sweep_phase
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|xc_tokens
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|verbose
operator|>=
literal|0
condition|)
block|{
name|time_end
argument_list|()
expr_stmt|;
name|time_begin
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|xc_compress_phase
argument_list|(
name|xc_output
argument_list|,
name|bufsize
argument_list|,
name|xc_tokens
argument_list|,
name|n
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|verbose
operator|>=
literal|0
condition|)
name|time_end
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|xc_sweep_phase
argument_list|(
argument|buffer
argument_list|,
argument|bufsize
argument_list|,
argument|tokens
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|xc
modifier|*
modifier|*
name|tokens
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|xc
modifier|*
modifier|*
name|pp
init|=
name|tokens
decl_stmt|;
specifier|register
name|i
operator|,
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
name|int
name|nn
decl_stmt|,
name|ii
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Sweep:"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xc_sweep0
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|tt
operator|.
name|tt_token_min
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
name|xc_ntoken_stat
operator|=
literal|0
expr_stmt|;
name|nn
operator|=
literal|0
expr_stmt|;
name|ii
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|tt
operator|.
name|tt_token_min
init|;
name|i
operator|<=
name|tt
operator|.
name|tt_token_max
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ii
operator|>
literal|7
condition|)
block|{
name|printf
argument_list|(
literal|"\n      "
argument_list|)
expr_stmt|;
name|ii
operator|=
literal|0
expr_stmt|;
block|}
name|ii
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|" (%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|n
operator|=
name|xc_sweep
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|,
name|pp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|pp
operator|+=
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|nn
operator|+=
name|n
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|qinsertq
argument_list|(
operator|&
name|xc_q1b
argument_list|,
operator|&
name|xc_q1a
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\n       %d tokens, %d candidates\n"
argument_list|,
name|xc_ntoken_stat
argument_list|,
name|nn
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|pp
operator|-
name|tokens
return|;
block|}
end_block

begin_macro
name|xc_sweep0
argument_list|(
argument|buffer
argument_list|,
argument|n
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|n
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|length
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|buffer
decl_stmt|;
specifier|register
name|short
modifier|*
name|hc
init|=
name|xc_hashcodes
decl_stmt|;
specifier|register
name|h
expr_stmt|;
if|if
condition|(
operator|--
name|length
operator|==
literal|0
condition|)
do|do
block|{
ifdef|#
directive|ifdef
name|char_sep
if|if
condition|(
operator|(
operator|*
name|hc
operator|++
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
name|char_sep
condition|)
name|hc
index|[
operator|-
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
else|#
directive|else
operator|*
name|hc
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
else|else
for|for
control|(
name|n
operator|-=
name|length
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|char_sep
if|if
condition|(
operator|*
name|p
operator|==
name|char_sep
condition|)
block|{
operator|*
name|hc
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|h
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|length
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|char_sep
if|if
condition|(
operator|*
name|p
operator|==
name|char_sep
condition|)
block|{
name|h
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|h
operator|=
name|hash
argument_list|(
name|h
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
operator|*
name|hc
operator|++
operator|=
name|h
expr_stmt|;
name|p
operator|-=
name|length
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|xc_sweep
argument_list|(
argument|buffer
argument_list|,
argument|bufsize
argument_list|,
argument|tokens
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|xc
modifier|*
modifier|*
name|tokens
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|length
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|xc
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|short
modifier|*
name|hc
decl_stmt|;
name|short
modifier|*
name|places
init|=
name|xc_places
index|[
name|length
index|]
decl_stmt|;
name|struct
name|xc
modifier|*
modifier|*
name|pp
init|=
name|tokens
decl_stmt|;
name|short
name|threshold
init|=
name|thresh
argument_list|(
name|length
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|xc_weight
name|short
name|wthreshold
init|=
name|wthresh
argument_list|(
name|length
argument_list|)
decl_stmt|;
name|short
name|limit
init|=
name|wlimit
argument_list|(
name|length
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|int
name|time
decl_stmt|;
name|i
operator|=
name|length
operator|-
literal|1
expr_stmt|;
name|bufsize
operator|-=
name|i
expr_stmt|;
name|cp
operator|=
name|buffer
operator|+
name|i
expr_stmt|;
name|hc
operator|=
name|xc_hashcodes
expr_stmt|;
name|time
operator|=
name|xc_time0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bufsize
condition|;
name|i
operator|++
operator|,
name|time
operator|++
control|)
block|{
name|struct
name|xc
modifier|*
modifier|*
name|h
decl_stmt|;
block|{
specifier|register
name|short
modifier|*
name|hc1
init|=
name|hc
decl_stmt|;
ifdef|#
directive|ifdef
name|char_sep
if|if
condition|(
operator|*
name|hc1
operator|<
literal|0
operator|||
operator|*
name|cp
operator|==
name|char_sep
condition|)
block|{
operator|*
name|hc1
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
name|hc
operator|=
name|hc1
expr_stmt|;
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|h
operator|=
name|xc_htab
operator|+
operator|(
operator|*
name|hc1
operator|=
name|hash
argument_list|(
operator|*
name|hc1
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
operator|)
expr_stmt|;
name|hc
operator|=
name|hc1
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
operator|*
name|h
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|hforw
control|)
if|if
condition|(
name|p
operator|->
name|length
operator|==
operator|(
name|char
operator|)
name|length
condition|)
block|{
specifier|register
name|char
modifier|*
name|p1
init|=
name|p
operator|->
name|string
decl_stmt|;
specifier|register
name|char
modifier|*
name|p2
init|=
name|cp
operator|-
name|length
decl_stmt|;
specifier|register
name|n
operator|=
name|length
expr_stmt|;
do|do
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
operator|*
name|p2
operator|++
condition|)
goto|goto
name|fail
goto|;
do|while
condition|(
operator|--
name|n
condition|)
do|;
break|break;
name|fail
label|:
empty_stmt|;
block|}
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|xc_q1a
operator|.
name|qback
expr_stmt|;
if|if
condition|(
name|p
operator|==
operator|&
name|xc_q1a
operator|||
name|p
operator|->
name|time
operator|>=
name|xc_time0
operator|&&
name|p
operator|->
name|length
operator|==
operator|(
name|char
operator|)
name|length
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|hback
operator|!=
literal|0
condition|)
if|if
condition|(
operator|(
operator|*
name|p
operator|->
name|hback
operator|=
name|p
operator|->
name|hforw
operator|)
operator|!=
literal|0
condition|)
name|p
operator|->
name|hforw
operator|->
name|hback
operator|=
name|p
operator|->
name|hback
expr_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p1
init|=
name|p
operator|->
name|string
decl_stmt|;
specifier|register
name|char
modifier|*
name|p2
init|=
name|cp
operator|-
name|length
decl_stmt|;
specifier|register
name|n
operator|=
name|length
expr_stmt|;
do|do
operator|*
name|p1
operator|++
operator|=
operator|*
name|p2
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|n
condition|)
do|;
block|}
name|p
operator|->
name|length
operator|=
name|length
expr_stmt|;
ifndef|#
directive|ifndef
name|xc_weight
name|p
operator|->
name|weight
operator|=
name|xc_weight
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|time
operator|=
name|time
expr_stmt|;
name|p
operator|->
name|bcount
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|ccount
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|hforw
operator|=
operator|*
name|h
operator|)
operator|!=
literal|0
condition|)
name|p
operator|->
name|hforw
operator|->
name|hback
operator|=
operator|&
name|p
operator|->
name|hforw
expr_stmt|;
operator|*
name|h
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|hback
operator|=
name|h
expr_stmt|;
name|qinsert
argument_list|(
name|p
argument_list|,
operator|&
name|xc_q1a
argument_list|)
expr_stmt|;
name|places
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|places
operator|=
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
name|xc_ntoken_stat
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|time
operator|<
name|xc_time0
condition|)
block|{
ifndef|#
directive|ifndef
name|xc_weight
if|if
condition|(
operator|(
name|p
operator|->
name|weight
operator|+=
name|p
operator|->
name|time
operator|-
name|time
operator|)
operator|<
literal|0
condition|)
name|p
operator|->
name|weight
operator|=
name|xc_weight
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|p
operator|->
name|weight
operator|+=
name|xc_weight
operator|)
operator|>
name|limit
condition|)
name|p
operator|->
name|weight
operator|=
name|limit
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|time
operator|=
name|time
expr_stmt|;
name|p
operator|->
name|bcount
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|ccount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|code
operator|>=
literal|0
condition|)
block|{
name|p
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|p
expr_stmt|;
block|}
elseif|else
ifndef|#
directive|ifndef
name|xc_weight
if|if
condition|(
name|p
operator|->
name|weight
operator|>=
name|wthreshold
condition|)
block|{
name|p
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|p
expr_stmt|;
name|qinsert
argument_list|(
name|p
argument_list|,
operator|&
name|xc_q1b
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|p
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
name|qinsert
argument_list|(
name|p
argument_list|,
operator|&
name|xc_q1a
argument_list|)
expr_stmt|;
block|}
name|places
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|places
operator|=
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
name|xc_ntoken_stat
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|time
operator|+
name|length
operator|>
name|time
condition|)
block|{
comment|/* 			 * overlapping token, don't count as two and 			 * don't update time, but do adjust weight to offset 			 * the difference 			 */
ifndef|#
directive|ifndef
name|xc_weight
if|if
condition|(
name|xc_weight
operator|!=
literal|0
condition|)
block|{
comment|/* XXX */
name|p
operator|->
name|weight
operator|+=
name|time
operator|-
name|p
operator|->
name|time
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|flag
operator|&&
name|p
operator|->
name|weight
operator|>=
name|wthreshold
condition|)
block|{
name|p
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|p
expr_stmt|;
name|qinsert
argument_list|(
name|p
argument_list|,
operator|&
name|xc_q1b
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|places
index|[
name|i
index|]
operator|=
name|p
operator|->
name|places
expr_stmt|;
name|p
operator|->
name|places
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|xc_weight
if|if
condition|(
operator|(
name|p
operator|->
name|weight
operator|+=
name|p
operator|->
name|time
operator|-
name|time
operator|)
operator|<
literal|0
condition|)
name|p
operator|->
name|weight
operator|=
name|xc_weight
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|p
operator|->
name|weight
operator|+=
name|xc_weight
operator|)
operator|>
name|limit
condition|)
name|p
operator|->
name|weight
operator|=
name|limit
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|time
operator|=
name|time
expr_stmt|;
name|p
operator|->
name|bcount
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|flag
operator|&&
comment|/* code must be< 0 if flag false here */
operator|(
name|p
operator|->
name|bcount
operator|>=
name|threshold
ifndef|#
directive|ifndef
name|xc_weight
operator|||
name|p
operator|->
name|weight
operator|>=
name|wthreshold
endif|#
directive|endif
operator|)
condition|)
block|{
name|p
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|p
expr_stmt|;
name|qinsert
argument_list|(
name|p
argument_list|,
operator|&
name|xc_q1b
argument_list|)
expr_stmt|;
block|}
name|places
index|[
name|i
index|]
operator|=
name|p
operator|->
name|places
expr_stmt|;
name|p
operator|->
name|places
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|pp
operator|-
name|tokens
operator|)
operator|>
literal|0
condition|)
block|{
operator|*
name|pp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xc_reverse
condition|)
name|xc_sweep_reverse
argument_list|(
name|tokens
argument_list|,
name|places
argument_list|)
expr_stmt|;
if|if
condition|(
name|xc_sort
operator|&&
name|i
operator|>
literal|1
condition|)
block|{
name|int
name|xc_token_compare
parameter_list|()
function_decl|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tokens
argument_list|,
name|i
argument_list|,
sizeof|sizeof
expr|*
name|tokens
argument_list|,
name|xc_token_compare
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xc_chop
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|i
operator|*
name|xc_chop
operator|/
literal|100
operator|)
operator|==
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
name|tokens
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_block

begin_expr_stmt
name|xc_sweep_reverse
argument_list|(
name|pp
argument_list|,
name|places
argument_list|)
specifier|register
expr|struct
name|xc
operator|*
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|short
modifier|*
name|places
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|xc
modifier|*
name|p
decl_stmt|;
specifier|register
name|short
name|front
decl_stmt|,
name|back
decl_stmt|,
name|t
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|pp
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
name|back
operator|=
operator|-
literal|1
expr_stmt|;
name|t
operator|=
name|p
operator|->
name|places
expr_stmt|;
comment|/* the list is never empty */
do|do
block|{
name|front
operator|=
name|places
index|[
name|t
index|]
expr_stmt|;
name|places
index|[
name|t
index|]
operator|=
name|back
expr_stmt|;
name|back
operator|=
name|t
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|t
operator|=
name|front
operator|)
operator|>=
literal|0
condition|)
do|;
name|p
operator|->
name|places
operator|=
name|back
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|xc_compress_phase
argument_list|(
argument|output
argument_list|,
argument|bufsize
argument_list|,
argument|tokens
argument_list|,
argument|ntoken
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|xc
modifier|*
modifier|*
name|output
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|xc
modifier|*
modifier|*
name|tokens
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|output
argument_list|,
name|bufsize
operator|*
sizeof|sizeof
expr|*
name|output
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xc_npass0
condition|;
name|i
operator|++
control|)
name|xc_compress_phase1
argument_list|(
name|output
argument_list|,
name|tokens
argument_list|,
name|ntoken
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xc_npass1
condition|;
name|i
operator|++
control|)
name|xc_compress_phase1
argument_list|(
name|output
argument_list|,
name|tokens
argument_list|,
name|ntoken
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xc_compress_cleanup
argument_list|(
name|output
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|xc_compress_phase1
argument_list|(
name|output
argument_list|,
name|tokens
argument_list|,
name|ntoken
argument_list|,
name|flag
argument_list|)
specifier|register
expr|struct
name|xc
operator|*
operator|*
name|output
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|xc
modifier|*
modifier|*
name|tokens
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|xc
modifier|*
modifier|*
name|pp
decl_stmt|;
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Compress:"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pp
operator|=
name|tokens
expr_stmt|;
while|while
condition|(
name|pp
operator|<
name|tokens
operator|+
name|ntoken
condition|)
block|{
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
block|{
name|xc_ntoken_stat
operator|=
literal|0
expr_stmt|;
name|xc_ccount_stat
operator|=
literal|0
expr_stmt|;
name|xc_ncover_stat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"\n         "
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|" (%d"
argument_list|,
operator|(
operator|*
name|pp
operator|)
operator|->
name|length
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pp
operator|+=
name|xc_compress
argument_list|(
name|output
argument_list|,
name|pp
argument_list|,
name|flag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %dt %du %dc)"
argument_list|,
name|xc_ntoken_stat
argument_list|,
name|xc_ccount_stat
argument_list|,
name|xc_ncover_stat
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|verbose
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|xc_compress_cleanup
argument_list|(
name|output
argument_list|,
name|bufsize
argument_list|)
specifier|register
expr|struct
name|xc
operator|*
operator|*
name|output
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|xc
modifier|*
modifier|*
name|end
decl_stmt|;
comment|/* the previous output phase may have been interrupted */
name|qinsertq
argument_list|(
operator|&
name|xc_q0b
argument_list|,
operator|&
name|xc_q0a
argument_list|)
expr_stmt|;
for|for
control|(
name|end
operator|=
name|output
operator|+
name|bufsize
init|;
name|output
operator|<
name|end
condition|;
control|)
block|{
specifier|register
name|struct
name|xc
modifier|*
name|p
decl_stmt|;
specifier|register
name|length
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|*
name|output
operator|)
operator|==
literal|0
condition|)
block|{
name|output
operator|++
expr_stmt|;
continue|continue;
block|}
name|length
operator|=
name|p
operator|->
name|length
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|flag
condition|)
block|{ 		}
elseif|else
if|if
condition|(
name|p
operator|->
name|code
operator|>=
literal|0
condition|)
block|{
name|qinsert
argument_list|(
name|p
argument_list|,
operator|&
name|xc_q0b
argument_list|)
expr_stmt|;
name|p
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|ccount
operator|==
literal|0
condition|)
block|{
operator|*
name|output
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|ccount
operator|>=
name|thresh
argument_list|(
name|length
argument_list|)
ifndef|#
directive|ifndef
name|xc_weight
operator|||
name|wthreshp
argument_list|(
name|p
operator|->
name|weight
argument_list|,
name|length
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|p
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|ccount
operator|=
literal|0
expr_stmt|;
operator|*
name|output
operator|=
literal|0
expr_stmt|;
block|}
name|output
operator|+=
name|length
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|xc_compress
argument_list|(
argument|output
argument_list|,
argument|tokens
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|xc
modifier|*
modifier|*
name|output
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|xc
modifier|*
modifier|*
name|tokens
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|xc
modifier|*
modifier|*
name|pp
init|=
name|tokens
decl_stmt|;
specifier|register
name|struct
name|xc
modifier|*
name|p
init|=
operator|*
name|pp
operator|++
decl_stmt|;
name|int
name|length
init|=
name|p
operator|->
name|length
decl_stmt|;
name|int
name|threshold
init|=
name|thresh
argument_list|(
name|length
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|xc_weight
name|short
name|wthreshold
init|=
name|wthresh
argument_list|(
name|length
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|short
modifier|*
name|places
init|=
name|xc_places
index|[
name|length
index|]
decl_stmt|;
name|int
modifier|*
name|initial_scores
init|=
name|xc_initial_scores
index|[
name|length
index|]
decl_stmt|;
name|int
name|initial_score0
init|=
name|put_token_score
argument_list|(
name|length
argument_list|)
decl_stmt|;
do|do
block|{
name|int
name|score
decl_stmt|;
specifier|register
name|struct
name|xc_undo
modifier|*
name|undop
decl_stmt|;
name|int
name|ccount
decl_stmt|;
ifdef|#
directive|ifdef
name|STATS
name|int
name|ncover
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
name|ccount
operator|=
name|p
operator|->
name|ccount
expr_stmt|;
if|if
condition|(
operator|(
name|short
operator|)
name|ccount
operator|>=
name|p
operator|->
name|bcount
condition|)
continue|continue;
if|if
condition|(
name|p
operator|->
name|code
operator|>=
literal|0
operator|||
name|ccount
operator|>=
name|threshold
condition|)
name|score
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|xc_weight
elseif|else
if|if
condition|(
name|p
operator|->
name|weight
operator|>=
name|wthreshold
condition|)
comment|/* allow one fewer match than normal */
comment|/* XXX, should adjust for ccount */
name|score
operator|=
operator|-
name|tt
operator|.
name|tt_set_token_cost
expr_stmt|;
endif|#
directive|endif
else|else
name|score
operator|=
name|initial_scores
index|[
name|ccount
index|]
expr_stmt|;
name|undop
operator|=
name|xc_undo
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
name|ncover
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|p
operator|->
name|places
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|places
index|[
name|i
index|]
control|)
block|{
specifier|register
name|struct
name|xc
modifier|*
modifier|*
name|jp
decl_stmt|;
specifier|register
name|struct
name|xc
modifier|*
name|x
decl_stmt|;
specifier|register
name|struct
name|xc
modifier|*
modifier|*
name|ip
init|=
name|output
operator|+
name|i
decl_stmt|;
specifier|register
name|score0
operator|=
name|initial_score0
expr_stmt|;
name|struct
name|xc
modifier|*
modifier|*
name|iip
init|=
name|ip
operator|+
name|length
decl_stmt|;
name|struct
name|xc_undo
modifier|*
name|undop1
init|=
name|undop
decl_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
operator|*
operator|(
name|jp
operator|=
name|ip
operator|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|z
goto|;
while|while
condition|(
operator|--
name|jp
operator|>=
name|output
condition|)
if|if
condition|(
operator|(
name|x
operator|=
operator|*
name|jp
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|jp
operator|+
name|x
operator|->
name|length
operator|>
name|ip
condition|)
goto|goto
name|z
goto|;
break|break;
block|}
name|jp
operator|=
name|ip
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|jp
operator|<
name|iip
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|=
operator|*
name|jp
operator|)
operator|==
literal|0
condition|)
block|{
name|jp
operator|++
expr_stmt|;
continue|continue;
block|}
name|z
label|:
if|if
condition|(
name|x
operator|==
name|p
condition|)
goto|goto
name|undo
goto|;
ifdef|#
directive|ifdef
name|STATS
name|ncover
operator|++
expr_stmt|;
endif|#
directive|endif
name|undop
operator|->
name|pos
operator|=
name|jp
expr_stmt|;
name|undop
operator|->
name|val
operator|=
name|x
expr_stmt|;
name|undop
operator|++
expr_stmt|;
operator|*
name|jp
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|ccount
operator|--
expr_stmt|;
name|score_adjust
argument_list|(
name|score0
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|score0
operator|<
literal|0
operator|&&
name|flag
condition|)
goto|goto
name|undo
goto|;
name|jp
operator|+=
name|x
operator|->
name|length
expr_stmt|;
block|}
name|undop
operator|->
name|pos
operator|=
name|ip
expr_stmt|;
name|undop
operator|->
name|val
operator|=
literal|0
expr_stmt|;
name|undop
operator|++
expr_stmt|;
operator|*
name|ip
operator|=
name|p
expr_stmt|;
name|ccount
operator|++
expr_stmt|;
name|score
operator|+=
name|score0
expr_stmt|;
continue|continue;
name|undo
label|:
while|while
condition|(
operator|--
name|undop
operator|>=
name|undop1
condition|)
if|if
condition|(
operator|*
name|undop
operator|->
name|pos
operator|=
name|x
operator|=
name|undop
operator|->
name|val
condition|)
name|x
operator|->
name|ccount
operator|++
expr_stmt|;
name|undop
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|score
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|STATS
name|xc_ccount_stat
operator|+=
name|ccount
operator|-
name|p
operator|->
name|ccount
expr_stmt|;
name|xc_ntoken_stat
operator|++
expr_stmt|;
name|xc_ncover_stat
operator|+=
name|ncover
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|ccount
operator|=
name|ccount
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|xc_undo
modifier|*
name|u
init|=
name|xc_undo
decl_stmt|;
while|while
condition|(
operator|--
name|undop
operator|>=
name|u
condition|)
block|{
specifier|register
name|struct
name|xc
modifier|*
name|x
decl_stmt|;
if|if
condition|(
operator|*
name|undop
operator|->
name|pos
operator|=
name|x
operator|=
name|undop
operator|->
name|val
condition|)
name|x
operator|->
name|ccount
operator|++
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|p
operator|=
operator|*
name|pp
operator|++
operator|)
operator|!=
literal|0
condition|)
do|;
return|return
name|pp
operator|-
name|tokens
return|;
block|}
end_block

begin_expr_stmt
name|xcwrite
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|x
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|struct
name|xc
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
specifier|register
name|struct
name|xc
modifier|*
modifier|*
name|output
init|=
name|xc_output
operator|+
name|x
decl_stmt|;
if|if
condition|(
name|n
operator|<
name|tt
operator|.
name|tt_token_min
condition|)
block|{
call|(
modifier|*
name|tt
operator|.
name|tt_write
call|)
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|output
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|tt
operator|.
name|tt_putc
call|)
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|code
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|p
operator|->
name|ccount
operator|==
literal|0
condition|)
name|qinsert
argument_list|(
name|p
argument_list|,
operator|&
name|xc_q0a
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tt
operator|.
name|tt_put_token
call|)
argument_list|(
name|p
operator|->
name|code
argument_list|,
name|p
operator|->
name|string
argument_list|,
name|p
operator|->
name|length
argument_list|)
expr_stmt|;
name|wwntokuse
operator|++
expr_stmt|;
name|wwntoksave
operator|+=
name|put_token_score
argument_list|(
name|p
operator|->
name|length
argument_list|)
expr_stmt|;
name|i
operator|+=
name|p
operator|->
name|length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p1
operator|=
name|xc_q0a
operator|.
name|qback
operator|)
operator|!=
operator|&
name|xc_q0a
condition|)
block|{
name|p
operator|->
name|code
operator|=
name|p1
operator|->
name|code
expr_stmt|;
name|p1
operator|->
name|code
operator|=
operator|-
literal|1
expr_stmt|;
name|qinsert
argument_list|(
name|p1
argument_list|,
operator|&
name|xc_q1a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|p
operator|->
name|ccount
operator|==
literal|0
condition|)
name|qinsert
argument_list|(
name|p
argument_list|,
operator|&
name|xc_q0a
argument_list|)
expr_stmt|;
else|else
name|qinsert
argument_list|(
name|p
argument_list|,
operator|&
name|xc_q0b
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tt
operator|.
name|tt_set_token
call|)
argument_list|(
name|p
operator|->
name|code
argument_list|,
name|p
operator|->
name|string
argument_list|,
name|p
operator|->
name|length
argument_list|)
expr_stmt|;
name|wwntokdef
operator|++
expr_stmt|;
name|wwntoksave
operator|-=
name|tt
operator|.
name|tt_set_token_cost
expr_stmt|;
name|i
operator|+=
name|p
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|ccount
operator|--
expr_stmt|;
call|(
modifier|*
name|tt
operator|.
name|tt_write
call|)
argument_list|(
name|p
operator|->
name|string
argument_list|,
name|p
operator|->
name|length
argument_list|)
expr_stmt|;
name|wwntokbad
operator|++
expr_stmt|;
name|i
operator|+=
name|p
operator|->
name|length
expr_stmt|;
block|}
block|}
name|wwntokc
operator|+=
name|n
expr_stmt|;
block|}
end_block

begin_macro
name|xc_token_compare
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|xc
modifier|*
modifier|*
name|p1
decl_stmt|,
modifier|*
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|*
name|p2
operator|)
operator|->
name|bcount
operator|-
operator|(
operator|*
name|p1
operator|)
operator|->
name|bcount
return|;
block|}
end_block

end_unit

