begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// -*- C++ -*-
end_comment

begin_comment
comment|/* Copyright (C) 1989, 1990 Free Software Foundation, Inc.      Written by James Clark (jjc@jclark.uucp)  This file is part of groff.  groff is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  groff is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with groff; see the file LICENSE.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_comment
comment|/* I have tried to incorporate the changes needed for TeX 3.0 tfm files, but I haven't tested them. */
end_comment

begin_comment
comment|/* Groff requires more font metric information than TeX.  The reason for this is that TeX has separate Math Italic fonts, whereas groff uses normal italic fonts for math.  The two additional pieces of information required by groff correspond to the two arguments to the math_fit() macro in the Metafont programs for the CM fonts. In the case of a font for which math_fitting is false, these two arguments are normally ignored by Metafont. We need to get hold of these two parameters and put them in the groff font file.  We do this by loading this definition after cmbase when creating cm.base.  def ignore_math_fit(expr left_adjustment,right_adjustment) =  special "adjustment";  numspecial left_adjustment*16/designsize;  numspecial right_adjustment*16/designsize;  enddef;  This puts the two arguments to the math_fit macro into the gf file. (They will appear in the gf file immediately before the character to which they apply.)  We then create a gf file using this cm.base.  Then we run tfmtodit and specify this gf file with the -g option.  This need only be done for a font for which math_fitting is false; When it's true, the left_correction and subscript_correction should both be zero. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"lib.h"
end_include

begin_include
include|#
directive|include
file|"errarg.h"
end_include

begin_include
include|#
directive|include
file|"error.h"
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_include
include|#
directive|include
file|"cset.h"
end_include

begin_comment
comment|/* Values in the tfm file should be multiplied by this. */
end_comment

begin_define
define|#
directive|define
name|MULTIPLIER
value|1
end_define

begin_struct
struct|struct
name|char_info_word
block|{
name|unsigned
name|char
name|width_index
decl_stmt|;
name|char
name|height_index
decl_stmt|;
name|char
name|depth_index
decl_stmt|;
name|char
name|italic_index
decl_stmt|;
name|char
name|tag
decl_stmt|;
name|unsigned
name|char
name|remainder
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|lig_kern_command
block|{
name|unsigned
name|char
name|skip_byte
decl_stmt|;
name|unsigned
name|char
name|next_char
decl_stmt|;
name|unsigned
name|char
name|op_byte
decl_stmt|;
name|unsigned
name|char
name|remainder
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|class
name|tfm
block|{
name|int
name|bc
decl_stmt|;
name|int
name|ec
decl_stmt|;
name|int
name|nw
decl_stmt|;
name|int
name|nh
decl_stmt|;
name|int
name|nd
decl_stmt|;
name|int
name|ni
decl_stmt|;
name|int
name|nl
decl_stmt|;
name|int
name|nk
decl_stmt|;
name|int
name|np
decl_stmt|;
name|int
name|cs
decl_stmt|;
name|int
name|ds
decl_stmt|;
name|char_info_word
modifier|*
name|char_info
decl_stmt|;
name|int
modifier|*
name|width
decl_stmt|;
name|int
modifier|*
name|height
decl_stmt|;
name|int
modifier|*
name|depth
decl_stmt|;
name|int
modifier|*
name|italic
decl_stmt|;
name|lig_kern_command
modifier|*
name|lig_kern
decl_stmt|;
name|int
modifier|*
name|kern
decl_stmt|;
name|int
modifier|*
name|param
decl_stmt|;
name|public
label|:
name|tfm
argument_list|()
expr_stmt|;
operator|~
name|tfm
argument_list|()
expr_stmt|;
name|int
name|load
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
name|contains
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|int
name|get_width
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|int
name|get_height
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|int
name|get_depth
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|int
name|get_italic
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|int
name|get_param
parameter_list|(
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
name|int
name|get_checksum
parameter_list|()
function_decl|;
name|int
name|get_design_size
parameter_list|()
function_decl|;
name|int
name|get_lig
parameter_list|(
name|unsigned
name|char
parameter_list|,
name|unsigned
name|char
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
name|friend
name|class
name|kern_iterator
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|kern_iterator
block|{
name|tfm
modifier|*
name|t
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|public
label|:
name|kern_iterator
argument_list|(
name|tfm
operator|*
argument_list|)
expr_stmt|;
name|int
name|next
parameter_list|(
name|unsigned
name|char
modifier|*
name|c1
parameter_list|,
name|unsigned
name|char
modifier|*
name|c2
parameter_list|,
name|int
modifier|*
name|k
parameter_list|)
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|kern_iterator
operator|::
name|kern_iterator
argument_list|(
name|tfm
operator|*
name|p
argument_list|)
operator|:
name|t
argument_list|(
name|p
argument_list|)
operator|,
name|i
argument_list|(
operator|-
literal|1
argument_list|)
operator|,
name|c
argument_list|(
argument|t->bc
argument_list|)
block|{ }
name|int
name|kern_iterator
operator|::
name|next
argument_list|(
argument|unsigned char *c1
argument_list|,
argument|unsigned char *c2
argument_list|,
argument|int *k
argument_list|)
block|{
for|for
control|(
init|;
name|c
operator|<=
name|t
operator|->
name|ec
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|t
operator|->
name|char_info
index|[
name|c
operator|-
name|t
operator|->
name|bc
index|]
operator|.
name|tag
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|i
operator|=
name|t
operator|->
name|char_info
index|[
name|c
operator|-
name|t
operator|->
name|bc
index|]
operator|.
name|remainder
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|lig_kern
index|[
name|i
index|]
operator|.
name|skip_byte
operator|>
literal|128
condition|)
name|i
operator|=
operator|(
literal|256
operator|*
name|t
operator|->
name|lig_kern
index|[
name|i
index|]
operator|.
name|op_byte
operator|+
name|t
operator|->
name|lig_kern
index|[
name|i
index|]
operator|.
name|remainder
operator|)
expr_stmt|;
block|}
end_expr_stmt

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|skip
init|=
name|t
operator|->
name|lig_kern
index|[
name|i
index|]
operator|.
name|skip_byte
decl_stmt|;
if|if
condition|(
name|skip
operator|<=
literal|128
operator|&&
name|t
operator|->
name|lig_kern
index|[
name|i
index|]
operator|.
name|op_byte
operator|>=
literal|128
condition|)
block|{
operator|*
name|c1
operator|=
name|c
expr_stmt|;
operator|*
name|c2
operator|=
name|t
operator|->
name|lig_kern
index|[
name|i
index|]
operator|.
name|next_char
expr_stmt|;
operator|*
name|k
operator|=
name|t
operator|->
name|kern
index|[
literal|256
operator|*
operator|(
name|t
operator|->
name|lig_kern
index|[
name|i
index|]
operator|.
name|op_byte
operator|-
literal|128
operator|)
operator|+
name|t
operator|->
name|lig_kern
index|[
name|i
index|]
operator|.
name|remainder
index|]
expr_stmt|;
if|if
condition|(
name|skip
operator|==
literal|128
condition|)
block|{
name|c
operator|++
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|i
operator|+=
name|skip
operator|+
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|skip
operator|>=
literal|128
condition|)
break|break;
name|i
operator|+=
name|skip
operator|+
literal|1
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|i
operator|=
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}   return
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} 	   tfm
operator|::
name|tfm
argument_list|()
operator|:
name|char_info
argument_list|(
literal|0
argument_list|)
operator|,
name|width
argument_list|(
literal|0
argument_list|)
operator|,
name|height
argument_list|(
literal|0
argument_list|)
operator|,
name|depth
argument_list|(
literal|0
argument_list|)
operator|,
name|italic
argument_list|(
literal|0
argument_list|)
operator|,
name|lig_kern
argument_list|(
literal|0
argument_list|)
operator|,
name|kern
argument_list|(
literal|0
argument_list|)
operator|,
name|param
argument_list|(
literal|0
argument_list|)
block|{ }
name|int
name|tfm
operator|::
name|get_lig
argument_list|(
argument|unsigned char c1
argument_list|,
argument|unsigned char c2
argument_list|,
argument|unsigned char *cp
argument_list|)
block|{
if|if
condition|(
name|contains
argument_list|(
name|c1
argument_list|)
operator|&&
name|char_info
index|[
name|c1
operator|-
name|bc
index|]
operator|.
name|tag
operator|==
literal|1
condition|)
block|{
name|int
name|i
init|=
name|char_info
index|[
name|c1
operator|-
name|bc
index|]
operator|.
name|remainder
decl_stmt|;
if|if
condition|(
name|lig_kern
index|[
name|i
index|]
operator|.
name|skip_byte
operator|>
literal|128
condition|)
name|i
operator|=
literal|256
operator|*
name|lig_kern
index|[
name|i
index|]
operator|.
name|op_byte
operator|+
name|lig_kern
index|[
name|i
index|]
operator|.
name|remainder
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|skip
init|=
name|lig_kern
index|[
name|i
index|]
operator|.
name|skip_byte
decl_stmt|;
if|if
condition|(
name|skip
operator|>
literal|128
condition|)
break|break;
comment|// We are only interested in normal ligatures, for which
comment|// op_byte == 0.
if|if
condition|(
name|lig_kern
index|[
name|i
index|]
operator|.
name|op_byte
operator|==
literal|0
operator|&&
name|lig_kern
index|[
name|i
index|]
operator|.
name|next_char
operator|==
name|c2
condition|)
block|{
operator|*
name|cp
operator|=
name|lig_kern
index|[
name|i
index|]
operator|.
name|remainder
expr_stmt|;
return|return
literal|1
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|skip
operator|==
literal|128
condition|)
break|break;
end_if

begin_expr_stmt
name|i
operator|+=
name|skip
operator|+
literal|1
expr_stmt|;
end_expr_stmt

begin_return
unit|}   }
return|return
literal|0
return|;
end_return

begin_expr_stmt
unit|}  int
name|tfm
operator|::
name|contains
argument_list|(
argument|int i
argument_list|)
block|{
return|return
name|i
operator|>=
name|bc
operator|&&
name|i
operator|<=
name|ec
operator|&&
name|char_info
index|[
name|i
operator|-
name|bc
index|]
operator|.
name|width_index
operator|!=
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int
name|tfm
operator|::
name|get_width
argument_list|(
argument|int i
argument_list|)
block|{
return|return
name|width
index|[
name|char_info
index|[
name|i
operator|-
name|bc
index|]
operator|.
name|width_index
index|]
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int
name|tfm
operator|::
name|get_height
argument_list|(
argument|int i
argument_list|)
block|{
return|return
name|height
index|[
name|char_info
index|[
name|i
operator|-
name|bc
index|]
operator|.
name|height_index
index|]
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int
name|tfm
operator|::
name|get_depth
argument_list|(
argument|int i
argument_list|)
block|{
return|return
name|depth
index|[
name|char_info
index|[
name|i
operator|-
name|bc
index|]
operator|.
name|depth_index
index|]
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int
name|tfm
operator|::
name|get_italic
argument_list|(
argument|int i
argument_list|)
block|{
return|return
name|italic
index|[
name|char_info
index|[
name|i
operator|-
name|bc
index|]
operator|.
name|italic_index
index|]
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int
name|tfm
operator|::
name|get_param
argument_list|(
argument|int i
argument_list|,
argument|int *p
argument_list|)
block|{
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|i
operator|>
name|np
condition|)
return|return
literal|0
return|;
else|else
block|{
operator|*
name|p
operator|=
name|param
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  int
name|tfm
operator|::
name|get_checksum
argument_list|()
block|{
return|return
name|cs
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int
name|tfm
operator|::
name|get_design_size
argument_list|()
block|{
return|return
name|ds
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|tfm
operator|::
operator|~
name|tfm
argument_list|()
block|{
name|delete
name|char_info
block|;
name|delete
name|width
block|;
name|delete
name|height
block|;
name|delete
name|depth
block|;
name|delete
name|italic
block|;
name|delete
name|lig_kern
block|;
name|delete
name|kern
block|;
name|delete
name|param
block|; }
name|int
name|read2
argument_list|(
argument|unsigned char *&s
argument_list|)
block|{
name|int
name|n
block|;
name|n
operator|=
operator|*
name|s
operator|++
operator|<<
literal|8
block|;
name|n
operator||=
operator|*
name|s
operator|++
block|;
return|return
name|n
return|;
block|}
end_expr_stmt

begin_function
name|int
name|read4
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|&
name|s
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
operator|*
name|s
operator|++
operator|<<
literal|24
expr_stmt|;
name|n
operator||=
operator|*
name|s
operator|++
operator|<<
literal|16
expr_stmt|;
name|n
operator||=
operator|*
name|s
operator|++
operator|<<
literal|8
expr_stmt|;
name|n
operator||=
operator|*
name|s
operator|++
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_expr_stmt
name|int
name|tfm
operator|::
name|load
argument_list|(
argument|const char *file
argument_list|)
block|{
name|FILE
operator|*
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
block|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|error
argument_list|(
literal|"can't open `%1': %2"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|int
name|c1
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|c2
init|=
name|getc
argument_list|(
name|fp
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|c1
operator|==
name|EOF
operator|||
name|c2
operator|==
name|EOF
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"unexpected end of file on `%1'"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_if

begin_decl_stmt
name|int
name|lf
init|=
operator|(
name|c1
operator|<<
literal|8
operator|)
operator|+
name|c2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|toread
init|=
name|lf
operator|*
literal|4
operator|-
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|buf
init|=
name|new
name|unsigned
name|char
index|[
name|toread
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|toread
argument_list|,
name|fp
argument_list|)
operator|!=
name|toread
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|"unexpected end of file on `%1'"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"error on file `%1'"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|delete
name|buf
decl_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_if

begin_expr_stmt
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|lf
operator|<
literal|6
condition|)
block|{
name|error
argument_list|(
literal|"bad tfm file `%1': impossibly short"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|delete
name|buf
decl_stmt|;
return|return
literal|0
return|;
block|}
end_if

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|ptr
init|=
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lh
init|=
name|read2
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|bc
operator|=
name|read2
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ec
operator|=
name|read2
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nw
operator|=
name|read2
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nh
operator|=
name|read2
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nd
operator|=
name|read2
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ni
operator|=
name|read2
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nl
operator|=
name|read2
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nk
operator|=
name|read2
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ne
init|=
name|read2
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|np
operator|=
name|read2
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
literal|6
operator|+
name|lh
operator|+
operator|(
name|ec
operator|-
name|bc
operator|+
literal|1
operator|)
operator|+
name|nw
operator|+
name|nh
operator|+
name|nd
operator|+
name|ni
operator|+
name|nl
operator|+
name|nk
operator|+
name|ne
operator|+
name|np
operator|!=
name|lf
condition|)
block|{
name|error
argument_list|(
literal|"bad tfm file `%1': lengths do not sum"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|delete
name|buf
decl_stmt|;
return|return
literal|0
return|;
block|}
end_if

begin_if
if|if
condition|(
name|lh
operator|<
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"bad tfm file `%1': header too short"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|delete
name|buf
decl_stmt|;
return|return
literal|0
return|;
block|}
end_if

begin_expr_stmt
name|char_info
operator|=
name|new
name|char_info_word
index|[
name|ec
operator|-
name|bc
operator|+
literal|1
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|width
operator|=
name|new
name|int
index|[
name|nw
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|height
operator|=
name|new
name|int
index|[
name|nh
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|depth
operator|=
name|new
name|int
index|[
name|nd
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|italic
operator|=
name|new
name|int
index|[
name|ni
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|lig_kern
operator|=
name|new
name|lig_kern_command
index|[
name|nl
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|kern
operator|=
name|new
name|int
index|[
name|nk
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|param
operator|=
name|new
name|int
index|[
name|np
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|cs
operator|=
name|read4
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ds
operator|=
name|read4
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ptr
operator|+=
operator|(
name|lh
operator|-
literal|2
operator|)
operator|*
literal|4
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ec
operator|-
name|bc
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|char_info
index|[
name|i
index|]
operator|.
name|width_index
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
name|unsigned
name|char
name|tem
init|=
operator|*
name|ptr
operator|++
decl_stmt|;
name|char_info
index|[
name|i
index|]
operator|.
name|depth_index
operator|=
name|tem
operator|&
literal|0xf
expr_stmt|;
name|char_info
index|[
name|i
index|]
operator|.
name|height_index
operator|=
name|tem
operator|>>
literal|4
expr_stmt|;
name|tem
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
name|char_info
index|[
name|i
index|]
operator|.
name|italic_index
operator|=
name|tem
operator|>>
literal|2
expr_stmt|;
name|char_info
index|[
name|i
index|]
operator|.
name|tag
operator|=
name|tem
operator|&
literal|3
expr_stmt|;
name|char_info
index|[
name|i
index|]
operator|.
name|remainder
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
block|}
end_for

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nw
condition|;
name|i
operator|++
control|)
name|width
index|[
name|i
index|]
operator|=
name|read4
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
end_for

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nh
condition|;
name|i
operator|++
control|)
name|height
index|[
name|i
index|]
operator|=
name|read4
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
end_for

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nd
condition|;
name|i
operator|++
control|)
name|depth
index|[
name|i
index|]
operator|=
name|read4
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
end_for

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ni
condition|;
name|i
operator|++
control|)
name|italic
index|[
name|i
index|]
operator|=
name|read4
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
end_for

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nl
condition|;
name|i
operator|++
control|)
block|{
name|lig_kern
index|[
name|i
index|]
operator|.
name|skip_byte
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
name|lig_kern
index|[
name|i
index|]
operator|.
name|next_char
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
name|lig_kern
index|[
name|i
index|]
operator|.
name|op_byte
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
name|lig_kern
index|[
name|i
index|]
operator|.
name|remainder
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
block|}
end_for

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nk
condition|;
name|i
operator|++
control|)
name|kern
index|[
name|i
index|]
operator|=
name|read4
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
end_for

begin_expr_stmt
name|ptr
operator|+=
name|ne
operator|*
literal|4
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|np
condition|;
name|i
operator|++
control|)
name|param
index|[
name|i
index|]
operator|=
name|read4
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
end_for

begin_expr_stmt
name|assert
argument_list|(
name|ptr
operator|==
name|buf
operator|+
name|lf
operator|*
literal|4
operator|-
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|delete
name|buf
decl_stmt|;
end_decl_stmt

begin_return
return|return
literal|1
return|;
end_return

begin_macro
unit|}  class
name|gf
end_macro

begin_block
block|{
name|int
name|left
index|[
literal|256
index|]
decl_stmt|;
name|int
name|right
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|int
name|sread4
parameter_list|(
name|int
modifier|*
name|p
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
function_decl|;
specifier|static
name|int
name|uread3
parameter_list|(
name|int
modifier|*
name|p
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
function_decl|;
specifier|static
name|int
name|uread2
parameter_list|(
name|int
modifier|*
name|p
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
function_decl|;
specifier|static
name|int
name|skip
parameter_list|(
name|int
name|n
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
function_decl|;
name|public
label|:
name|gf
argument_list|()
expr_stmt|;
name|int
name|load
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
function_decl|;
name|int
name|get_left_adjustment
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|left
index|[
name|i
index|]
return|;
block|}
name|int
name|get_right_adjustment
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|right
index|[
name|i
index|]
return|;
block|}
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|gf
operator|::
name|gf
argument_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|left
index|[
name|i
index|]
operator|=
name|right
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|int
name|gf
operator|::
name|load
argument_list|(
argument|const char *file
argument_list|)
block|{   enum
block|{
name|paint_0
operator|=
literal|0
block|,
name|paint1
operator|=
literal|64
block|,
name|boc
operator|=
literal|67
block|,
name|boc1
operator|=
literal|68
block|,
name|eoc
operator|=
literal|69
block|,
name|skip0
operator|=
literal|70
block|,
name|skip1
operator|=
literal|71
block|,
name|new_row_0
operator|=
literal|74
block|,
name|xxx1
operator|=
literal|239
block|,
name|yyy
operator|=
literal|243
block|,
name|no_op
operator|=
literal|244
block|,
name|pre
operator|=
literal|247
block|,
name|post
operator|=
literal|248
block|,   }
block|;
name|int
name|got_an_adjustment
operator|=
literal|0
block|;
name|int
name|pending_adjustment
operator|=
literal|0
block|;
name|int
name|left_adj
block|,
name|right_adj
block|;
specifier|const
name|int
name|gf_id_byte
operator|=
literal|131
block|;
name|FILE
operator|*
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
block|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|error
argument_list|(
literal|"can't open `%1': %2"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|!=
name|pre
operator|||
name|getc
argument_list|(
name|fp
argument_list|)
operator|!=
name|gf_id_byte
condition|)
block|{
name|error
argument_list|(
literal|"bad gf file"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_if

begin_decl_stmt
name|int
name|n
init|=
name|getc
argument_list|(
name|fp
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|n
operator|==
name|EOF
condition|)
goto|goto
name|eof
goto|;
end_if

begin_if
if|if
condition|(
operator|!
name|skip
argument_list|(
name|n
argument_list|,
name|fp
argument_list|)
condition|)
goto|goto
name|eof
goto|;
end_if

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|op
init|=
name|getc
argument_list|(
name|fp
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|EOF
condition|)
goto|goto
name|eof
goto|;
if|if
condition|(
name|op
operator|==
name|post
condition|)
break|break;
if|if
condition|(
operator|(
name|op
operator|>=
name|paint_0
operator|&&
name|op
operator|<=
name|paint_0
operator|+
literal|63
operator|)
operator|||
operator|(
name|op
operator|>=
name|new_row_0
operator|&&
name|op
operator|<=
name|new_row_0
operator|+
literal|164
operator|)
condition|)
continue|continue;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|no_op
case|:
case|case
name|eoc
case|:
case|case
name|skip0
case|:
break|break;
case|case
name|paint1
case|:
case|case
name|skip1
case|:
if|if
condition|(
operator|!
name|skip
argument_list|(
literal|1
argument_list|,
name|fp
argument_list|)
condition|)
goto|goto
name|eof
goto|;
break|break;
case|case
name|paint1
operator|+
literal|1
case|:
case|case
name|skip1
operator|+
literal|1
case|:
if|if
condition|(
operator|!
name|skip
argument_list|(
literal|2
argument_list|,
name|fp
argument_list|)
condition|)
goto|goto
name|eof
goto|;
break|break;
case|case
name|paint1
operator|+
literal|2
case|:
case|case
name|skip1
operator|+
literal|2
case|:
if|if
condition|(
operator|!
name|skip
argument_list|(
literal|3
argument_list|,
name|fp
argument_list|)
condition|)
goto|goto
name|eof
goto|;
break|break;
case|case
name|boc
case|:
block|{
name|int
name|code
decl_stmt|;
if|if
condition|(
operator|!
name|sread4
argument_list|(
operator|&
name|code
argument_list|,
name|fp
argument_list|)
condition|)
goto|goto
name|eof
goto|;
if|if
condition|(
name|pending_adjustment
condition|)
block|{
name|pending_adjustment
operator|=
literal|0
expr_stmt|;
name|left
index|[
name|code
operator|&
literal|0377
index|]
operator|=
name|left_adj
expr_stmt|;
name|right
index|[
name|code
operator|&
literal|0377
index|]
operator|=
name|right_adj
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skip
argument_list|(
literal|20
argument_list|,
name|fp
argument_list|)
condition|)
goto|goto
name|eof
goto|;
break|break;
block|}
case|case
name|boc1
case|:
block|{
name|int
name|code
init|=
name|getc
argument_list|(
name|fp
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|EOF
condition|)
goto|goto
name|eof
goto|;
if|if
condition|(
name|pending_adjustment
condition|)
block|{
name|pending_adjustment
operator|=
literal|0
expr_stmt|;
name|left
index|[
name|code
index|]
operator|=
name|left_adj
expr_stmt|;
name|right
index|[
name|code
index|]
operator|=
name|right_adj
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|skip
argument_list|(
literal|4
argument_list|,
name|fp
argument_list|)
condition|)
goto|goto
name|eof
goto|;
break|break;
block|}
case|case
name|xxx1
case|:
block|{
name|int
name|len
init|=
name|getc
argument_list|(
name|fp
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
name|EOF
condition|)
goto|goto
name|eof
goto|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|fp
argument_list|)
operator|!=
name|len
condition|)
goto|goto
name|eof
goto|;
if|if
condition|(
name|len
operator|==
literal|10
comment|/* strlen("adjustment") */
operator|&&
name|memcmp
argument_list|(
name|buf
argument_list|,
literal|"adjustment"
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|c
init|=
name|getc
argument_list|(
name|fp
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|yyy
condition|)
block|{
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|sread4
argument_list|(
operator|&
name|left_adj
argument_list|,
name|fp
argument_list|)
condition|)
goto|goto
name|eof
goto|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|yyy
condition|)
block|{
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|sread4
argument_list|(
operator|&
name|right_adj
argument_list|,
name|fp
argument_list|)
condition|)
goto|goto
name|eof
goto|;
name|got_an_adjustment
operator|=
literal|1
expr_stmt|;
name|pending_adjustment
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
case|case
name|xxx1
operator|+
literal|1
case|:
if|if
condition|(
operator|!
name|uread2
argument_list|(
operator|&
name|n
argument_list|,
name|fp
argument_list|)
operator|||
operator|!
name|skip
argument_list|(
name|n
argument_list|,
name|fp
argument_list|)
condition|)
goto|goto
name|eof
goto|;
break|break;
case|case
name|xxx1
operator|+
literal|2
case|:
if|if
condition|(
operator|!
name|uread3
argument_list|(
operator|&
name|n
argument_list|,
name|fp
argument_list|)
operator|||
operator|!
name|skip
argument_list|(
name|n
argument_list|,
name|fp
argument_list|)
condition|)
goto|goto
name|eof
goto|;
break|break;
case|case
name|xxx1
operator|+
literal|3
case|:
if|if
condition|(
operator|!
name|sread4
argument_list|(
operator|&
name|n
argument_list|,
name|fp
argument_list|)
operator|||
operator|!
name|skip
argument_list|(
name|n
argument_list|,
name|fp
argument_list|)
condition|)
goto|goto
name|eof
goto|;
break|break;
case|case
name|yyy
case|:
if|if
condition|(
operator|!
name|skip
argument_list|(
literal|4
argument_list|,
name|fp
argument_list|)
condition|)
goto|goto
name|eof
goto|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"unrecognized opcode `%1'"
argument_list|,
name|op
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_for

begin_if
if|if
condition|(
operator|!
name|got_an_adjustment
condition|)
name|warning
argument_list|(
literal|"no adjustment specials found in gf file"
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
literal|1
return|;
end_return

begin_label
name|eof
label|:
end_label

begin_expr_stmt
name|error
argument_list|(
literal|"unexpected end of file"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_expr_stmt
unit|}  int
name|gf
operator|::
name|sread4
argument_list|(
argument|int *p
argument_list|,
argument|FILE *fp
argument_list|)
block|{
operator|*
name|p
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
block|;
if|if
condition|(
operator|*
name|p
operator|>=
literal|128
condition|)
operator|*
name|p
operator|-=
literal|256
expr_stmt|;
operator|*
name|p
operator|<<=
literal|8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|p
operator||=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|p
operator|<<=
literal|8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|p
operator||=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|p
operator|<<=
literal|8
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|p
operator||=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|!
name|ferror
argument_list|(
name|fp
argument_list|)
operator|&&
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  int
name|gf
operator|::
name|uread3
argument_list|(
argument|int *p
argument_list|,
argument|FILE *fp
argument_list|)
block|{
operator|*
name|p
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
block|;
operator|*
name|p
operator|<<=
literal|8
block|;
operator|*
name|p
operator||=
name|getc
argument_list|(
name|fp
argument_list|)
block|;
operator|*
name|p
operator|<<=
literal|8
block|;
operator|*
name|p
operator||=
name|getc
argument_list|(
name|fp
argument_list|)
block|;
return|return
operator|!
name|ferror
argument_list|(
name|fp
argument_list|)
operator|&&
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int
name|gf
operator|::
name|uread2
argument_list|(
argument|int *p
argument_list|,
argument|FILE *fp
argument_list|)
block|{
operator|*
name|p
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
block|;
operator|*
name|p
operator|<<=
literal|8
block|;
operator|*
name|p
operator||=
name|getc
argument_list|(
name|fp
argument_list|)
block|;
return|return
operator|!
name|ferror
argument_list|(
name|fp
argument_list|)
operator|&&
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int
name|gf
operator|::
name|skip
argument_list|(
argument|int n
argument_list|,
argument|FILE *fp
argument_list|)
block|{
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
if|if
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
literal|0
return|;
end_expr_stmt

begin_return
return|return
literal|1
return|;
end_return

begin_macro
unit|}   struct
name|char_list
end_macro

begin_block
block|{
name|char
modifier|*
name|ch
decl_stmt|;
name|char_list
modifier|*
name|next
decl_stmt|;
name|char_list
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|char_list
operator|*
operator|=
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|char_list
operator|::
name|char_list
argument_list|(
specifier|const
name|char
operator|*
name|s
argument_list|,
name|char_list
operator|*
name|p
argument_list|)
operator|:
name|ch
argument_list|(
name|strsave
argument_list|(
name|s
argument_list|)
argument_list|)
operator|,
name|next
argument_list|(
argument|p
argument_list|)
block|{ }
name|int
name|read_map
argument_list|(
argument|const char *file
argument_list|,
argument|char_list **table
argument_list|)
block|{
name|FILE
operator|*
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
block|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|error
argument_list|(
literal|"can't open `%1': %2"
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_expr_stmt

begin_for
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|table
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
end_for

begin_decl_stmt
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lineno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_while
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|int
argument_list|(
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
name|char
modifier|*
name|ptr
init|=
name|buf
decl_stmt|;
while|while
condition|(
name|csspace
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'\0'
operator|||
operator|*
name|ptr
operator|==
literal|'#'
condition|)
continue|continue;
name|ptr
operator|=
name|strtok
argument_list|(
name|ptr
argument_list|,
literal|" \n\t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
continue|continue;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|ptr
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"%1:%2: bad map file"
argument_list|,
name|file
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
literal|255
condition|)
block|{
name|error
argument_list|(
literal|"%1:%2: code out of range"
argument_list|,
name|file
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ptr
operator|=
name|strtok
argument_list|(
literal|0
argument_list|,
literal|" \n\t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
name|error
argument_list|(
literal|"%1:%2: missing names"
argument_list|,
name|file
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
init|;
name|ptr
condition|;
name|ptr
operator|=
name|strtok
argument_list|(
literal|0
argument_list|,
literal|" \n\t"
argument_list|)
control|)
name|table
index|[
name|n
index|]
operator|=
name|new
name|char_list
argument_list|(
name|ptr
argument_list|,
name|table
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
end_while

begin_expr_stmt
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
literal|1
return|;
end_return

begin_comment
unit|}
comment|/* Every character that can participate in a ligature appears in the lig_chars table. `ch' gives the full-name of the character, `name' gives the groff name of the character, `i' gives its index in the encoding, which is filled in later  (-1 if it does not appear). */
end_comment

begin_block
unit|struct
block|{
specifier|const
name|char
modifier|*
name|ch
decl_stmt|;
name|int
name|i
decl_stmt|;
block|}
end_block

begin_expr_stmt
name|lig_chars
index|[]
operator|=
block|{
literal|"f"
block|,
operator|-
literal|1
block|,
literal|"i"
block|,
operator|-
literal|1
block|,
literal|"l"
block|,
operator|-
literal|1
block|,
literal|"ff"
block|,
operator|-
literal|1
block|,
literal|"fi"
block|,
operator|-
literal|1
block|,
literal|"fl"
block|,
operator|-
literal|1
block|,
literal|"Fi"
block|,
operator|-
literal|1
block|,
literal|"Fl"
block|,
operator|-
literal|1
block|, }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Indices into lig_chars[].
end_comment

begin_enum
enum|enum
block|{
name|CH_f
block|,
name|CH_i
block|,
name|CH_l
block|,
name|CH_ff
block|,
name|CH_fi
block|,
name|CH_fl
block|,
name|CH_ffi
block|,
name|CH_ffl
block|}
enum|;
end_enum

begin_comment
comment|// Each possible ligature appears in this table.
end_comment

begin_struct
struct|struct
block|{
name|unsigned
name|char
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|res
decl_stmt|;
specifier|const
name|char
modifier|*
name|ch
decl_stmt|;
block|}
name|lig_table
index|[]
init|=
block|{
name|CH_f
block|,
name|CH_f
block|,
name|CH_ff
block|,
literal|"ff"
block|,
name|CH_f
block|,
name|CH_i
block|,
name|CH_fi
block|,
literal|"fi"
block|,
name|CH_f
block|,
name|CH_l
block|,
name|CH_fl
block|,
literal|"fl"
block|,
name|CH_ff
block|,
name|CH_i
block|,
name|CH_ffi
block|,
literal|"ffi"
block|,
name|CH_ff
block|,
name|CH_l
block|,
name|CH_ffl
block|,
literal|"ffl"
block|,   }
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|int
name|special_flag
init|=
literal|0
decl_stmt|;
name|int
name|skewchar
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|opt
decl_stmt|;
specifier|const
name|char
modifier|*
name|gf_file
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"svg:k:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'g'
case|:
name|gf_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|special_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|n
init|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|ptr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|==
literal|0
operator|&&
name|ptr
operator|==
name|optarg
operator|)
operator|||
operator|*
name|ptr
operator|!=
literal|'\0'
operator|||
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|UCHAR_MAX
condition|)
name|error
argument_list|(
literal|"invalid skewchar"
argument_list|)
expr_stmt|;
else|else
name|skewchar
operator|=
operator|(
name|int
operator|)
name|n
expr_stmt|;
break|break;
block|}
case|case
literal|'v'
case|:
block|{
specifier|extern
specifier|const
name|char
modifier|*
name|version_string
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tfmtodit version %s\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'?'
case|:
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
name|EOF
case|:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|-
name|optind
operator|!=
literal|3
condition|)
name|usage
argument_list|()
expr_stmt|;
name|gf
name|g
decl_stmt|;
if|if
condition|(
name|gf_file
condition|)
block|{
if|if
condition|(
operator|!
name|g
operator|.
name|load
argument_list|(
name|gf_file
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
specifier|const
name|char
modifier|*
name|tfm_file
init|=
name|argv
index|[
name|optind
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|map_file
init|=
name|argv
index|[
name|optind
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|font_file
init|=
name|argv
index|[
name|optind
operator|+
literal|2
index|]
decl_stmt|;
name|tfm
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|.
name|load
argument_list|(
name|tfm_file
argument_list|)
condition|)
return|return
literal|1
return|;
name|char_list
modifier|*
name|table
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|read_map
argument_list|(
name|map_file
argument_list|,
name|table
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|freopen
argument_list|(
name|font_file
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"can't open `%1' for writing: %2"
argument_list|,
name|font_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|printf
argument_list|(
literal|"name %s\n"
argument_list|,
name|font_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|special_flag
condition|)
name|fputs
argument_list|(
literal|"special\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|char
modifier|*
name|internal_name
init|=
name|strsave
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|internal_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|4
operator|&&
name|strcmp
argument_list|(
name|internal_name
operator|+
name|len
operator|-
literal|4
argument_list|,
literal|".tfm"
argument_list|)
operator|==
literal|0
condition|)
name|internal_name
index|[
name|len
operator|-
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
name|char
modifier|*
name|s
init|=
name|strrchr
argument_list|(
name|internal_name
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"internalname %s\n"
argument_list|,
name|s
condition|?
name|s
operator|+
literal|1
else|:
name|internal_name
argument_list|)
expr_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|get_param
argument_list|(
literal|2
argument_list|,
operator|&
name|n
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"spacewidth %d\n"
argument_list|,
name|n
operator|*
name|MULTIPLIER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|.
name|get_param
argument_list|(
literal|1
argument_list|,
operator|&
name|n
argument_list|)
operator|&&
name|n
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"slant %f\n"
argument_list|,
name|atan2
argument_list|(
name|n
operator|/
name|double
argument_list|(
literal|1
operator|<<
literal|20
argument_list|)
argument_list|,
literal|1.0
argument_list|)
operator|*
literal|180.0
operator|/
name|M_PI
argument_list|)
expr_stmt|;
name|int
name|xheight
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|.
name|get_param
argument_list|(
literal|5
argument_list|,
operator|&
name|xheight
argument_list|)
condition|)
name|xheight
operator|=
literal|0
expr_stmt|;
name|int
name|i
decl_stmt|;
comment|// Print the list of ligatures.
comment|// First find the indices of each character that can participate in
comment|// a ligature.
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|lig_chars
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|lig_chars
index|[
literal|0
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
for|for
control|(
name|char_list
modifier|*
name|p
init|=
name|table
index|[
name|i
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|lig_chars
index|[
name|j
index|]
operator|.
name|ch
argument_list|,
name|p
operator|->
name|ch
argument_list|)
operator|==
literal|0
condition|)
name|lig_chars
index|[
name|j
index|]
operator|.
name|i
operator|=
name|i
expr_stmt|;
comment|// For each possible ligature, if its participants all exist,
comment|// and it appears as a ligature in the tfm file, include in
comment|// the list of ligatures.
name|int
name|started
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|lig_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|lig_table
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|i1
init|=
name|lig_chars
index|[
name|lig_table
index|[
name|i
index|]
operator|.
name|c1
index|]
operator|.
name|i
decl_stmt|;
name|int
name|i2
init|=
name|lig_chars
index|[
name|lig_table
index|[
name|i
index|]
operator|.
name|c2
index|]
operator|.
name|i
decl_stmt|;
name|int
name|r
init|=
name|lig_chars
index|[
name|lig_table
index|[
name|i
index|]
operator|.
name|res
index|]
operator|.
name|i
decl_stmt|;
if|if
condition|(
name|i1
operator|>=
literal|0
operator|&&
name|i2
operator|>=
literal|0
operator|&&
name|r
operator|>=
literal|0
condition|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|get_lig
argument_list|(
name|i1
argument_list|,
name|i2
argument_list|,
operator|&
name|c
argument_list|)
operator|&&
name|c
operator|==
name|r
condition|)
block|{
if|if
condition|(
operator|!
name|started
condition|)
block|{
name|started
operator|=
literal|1
expr_stmt|;
name|fputs
argument_list|(
literal|"ligatures"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|lig_table
index|[
name|i
index|]
operator|.
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|started
condition|)
name|fputs
argument_list|(
literal|" 0\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"checksum %d\n"
argument_list|,
name|t
operator|.
name|get_checksum
argument_list|()
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"designsize %d\n"
argument_list|,
name|t
operator|.
name|get_design_size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now print out the kerning information.
name|int
name|had_kern
init|=
literal|0
decl_stmt|;
name|kern_iterator
name|iter
argument_list|(
operator|&
name|t
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|k
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|next
argument_list|(
operator|&
name|c1
argument_list|,
operator|&
name|c2
argument_list|,
operator|&
name|k
argument_list|)
condition|)
if|if
condition|(
name|c2
operator|!=
name|skewchar
condition|)
block|{
name|k
operator|*=
name|MULTIPLIER
expr_stmt|;
name|char_list
modifier|*
name|q
init|=
name|table
index|[
name|c2
index|]
decl_stmt|;
for|for
control|(
name|char_list
modifier|*
name|p1
init|=
name|table
index|[
name|c1
index|]
init|;
name|p1
condition|;
name|p1
operator|=
name|p1
operator|->
name|next
control|)
for|for
control|(
name|char_list
modifier|*
name|p2
init|=
name|q
init|;
name|p2
condition|;
name|p2
operator|=
name|p2
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|had_kern
condition|)
block|{
name|printf
argument_list|(
literal|"kernpairs\n"
argument_list|)
expr_stmt|;
name|had_kern
operator|=
literal|1
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s %s %d\n"
argument_list|,
name|p1
operator|->
name|ch
argument_list|,
name|p2
operator|->
name|ch
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"charset\n"
argument_list|)
expr_stmt|;
name|char_list
name|unnamed
argument_list|(
literal|"---"
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|t
operator|.
name|contains
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|char_list
modifier|*
name|p
init|=
name|table
index|[
name|i
index|]
condition|?
name|table
index|[
name|i
index|]
else|:
operator|&
name|unnamed
decl_stmt|;
name|int
name|m
index|[
literal|6
index|]
decl_stmt|;
name|m
index|[
literal|0
index|]
operator|=
name|t
operator|.
name|get_width
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|m
index|[
literal|1
index|]
operator|=
name|t
operator|.
name|get_height
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|m
index|[
literal|2
index|]
operator|=
name|t
operator|.
name|get_depth
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|m
index|[
literal|3
index|]
operator|=
name|t
operator|.
name|get_italic
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|m
index|[
literal|4
index|]
operator|=
name|g
operator|.
name|get_left_adjustment
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|m
index|[
literal|5
index|]
operator|=
name|g
operator|.
name|get_right_adjustment
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\t%d"
argument_list|,
name|p
operator|->
name|ch
argument_list|,
name|m
index|[
literal|0
index|]
operator|*
name|MULTIPLIER
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
name|int
argument_list|(
sizeof|sizeof
argument_list|(
name|m
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|m
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|m
index|[
name|j
index|]
operator|!=
literal|0
condition|)
break|break;
for|for
control|(
name|int
name|k
init|=
literal|1
init|;
name|k
operator|<=
name|j
condition|;
name|k
operator|++
control|)
name|printf
argument_list|(
literal|",%d"
argument_list|,
name|m
index|[
name|k
index|]
operator|*
name|MULTIPLIER
argument_list|)
expr_stmt|;
name|int
name|type
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|m
index|[
literal|2
index|]
operator|>
literal|0
condition|)
name|type
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|m
index|[
literal|1
index|]
operator|>
name|xheight
condition|)
name|type
operator|+=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"\t%d\t%04o\n"
argument_list|,
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|p
operator|->
name|next
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|printf
argument_list|(
literal|"%s\t\"\n"
argument_list|,
name|p
operator|->
name|ch
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-sv] [-g gf_file] [-k skewchar] tfm_file map_file font\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

