begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)sccs.c	8.1 (Berkeley) 6/6/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_comment
comment|/* **  SCCS.C -- human-oriented front end to the SCCS system. ** **	Without trying to add any functionality to speak of, this **	program tries to make SCCS a little more accessible to human **	types.  The main thing it does is automatically put the **	string "SCCS/s." on the front of names.  Also, it has a **	couple of things that are designed to shorten frequent **	combinations, e.g., "delget" which expands to a "delta" **	and a "get". ** **	This program can also function as a setuid front end. **	To do this, you should copy the source, renaming it to **	whatever you want, e.g., "syssccs".  Change any defaults **	in the program (e.g., syssccs might default -d to **	"/usr/src/sys").  Then recompile and put the result **	as setuid to whomever you want.  In this mode, sccs **	knows to not run setuid for certain programs in order **	to preserve security, and so forth. ** **	Usage: **		sccs [flags] command [args] ** **	Flags: **		-d<dir><dir> represents a directory to search **				out of.  It should be a full pathname **				for general usage.  E.g., if<dir> is **				"/usr/src/sys", then a reference to the **				file "dev/bio.c" becomes a reference to **				"/usr/src/sys/dev/bio.c". **		-p<path>	prepends<path> to the final component **				of the pathname.  By default, this is **				"SCCS".  For example, in the -d example **				above, the path then gets modified to **				"/usr/src/sys/dev/SCCS/s.bio.c".  In **				more common usage (without the -d flag), **				"prog.c" would get modified to **				"SCCS/s.prog.c".  In both cases, the **				"s." gets automatically prepended. **		-r		run as the real user. ** **	Commands: **		admin, **		get, **		delta, **		rmdel, **		cdc, **		etc.		Straight out of SCCS; only difference **				is that pathnames get modified as **				described above. **		enter		Front end doing "sccs admin -i<name><name>" **		create		Macro for "enter" followed by "get". **		edit		Macro for "get -e". **		unedit		Removes a file being edited, knowing **				about p-files, etc. **		delget		Macro for "delta" followed by "get". **		deledit		Macro for "delta" followed by "get -e". **		branch		Macro for "get -b -e", followed by "delta **				-s -n", followd by "get -e -t -g". **		diffs		"diff" the specified version of files **				and the checked-out version. **		print		Macro for "prs -e" followed by "get -p -m". **		tell		List what files are being edited. **		info		Print information about files being edited. **		clean		Remove all files that can be **				regenerated from SCCS files. **		check		Like info, but return exit status, for **				use in makefiles. **		fix		Remove a top delta& reedit, but save **				the previous changes in that delta. ** **	Compilation Flags: **		UIDUSER -- determine who the user is by looking at the **			uid rather than the login name -- for machines **			where SCCS gets the user in this way. **		SCCSDIR -- if defined, forces the -d flag to take on **			this value.  This is so that the setuid **			aspects of this program cannot be abused. **			This flag also disables the -p flag. **		SCCSPATH -- the default for the -p flag. **		MYNAME -- the title this program should print when it **			gives error messages. ** **	Compilation Instructions: **		cc -O -n -s sccs.c **		The flags listed above can be -D defined to simplify **			recompilation for variant versions. ** **	Author: **		Eric Allman, UCB/INGRES **		Copyright 1980 Regents of the University of California */
end_comment

begin_escape
end_escape

begin_comment
comment|/*******************  Configuration Information  ********************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SCCSPATH
end_ifndef

begin_define
define|#
directive|define
name|SCCSPATH
value|"SCCS"
end_define

begin_comment
comment|/* pathname in which to find s-files */
end_comment

begin_endif
endif|#
directive|endif
endif|NOT SCCSPATH
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MYNAME
end_ifndef

begin_define
define|#
directive|define
name|MYNAME
value|"sccs"
end_define

begin_comment
comment|/* name used for printing errors */
end_comment

begin_endif
endif|#
directive|endif
endif|NOT MYNAME
end_endif

begin_comment
comment|/****************  End of Configuration Information  ****************/
end_comment

begin_escape
end_escape

begin_typedef
typedef|typedef
name|char
name|bool
typedef|;
end_typedef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|bitset
parameter_list|(
name|bit
parameter_list|,
name|word
parameter_list|)
value|((bool) ((bit)& (word)))
end_define

begin_struct
struct|struct
name|sccsprog
block|{
name|char
modifier|*
name|sccsname
decl_stmt|;
comment|/* name of SCCS routine */
name|short
name|sccsoper
decl_stmt|;
comment|/* opcode, see below */
name|short
name|sccsflags
decl_stmt|;
comment|/* flags, see below */
name|char
modifier|*
name|sccspath
decl_stmt|;
comment|/* pathname of binary implementing */
block|}
struct|;
end_struct

begin_comment
comment|/* values for sccsoper */
end_comment

begin_define
define|#
directive|define
name|PROG
value|0
end_define

begin_comment
comment|/* call a program */
end_comment

begin_define
define|#
directive|define
name|CMACRO
value|1
end_define

begin_comment
comment|/* command substitution macro */
end_comment

begin_define
define|#
directive|define
name|FIX
value|2
end_define

begin_comment
comment|/* fix a delta */
end_comment

begin_define
define|#
directive|define
name|CLEAN
value|3
end_define

begin_comment
comment|/* clean out recreatable files */
end_comment

begin_define
define|#
directive|define
name|UNEDIT
value|4
end_define

begin_comment
comment|/* unedit a file */
end_comment

begin_define
define|#
directive|define
name|SHELL
value|5
end_define

begin_comment
comment|/* call a shell file (like PROG) */
end_comment

begin_define
define|#
directive|define
name|DIFFS
value|6
end_define

begin_comment
comment|/* diff between sccs& file out */
end_comment

begin_define
define|#
directive|define
name|DODIFF
value|7
end_define

begin_comment
comment|/* internal call to diff program */
end_comment

begin_define
define|#
directive|define
name|ENTER
value|8
end_define

begin_comment
comment|/* enter new files */
end_comment

begin_comment
comment|/* bits for sccsflags */
end_comment

begin_define
define|#
directive|define
name|NO_SDOT
value|0001
end_define

begin_comment
comment|/* no s. on front of args */
end_comment

begin_define
define|#
directive|define
name|REALUSER
value|0002
end_define

begin_comment
comment|/* protected (e.g., admin) */
end_comment

begin_comment
comment|/* modes for the "clean", "info", "check" ops */
end_comment

begin_define
define|#
directive|define
name|CLEANC
value|0
end_define

begin_comment
comment|/* clean command */
end_comment

begin_define
define|#
directive|define
name|INFOC
value|1
end_define

begin_comment
comment|/* info command */
end_comment

begin_define
define|#
directive|define
name|CHECKC
value|2
end_define

begin_comment
comment|/* check command */
end_comment

begin_define
define|#
directive|define
name|TELLC
value|3
end_define

begin_comment
comment|/* give list of files being edited */
end_comment

begin_comment
comment|/* **  Description of commands known to this program. **	First argument puts the command into a class.  Second arg is **	info regarding treatment of this command.  Third arg is a **	list of flags this command accepts from macros, etc.  Fourth **	arg is the pathname of the implementing program, or the **	macro definition, or the arg to a sub-algorithm. */
end_comment

begin_decl_stmt
name|struct
name|sccsprog
name|SccsProg
index|[]
init|=
block|{
literal|"admin"
block|,
name|PROG
block|,
name|REALUSER
block|,
name|_PATH_SCCSADMIN
block|,
literal|"cdc"
block|,
name|PROG
block|,
literal|0
block|,
name|_PATH_SCCSRMDEL
block|,
literal|"comb"
block|,
name|PROG
block|,
literal|0
block|,
name|_PATH_SCCSCOMB
block|,
literal|"delta"
block|,
name|PROG
block|,
literal|0
block|,
name|_PATH_SCCSDELTA
block|,
literal|"get"
block|,
name|PROG
block|,
literal|0
block|,
name|_PATH_SCCSGET
block|,
literal|"help"
block|,
name|PROG
block|,
name|NO_SDOT
block|,
name|_PATH_SCCSHELP
block|,
literal|"prs"
block|,
name|PROG
block|,
literal|0
block|,
name|_PATH_SCCSPRS
block|,
literal|"prt"
block|,
name|PROG
block|,
literal|0
block|,
name|_PATH_SCCSPRT
block|,
literal|"rmdel"
block|,
name|PROG
block|,
name|REALUSER
block|,
name|_PATH_SCCSRMDEL
block|,
literal|"val"
block|,
name|PROG
block|,
literal|0
block|,
name|_PATH_SCCSVAL
block|,
literal|"what"
block|,
name|PROG
block|,
name|NO_SDOT
block|,
name|_PATH_SCCSWHAT
block|,
literal|"sccsdiff"
block|,
name|SHELL
block|,
name|REALUSER
block|,
name|_PATH_SCCSDIFF
block|,
literal|"edit"
block|,
name|CMACRO
block|,
name|NO_SDOT
block|,
literal|"get -e"
block|,
literal|"delget"
block|,
name|CMACRO
block|,
name|NO_SDOT
block|,
literal|"delta:mysrp/get:ixbeskcl -t"
block|,
literal|"deledit"
block|,
name|CMACRO
block|,
name|NO_SDOT
block|,
literal|"delta:mysrp -n/get:ixbskcl -e -t -g"
block|,
literal|"fix"
block|,
name|FIX
block|,
name|NO_SDOT
block|,
name|NULL
block|,
literal|"clean"
block|,
name|CLEAN
block|,
name|REALUSER
operator||
name|NO_SDOT
block|,
operator|(
name|char
operator|*
operator|)
name|CLEANC
block|,
literal|"info"
block|,
name|CLEAN
block|,
name|REALUSER
operator||
name|NO_SDOT
block|,
operator|(
name|char
operator|*
operator|)
name|INFOC
block|,
literal|"check"
block|,
name|CLEAN
block|,
name|REALUSER
operator||
name|NO_SDOT
block|,
operator|(
name|char
operator|*
operator|)
name|CHECKC
block|,
literal|"tell"
block|,
name|CLEAN
block|,
name|REALUSER
operator||
name|NO_SDOT
block|,
operator|(
name|char
operator|*
operator|)
name|TELLC
block|,
literal|"unedit"
block|,
name|UNEDIT
block|,
name|NO_SDOT
block|,
name|NULL
block|,
literal|"diffs"
block|,
name|DIFFS
block|,
name|NO_SDOT
operator||
name|REALUSER
block|,
name|NULL
block|,
literal|"-diff"
block|,
name|DODIFF
block|,
name|NO_SDOT
operator||
name|REALUSER
block|,
name|_PATH_SCCSBDIFF
block|,
literal|"print"
block|,
name|CMACRO
block|,
literal|0
block|,
literal|"prs -e/get -p -m -s"
block|,
literal|"branch"
block|,
name|CMACRO
block|,
name|NO_SDOT
block|,
literal|"get:ixrc -e -b/delta: -s -n -ybranch-place-holder/get:pl -e -t -g"
block|,
literal|"enter"
block|,
name|ENTER
block|,
name|NO_SDOT
block|,
name|NULL
block|,
literal|"create"
block|,
name|CMACRO
block|,
name|NO_SDOT
block|,
literal|"enter/get:ixbeskcl -t"
block|,
name|NULL
block|,
operator|-
literal|1
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* one line from a p-file */
end_comment

begin_struct
struct|struct
name|pfile
block|{
name|char
modifier|*
name|p_osid
decl_stmt|;
comment|/* old SID */
name|char
modifier|*
name|p_nsid
decl_stmt|;
comment|/* new SID */
name|char
modifier|*
name|p_user
decl_stmt|;
comment|/* user who did edit */
name|char
modifier|*
name|p_date
decl_stmt|;
comment|/* date of get */
name|char
modifier|*
name|p_time
decl_stmt|;
comment|/* time of get */
name|char
modifier|*
name|p_aux
decl_stmt|;
comment|/* extra info at end */
block|}
struct|;
end_struct

begin_decl_stmt
name|char
modifier|*
name|SccsPath
init|=
name|SCCSPATH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname of SCCS files */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSDIR
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|SccsDir
init|=
name|SCCSDIR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* directory to begin search from */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|SccsDir
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|MyName
index|[]
init|=
name|MYNAME
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name used in messages */
end_comment

begin_decl_stmt
name|int
name|OutFile
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* override output file for commands */
end_comment

begin_decl_stmt
name|bool
name|RealUser
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, running as real user */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|bool
name|Debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* turn on tracing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|V6
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
endif|V6
end_endif

begin_decl_stmt
name|char
modifier|*
name|gstrcat
argument_list|()
decl_stmt|,
modifier|*
name|strcat
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|gstrncat
argument_list|()
decl_stmt|,
modifier|*
name|strncat
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|gstrcpy
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FBUFSIZ
value|BUFSIZ
end_define

begin_define
define|#
directive|define
name|PFILELG
value|120
end_define

begin_escape
end_escape

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|struct
name|sccsprog
modifier|*
name|lookup
parameter_list|()
function_decl|;
specifier|register
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|V6
ifndef|#
directive|ifndef
name|SCCSDIR
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
name|char
name|buf
index|[
name|FBUFSIZ
index|]
decl_stmt|;
comment|/* pull "SccsDir" out of the environment (possibly) */
name|p
operator|=
name|getenv
argument_list|(
literal|"PROJECTDIR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|SccsDir
operator|=
name|p
expr_stmt|;
else|else
block|{
name|pw
operator|=
name|getpwnam
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"user %s does not exist"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
name|gstrcpy
argument_list|(
name|buf
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|gstrcat
argument_list|(
name|buf
argument_list|,
literal|"/src"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|gstrcpy
argument_list|(
name|buf
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|gstrcat
argument_list|(
name|buf
argument_list|,
literal|"/source"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"project %s has no source!"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
block|}
name|SccsDir
operator|=
name|buf
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|SCCSDIR
endif|#
directive|endif
endif|V6
comment|/* 	**  Detect and decode flags intended for this program. 	*/
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [flags] command [flags]\n"
argument_list|,
name|MyName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|p
operator|=
operator|*
operator|++
name|argv
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'-'
condition|)
break|break;
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'r'
case|:
comment|/* run as real user */
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|RealUser
operator|++
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|SCCSDIR
case|case
literal|'p'
case|:
comment|/* path of sccs files */
name|SccsPath
operator|=
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|SccsPath
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|argv
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|SccsPath
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* directory to search from */
name|SccsDir
operator|=
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|SccsDir
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|argv
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|SccsDir
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'T'
case|:
comment|/* trace */
name|Debug
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|usrerr
argument_list|(
literal|"unknown option -%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|SccsPath
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|SccsPath
operator|=
literal|"."
expr_stmt|;
block|}
name|i
operator|=
name|command
argument_list|(
name|argv
argument_list|,
name|FALSE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  COMMAND -- look up and perform a command ** **	This routine is the guts of this program.  Given an **	argument vector, it looks up the "command" (argv[0]) **	in the configuration table and does the necessary stuff. ** **	Parameters: **		argv -- an argument vector to process. **		forkflag -- if set, fork before executing the command. **		editflag -- if set, only include flags listed in the **			sccsklets field of the command descriptor. **		arg0 -- a space-seperated list of arguments to insert **			before argv. ** **	Returns: **		zero -- command executed ok. **		else -- error status. ** **	Side Effects: **		none. */
end_comment

begin_macro
name|command
argument_list|(
argument|argv
argument_list|,
argument|forkflag
argument_list|,
argument|arg0
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|forkflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|arg0
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sccsprog
modifier|*
name|cmd
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|FBUFSIZ
index|]
decl_stmt|;
specifier|extern
name|struct
name|sccsprog
modifier|*
name|lookup
parameter_list|()
function_decl|;
name|char
modifier|*
name|nav
index|[
literal|1000
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|np
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|extern
name|bool
name|unedit
parameter_list|()
function_decl|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|makefile
parameter_list|()
function_decl|;
name|char
modifier|*
name|editchs
decl_stmt|;
specifier|extern
name|char
modifier|*
name|tail
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
block|{
name|printf
argument_list|(
literal|"command:\n\t\"%s\"\n"
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|argv
init|;
operator|*
name|np
operator|!=
name|NULL
condition|;
name|np
operator|++
control|)
name|printf
argument_list|(
literal|"\t\"%s\"\n"
argument_list|,
operator|*
name|np
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	**  Copy arguments. 	**	Copy from arg0& if necessary at most one arg 	**	from argv[0]. 	*/
name|np
operator|=
name|ap
operator|=
operator|&
name|nav
index|[
literal|1
index|]
expr_stmt|;
name|editchs
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|arg0
operator|,
name|q
operator|=
name|buf
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'/'
condition|;
control|)
block|{
operator|*
name|np
operator|++
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
name|editchs
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
operator|*
name|np
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|==
name|NULL
condition|)
operator|*
name|np
operator|++
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
comment|/* 	**  Look up command. 	**	At this point, *ap is the command name. 	*/
name|cmd
operator|=
name|lookup
argument_list|(
operator|*
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"Unknown command \"%s\""
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_USAGE
operator|)
return|;
block|}
comment|/* 	**  Copy remaining arguments doing editing as appropriate. 	*/
for|for
control|(
init|;
operator|*
name|argv
operator|!=
name|NULL
condition|;
name|argv
operator|++
control|)
block|{
name|p
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|editchs
operator|==
name|NULL
operator|||
name|index
argument_list|(
name|editchs
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
operator|!=
name|NULL
condition|)
operator|*
name|np
operator|++
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|NO_SDOT
argument_list|,
name|cmd
operator|->
name|sccsflags
argument_list|)
condition|)
name|p
operator|=
name|makefile
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|np
operator|++
operator|=
name|p
expr_stmt|;
block|}
block|}
operator|*
name|np
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  Interpret operation associated with this command. 	*/
switch|switch
condition|(
name|cmd
operator|->
name|sccsoper
condition|)
block|{
case|case
name|SHELL
case|:
comment|/* call a shell file */
operator|*
name|ap
operator|=
name|cmd
operator|->
name|sccspath
expr_stmt|;
operator|*
operator|--
name|ap
operator|=
literal|"sh"
expr_stmt|;
name|rval
operator|=
name|callprog
argument_list|(
name|_PATH_BSHELL
argument_list|,
name|cmd
operator|->
name|sccsflags
argument_list|,
name|ap
argument_list|,
name|forkflag
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROG
case|:
comment|/* call an sccs prog */
name|rval
operator|=
name|callprog
argument_list|(
name|cmd
operator|->
name|sccspath
argument_list|,
name|cmd
operator|->
name|sccsflags
argument_list|,
name|ap
argument_list|,
name|forkflag
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMACRO
case|:
comment|/* command macro */
comment|/* step through& execute each part of the macro */
for|for
control|(
name|p
operator|=
name|cmd
operator|->
name|sccspath
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'/'
condition|)
name|p
operator|++
expr_stmt|;
name|rval
operator|=
name|command
argument_list|(
operator|&
name|ap
index|[
literal|1
index|]
argument_list|,
operator|*
name|p
operator|!=
literal|'\0'
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
literal|0
condition|)
break|break;
block|}
break|break;
case|case
name|FIX
case|:
comment|/* fix a delta */
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|ap
index|[
literal|1
index|]
argument_list|,
literal|"-r"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"-r flag needed for fix command"
argument_list|)
expr_stmt|;
name|rval
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
comment|/* get the version with all changes */
name|rval
operator|=
name|command
argument_list|(
operator|&
name|ap
index|[
literal|1
index|]
argument_list|,
name|TRUE
argument_list|,
literal|"get -k"
argument_list|)
expr_stmt|;
comment|/* now remove that version from the s-file */
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
name|rval
operator|=
name|command
argument_list|(
operator|&
name|ap
index|[
literal|1
index|]
argument_list|,
name|TRUE
argument_list|,
literal|"rmdel:r"
argument_list|)
expr_stmt|;
comment|/* and edit the old version (but don't clobber new vers) */
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
name|rval
operator|=
name|command
argument_list|(
operator|&
name|ap
index|[
literal|2
index|]
argument_list|,
name|FALSE
argument_list|,
literal|"get -e -g"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLEAN
case|:
name|rval
operator|=
name|clean
argument_list|(
operator|(
name|int
operator|)
name|cmd
operator|->
name|sccspath
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNEDIT
case|:
for|for
control|(
name|argv
operator|=
name|np
operator|=
operator|&
name|ap
index|[
literal|1
index|]
init|;
operator|*
name|argv
operator|!=
name|NULL
condition|;
name|argv
operator|++
control|)
block|{
if|if
condition|(
name|unedit
argument_list|(
operator|*
name|argv
argument_list|)
condition|)
operator|*
name|np
operator|++
operator|=
operator|*
name|argv
expr_stmt|;
block|}
operator|*
name|np
operator|=
name|NULL
expr_stmt|;
comment|/* get all the files that we unedited successfully */
if|if
condition|(
name|np
operator|>
operator|&
name|ap
index|[
literal|1
index|]
condition|)
name|rval
operator|=
name|command
argument_list|(
operator|&
name|ap
index|[
literal|1
index|]
argument_list|,
name|FALSE
argument_list|,
literal|"get"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIFFS
case|:
comment|/* diff between s-file& edit file */
comment|/* find the end of the flag arguments */
for|for
control|(
name|np
operator|=
operator|&
name|ap
index|[
literal|1
index|]
init|;
operator|*
name|np
operator|!=
name|NULL
operator|&&
operator|*
operator|*
name|np
operator|==
literal|'-'
condition|;
name|np
operator|++
control|)
continue|continue;
name|argv
operator|=
name|np
expr_stmt|;
comment|/* for each file, do the diff */
name|p
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|np
operator|!=
name|NULL
condition|)
block|{
comment|/* messy, but we need a null terminated argv */
operator|*
name|argv
operator|=
operator|*
name|np
operator|++
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
name|dodiff
argument_list|(
name|ap
argument_list|,
name|tail
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
name|rval
operator|=
name|i
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|p
expr_stmt|;
block|}
break|break;
case|case
name|DODIFF
case|:
comment|/* internal diff call */
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|ap
init|;
operator|*
name|np
operator|!=
name|NULL
condition|;
name|np
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|np
operator|)
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
operator|(
operator|*
name|np
operator|)
index|[
literal|1
index|]
operator|==
literal|'C'
condition|)
operator|(
operator|*
name|np
operator|)
index|[
literal|1
index|]
operator|=
literal|'c'
expr_stmt|;
block|}
comment|/* insert "-" argument */
name|np
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|np
index|[
literal|0
index|]
operator|=
name|np
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|np
index|[
operator|-
literal|1
index|]
operator|=
literal|"-"
expr_stmt|;
comment|/* execute the diff program of choice */
ifndef|#
directive|ifndef
name|V6
name|execvp
argument_list|(
literal|"diff"
argument_list|,
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|execv
argument_list|(
name|cmd
operator|->
name|sccspath
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
literal|"cannot exec %s"
argument_list|,
name|cmd
operator|->
name|sccspath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
case|case
name|ENTER
case|:
comment|/* enter new sccs files */
comment|/* skip over flag arguments */
for|for
control|(
name|np
operator|=
operator|&
name|ap
index|[
literal|1
index|]
init|;
operator|*
name|np
operator|!=
name|NULL
operator|&&
operator|*
operator|*
name|np
operator|==
literal|'-'
condition|;
name|np
operator|++
control|)
continue|continue;
name|argv
operator|=
name|np
expr_stmt|;
comment|/* do an admin for each file */
name|p
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|np
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"\n%s:\n"
argument_list|,
operator|*
name|np
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"-i"
argument_list|)
expr_stmt|;
name|gstrcat
argument_list|(
name|buf
argument_list|,
operator|*
name|np
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|ap
index|[
literal|0
index|]
operator|=
name|buf
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|tail
argument_list|(
operator|*
name|np
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|rval
operator|=
name|command
argument_list|(
name|ap
argument_list|,
name|TRUE
argument_list|,
literal|"admin"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|gstrcat
argument_list|(
name|buf
argument_list|,
name|tail
argument_list|(
operator|*
name|np
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
operator|*
name|np
argument_list|,
name|buf
argument_list|)
operator|>=
literal|0
condition|)
name|unlink
argument_list|(
operator|*
name|np
argument_list|)
expr_stmt|;
block|}
name|np
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|syserr
argument_list|(
literal|"oper %d"
argument_list|,
name|cmd
operator|->
name|sccsoper
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"command: rval=%d\n"
argument_list|,
name|rval
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  LOOKUP -- look up an SCCS command name. ** **	Parameters: **		name -- the name of the command to look up. ** **	Returns: **		ptr to command descriptor for this command. **		NULL if no such entry. ** **	Side Effects: **		none. */
end_comment

begin_function
name|struct
name|sccsprog
modifier|*
name|lookup
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|sccsprog
modifier|*
name|cmd
decl_stmt|;
for|for
control|(
name|cmd
operator|=
name|SccsProg
init|;
name|cmd
operator|->
name|sccsname
operator|!=
name|NULL
condition|;
name|cmd
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
operator|->
name|sccsname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|cmd
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  CALLPROG -- call a program ** **	Used to call the SCCS programs. ** **	Parameters: **		progpath -- pathname of the program to call. **		flags -- status flags from the command descriptors. **		argv -- an argument vector to pass to the program. **		forkflag -- if true, fork before calling, else just **			exec. ** **	Returns: **		The exit status of the program. **		Nothing if forkflag == FALSE. ** **	Side Effects: **		Can exit if forkflag == FALSE. */
end_comment

begin_macro
name|callprog
argument_list|(
argument|progpath
argument_list|,
argument|flags
argument_list|,
argument|argv
argument_list|,
argument|forkflag
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|progpath
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|forkflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|wpid
decl_stmt|;
specifier|auto
name|int
name|st
decl_stmt|;
specifier|register
name|int
name|sigcode
decl_stmt|;
specifier|register
name|int
name|coredumped
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|sigmsg
decl_stmt|;
name|char
name|sigmsgbuf
index|[
literal|10
operator|+
literal|1
index|]
decl_stmt|;
comment|/* "Signal 127" + terminating '\0' */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
block|{
name|printf
argument_list|(
literal|"callprog:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|argv
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\t\"%s\"\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|*
name|argv
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	**  Fork if appropriate. 	*/
if|if
condition|(
name|forkflag
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"Forking\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"cannot fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|wpid
operator|=
name|wait
argument_list|(
operator|&
name|st
argument_list|)
operator|)
operator|!=
operator|-
literal|1
operator|&&
name|wpid
operator|!=
name|i
condition|)
empty_stmt|;
if|if
condition|(
operator|(
name|sigcode
operator|=
name|st
operator|&
literal|0377
operator|)
operator|==
literal|0
condition|)
name|st
operator|=
operator|(
name|st
operator|>>
literal|8
operator|)
operator|&
literal|0377
expr_stmt|;
else|else
block|{
name|coredumped
operator|=
name|sigcode
operator|&
literal|0200
expr_stmt|;
name|sigcode
operator|&=
literal|0177
expr_stmt|;
if|if
condition|(
name|sigcode
operator|!=
name|SIGINT
operator|&&
name|sigcode
operator|!=
name|SIGPIPE
condition|)
block|{
if|if
condition|(
name|sigcode
operator|<
name|NSIG
condition|)
name|sigmsg
operator|=
name|sys_siglist
index|[
name|sigcode
index|]
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|sigmsgbuf
argument_list|,
literal|"Signal %d"
argument_list|,
name|sigcode
argument_list|)
expr_stmt|;
name|sigmsg
operator|=
name|sigmsgbuf
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sccs: %s: %s%s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|sigmsg
argument_list|,
name|coredumped
condition|?
literal|" - core dumped"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|st
operator|=
name|EX_SOFTWARE
expr_stmt|;
block|}
if|if
condition|(
name|OutFile
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|OutFile
argument_list|)
expr_stmt|;
name|OutFile
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|st
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|OutFile
operator|>=
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"callprog: setting stdout w/o forking"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
comment|/* set protection as appropriate */
if|if
condition|(
name|bitset
argument_list|(
name|REALUSER
argument_list|,
name|flags
argument_list|)
condition|)
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* change standard input& output if needed */
if|if
condition|(
name|OutFile
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|OutFile
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|OutFile
argument_list|)
expr_stmt|;
block|}
comment|/* call real SCCS program */
name|execv
argument_list|(
name|progpath
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
literal|"cannot execute %s"
argument_list|,
name|progpath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MAKEFILE -- make filename of SCCS file ** **	If the name passed is already the name of an SCCS file, **	just return it.  Otherwise, munge the name into the name **	of the actual SCCS file. ** **	There are cases when it is not clear what you want to **	do.  For example, if SccsPath is an absolute pathname **	and the name given is also an absolute pathname, we go **	for SccsPath (& only use the last component of the name **	passed) -- this is important for security reasons (if **	sccs is being used as a setuid front end), but not **	particularly intuitive. ** **	Parameters: **		name -- the file name to be munged. ** **	Returns: **		The pathname of the sccs file. **		NULL on error. ** **	Side Effects: **		none. */
end_comment

begin_function
name|char
modifier|*
name|makefile
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
literal|3
operator|*
name|FBUFSIZ
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
specifier|extern
name|bool
name|safepath
parameter_list|()
function_decl|;
specifier|extern
name|bool
name|isdir
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|rindex
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|name
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
comment|/* 	**  Check to see that the path is "safe", i.e., that we 	**  are not letting some nasty person use the setuid part 	**  of this program to look at or munge some presumably 	**  hidden files. 	*/
if|if
condition|(
name|SccsDir
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
operator|!
name|safepath
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	**  Create the base pathname. 	*/
comment|/* first the directory part */
if|if
condition|(
name|SccsDir
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"./"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|gstrcpy
argument_list|(
name|buf
argument_list|,
name|SccsDir
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|gstrcat
argument_list|(
name|buf
argument_list|,
literal|"/"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|gstrcpy
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* then the head of the pathname */
name|gstrncat
argument_list|(
name|buf
argument_list|,
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
operator|&
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
index|]
expr_stmt|;
comment|/* now copy the final part of the name, in case useful */
name|gstrcpy
argument_list|(
name|q
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* so is it useful? */
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"s."
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|isdir
argument_list|(
name|buf
argument_list|)
condition|)
block|{
comment|/* sorry, no; copy the SCCS pathname& the "s." */
name|gstrcpy
argument_list|(
name|q
argument_list|,
name|SccsPath
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|gstrcat
argument_list|(
name|buf
argument_list|,
literal|"/s."
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* and now the end of the name */
name|gstrcat
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* if i haven't changed it, why did I do all this? */
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
name|p
operator|=
name|name
expr_stmt|;
else|else
block|{
comment|/* but if I have, squirrel it away */
name|p
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"Sccs: no mem"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  ISDIR -- return true if the argument is a directory. ** **	Parameters: **		name -- the pathname of the file to check. ** **	Returns: **		TRUE if 'name' is a directory, FALSE otherwise. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|isdir
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
return|return
operator|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SAFEPATH -- determine whether a pathname is "safe" ** **	"Safe" pathnames only allow you to get deeper into the **	directory structure, i.e., full pathnames and ".." are **	not allowed. ** **	Parameters: **		p -- the name to check. ** **	Returns: **		TRUE -- if the path is safe. **		FALSE -- if the path is not safe. ** **	Side Effects: **		Prints a message if the path is not safe. */
end_comment

begin_function
name|bool
name|safepath
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'/'
condition|)
block|{
while|while
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"../"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".."
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|p
operator|++
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"You may not use full pathnames or \"..\"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  CLEAN -- clean out recreatable files ** **	Any file for which an "s." file exists but no "p." file **	exists in the current directory is purged. ** **	Parameters: **		mode -- tells whether this came from a "clean", "info", or **			"check" command. **		argv -- the rest of the argument vector. ** **	Returns: **		none. ** **	Side Effects: **		Removes files in the current directory. **		Prints information regarding files being edited. **		Exits if a "check" command. */
end_comment

begin_macro
name|clean
argument_list|(
argument|mode
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|direct
modifier|*
name|dir
decl_stmt|;
name|char
name|buf
index|[
name|FBUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|bufend
decl_stmt|;
specifier|register
name|DIR
modifier|*
name|dirp
decl_stmt|;
specifier|register
name|char
modifier|*
name|basefile
decl_stmt|;
name|bool
name|gotedit
decl_stmt|;
name|bool
name|gotpfent
decl_stmt|;
name|FILE
modifier|*
name|pfp
decl_stmt|;
name|bool
name|nobranch
init|=
name|FALSE
decl_stmt|;
specifier|extern
name|struct
name|pfile
modifier|*
name|getpfent
parameter_list|()
function_decl|;
specifier|register
name|struct
name|pfile
modifier|*
name|pf
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
specifier|extern
name|char
modifier|*
name|username
parameter_list|()
function_decl|;
name|char
modifier|*
name|usernm
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|subdir
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cmdname
decl_stmt|;
comment|/* 	**  Process the argv 	*/
name|cmdname
operator|=
operator|*
name|argv
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|argv
init|;
operator|*
operator|++
name|ap
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|ap
operator|==
literal|'-'
condition|)
block|{
comment|/* we have a flag */
switch|switch
condition|(
operator|(
operator|*
name|ap
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
name|nobranch
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
operator|(
operator|*
name|ap
operator|)
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
name|usernm
operator|=
operator|&
operator|(
operator|*
name|ap
operator|)
index|[
literal|2
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|!=
name|NULL
operator|&&
name|ap
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
name|usernm
operator|=
operator|*
operator|++
name|ap
expr_stmt|;
else|else
name|usernm
operator|=
name|username
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|subdir
operator|!=
name|NULL
condition|)
name|usrerr
argument_list|(
literal|"too many args"
argument_list|)
expr_stmt|;
else|else
name|subdir
operator|=
operator|*
name|ap
expr_stmt|;
block|}
block|}
comment|/* 	**  Find and open the SCCS directory. 	*/
name|gstrcpy
argument_list|(
name|buf
argument_list|,
name|SccsDir
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|gstrcat
argument_list|(
name|buf
argument_list|,
literal|"/"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|subdir
operator|!=
name|NULL
condition|)
block|{
name|gstrcat
argument_list|(
name|buf
argument_list|,
name|subdir
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|gstrcat
argument_list|(
name|buf
argument_list|,
literal|"/"
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gstrcat
argument_list|(
name|buf
argument_list|,
name|SccsPath
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|bufend
operator|=
operator|&
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
index|]
expr_stmt|;
name|dirp
operator|=
name|opendir
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"cannot open %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_NOINPUT
operator|)
return|;
block|}
comment|/* 	**  Scan the SCCS directory looking for s. files. 	**	gotedit tells whether we have tried to clean any 	**		files that are being edited. 	*/
name|gotedit
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|dir
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|dir
operator|->
name|d_name
argument_list|,
literal|"s."
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* got an s. file -- see if the p. file exists */
name|gstrcpy
argument_list|(
name|bufend
argument_list|,
literal|"/p."
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|basefile
operator|=
name|bufend
operator|+
literal|3
expr_stmt|;
name|gstrcpy
argument_list|(
name|basefile
argument_list|,
operator|&
name|dir
operator|->
name|d_name
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		**  open and scan the p-file. 		**	'gotpfent' tells if we have found a valid p-file 		**		entry. 		*/
name|pfp
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|gotpfent
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|pfp
operator|!=
name|NULL
condition|)
block|{
comment|/* the file exists -- report it's contents */
while|while
condition|(
operator|(
name|pf
operator|=
name|getpfent
argument_list|(
name|pfp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nobranch
operator|&&
name|isbranch
argument_list|(
name|pf
operator|->
name|p_nsid
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|usernm
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|usernm
argument_list|,
name|pf
operator|->
name|p_user
argument_list|)
operator|!=
literal|0
operator|&&
name|mode
operator|!=
name|CLEANC
condition|)
continue|continue;
name|gotedit
operator|=
name|TRUE
expr_stmt|;
name|gotpfent
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|TELLC
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|basefile
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"%12s: being edited: "
argument_list|,
name|basefile
argument_list|)
expr_stmt|;
name|putpfent
argument_list|(
name|pf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
block|}
comment|/* the s. file exists and no p. file exists -- unlink the g-file */
if|if
condition|(
name|mode
operator|==
name|CLEANC
operator|&&
operator|!
name|gotpfent
condition|)
block|{
name|char
name|unlinkbuf
index|[
name|FBUFSIZ
index|]
decl_stmt|;
name|gstrcpy
argument_list|(
name|unlinkbuf
argument_list|,
operator|&
name|dir
operator|->
name|d_name
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|unlinkbuf
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|unlinkbuf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* cleanup& report results */
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gotedit
operator|&&
name|mode
operator|==
name|INFOC
condition|)
block|{
name|printf
argument_list|(
literal|"Nothing being edited"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nobranch
condition|)
name|printf
argument_list|(
literal|" (on trunk)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usernm
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" by %s\n"
argument_list|,
name|usernm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|CHECKC
condition|)
name|exit
argument_list|(
name|gotedit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_OK
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  ISBRANCH -- is the SID a branch? ** **	Parameters: **		sid -- the sid to check. ** **	Returns: **		TRUE if the sid represents a branch. **		FALSE otherwise. ** **	Side Effects: **		none. */
end_comment

begin_macro
name|isbranch
argument_list|(
argument|sid
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sid
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|dots
decl_stmt|;
name|dots
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sid
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
name|dots
operator|++
expr_stmt|;
if|if
condition|(
name|dots
operator|>
literal|1
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  UNEDIT -- unedit a file ** **	Checks to see that the current user is actually editting **	the file and arranges that s/he is not editting it. ** **	Parameters: **		fn -- the name of the file to be unedited. ** **	Returns: **		TRUE -- if the file was successfully unedited. **		FALSE -- if the file was not unedited for some **			reason. ** **	Side Effects: **		fn is removed **		entries are removed from pfile. */
end_comment

begin_function
name|bool
name|unedit
parameter_list|(
name|fn
parameter_list|)
name|char
modifier|*
name|fn
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|pfp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|pfn
decl_stmt|;
specifier|static
name|char
name|tfn
index|[]
init|=
name|_PATH_TMP
decl_stmt|;
name|FILE
modifier|*
name|tfp
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|bool
name|delete
init|=
name|FALSE
decl_stmt|;
name|bool
name|others
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|myname
decl_stmt|;
specifier|extern
name|char
modifier|*
name|username
parameter_list|()
function_decl|;
name|struct
name|pfile
modifier|*
name|pent
decl_stmt|;
specifier|extern
name|struct
name|pfile
modifier|*
name|getpfent
parameter_list|()
function_decl|;
name|char
name|buf
index|[
name|PFILELG
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|makefile
argument_list|()
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|,
modifier|*
name|tail
argument_list|()
decl_stmt|;
comment|/* make "s." filename& find the trailing component */
name|pfn
operator|=
name|makefile
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfn
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|q
operator|=
name|rindex
argument_list|(
name|pfn
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|q
operator|=
operator|&
name|pfn
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|q
index|[
literal|1
index|]
operator|!=
literal|'s'
operator|||
name|q
index|[
literal|2
index|]
operator|!=
literal|'.'
condition|)
block|{
name|usrerr
argument_list|(
literal|"bad file name \"%s\""
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* turn "s." into "p."& try to open it */
operator|*
operator|++
name|q
operator|=
literal|'p'
expr_stmt|;
name|pfp
operator|=
name|fopen
argument_list|(
name|pfn
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%12s: not being edited\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* create temp file for editing p-file */
name|mktemp
argument_list|(
name|tfn
argument_list|)
expr_stmt|;
name|tfp
operator|=
name|fopen
argument_list|(
name|tfn
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"cannot create \"%s\""
argument_list|,
name|tfn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
comment|/* figure out who I am */
name|myname
operator|=
name|username
argument_list|()
expr_stmt|;
comment|/* 	**  Copy p-file to temp file, doing deletions as needed. 	*/
while|while
condition|(
operator|(
name|pent
operator|=
name|getpfent
argument_list|(
name|pfp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pent
operator|->
name|p_user
argument_list|,
name|myname
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* a match */
name|delete
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* output it again */
name|putpfent
argument_list|(
name|pent
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
name|others
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Before changing anything, make sure we can remove 	 * the file in question (assuming it exists). 	 */
if|if
condition|(
name|delete
condition|)
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
name|cp
operator|=
name|tail
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
comment|/* 			 * This is wrong, but the rest of the program 			 * has built in assumptions about "." as well, 			 * so why make unedit a special case? 			 */
if|if
condition|(
name|access
argument_list|(
literal|"."
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|bad
label|:
name|printf
argument_list|(
literal|"%12s: can't remove\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tfn
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
comment|/* do final cleanup */
if|if
condition|(
name|others
condition|)
block|{
comment|/* copy it back (perhaps it should be linked?) */
if|if
condition|(
name|freopen
argument_list|(
name|tfn
argument_list|,
literal|"r"
argument_list|,
name|tfp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"cannot reopen \"%s\""
argument_list|,
name|tfn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freopen
argument_list|(
name|pfn
argument_list|,
literal|"w"
argument_list|,
name|pfp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"cannot create \"%s\""
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|tfp
argument_list|)
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* it's empty -- remove it */
name|unlink
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tfn
argument_list|)
expr_stmt|;
comment|/* actually remove the g-file */
if|if
condition|(
name|delete
condition|)
block|{
comment|/* 		 * Since we've checked above, we can 		 * use the return from unlink to 		 * determine if the file existed or not. 		 */
if|if
condition|(
name|unlink
argument_list|(
name|cp
argument_list|)
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"%12s: removed\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%12s: not being edited by you\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  DODIFF -- diff an s-file against a g-file ** **	Parameters: **		getv -- argv for the 'get' command. **		gfile -- name of the g-file to diff against. ** **	Returns: **		Result of get. ** **	Side Effects: **		none. */
end_comment

begin_macro
name|dodiff
argument_list|(
argument|getv
argument_list|,
argument|gfile
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|getv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|gfile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pipev
index|[
literal|2
index|]
decl_stmt|;
name|int
name|rval
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|pid
decl_stmt|;
specifier|auto
name|int
name|st
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|sig_t
name|osig
decl_stmt|;
name|printf
argument_list|(
literal|"\n------- %s -------\n"
argument_list|,
name|gfile
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* create context for diff to run in */
if|if
condition|(
name|pipe
argument_list|(
name|pipev
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"dodiff: pipe failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"dodiff: fork failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
block|{
comment|/* in parent; run get */
name|OutFile
operator|=
name|pipev
index|[
literal|1
index|]
expr_stmt|;
name|close
argument_list|(
name|pipev
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rval
operator|=
name|command
argument_list|(
operator|&
name|getv
index|[
literal|1
index|]
argument_list|,
name|TRUE
argument_list|,
literal|"get:rcixt -s -k -p"
argument_list|)
expr_stmt|;
name|osig
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|i
operator|=
name|wait
argument_list|(
operator|&
name|st
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|i
operator|!=
name|pid
operator|)
operator|||
name|errno
operator|==
name|EINTR
condition|)
name|errno
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|osig
argument_list|)
expr_stmt|;
comment|/* ignore result of diff */
block|}
else|else
block|{
comment|/* in child, run diff */
if|if
condition|(
name|close
argument_list|(
name|pipev
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
operator|||
name|close
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
operator|||
name|dup
argument_list|(
name|pipev
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
operator|||
name|close
argument_list|(
name|pipev
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"dodiff: magic failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|command
argument_list|(
operator|&
name|getv
index|[
literal|1
index|]
argument_list|,
name|FALSE
argument_list|,
literal|"-diff:elsfhbC"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  TAIL -- return tail of filename. ** **	Parameters: **		fn -- the filename. ** **	Returns: **		a pointer to the tail of the filename; e.g., given **		"cmd/ls.c", "ls.c" is returned. ** **	Side Effects: **		none. */
end_comment

begin_function
name|char
modifier|*
name|tail
parameter_list|(
name|fn
parameter_list|)
specifier|register
name|char
modifier|*
name|fn
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|fn
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|fn
operator|=
operator|&
name|p
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
name|fn
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  GETPFENT -- get an entry from the p-file ** **	Parameters: **		pfp -- p-file file pointer ** **	Returns: **		pointer to p-file struct for next entry **		NULL on EOF or error ** **	Side Effects: **		Each call wipes out results of previous call. */
end_comment

begin_function
name|struct
name|pfile
modifier|*
name|getpfent
parameter_list|(
name|pfp
parameter_list|)
name|FILE
modifier|*
name|pfp
decl_stmt|;
block|{
specifier|static
name|struct
name|pfile
name|ent
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|PFILELG
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|nextfield
parameter_list|()
function_decl|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|pfp
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ent
operator|.
name|p_osid
operator|=
name|p
operator|=
name|buf
expr_stmt|;
name|ent
operator|.
name|p_nsid
operator|=
name|p
operator|=
name|nextfield
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ent
operator|.
name|p_user
operator|=
name|p
operator|=
name|nextfield
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ent
operator|.
name|p_date
operator|=
name|p
operator|=
name|nextfield
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ent
operator|.
name|p_time
operator|=
name|p
operator|=
name|nextfield
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ent
operator|.
name|p_aux
operator|=
name|p
operator|=
name|nextfield
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|ent
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|nextfield
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  PUTPFENT -- output a p-file entry to a file ** **	Parameters: **		pf -- the p-file entry **		f -- the file to put it on. ** **	Returns: **		none. ** **	Side Effects: **		pf is written onto file f. */
end_comment

begin_expr_stmt
name|putpfent
argument_list|(
name|pf
argument_list|,
name|f
argument_list|)
specifier|register
expr|struct
name|pfile
operator|*
name|pf
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s %s %s %s %s"
argument_list|,
name|pf
operator|->
name|p_osid
argument_list|,
name|pf
operator|->
name|p_nsid
argument_list|,
name|pf
operator|->
name|p_user
argument_list|,
name|pf
operator|->
name|p_date
argument_list|,
name|pf
operator|->
name|p_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|p_aux
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %s"
argument_list|,
name|pf
operator|->
name|p_aux
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  USRERR -- issue user-level error ** **	Parameters: **		f -- format string. **		p1-p3 -- parameters to a printf. ** **	Returns: **		-1 ** **	Side Effects: **		none. */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|usrerr
argument_list|(
argument|f
argument_list|,
argument|p1
argument_list|,
argument|p2
argument_list|,
argument|p3
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: "
argument_list|,
name|MyName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|f
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|p3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SYSERR -- print system-generated error. ** **	Parameters: **		f -- format string to a printf. **		p1, p2, p3 -- parameters to f. ** **	Returns: **		never. ** **	Side Effects: **		none. */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|syserr
argument_list|(
argument|f
argument_list|,
argument|p1
argument_list|,
argument|p2
argument_list|,
argument|p3
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s SYSERR: "
argument_list|,
name|MyName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|f
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|p3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
else|else
block|{
name|perror
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  USERNAME -- return name of the current user ** **	Parameters: **		none ** **	Returns: **		name of current user ** **	Side Effects: **		none */
end_comment

begin_function
name|char
modifier|*
name|username
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|UIDUSER
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|pw
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"who are you? (uid=%d)"
argument_list|,
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pw
operator|->
name|pw_name
operator|)
return|;
else|#
directive|else
specifier|extern
name|char
modifier|*
name|getlogin
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|p
operator|=
name|getlogin
argument_list|()
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
endif|#
directive|endif
endif|UIDUSER
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **	Guarded string manipulation routines; the last argument **	is the length of the buffer into which the strcpy or strcat **	is to be done. */
end_comment

begin_function
name|char
modifier|*
name|gstrcat
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
name|to
decl_stmt|,
decl|*
name|from
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|strlen
argument_list|(
name|from
argument_list|)
operator|+
name|strlen
argument_list|(
name|to
argument_list|)
operator|>=
name|length
condition|)
block|{
name|gstrbotch
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|strcat
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|gstrncat
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|n
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
name|to
decl_stmt|,
decl|*
name|from
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|+
name|strlen
argument_list|(
name|to
argument_list|)
operator|>=
name|length
condition|)
block|{
name|gstrbotch
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|strncat
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|n
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|gstrcpy
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
name|to
decl_stmt|,
decl|*
name|from
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|strlen
argument_list|(
name|from
argument_list|)
operator|>=
name|length
condition|)
block|{
name|gstrbotch
argument_list|(
name|from
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|strcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|gstrbotch
argument_list|(
argument|str1
argument_list|,
argument|str2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str1
decl_stmt|,
modifier|*
name|str2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|usrerr
argument_list|(
literal|"Filename(s) too long: %s %s"
argument_list|,
name|str1
argument_list|,
name|str2
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

