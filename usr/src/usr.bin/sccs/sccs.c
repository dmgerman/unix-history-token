begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<whoami.h>
end_include

begin_comment
comment|/* **  SCCS.C -- human-oriented front end to the SCCS system. ** **	Without trying to add any functionality to speak of, this **	program tries to make SCCS a little more accessible to human **	types.  The main thing it does is automatically put the **	string "SCCS/s." on the front of names.  Also, it has a **	couple of things that are designed to shorten frequent **	combinations, e.g., "delget" which expands to a "delta" **	and a "get". ** **	This program can also function as a setuid front end. **	To do this, you should copy the source, renaming it to **	whatever you want, e.g., "syssccs".  Change any defaults **	in the program (e.g., syssccs might default -d to **	"/usr/src/sys").  Then recompile and put the result **	as setuid to whomever you want.  In this mode, sccs **	knows to not run setuid for certain programs in order **	to preserve security, and so forth. ** **	Usage: **		sccs [flags] command [args] ** **	Flags: **		-d<dir><dir> represents a directory to search **				out of.  It should be a full pathname **				for general usage.  E.g., if<dir> is **				"/usr/src/sys", then a reference to the **				file "dev/bio.c" becomes a reference to **				"/usr/src/sys/dev/bio.c". **		-p<path>	prepends<path> to the final component **				of the pathname.  By default, this is **				"SCCS".  For example, in the -d example **				above, the path then gets modified to **				"/usr/src/sys/dev/SCCS/s.bio.c".  In **				more common usage (without the -d flag), **				"prog.c" would get modified to **				"SCCS/s.prog.c".  In both cases, the **				"s." gets automatically prepended. **		-r		run as the real user. ** **	Commands: **		admin, **		get, **		delta, **		rmdel, **		chghist, **		etc.		Straight out of SCCS; only difference **				is that pathnames get modified as **				described above. **		edit		Macro for "get -e". **		unedit		Removes a file being edited, knowing **				about p-files, etc. **		delget		Macro for "delta" followed by "get". **		deledit		Macro for "delta" followed by "get -e". **		info		Tell what files being edited. **		clean		Remove all files that can be **				regenerated from SCCS files. **		check		Like info, but return exit status, for **				use in makefiles. **		fix		Remove a top delta& reedit, but save **				the previous changes in that delta. ** **	Compilation Flags: **		UIDUSER -- determine who the user is by looking at the **			uid rather than the login name -- for machines **			where SCCS gets the user in this way. **		SRCDIR -- if defined, forces the -d flag to take on **			this value.  This is so that the setuid **			aspects of this program cannot be abused. ** **	Compilation Instructions: **		cc -O -n -s sccs.c ** **	Author: **		Eric Allman, UCB/INGRES */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CSVAX
end_ifdef

begin_define
define|#
directive|define
name|UIDUSER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|SccsId
index|[]
init|=
literal|"@(#)sccs.c	1.27 %G%"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|bitset
parameter_list|(
name|bit
parameter_list|,
name|word
parameter_list|)
value|((bit)& (word))
end_define

begin_typedef
typedef|typedef
name|char
name|bool
typedef|;
end_typedef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|UIDUSER
end_ifdef

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_endif
endif|#
directive|endif
endif|UIDUSER
end_endif

begin_decl_stmt
name|char
name|MyName
index|[]
init|=
literal|"sccs"
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|sccsprog
block|{
name|char
modifier|*
name|sccsname
decl_stmt|;
comment|/* name of SCCS routine */
name|short
name|sccsoper
decl_stmt|;
comment|/* opcode, see below */
name|short
name|sccsflags
decl_stmt|;
comment|/* flags, see below */
name|char
modifier|*
name|sccspath
decl_stmt|;
comment|/* pathname of binary implementing */
block|}
struct|;
end_struct

begin_comment
comment|/* values for sccsoper */
end_comment

begin_define
define|#
directive|define
name|PROG
value|0
end_define

begin_comment
comment|/* call a program */
end_comment

begin_define
define|#
directive|define
name|CMACRO
value|1
end_define

begin_comment
comment|/* command substitution macro */
end_comment

begin_define
define|#
directive|define
name|FIX
value|2
end_define

begin_comment
comment|/* fix a delta */
end_comment

begin_define
define|#
directive|define
name|CLEAN
value|3
end_define

begin_comment
comment|/* clean out recreatable files */
end_comment

begin_define
define|#
directive|define
name|UNEDIT
value|4
end_define

begin_comment
comment|/* unedit a file */
end_comment

begin_comment
comment|/* bits for sccsflags */
end_comment

begin_define
define|#
directive|define
name|NO_SDOT
value|0001
end_define

begin_comment
comment|/* no s. on front of args */
end_comment

begin_define
define|#
directive|define
name|REALUSER
value|0002
end_define

begin_comment
comment|/* protected (e.g., admin) */
end_comment

begin_comment
comment|/* modes for the "clean", "info", "check" ops */
end_comment

begin_define
define|#
directive|define
name|CLEANC
value|0
end_define

begin_comment
comment|/* clean command */
end_comment

begin_define
define|#
directive|define
name|INFOC
value|1
end_define

begin_comment
comment|/* info command */
end_comment

begin_define
define|#
directive|define
name|CHECKC
value|2
end_define

begin_comment
comment|/* check command */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CSVAX
end_ifdef

begin_define
define|#
directive|define
name|PROGPATH
parameter_list|(
name|name
parameter_list|)
value|"/usr/local/name"
end_define

begin_endif
endif|#
directive|endif
endif|CSVAX
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PROGPATH
end_ifndef

begin_define
define|#
directive|define
name|PROGPATH
parameter_list|(
name|name
parameter_list|)
value|"/usr/sccs/name"
end_define

begin_endif
endif|#
directive|endif
endif|PROGPATH
end_endif

begin_decl_stmt
name|struct
name|sccsprog
name|SccsProg
index|[]
init|=
block|{
literal|"admin"
block|,
name|PROG
block|,
name|REALUSER
block|,
name|PROGPATH
argument_list|(
name|admin
argument_list|)
block|,
literal|"chghist"
block|,
name|PROG
block|,
literal|0
block|,
name|PROGPATH
argument_list|(
name|rmdel
argument_list|)
block|,
literal|"comb"
block|,
name|PROG
block|,
literal|0
block|,
name|PROGPATH
argument_list|(
name|comb
argument_list|)
block|,
literal|"delta"
block|,
name|PROG
block|,
literal|0
block|,
name|PROGPATH
argument_list|(
name|delta
argument_list|)
block|,
literal|"get"
block|,
name|PROG
block|,
literal|0
block|,
name|PROGPATH
argument_list|(
name|get
argument_list|)
block|,
literal|"help"
block|,
name|PROG
block|,
name|NO_SDOT
block|,
name|PROGPATH
argument_list|(
name|help
argument_list|)
block|,
literal|"prt"
block|,
name|PROG
block|,
literal|0
block|,
name|PROGPATH
argument_list|(
name|prt
argument_list|)
block|,
literal|"rmdel"
block|,
name|PROG
block|,
name|REALUSER
block|,
name|PROGPATH
argument_list|(
name|rmdel
argument_list|)
block|,
literal|"what"
block|,
name|PROG
block|,
name|NO_SDOT
block|,
name|PROGPATH
argument_list|(
name|what
argument_list|)
block|,
literal|"edit"
block|,
name|CMACRO
block|,
literal|0
block|,
literal|"get -e"
block|,
literal|"delget"
block|,
name|CMACRO
block|,
literal|0
block|,
literal|"delta/get"
block|,
literal|"deledit"
block|,
name|CMACRO
block|,
literal|0
block|,
literal|"delta/get -e"
block|,
literal|"fix"
block|,
name|FIX
block|,
literal|0
block|,
name|NULL
block|,
literal|"clean"
block|,
name|CLEAN
block|,
name|REALUSER
block|,
operator|(
name|char
operator|*
operator|)
name|CLEANC
block|,
literal|"info"
block|,
name|CLEAN
block|,
name|REALUSER
block|,
operator|(
name|char
operator|*
operator|)
name|INFOC
block|,
literal|"check"
block|,
name|CLEAN
block|,
name|REALUSER
block|,
operator|(
name|char
operator|*
operator|)
name|CHECKC
block|,
literal|"unedit"
block|,
name|UNEDIT
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
operator|-
literal|1
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|pfile
block|{
name|char
modifier|*
name|p_osid
decl_stmt|;
comment|/* old SID */
name|char
modifier|*
name|p_nsid
decl_stmt|;
comment|/* new SID */
name|char
modifier|*
name|p_user
decl_stmt|;
comment|/* user who did edit */
name|char
modifier|*
name|p_date
decl_stmt|;
comment|/* date of get */
name|char
modifier|*
name|p_time
decl_stmt|;
comment|/* time of get */
block|}
struct|;
end_struct

begin_decl_stmt
name|char
modifier|*
name|SccsPath
init|=
literal|"SCCS"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname of SCCS files */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SRCDIR
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|SccsDir
init|=
name|SRCDIR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* directory to begin search from */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|SccsDir
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* directory to begin search from */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|bool
name|RealUser
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, running as real user */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|bool
name|Debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* turn on tracing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|struct
name|sccsprog
modifier|*
name|lookup
parameter_list|()
function_decl|;
comment|/* 	**  Detect and decode flags intended for this program. 	*/
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [flags] command [flags]\n"
argument_list|,
name|MyName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|p
operator|=
operator|*
operator|++
name|argv
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'-'
condition|)
break|break;
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'r'
case|:
comment|/* run as real user */
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|RealUser
operator|++
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|SRCDIR
case|case
literal|'p'
case|:
comment|/* path of sccs files */
name|SccsPath
operator|=
operator|++
name|p
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* directory to search from */
name|SccsDir
operator|=
operator|++
name|p
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'T'
case|:
comment|/* trace */
name|Debug
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|usrerr
argument_list|(
literal|"unknown option -%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|SccsPath
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|SccsPath
operator|=
literal|"."
expr_stmt|;
block|}
name|command
argument_list|(
name|argv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|command
argument_list|(
argument|argv
argument_list|,
argument|forkflag
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|forkflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sccsprog
modifier|*
name|cmd
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
specifier|extern
name|struct
name|sccsprog
modifier|*
name|lookup
parameter_list|()
function_decl|;
name|char
modifier|*
name|nav
index|[
literal|200
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|avp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|bool
name|unedit
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
block|{
name|printf
argument_list|(
literal|"command:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|avp
operator|=
name|argv
init|;
operator|*
name|avp
operator|!=
name|NULL
condition|;
name|avp
operator|++
control|)
name|printf
argument_list|(
literal|"    \"%s\"\n"
argument_list|,
operator|*
name|avp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	**  Look up command. 	**	At this point, argv points to the command name. 	*/
name|cmd
operator|=
name|lookup
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"Unknown command \"%s\""
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Interpret operation associated with this command. 	*/
switch|switch
condition|(
name|cmd
operator|->
name|sccsoper
condition|)
block|{
case|case
name|PROG
case|:
comment|/* call an sccs prog */
name|callprog
argument_list|(
name|cmd
operator|->
name|sccspath
argument_list|,
name|cmd
operator|->
name|sccsflags
argument_list|,
name|argv
argument_list|,
name|forkflag
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMACRO
case|:
comment|/* command macro */
for|for
control|(
name|p
operator|=
name|cmd
operator|->
name|sccspath
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
name|avp
operator|=
name|nav
expr_stmt|;
operator|*
name|avp
operator|++
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|q
operator|=
name|buf
init|;
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
operator|,
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
block|{
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|avp
operator|++
operator|=
operator|&
name|q
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
operator|*
name|q
operator|=
operator|*
name|p
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|avp
operator|=
name|NULL
expr_stmt|;
name|xcommand
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
argument_list|,
operator|*
name|p
operator|!=
literal|'\0'
argument_list|,
name|nav
index|[
literal|0
index|]
argument_list|,
name|nav
index|[
literal|1
index|]
argument_list|,
name|nav
index|[
literal|2
index|]
argument_list|,
name|nav
index|[
literal|3
index|]
argument_list|,
name|nav
index|[
literal|4
index|]
argument_list|,
name|nav
index|[
literal|5
index|]
argument_list|,
name|nav
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
block|}
name|syserr
argument_list|(
literal|"internal error: CMACRO"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
case|case
name|FIX
case|:
comment|/* fix a delta */
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-r"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"-r flag needed for fix command"
argument_list|)
expr_stmt|;
break|break;
block|}
name|xcommand
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
argument_list|,
name|TRUE
argument_list|,
literal|"get"
argument_list|,
literal|"-k"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xcommand
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
argument_list|,
name|TRUE
argument_list|,
literal|"rmdel"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xcommand
argument_list|(
operator|&
name|argv
index|[
literal|2
index|]
argument_list|,
name|FALSE
argument_list|,
literal|"get"
argument_list|,
literal|"-e"
argument_list|,
literal|"-g"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
literal|"FIX"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
case|case
name|CLEAN
case|:
name|clean
argument_list|(
operator|(
name|int
operator|)
name|cmd
operator|->
name|sccspath
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNEDIT
case|:
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|avp
operator|=
operator|&
name|argv
index|[
literal|1
index|]
init|;
operator|*
name|avp
operator|!=
name|NULL
condition|;
name|avp
operator|++
control|)
block|{
if|if
condition|(
name|unedit
argument_list|(
operator|*
name|avp
argument_list|)
condition|)
name|nav
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|avp
expr_stmt|;
block|}
name|nav
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|xcommand
argument_list|(
name|nav
argument_list|,
name|FALSE
argument_list|,
literal|"get"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"oper %d"
argument_list|,
name|cmd
operator|->
name|sccsoper
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  LOOKUP -- look up an SCCS command name. ** **	Parameters: **		name -- the name of the command to look up. ** **	Returns: **		ptr to command descriptor for this command. **		NULL if no such entry. ** **	Side Effects: **		none. */
end_comment

begin_function
name|struct
name|sccsprog
modifier|*
name|lookup
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|sccsprog
modifier|*
name|cmd
decl_stmt|;
for|for
control|(
name|cmd
operator|=
name|SccsProg
init|;
name|cmd
operator|->
name|sccsname
operator|!=
name|NULL
condition|;
name|cmd
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
operator|->
name|sccsname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|cmd
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_macro
name|xcommand
argument_list|(
argument|argv
argument_list|,
argument|forkflag
argument_list|,
argument|arg0
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|forkflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|arg0
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|char
modifier|*
name|newargv
index|[
literal|1000
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|np
decl_stmt|;
name|np
operator|=
name|newargv
expr_stmt|;
for|for
control|(
name|av
operator|=
operator|&
name|arg0
init|;
operator|*
name|av
operator|!=
name|NULL
condition|;
name|av
operator|++
control|)
operator|*
name|np
operator|++
operator|=
operator|*
name|av
expr_stmt|;
for|for
control|(
name|av
operator|=
name|argv
init|;
operator|*
name|av
operator|!=
name|NULL
condition|;
name|av
operator|++
control|)
operator|*
name|np
operator|++
operator|=
operator|*
name|av
expr_stmt|;
operator|*
name|np
operator|=
name|NULL
expr_stmt|;
name|command
argument_list|(
name|newargv
argument_list|,
name|forkflag
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|callprog
argument_list|(
argument|progpath
argument_list|,
argument|flags
argument_list|,
argument|argv
argument_list|,
argument|forkflag
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|progpath
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|forkflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
specifier|extern
name|char
modifier|*
name|makefile
parameter_list|()
function_decl|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|auto
name|int
name|st
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|nav
decl_stmt|;
if|if
condition|(
operator|*
name|argv
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	**  Fork if appropriate. 	*/
if|if
condition|(
name|forkflag
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"Forking\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"cannot fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|wait
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
return|return
operator|(
name|st
operator|)
return|;
block|}
block|}
comment|/* 	**  Build new argument vector. 	*/
comment|/* copy program filename arguments and flags */
name|nav
operator|=
operator|&
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|av
operator|=
name|argv
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
operator|++
name|av
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|NO_SDOT
argument_list|,
name|flags
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'-'
condition|)
operator|*
name|nav
operator|=
name|makefile
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
operator|*
name|nav
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|nav
operator|!=
name|NULL
condition|)
name|nav
operator|++
expr_stmt|;
block|}
operator|*
name|nav
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  Set protection as appropriate. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|REALUSER
argument_list|,
name|flags
argument_list|)
condition|)
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* 	**  Call real SCCS program. 	*/
name|execv
argument_list|(
name|progpath
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
literal|"cannot execute %s"
argument_list|,
name|progpath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MAKEFILE -- make filename of SCCS file ** **	If the name passed is already the name of an SCCS file, **	just return it.  Otherwise, munge the name into the name **	of the actual SCCS file. ** **	There are cases when it is not clear what you want to **	do.  For example, if SccsPath is an absolute pathname **	and the name given is also an absolute pathname, we go **	for SccsPath (& only use the last component of the name **	passed) -- this is important for security reasons (if **	sccs is being used as a setuid front end), but not **	particularly intuitive. ** **	Parameters: **		name -- the file name to be munged. ** **	Returns: **		The pathname of the sccs file. **		NULL on error. ** **	Side Effects: **		none. */
end_comment

begin_function
name|char
modifier|*
name|makefile
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
specifier|extern
name|bool
name|isdir
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|rindex
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|name
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
comment|/* 	**  See if the name can be used as-is. 	*/
if|if
condition|(
name|SccsPath
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"./"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"s."
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|name
operator|)
return|;
if|if
condition|(
name|isdir
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|(
name|name
operator|)
return|;
block|}
comment|/* 	**  Create the actual pathname. 	*/
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|SccsDir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|buf
argument_list|,
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
expr_stmt|;
name|q
operator|=
operator|&
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
index|]
expr_stmt|;
name|strcpy
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"s."
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|isdir
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|q
argument_list|,
name|SccsPath
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"/s."
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
name|p
operator|=
name|name
expr_stmt|;
return|return
operator|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  ISDIR -- return true if the argument is a directory. ** **	Parameters: **		name -- the pathname of the file to check. ** **	Returns: **		TRUE if 'name' is a directory, FALSE otherwise. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|isdir
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
return|return
operator|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SAFEPATH -- determine whether a pathname is "safe" ** **	"Safe" pathnames only allow you to get deeper into the **	directory structure, i.e., full pathnames and ".." are **	not allowed. ** **	Parameters: **		p -- the name to check. ** **	Returns: **		TRUE -- if the path is safe. **		FALSE -- if the path is not safe. ** **	Side Effects: **		Prints a message if the path is not safe. */
end_comment

begin_function
name|bool
name|safepath
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'/'
condition|)
block|{
while|while
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"../"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".."
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|p
operator|++
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"You may not use full pathnames or \"..\"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  CLEAN -- clean out recreatable files ** **	Any file for which an "s." file exists but no "p." file **	exists in the current directory is purged. ** **	Parameters: **		tells whether this came from a "clean", "info", or **		"check" command. ** **	Returns: **		none. ** **	Side Effects: **		Removes files in the current directory. **		Prints information regarding files being edited. **		Exits if a "check" command. */
end_comment

begin_macro
name|clean
argument_list|(
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|direct
name|dir
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|char
name|pline
index|[
literal|120
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|dirfd
decl_stmt|;
specifier|register
name|char
modifier|*
name|basefile
decl_stmt|;
name|bool
name|gotedit
decl_stmt|;
name|FILE
modifier|*
name|pfp
decl_stmt|;
name|dirfd
operator|=
name|fopen
argument_list|(
name|SccsPath
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirfd
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"cannot open %s"
argument_list|,
name|SccsPath
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	**  Scan the SCCS directory looking for s. files. 	*/
name|gotedit
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|fread
argument_list|(
operator|&
name|dir
argument_list|,
sizeof|sizeof
name|dir
argument_list|,
literal|1
argument_list|,
name|dirfd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dir
operator|.
name|d_ino
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|dir
operator|.
name|d_name
argument_list|,
literal|"s."
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* got an s. file -- see if the p. file exists */
name|strcpy
argument_list|(
name|buf
argument_list|,
name|SccsPath
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"/p."
argument_list|)
expr_stmt|;
name|basefile
operator|=
operator|&
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
index|]
expr_stmt|;
name|strncpy
argument_list|(
name|basefile
argument_list|,
operator|&
name|dir
operator|.
name|d_name
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
name|dir
operator|.
name|d_name
operator|-
literal|2
argument_list|)
expr_stmt|;
name|basefile
index|[
sizeof|sizeof
name|dir
operator|.
name|d_name
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pfp
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfp
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|pline
argument_list|,
sizeof|sizeof
name|pline
argument_list|,
name|pfp
argument_list|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%12s: being edited: %s"
argument_list|,
name|basefile
argument_list|,
name|pline
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|gotedit
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
comment|/* the s. file exists and no p. file exists -- unlink the g-file */
if|if
condition|(
name|mode
operator|==
name|CLEANC
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
operator|&
name|dir
operator|.
name|d_name
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
name|dir
operator|.
name|d_name
operator|-
literal|2
argument_list|)
expr_stmt|;
name|buf
index|[
sizeof|sizeof
name|dir
operator|.
name|d_name
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|unlink
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|dirfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gotedit
operator|&&
name|mode
operator|==
name|INFOC
condition|)
name|printf
argument_list|(
literal|"Nothing being edited\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CHECKC
condition|)
name|exit
argument_list|(
name|gotedit
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  UNEDIT -- unedit a file ** **	Checks to see that the current user is actually editting **	the file and arranges that s/he is not editting it. ** **	Parameters: **		fn -- the name of the file to be unedited. ** **	Returns: **		TRUE -- if the file was successfully unedited. **		FALSE -- if the file was not unedited for some **			reason. ** **	Side Effects: **		fn is removed **		entries are removed from pfile. */
end_comment

begin_function
name|bool
name|unedit
parameter_list|(
name|fn
parameter_list|)
name|char
modifier|*
name|fn
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|pfp
decl_stmt|;
name|char
modifier|*
name|pfn
decl_stmt|;
specifier|static
name|char
name|tfn
index|[]
init|=
literal|"/tmp/sccsXXXXX"
decl_stmt|;
name|FILE
modifier|*
name|tfp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|bool
name|delete
init|=
name|FALSE
decl_stmt|;
name|bool
name|others
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|myname
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getlogin
parameter_list|()
function_decl|;
name|struct
name|pfile
modifier|*
name|pent
decl_stmt|;
specifier|extern
name|struct
name|pfile
modifier|*
name|getpfile
parameter_list|()
function_decl|;
name|char
name|buf
index|[
literal|120
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|UIDUSER
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
endif|#
directive|endif
endif|UIDUSER
comment|/* make "s." filename& find the trailing component */
name|pfn
operator|=
name|makefile
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfn
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|q
operator|=
name|rindex
argument_list|(
name|pfn
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|q
operator|=
operator|&
name|pfn
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|q
index|[
literal|1
index|]
operator|!=
literal|'s'
operator|||
name|q
index|[
literal|2
index|]
operator|!=
literal|'.'
condition|)
block|{
name|usrerr
argument_list|(
literal|"bad file name \"%s\""
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* turn "s." into "p." */
operator|*
operator|++
name|q
operator|=
literal|'p'
expr_stmt|;
name|pfp
operator|=
name|fopen
argument_list|(
name|pfn
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%12s: not being edited\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 	**  Copy p-file to temp file, doing deletions as needed. 	*/
name|mktemp
argument_list|(
name|tfn
argument_list|)
expr_stmt|;
name|tfp
operator|=
name|fopen
argument_list|(
name|tfn
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"cannot create \"%s\""
argument_list|,
name|tfn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|UIDUSER
name|pw
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"who are you? (uid=%d)"
argument_list|,
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|myname
operator|=
name|pw
operator|->
name|pw_name
expr_stmt|;
else|#
directive|else
name|myname
operator|=
name|getlogin
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|UIDUSER
while|while
condition|(
operator|(
name|pent
operator|=
name|getpfile
argument_list|(
name|pfp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pent
operator|->
name|p_user
argument_list|,
name|myname
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* a match */
name|delete
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"%s %s %s %s %s\n"
argument_list|,
name|pent
operator|->
name|p_osid
argument_list|,
name|pent
operator|->
name|p_nsid
argument_list|,
name|pent
operator|->
name|p_user
argument_list|,
name|pent
operator|->
name|p_date
argument_list|,
name|pent
operator|->
name|p_time
argument_list|)
expr_stmt|;
name|others
operator|++
expr_stmt|;
block|}
block|}
comment|/* do final cleanup */
if|if
condition|(
name|others
condition|)
block|{
if|if
condition|(
name|freopen
argument_list|(
name|tfn
argument_list|,
literal|"r"
argument_list|,
name|tfp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"cannot reopen \"%s\""
argument_list|,
name|tfn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freopen
argument_list|(
name|pfn
argument_list|,
literal|"w"
argument_list|,
name|pfp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"cannot create \"%s\""
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|tfp
argument_list|)
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unlink
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tfn
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete
condition|)
block|{
name|unlink
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%12s: removed\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%12s: not being edited by you\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  GETPFILE -- get an entry from the p-file ** **	Parameters: **		pfp -- p-file file pointer ** **	Returns: **		pointer to p-file struct for next entry **		NULL on EOF or error ** **	Side Effects: **		Each call wipes out results of previous call. */
end_comment

begin_function
name|struct
name|pfile
modifier|*
name|getpfile
parameter_list|(
name|pfp
parameter_list|)
name|FILE
modifier|*
name|pfp
decl_stmt|;
block|{
specifier|static
name|struct
name|pfile
name|ent
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|120
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|nextfield
parameter_list|()
function_decl|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|pfp
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ent
operator|.
name|p_osid
operator|=
name|p
operator|=
name|buf
expr_stmt|;
name|ent
operator|.
name|p_nsid
operator|=
name|p
operator|=
name|nextfield
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ent
operator|.
name|p_user
operator|=
name|p
operator|=
name|nextfield
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ent
operator|.
name|p_date
operator|=
name|p
operator|=
name|nextfield
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ent
operator|.
name|p_time
operator|=
name|p
operator|=
name|nextfield
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|nextfield
argument_list|(
name|p
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|ent
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|nextfield
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  USRERR -- issue user-level error ** **	Parameters: **		f -- format string. **		p1-p3 -- parameters to a printf. ** **	Returns: **		-1 ** **	Side Effects: **		none. */
end_comment

begin_macro
name|usrerr
argument_list|(
argument|f
argument_list|,
argument|p1
argument_list|,
argument|p2
argument_list|,
argument|p3
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: "
argument_list|,
name|MyName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|f
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|p3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SYSERR -- print system-generated error. ** **	Parameters: **		f -- format string to a printf. **		p1, p2, p3 -- parameters to f. ** **	Returns: **		never. ** **	Side Effects: **		none. */
end_comment

begin_macro
name|syserr
argument_list|(
argument|f
argument_list|,
argument|p1
argument_list|,
argument|p2
argument_list|,
argument|p3
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s SYSERR: "
argument_list|,
name|MyName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|f
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|p3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
else|else
block|{
name|perror
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

