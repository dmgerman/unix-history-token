begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)w.c	4.14 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * w - print system status (who and what)  *  * This program is similar to the systat command on Tenex/Tops 10/20  * It needs read permission on /dev/mem, /dev/kmem, and /dev/drum.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<sys/vm.h>
end_include

begin_define
define|#
directive|define
name|NMAX
value|sizeof(utmp.ut_name)
end_define

begin_define
define|#
directive|define
name|LMAX
value|sizeof(utmp.ut_line)
end_define

begin_define
define|#
directive|define
name|ARGWIDTH
value|33
end_define

begin_comment
comment|/* # chars left on 80 col crt for args */
end_comment

begin_struct
struct|struct
name|pr
block|{
name|short
name|w_pid
decl_stmt|;
comment|/* proc.p_pid */
name|char
name|w_flag
decl_stmt|;
comment|/* proc.p_flag */
name|short
name|w_size
decl_stmt|;
comment|/* proc.p_size */
name|long
name|w_seekaddr
decl_stmt|;
comment|/* where to find args */
name|long
name|w_lastpg
decl_stmt|;
comment|/* disk address of stack */
name|int
name|w_igintr
decl_stmt|;
comment|/* INTR+3*QUIT, 0=die, 1=ign, 2=catch */
name|time_t
name|w_time
decl_stmt|;
comment|/* CPU time used by this process */
name|time_t
name|w_ctime
decl_stmt|;
comment|/* CPU time used by children */
name|dev_t
name|w_tty
decl_stmt|;
comment|/* tty device of process */
name|int
name|w_uid
decl_stmt|;
comment|/* uid of process */
name|char
name|w_comm
index|[
literal|15
index|]
decl_stmt|;
comment|/* user.u_comm, null terminated */
name|char
name|w_args
index|[
name|ARGWIDTH
operator|+
literal|1
index|]
decl_stmt|;
comment|/* args if interesting process */
block|}
modifier|*
name|pr
struct|;
end_struct

begin_decl_stmt
name|int
name|nproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
block|{
literal|"_proc"
block|}
block|,
define|#
directive|define
name|X_PROC
value|0
block|{
literal|"_swapdev"
block|}
block|,
define|#
directive|define
name|X_SWAPDEV
value|1
block|{
literal|"_Usrptmap"
block|}
block|,
define|#
directive|define
name|X_USRPTMA
value|2
block|{
literal|"_usrpt"
block|}
block|,
define|#
directive|define
name|X_USRPT
value|3
block|{
literal|"_nswap"
block|}
block|,
define|#
directive|define
name|X_NSWAP
value|4
block|{
literal|"_avenrun"
block|}
block|,
define|#
directive|define
name|X_AVENRUN
value|5
block|{
literal|"_boottime"
block|}
block|,
define|#
directive|define
name|X_BOOTTIME
value|6
block|{
literal|"_nproc"
block|}
block|,
define|#
directive|define
name|X_NPROC
value|7
block|{
literal|"_dmmin"
block|}
block|,
define|#
directive|define
name|X_DMMIN
value|8
block|{
literal|"_dmmax"
block|}
block|,
define|#
directive|define
name|X_DMMAX
value|9
block|{
literal|""
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|ps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|ut
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|bootfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|kmem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|swap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* /dev/kmem, mem, and swap */
end_comment

begin_decl_stmt
name|int
name|nswap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dmmin
decl_stmt|,
name|dmmax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dev_t
name|tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|doing
index|[
literal|520
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* process attached to terminal */
end_comment

begin_decl_stmt
name|time_t
name|proctime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cpu time of process in doing */
end_comment

begin_decl_stmt
name|double
name|avenrun
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|aproc
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DIV60
parameter_list|(
name|t
parameter_list|)
value|((t+30)/60)
end_define

begin_comment
comment|/* x/60 rounded */
end_comment

begin_define
define|#
directive|define
name|TTYEQ
value|(tty == pr[i].w_tty&& uid == pr[i].w_uid)
end_define

begin_define
define|#
directive|define
name|IGINT
value|(1+3*1)
end_define

begin_comment
comment|/* ignoring both SIGINT& SIGQUIT */
end_comment

begin_function_decl
name|char
modifier|*
name|getargs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|fread
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -d flag: debugging output */
end_comment

begin_decl_stmt
name|int
name|header
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -h flag: don't print heading */
end_comment

begin_decl_stmt
name|int
name|lflag
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -l flag: long style output */
end_comment

begin_decl_stmt
name|int
name|login
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if invoked as login shell */
end_comment

begin_decl_stmt
name|int
name|idle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of minutes user is idle */
end_comment

begin_decl_stmt
name|int
name|nusers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of users logged in now */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sel_user
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* login of particular user selected */
end_comment

begin_decl_stmt
name|char
name|firstchar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first char of name of prog invoked as */
end_comment

begin_decl_stmt
name|time_t
name|jobtime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total cpu time visible */
end_comment

begin_decl_stmt
name|time_t
name|now
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the current time of day */
end_comment

begin_decl_stmt
name|struct
name|tm
modifier|*
name|nowt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current time as time struct */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|boottime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|uptime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time of last reboot& elapsed time since */
end_comment

begin_decl_stmt
name|int
name|np
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of processes currently active */
end_comment

begin_decl_stmt
name|struct
name|utmp
name|utmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
name|mproc
decl_stmt|;
end_decl_stmt

begin_union
union|union
block|{
name|struct
name|user
name|U_up
decl_stmt|;
name|char
name|pad
index|[
name|NBPG
index|]
index|[
name|UPAGES
index|]
decl_stmt|;
block|}
name|Up
union|;
end_union

begin_define
define|#
directive|define
name|up
value|Up.U_up
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|days
decl_stmt|,
name|hrs
decl_stmt|,
name|mins
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|curpid
decl_stmt|,
name|empty
decl_stmt|;
name|login
operator|=
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
expr_stmt|;
name|cp
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|firstchar
operator|=
name|login
condition|?
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
else|:
operator|(
name|cp
operator|==
literal|0
operator|)
condition|?
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
else|:
name|cp
index|[
literal|1
index|]
expr_stmt|;
name|cp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* for Usage */
while|while
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|argv
index|[
literal|1
index|]
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'d'
case|:
name|debug
operator|++
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|header
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|lflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|lflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
case|case
literal|'w'
case|:
name|firstchar
operator|=
name|argv
index|[
literal|1
index|]
index|[
name|i
index|]
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Bad flag %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|||
name|argc
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: %s [ -hlsuw ] [ user ]\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|sel_user
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|kmem
operator|=
name|open
argument_list|(
literal|"/dev/kmem"
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No kmem\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|nlist
argument_list|(
literal|"/vmunix"
argument_list|,
name|nl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
index|[
literal|0
index|]
operator|.
name|n_type
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No namelist\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|firstchar
operator|!=
literal|'u'
condition|)
name|readpr
argument_list|()
expr_stmt|;
name|ut
operator|=
name|fopen
argument_list|(
literal|"/etc/utmp"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
condition|)
block|{
comment|/* Print time of day */
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|nowt
operator|=
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|prtat
argument_list|(
name|nowt
argument_list|)
expr_stmt|;
comment|/* 		 * Print how long system has been up. 		 * (Found by looking for "boottime" in kernel) 		 */
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|X_BOOTTIME
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|boottime
argument_list|,
sizeof|sizeof
argument_list|(
name|boottime
argument_list|)
argument_list|)
expr_stmt|;
name|uptime
operator|=
name|now
operator|-
name|boottime
operator|.
name|tv_sec
expr_stmt|;
name|uptime
operator|+=
literal|30
expr_stmt|;
name|days
operator|=
name|uptime
operator|/
operator|(
literal|60
operator|*
literal|60
operator|*
literal|24
operator|)
expr_stmt|;
name|uptime
operator|%=
operator|(
literal|60
operator|*
literal|60
operator|*
literal|24
operator|)
expr_stmt|;
name|hrs
operator|=
name|uptime
operator|/
operator|(
literal|60
operator|*
literal|60
operator|)
expr_stmt|;
name|uptime
operator|%=
operator|(
literal|60
operator|*
literal|60
operator|)
expr_stmt|;
name|mins
operator|=
name|uptime
operator|/
literal|60
expr_stmt|;
name|printf
argument_list|(
literal|"  up"
argument_list|)
expr_stmt|;
if|if
condition|(
name|days
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %d day%s,"
argument_list|,
name|days
argument_list|,
name|days
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|hrs
operator|>
literal|0
operator|&&
name|mins
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" %2d:%02d,"
argument_list|,
name|hrs
argument_list|,
name|mins
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hrs
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %d hr%s,"
argument_list|,
name|hrs
argument_list|,
name|hrs
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|mins
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %d min%s,"
argument_list|,
name|mins
argument_list|,
name|mins
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* Print number of users logged in to system */
while|while
condition|(
name|fread
argument_list|(
operator|&
name|utmp
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|ut
argument_list|)
condition|)
block|{
if|if
condition|(
name|utmp
operator|.
name|ut_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|nusers
operator|++
expr_stmt|;
block|}
name|rewind
argument_list|(
name|ut
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %d users"
argument_list|,
name|nusers
argument_list|)
expr_stmt|;
comment|/* 		 * Print 1, 5, and 15 minute load averages. 		 * (Found by looking in kernel for avenrun). 		 */
name|printf
argument_list|(
literal|",  load average:"
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|X_AVENRUN
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
name|avenrun
argument_list|,
sizeof|sizeof
argument_list|(
name|avenrun
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|avenrun
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|avenrun
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %.2f"
argument_list|,
name|avenrun
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstchar
operator|==
literal|'u'
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Headers for rest of output */
if|if
condition|(
name|lflag
condition|)
name|printf
argument_list|(
literal|"User     tty       login@  idle   JCPU   PCPU  what\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"User    tty  idle  what\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* for each entry in utmp */
if|if
condition|(
name|fread
argument_list|(
operator|&
name|utmp
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|ut
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|ut
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|utmp
operator|.
name|ut_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* that tty is free */
if|if
condition|(
name|sel_user
operator|&&
name|strcmpn
argument_list|(
name|utmp
operator|.
name|ut_name
argument_list|,
name|sel_user
argument_list|,
name|NMAX
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* we wanted only somebody else */
name|gettty
argument_list|()
expr_stmt|;
name|jobtime
operator|=
literal|0
expr_stmt|;
name|proctime
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|doing
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
comment|/* default act: normally never prints */
name|empty
operator|=
literal|1
expr_stmt|;
name|curpid
operator|=
operator|-
literal|1
expr_stmt|;
name|idle
operator|=
name|findidle
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|np
condition|;
name|i
operator|++
control|)
block|{
comment|/* for each process on this tty */
if|if
condition|(
operator|!
operator|(
name|TTYEQ
operator|)
condition|)
continue|continue;
name|jobtime
operator|+=
name|pr
index|[
name|i
index|]
operator|.
name|w_time
operator|+
name|pr
index|[
name|i
index|]
operator|.
name|w_ctime
expr_stmt|;
name|proctime
operator|+=
name|pr
index|[
name|i
index|]
operator|.
name|w_time
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"\t\t%d\t%s"
argument_list|,
name|pr
index|[
name|i
index|]
operator|.
name|w_pid
argument_list|,
name|pr
index|[
name|i
index|]
operator|.
name|w_args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|pr
index|[
name|i
index|]
operator|.
name|w_igintr
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|j
operator|==
name|IGINT
condition|)
name|printf
argument_list|(
literal|"&"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"& %d %d"
argument_list|,
name|j
operator|%
literal|3
argument_list|,
name|j
operator|/
literal|3
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|empty
operator|&&
name|pr
index|[
name|i
index|]
operator|.
name|w_igintr
operator|!=
name|IGINT
condition|)
block|{
name|empty
operator|=
literal|0
expr_stmt|;
name|curpid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pr
index|[
name|i
index|]
operator|.
name|w_pid
operator|>
name|curpid
operator|&&
operator|(
name|pr
index|[
name|i
index|]
operator|.
name|w_igintr
operator|!=
name|IGINT
operator|||
name|empty
operator|)
condition|)
block|{
name|curpid
operator|=
name|pr
index|[
name|i
index|]
operator|.
name|w_pid
expr_stmt|;
name|strcpy
argument_list|(
name|doing
argument_list|,
name|lflag
condition|?
name|pr
index|[
name|i
index|]
operator|.
name|w_args
else|:
name|pr
index|[
name|i
index|]
operator|.
name|w_comm
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|doing
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|doing
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|doing
index|[
literal|1
index|]
operator|<=
literal|' '
operator|||
name|doing
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
block|{
name|strcat
argument_list|(
name|doing
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|doing
argument_list|,
name|pr
index|[
name|i
index|]
operator|.
name|w_comm
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|doing
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|putline
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* figure out the major/minor device # pair for this tty */
end_comment

begin_macro
name|gettty
argument_list|()
end_macro

begin_block
block|{
name|char
name|ttybuf
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|ttybuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|ttybuf
argument_list|,
literal|"/dev/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ttybuf
argument_list|,
name|utmp
operator|.
name|ut_line
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|ttybuf
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
name|tty
operator|=
name|statbuf
operator|.
name|st_rdev
expr_stmt|;
name|uid
operator|=
name|statbuf
operator|.
name|st_uid
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * putline: print out the accumulated line of info about one user.  */
end_comment

begin_macro
name|putline
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|tm
decl_stmt|;
comment|/* print login name of the user */
name|printf
argument_list|(
literal|"%-*.*s "
argument_list|,
name|NMAX
argument_list|,
name|NMAX
argument_list|,
name|utmp
operator|.
name|ut_name
argument_list|)
expr_stmt|;
comment|/* print tty user is on */
if|if
condition|(
name|lflag
condition|)
comment|/* long form: all (up to) LMAX chars */
name|printf
argument_list|(
literal|"%-*.*s"
argument_list|,
name|LMAX
argument_list|,
name|LMAX
argument_list|,
name|utmp
operator|.
name|ut_line
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* short form: 2 chars, skipping 'tty' if there */
if|if
condition|(
name|utmp
operator|.
name|ut_line
index|[
literal|0
index|]
operator|==
literal|'t'
operator|&&
name|utmp
operator|.
name|ut_line
index|[
literal|1
index|]
operator|==
literal|'t'
operator|&&
name|utmp
operator|.
name|ut_line
index|[
literal|2
index|]
operator|==
literal|'y'
condition|)
name|printf
argument_list|(
literal|"%-2.2s"
argument_list|,
operator|&
name|utmp
operator|.
name|ut_line
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-2.2s"
argument_list|,
name|utmp
operator|.
name|ut_line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lflag
condition|)
comment|/* print when the user logged in */
name|prtat
argument_list|(
name|localtime
argument_list|(
operator|&
name|utmp
operator|.
name|ut_time
argument_list|)
argument_list|)
expr_stmt|;
comment|/* print idle time */
name|prttime
argument_list|(
name|idle
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|lflag
condition|)
block|{
comment|/* print CPU time for all processes& children */
name|prttime
argument_list|(
name|jobtime
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|/* print cpu time for interesting process */
name|prttime
argument_list|(
name|proctime
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
comment|/* what user is doing, either command tail or args */
name|printf
argument_list|(
literal|" %-.32s\n"
argument_list|,
name|doing
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* find& return number of minutes current tty has been idle */
end_comment

begin_macro
name|findidle
argument_list|()
end_macro

begin_block
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
name|long
name|lastaction
decl_stmt|,
name|diff
decl_stmt|;
name|char
name|ttyname
index|[
literal|20
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|ttyname
argument_list|,
literal|"/dev/"
argument_list|)
expr_stmt|;
name|strcatn
argument_list|(
name|ttyname
argument_list|,
name|utmp
operator|.
name|ut_line
argument_list|,
name|LMAX
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|ttyname
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|lastaction
operator|=
name|stbuf
operator|.
name|st_atime
expr_stmt|;
name|diff
operator|=
name|now
operator|-
name|lastaction
expr_stmt|;
name|diff
operator|=
name|DIV60
argument_list|(
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|diff
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|diff
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * prttime prints a time in hours and minutes.  * The character string tail is printed at the end, obvious  * strings to pass are "", " ", or "am".  */
end_comment

begin_macro
name|prttime
argument_list|(
argument|tim
argument_list|,
argument|tail
argument_list|)
end_macro

begin_decl_stmt
name|time_t
name|tim
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tail
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|didhrs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tim
operator|>=
literal|60
condition|)
block|{
name|printf
argument_list|(
literal|"%3d:"
argument_list|,
name|tim
operator|/
literal|60
argument_list|)
expr_stmt|;
name|didhrs
operator|++
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
block|}
name|tim
operator|%=
literal|60
expr_stmt|;
if|if
condition|(
name|tim
operator|>
literal|0
operator|||
name|didhrs
condition|)
block|{
name|printf
argument_list|(
name|didhrs
operator|&&
name|tim
operator|<
literal|10
condition|?
literal|"%02d"
else|:
literal|"%2d"
argument_list|,
name|tim
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* prtat prints a 12 hour time given a pointer to a time of day */
end_comment

begin_macro
name|prtat
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tm
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|t
decl_stmt|,
name|pm
decl_stmt|;
name|t
operator|=
name|p
operator|->
name|tm_hour
expr_stmt|;
name|pm
operator|=
operator|(
name|t
operator|>
literal|11
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|>
literal|11
condition|)
name|t
operator|-=
literal|12
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
name|t
operator|=
literal|12
expr_stmt|;
name|prttime
argument_list|(
name|t
operator|*
literal|60
operator|+
name|p
operator|->
name|tm_min
argument_list|,
name|pm
condition|?
literal|"pm"
else|:
literal|"am"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * readpr finds and reads in the array pr, containing the interesting  * parts of the proc and user tables for each live process.  */
end_comment

begin_macro
name|readpr
argument_list|()
end_macro

begin_block
block|{
name|int
name|pn
decl_stmt|,
name|mf
decl_stmt|,
name|addr
decl_stmt|,
name|c
decl_stmt|;
name|int
name|szpt
decl_stmt|,
name|pfnum
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|pte
modifier|*
name|Usrptma
decl_stmt|,
modifier|*
name|usrpt
decl_stmt|,
modifier|*
name|pte
decl_stmt|,
name|apte
decl_stmt|;
name|struct
name|dblock
name|db
decl_stmt|;
name|Usrptma
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|nl
index|[
name|X_USRPTMA
index|]
operator|.
name|n_value
expr_stmt|;
name|usrpt
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|nl
index|[
name|X_USRPT
index|]
operator|.
name|n_value
expr_stmt|;
if|if
condition|(
operator|(
name|mem
operator|=
name|open
argument_list|(
literal|"/dev/mem"
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No mem\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|swap
operator|=
name|open
argument_list|(
literal|"/dev/drum"
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No drum\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * read mem to find swap dev. 	 */
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|X_SWAPDEV
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|nl
index|[
name|X_SWAPDEV
index|]
operator|.
name|n_value
argument_list|,
sizeof|sizeof
argument_list|(
name|nl
index|[
name|X_SWAPDEV
index|]
operator|.
name|n_value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Find base of and parameters of swap 	 */
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|X_NSWAP
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|nswap
argument_list|,
sizeof|sizeof
argument_list|(
name|nswap
argument_list|)
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|X_DMMIN
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|dmmin
argument_list|,
sizeof|sizeof
argument_list|(
name|dmmin
argument_list|)
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|X_DMMAX
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|dmmax
argument_list|,
sizeof|sizeof
argument_list|(
name|dmmax
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Locate proc table 	 */
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|X_NPROC
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|nproc
argument_list|,
sizeof|sizeof
argument_list|(
name|nproc
argument_list|)
argument_list|)
expr_stmt|;
name|pr
operator|=
operator|(
expr|struct
name|pr
operator|*
operator|)
name|calloc
argument_list|(
name|nproc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|=
literal|0
expr_stmt|;
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|X_PROC
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|aproc
argument_list|,
sizeof|sizeof
argument_list|(
name|aproc
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pn
operator|=
literal|0
init|;
name|pn
operator|<
name|nproc
condition|;
name|pn
operator|++
control|)
block|{
name|lseek
argument_list|(
name|kmem
argument_list|,
call|(
name|int
call|)
argument_list|(
name|aproc
operator|+
name|pn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|mproc
argument_list|,
sizeof|sizeof
name|mproc
argument_list|)
expr_stmt|;
comment|/* decide if it's an interesting process */
if|if
condition|(
name|mproc
operator|.
name|p_stat
operator|==
literal|0
operator|||
name|mproc
operator|.
name|p_pgrp
operator|==
literal|0
condition|)
continue|continue;
comment|/* find& read in the user structure */
if|if
condition|(
operator|(
name|mproc
operator|.
name|p_flag
operator|&
name|SLOAD
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* not in memory - get from swap device */
name|addr
operator|=
name|dtob
argument_list|(
name|mproc
operator|.
name|p_swaddr
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|swap
argument_list|,
operator|(
name|long
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|swap
argument_list|,
operator|&
name|up
argument_list|,
sizeof|sizeof
argument_list|(
name|up
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|up
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
else|else
block|{
name|int
name|p0br
decl_stmt|,
name|cc
decl_stmt|;
define|#
directive|define
name|INTPPG
value|(NBPG / sizeof (int))
name|struct
name|pte
name|pagetbl
index|[
name|NBPG
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
index|]
decl_stmt|;
comment|/* loaded, get each page from memory separately */
name|szpt
operator|=
name|mproc
operator|.
name|p_szpt
expr_stmt|;
name|p0br
operator|=
operator|(
name|int
operator|)
name|mproc
operator|.
name|p_p0br
expr_stmt|;
name|pte
operator|=
operator|&
name|Usrptma
index|[
name|btokmx
argument_list|(
name|mproc
operator|.
name|p_p0br
argument_list|)
operator|+
name|szpt
operator|-
literal|1
index|]
expr_stmt|;
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|pte
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|apte
argument_list|,
sizeof|sizeof
argument_list|(
name|apte
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|apte
argument_list|)
condition|)
continue|continue;
name|lseek
argument_list|(
name|mem
argument_list|,
name|ctob
argument_list|(
name|apte
operator|.
name|pg_pfnum
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
name|pagetbl
argument_list|,
sizeof|sizeof
argument_list|(
name|pagetbl
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|pagetbl
argument_list|)
condition|)
name|cont
label|:
continue|continue;
for|for
control|(
name|cc
operator|=
literal|0
init|;
name|cc
operator|<
name|UPAGES
condition|;
name|cc
operator|++
control|)
block|{
comment|/* get u area */
name|int
name|upage
init|=
name|pagetbl
index|[
name|NPTEPG
operator|-
name|UPAGES
operator|+
name|cc
index|]
operator|.
name|pg_pfnum
decl_stmt|;
name|lseek
argument_list|(
name|mem
argument_list|,
name|ctob
argument_list|(
name|upage
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|up
operator|)
operator|+
name|INTPPG
operator|*
name|cc
argument_list|,
name|NBPG
argument_list|)
operator|!=
name|NBPG
condition|)
goto|goto
name|cont
goto|;
block|}
name|szpt
operator|=
name|up
operator|.
name|u_pcb
operator|.
name|pcb_szpt
expr_stmt|;
name|pr
index|[
name|np
index|]
operator|.
name|w_seekaddr
operator|=
name|ctob
argument_list|(
name|apte
operator|.
name|pg_pfnum
argument_list|)
expr_stmt|;
block|}
name|vstodb
argument_list|(
literal|0
argument_list|,
name|CLSIZE
argument_list|,
operator|&
name|up
operator|.
name|u_smap
argument_list|,
operator|&
name|db
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pr
index|[
name|np
index|]
operator|.
name|w_lastpg
operator|=
name|dtob
argument_list|(
name|db
operator|.
name|db_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|.
name|u_ttyp
operator|==
name|NULL
condition|)
continue|continue;
comment|/* save the interesting parts */
name|pr
index|[
name|np
index|]
operator|.
name|w_pid
operator|=
name|mproc
operator|.
name|p_pid
expr_stmt|;
name|pr
index|[
name|np
index|]
operator|.
name|w_flag
operator|=
name|mproc
operator|.
name|p_flag
expr_stmt|;
name|pr
index|[
name|np
index|]
operator|.
name|w_size
operator|=
name|mproc
operator|.
name|p_dsize
operator|+
name|mproc
operator|.
name|p_ssize
expr_stmt|;
name|pr
index|[
name|np
index|]
operator|.
name|w_igintr
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|up
operator|.
name|u_signal
index|[
literal|2
index|]
operator|==
literal|1
operator|)
operator|+
literal|2
operator|*
operator|(
operator|(
name|int
operator|)
name|up
operator|.
name|u_signal
index|[
literal|2
index|]
operator|>
literal|1
operator|)
operator|+
literal|3
operator|*
operator|(
operator|(
name|int
operator|)
name|up
operator|.
name|u_signal
index|[
literal|3
index|]
operator|==
literal|1
operator|)
operator|)
operator|+
literal|6
operator|*
operator|(
operator|(
name|int
operator|)
name|up
operator|.
name|u_signal
index|[
literal|3
index|]
operator|>
literal|1
operator|)
expr_stmt|;
name|pr
index|[
name|np
index|]
operator|.
name|w_time
operator|=
name|up
operator|.
name|u_ru
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|+
name|up
operator|.
name|u_ru
operator|.
name|ru_stime
operator|.
name|tv_sec
expr_stmt|;
name|pr
index|[
name|np
index|]
operator|.
name|w_ctime
operator|=
name|up
operator|.
name|u_cru
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|+
name|up
operator|.
name|u_cru
operator|.
name|ru_stime
operator|.
name|tv_sec
expr_stmt|;
name|pr
index|[
name|np
index|]
operator|.
name|w_tty
operator|=
name|up
operator|.
name|u_ttyd
expr_stmt|;
name|pr
index|[
name|np
index|]
operator|.
name|w_uid
operator|=
name|mproc
operator|.
name|p_uid
expr_stmt|;
name|up
operator|.
name|u_comm
index|[
literal|14
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Bug: This bombs next field. */
name|strcpy
argument_list|(
name|pr
index|[
name|np
index|]
operator|.
name|w_comm
argument_list|,
name|up
operator|.
name|u_comm
argument_list|)
expr_stmt|;
comment|/* 		 * Get args if there's a chance we'll print it. 		 * Cant just save pointer: getargs returns static place. 		 * Cant use strcpyn: that crock blank pads. 		 */
name|pr
index|[
name|np
index|]
operator|.
name|w_args
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strcatn
argument_list|(
name|pr
index|[
name|np
index|]
operator|.
name|w_args
argument_list|,
name|getargs
argument_list|(
operator|&
name|pr
index|[
name|np
index|]
argument_list|)
argument_list|,
name|ARGWIDTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
index|[
name|np
index|]
operator|.
name|w_args
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|pr
index|[
name|np
index|]
operator|.
name|w_args
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|pr
index|[
name|np
index|]
operator|.
name|w_args
index|[
literal|1
index|]
operator|<=
literal|' '
operator|||
name|pr
index|[
name|np
index|]
operator|.
name|w_args
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
block|{
name|strcat
argument_list|(
name|pr
index|[
name|np
index|]
operator|.
name|w_args
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pr
index|[
name|np
index|]
operator|.
name|w_args
argument_list|,
name|pr
index|[
name|np
index|]
operator|.
name|w_comm
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pr
index|[
name|np
index|]
operator|.
name|w_args
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|np
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * getargs: given a pointer to a proc structure, this looks at the swap area  * and tries to reconstruct the arguments. This is straight out of ps.  */
end_comment

begin_function
name|char
modifier|*
name|getargs
parameter_list|(
name|p
parameter_list|)
name|struct
name|pr
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|addr
decl_stmt|,
name|nbad
decl_stmt|;
specifier|static
name|int
name|abuf
index|[
name|CLSIZE
operator|*
name|NBPG
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
name|struct
name|pte
name|pagetbl
index|[
name|NPTEPG
index|]
decl_stmt|;
specifier|register
name|int
modifier|*
name|ip
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|w_flag
operator|&
name|SLOAD
operator|)
operator|==
literal|0
condition|)
block|{
name|lseek
argument_list|(
name|swap
argument_list|,
name|p
operator|->
name|w_lastpg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|swap
argument_list|,
name|abuf
argument_list|,
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
condition|)
return|return
operator|(
name|p
operator|->
name|w_comm
operator|)
return|;
block|}
else|else
block|{
name|c
operator|=
name|p
operator|->
name|w_seekaddr
expr_stmt|;
name|lseek
argument_list|(
name|mem
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
name|pagetbl
argument_list|,
name|NBPG
argument_list|)
operator|!=
name|NBPG
condition|)
return|return
operator|(
name|p
operator|->
name|w_comm
operator|)
return|;
if|if
condition|(
name|pagetbl
index|[
name|NPTEPG
operator|-
name|CLSIZE
operator|-
name|UPAGES
index|]
operator|.
name|pg_fod
operator|==
literal|0
operator|&&
name|pagetbl
index|[
name|NPTEPG
operator|-
name|CLSIZE
operator|-
name|UPAGES
index|]
operator|.
name|pg_pfnum
condition|)
block|{
name|lseek
argument_list|(
name|mem
argument_list|,
name|ctob
argument_list|(
name|pagetbl
index|[
name|NPTEPG
operator|-
name|CLSIZE
operator|-
name|UPAGES
index|]
operator|.
name|pg_pfnum
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
name|abuf
argument_list|,
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
condition|)
return|return
operator|(
name|p
operator|->
name|w_comm
operator|)
return|;
block|}
else|else
block|{
name|lseek
argument_list|(
name|swap
argument_list|,
name|p
operator|->
name|w_lastpg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|swap
argument_list|,
name|abuf
argument_list|,
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
condition|)
return|return
operator|(
name|p
operator|->
name|w_comm
operator|)
return|;
block|}
block|}
name|abuf
index|[
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|abuf
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ip
operator|=
operator|&
name|abuf
index|[
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|abuf
index|[
literal|0
index|]
argument_list|)
operator|-
literal|2
index|]
init|;
name|ip
operator|>
name|abuf
condition|;
control|)
block|{
comment|/* Look from top for -1 or 0 as terminator flag. */
if|if
condition|(
operator|*
operator|--
name|ip
operator|==
operator|-
literal|1
operator|||
operator|*
name|ip
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
name|cp
operator|++
expr_stmt|;
name|nbad
operator|=
literal|0
expr_stmt|;
comment|/* up to 5 funny chars as ?'s */
for|for
control|(
name|cp1
operator|=
name|cp
init|;
name|cp1
operator|<
operator|(
name|char
operator|*
operator|)
operator|&
name|abuf
index|[
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|abuf
index|[
literal|0
index|]
argument_list|)
index|]
condition|;
name|cp1
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|cp1
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
comment|/* nulls between args => spaces */
operator|*
name|cp1
operator|=
literal|' '
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|' '
operator|||
name|c
operator|>
literal|0176
condition|)
block|{
if|if
condition|(
operator|++
name|nbad
operator|>=
literal|5
condition|)
block|{
operator|*
name|cp1
operator|++
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
operator|*
name|cp1
operator|=
literal|'?'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
comment|/* Oops - found an 							 * environment var, back 							 * over& erase it. */
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp1
operator|>
name|cp
operator|&&
operator|*
operator|--
name|cp1
operator|!=
literal|' '
condition|)
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
operator|*
operator|--
name|cp1
operator|==
literal|' '
condition|)
comment|/* strip trailing spaces */
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
block|}
return|return
operator|(
name|p
operator|->
name|w_comm
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a base/size pair in virtual swap area,  * return a physical base/size pair which is the  * (largest) initial, physically contiguous block.  */
end_comment

begin_expr_stmt
name|vstodb
argument_list|(
name|vsbase
argument_list|,
name|vssize
argument_list|,
name|dmp
argument_list|,
name|dbp
argument_list|,
name|rev
argument_list|)
specifier|register
name|int
name|vsbase
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|vssize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dmap
modifier|*
name|dmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|dblock
modifier|*
name|dbp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|blk
init|=
name|dmmin
decl_stmt|;
specifier|register
name|swblk_t
modifier|*
name|ip
init|=
name|dmp
operator|->
name|dm_map
decl_stmt|;
name|vsbase
operator|=
name|ctod
argument_list|(
name|vsbase
argument_list|)
expr_stmt|;
name|vssize
operator|=
name|ctod
argument_list|(
name|vssize
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsbase
operator|<
literal|0
operator|||
name|vsbase
operator|+
name|vssize
operator|>
name|dmp
operator|->
name|dm_size
condition|)
name|panic
argument_list|(
literal|"vstodb"
argument_list|)
expr_stmt|;
while|while
condition|(
name|vsbase
operator|>=
name|blk
condition|)
block|{
name|vsbase
operator|-=
name|blk
expr_stmt|;
if|if
condition|(
name|blk
operator|<
name|dmmax
condition|)
name|blk
operator|*=
literal|2
expr_stmt|;
name|ip
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ip
operator|<=
literal|0
operator|||
operator|*
name|ip
operator|+
name|blk
operator|>
name|nswap
condition|)
name|panic
argument_list|(
literal|"vstodb *ip"
argument_list|)
expr_stmt|;
name|dbp
operator|->
name|db_size
operator|=
name|min
argument_list|(
name|vssize
argument_list|,
name|blk
operator|-
name|vsbase
argument_list|)
expr_stmt|;
name|dbp
operator|->
name|db_base
operator|=
operator|*
name|ip
operator|+
operator|(
name|rev
condition|?
name|blk
operator|-
operator|(
name|vsbase
operator|+
name|dbp
operator|->
name|db_size
operator|)
else|:
name|vsbase
operator|)
expr_stmt|;
block|}
end_block

begin_macro
name|panic
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* printf("%s\n", cp); */
block|}
end_block

begin_macro
name|min
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
name|a
operator|<
name|b
condition|?
name|a
else|:
name|b
operator|)
return|;
block|}
end_block

end_unit

