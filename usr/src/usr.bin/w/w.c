begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)w.c	5.13 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * w - print system status (who and what)  *  * This program is similar to the systat command on Tenex/Tops 10/20  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<sys/vm.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_define
define|#
directive|define
name|ARGWIDTH
value|33
end_define

begin_comment
comment|/* # chars left on 80 col crt for args */
end_comment

begin_struct
struct|struct
name|pr
block|{
name|short
name|w_pid
decl_stmt|;
comment|/* proc.p_pid */
name|char
name|w_flag
decl_stmt|;
comment|/* proc.p_flag */
name|short
name|w_size
decl_stmt|;
comment|/* proc.p_size */
name|long
name|w_seekaddr
decl_stmt|;
comment|/* where to find args */
name|long
name|w_lastpg
decl_stmt|;
comment|/* disk address of stack */
name|int
name|w_igintr
decl_stmt|;
comment|/* INTR+3*QUIT, 0=die, 1=ign, 2=catch */
name|time_t
name|w_time
decl_stmt|;
comment|/* CPU time used by this process */
name|time_t
name|w_ctime
decl_stmt|;
comment|/* CPU time used by children */
name|dev_t
name|w_tty
decl_stmt|;
comment|/* tty device of process */
name|int
name|w_uid
decl_stmt|;
comment|/* uid of process */
name|char
name|w_comm
index|[
literal|15
index|]
decl_stmt|;
comment|/* user.u_comm, null terminated */
name|char
name|w_args
index|[
name|ARGWIDTH
operator|+
literal|1
index|]
decl_stmt|;
comment|/* args if interesting process */
block|}
modifier|*
name|pr
struct|;
end_struct

begin_decl_stmt
name|int
name|nproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
block|{
literal|"_nproc"
block|}
block|,
define|#
directive|define
name|X_NPROC
value|0
block|{
literal|"_boottime"
block|}
block|,
define|#
directive|define
name|X_BOOTTIME
value|1
block|{
literal|"_proc"
block|}
block|,
define|#
directive|define
name|X_PROC
value|2
block|{
literal|"_swapdev"
block|}
block|,
define|#
directive|define
name|X_SWAPDEV
value|3
block|{
literal|"_Usrptmap"
block|}
block|,
define|#
directive|define
name|X_USRPTMA
value|4
block|{
literal|"_usrpt"
block|}
block|,
define|#
directive|define
name|X_USRPT
value|5
block|{
literal|"_nswap"
block|}
block|,
define|#
directive|define
name|X_NSWAP
value|6
block|{
literal|"_dmmin"
block|}
block|,
define|#
directive|define
name|X_DMMIN
value|7
block|{
literal|"_dmmax"
block|}
block|,
define|#
directive|define
name|X_DMMAX
value|8
block|{
literal|""
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|ps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|ut
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|bootfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|kmem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|swap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* kmem, mem, and swap */
end_comment

begin_decl_stmt
name|int
name|nswap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dmmin
decl_stmt|,
name|dmmax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dev_t
name|tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|doing
index|[
literal|520
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* process attached to terminal */
end_comment

begin_decl_stmt
name|time_t
name|proctime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cpu time of process in doing */
end_comment

begin_decl_stmt
name|double
name|avenrun
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|aproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pid_t
name|pgid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pid_t
name|tpgid
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DIV60
parameter_list|(
name|t
parameter_list|)
value|((t+30)/60)
end_define

begin_comment
comment|/* x/60 rounded */
end_comment

begin_define
define|#
directive|define
name|TTYEQ
value|(tty == pr[i].w_tty)
end_define

begin_define
define|#
directive|define
name|IGINT
value|(1+3*1)
end_define

begin_comment
comment|/* ignoring both SIGINT& SIGQUIT */
end_comment

begin_function_decl
name|char
modifier|*
name|getargs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|time_t
name|findidle
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -d flag: debugging output */
end_comment

begin_decl_stmt
name|int
name|ttywidth
init|=
literal|80
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* width of tty */
end_comment

begin_decl_stmt
name|int
name|header
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -h flag: don't print heading */
end_comment

begin_decl_stmt
name|int
name|lflag
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -l flag: long style output */
end_comment

begin_decl_stmt
name|int
name|prfrom
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if not -f flag: print host from */
end_comment

begin_decl_stmt
name|int
name|login
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if invoked as login shell */
end_comment

begin_decl_stmt
name|time_t
name|idle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of minutes user is idle */
end_comment

begin_decl_stmt
name|int
name|nusers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of users logged in now */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sel_user
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* login of particular user selected */
end_comment

begin_decl_stmt
name|char
name|firstchar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first char of name of prog invoked as */
end_comment

begin_decl_stmt
name|time_t
name|jobtime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total cpu time visible */
end_comment

begin_decl_stmt
name|time_t
name|now
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the current time of day */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|boottime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|uptime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time of last reboot& elapsed time since */
end_comment

begin_decl_stmt
name|int
name|np
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of processes currently active */
end_comment

begin_decl_stmt
name|struct
name|utmp
name|utmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
name|mproc
decl_stmt|;
end_decl_stmt

begin_union
union|union
block|{
name|struct
name|user
name|U_up
decl_stmt|;
name|char
name|pad
index|[
name|NBPG
index|]
index|[
name|UPAGES
index|]
decl_stmt|;
block|}
name|Up
union|;
end_union

begin_define
define|#
directive|define
name|up
value|Up.U_up
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|days
decl_stmt|,
name|hrs
decl_stmt|,
name|mins
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|curpid
decl_stmt|,
name|empty
decl_stmt|;
name|struct
name|winsize
name|win
decl_stmt|;
name|login
operator|=
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
expr_stmt|;
name|cp
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|firstchar
operator|=
name|login
condition|?
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
else|:
operator|(
name|cp
operator|==
literal|0
operator|)
condition|?
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
else|:
name|cp
index|[
literal|1
index|]
expr_stmt|;
name|cp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* for Usage */
while|while
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|argv
index|[
literal|1
index|]
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'d'
case|:
name|debug
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|prfrom
operator|=
operator|!
name|prfrom
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|header
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|lflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|lflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
case|case
literal|'w'
case|:
name|firstchar
operator|=
name|argv
index|[
literal|1
index|]
index|[
name|i
index|]
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Bad flag %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|||
name|argc
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: %s [ -hlsfuw ] [ user ]\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|sel_user
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|kmem
operator|=
name|open
argument_list|(
name|_PATH_KMEM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"w: no %s.\n"
argument_list|,
name|_PATH_KMEM
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|nlist
argument_list|(
name|_PATH_UNIX
argument_list|,
name|nl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
index|[
literal|0
index|]
operator|.
name|n_type
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"w: no %s namelist.\n"
argument_list|,
name|_PATH_UNIX
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|firstchar
operator|==
literal|'u'
condition|)
comment|/* uptime(1) */
name|nl
index|[
name|X_BOOTTIME
operator|+
literal|1
index|]
operator|.
name|n_name
operator|=
literal|""
expr_stmt|;
else|else
block|{
comment|/* then read in procs, get window size */
name|readpr
argument_list|()
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|win
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|win
operator|.
name|ws_col
operator|>
literal|70
condition|)
name|ttywidth
operator|=
name|win
operator|.
name|ws_col
expr_stmt|;
block|}
name|ut
operator|=
name|fopen
argument_list|(
name|_PATH_UTMP
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
condition|)
block|{
comment|/* Print time of day */
name|prtat
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* 		 * Print how long system has been up. 		 * (Found by looking for "boottime" in kernel) 		 */
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|X_BOOTTIME
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|boottime
argument_list|,
sizeof|sizeof
argument_list|(
name|boottime
argument_list|)
argument_list|)
expr_stmt|;
name|uptime
operator|=
name|now
operator|-
name|boottime
operator|.
name|tv_sec
expr_stmt|;
name|uptime
operator|+=
literal|30
expr_stmt|;
name|days
operator|=
name|uptime
operator|/
operator|(
literal|60
operator|*
literal|60
operator|*
literal|24
operator|)
expr_stmt|;
name|uptime
operator|%=
operator|(
literal|60
operator|*
literal|60
operator|*
literal|24
operator|)
expr_stmt|;
name|hrs
operator|=
name|uptime
operator|/
operator|(
literal|60
operator|*
literal|60
operator|)
expr_stmt|;
name|uptime
operator|%=
operator|(
literal|60
operator|*
literal|60
operator|)
expr_stmt|;
name|mins
operator|=
name|uptime
operator|/
literal|60
expr_stmt|;
name|printf
argument_list|(
literal|"  up"
argument_list|)
expr_stmt|;
if|if
condition|(
name|days
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %d day%s,"
argument_list|,
name|days
argument_list|,
name|days
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|hrs
operator|>
literal|0
operator|&&
name|mins
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" %2d:%02d,"
argument_list|,
name|hrs
argument_list|,
name|mins
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hrs
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %d hr%s,"
argument_list|,
name|hrs
argument_list|,
name|hrs
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|mins
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %d min%s,"
argument_list|,
name|mins
argument_list|,
name|mins
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* Print number of users logged in to system */
while|while
condition|(
name|fread
argument_list|(
operator|&
name|utmp
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|ut
argument_list|)
condition|)
block|{
if|if
condition|(
name|utmp
operator|.
name|ut_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|nusers
operator|++
expr_stmt|;
block|}
name|rewind
argument_list|(
name|ut
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %d user%s"
argument_list|,
name|nusers
argument_list|,
name|nusers
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* 		 * Print 1, 5, and 15 minute load averages. 		 */
name|printf
argument_list|(
literal|",  load average:"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getloadavg
argument_list|(
name|avenrun
argument_list|,
sizeof|sizeof
argument_list|(
name|avenrun
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|avenrun
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|avenrun
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|avenrun
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %.2f"
argument_list|,
name|avenrun
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstchar
operator|==
literal|'u'
condition|)
comment|/* if this was uptime(1), finished */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Headers for rest of output */
if|if
condition|(
name|lflag
operator|&&
name|prfrom
condition|)
name|printf
argument_list|(
literal|"USER    TTY FROM            LOGIN@  IDLE   JCPU   PCPU  WHAT\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lflag
condition|)
name|printf
argument_list|(
literal|"USER     TTY       LOGIN@  IDLE   JCPU   PCPU  WHAT\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prfrom
condition|)
name|printf
argument_list|(
literal|"USER    TTY FROM            IDLE  WHAT\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"USER    TTY  IDLE  WHAT\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* for each entry in utmp */
if|if
condition|(
name|fread
argument_list|(
operator|&
name|utmp
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|ut
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|ut
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|utmp
operator|.
name|ut_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* that tty is free */
if|if
condition|(
name|sel_user
operator|&&
name|strncmp
argument_list|(
name|utmp
operator|.
name|ut_name
argument_list|,
name|sel_user
argument_list|,
name|UT_NAMESIZE
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* we wanted only somebody else */
name|gettty
argument_list|()
expr_stmt|;
name|jobtime
operator|=
literal|0
expr_stmt|;
name|proctime
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|doing
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
comment|/* default act: normally never prints */
name|empty
operator|=
literal|1
expr_stmt|;
name|curpid
operator|=
operator|-
literal|1
expr_stmt|;
name|idle
operator|=
name|findidle
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|np
condition|;
name|i
operator|++
control|)
block|{
comment|/* for each process on this tty */
if|if
condition|(
operator|!
operator|(
name|TTYEQ
operator|)
condition|)
continue|continue;
name|jobtime
operator|+=
name|pr
index|[
name|i
index|]
operator|.
name|w_time
operator|+
name|pr
index|[
name|i
index|]
operator|.
name|w_ctime
expr_stmt|;
name|proctime
operator|+=
name|pr
index|[
name|i
index|]
operator|.
name|w_time
expr_stmt|;
comment|/*  			 * Meaning of debug fields following proc name is: 			 *& by itself: ignoring both SIGINT and QUIT. 			 *		(==> this proc is not a candidate.) 			 *&<i><q>:   i is SIGINT status, q is quit. 			 *		0 == DFL, 1 == IGN, 2 == caught. 			 * *:		proc pgrp == tty pgrp. 			 */
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"\t\t%d\t%s"
argument_list|,
name|pr
index|[
name|i
index|]
operator|.
name|w_pid
argument_list|,
name|pr
index|[
name|i
index|]
operator|.
name|w_args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|pr
index|[
name|i
index|]
operator|.
name|w_igintr
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|j
operator|==
name|IGINT
condition|)
name|printf
argument_list|(
literal|"&"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"& %d %d"
argument_list|,
name|j
operator|%
literal|3
argument_list|,
name|j
operator|/
literal|3
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|empty
operator|&&
name|pr
index|[
name|i
index|]
operator|.
name|w_igintr
operator|!=
name|IGINT
condition|)
block|{
name|empty
operator|=
literal|0
expr_stmt|;
name|curpid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pr
index|[
name|i
index|]
operator|.
name|w_pid
operator|>
name|curpid
operator|&&
operator|(
name|pr
index|[
name|i
index|]
operator|.
name|w_igintr
operator|!=
name|IGINT
operator|||
name|empty
operator|)
condition|)
block|{
name|curpid
operator|=
name|pr
index|[
name|i
index|]
operator|.
name|w_pid
expr_stmt|;
name|strcpy
argument_list|(
name|doing
argument_list|,
name|lflag
condition|?
name|pr
index|[
name|i
index|]
operator|.
name|w_args
else|:
name|pr
index|[
name|i
index|]
operator|.
name|w_comm
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|doing
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|doing
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|doing
index|[
literal|1
index|]
operator|<=
literal|' '
operator|||
name|doing
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
block|{
name|strcat
argument_list|(
name|doing
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|doing
argument_list|,
name|pr
index|[
name|i
index|]
operator|.
name|w_comm
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|doing
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|putline
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* figure out the major/minor device # pair for this tty */
end_comment

begin_macro
name|gettty
argument_list|()
end_macro

begin_block
block|{
name|char
name|ttybuf
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|ttybuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|ttybuf
argument_list|,
name|_PATH_DEV
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ttybuf
argument_list|,
name|utmp
operator|.
name|ut_line
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|ttybuf
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
name|tty
operator|=
name|statbuf
operator|.
name|st_rdev
expr_stmt|;
name|uid
operator|=
name|statbuf
operator|.
name|st_uid
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * putline: print out the accumulated line of info about one user.  */
end_comment

begin_macro
name|putline
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|tm
decl_stmt|;
name|int
name|width
init|=
name|ttywidth
operator|-
literal|1
decl_stmt|;
comment|/* print login name of the user */
name|printf
argument_list|(
literal|"%-*.*s "
argument_list|,
name|UT_NAMESIZE
argument_list|,
name|UT_NAMESIZE
argument_list|,
name|utmp
operator|.
name|ut_name
argument_list|)
expr_stmt|;
name|width
operator|-=
name|UT_NAMESIZE
operator|+
literal|1
expr_stmt|;
comment|/* print tty user is on */
if|if
condition|(
name|lflag
operator|&&
operator|!
name|prfrom
condition|)
block|{
comment|/* long form: all (up to) UT_LINESIZE chars */
name|printf
argument_list|(
literal|"%-*.*s"
argument_list|,
name|UT_LINESIZE
argument_list|,
name|UT_LINESIZE
argument_list|,
name|utmp
operator|.
name|ut_line
argument_list|)
expr_stmt|;
name|width
operator|-=
name|UT_LINESIZE
expr_stmt|;
block|}
else|else
block|{
comment|/* short form: 2 chars, skipping 'tty' if there */
if|if
condition|(
name|utmp
operator|.
name|ut_line
index|[
literal|0
index|]
operator|==
literal|'t'
operator|&&
name|utmp
operator|.
name|ut_line
index|[
literal|1
index|]
operator|==
literal|'t'
operator|&&
name|utmp
operator|.
name|ut_line
index|[
literal|2
index|]
operator|==
literal|'y'
condition|)
name|printf
argument_list|(
literal|"%-2.2s"
argument_list|,
operator|&
name|utmp
operator|.
name|ut_line
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-2.2s"
argument_list|,
name|utmp
operator|.
name|ut_line
argument_list|)
expr_stmt|;
name|width
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|prfrom
condition|)
block|{
if|if
condition|(
operator|*
name|utmp
operator|.
name|ut_host
operator|==
literal|'\0'
condition|)
name|printf
argument_list|(
literal|" -             "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %-14.14s"
argument_list|,
name|utmp
operator|.
name|ut_host
argument_list|)
expr_stmt|;
name|width
operator|-=
literal|15
expr_stmt|;
block|}
if|if
condition|(
name|lflag
condition|)
block|{
comment|/* print when the user logged in */
name|prtat
argument_list|(
operator|&
name|utmp
operator|.
name|ut_time
argument_list|)
expr_stmt|;
name|width
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* print idle time */
if|if
condition|(
name|idle
operator|>=
literal|36
operator|*
literal|60
condition|)
name|printf
argument_list|(
literal|"%2ddays "
argument_list|,
operator|(
name|idle
operator|+
literal|12
operator|*
literal|60
operator|)
operator|/
operator|(
literal|24
operator|*
literal|60
operator|)
argument_list|)
expr_stmt|;
else|else
name|prttime
argument_list|(
name|idle
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|width
operator|-=
literal|7
expr_stmt|;
if|if
condition|(
name|lflag
condition|)
block|{
comment|/* print CPU time for all processes& children */
name|prttime
argument_list|(
name|jobtime
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|width
operator|-=
literal|7
expr_stmt|;
comment|/* print cpu time for interesting process */
name|prttime
argument_list|(
name|proctime
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|width
operator|-=
literal|7
expr_stmt|;
block|}
comment|/* what user is doing, either command tail or args */
name|printf
argument_list|(
literal|" %-.*s\n"
argument_list|,
name|width
operator|-
literal|1
argument_list|,
name|doing
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* find& return number of minutes current tty has been idle */
end_comment

begin_function
name|time_t
name|findidle
parameter_list|()
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
name|long
name|lastaction
decl_stmt|,
name|diff
decl_stmt|;
name|char
name|ttyname
index|[
literal|20
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|ttyname
argument_list|,
name|_PATH_DEV
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|ttyname
argument_list|,
name|utmp
operator|.
name|ut_line
argument_list|,
name|UT_LINESIZE
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|ttyname
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|lastaction
operator|=
name|stbuf
operator|.
name|st_atime
expr_stmt|;
name|diff
operator|=
name|now
operator|-
name|lastaction
expr_stmt|;
name|diff
operator|=
name|DIV60
argument_list|(
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|diff
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|diff
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HR
value|(60 * 60)
end_define

begin_define
define|#
directive|define
name|DAY
value|(24 * HR)
end_define

begin_define
define|#
directive|define
name|MON
value|(30 * DAY)
end_define

begin_comment
comment|/*  * prttime prints a time in hours and minutes or minutes and seconds.  * The character string tail is printed at the end, obvious  * strings to pass are "", " ", or "am".  */
end_comment

begin_macro
name|prttime
argument_list|(
argument|tim
argument_list|,
argument|tail
argument_list|)
end_macro

begin_decl_stmt
name|time_t
name|tim
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tail
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|tim
operator|>=
literal|60
condition|)
block|{
name|printf
argument_list|(
literal|" %2d:"
argument_list|,
name|tim
operator|/
literal|60
argument_list|)
expr_stmt|;
name|tim
operator|%=
literal|60
expr_stmt|;
name|printf
argument_list|(
literal|"%02d"
argument_list|,
name|tim
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tim
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"    %2d"
argument_list|,
name|tim
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|weekday
index|[]
init|=
block|{
literal|"Sun"
block|,
literal|"Mon"
block|,
literal|"Tue"
block|,
literal|"Wed"
block|,
literal|"Thu"
block|,
literal|"Fri"
block|,
literal|"Sat"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|month
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prtat prints a 12 hour time given a pointer to a time of day */
end_comment

begin_macro
name|prtat
argument_list|(
argument|time
argument_list|)
end_macro

begin_decl_stmt
name|long
modifier|*
name|time
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tm
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|hr
decl_stmt|,
name|pm
decl_stmt|;
name|p
operator|=
name|localtime
argument_list|(
name|time
argument_list|)
expr_stmt|;
name|hr
operator|=
name|p
operator|->
name|tm_hour
expr_stmt|;
name|pm
operator|=
operator|(
name|hr
operator|>
literal|11
operator|)
expr_stmt|;
if|if
condition|(
name|hr
operator|>
literal|11
condition|)
name|hr
operator|-=
literal|12
expr_stmt|;
if|if
condition|(
name|hr
operator|==
literal|0
condition|)
name|hr
operator|=
literal|12
expr_stmt|;
if|if
condition|(
name|now
operator|-
operator|*
name|time
operator|<=
literal|18
operator|*
name|HR
condition|)
name|prttime
argument_list|(
name|hr
operator|*
literal|60
operator|+
name|p
operator|->
name|tm_min
argument_list|,
name|pm
condition|?
literal|"pm"
else|:
literal|"am"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|now
operator|-
operator|*
name|time
operator|<=
literal|7
operator|*
name|DAY
condition|)
name|printf
argument_list|(
literal|" %*s%d%s"
argument_list|,
name|hr
operator|<
literal|10
condition|?
literal|4
else|:
literal|3
argument_list|,
name|weekday
index|[
name|p
operator|->
name|tm_wday
index|]
argument_list|,
name|hr
argument_list|,
name|pm
condition|?
literal|"pm"
else|:
literal|"am"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %2d%s%2d"
argument_list|,
name|p
operator|->
name|tm_mday
argument_list|,
name|month
index|[
name|p
operator|->
name|tm_mon
index|]
argument_list|,
name|p
operator|->
name|tm_year
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * readpr finds and reads in the array pr, containing the interesting  * parts of the proc and user tables for each live process.  * We only accept procs whos controlling tty has a pgrp equal to the  * pgrp of the proc.  This accurately defines the notion of the current  * process(s), but because of time skew, we always read in the tty struct  * after reading the proc, even though the same tty struct may have been  * read earlier on.  */
end_comment

begin_macro
name|readpr
argument_list|()
end_macro

begin_block
block|{
name|int
name|pn
decl_stmt|,
name|mf
decl_stmt|,
name|addr
decl_stmt|,
name|c
decl_stmt|;
name|int
name|szpt
decl_stmt|,
name|pfnum
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|pte
modifier|*
name|Usrptma
decl_stmt|,
modifier|*
name|usrpt
decl_stmt|,
modifier|*
name|pte
decl_stmt|,
name|apte
decl_stmt|;
name|struct
name|dblock
name|db
decl_stmt|;
name|Usrptma
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|nl
index|[
name|X_USRPTMA
index|]
operator|.
name|n_value
expr_stmt|;
name|usrpt
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|nl
index|[
name|X_USRPT
index|]
operator|.
name|n_value
expr_stmt|;
if|if
condition|(
operator|(
name|mem
operator|=
name|open
argument_list|(
name|_PATH_MEM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"w: no %s.\n"
argument_list|,
name|_PATH_MEM
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|swap
operator|=
name|open
argument_list|(
name|_PATH_DRUM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"w: no %s\n"
argument_list|,
name|_PATH_DRUM
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * read mem to find swap dev. 	 */
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|X_SWAPDEV
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|nl
index|[
name|X_SWAPDEV
index|]
operator|.
name|n_value
argument_list|,
sizeof|sizeof
argument_list|(
name|nl
index|[
name|X_SWAPDEV
index|]
operator|.
name|n_value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Find base of and parameters of swap 	 */
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|X_NSWAP
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|nswap
argument_list|,
sizeof|sizeof
argument_list|(
name|nswap
argument_list|)
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|X_DMMIN
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|dmmin
argument_list|,
sizeof|sizeof
argument_list|(
name|dmmin
argument_list|)
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|X_DMMAX
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|dmmax
argument_list|,
sizeof|sizeof
argument_list|(
name|dmmax
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Locate proc table 	 */
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|X_NPROC
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|nproc
argument_list|,
sizeof|sizeof
argument_list|(
name|nproc
argument_list|)
argument_list|)
expr_stmt|;
name|pr
operator|=
operator|(
expr|struct
name|pr
operator|*
operator|)
name|calloc
argument_list|(
name|nproc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|=
literal|0
expr_stmt|;
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|X_PROC
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|aproc
argument_list|,
sizeof|sizeof
argument_list|(
name|aproc
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pn
operator|=
literal|0
init|;
name|pn
operator|<
name|nproc
condition|;
name|pn
operator|++
control|)
block|{
name|lseek
argument_list|(
name|kmem
argument_list|,
call|(
name|int
call|)
argument_list|(
name|aproc
operator|+
name|pn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|mproc
argument_list|,
sizeof|sizeof
name|mproc
argument_list|)
expr_stmt|;
comment|/* decide if it's an interesting process */
if|if
condition|(
name|mproc
operator|.
name|p_stat
operator|==
literal|0
operator|||
name|mproc
operator|.
name|p_stat
operator|==
name|SZOMB
operator|||
name|mproc
operator|.
name|p_stat
operator|==
name|SSTOP
operator|||
name|mproc
operator|.
name|p_pgrp
operator|==
literal|0
condition|)
continue|continue;
comment|/* find& read in the user structure */
if|if
condition|(
operator|(
name|mproc
operator|.
name|p_flag
operator|&
name|SLOAD
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* not in memory - get from swap device */
name|addr
operator|=
name|dtob
argument_list|(
name|mproc
operator|.
name|p_swaddr
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|swap
argument_list|,
operator|(
name|long
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|swap
argument_list|,
operator|&
name|up
argument_list|,
sizeof|sizeof
argument_list|(
name|up
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|up
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
else|else
block|{
name|int
name|p0br
decl_stmt|,
name|cc
decl_stmt|;
define|#
directive|define
name|INTPPG
value|(NBPG / sizeof (int))
name|struct
name|pte
name|pagetbl
index|[
name|NBPG
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
index|]
decl_stmt|;
comment|/* loaded, get each page from memory separately */
name|szpt
operator|=
name|mproc
operator|.
name|p_szpt
expr_stmt|;
name|p0br
operator|=
operator|(
name|int
operator|)
name|mproc
operator|.
name|p_p0br
expr_stmt|;
name|pte
operator|=
operator|&
name|Usrptma
index|[
name|btokmx
argument_list|(
name|mproc
operator|.
name|p_p0br
argument_list|)
operator|+
name|szpt
operator|-
literal|1
index|]
expr_stmt|;
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|pte
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|apte
argument_list|,
sizeof|sizeof
argument_list|(
name|apte
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|apte
argument_list|)
condition|)
continue|continue;
name|lseek
argument_list|(
name|mem
argument_list|,
name|ctob
argument_list|(
name|apte
operator|.
name|pg_pfnum
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
name|pagetbl
argument_list|,
sizeof|sizeof
argument_list|(
name|pagetbl
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|pagetbl
argument_list|)
condition|)
name|cont
label|:
continue|continue;
for|for
control|(
name|cc
operator|=
literal|0
init|;
name|cc
operator|<
name|UPAGES
condition|;
name|cc
operator|++
control|)
block|{
comment|/* get u area */
name|int
name|upage
init|=
name|pagetbl
index|[
name|NPTEPG
operator|-
name|UPAGES
operator|+
name|cc
index|]
operator|.
name|pg_pfnum
decl_stmt|;
name|lseek
argument_list|(
name|mem
argument_list|,
name|ctob
argument_list|(
name|upage
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|up
operator|)
operator|+
name|INTPPG
operator|*
name|cc
argument_list|,
name|NBPG
argument_list|)
operator|!=
name|NBPG
condition|)
goto|goto
name|cont
goto|;
block|}
name|szpt
operator|=
name|up
operator|.
name|u_pcb
operator|.
name|pcb_szpt
expr_stmt|;
name|pr
index|[
name|np
index|]
operator|.
name|w_seekaddr
operator|=
name|ctob
argument_list|(
name|apte
operator|.
name|pg_pfnum
argument_list|)
expr_stmt|;
block|}
name|vstodb
argument_list|(
literal|0
argument_list|,
name|CLSIZE
argument_list|,
operator|&
name|up
operator|.
name|u_smap
argument_list|,
operator|&
name|db
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pr
index|[
name|np
index|]
operator|.
name|w_lastpg
operator|=
name|dtob
argument_list|(
name|db
operator|.
name|db_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|.
name|u_ttyp
operator|==
name|NULL
condition|)
continue|continue;
comment|/* only include a process whose tty has a pgrp which matchs its own */
name|lseek
argument_list|(
name|kmem
argument_list|,
call|(
name|off_t
call|)
argument_list|(
operator|&
name|up
operator|.
name|u_ttyp
operator|->
name|t_pgid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|tpgid
argument_list|,
sizeof|sizeof
argument_list|(
name|tpgid
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|tpgid
argument_list|)
condition|)
continue|continue;
name|lseek
argument_list|(
name|kmem
argument_list|,
call|(
name|off_t
call|)
argument_list|(
operator|&
name|mproc
operator|.
name|p_pgrp
operator|->
name|pg_id
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|pgid
argument_list|,
sizeof|sizeof
argument_list|(
name|pgid
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|pgid
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|pgid
operator|!=
name|tpgid
condition|)
continue|continue;
comment|/* save the interesting parts */
name|pr
index|[
name|np
index|]
operator|.
name|w_pid
operator|=
name|mproc
operator|.
name|p_pid
expr_stmt|;
name|pr
index|[
name|np
index|]
operator|.
name|w_flag
operator|=
name|mproc
operator|.
name|p_flag
expr_stmt|;
name|pr
index|[
name|np
index|]
operator|.
name|w_size
operator|=
name|mproc
operator|.
name|p_dsize
operator|+
name|mproc
operator|.
name|p_ssize
expr_stmt|;
name|pr
index|[
name|np
index|]
operator|.
name|w_igintr
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|up
operator|.
name|u_signal
index|[
literal|2
index|]
operator|==
literal|1
operator|)
operator|+
literal|2
operator|*
operator|(
operator|(
name|int
operator|)
name|up
operator|.
name|u_signal
index|[
literal|2
index|]
operator|>
literal|1
operator|)
operator|+
literal|3
operator|*
operator|(
operator|(
name|int
operator|)
name|up
operator|.
name|u_signal
index|[
literal|3
index|]
operator|==
literal|1
operator|)
operator|)
operator|+
literal|6
operator|*
operator|(
operator|(
name|int
operator|)
name|up
operator|.
name|u_signal
index|[
literal|3
index|]
operator|>
literal|1
operator|)
expr_stmt|;
name|pr
index|[
name|np
index|]
operator|.
name|w_time
operator|=
name|up
operator|.
name|u_ru
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|+
name|up
operator|.
name|u_ru
operator|.
name|ru_stime
operator|.
name|tv_sec
expr_stmt|;
name|pr
index|[
name|np
index|]
operator|.
name|w_ctime
operator|=
name|up
operator|.
name|u_cru
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|+
name|up
operator|.
name|u_cru
operator|.
name|ru_stime
operator|.
name|tv_sec
expr_stmt|;
name|pr
index|[
name|np
index|]
operator|.
name|w_tty
operator|=
name|up
operator|.
name|u_ttyd
expr_stmt|;
name|pr
index|[
name|np
index|]
operator|.
name|w_uid
operator|=
name|mproc
operator|.
name|p_uid
expr_stmt|;
name|up
operator|.
name|u_comm
index|[
literal|14
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Bug: This bombs next field. */
name|strcpy
argument_list|(
name|pr
index|[
name|np
index|]
operator|.
name|w_comm
argument_list|,
name|up
operator|.
name|u_comm
argument_list|)
expr_stmt|;
comment|/* 		 * Get args if there's a chance we'll print it. 		 * Can't just save pointer: getargs returns static place. 		 * Can't use strncpy, it blank pads. 		 */
name|pr
index|[
name|np
index|]
operator|.
name|w_args
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strncat
argument_list|(
name|pr
index|[
name|np
index|]
operator|.
name|w_args
argument_list|,
name|getargs
argument_list|(
operator|&
name|pr
index|[
name|np
index|]
argument_list|)
argument_list|,
name|ARGWIDTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
index|[
name|np
index|]
operator|.
name|w_args
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|pr
index|[
name|np
index|]
operator|.
name|w_args
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|pr
index|[
name|np
index|]
operator|.
name|w_args
index|[
literal|1
index|]
operator|<=
literal|' '
operator|||
name|pr
index|[
name|np
index|]
operator|.
name|w_args
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
block|{
name|strcat
argument_list|(
name|pr
index|[
name|np
index|]
operator|.
name|w_args
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pr
index|[
name|np
index|]
operator|.
name|w_args
argument_list|,
name|pr
index|[
name|np
index|]
operator|.
name|w_comm
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pr
index|[
name|np
index|]
operator|.
name|w_args
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|np
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * getargs: given a pointer to a proc structure, this looks at the swap area  * and tries to reconstruct the arguments. This is straight out of ps.  */
end_comment

begin_function
name|char
modifier|*
name|getargs
parameter_list|(
name|p
parameter_list|)
name|struct
name|pr
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|addr
decl_stmt|,
name|nbad
decl_stmt|;
specifier|static
name|int
name|abuf
index|[
name|CLSIZE
operator|*
name|NBPG
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
name|struct
name|pte
name|pagetbl
index|[
name|NPTEPG
index|]
decl_stmt|;
specifier|register
name|int
modifier|*
name|ip
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|w_flag
operator|&
name|SLOAD
operator|)
operator|==
literal|0
condition|)
block|{
name|lseek
argument_list|(
name|swap
argument_list|,
name|p
operator|->
name|w_lastpg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|swap
argument_list|,
name|abuf
argument_list|,
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
condition|)
return|return
operator|(
name|p
operator|->
name|w_comm
operator|)
return|;
block|}
else|else
block|{
name|c
operator|=
name|p
operator|->
name|w_seekaddr
expr_stmt|;
name|lseek
argument_list|(
name|mem
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
name|pagetbl
argument_list|,
name|NBPG
argument_list|)
operator|!=
name|NBPG
condition|)
return|return
operator|(
name|p
operator|->
name|w_comm
operator|)
return|;
if|if
condition|(
name|pagetbl
index|[
name|NPTEPG
operator|-
name|CLSIZE
operator|-
name|UPAGES
index|]
operator|.
name|pg_fod
operator|==
literal|0
operator|&&
name|pagetbl
index|[
name|NPTEPG
operator|-
name|CLSIZE
operator|-
name|UPAGES
index|]
operator|.
name|pg_pfnum
condition|)
block|{
name|lseek
argument_list|(
name|mem
argument_list|,
name|ctob
argument_list|(
name|pagetbl
index|[
name|NPTEPG
operator|-
name|CLSIZE
operator|-
name|UPAGES
index|]
operator|.
name|pg_pfnum
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
name|abuf
argument_list|,
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
condition|)
return|return
operator|(
name|p
operator|->
name|w_comm
operator|)
return|;
block|}
else|else
block|{
name|lseek
argument_list|(
name|swap
argument_list|,
name|p
operator|->
name|w_lastpg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|swap
argument_list|,
name|abuf
argument_list|,
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
condition|)
return|return
operator|(
name|p
operator|->
name|w_comm
operator|)
return|;
block|}
block|}
name|abuf
index|[
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|abuf
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ip
operator|=
operator|&
name|abuf
index|[
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|abuf
index|[
literal|0
index|]
argument_list|)
operator|-
literal|2
index|]
init|;
name|ip
operator|>
name|abuf
condition|;
control|)
block|{
comment|/* Look from top for -1 or 0 as terminator flag. */
if|if
condition|(
operator|*
operator|--
name|ip
operator|==
operator|-
literal|1
operator|||
operator|*
name|ip
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
name|cp
operator|++
expr_stmt|;
name|nbad
operator|=
literal|0
expr_stmt|;
comment|/* up to 5 funny chars as ?'s */
for|for
control|(
name|cp1
operator|=
name|cp
init|;
name|cp1
operator|<
operator|(
name|char
operator|*
operator|)
operator|&
name|abuf
index|[
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|abuf
index|[
literal|0
index|]
argument_list|)
index|]
condition|;
name|cp1
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|cp1
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
comment|/* nulls between args => spaces */
operator|*
name|cp1
operator|=
literal|' '
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|' '
operator|||
name|c
operator|>
literal|0176
condition|)
block|{
if|if
condition|(
operator|++
name|nbad
operator|>=
literal|5
condition|)
block|{
operator|*
name|cp1
operator|++
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
operator|*
name|cp1
operator|=
literal|'?'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
comment|/* Oops - found an 							 * environment var, back 							 * over& erase it. */
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp1
operator|>
name|cp
operator|&&
operator|*
operator|--
name|cp1
operator|!=
literal|' '
condition|)
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
operator|*
operator|--
name|cp1
operator|==
literal|' '
condition|)
comment|/* strip trailing spaces */
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
block|}
return|return
operator|(
name|p
operator|->
name|w_comm
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a base/size pair in virtual swap area,  * return a physical base/size pair which is the  * (largest) initial, physically contiguous block.  */
end_comment

begin_expr_stmt
name|vstodb
argument_list|(
name|vsbase
argument_list|,
name|vssize
argument_list|,
name|dmp
argument_list|,
name|dbp
argument_list|,
name|rev
argument_list|)
specifier|register
name|int
name|vsbase
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|vssize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dmap
modifier|*
name|dmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|dblock
modifier|*
name|dbp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|blk
init|=
name|dmmin
decl_stmt|;
specifier|register
name|swblk_t
modifier|*
name|ip
init|=
name|dmp
operator|->
name|dm_map
decl_stmt|;
name|vsbase
operator|=
name|ctod
argument_list|(
name|vsbase
argument_list|)
expr_stmt|;
name|vssize
operator|=
name|ctod
argument_list|(
name|vssize
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsbase
operator|<
literal|0
operator|||
name|vsbase
operator|+
name|vssize
operator|>
name|dmp
operator|->
name|dm_size
condition|)
name|panic
argument_list|(
literal|"vstodb"
argument_list|)
expr_stmt|;
while|while
condition|(
name|vsbase
operator|>=
name|blk
condition|)
block|{
name|vsbase
operator|-=
name|blk
expr_stmt|;
if|if
condition|(
name|blk
operator|<
name|dmmax
condition|)
name|blk
operator|*=
literal|2
expr_stmt|;
name|ip
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ip
operator|<=
literal|0
operator|||
operator|*
name|ip
operator|+
name|blk
operator|>
name|nswap
condition|)
name|panic
argument_list|(
literal|"vstodb *ip"
argument_list|)
expr_stmt|;
name|dbp
operator|->
name|db_size
operator|=
name|min
argument_list|(
name|vssize
argument_list|,
name|blk
operator|-
name|vsbase
argument_list|)
expr_stmt|;
name|dbp
operator|->
name|db_base
operator|=
operator|*
name|ip
operator|+
operator|(
name|rev
condition|?
name|blk
operator|-
operator|(
name|vsbase
operator|+
name|dbp
operator|->
name|db_size
operator|)
else|:
name|vsbase
operator|)
expr_stmt|;
block|}
end_block

begin_macro
name|panic
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* printf("%s\n", cp); */
block|}
end_block

begin_macro
name|min
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
name|a
operator|<
name|b
condition|?
name|a
else|:
name|b
operator|)
return|;
block|}
end_block

end_unit

