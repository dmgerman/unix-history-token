begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)login.c	5.15 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * login [ name ]  * login -r hostname (for rlogind)  * login -h hostname (for telnetd, etc.)  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/quota.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<lastlog.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ttyent.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_define
define|#
directive|define
name|TTYGRPNAME
value|"tty"
end_define

begin_comment
comment|/* name of group to own ttys */
end_comment

begin_define
define|#
directive|define
name|TTYGID
parameter_list|(
name|gid
parameter_list|)
value|tty_gid(gid)
end_define

begin_comment
comment|/* gid that owns all ttys */
end_comment

begin_define
define|#
directive|define
name|SCMPN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|strncmp(a, b, sizeof(a))
end_define

begin_define
define|#
directive|define
name|SCPYN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|strncpy(a, b, sizeof(a))
end_define

begin_define
define|#
directive|define
name|NMAX
value|sizeof(utmp.ut_name)
end_define

begin_define
define|#
directive|define
name|HMAX
value|sizeof(utmp.ut_host)
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|-1
end_define

begin_decl_stmt
name|char
name|nolog
index|[]
init|=
literal|"/etc/nologin"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|qlog
index|[]
init|=
literal|".hushlogin"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|maildir
index|[
literal|30
index|]
init|=
literal|"/usr/spool/mail/"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|lastlog
index|[]
init|=
literal|"/usr/adm/lastlog"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|passwd
name|nouser
init|=
block|{
literal|""
block|,
literal|"nope"
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sgttyb
name|ttyb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|utmp
name|utmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|minusnam
index|[
literal|16
index|]
init|=
literal|"-"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|envinit
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* now set by setenv calls */
end_comment

begin_comment
comment|/*  * This bounds the time given to login.  We initialize it here  * so it can be patched on machines where it's too small.  */
end_comment

begin_decl_stmt
name|int
name|timeout
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|term
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|strcat
argument_list|()
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|timedout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|ttyname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|crypt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getpass
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|stypeof
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tchars
name|tc
init|=
block|{
name|CINTR
block|,
name|CQUIT
block|,
name|CSTART
block|,
name|CSTOP
block|,
name|CEOT
block|,
name|CBRK
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ltchars
name|ltc
init|=
block|{
name|CSUSP
block|,
name|CDSUSP
block|,
name|CRPRNT
block|,
name|CFLUSH
block|,
name|CWERASE
block|,
name|CLNEXT
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|winsize
name|win
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|usererr
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|rusername
index|[
name|NMAX
operator|+
literal|1
index|]
decl_stmt|,
name|lusername
index|[
name|NMAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|rpassword
index|[
name|NMAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|name
index|[
name|NMAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rhost
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|namep
decl_stmt|;
name|int
name|pflag
init|=
literal|0
decl_stmt|,
name|hflag
init|=
literal|0
decl_stmt|,
name|t
decl_stmt|,
name|f
decl_stmt|,
name|c
decl_stmt|;
name|int
name|invalid
decl_stmt|,
name|quietlog
decl_stmt|;
name|FILE
modifier|*
name|nlfd
decl_stmt|;
name|char
modifier|*
name|ttyn
decl_stmt|,
modifier|*
name|tty
decl_stmt|;
name|int
name|ldisc
init|=
literal|0
decl_stmt|,
name|zero
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|envnew
decl_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|timedout
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|quota
argument_list|(
name|Q_SETUID
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * -p is used by getty to tell login not to destroy the environment 	 * -r is used by rlogind to cause the autologin protocol; 	 * -h is used by other servers to pass the name of the 	 * remote host to login so that it may be placed in utmp and wtmp 	 */
while|while
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-r"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rflag
operator|||
name|hflag
condition|)
block|{
name|printf
argument_list|(
literal|"Only one of -r and -h allowed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|rflag
operator|=
literal|1
expr_stmt|;
name|usererr
operator|=
name|doremotelogin
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|utmp
operator|.
name|ut_host
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|argc
operator|-=
literal|2
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-h"
argument_list|)
operator|==
literal|0
operator|&&
name|getuid
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rflag
operator|||
name|hflag
condition|)
block|{
name|printf
argument_list|(
literal|"Only one of -r and -h allowed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hflag
operator|=
literal|1
expr_stmt|;
name|SCPYN
argument_list|(
name|utmp
operator|.
name|ut_host
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|argc
operator|-=
literal|2
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-p"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|pflag
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|zero
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCNXCL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|zero
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|FIOASYNC
argument_list|,
operator|&
name|zero
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|ttyb
argument_list|)
expr_stmt|;
comment|/* 	 * If talking to an rlogin process, 	 * propagate the terminal type and 	 * baud rate across the network. 	 */
if|if
condition|(
name|rflag
condition|)
name|doremoteterm
argument_list|(
name|term
argument_list|,
operator|&
name|ttyb
argument_list|)
expr_stmt|;
name|ttyb
operator|.
name|sg_erase
operator|=
name|CERASE
expr_stmt|;
name|ttyb
operator|.
name|sg_kill
operator|=
name|CKILL
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|ltc
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|tc
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|ttyb
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|getdtablesize
argument_list|()
init|;
name|t
operator|>
literal|2
condition|;
name|t
operator|--
control|)
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ttyn
operator|=
name|ttyname
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyn
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
operator|||
operator|*
name|ttyn
operator|==
literal|'\0'
condition|)
name|ttyn
operator|=
literal|"/dev/tty??"
expr_stmt|;
name|tty
operator|=
name|rindex
argument_list|(
name|ttyn
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
operator|==
name|NULL
condition|)
name|tty
operator|=
name|ttyn
expr_stmt|;
else|else
name|tty
operator|++
expr_stmt|;
name|openlog
argument_list|(
literal|"login"
argument_list|,
name|LOG_ODELAY
argument_list|,
name|LOG_AUTH
argument_list|)
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
name|invalid
operator|=
name|FALSE
expr_stmt|;
do|do
block|{
name|ldisc
operator|=
literal|0
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETD
argument_list|,
operator|&
name|ldisc
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|utmp
operator|.
name|ut_name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 		 * Name specified, take it. 		 */
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|SCPYN
argument_list|(
name|utmp
operator|.
name|ut_name
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|argc
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * If remote login take given name, 		 * otherwise prompt user for something. 		 */
if|if
condition|(
name|rflag
operator|&&
operator|!
name|invalid
condition|)
name|SCPYN
argument_list|(
name|utmp
operator|.
name|ut_name
argument_list|,
name|lusername
argument_list|)
expr_stmt|;
else|else
name|getloginname
argument_list|(
operator|&
name|utmp
argument_list|)
expr_stmt|;
name|invalid
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_shell
argument_list|,
literal|"/bin/csh"
argument_list|)
condition|)
block|{
name|ldisc
operator|=
name|NTTYDISC
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETD
argument_list|,
operator|&
name|ldisc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If no remote login authentication and 		 * a password exists for this user, prompt 		 * for one and verify it. 		 */
if|if
condition|(
name|usererr
operator|==
operator|-
literal|1
operator|&&
operator|*
name|pwd
operator|->
name|pw_passwd
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|pp
decl_stmt|;
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
operator|-
literal|4
argument_list|)
expr_stmt|;
name|pp
operator|=
name|getpass
argument_list|(
literal|"Password:"
argument_list|)
expr_stmt|;
name|namep
operator|=
name|crypt
argument_list|(
name|pp
argument_list|,
name|pwd
operator|->
name|pw_passwd
argument_list|)
expr_stmt|;
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|namep
argument_list|,
name|pwd
operator|->
name|pw_passwd
argument_list|)
condition|)
name|invalid
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 		 * If user not super-user, check for logins disabled. 		 */
if|if
condition|(
name|pwd
operator|->
name|pw_uid
operator|!=
literal|0
operator|&&
operator|(
name|nlfd
operator|=
name|fopen
argument_list|(
name|nolog
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|nlfd
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If valid so far and root is logging in, 		 * see if root logins on this terminal are permitted. 		 */
if|if
condition|(
operator|!
name|invalid
operator|&&
name|pwd
operator|->
name|pw_uid
operator|==
literal|0
operator|&&
operator|!
name|rootterm
argument_list|(
name|tty
argument_list|)
condition|)
block|{
if|if
condition|(
name|utmp
operator|.
name|ut_host
index|[
literal|0
index|]
condition|)
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"ROOT LOGIN REFUSED ON %s FROM %.*s"
argument_list|,
name|tty
argument_list|,
name|HMAX
argument_list|,
name|utmp
operator|.
name|ut_host
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"ROOT LOGIN REFUSED ON %s"
argument_list|,
name|tty
argument_list|)
expr_stmt|;
name|invalid
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|invalid
condition|)
block|{
name|printf
argument_list|(
literal|"Login incorrect\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|t
operator|>=
literal|5
condition|)
block|{
if|if
condition|(
name|utmp
operator|.
name|ut_host
index|[
literal|0
index|]
condition|)
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"REPEATED LOGIN FAILURES ON %s FROM %.*s, %.*s"
argument_list|,
name|tty
argument_list|,
name|HMAX
argument_list|,
name|utmp
operator|.
name|ut_host
argument_list|,
name|NMAX
argument_list|,
name|utmp
operator|.
name|ut_name
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"REPEATED LOGIN FAILURES ON %s, %.*s"
argument_list|,
name|tty
argument_list|,
name|NMAX
argument_list|,
name|utmp
operator|.
name|ut_name
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCHPCL
argument_list|,
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
operator|,
name|close
argument_list|(
literal|1
argument_list|)
operator|,
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|pwd
operator|->
name|pw_shell
operator|==
literal|'\0'
condition|)
name|pwd
operator|->
name|pw_shell
operator|=
literal|"/bin/sh"
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|pwd
operator|->
name|pw_dir
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|invalid
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
literal|"/"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"No directory!\n"
argument_list|)
expr_stmt|;
name|invalid
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"No directory! %s\n"
argument_list|,
literal|"Logging in with home=/"
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_dir
operator|=
literal|"/"
expr_stmt|;
block|}
block|}
comment|/* 		 * Remote login invalid must have been because 		 * of a restriction of some sort, no extra chances. 		 */
if|if
condition|(
operator|!
name|usererr
operator|&&
name|invalid
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|invalid
condition|)
do|;
comment|/* committed to login turn off timeout */
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|quota
argument_list|(
name|Q_SETUID
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINVAL
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EUSERS
condition|)
name|printf
argument_list|(
literal|"%s.\n%s.\n"
argument_list|,
literal|"Too many users logged on already"
argument_list|,
literal|"Try again later"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|EPROCLIM
condition|)
name|printf
argument_list|(
literal|"You have too many processes running.\n"
argument_list|)
expr_stmt|;
else|else
name|perror
argument_list|(
literal|"quota (Q_SETUID)"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|time
argument_list|(
operator|&
name|utmp
operator|.
name|ut_time
argument_list|)
expr_stmt|;
name|t
operator|=
name|ttyslot
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|>
literal|0
operator|&&
operator|(
name|f
operator|=
name|open
argument_list|(
literal|"/etc/utmp"
argument_list|,
name|O_WRONLY
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|lseek
argument_list|(
name|f
argument_list|,
call|(
name|long
call|)
argument_list|(
name|t
operator|*
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|utmp
operator|.
name|ut_line
argument_list|,
name|tty
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|utmp
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
literal|"/usr/adm/wtmp"
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|write
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|utmp
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|quietlog
operator|=
name|access
argument_list|(
name|qlog
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|lastlog
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|struct
name|lastlog
name|ll
decl_stmt|;
name|lseek
argument_list|(
name|f
argument_list|,
operator|(
name|long
operator|)
name|pwd
operator|->
name|pw_uid
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lastlog
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ll
argument_list|,
sizeof|sizeof
name|ll
argument_list|)
operator|==
sizeof|sizeof
name|ll
operator|&&
name|ll
operator|.
name|ll_time
operator|!=
literal|0
operator|&&
operator|!
name|quietlog
condition|)
block|{
name|printf
argument_list|(
literal|"Last login: %.*s "
argument_list|,
literal|24
operator|-
literal|5
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ctime
argument_list|(
operator|&
name|ll
operator|.
name|ll_time
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ll
operator|.
name|ll_host
operator|!=
literal|'\0'
condition|)
name|printf
argument_list|(
literal|"from %.*s\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
operator|.
name|ll_host
argument_list|)
argument_list|,
name|ll
operator|.
name|ll_host
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"on %.*s\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
operator|.
name|ll_line
argument_list|)
argument_list|,
name|ll
operator|.
name|ll_line
argument_list|)
expr_stmt|;
block|}
name|lseek
argument_list|(
name|f
argument_list|,
operator|(
name|long
operator|)
name|pwd
operator|->
name|pw_uid
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lastlog
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|ll
operator|.
name|ll_time
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|ll
operator|.
name|ll_line
argument_list|,
name|tty
argument_list|)
expr_stmt|;
name|SCPYN
argument_list|(
name|ll
operator|.
name|ll_host
argument_list|,
name|utmp
operator|.
name|ut_host
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ll
argument_list|,
sizeof|sizeof
name|ll
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|chown
argument_list|(
name|ttyn
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|TTYGID
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hflag
operator|&&
operator|!
name|rflag
condition|)
comment|/* XXX */
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSWINSZ
argument_list|,
operator|&
name|win
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|ttyn
argument_list|,
literal|0620
argument_list|)
expr_stmt|;
name|setgid
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|utmp
operator|.
name|ut_name
argument_list|,
name|NMAX
argument_list|)
expr_stmt|;
name|name
index|[
name|NMAX
index|]
operator|=
literal|'\0'
expr_stmt|;
name|initgroups
argument_list|(
name|name
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|quota
argument_list|(
name|Q_DOWARN
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
operator|(
name|dev_t
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|pwd
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
comment|/* destroy environment unless user has asked to preserve it */
if|if
condition|(
operator|!
name|pflag
condition|)
name|environ
operator|=
name|envinit
expr_stmt|;
comment|/* set up environment, this time without destruction */
comment|/* copy the environment before setenving */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|environ
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|i
operator|++
expr_stmt|;
name|envnew
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|envnew
index|[
name|i
index|]
operator|=
name|environ
index|[
name|i
index|]
expr_stmt|;
name|environ
operator|=
name|envnew
expr_stmt|;
name|setenv
argument_list|(
literal|"HOME="
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"SHELL="
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|term
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strncpy
argument_list|(
name|term
argument_list|,
name|stypeof
argument_list|(
name|tty
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|term
argument_list|)
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"TERM="
argument_list|,
name|term
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"USER="
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"PATH="
argument_list|,
literal|":/usr/ucb:/bin:/usr/bin"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|namep
operator|=
name|rindex
argument_list|(
name|pwd
operator|->
name|pw_shell
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|namep
operator|=
name|pwd
operator|->
name|pw_shell
expr_stmt|;
else|else
name|namep
operator|++
expr_stmt|;
name|strcat
argument_list|(
name|minusnam
argument_list|,
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
index|[
sizeof|sizeof
argument_list|(
literal|"tty"
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'d'
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"DIALUP %s, %s"
argument_list|,
name|tty
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|->
name|pw_uid
operator|==
literal|0
condition|)
if|if
condition|(
name|utmp
operator|.
name|ut_host
index|[
literal|0
index|]
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ROOT LOGIN %s FROM %.*s"
argument_list|,
name|tty
argument_list|,
name|HMAX
argument_list|,
name|utmp
operator|.
name|ut_host
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ROOT LOGIN %s"
argument_list|,
name|tty
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quietlog
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|showmotd
argument_list|()
expr_stmt|;
name|strcat
argument_list|(
name|maildir
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|maildir
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
name|st
operator|.
name|st_size
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"You have %smail.\n"
argument_list|,
operator|(
name|st
operator|.
name|st_mtime
operator|>
name|st
operator|.
name|st_atime
operator|)
condition|?
literal|"new "
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
name|pwd
operator|->
name|pw_shell
argument_list|,
name|minusnam
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|pwd
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"No shell\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|getloginname
argument_list|(
name|up
argument_list|)
specifier|register
expr|struct
name|utmp
operator|*
name|up
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|namep
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
name|up
operator|->
name|ut_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|namep
operator|=
name|up
operator|->
name|ut_name
expr_stmt|;
name|printf
argument_list|(
literal|"login: "
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|namep
operator|<
name|up
operator|->
name|ut_name
operator|+
name|NMAX
condition|)
operator|*
name|namep
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
name|strncpy
argument_list|(
name|lusername
argument_list|,
name|up
operator|->
name|ut_name
argument_list|,
name|NMAX
argument_list|)
expr_stmt|;
name|lusername
index|[
name|NMAX
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|pwd
operator|=
name|getpwnam
argument_list|(
name|lusername
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|pwd
operator|=
operator|&
name|nouser
expr_stmt|;
block|}
end_block

begin_macro
name|timedout
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"Login timed out after %d seconds\n"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|stopmotd
decl_stmt|;
end_decl_stmt

begin_macro
name|catch
argument_list|()
end_macro

begin_block
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|stopmotd
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|rootterm
argument_list|(
argument|tty
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|tty
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ttyent
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|getttynam
argument_list|(
name|tty
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|ty_status
operator|&
name|TTY_SECURE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|showmotd
argument_list|()
end_macro

begin_block
block|{
name|FILE
modifier|*
name|mf
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|catch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mf
operator|=
name|fopen
argument_list|(
literal|"/etc/motd"
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|mf
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|stopmotd
operator|==
literal|0
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|mf
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
end_block

begin_undef
undef|#
directive|undef
name|UNKNOWN
end_undef

begin_define
define|#
directive|define
name|UNKNOWN
value|"su"
end_define

begin_function
name|char
modifier|*
name|stypeof
parameter_list|(
name|ttyid
parameter_list|)
name|char
modifier|*
name|ttyid
decl_stmt|;
block|{
specifier|register
name|struct
name|ttyent
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|ttyid
operator|==
name|NULL
operator|||
operator|(
name|t
operator|=
name|getttynam
argument_list|(
name|ttyid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|UNKNOWN
operator|)
return|;
return|return
operator|(
name|t
operator|->
name|ty_type
operator|)
return|;
block|}
end_function

begin_macro
name|doremotelogin
argument_list|(
argument|host
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|host
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|getstr
argument_list|(
name|rusername
argument_list|,
sizeof|sizeof
argument_list|(
name|rusername
argument_list|)
argument_list|,
literal|"remuser"
argument_list|)
expr_stmt|;
name|getstr
argument_list|(
name|lusername
argument_list|,
sizeof|sizeof
argument_list|(
name|lusername
argument_list|)
argument_list|,
literal|"locuser"
argument_list|)
expr_stmt|;
name|getstr
argument_list|(
name|term
argument_list|,
sizeof|sizeof
argument_list|(
name|term
argument_list|)
argument_list|,
literal|"Terminal type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getuid
argument_list|()
condition|)
block|{
name|pwd
operator|=
operator|&
name|nouser
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pwd
operator|=
name|getpwnam
argument_list|(
name|lusername
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
name|pwd
operator|=
operator|&
name|nouser
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|ruserok
argument_list|(
name|host
argument_list|,
operator|(
name|pwd
operator|->
name|pw_uid
operator|==
literal|0
operator|)
argument_list|,
name|rusername
argument_list|,
name|lusername
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|getstr
argument_list|(
argument|buf
argument_list|,
argument|cnt
argument_list|,
argument|err
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|err
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|c
decl_stmt|;
do|do
block|{
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|cnt
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s too long\r\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|buf
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|0
condition|)
do|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|speeds
index|[]
init|=
block|{
literal|"0"
block|,
literal|"50"
block|,
literal|"75"
block|,
literal|"110"
block|,
literal|"134"
block|,
literal|"150"
block|,
literal|"200"
block|,
literal|"300"
block|,
literal|"600"
block|,
literal|"1200"
block|,
literal|"1800"
block|,
literal|"2400"
block|,
literal|"4800"
block|,
literal|"9600"
block|,
literal|"19200"
block|,
literal|"38400"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NSPEEDS
value|(sizeof (speeds) / sizeof (speeds[0]))
end_define

begin_macro
name|doremoteterm
argument_list|(
argument|term
argument_list|,
argument|tp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|term
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sgttyb
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|index
argument_list|(
name|term
argument_list|,
literal|'/'
argument_list|)
decl_stmt|,
modifier|*
modifier|*
name|cpp
decl_stmt|;
name|char
modifier|*
name|speed
decl_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|speed
operator|=
name|cp
expr_stmt|;
name|cp
operator|=
name|index
argument_list|(
name|speed
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|cpp
operator|=
name|speeds
init|;
name|cpp
operator|<
operator|&
name|speeds
index|[
name|NSPEEDS
index|]
condition|;
name|cpp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|cpp
argument_list|,
name|speed
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|sg_ispeed
operator|=
name|tp
operator|->
name|sg_ospeed
operator|=
name|cpp
operator|-
name|speeds
expr_stmt|;
break|break;
block|}
block|}
name|tp
operator|->
name|sg_flags
operator|=
name|ECHO
operator||
name|CRMOD
operator||
name|ANYP
operator||
name|XTABS
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set the value of var to be arg in the Unix 4.2 BSD environment env.  * Var should end with '='.  * (bindings are of the form "var=value")  * This procedure assumes the memory for the first level of environ  * was allocated using malloc.  */
end_comment

begin_macro
name|setenv
argument_list|(
argument|var
argument_list|,
argument|value
argument_list|,
argument|clobber
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|var
decl_stmt|,
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|varlen
init|=
name|strlen
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|int
name|vallen
init|=
name|strlen
argument_list|(
name|value
argument_list|)
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|environ
index|[
name|index
index|]
operator|!=
name|NULL
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|environ
index|[
name|index
index|]
argument_list|,
name|var
argument_list|,
name|varlen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* found it */
if|if
condition|(
operator|!
name|clobber
condition|)
return|return;
name|environ
index|[
name|index
index|]
operator|=
name|malloc
argument_list|(
name|varlen
operator|+
name|vallen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|environ
index|[
name|index
index|]
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|environ
index|[
name|index
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|environ
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|environ
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|index
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|environ
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"login: malloc out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|environ
index|[
name|index
index|]
operator|=
name|malloc
argument_list|(
name|varlen
operator|+
name|vallen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|environ
index|[
name|index
index|]
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|environ
index|[
name|index
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|environ
index|[
operator|++
name|index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_macro
name|tty_gid
argument_list|(
argument|default_gid
argument_list|)
end_macro

begin_decl_stmt
name|int
name|default_gid
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|group
modifier|*
name|getgrnam
argument_list|()
decl_stmt|,
modifier|*
name|gr
decl_stmt|;
name|int
name|gid
init|=
name|default_gid
decl_stmt|;
name|gr
operator|=
name|getgrnam
argument_list|(
name|TTYGRPNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|!=
operator|(
expr|struct
name|group
operator|*
operator|)
literal|0
condition|)
name|gid
operator|=
name|gr
operator|->
name|gr_gid
expr_stmt|;
name|endgrent
argument_list|()
expr_stmt|;
return|return
operator|(
name|gid
operator|)
return|;
block|}
end_block

end_unit

