begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1982 The Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)gcore.c	5.6 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * gcore - get core images of running processes  *  * Author: Eric Cooper  * Written: Fall 1981.  *  * Inspired by a version 6 program by Len Levin, 1978.  * Several pieces of code lifted from Bill Joy's 4BSD ps.  *  * Permission to copy or modify this program in whole or in part is hereby  * granted, provided that the above credits are preserved.  *  * This code performs a simple simulation of the virtual memory system in user  * code.  If the virtual memory system changes, this program must be modified  * accordingly.  It must also be recompiled whenever system data structures  * change.  */
end_comment

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vm.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_comment
comment|/* Various macros for efficiency. */
end_comment

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a< b ? a : b)
end_define

begin_define
define|#
directive|define
name|Seek
parameter_list|(
name|f
parameter_list|,
name|pos
parameter_list|)
value|{\ 	if (lseek(f, (long) (pos), 0) != (long) (pos)) \ 		panic("seek error"); \ }
end_define

begin_define
define|#
directive|define
name|Read
parameter_list|(
name|f
parameter_list|,
name|addr
parameter_list|,
name|n
parameter_list|)
value|{\ 	if (read(f, (char *) (addr), (int) (n)) != (int) (n)) \ 		panic("read error"); \ }
end_define

begin_define
define|#
directive|define
name|Get
parameter_list|(
name|f
parameter_list|,
name|pos
parameter_list|,
name|addr
parameter_list|,
name|n
parameter_list|)
value|{\ 	Seek(f, pos); \ 	Read(f, addr, n); \ }
end_define

begin_decl_stmt
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
block|{
literal|"_proc"
block|}
block|,
define|#
directive|define
name|X_PROC
value|0
block|{
literal|"_Usrptmap"
block|}
block|,
define|#
directive|define
name|X_USRPTMA
value|1
block|{
literal|"_usrpt"
block|}
block|,
define|#
directive|define
name|X_USRPT
value|2
block|{
literal|"_nswap"
block|}
block|,
define|#
directive|define
name|X_NSWAP
value|3
block|{
literal|"_nproc"
block|}
block|,
define|#
directive|define
name|X_NPROC
value|4
block|{
literal|"_dmmin"
block|}
block|,
define|#
directive|define
name|X_DMMIN
value|5
block|{
literal|"_dmmax"
block|}
block|,
define|#
directive|define
name|X_DMMAX
value|6
block|{
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FEW
value|20
end_define

begin_comment
comment|/* for fewer system calls */
end_comment

begin_decl_stmt
name|struct
name|proc
name|proc
index|[
name|FEW
index|]
decl_stmt|;
end_decl_stmt

begin_union
union|union
block|{
name|struct
name|user
name|user
decl_stmt|;
name|char
name|upages
index|[
name|UPAGES
index|]
index|[
name|NBPG
index|]
decl_stmt|;
block|}
name|user
union|;
end_union

begin_define
define|#
directive|define
name|u
value|user.user
end_define

begin_define
define|#
directive|define
name|uarea
value|user.upages
end_define

begin_define
define|#
directive|define
name|NLIST
value|"/vmunix"
end_define

begin_define
define|#
directive|define
name|KMEM
value|"/dev/kmem"
end_define

begin_define
define|#
directive|define
name|MEM
value|"/dev/mem"
end_define

begin_define
define|#
directive|define
name|SWAP
value|"/dev/drum"
end_define

begin_comment
comment|/* "/dev/swap" on some systems */
end_comment

begin_decl_stmt
name|int
name|nproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nswap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dmmin
decl_stmt|,
name|dmmax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pte
modifier|*
name|Usrptmap
decl_stmt|,
modifier|*
name|usrpt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|coref
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|kmem
decl_stmt|,
name|mem
decl_stmt|,
name|swap
decl_stmt|,
name|cor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|cont_frame
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|off_t
name|procbase
decl_stmt|,
name|procp
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|uid
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: %s pid ...\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|openfiles
argument_list|()
expr_stmt|;
name|getkvars
argument_list|()
expr_stmt|;
name|procbase
operator|=
name|getw
argument_list|(
name|nl
index|[
name|X_PROC
index|]
operator|.
name|n_value
argument_list|)
expr_stmt|;
name|nproc
operator|=
name|getw
argument_list|(
name|nl
index|[
name|X_NPROC
index|]
operator|.
name|n_value
argument_list|)
expr_stmt|;
name|nswap
operator|=
name|getw
argument_list|(
name|nl
index|[
name|X_NSWAP
index|]
operator|.
name|n_value
argument_list|)
expr_stmt|;
name|dmmin
operator|=
name|getw
argument_list|(
name|nl
index|[
name|X_DMMIN
index|]
operator|.
name|n_value
argument_list|)
expr_stmt|;
name|dmmax
operator|=
name|getw
argument_list|(
name|nl
index|[
name|X_DMMAX
index|]
operator|.
name|n_value
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pid
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
operator|)
operator|<=
literal|0
operator|||
name|setjmp
argument_list|(
name|cont_frame
argument_list|)
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%d: "
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|procp
operator|=
name|procbase
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nproc
condition|;
name|i
operator|+=
name|FEW
control|)
block|{
name|Seek
argument_list|(
name|kmem
argument_list|,
name|procp
argument_list|)
expr_stmt|;
name|j
operator|=
name|nproc
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|FEW
condition|)
name|j
operator|=
name|FEW
expr_stmt|;
name|j
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
expr_stmt|;
name|Read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
name|proc
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|procp
operator|+=
name|j
expr_stmt|;
for|for
control|(
name|j
operator|=
name|j
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|p
operator|=
operator|&
name|proc
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_pid
operator|==
name|pid
condition|)
goto|goto
name|found
goto|;
block|}
block|}
name|printf
argument_list|(
literal|"Process not found.\n"
argument_list|)
expr_stmt|;
continue|continue;
name|found
label|:
if|if
condition|(
name|p
operator|->
name|p_uid
operator|!=
operator|(
name|uid
operator|=
name|getuid
argument_list|()
operator|)
operator|&&
name|uid
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Not owner.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p
operator|->
name|p_stat
operator|==
name|SZOMB
condition|)
block|{
name|printf
argument_list|(
literal|"Zombie.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SWEXIT
condition|)
name|printf
argument_list|(
literal|"Warning: process exiting.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SSYS
condition|)
block|{
name|printf
argument_list|(
literal|"System process.\n"
argument_list|)
expr_stmt|;
comment|/* i.e. swapper or pagedaemon */
continue|continue;
block|}
name|sprintf
argument_list|(
name|coref
argument_list|,
literal|"core.%d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cor
operator|=
name|creat
argument_list|(
name|coref
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|coref
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|core
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|cor
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s dumped\n"
argument_list|,
name|coref
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|getw
argument_list|(
argument|loc
argument_list|)
end_macro

begin_decl_stmt
name|off_t
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|word
decl_stmt|;
name|Get
argument_list|(
name|kmem
argument_list|,
name|loc
argument_list|,
operator|&
name|word
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|word
operator|)
return|;
block|}
end_block

begin_macro
name|openfiles
argument_list|()
end_macro

begin_block
block|{
name|kmem
operator|=
name|open
argument_list|(
name|KMEM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|kmem
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|KMEM
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|mem
operator|=
name|open
argument_list|(
name|MEM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|MEM
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|swap
operator|=
name|open
argument_list|(
name|SWAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|SWAP
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|getkvars
argument_list|()
end_macro

begin_block
block|{
name|nlist
argument_list|(
name|NLIST
argument_list|,
name|nl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
index|[
literal|0
index|]
operator|.
name|n_type
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: No namelist\n"
argument_list|,
name|NLIST
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Usrptmap
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|nl
index|[
name|X_USRPTMA
index|]
operator|.
name|n_value
expr_stmt|;
name|usrpt
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|nl
index|[
name|X_USRPT
index|]
operator|.
name|n_value
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Get the system page table entries (mapping the user page table).  * These are the entries Usrptmap[i .. i + szpt],  * where i = btokmx(p->p_p0br) and szpt = p->p_szpt.  * For our purposes, we can skip over the ptes mapping  * the text segment ptes.  */
end_comment

begin_decl_stmt
name|struct
name|pte
modifier|*
name|syspt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pte's from Usrptmap */
end_comment

begin_decl_stmt
name|int
name|nsysptes
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|getsyspt
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|nsysptes
operator|=
name|p
operator|->
name|p_szpt
operator|-
operator|(
name|p
operator|->
name|p_tsize
operator|/
name|NPTEPG
operator|)
expr_stmt|;
name|syspt
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|malloc
argument_list|(
name|nsysptes
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|syspt
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"can't alloc %d page table entries"
argument_list|,
name|nsysptes
argument_list|)
expr_stmt|;
name|Get
argument_list|(
name|kmem
argument_list|,
operator|&
name|Usrptmap
index|[
name|btokmx
argument_list|(
name|p
operator|->
name|p_p0br
argument_list|)
operator|+
operator|(
name|p
operator|->
name|p_tsize
operator|/
name|NPTEPG
operator|)
index|]
argument_list|,
name|syspt
argument_list|,
name|nsysptes
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Get the user page table for a segment.  * seg 0 = p0 (not including text)  * seg 1 = p1 (stack and u area)  * The system pt is consulted to find each page of user ptes.  */
end_comment

begin_function
name|struct
name|pte
modifier|*
name|getpt
parameter_list|(
name|p
parameter_list|,
name|seg
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|seg
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|spt
decl_stmt|;
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
name|int
name|nptes
decl_stmt|,
name|offset
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|seg
operator|==
literal|0
condition|)
block|{
name|nptes
operator|=
name|p
operator|->
name|p_dsize
expr_stmt|;
name|spt
operator|=
name|syspt
expr_stmt|;
name|offset
operator|=
name|p
operator|->
name|p_tsize
operator|%
name|NPTEPG
expr_stmt|;
block|}
else|else
block|{
name|nptes
operator|=
name|p
operator|->
name|p_ssize
operator|+
name|UPAGES
expr_stmt|;
name|spt
operator|=
name|syspt
operator|+
operator|(
name|nsysptes
operator|-
name|ctopt
argument_list|(
name|nptes
argument_list|)
operator|)
expr_stmt|;
name|offset
operator|=
operator|-
name|nptes
operator|%
name|NPTEPG
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|offset
operator|+=
name|NPTEPG
expr_stmt|;
block|}
name|pt
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|malloc
argument_list|(
name|nptes
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"can't alloc %d page table entries"
argument_list|,
name|nptes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nptes
condition|;
name|i
operator|+=
name|n
control|)
block|{
name|n
operator|=
name|min
argument_list|(
name|NPTEPG
operator|-
name|offset
argument_list|,
name|nptes
operator|-
name|i
argument_list|)
expr_stmt|;
name|Get
argument_list|(
name|mem
argument_list|,
name|ctob
argument_list|(
name|spt
operator|->
name|pg_pfnum
argument_list|)
operator|+
name|offset
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
argument_list|,
name|pt
operator|+
name|i
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
argument_list|)
expr_stmt|;
name|spt
operator|++
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|pt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Build the core file.  */
end_comment

begin_expr_stmt
name|core
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|pte
modifier|*
name|p0
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SLOAD
condition|)
block|{
comment|/* page tables are resident */
name|getsyspt
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p0
operator|=
name|getpt
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p1
operator|=
name|getpt
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|showpt
argument_list|(
name|syspt
argument_list|,
name|nsysptes
argument_list|,
literal|"system"
argument_list|)
expr_stmt|;
name|showpt
argument_list|(
name|p0
argument_list|,
name|p
operator|->
name|p_dsize
argument_list|,
literal|"p0"
argument_list|)
expr_stmt|;
name|showpt
argument_list|(
name|p1
argument_list|,
name|p
operator|->
name|p_ssize
operator|+
name|UPAGES
argument_list|,
literal|"p1"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|getu
argument_list|(
name|p
argument_list|,
operator|&
name|p1
index|[
name|p
operator|->
name|p_ssize
index|]
argument_list|)
expr_stmt|;
comment|/* u area */
name|getseg
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|p_dsize
argument_list|,
name|p0
argument_list|,
operator|&
name|u
operator|.
name|u_dmap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* data */
name|getseg
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|p_ssize
argument_list|,
name|p1
argument_list|,
operator|&
name|u
operator|.
name|u_smap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* stack */
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SLOAD
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|syspt
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p0
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Get the u area.  * Keeps around the u structure for later use  * (the data and stack disk map structures).  */
end_comment

begin_expr_stmt
name|getu
argument_list|(
name|p
argument_list|,
name|pages
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|pte
modifier|*
name|pages
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SLOAD
operator|)
operator|==
literal|0
condition|)
block|{
name|Get
argument_list|(
name|swap
argument_list|,
name|ctob
argument_list|(
name|p
operator|->
name|p_swaddr
argument_list|)
argument_list|,
name|uarea
argument_list|,
name|ctob
argument_list|(
name|UPAGES
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|cor
argument_list|,
name|uarea
argument_list|,
name|ctob
argument_list|(
name|UPAGES
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|+=
name|CLSIZE
control|)
block|{
name|Get
argument_list|(
name|mem
argument_list|,
name|ctob
argument_list|(
name|pages
index|[
name|i
index|]
operator|.
name|pg_pfnum
argument_list|)
argument_list|,
name|uarea
index|[
name|i
index|]
argument_list|,
name|ctob
argument_list|(
name|CLSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|cor
argument_list|,
name|uarea
index|[
name|i
index|]
argument_list|,
name|ctob
argument_list|(
name|CLSIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Copy a segment to the core file.  * The segment is described by its size in clicks,  * its page table, its disk map, and whether or not  * it grows backwards.  * Note that the page table address is allowed to be meaningless  * if the process is swapped out.  */
end_comment

begin_expr_stmt
name|getseg
argument_list|(
name|p
argument_list|,
name|segsize
argument_list|,
name|pages
argument_list|,
name|map
argument_list|,
name|rev
argument_list|)
specifier|register
expr|struct
name|proc
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|segsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|pte
modifier|*
name|pages
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dmap
modifier|*
name|map
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|dblock
name|db
decl_stmt|;
name|int
name|size
decl_stmt|;
name|char
name|buf
index|[
name|ctob
argument_list|(
name|CLSIZE
argument_list|)
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|segsize
condition|;
name|i
operator|+=
name|CLSIZE
control|)
block|{
name|size
operator|=
name|min
argument_list|(
name|CLSIZE
argument_list|,
name|segsize
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SLOAD
operator|)
operator|==
literal|0
operator|||
name|pages
index|[
name|i
index|]
operator|.
name|pg_fod
operator|||
name|pages
index|[
name|i
index|]
operator|.
name|pg_pfnum
operator|==
literal|0
condition|)
block|{
name|vstodb
argument_list|(
name|i
argument_list|,
name|size
argument_list|,
name|map
argument_list|,
operator|&
name|db
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|Get
argument_list|(
name|swap
argument_list|,
name|ctob
argument_list|(
name|db
operator|.
name|db_base
argument_list|)
argument_list|,
name|buf
argument_list|,
name|ctob
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|cor
argument_list|,
name|buf
argument_list|,
name|ctob
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Get
argument_list|(
name|mem
argument_list|,
name|ctob
argument_list|(
name|pages
index|[
name|i
index|]
operator|.
name|pg_pfnum
argument_list|)
argument_list|,
name|buf
argument_list|,
name|ctob
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|cor
argument_list|,
name|buf
argument_list|,
name|ctob
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Given a base/size pair in virtual swap area,  * return a physical base/size pair which is the  * (largest) initial, physically contiguous block.  */
end_comment

begin_expr_stmt
name|vstodb
argument_list|(
name|vsbase
argument_list|,
name|vssize
argument_list|,
name|dmp
argument_list|,
name|dbp
argument_list|,
name|rev
argument_list|)
specifier|register
name|int
name|vsbase
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|vssize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dmap
modifier|*
name|dmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|dblock
modifier|*
name|dbp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|blk
init|=
name|dmmin
decl_stmt|;
specifier|register
name|swblk_t
modifier|*
name|ip
init|=
name|dmp
operator|->
name|dm_map
decl_stmt|;
if|if
condition|(
name|vsbase
operator|<
literal|0
operator|||
name|vsbase
operator|+
name|vssize
operator|>
name|dmp
operator|->
name|dm_size
condition|)
name|panic
argument_list|(
literal|"can't make sense out of virtual memory (gcore probably needs to be recompiled)"
argument_list|)
expr_stmt|;
while|while
condition|(
name|vsbase
operator|>=
name|blk
condition|)
block|{
name|vsbase
operator|-=
name|blk
expr_stmt|;
if|if
condition|(
name|blk
operator|<
name|dmmax
condition|)
name|blk
operator|*=
literal|2
expr_stmt|;
name|ip
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ip
operator|<=
literal|0
operator|||
operator|*
name|ip
operator|+
name|blk
operator|>
name|nswap
condition|)
name|panic
argument_list|(
literal|"vstodb *ip"
argument_list|)
expr_stmt|;
name|dbp
operator|->
name|db_size
operator|=
name|MIN
argument_list|(
name|vssize
argument_list|,
name|blk
operator|-
name|vsbase
argument_list|)
expr_stmt|;
name|dbp
operator|->
name|db_base
operator|=
operator|*
name|ip
operator|+
operator|(
name|rev
condition|?
name|blk
operator|-
operator|(
name|vsbase
operator|+
name|dbp
operator|->
name|db_size
operator|)
else|:
name|vsbase
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|panic
argument_list|(
argument|cp
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
name|cp
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|cont_frame
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*   * Debugging routine to print out page table.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|showpt
argument_list|(
argument|pt
argument_list|,
argument|n
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|pte
modifier|*
name|pt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pte
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"*** %s page table\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|pt
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
operator|!
name|p
operator|->
name|pg_fod
condition|)
name|printf
argument_list|(
literal|"%d: %x\n"
argument_list|,
name|i
argument_list|,
name|p
operator|->
name|pg_pfnum
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

