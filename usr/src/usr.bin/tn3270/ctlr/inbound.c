begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	Copyright (c) 1984, 1985, 1986 by the Regents of the  *	University of California and by Gregory Glenn Minshall.  *  *	Permission to use, copy, modify, and distribute these  *	programs and their documentation for any purpose and  *	without fee is hereby granted, provided that this  *	copyright and permission appear on all copies and  *	supporting documentation, the name of the Regents of  *	the University of California not be used in advertising  *	or publicity pertaining to distribution of the programs  *	without specific prior permission, and notice be given in  *	supporting documentation that copying and distribution is  *	by permission of the Regents of the University of California  *	and by Gregory Glenn Minshall.  Neither the Regents of the  *	University of California nor Gregory Glenn Minshall make  *	representations about the suitability of this software  *	for any purpose.  It is provided "as is" without  *	express or implied warranty.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)inbound.c	3.1  10/29/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ndef lint */
end_comment

begin_include
include|#
directive|include
file|"../general.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"hostctlr.h"
end_include

begin_include
include|#
directive|include
file|"scrnctlr.h"
end_include

begin_include
include|#
directive|include
file|"screen.h"
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_include
include|#
directive|include
file|"dctype.h"
end_include

begin_include
include|#
directive|include
file|"ebc_disp.h"
end_include

begin_include
include|#
directive|include
file|"../system/globals.h"
end_include

begin_include
include|#
directive|include
file|"inbound.ext"
end_include

begin_include
include|#
directive|include
file|"outbound.ext"
end_include

begin_include
include|#
directive|include
file|"../telnet.ext"
end_include

begin_define
define|#
directive|define
name|EmptyChar
parameter_list|()
value|(ourPTail == ourPHead)
end_define

begin_define
define|#
directive|define
name|FullChar
parameter_list|()
value|(ourPHead == ourBuffer+sizeof ourBuffer)
end_define

begin_comment
comment|/*  * We define something to allow us to to IsProtected() quickly  * on unformatted screens (with the current algorithm for fields,  * unprotected takes exponential time...).  *  *	The idea is to call SetXIsProtected() BEFORE the  * loop, then use XIsProtected().  */
end_comment

begin_define
define|#
directive|define
name|SetXIsProtected
parameter_list|()
value|XFormattedScreen = FormattedScreen()
end_define

begin_define
define|#
directive|define
name|XIsProtected
parameter_list|(
name|p
parameter_list|)
value|(XFormattedScreen&& IsProtected(p))
end_define

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
name|ourBuffer
index|[
literal|400
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ourPHead
init|=
name|ourBuffer
decl_stmt|,
modifier|*
name|ourPTail
init|=
name|ourBuffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|HadAid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Had an AID haven't sent */
end_comment

begin_decl_stmt
specifier|static
name|int
name|XFormattedScreen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For optimizations */
end_comment

begin_include
include|#
directive|include
file|"3270pc.out"
end_include

begin_comment
comment|/* the following are global variables */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|UnLocked
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keyboard is UnLocked? */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Tab() - sets cursor to the start of the next unprotected field */
end_comment

begin_function
specifier|static
name|void
name|Tab
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|i
operator|=
name|CursorAddress
expr_stmt|;
name|j
operator|=
name|WhereAttrByte
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|IsStartField
argument_list|(
name|i
argument_list|)
operator|&&
name|IsUnProtected
argument_list|(
name|ScreenInc
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
name|i
operator|=
name|FieldInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|j
condition|)
do|;
if|if
condition|(
name|IsStartField
argument_list|(
name|i
argument_list|)
operator|&&
name|IsUnProtected
argument_list|(
name|ScreenInc
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|CursorAddress
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CursorAddress
operator|=
name|SetBufferAddress
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* BackTab() - sets cursor to the start of the most recent field */
end_comment

begin_function
specifier|static
name|void
name|BackTab
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|ScreenDec
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|IsStartField
argument_list|(
name|ScreenDec
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&&
name|IsUnProtected
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|CursorAddress
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|CursorAddress
condition|)
block|{
name|CursorAddress
operator|=
name|SetBufferAddress
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|ScreenDec
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* EraseEndOfField - erase all characters to the end of a field */
end_comment

begin_function
specifier|static
name|void
name|EraseEndOfField
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|IsProtected
argument_list|(
name|CursorAddress
argument_list|)
condition|)
block|{
name|RingBell
argument_list|(
literal|"Protected Field"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TurnOnMdt
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
if|if
condition|(
name|FormattedScreen
argument_list|()
condition|)
block|{
name|i
operator|=
name|CursorAddress
expr_stmt|;
do|do
block|{
name|AddHost
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|i
operator|!=
name|CursorAddress
operator|)
operator|&&
operator|!
name|IsStartField
argument_list|(
name|i
argument_list|)
condition|)
do|;
block|}
else|else
block|{
comment|/* Screen is Unformatted */
name|i
operator|=
name|CursorAddress
expr_stmt|;
do|do
block|{
name|AddHost
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|HighestScreen
argument_list|()
condition|)
do|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Delete() - deletes a character from the screen  *  *	What we want to do is delete the section  *	[where, from-1] from the screen,  *	filling in with what comes at from.  *  *	The deleting continues to the end of the field (or  *	until the cursor wraps).  *  *	From can be a start of a field.  We  *	check for that.  However, there can't be any  *	fields that start between where and from.  *	We don't check for that.  *  *	Also, we assume that the protection status of  *	everything has been checked by the caller.  *  */
end_comment

begin_function
specifier|static
name|void
name|Delete
parameter_list|(
name|where
parameter_list|,
name|from
parameter_list|)
specifier|register
name|int
name|where
decl_stmt|,
comment|/* Where to start deleting from */
name|from
decl_stmt|;
comment|/* Where to pull back from */
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|TurnOnMdt
argument_list|(
name|where
argument_list|)
expr_stmt|;
comment|/* Only do this once in this field */
name|i
operator|=
name|where
expr_stmt|;
do|do
block|{
if|if
condition|(
name|IsStartField
argument_list|(
name|from
argument_list|)
condition|)
block|{
name|AddHost
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stick the edge at the start field */
block|}
else|else
block|{
name|AddHost
argument_list|(
name|i
argument_list|,
name|GetHost
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|=
name|ScreenInc
argument_list|(
name|from
argument_list|)
expr_stmt|;
comment|/* Move the edge */
block|}
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|!
name|IsStartField
argument_list|(
name|i
argument_list|)
operator|)
operator|&&
operator|(
name|i
operator|!=
name|where
operator|)
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|ColBak
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|ScreenLineOffset
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|i
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|OptColTabs
index|[
name|i
index|]
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|CursorAddress
operator|=
name|SetBufferAddress
argument_list|(
name|ScreenLine
argument_list|(
name|CursorAddress
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ColTab
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|ScreenLineOffset
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|i
operator|+
literal|1
init|;
name|i
operator|<
name|NumberColumns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|OptColTabs
index|[
name|i
index|]
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|NumberColumns
condition|)
block|{
name|i
operator|=
name|NumberColumns
operator|-
literal|1
expr_stmt|;
block|}
name|CursorAddress
operator|=
name|SetBufferAddress
argument_list|(
name|ScreenLine
argument_list|(
name|CursorAddress
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Home
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|i
operator|=
name|SetBufferAddress
argument_list|(
name|OptHome
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|j
operator|=
name|WhereLowByte
argument_list|(
name|i
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|IsUnProtected
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|CursorAddress
operator|=
name|i
expr_stmt|;
return|return;
block|}
comment|/* the following could be a problem if we got here with an 	     * unformatted screen.  However, this is "impossible", since 	     * with an unformatted screen, the IsUnProtected(i) above 	     * should be true. 	     */
name|i
operator|=
name|ScreenInc
argument_list|(
name|FieldInc
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|j
condition|)
do|;
name|CursorAddress
operator|=
name|LowestScreen
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|LastOfField
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* position to start from */
end_comment

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|k
operator|=
name|j
operator|=
name|i
expr_stmt|;
name|SetXIsProtected
argument_list|()
expr_stmt|;
while|while
condition|(
name|XIsProtected
argument_list|(
name|i
argument_list|)
operator|||
name|Disspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|j
condition|)
block|{
break|break;
block|}
block|}
comment|/* We are now IN a word IN an unprotected field (or wrapped) */
while|while
condition|(
operator|!
name|XIsProtected
argument_list|(
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|Disspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|k
operator|=
name|i
expr_stmt|;
block|}
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|j
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
name|k
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|FlushChar
parameter_list|()
block|{
name|ourPTail
operator|=
name|ourPHead
operator|=
name|ourBuffer
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add one EBCDIC (NOT display code) character to the buffer.  */
end_comment

begin_function
specifier|static
name|void
name|AddChar
parameter_list|(
name|character
parameter_list|)
name|char
name|character
decl_stmt|;
block|{
if|if
condition|(
name|FullChar
argument_list|()
condition|)
block|{
name|ourPTail
operator|+=
name|DataToNetwork
argument_list|(
name|ourPTail
argument_list|,
name|ourPHead
operator|-
name|ourPTail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|EmptyChar
argument_list|()
condition|)
block|{
name|FlushChar
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"File %s, line %d:  No room in network buffer!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|ExitString
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
operator|*
name|ourPHead
operator|++
operator|=
name|character
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|SendUnformatted
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|int
name|Nulls
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* look for start of field */
name|Nulls
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|j
operator|=
name|LowestScreen
argument_list|()
expr_stmt|;
do|do
block|{
name|c
operator|=
name|GetHost
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|Nulls
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|Nulls
condition|)
block|{
name|Nulls
operator|--
expr_stmt|;
name|AddChar
argument_list|(
name|EBCDIC_BLANK
argument_list|)
expr_stmt|;
comment|/* put in blanks */
block|}
name|AddChar
argument_list|(
name|disp_ebc
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|j
condition|)
do|;
block|}
end_function

begin_expr_stmt
specifier|static
name|SendField
argument_list|(
name|i
argument_list|,
name|command
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* where we saw MDT bit */
end_comment

begin_decl_stmt
name|int
name|command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The command code (type of read) */
end_comment

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|Nulls
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* look for start of field */
name|i
operator|=
name|j
operator|=
name|WhereLowByte
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* On a test_request_read, don't send sba and address */
if|if
condition|(
operator|(
name|AidByte
operator|!=
name|AID_TREQ
operator|)
operator|||
operator|(
name|command
operator|==
name|CMD_SNA_READ_MODIFIED_ALL
operator|)
condition|)
block|{
name|AddChar
argument_list|(
name|ORDER_SBA
argument_list|)
expr_stmt|;
comment|/* set start field */
name|AddChar
argument_list|(
name|BufferTo3270_0
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set address of this field */
name|AddChar
argument_list|(
name|BufferTo3270_1
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Only on read_modified_all do we return the contents 		 * of the field when the attention was caused by a 		 * selector pen. 		 */
if|if
condition|(
operator|(
name|AidByte
operator|!=
name|AID_SELPEN
operator|)
operator|||
operator|(
name|command
operator|==
name|CMD_SNA_READ_MODIFIED_ALL
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|IsStartField
argument_list|(
name|j
argument_list|)
condition|)
block|{
name|Nulls
operator|=
literal|0
expr_stmt|;
name|k
operator|=
name|ScreenInc
argument_list|(
name|WhereHighByte
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|c
operator|=
name|GetHost
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|Nulls
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|Nulls
condition|)
block|{
name|Nulls
operator|--
expr_stmt|;
name|AddChar
argument_list|(
name|EBCDIC_BLANK
argument_list|)
expr_stmt|;
comment|/* put in blanks */
block|}
name|AddChar
argument_list|(
name|disp_ebc
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
name|j
operator|=
name|ScreenInc
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|j
operator|!=
name|k
operator|)
operator|&&
operator|(
name|j
operator|!=
name|i
operator|)
condition|)
do|;
block|}
block|}
else|else
block|{
name|j
operator|=
name|FieldInc
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|j
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Various types of reads... */
end_comment

begin_function
name|void
name|DoReadModified
parameter_list|(
name|command
parameter_list|)
name|int
name|command
decl_stmt|;
comment|/* The command sent */
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|AidByte
condition|)
block|{
if|if
condition|(
name|AidByte
operator|!=
name|AID_TREQ
condition|)
block|{
name|AddChar
argument_list|(
name|AidByte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Test Request Read header */
name|AddChar
argument_list|(
name|EBCDIC_SOH
argument_list|)
expr_stmt|;
name|AddChar
argument_list|(
name|EBCDIC_PERCENT
argument_list|)
expr_stmt|;
name|AddChar
argument_list|(
name|EBCDIC_SLASH
argument_list|)
expr_stmt|;
name|AddChar
argument_list|(
name|EBCDIC_STX
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|AddChar
argument_list|(
name|AID_NONE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|AidByte
operator|!=
name|AID_PA1
operator|)
operator|&&
operator|(
name|AidByte
operator|!=
name|AID_PA2
operator|)
operator|&&
operator|(
name|AidByte
operator|!=
name|AID_PA3
operator|)
operator|&&
operator|(
name|AidByte
operator|!=
name|AID_CLEAR
operator|)
operator|)
operator|||
operator|(
name|command
operator|==
name|CMD_SNA_READ_MODIFIED_ALL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|AidByte
operator|!=
name|AID_TREQ
operator|)
operator|||
operator|(
name|command
operator|==
name|CMD_SNA_READ_MODIFIED_ALL
operator|)
condition|)
block|{
comment|/* Test request read_modified doesn't give cursor address */
name|AddChar
argument_list|(
name|BufferTo3270_0
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
expr_stmt|;
name|AddChar
argument_list|(
name|BufferTo3270_1
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|j
operator|=
name|WhereAttrByte
argument_list|(
name|LowestScreen
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Is this an unformatted screen? */
if|if
condition|(
operator|!
name|IsStartField
argument_list|(
name|i
argument_list|)
condition|)
block|{
comment|/* yes, handle separate */
name|SendUnformatted
argument_list|()
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
if|if
condition|(
name|HasMdt
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|i
operator|=
name|SendField
argument_list|(
name|i
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|FieldInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|i
operator|!=
name|j
condition|)
do|;
block|}
block|}
name|ourPTail
operator|+=
name|DataToNetwork
argument_list|(
name|ourPTail
argument_list|,
name|ourPHead
operator|-
name|ourPTail
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|EmptyChar
argument_list|()
condition|)
block|{
name|FlushChar
argument_list|()
expr_stmt|;
name|HadAid
operator|=
literal|0
expr_stmt|;
comment|/* killed that buffer */
block|}
block|}
end_function

begin_comment
comment|/* A read buffer operation... */
end_comment

begin_function
name|void
name|DoReadBuffer
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|AidByte
condition|)
block|{
name|AddChar
argument_list|(
name|AidByte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AddChar
argument_list|(
name|AID_NONE
argument_list|)
expr_stmt|;
block|}
name|AddChar
argument_list|(
name|BufferTo3270_0
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
expr_stmt|;
name|AddChar
argument_list|(
name|BufferTo3270_1
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|j
operator|=
name|LowestScreen
argument_list|()
expr_stmt|;
do|do
block|{
if|if
condition|(
name|IsStartField
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|AddChar
argument_list|(
name|ORDER_SF
argument_list|)
expr_stmt|;
name|AddChar
argument_list|(
name|BufferTo3270_1
argument_list|(
name|FieldAttributes
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AddChar
argument_list|(
name|disp_ebc
index|[
name|GetHost
argument_list|(
name|i
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|j
condition|)
do|;
name|ourPTail
operator|+=
name|DataToNetwork
argument_list|(
name|ourPTail
argument_list|,
name|ourPHead
operator|-
name|ourPTail
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|EmptyChar
argument_list|()
condition|)
block|{
name|FlushChar
argument_list|()
expr_stmt|;
name|HadAid
operator|=
literal|0
expr_stmt|;
comment|/* killed that buffer */
block|}
block|}
end_function

begin_comment
comment|/* Try to send some data to host */
end_comment

begin_function
name|void
name|SendToIBM
parameter_list|()
block|{
specifier|extern
name|int
name|TransparentClock
decl_stmt|,
name|OutputClock
decl_stmt|;
if|if
condition|(
name|TransparentClock
operator|==
name|OutputClock
condition|)
block|{
if|if
condition|(
name|HadAid
condition|)
block|{
name|AddChar
argument_list|(
name|AidByte
argument_list|)
expr_stmt|;
name|HadAid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|AddChar
argument_list|(
name|AID_NONE_PRINTER
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|ourPTail
operator|+=
name|DataToNetwork
argument_list|(
name|ourPTail
argument_list|,
name|ourPHead
operator|-
name|ourPTail
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|EmptyChar
argument_list|()
condition|)
do|;
name|FlushChar
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HadAid
condition|)
block|{
name|DoReadModified
argument_list|(
name|CMD_READ_MODIFIED
argument_list|)
expr_stmt|;
block|}
name|netflush
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This takes in one character from the keyboard and places it on the  * screen.  */
end_comment

begin_function
specifier|static
name|void
name|OneCharacter
parameter_list|(
name|c
parameter_list|,
name|insert
parameter_list|)
name|int
name|c
decl_stmt|;
comment|/* character (Ebcdic) to be shoved in */
name|int
name|insert
decl_stmt|;
comment|/* are we in insert mode? */
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|IsProtected
argument_list|(
name|CursorAddress
argument_list|)
condition|)
block|{
name|RingBell
argument_list|(
literal|"Protected Field"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|insert
condition|)
block|{
comment|/* is the last character in the field a blank or null? */
name|i
operator|=
name|ScreenDec
argument_list|(
name|FieldInc
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|=
name|GetHost
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Disspace
argument_list|(
name|j
argument_list|)
condition|)
block|{
name|RingBell
argument_list|(
literal|"No more room for insert"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
name|ScreenDec
argument_list|(
name|i
argument_list|)
init|;
name|i
operator|!=
name|CursorAddress
condition|;
name|j
operator|=
name|ScreenDec
argument_list|(
name|j
argument_list|)
operator|,
name|i
operator|=
name|ScreenDec
argument_list|(
name|i
argument_list|)
control|)
block|{
name|AddHost
argument_list|(
name|i
argument_list|,
name|GetHost
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|AddHost
argument_list|(
name|CursorAddress
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|TurnOnMdt
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
name|CursorAddress
operator|=
name|ScreenInc
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
if|if
condition|(
name|IsStartField
argument_list|(
name|CursorAddress
argument_list|)
operator|&&
operator|(
operator|(
name|FieldAttributes
argument_list|(
name|CursorAddress
argument_list|)
operator|&
name|ATTR_AUTO_SKIP_MASK
operator|)
operator|==
name|ATTR_AUTO_SKIP_VALUE
operator|)
condition|)
block|{
name|Tab
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* go through data until an AID character is hit, then generate an interrupt */
end_comment

begin_function
name|int
name|DataFrom3270
parameter_list|(
name|buffer
parameter_list|,
name|count
parameter_list|)
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* where the data is */
name|int
name|count
decl_stmt|;
comment|/* how much data there is */
block|{
name|int
name|origCount
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|static
name|int
name|InsertMode
init|=
literal|0
decl_stmt|;
comment|/* is the terminal in insert mode? */
name|enum
name|type
name|type
decl_stmt|;
specifier|extern
name|int
name|OutputClock
decl_stmt|,
name|TransparentClock
decl_stmt|;
specifier|static
name|int
name|shifted
init|=
literal|0
decl_stmt|,
name|alted
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|HITNUM
parameter_list|()
value|((shifted? 1:0) + ((alted?1:0)<<1))
if|if
condition|(
operator|*
name|buffer
operator|>=
name|numberof
argument_list|(
name|hits
argument_list|)
condition|)
block|{
name|ExitString
argument_list|(
literal|"Unknown scancode encountered in DataFrom3270.\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|type
operator|=
name|hits
index|[
operator|*
name|buffer
index|]
operator|.
name|hit
index|[
name|HITNUM
argument_list|()
index|]
operator|.
name|type
expr_stmt|;
name|c
operator|=
name|hits
index|[
operator|*
name|buffer
index|]
operator|.
name|hit
index|[
name|HITNUM
argument_list|()
index|]
operator|.
name|code
expr_stmt|;
if|if
condition|(
operator|!
name|UnLocked
operator|||
name|HadAid
condition|)
block|{
if|if
condition|(
name|HadAid
condition|)
block|{
name|SendToIBM
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|EmptyChar
argument_list|()
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* nothing to do */
block|}
block|}
if|if
condition|(
operator|!
name|HadAid
operator|&&
name|EmptyChar
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|type
operator|==
name|function
operator|)
operator|&&
operator|(
operator|(
name|c
operator|==
name|FCN_RESET
operator|)
operator|||
operator|(
name|c
operator|==
name|FCN_MASTER_RESET
operator|)
operator|)
condition|)
block|{
name|UnLocked
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|UnLocked
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* now, either empty, or haven't seen aid yet */
name|origCount
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|TransparentClock
operator|==
name|OutputClock
condition|)
block|{
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
operator|*
name|buffer
operator|>=
name|numberof
argument_list|(
name|hits
argument_list|)
condition|)
block|{
name|ExitString
argument_list|(
literal|"Unknown scancode encountered in DataFrom3270.\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|type
operator|=
name|hits
index|[
operator|*
name|buffer
index|]
operator|.
name|hit
index|[
name|HITNUM
argument_list|()
index|]
operator|.
name|type
expr_stmt|;
name|c
operator|=
name|hits
index|[
operator|*
name|buffer
index|]
operator|.
name|hit
index|[
name|HITNUM
argument_list|()
index|]
operator|.
name|code
expr_stmt|;
name|buffer
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|aid
condition|)
block|{
name|UnLocked
operator|=
literal|0
expr_stmt|;
name|InsertMode
operator|=
literal|0
expr_stmt|;
name|AidByte
operator|=
operator|(
name|c
operator|)
expr_stmt|;
name|HadAid
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|function
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|FCN_ESCAPE
case|:
name|StopScreen
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|command
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ConnectScreen
argument_list|()
expr_stmt|;
break|break;
case|case
name|FCN_RESET
case|:
case|case
name|FCN_MASTER_RESET
case|:
name|UnLocked
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|origCount
operator|-
operator|(
name|count
operator|+
literal|1
operator|)
operator|)
return|;
block|}
block|}
block|}
block|}
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
operator|*
name|buffer
operator|>=
name|numberof
argument_list|(
name|hits
argument_list|)
condition|)
block|{
name|ExitString
argument_list|(
literal|"Unknown scancode encountered in DataFrom3270.\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|type
operator|=
name|hits
index|[
operator|*
name|buffer
index|]
operator|.
name|hit
index|[
name|HITNUM
argument_list|()
index|]
operator|.
name|type
expr_stmt|;
name|c
operator|=
name|hits
index|[
operator|*
name|buffer
index|]
operator|.
name|hit
index|[
name|HITNUM
argument_list|()
index|]
operator|.
name|code
expr_stmt|;
name|buffer
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|character
condition|)
block|{
comment|/* Add the character to the buffer */
name|OneCharacter
argument_list|(
name|c
argument_list|,
name|InsertMode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|aid
condition|)
block|{
comment|/* got Aid */
if|if
condition|(
name|c
operator|==
name|AID_CLEAR
condition|)
block|{
name|LocalClearScreen
argument_list|()
expr_stmt|;
comment|/* Side effect is to clear 3270 */
block|}
name|UnLocked
operator|=
literal|0
expr_stmt|;
name|InsertMode
operator|=
literal|0
expr_stmt|;
comment|/* just like a 3278 */
name|AidByte
operator|=
name|c
expr_stmt|;
name|HadAid
operator|=
literal|1
expr_stmt|;
name|SendToIBM
argument_list|()
expr_stmt|;
return|return
operator|(
name|origCount
operator|-
name|count
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|function
condition|)
block|{
name|ExitString
argument_list|(
literal|"Illegal or undefined scancode!\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|FCN_MAKE_SHIFT
case|:
name|shifted
operator|++
expr_stmt|;
break|break;
case|case
name|FCN_BREAK_SHIFT
case|:
name|shifted
operator|--
expr_stmt|;
if|if
condition|(
name|shifted
operator|<
literal|0
condition|)
block|{
name|ExitString
argument_list|(
literal|"More BREAK_SHIFT than MAKE_SHIFT.\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
break|break;
case|case
name|FCN_MAKE_ALT
case|:
name|alted
operator|++
expr_stmt|;
break|break;
case|case
name|FCN_BREAK_ALT
case|:
name|alted
operator|--
expr_stmt|;
if|if
condition|(
name|alted
operator|<
literal|0
condition|)
block|{
name|ExitString
argument_list|(
literal|"More BREAK_ALT than MAKE_ALT.\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
break|break;
case|case
name|FCN_CURSEL
case|:
name|c
operator|=
name|FieldAttributes
argument_list|(
name|CursorAddress
argument_list|)
operator|&
name|ATTR_DSPD_MASK
expr_stmt|;
if|if
condition|(
operator|!
name|FormattedScreen
argument_list|()
operator|||
operator|(
operator|(
name|c
operator|!=
name|ATTR_DSPD_DSPD
operator|)
operator|&&
operator|(
name|c
operator|!=
name|ATTR_DSPD_HIGH
operator|)
operator|)
condition|)
block|{
name|RingBell
argument_list|(
literal|"Cursor not in selectable field"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|ScreenInc
argument_list|(
name|WhereAttrByte
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|GetHost
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|DISP_QUESTION
condition|)
block|{
name|AddHost
argument_list|(
name|i
argument_list|,
name|DISP_GREATER_THAN
argument_list|)
expr_stmt|;
name|TurnOnMdt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|DISP_GREATER_THAN
condition|)
block|{
name|AddHost
argument_list|(
name|i
argument_list|,
name|DISP_QUESTION
argument_list|)
expr_stmt|;
name|TurnOffMdt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|DISP_BLANK
operator|||
name|c
operator|==
name|DISP_NULL
operator|||
name|c
operator|==
name|DISP_AMPERSAND
condition|)
block|{
name|UnLocked
operator|=
literal|0
expr_stmt|;
name|InsertMode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|DISP_AMPERSAND
condition|)
block|{
name|TurnOnMdt
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* Only for& type */
name|AidByte
operator|=
name|AID_ENTER
expr_stmt|;
block|}
else|else
block|{
name|AidByte
operator|=
name|AID_SELPEN
expr_stmt|;
block|}
name|HadAid
operator|=
literal|1
expr_stmt|;
name|SendToIBM
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|RingBell
argument_list|(
literal|"Cursor not in a selectable field (designator)"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
if|#
directive|if
name|defined
argument_list|(
name|FCN_ERASE
argument_list|)
case|case
name|FCN_ERASE
case|:
if|if
condition|(
name|IsProtected
argument_list|(
name|ScreenDec
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
condition|)
block|{
name|RingBell
argument_list|(
literal|"Protected Field"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CursorAddress
operator|=
name|ScreenDec
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
name|Delete
argument_list|(
name|CursorAddress
argument_list|,
name|ScreenInc
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* defined(FCN_ERASE) */
if|#
directive|if
name|defined
argument_list|(
name|FCN_WERASE
argument_list|)
case|case
name|FCN_WERASE
case|:
name|j
operator|=
name|CursorAddress
expr_stmt|;
name|i
operator|=
name|ScreenDec
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|IsProtected
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|RingBell
argument_list|(
literal|"Protected Field"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SetXIsProtected
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
operator|!
name|XIsProtected
argument_list|(
name|i
argument_list|)
operator|&&
name|Disspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|i
operator|!=
name|j
operator|)
condition|)
block|{
name|i
operator|=
name|ScreenDec
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* we are pointing at a character in a word, or 		     * at a protected position 		     */
while|while
condition|(
operator|(
operator|!
name|XIsProtected
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|Disspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|i
operator|!=
name|j
operator|)
condition|)
block|{
name|i
operator|=
name|ScreenDec
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* we are pointing at a space, or at a protected 		     * position 		     */
name|CursorAddress
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Delete
argument_list|(
name|CursorAddress
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* defined(WERASE) */
if|#
directive|if
name|defined
argument_list|(
name|FCN_FERASE
argument_list|)
case|case
name|FCN_FERASE
case|:
if|if
condition|(
name|IsProtected
argument_list|(
name|CursorAddress
argument_list|)
condition|)
block|{
name|RingBell
argument_list|(
literal|"Protected Field"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CursorAddress
operator|=
name|ScreenInc
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
comment|/* for btab */
name|BackTab
argument_list|()
expr_stmt|;
name|EraseEndOfField
argument_list|()
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* defined(FCN_FERASE) */
if|#
directive|if
name|defined
argument_list|(
name|FCN_RESET
argument_list|)
case|case
name|FCN_RESET
case|:
name|InsertMode
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* defined(FCN_RESET) */
if|#
directive|if
name|defined
argument_list|(
name|FCN_MASTER_RESET
argument_list|)
case|case
name|FCN_MASTER_RESET
case|:
name|InsertMode
operator|=
literal|0
expr_stmt|;
name|RefreshScreen
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* defined(FCN_MASTER_RESET) */
case|case
name|FCN_UP
case|:
name|CursorAddress
operator|=
name|ScreenUp
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
break|break;
case|case
name|FCN_LEFT
case|:
name|CursorAddress
operator|=
name|ScreenDec
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
break|break;
case|case
name|FCN_RIGHT
case|:
name|CursorAddress
operator|=
name|ScreenInc
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
break|break;
case|case
name|FCN_DOWN
case|:
name|CursorAddress
operator|=
name|ScreenDown
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
break|break;
case|case
name|FCN_DELETE
case|:
if|if
condition|(
name|IsProtected
argument_list|(
name|CursorAddress
argument_list|)
condition|)
block|{
name|RingBell
argument_list|(
literal|"Protected Field"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Delete
argument_list|(
name|CursorAddress
argument_list|,
name|ScreenInc
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FCN_INSRT
case|:
name|InsertMode
operator|=
operator|!
name|InsertMode
expr_stmt|;
break|break;
case|case
name|FCN_HOME
case|:
name|Home
argument_list|()
expr_stmt|;
break|break;
case|case
name|FCN_NL
case|:
comment|/* The algorithm is to look for the first unprotected 		 * column after column 0 of the following line.  Having 		 * found that unprotected column, we check whether the 		 * cursor-address-at-entry is at or to the right of the 		 * LeftMargin AND the LeftMargin column of the found line 		 * is unprotected.  If this conjunction is true, then 		 * we set the found pointer to the address of the LeftMargin 		 * column in the found line. 		 * Then, we set the cursor address to the found address. 		 */
name|i
operator|=
name|SetBufferAddress
argument_list|(
name|ScreenLine
argument_list|(
name|ScreenDown
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|j
operator|=
name|ScreenInc
argument_list|(
name|WhereAttrByte
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|IsUnProtected
argument_list|(
name|i
argument_list|)
condition|)
block|{
break|break;
block|}
comment|/* Again (see comment in Home()), this COULD be a problem 		     * with an unformatted screen. 		     */
comment|/* If there was a field with only an attribute byte, 		     * we may be pointing to the attribute byte of the NEXT 		     * field, so just look at the next byte. 		     */
if|if
condition|(
name|IsStartField
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|ScreenInc
argument_list|(
name|FieldInc
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|i
operator|!=
name|j
condition|)
do|;
if|if
condition|(
operator|!
name|IsUnProtected
argument_list|(
name|i
argument_list|)
condition|)
block|{
comment|/* couldn't find unprotected */
name|i
operator|=
name|SetBufferAddress
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|OptLeftMargin
operator|<=
name|ScreenLineOffset
argument_list|(
name|CursorAddress
argument_list|)
condition|)
block|{
if|if
condition|(
name|IsUnProtected
argument_list|(
name|SetBufferAddress
argument_list|(
name|ScreenLine
argument_list|(
name|i
argument_list|)
argument_list|,
name|OptLeftMargin
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|=
name|SetBufferAddress
argument_list|(
name|ScreenLine
argument_list|(
name|i
argument_list|)
argument_list|,
name|OptLeftMargin
argument_list|)
expr_stmt|;
block|}
block|}
name|CursorAddress
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|FCN_EINP
case|:
if|if
condition|(
operator|!
name|FormattedScreen
argument_list|()
condition|)
block|{
name|i
operator|=
name|CursorAddress
expr_stmt|;
name|TurnOnMdt
argument_list|(
name|i
argument_list|)
expr_stmt|;
do|do
block|{
name|AddHost
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|CursorAddress
condition|)
do|;
block|}
else|else
block|{
comment|/* 			 * The algorithm is:  go through each unprotected 			 * field on the screen, clearing it out.  When 			 * we are at the start of a field, skip that field 			 * if its contents are protected. 			 */
name|i
operator|=
name|j
operator|=
name|FieldInc
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|IsUnProtected
argument_list|(
name|ScreenInc
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|TurnOnMdt
argument_list|(
name|i
argument_list|)
expr_stmt|;
do|do
block|{
name|AddHost
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|IsStartField
argument_list|(
name|i
argument_list|)
condition|)
do|;
block|}
else|else
block|{
name|i
operator|=
name|FieldInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|i
operator|!=
name|j
condition|)
do|;
block|}
name|Home
argument_list|()
expr_stmt|;
break|break;
case|case
name|FCN_EEOF
case|:
name|EraseEndOfField
argument_list|()
expr_stmt|;
break|break;
case|case
name|FCN_SPACE
case|:
name|OneCharacter
argument_list|(
name|DISP_BLANK
argument_list|,
name|InsertMode
argument_list|)
expr_stmt|;
comment|/* Add cent */
break|break;
case|case
name|FCN_CENTSIGN
case|:
name|OneCharacter
argument_list|(
name|DISP_CENTSIGN
argument_list|,
name|InsertMode
argument_list|)
expr_stmt|;
comment|/* Add cent */
break|break;
case|case
name|FCN_FM
case|:
name|OneCharacter
argument_list|(
name|DISP_FM
argument_list|,
name|InsertMode
argument_list|)
expr_stmt|;
comment|/* Add field mark */
break|break;
case|case
name|FCN_DP
case|:
if|if
condition|(
name|IsProtected
argument_list|(
name|CursorAddress
argument_list|)
condition|)
block|{
name|RingBell
argument_list|(
literal|"Protected Field"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OneCharacter
argument_list|(
name|DISP_DUP
argument_list|,
name|InsertMode
argument_list|)
expr_stmt|;
comment|/* Add dup character */
name|Tab
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|FCN_TAB
case|:
name|Tab
argument_list|()
expr_stmt|;
break|break;
case|case
name|FCN_BTAB
case|:
name|BackTab
argument_list|()
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|NOTUSED
comment|/* Actually, this is superseded by unix flow 				 * control. 				 */
case|case
name|FCN_XOFF
case|:
name|Flow
operator|=
literal|0
expr_stmt|;
comment|/* stop output */
break|break;
case|case
name|FCN_XON
case|:
if|if
condition|(
operator|!
name|Flow
condition|)
block|{
name|Flow
operator|=
literal|1
expr_stmt|;
comment|/* turn it back on */
name|DoTerminalOutput
argument_list|()
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* NOTUSED */
if|#
directive|if
name|defined
argument_list|(
name|FCN_ESCAPE
argument_list|)
case|case
name|FCN_ESCAPE
case|:
comment|/* FlushChar(); do we want to flush characters from before? */
name|StopScreen
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|command
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ConnectScreen
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* defined(FCN_ESCAPE)  #if	defined(FCN_DISC) 	    case FCN_DISC: 		StopScreen(1); 		suspend(); 		ConnectScreen(); 		break; #endif	/* defined(FCN_DISC) */
if|#
directive|if
name|defined
argument_list|(
name|FCN_RESHOW
argument_list|)
case|case
name|FCN_RESHOW
case|:
name|RefreshScreen
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* defined(FCN_RESHOW) */
if|#
directive|if
name|defined
argument_list|(
name|FCN_SETTAB
argument_list|)
case|case
name|FCN_SETTAB
case|:
name|OptColTabs
index|[
name|ScreenLineOffset
argument_list|(
name|CursorAddress
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* defined(FCN_SETTAB) */
if|#
directive|if
name|defined
argument_list|(
name|FCN_DELTAB
argument_list|)
case|case
name|FCN_DELTAB
case|:
name|OptColTabs
index|[
name|ScreenLineOffset
argument_list|(
name|CursorAddress
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* defined(FCN_DELTAB) */
if|#
directive|if
name|defined
argument_list|(
name|FCN_CLRTAB
argument_list|)
comment|/* 		 * Clear all tabs, home line, and left margin. 		 */
case|case
name|FCN_CLRTAB
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|OptColTabs
condition|;
name|i
operator|++
control|)
block|{
name|OptColTabs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|OptHome
operator|=
literal|0
expr_stmt|;
name|OptLeftMargin
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* defined(FCN_CLRTAB) */
if|#
directive|if
name|defined
argument_list|(
name|FCN_COLTAB
argument_list|)
case|case
name|FCN_COLTAB
case|:
name|ColTab
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* defined(FCN_COLTAB) */
if|#
directive|if
name|defined
argument_list|(
name|FCN_COLBAK
argument_list|)
case|case
name|FCN_COLBAK
case|:
name|ColBak
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* defined(FCN_COLBAK) */
if|#
directive|if
name|defined
argument_list|(
name|FCN_INDENT
argument_list|)
case|case
name|FCN_INDENT
case|:
name|ColTab
argument_list|()
expr_stmt|;
name|OptLeftMargin
operator|=
name|ScreenLineOffset
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* defined(FCN_INDENT) */
if|#
directive|if
name|defined
argument_list|(
name|FCN_UNDENT
argument_list|)
case|case
name|FCN_UNDENT
case|:
name|ColBak
argument_list|()
expr_stmt|;
name|OptLeftMargin
operator|=
name|ScreenLineOffset
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* defined(FCN_UNDENT) */
if|#
directive|if
name|defined
argument_list|(
name|FCN_SETMRG
argument_list|)
case|case
name|FCN_SETMRG
case|:
name|OptLeftMargin
operator|=
name|ScreenLineOffset
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* defined(FCN_SETMRG) */
if|#
directive|if
name|defined
argument_list|(
name|FCN_SETHOM
argument_list|)
case|case
name|FCN_SETHOM
case|:
name|OptHome
operator|=
name|ScreenLine
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* defined(FCN_SETHOM) */
if|#
directive|if
name|defined
argument_list|(
name|FCN_WORDTAB
argument_list|)
comment|/* 		 * Point to first character of next unprotected word on 		 * screen. 		 */
case|case
name|FCN_WORDTAB
case|:
name|i
operator|=
name|CursorAddress
expr_stmt|;
name|SetXIsProtected
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|XIsProtected
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|Disspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|CursorAddress
condition|)
block|{
break|break;
block|}
block|}
comment|/* i is either protected, a space (blank or null), 		 * or wrapped 		 */
while|while
condition|(
name|XIsProtected
argument_list|(
name|i
argument_list|)
operator|||
name|Disspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|CursorAddress
condition|)
block|{
break|break;
block|}
block|}
name|CursorAddress
operator|=
name|i
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* defined(FCN_WORDTAB) */
if|#
directive|if
name|defined
argument_list|(
name|FCN_WORDBACKTAB
argument_list|)
case|case
name|FCN_WORDBACKTAB
case|:
name|i
operator|=
name|ScreenDec
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
name|SetXIsProtected
argument_list|()
expr_stmt|;
while|while
condition|(
name|XIsProtected
argument_list|(
name|i
argument_list|)
operator|||
name|Disspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|=
name|ScreenDec
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|CursorAddress
condition|)
block|{
break|break;
block|}
block|}
comment|/* i is pointing to a character IN an unprotected word 		     * (or i wrapped) 		     */
while|while
condition|(
operator|!
name|Disspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|=
name|ScreenDec
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|CursorAddress
condition|)
block|{
break|break;
block|}
block|}
name|CursorAddress
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* defined(FCN_WORDBACKTAB) */
if|#
directive|if
name|defined
argument_list|(
name|FCN_WORDEND
argument_list|)
comment|/* Point to last non-blank character of this/next 			 * unprotected word. 			 */
case|case
name|FCN_WORDEND
case|:
name|i
operator|=
name|ScreenInc
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
name|SetXIsProtected
argument_list|()
expr_stmt|;
while|while
condition|(
name|XIsProtected
argument_list|(
name|i
argument_list|)
operator|||
name|Disspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|CursorAddress
condition|)
block|{
break|break;
block|}
block|}
comment|/* we are pointing at a character IN an 			 * unprotected word (or we wrapped) 			 */
while|while
condition|(
operator|!
name|Disspace
argument_list|(
name|GetHost
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|CursorAddress
condition|)
block|{
break|break;
block|}
block|}
name|CursorAddress
operator|=
name|ScreenDec
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* defined(WORDEND) */
if|#
directive|if
name|defined
argument_list|(
name|FCN_FIELDEND
argument_list|)
comment|/* Get to last non-blank of this/next unprotected 			 * field. 			 */
case|case
name|FCN_FIELDEND
case|:
name|i
operator|=
name|LastOfField
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|CursorAddress
condition|)
block|{
name|CursorAddress
operator|=
name|i
expr_stmt|;
comment|/* We moved; take this */
block|}
else|else
block|{
name|j
operator|=
name|FieldInc
argument_list|(
name|CursorAddress
argument_list|)
expr_stmt|;
comment|/* Move to next field */
name|i
operator|=
name|LastOfField
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|j
condition|)
block|{
name|CursorAddress
operator|=
name|i
expr_stmt|;
comment|/* We moved; take this */
block|}
comment|/* else - nowhere else on screen to be; stay here */
block|}
break|break;
endif|#
directive|endif
comment|/* defined(FCN_FIELDEND) */
default|default:
comment|/* We don't handle this yet */
name|RingBell
argument_list|(
literal|"Function not implemented"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|origCount
operator|-
name|count
operator|)
return|;
block|}
end_function

end_unit

