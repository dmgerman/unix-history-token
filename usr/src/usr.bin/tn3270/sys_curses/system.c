begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)system.c	4.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|pyr
argument_list|)
end_if

begin_define
define|#
directive|define
name|fd_set
value|fdset_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(pyr) */
end_comment

begin_comment
comment|/*  * Wouldn't it be nice if these REALLY were in<sys/inode.h>?  Or,  * equivalently, if<sys/inode.h> REALLY existed?  */
end_comment

begin_define
define|#
directive|define
name|IREAD
value|00400
end_define

begin_define
define|#
directive|define
name|IWRITE
value|00200
end_define

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|"../general/general.h"
end_include

begin_include
include|#
directive|include
file|"../ctlr/api.h"
end_include

begin_include
include|#
directive|include
file|"../api/api_exch.h"
end_include

begin_include
include|#
directive|include
file|"../general/globals.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|FD_SETSIZE
end_ifndef

begin_comment
comment|/*  * The following is defined just in case someone should want to run  * this telnet on a 4.2 system.  *  */
end_comment

begin_define
define|#
directive|define
name|FD_SET
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|)
value|((p)->fds_bits[0] |= (1<<(n)))
end_define

begin_define
define|#
directive|define
name|FD_CLR
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|)
value|((p)->fds_bits[0]&= ~(1<<(n)))
end_define

begin_define
define|#
directive|define
name|FD_ISSET
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|)
value|((p)->fds_bits[0]& (1<<(n)))
end_define

begin_define
define|#
directive|define
name|FD_ZERO
parameter_list|(
name|p
parameter_list|)
value|((p)->fds_bits[0] = 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|shell_pid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|key
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Actual key */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|keyname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of file with key in it */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ourENVlist
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lots of room */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sock
init|=
operator|-
literal|1
decl_stmt|,
comment|/* Connected socket */
name|serversock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Server (listening) socket */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|DEAD
block|,
name|UNCONNECTED
block|,
name|CONNECTED
block|}
name|state
enum|;
end_enum

begin_decl_stmt
specifier|static
name|long
name|storage_location
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address we have */
end_comment

begin_decl_stmt
specifier|static
name|short
name|storage_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length we have */
end_comment

begin_decl_stmt
specifier|static
name|int
name|storage_must_send
init|=
literal|0
decl_stmt|,
comment|/* Storage belongs on other side of wire */
name|storage_accessed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The storage is accessed (so leave alone)! */
end_comment

begin_decl_stmt
specifier|static
name|long
name|storage
index|[
literal|1000
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|union
name|REGS
name|inputRegs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|SREGS
name|inputSregs
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|kill_connection
parameter_list|()
block|{
name|state
operator|=
name|UNCONNECTED
expr_stmt|;
if|if
condition|(
name|sock
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nextstore
parameter_list|()
block|{
name|struct
name|storage_descriptor
name|sd
decl_stmt|;
if|if
condition|(
name|api_exch_intype
argument_list|(
name|EXCH_TYPE_STORE_DESC
argument_list|,
sizeof|sizeof
name|sd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|storage_length
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|storage_length
operator|=
name|sd
operator|.
name|length
expr_stmt|;
name|storage_location
operator|=
name|sd
operator|.
name|location
expr_stmt|;
if|if
condition|(
name|storage_length
operator|>
sizeof|sizeof
name|storage
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"API client tried to send too much storage (%d).\n"
argument_list|,
name|storage_length
argument_list|)
expr_stmt|;
name|storage_length
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|api_exch_intype
argument_list|(
name|EXCH_TYPE_BYTES
argument_list|,
name|storage_length
argument_list|,
operator|(
name|char
operator|*
operator|)
name|storage
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|storage_length
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|doreject
parameter_list|(
name|message
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
block|{
name|struct
name|storage_descriptor
name|sd
decl_stmt|;
name|int
name|length
init|=
name|strlen
argument_list|(
name|message
argument_list|)
decl_stmt|;
if|if
condition|(
name|api_exch_outcommand
argument_list|(
name|EXCH_CMD_REJECTED
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|sd
operator|.
name|length
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|api_exch_outtype
argument_list|(
name|EXCH_TYPE_STORE_DESC
argument_list|,
sizeof|sizeof
name|sd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|api_exch_outtype
argument_list|(
name|EXCH_TYPE_BYTES
argument_list|,
name|length
argument_list|,
name|message
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * doassociate()  *  * Negotiate with the other side and try to do something.  *  * Returns:  *  *	-1:	Error in processing  *	 0:	Invalid password entered  *	 1:	Association OK  */
end_comment

begin_function
specifier|static
name|int
name|doassociate
parameter_list|()
block|{
name|struct
name|passwd
modifier|*
name|pwent
decl_stmt|;
name|char
name|promptbuf
index|[
literal|100
index|]
decl_stmt|,
name|buffer
index|[
literal|200
index|]
decl_stmt|;
name|struct
name|storage_descriptor
name|sd
decl_stmt|;
specifier|extern
name|char
modifier|*
name|crypt
parameter_list|()
function_decl|;
if|if
condition|(
name|api_exch_intype
argument_list|(
name|EXCH_TYPE_STORE_DESC
argument_list|,
sizeof|sizeof
name|sd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|sd
operator|.
name|length
operator|=
name|sd
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|sd
operator|.
name|length
operator|>
sizeof|sizeof
name|buffer
condition|)
block|{
name|doreject
argument_list|(
literal|"(internal error) Authentication key too long"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|api_exch_intype
argument_list|(
name|EXCH_TYPE_BYTES
argument_list|,
name|sd
operator|.
name|length
argument_list|,
name|buffer
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|buffer
index|[
name|sd
operator|.
name|length
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buffer
argument_list|,
name|key
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|43
operator|)
specifier|extern
name|uid_t
name|geteuid
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/* (!defined(sun)) || defined(BSD)&& (BSD>= 43) */
if|if
condition|(
operator|(
name|pwent
operator|=
name|getpwuid
argument_list|(
operator|(
name|int
operator|)
name|geteuid
argument_list|()
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|sprintf
argument_list|(
name|promptbuf
argument_list|,
literal|"Enter password for user %s:"
argument_list|,
name|pwent
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|api_exch_outcommand
argument_list|(
name|EXCH_CMD_SEND_AUTH
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|sd
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|promptbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|api_exch_outtype
argument_list|(
name|EXCH_TYPE_STORE_DESC
argument_list|,
sizeof|sizeof
name|sd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|api_exch_outtype
argument_list|(
name|EXCH_TYPE_BYTES
argument_list|,
name|strlen
argument_list|(
name|promptbuf
argument_list|)
argument_list|,
name|promptbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|sd
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|pwent
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|api_exch_outtype
argument_list|(
name|EXCH_TYPE_STORE_DESC
argument_list|,
sizeof|sizeof
name|sd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|api_exch_outtype
argument_list|(
name|EXCH_TYPE_BYTES
argument_list|,
name|strlen
argument_list|(
name|pwent
operator|->
name|pw_name
argument_list|)
argument_list|,
name|pwent
operator|->
name|pw_name
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|api_exch_incommand
argument_list|(
name|EXCH_CMD_AUTH
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|api_exch_intype
argument_list|(
name|EXCH_TYPE_STORE_DESC
argument_list|,
sizeof|sizeof
name|sd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|sd
operator|.
name|length
operator|=
name|sd
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|sd
operator|.
name|length
operator|>
sizeof|sizeof
name|buffer
condition|)
block|{
name|doreject
argument_list|(
literal|"Password entered was too long"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|api_exch_intype
argument_list|(
name|EXCH_TYPE_BYTES
argument_list|,
name|sd
operator|.
name|length
argument_list|,
name|buffer
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|buffer
index|[
name|sd
operator|.
name|length
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Is this the correct password? */
if|if
condition|(
name|strlen
argument_list|(
name|pwent
operator|->
name|pw_name
argument_list|)
condition|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ptr
operator|=
name|pwent
operator|->
name|pw_name
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|sd
operator|.
name|length
condition|)
block|{
name|buffer
index|[
name|i
operator|++
index|]
operator|^=
operator|*
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|0
condition|)
block|{
name|ptr
operator|=
name|pwent
operator|->
name|pw_name
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|crypt
argument_list|(
name|buffer
argument_list|,
name|pwent
operator|->
name|pw_passwd
argument_list|)
argument_list|,
name|pwent
operator|->
name|pw_passwd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|doreject
argument_list|(
literal|"Invalid password"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Don't let us do too many of these */
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|api_exch_outcommand
argument_list|(
name|EXCH_CMD_ASSOCIATED
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
name|void
name|freestorage
parameter_list|()
block|{
name|struct
name|storage_descriptor
name|sd
decl_stmt|;
if|if
condition|(
name|storage_accessed
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Internal error - attempt to free accessed storage.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(Encountered in file %s at line %d.)\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|storage_must_send
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|storage_must_send
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|api_exch_outcommand
argument_list|(
name|EXCH_CMD_HEREIS
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|kill_connection
argument_list|()
expr_stmt|;
return|return;
block|}
name|sd
operator|.
name|length
operator|=
name|storage_length
expr_stmt|;
name|sd
operator|.
name|location
operator|=
name|storage_location
expr_stmt|;
if|if
condition|(
name|api_exch_outtype
argument_list|(
name|EXCH_TYPE_STORE_DESC
argument_list|,
sizeof|sizeof
name|sd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|kill_connection
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|api_exch_outtype
argument_list|(
name|EXCH_TYPE_BYTES
argument_list|,
name|storage_length
argument_list|,
operator|(
name|char
operator|*
operator|)
name|storage
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|kill_connection
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|getstorage
parameter_list|(
name|address
parameter_list|,
name|length
parameter_list|,
name|copyin
parameter_list|)
name|long
name|address
decl_stmt|;
name|int
name|length
decl_stmt|,
name|copyin
decl_stmt|;
block|{
name|struct
name|storage_descriptor
name|sd
decl_stmt|;
name|freestorage
argument_list|()
expr_stmt|;
if|if
condition|(
name|storage_accessed
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Internal error - attempt to get while storage accessed.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(Encountered in file %s at line %d.)\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
name|storage_must_send
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|api_exch_outcommand
argument_list|(
name|EXCH_CMD_GIMME
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|kill_connection
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|storage_location
operator|=
name|address
expr_stmt|;
name|storage_length
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|copyin
condition|)
block|{
name|sd
operator|.
name|location
operator|=
operator|(
name|long
operator|)
name|storage_location
expr_stmt|;
name|sd
operator|.
name|length
operator|=
name|storage_length
expr_stmt|;
if|if
condition|(
name|api_exch_outtype
argument_list|(
name|EXCH_TYPE_STORE_DESC
argument_list|,
sizeof|sizeof
name|sd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|kill_connection
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|api_exch_incommand
argument_list|(
name|EXCH_CMD_HEREIS
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad data from other side.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(Encountered at %s, %d.)\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|nextstore
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|kill_connection
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|movetous
parameter_list|(
name|local
parameter_list|,
name|es
parameter_list|,
name|di
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
name|local
decl_stmt|;
name|unsigned
name|int
name|es
decl_stmt|,
name|di
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|long
name|where
init|=
name|SEG_OFF_BACK
argument_list|(
name|es
argument_list|,
name|di
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
sizeof|sizeof
name|storage
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Internal API error - movetous() length too long.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(detected in file %s, line %d)\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|getstorage
argument_list|(
name|where
argument_list|,
name|length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|local
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|storage
operator|+
operator|(
operator|(
name|where
operator|-
name|storage_location
operator|)
operator|)
operator|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|movetothem
parameter_list|(
name|es
parameter_list|,
name|di
parameter_list|,
name|local
parameter_list|,
name|length
parameter_list|)
name|unsigned
name|int
name|es
decl_stmt|,
name|di
decl_stmt|;
name|char
modifier|*
name|local
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|long
name|where
init|=
name|SEG_OFF_BACK
argument_list|(
name|es
argument_list|,
name|di
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
sizeof|sizeof
name|storage
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Internal API error - movetothem() length too long.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(detected in file %s, line %d)\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|freestorage
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|storage
argument_list|,
name|local
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|storage_length
operator|=
name|length
expr_stmt|;
name|storage_location
operator|=
name|where
expr_stmt|;
name|storage_must_send
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|access_api
parameter_list|(
name|location
parameter_list|,
name|length
parameter_list|,
name|copyin
parameter_list|)
name|char
modifier|*
name|location
decl_stmt|;
name|int
name|length
decl_stmt|,
name|copyin
decl_stmt|;
comment|/* Do we need to copy in initially? */
block|{
if|if
condition|(
name|storage_accessed
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Internal error - storage accessed twice\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(Encountered in file %s, line %d.)\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
block|{
name|freestorage
argument_list|()
expr_stmt|;
name|getstorage
argument_list|(
operator|(
name|long
operator|)
name|location
argument_list|,
name|length
argument_list|,
name|copyin
argument_list|)
expr_stmt|;
name|storage_accessed
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|storage
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|unaccess_api
parameter_list|(
name|location
parameter_list|,
name|local
parameter_list|,
name|length
parameter_list|,
name|copyout
parameter_list|)
name|char
modifier|*
name|location
decl_stmt|;
name|char
modifier|*
name|local
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|copyout
decl_stmt|;
block|{
if|if
condition|(
name|storage_accessed
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Internal error - unnecessary unaccess_api call.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(Encountered in file %s, line %d.)\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
name|storage_accessed
operator|=
literal|0
expr_stmt|;
name|storage_must_send
operator|=
name|copyout
expr_stmt|;
comment|/* if needs to go back */
block|}
end_function

begin_comment
comment|/*  * Accept a connection from an API client, aborting if the child dies.  */
end_comment

begin_function
specifier|static
name|int
name|doconnect
parameter_list|()
block|{
name|fd_set
name|fdset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdset
argument_list|)
expr_stmt|;
while|while
condition|(
name|shell_active
operator|&&
operator|(
name|sock
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|FD_SET
argument_list|(
name|serversock
argument_list|,
operator|&
name|fdset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|select
argument_list|(
name|serversock
operator|+
literal|1
argument_list|,
operator|&
name|fdset
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|=
name|EINTR
condition|)
block|{
continue|continue;
block|}
else|else
block|{
name|perror
argument_list|(
literal|"in select waiting for API connection"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|i
operator|=
name|accept
argument_list|(
name|serversock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"accepting API connection"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|sock
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* If the process has already exited, we may need to close */
if|if
condition|(
operator|(
name|shell_active
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sock
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
specifier|extern
name|void
name|setcommandmode
parameter_list|()
function_decl|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
name|setcommandmode
argument_list|()
expr_stmt|;
comment|/* In case child_died sneaked in */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * shell_continue() actually runs the command, and looks for API  * requests coming back in.  *  * We are called from the main loop in telnet.c.  */
end_comment

begin_function
name|int
name|shell_continue
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|DEAD
case|:
name|pause
argument_list|()
expr_stmt|;
comment|/* Nothing to do */
break|break;
case|case
name|UNCONNECTED
case|:
if|if
condition|(
name|doconnect
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|kill_connection
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* At this point, it is possible that we've gone away */
if|if
condition|(
name|shell_active
operator|==
literal|0
condition|)
block|{
name|kill_connection
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|api_exch_init
argument_list|(
name|sock
argument_list|,
literal|"server"
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
name|state
operator|==
name|UNCONNECTED
condition|)
block|{
if|if
condition|(
name|api_exch_incommand
argument_list|(
name|EXCH_CMD_ASSOCIATE
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|kill_connection
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|doassociate
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|kill_connection
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|state
operator|=
name|CONNECTED
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|CONNECTED
case|:
switch|switch
condition|(
name|i
operator|=
name|api_exch_nextcommand
argument_list|()
condition|)
block|{
case|case
name|EXCH_CMD_REQUEST
case|:
if|if
condition|(
name|api_exch_intype
argument_list|(
name|EXCH_TYPE_REGS
argument_list|,
sizeof|sizeof
name|inputRegs
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inputRegs
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|kill_connection
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|api_exch_intype
argument_list|(
name|EXCH_TYPE_SREGS
argument_list|,
sizeof|sizeof
name|inputSregs
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inputSregs
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|kill_connection
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextstore
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|kill_connection
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|handle_api
argument_list|(
operator|&
name|inputRegs
argument_list|,
operator|&
name|inputSregs
argument_list|)
expr_stmt|;
name|freestorage
argument_list|()
expr_stmt|;
comment|/* Send any storage back */
if|if
condition|(
name|api_exch_outcommand
argument_list|(
name|EXCH_CMD_REPLY
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|kill_connection
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|api_exch_outtype
argument_list|(
name|EXCH_TYPE_REGS
argument_list|,
sizeof|sizeof
name|inputRegs
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inputRegs
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|kill_connection
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|api_exch_outtype
argument_list|(
name|EXCH_TYPE_SREGS
argument_list|,
sizeof|sizeof
name|inputSregs
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inputSregs
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|kill_connection
argument_list|()
expr_stmt|;
block|}
comment|/* Done, and it all worked! */
block|}
break|break;
case|case
name|EXCH_CMD_DISASSOCIATE
case|:
name|kill_connection
argument_list|()
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Looking for a REQUEST or DISASSOCIATE command\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\treceived 0x%02x.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|kill_connection
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
name|shell_active
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|child_died
parameter_list|()
block|{
name|union
name|wait
name|status
decl_stmt|;
specifier|register
name|int
name|pid
decl_stmt|;
while|while
condition|(
operator|(
name|pid
operator|=
name|wait3
argument_list|(
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|,
operator|(
expr|struct
name|rusage
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pid
operator|==
name|shell_pid
condition|)
block|{
name|char
name|inputbuffer
index|[
literal|100
index|]
decl_stmt|;
specifier|extern
name|void
name|setconnmode
parameter_list|()
function_decl|;
specifier|extern
name|void
name|ConnectScreen
parameter_list|()
function_decl|;
name|shell_active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sock
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"[Hit return to continue]"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gets
argument_list|(
name|inputbuffer
argument_list|)
expr_stmt|;
name|setconnmode
argument_list|()
expr_stmt|;
name|ConnectScreen
argument_list|()
expr_stmt|;
comment|/* Turn screen on (if need be) */
operator|(
name|void
operator|)
name|close
argument_list|(
name|serversock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|keyname
argument_list|)
expr_stmt|;
block|}
block|}
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|child_died
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called from telnet.c to fork a lower command.com.  We  * use the spint... routines so that we can pick up  * interrupts generated by application programs.  */
end_comment

begin_function
name|int
name|shell
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|length
decl_stmt|;
name|struct
name|sockaddr_in
name|server
decl_stmt|;
name|char
name|sockNAME
index|[
literal|100
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
modifier|*
name|whereAPI
init|=
literal|0
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|long
name|ikey
decl_stmt|;
specifier|extern
name|long
name|random
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
comment|/* First, create verification file. */
do|do
block|{
name|keyname
operator|=
name|mktemp
argument_list|(
literal|"/tmp/apiXXXXXX"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|keyname
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
name|IREAD
operator||
name|IWRITE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|fd
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EEXIST
operator|)
condition|)
do|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"open"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Now, get seed for random */
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"gettimeofday"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|srandom
argument_list|(
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
comment|/* seed random number generator */
do|do
block|{
name|ikey
operator|=
name|random
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|ikey
operator|==
literal|0
condition|)
do|;
name|sprintf
argument_list|(
name|key
argument_list|,
literal|"%lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ikey
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|key
argument_list|,
name|strlen
argument_list|(
name|key
argument_list|)
argument_list|)
operator|!=
name|strlen
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|key
index|[
name|strlen
argument_list|(
name|key
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Get rid of newline */
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Next, create the socket which will be connected to */
name|serversock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|serversock
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"opening API socket"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|server
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|server
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|server
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|serversock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server
argument_list|,
sizeof|sizeof
name|server
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"binding API socket"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|length
operator|=
sizeof|sizeof
name|server
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|serversock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server
argument_list|,
operator|&
name|length
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"getting API socket name"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|serversock
argument_list|)
expr_stmt|;
block|}
name|listen
argument_list|(
name|serversock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Get name to advertise in address list */
name|strcpy
argument_list|(
name|sockNAME
argument_list|,
literal|"API3270="
argument_list|)
expr_stmt|;
name|gethostname
argument_list|(
name|sockNAME
operator|+
name|strlen
argument_list|(
name|sockNAME
argument_list|)
argument_list|,
sizeof|sizeof
name|sockNAME
operator|-
name|strlen
argument_list|(
name|sockNAME
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|sockNAME
argument_list|)
operator|>
operator|(
sizeof|sizeof
name|sockNAME
operator|-
operator|(
literal|10
operator|+
name|strlen
argument_list|(
name|keyname
argument_list|)
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Local hostname too large; using 'localhost'.\n"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sockNAME
argument_list|,
literal|"localhost"
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|sockNAME
operator|+
name|strlen
argument_list|(
name|sockNAME
argument_list|)
argument_list|,
literal|":%u"
argument_list|,
name|ntohs
argument_list|(
name|server
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sockNAME
operator|+
name|strlen
argument_list|(
name|sockNAME
argument_list|)
argument_list|,
literal|":%s"
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
if|if
condition|(
name|whereAPI
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|,
modifier|*
modifier|*
name|nextenv
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
name|ptr
operator|=
name|environ
expr_stmt|;
name|nextenv
operator|=
name|ourENVlist
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
if|if
condition|(
name|nextenv
operator|>=
operator|&
name|ourENVlist
index|[
name|highestof
argument_list|(
name|ourENVlist
argument_list|)
operator|-
literal|1
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many environmental variables\n"
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|nextenv
operator|++
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
block|}
name|whereAPI
operator|=
name|nextenv
operator|++
expr_stmt|;
operator|*
name|nextenv
operator|++
operator|=
literal|0
expr_stmt|;
name|environ
operator|=
name|ourENVlist
expr_stmt|;
comment|/* New environment */
block|}
operator|*
name|whereAPI
operator|=
name|sockNAME
expr_stmt|;
name|child_died
argument_list|()
expr_stmt|;
comment|/* Start up signal handler */
name|shell_active
operator|=
literal|1
expr_stmt|;
comment|/* We are running down below */
if|if
condition|(
name|shell_pid
operator|=
name|vfork
argument_list|()
condition|)
block|{
if|if
condition|(
name|shell_pid
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"vfork"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|serversock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|UNCONNECTED
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* New process */
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
literal|30
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
comment|/* Just get a shell */
name|char
modifier|*
name|cmdname
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|cmdname
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
name|cmdname
argument_list|,
name|cmdname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"Exec'ing new shell...\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execvp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"Exec'ing command.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*NOTREACHED*/
block|}
return|return
name|shell_active
return|;
comment|/* Go back to main loop */
block|}
end_function

end_unit

