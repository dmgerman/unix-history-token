begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ex.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains the code for reading ex commands. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_comment
comment|/* This data type is used to describe the possible argument combinations */
end_comment

begin_typedef
typedef|typedef
name|short
name|ARGT
typedef|;
end_typedef

begin_define
define|#
directive|define
name|FROM
value|1
end_define

begin_comment
comment|/* allow a linespec */
end_comment

begin_define
define|#
directive|define
name|TO
value|2
end_define

begin_comment
comment|/* allow a second linespec */
end_comment

begin_define
define|#
directive|define
name|BANG
value|4
end_define

begin_comment
comment|/* allow a ! after the command name */
end_comment

begin_define
define|#
directive|define
name|EXTRA
value|8
end_define

begin_comment
comment|/* allow extra args after command name */
end_comment

begin_define
define|#
directive|define
name|XFILE
value|16
end_define

begin_comment
comment|/* expand wildcards in extra part */
end_comment

begin_define
define|#
directive|define
name|NOSPC
value|32
end_define

begin_comment
comment|/* no spaces allowed in the extra part */
end_comment

begin_define
define|#
directive|define
name|DFLALL
value|64
end_define

begin_comment
comment|/* default file range is 1,$ */
end_comment

begin_define
define|#
directive|define
name|DFLNONE
value|128
end_define

begin_comment
comment|/* no default file range */
end_comment

begin_define
define|#
directive|define
name|NODFL
value|256
end_define

begin_comment
comment|/* do not default to the current file name */
end_comment

begin_define
define|#
directive|define
name|EXRCOK
value|512
end_define

begin_comment
comment|/* can be in a .exrc file */
end_comment

begin_define
define|#
directive|define
name|NL
value|1024
end_define

begin_comment
comment|/* if mode!=MODE_EX, then write a newline first */
end_comment

begin_define
define|#
directive|define
name|PLUS
value|2048
end_define

begin_comment
comment|/* allow a line number, as in ":e +32 foo" */
end_comment

begin_define
define|#
directive|define
name|ZERO
value|4096
end_define

begin_comment
comment|/* allow 0 to be given as a line number */
end_comment

begin_define
define|#
directive|define
name|NOBAR
value|8192
end_define

begin_comment
comment|/* treat following '|' chars as normal */
end_comment

begin_define
define|#
directive|define
name|FILES
value|(XFILE + EXTRA)
end_define

begin_comment
comment|/* multiple extra files allowed */
end_comment

begin_define
define|#
directive|define
name|WORD1
value|(EXTRA + NOSPC)
end_define

begin_comment
comment|/* one extra word allowed */
end_comment

begin_define
define|#
directive|define
name|FILE1
value|(FILES + NOSPC)
end_define

begin_comment
comment|/* 1 file allowed, defaults to current file */
end_comment

begin_define
define|#
directive|define
name|NAMEDF
value|(FILE1 + NODFL)
end_define

begin_comment
comment|/* 1 file allowed, defaults to "" */
end_comment

begin_define
define|#
directive|define
name|NAMEDFS
value|(FILES + NODFL)
end_define

begin_comment
comment|/* multiple files allowed, default is "" */
end_comment

begin_define
define|#
directive|define
name|RANGE
value|(FROM + TO)
end_define

begin_comment
comment|/* range of linespecs allowed */
end_comment

begin_define
define|#
directive|define
name|NONE
value|0
end_define

begin_comment
comment|/* no args allowed at all */
end_comment

begin_comment
comment|/* This array maps ex command names to command codes. The order in which  * command names are listed below is significant -- ambiguous abbreviations  * are always resolved to be the first possible match.  (e.g. "r" is taken  * to mean "read", not "rewind", because "read" comes before "rewind")  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of the command */
name|CMD
name|code
decl_stmt|;
comment|/* enum code of the command */
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|()
function_decl|;
comment|/* function which executes the command */
name|ARGT
name|argt
decl_stmt|;
comment|/* command line arguments permitted/needed/used */
block|}
name|cmdnames
index|[]
init|=
block|{
comment|/*	cmd name	cmd code	function	arguments */
block|{
literal|"append"
block|,
name|CMD_APPEND
block|,
name|cmd_append
block|,
name|FROM
operator|+
name|ZERO
operator|+
name|BANG
block|}
block|,
ifdef|#
directive|ifdef
name|DEBUG
block|{
literal|"bug"
block|,
name|CMD_DEBUG
block|,
name|cmd_debug
block|,
name|RANGE
operator|+
name|BANG
operator|+
name|EXTRA
operator|+
name|NL
block|}
block|,
endif|#
directive|endif
block|{
literal|"change"
block|,
name|CMD_CHANGE
block|,
name|cmd_append
block|,
name|RANGE
operator|+
name|BANG
block|}
block|,
block|{
literal|"delete"
block|,
name|CMD_DELETE
block|,
name|cmd_delete
block|,
name|RANGE
operator|+
name|WORD1
block|}
block|,
block|{
literal|"edit"
block|,
name|CMD_EDIT
block|,
name|cmd_edit
block|,
name|BANG
operator|+
name|FILE1
operator|+
name|PLUS
block|}
block|,
block|{
literal|"file"
block|,
name|CMD_FILE
block|,
name|cmd_file
block|,
name|NAMEDF
block|}
block|,
block|{
literal|"global"
block|,
name|CMD_GLOBAL
block|,
name|cmd_global
block|,
name|RANGE
operator|+
name|BANG
operator|+
name|EXTRA
operator|+
name|DFLALL
operator|+
name|NOBAR
block|}
block|,
block|{
literal|"insert"
block|,
name|CMD_INSERT
block|,
name|cmd_append
block|,
name|FROM
operator|+
name|BANG
block|}
block|,
block|{
literal|"join"
block|,
name|CMD_INSERT
block|,
name|cmd_join
block|,
name|RANGE
operator|+
name|BANG
block|}
block|,
block|{
literal|"k"
block|,
name|CMD_MARK
block|,
name|cmd_mark
block|,
name|FROM
operator|+
name|WORD1
block|}
block|,
block|{
literal|"list"
block|,
name|CMD_LIST
block|,
name|cmd_print
block|,
name|RANGE
operator|+
name|NL
block|}
block|,
block|{
literal|"move"
block|,
name|CMD_MOVE
block|,
name|cmd_move
block|,
name|RANGE
operator|+
name|EXTRA
block|}
block|,
block|{
literal|"next"
block|,
name|CMD_NEXT
block|,
name|cmd_next
block|,
name|BANG
operator|+
name|NAMEDFS
block|}
block|,
block|{
literal|"Next"
block|,
name|CMD_PREVIOUS
block|,
name|cmd_next
block|,
name|BANG
block|}
block|,
block|{
literal|"print"
block|,
name|CMD_PRINT
block|,
name|cmd_print
block|,
name|RANGE
operator|+
name|NL
block|}
block|,
block|{
literal|"quit"
block|,
name|CMD_QUIT
block|,
name|cmd_xit
block|,
name|BANG
block|}
block|,
block|{
literal|"read"
block|,
name|CMD_READ
block|,
name|cmd_read
block|,
name|FROM
operator|+
name|ZERO
operator|+
name|NAMEDF
block|}
block|,
block|{
literal|"substitute"
block|,
name|CMD_SUBSTITUTE
block|,
name|cmd_substitute
block|,
name|RANGE
operator|+
name|EXTRA
block|}
block|,
block|{
literal|"to"
block|,
name|CMD_COPY
block|,
name|cmd_move
block|,
name|RANGE
operator|+
name|EXTRA
block|}
block|,
block|{
literal|"undo"
block|,
name|CMD_UNDO
block|,
name|cmd_undo
block|,
name|NONE
block|}
block|,
block|{
literal|"vglobal"
block|,
name|CMD_VGLOBAL
block|,
name|cmd_global
block|,
name|RANGE
operator|+
name|EXTRA
operator|+
name|DFLALL
operator|+
name|NOBAR
block|}
block|,
block|{
literal|"write"
block|,
name|CMD_WRITE
block|,
name|cmd_write
block|,
name|RANGE
operator|+
name|BANG
operator|+
name|FILE1
operator|+
name|DFLALL
block|}
block|,
block|{
literal|"xit"
block|,
name|CMD_XIT
block|,
name|cmd_xit
block|,
name|BANG
operator|+
name|NL
block|}
block|,
block|{
literal|"yank"
block|,
name|CMD_YANK
block|,
name|cmd_delete
block|,
name|RANGE
operator|+
name|WORD1
block|}
block|,
block|{
literal|"!"
block|,
name|CMD_BANG
block|,
name|cmd_shell
block|,
name|EXRCOK
operator|+
name|RANGE
operator|+
name|NAMEDFS
operator|+
name|DFLNONE
operator|+
name|NL
operator|+
name|NOBAR
block|}
block|,
block|{
literal|"#"
block|,
name|CMD_NUMBER
block|,
name|cmd_print
block|,
name|RANGE
operator|+
name|NL
block|}
block|,
block|{
literal|"<"
block|,
name|CMD_SHIFTL
block|,
name|cmd_shift
block|,
name|RANGE
block|}
block|,
block|{
literal|">"
block|,
name|CMD_SHIFTR
block|,
name|cmd_shift
block|,
name|RANGE
block|}
block|,
block|{
literal|"="
block|,
name|CMD_EQUAL
block|,
name|cmd_file
block|,
name|RANGE
block|}
block|,
block|{
literal|"&"
block|,
name|CMD_SUBAGAIN
block|,
name|cmd_substitute
block|,
name|RANGE
block|}
block|,
ifndef|#
directive|ifndef
name|NO_AT
block|{
literal|"@"
block|,
name|CMD_AT
block|,
name|cmd_at
block|,
name|EXTRA
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_ABBR
block|{
literal|"abbreviate"
block|,
name|CMD_ABBR
block|,
name|cmd_map
block|,
name|EXRCOK
operator|+
name|BANG
operator|+
name|EXTRA
block|}
block|,
endif|#
directive|endif
block|{
literal|"args"
block|,
name|CMD_ARGS
block|,
name|cmd_args
block|,
name|EXRCOK
operator|+
name|NAMEDFS
block|}
block|,
ifndef|#
directive|ifndef
name|NO_ERRLIST
block|{
literal|"cc"
block|,
name|CMD_CC
block|,
name|cmd_make
block|,
name|BANG
operator|+
name|FILES
block|}
block|,
endif|#
directive|endif
block|{
literal|"cd"
block|,
name|CMD_CD
block|,
name|cmd_cd
block|,
name|EXRCOK
operator|+
name|BANG
operator|+
name|NAMEDF
block|}
block|,
block|{
literal|"copy"
block|,
name|CMD_COPY
block|,
name|cmd_move
block|,
name|RANGE
operator|+
name|EXTRA
block|}
block|,
ifndef|#
directive|ifndef
name|NO_DIGRAPH
block|{
literal|"digraph"
block|,
name|CMD_DIGRAPH
block|,
name|cmd_digraph
block|,
name|EXRCOK
operator|+
name|BANG
operator|+
name|EXTRA
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_ERRLIST
block|{
literal|"errlist"
block|,
name|CMD_ERRLIST
block|,
name|cmd_errlist
block|,
name|BANG
operator|+
name|NAMEDF
block|}
block|,
endif|#
directive|endif
block|{
literal|"ex"
block|,
name|CMD_EDIT
block|,
name|cmd_edit
block|,
name|BANG
operator|+
name|FILE1
block|}
block|,
block|{
literal|"mark"
block|,
name|CMD_MARK
block|,
name|cmd_mark
block|,
name|FROM
operator|+
name|WORD1
block|}
block|,
ifndef|#
directive|ifndef
name|NO_MKEXRC
block|{
literal|"mkexrc"
block|,
name|CMD_MKEXRC
block|,
name|cmd_mkexrc
block|,
name|NAMEDF
block|}
block|,
endif|#
directive|endif
block|{
literal|"number"
block|,
name|CMD_NUMBER
block|,
name|cmd_print
block|,
name|RANGE
operator|+
name|NL
block|}
block|,
block|{
literal|"put"
block|,
name|CMD_PUT
block|,
name|cmd_put
block|,
name|FROM
operator|+
name|ZERO
operator|+
name|WORD1
block|}
block|,
block|{
literal|"set"
block|,
name|CMD_SET
block|,
name|cmd_set
block|,
name|EXRCOK
operator|+
name|EXTRA
block|}
block|,
block|{
literal|"shell"
block|,
name|CMD_SHELL
block|,
name|cmd_shell
block|,
name|NL
block|}
block|,
block|{
literal|"source"
block|,
name|CMD_SOURCE
block|,
name|cmd_source
block|,
name|EXRCOK
operator|+
name|NAMEDF
block|}
block|,
ifdef|#
directive|ifdef
name|SIGTSTP
block|{
literal|"stop"
block|,
name|CMD_STOP
block|,
name|cmd_suspend
block|,
name|NONE
block|}
block|,
endif|#
directive|endif
block|{
literal|"tag"
block|,
name|CMD_TAG
block|,
name|cmd_tag
block|,
name|BANG
operator|+
name|WORD1
block|}
block|,
block|{
literal|"version"
block|,
name|CMD_VERSION
block|,
name|cmd_version
block|,
name|EXRCOK
operator|+
name|NONE
block|}
block|,
block|{
literal|"visual"
block|,
name|CMD_VISUAL
block|,
name|cmd_edit
block|,
name|BANG
operator|+
name|NAMEDF
block|}
block|,
block|{
literal|"wq"
block|,
name|CMD_WQUIT
block|,
name|cmd_xit
block|,
name|NL
block|}
block|,
ifdef|#
directive|ifdef
name|DEBUG
block|{
literal|"debug"
block|,
name|CMD_DEBUG
block|,
name|cmd_debug
block|,
name|RANGE
operator|+
name|BANG
operator|+
name|EXTRA
operator|+
name|NL
block|}
block|,
block|{
literal|"validate"
block|,
name|CMD_VALIDATE
block|,
name|cmd_validate
block|,
name|BANG
operator|+
name|NL
block|}
block|,
endif|#
directive|endif
block|{
literal|"chdir"
block|,
name|CMD_CD
block|,
name|cmd_cd
block|,
name|EXRCOK
operator|+
name|BANG
operator|+
name|NAMEDF
block|}
block|,
ifndef|#
directive|ifndef
name|NO_COLOR
block|{
literal|"color"
block|,
name|CMD_COLOR
block|,
name|cmd_color
block|,
name|EXRCOK
operator|+
name|EXTRA
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_ERRLIST
block|{
literal|"make"
block|,
name|CMD_MAKE
block|,
name|cmd_make
block|,
name|BANG
operator|+
name|NAMEDFS
block|}
block|,
endif|#
directive|endif
block|{
literal|"map"
block|,
name|CMD_MAP
block|,
name|cmd_map
block|,
name|EXRCOK
operator|+
name|BANG
operator|+
name|EXTRA
block|}
block|,
block|{
literal|"previous"
block|,
name|CMD_PREVIOUS
block|,
name|cmd_next
block|,
name|BANG
block|}
block|,
block|{
literal|"rewind"
block|,
name|CMD_REWIND
block|,
name|cmd_next
block|,
name|BANG
block|}
block|,
ifdef|#
directive|ifdef
name|SIGTSTP
block|{
literal|"suspend"
block|,
name|CMD_SUSPEND
block|,
name|cmd_suspend
block|,
name|NONE
block|}
block|,
endif|#
directive|endif
block|{
literal|"unmap"
block|,
name|CMD_UNMAP
block|,
name|cmd_map
block|,
name|EXRCOK
operator|+
name|BANG
operator|+
name|EXTRA
block|}
block|,
ifndef|#
directive|ifndef
name|NO_ABBR
block|{
literal|"unabbreviate"
block|,
name|CMD_UNABBR
block|,
name|cmd_map
block|,
name|EXRCOK
operator|+
name|WORD1
block|}
block|,
endif|#
directive|endif
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* This function parses a search pattern - given a pointer to a / or ?,  * it replaces the ending / or ? with a \0, and returns a pointer to the  * stuff that came after the pattern.  */
end_comment

begin_function
name|char
modifier|*
name|parseptrn
parameter_list|(
name|ptrn
parameter_list|)
name|REG
name|char
modifier|*
name|ptrn
decl_stmt|;
block|{
name|REG
name|char
modifier|*
name|scan
decl_stmt|;
for|for
control|(
name|scan
operator|=
name|ptrn
operator|+
literal|1
init|;
operator|*
name|scan
operator|&&
operator|*
name|scan
operator|!=
operator|*
name|ptrn
condition|;
name|scan
operator|++
control|)
block|{
comment|/* allow backslashed versions of / and ? in the pattern */
if|if
condition|(
operator|*
name|scan
operator|==
literal|'\\'
operator|&&
name|scan
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|scan
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|scan
condition|)
block|{
operator|*
name|scan
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|scan
return|;
block|}
end_function

begin_comment
comment|/* This function parses a line specifier for ex commands */
end_comment

begin_function
name|char
modifier|*
name|linespec
parameter_list|(
name|s
parameter_list|,
name|markptr
parameter_list|)
name|REG
name|char
modifier|*
name|s
decl_stmt|;
comment|/* start of the line specifier */
name|MARK
modifier|*
name|markptr
decl_stmt|;
comment|/* where to store the mark's value */
block|{
name|long
name|num
decl_stmt|;
name|REG
name|char
modifier|*
name|t
decl_stmt|;
comment|/* parse each ;-delimited clause of this linespec */
do|do
block|{
comment|/* skip an initial ';', if any */
if|if
condition|(
operator|*
name|s
operator|==
literal|';'
condition|)
block|{
name|s
operator|++
expr_stmt|;
block|}
comment|/* skip leading spaces */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
block|}
comment|/* dot means current position */
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
name|s
operator|++
expr_stmt|;
operator|*
name|markptr
operator|=
name|cursor
expr_stmt|;
block|}
comment|/* '$' means the last line */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
condition|)
block|{
name|s
operator|++
expr_stmt|;
operator|*
name|markptr
operator|=
name|MARK_LAST
expr_stmt|;
block|}
comment|/* digit means an absolute line number */
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
for|for
control|(
name|num
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
block|{
name|num
operator|=
name|num
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
block|}
operator|*
name|markptr
operator|=
name|MARK_AT_LINE
argument_list|(
name|num
argument_list|)
expr_stmt|;
block|}
comment|/* appostrophe means go to a set mark */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\''
condition|)
block|{
name|s
operator|++
expr_stmt|;
operator|*
name|markptr
operator|=
name|m_tomark
argument_list|(
name|cursor
argument_list|,
literal|1L
argument_list|,
operator|(
name|int
operator|)
operator|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
comment|/* slash means do a search */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
operator|||
operator|*
name|s
operator|==
literal|'?'
condition|)
block|{
comment|/* put a '\0' at the end of the search pattern */
name|t
operator|=
name|parseptrn
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* search for the pattern */
operator|*
name|markptr
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
block|{
name|pfetch
argument_list|(
name|markline
argument_list|(
operator|*
name|markptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|>
literal|0
condition|)
operator|*
name|markptr
operator|+=
name|plen
operator|-
literal|1
expr_stmt|;
operator|*
name|markptr
operator|=
name|m_fsrch
argument_list|(
operator|*
name|markptr
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|markptr
operator|=
name|m_bsrch
argument_list|(
operator|*
name|markptr
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* adjust command string pointer */
name|s
operator|=
name|t
expr_stmt|;
block|}
comment|/* if linespec was faulty, quit now */
if|if
condition|(
operator|!
operator|*
name|markptr
condition|)
block|{
return|return
name|s
return|;
block|}
comment|/* maybe add an offset */
name|t
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'-'
operator|||
operator|*
name|t
operator|==
literal|'+'
condition|)
block|{
name|s
operator|++
expr_stmt|;
for|for
control|(
name|num
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
block|{
name|num
operator|=
name|num
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|==
literal|0
condition|)
block|{
name|num
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|markptr
operator|=
name|m_updnto
argument_list|(
operator|*
name|markptr
argument_list|,
name|num
argument_list|,
operator|*
name|t
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|s
operator|==
literal|';'
operator|||
operator|*
name|s
operator|==
literal|'+'
operator|||
operator|*
name|s
operator|==
literal|'-'
condition|)
do|;
comment|/* protect against invalid line numbers */
name|num
operator|=
name|markline
argument_list|(
operator|*
name|markptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|<
literal|1L
operator|||
name|num
operator|>
name|nlines
condition|)
block|{
name|msg
argument_list|(
literal|"Invalid line number -- must be from 1 to %ld"
argument_list|,
name|nlines
argument_list|)
expr_stmt|;
operator|*
name|markptr
operator|=
name|MARK_UNSET
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* This function reads an ex command and executes it. */
end_comment

begin_function
name|void
name|ex
parameter_list|()
block|{
name|char
name|cmdbuf
index|[
literal|150
index|]
decl_stmt|;
name|REG
name|int
name|cmdlen
decl_stmt|;
specifier|static
name|long
name|oldline
decl_stmt|;
name|significant
operator|=
name|FALSE
expr_stmt|;
name|oldline
operator|=
name|markline
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
while|while
condition|(
name|mode
operator|==
name|MODE_EX
condition|)
block|{
comment|/* read a line */
ifdef|#
directive|ifdef
name|CRUNCH
name|cmdlen
operator|=
name|vgets
argument_list|(
literal|':'
argument_list|,
name|cmdbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|cmdbuf
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|cmdlen
operator|=
name|vgets
argument_list|(
operator|*
name|o_prompt
condition|?
literal|':'
else|:
literal|'\0'
argument_list|,
name|cmdbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|cmdbuf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cmdlen
operator|<
literal|0
condition|)
block|{
return|return;
block|}
comment|/* if empty line, assume ".+1" */
if|if
condition|(
name|cmdlen
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|cmdbuf
argument_list|,
literal|".+1"
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|refresh
argument_list|()
expr_stmt|;
comment|/* parse& execute the command */
name|doexcmd
argument_list|(
name|cmdbuf
argument_list|)
expr_stmt|;
comment|/* handle autoprint */
if|if
condition|(
name|significant
operator|||
name|markline
argument_list|(
name|cursor
argument_list|)
operator|!=
name|oldline
condition|)
block|{
name|significant
operator|=
name|FALSE
expr_stmt|;
name|oldline
operator|=
name|markline
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|o_autoprint
operator|&&
name|mode
operator|==
name|MODE_EX
condition|)
block|{
name|cmd_print
argument_list|(
name|cursor
argument_list|,
name|cursor
argument_list|,
name|CMD_PRINT
argument_list|,
name|FALSE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|doexcmd
parameter_list|(
name|cmdbuf
parameter_list|)
name|char
modifier|*
name|cmdbuf
decl_stmt|;
comment|/* string containing an ex command */
block|{
name|REG
name|char
modifier|*
name|scan
decl_stmt|;
comment|/* used to scan thru cmdbuf */
name|MARK
name|frommark
decl_stmt|;
comment|/* first linespec */
name|MARK
name|tomark
decl_stmt|;
comment|/* second linespec */
name|REG
name|int
name|cmdlen
decl_stmt|;
comment|/* length of the command name given */
name|CMD
name|cmd
decl_stmt|;
comment|/* what command is this? */
name|ARGT
name|argt
decl_stmt|;
comment|/* argument types for this command */
name|short
name|forceit
decl_stmt|;
comment|/* bang version of a command? */
name|REG
name|int
name|cmdidx
decl_stmt|;
comment|/* index of command */
name|REG
name|char
modifier|*
name|build
decl_stmt|;
comment|/* used while copying filenames */
name|int
name|iswild
decl_stmt|;
comment|/* boolean: filenames use wildcards? */
name|int
name|isdfl
decl_stmt|;
comment|/* using default line ranges? */
name|int
name|didsub
decl_stmt|;
comment|/* did we substitute file names for % or # */
comment|/* ex commands can't be undone via the shift-U command */
name|U_line
operator|=
literal|0L
expr_stmt|;
comment|/* permit extra colons at the start of the line */
for|for
control|(
init|;
operator|*
name|cmdbuf
operator|==
literal|':'
condition|;
name|cmdbuf
operator|++
control|)
block|{ 	}
comment|/* ignore command lines that start with a double-quote */
if|if
condition|(
operator|*
name|cmdbuf
operator|==
literal|'"'
condition|)
block|{
return|return;
block|}
name|scan
operator|=
name|cmdbuf
expr_stmt|;
comment|/* parse the line specifier */
if|if
condition|(
name|nlines
operator|<
literal|1
condition|)
block|{
comment|/* no file, so don't allow addresses */
block|}
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|'%'
condition|)
block|{
comment|/* '%' means all lines */
name|frommark
operator|=
name|MARK_FIRST
expr_stmt|;
name|tomark
operator|=
name|MARK_LAST
expr_stmt|;
name|scan
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|'0'
condition|)
block|{
name|frommark
operator|=
name|tomark
operator|=
name|MARK_UNSET
expr_stmt|;
name|scan
operator|++
expr_stmt|;
block|}
else|else
block|{
name|frommark
operator|=
name|cursor
expr_stmt|;
name|scan
operator|=
name|linespec
argument_list|(
name|scan
argument_list|,
operator|&
name|frommark
argument_list|)
expr_stmt|;
name|tomark
operator|=
name|frommark
expr_stmt|;
if|if
condition|(
name|frommark
operator|&&
operator|*
name|scan
operator|==
literal|','
condition|)
block|{
name|scan
operator|++
expr_stmt|;
name|scan
operator|=
name|linespec
argument_list|(
name|scan
argument_list|,
operator|&
name|tomark
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tomark
condition|)
block|{
comment|/* faulty line spec -- fault already described */
return|return;
block|}
if|if
condition|(
name|frommark
operator|>
name|tomark
condition|)
block|{
name|msg
argument_list|(
literal|"first address exceeds the second"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|isdfl
operator|=
operator|(
name|scan
operator|==
name|cmdbuf
operator|)
expr_stmt|;
comment|/* skip whitespace */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
block|{
name|scan
operator|++
expr_stmt|;
block|}
comment|/* if no command, then just move the cursor to the mark */
if|if
condition|(
operator|!
operator|*
name|scan
condition|)
block|{
if|if
condition|(
name|tomark
operator|!=
name|MARK_UNSET
condition|)
name|cursor
operator|=
name|tomark
expr_stmt|;
return|return;
block|}
comment|/* figure out how long the command name is */
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
block|{
name|cmdlen
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|cmdlen
operator|=
literal|1
init|;
name|isalpha
argument_list|(
name|scan
index|[
name|cmdlen
index|]
argument_list|)
condition|;
name|cmdlen
operator|++
control|)
block|{ 		}
block|}
comment|/* lookup the command code */
for|for
control|(
name|cmdidx
operator|=
literal|0
init|;
name|cmdnames
index|[
name|cmdidx
index|]
operator|.
name|name
operator|&&
name|strncmp
argument_list|(
name|scan
argument_list|,
name|cmdnames
index|[
name|cmdidx
index|]
operator|.
name|name
argument_list|,
name|cmdlen
argument_list|)
condition|;
name|cmdidx
operator|++
control|)
block|{ 	}
name|argt
operator|=
name|cmdnames
index|[
name|cmdidx
index|]
operator|.
name|argt
expr_stmt|;
name|cmd
operator|=
name|cmdnames
index|[
name|cmdidx
index|]
operator|.
name|code
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|CMD_NULL
condition|)
block|{
name|msg
argument_list|(
literal|"Unknown command \"%.*s\""
argument_list|,
name|cmdlen
argument_list|,
name|scan
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* !!! if the command doesn't have NOBAR set, then replace | with \0 */
comment|/* if the command ended with a bang, set the forceit flag */
name|scan
operator|+=
name|cmdlen
expr_stmt|;
if|if
condition|(
operator|(
name|argt
operator|&
name|BANG
operator|)
operator|&&
operator|*
name|scan
operator|==
literal|'!'
condition|)
block|{
name|scan
operator|++
expr_stmt|;
name|forceit
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|forceit
operator|=
literal|0
expr_stmt|;
block|}
comment|/* skip any more whitespace, to leave scan pointing to arguments */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
block|{
name|scan
operator|++
expr_stmt|;
block|}
comment|/* a couple of special cases for filenames */
if|if
condition|(
name|argt
operator|&
name|XFILE
condition|)
block|{
comment|/* if names were given, process them */
if|if
condition|(
operator|*
name|scan
condition|)
block|{
for|for
control|(
name|build
operator|=
name|tmpblk
operator|.
name|c
operator|,
name|iswild
operator|=
name|didsub
operator|=
name|FALSE
init|;
operator|*
name|scan
condition|;
name|scan
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|scan
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|scan
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|||
name|scan
index|[
literal|1
index|]
operator|==
literal|'%'
operator|||
name|scan
index|[
literal|1
index|]
operator|==
literal|'#'
condition|)
block|{
operator|*
name|build
operator|++
operator|=
operator|*
operator|++
name|scan
expr_stmt|;
block|}
else|else
block|{
operator|*
name|build
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
operator|!
operator|*
name|origname
condition|)
block|{
name|msg
argument_list|(
literal|"No filename to substitute for %%"
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|build
argument_list|,
name|origname
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|build
condition|)
block|{
name|build
operator|++
expr_stmt|;
block|}
name|didsub
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
if|if
condition|(
operator|!
operator|*
name|prevorig
condition|)
block|{
name|msg
argument_list|(
literal|"No filename to substitute for #"
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|build
argument_list|,
name|prevorig
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|build
condition|)
block|{
name|build
operator|++
expr_stmt|;
block|}
name|didsub
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
case|case
literal|'?'
case|:
if|#
directive|if
operator|!
operator|(
name|MSDOS
operator|||
name|TOS
operator|)
case|case
literal|'['
case|:
case|case
literal|'`'
case|:
case|case
literal|'{'
case|:
comment|/* } */
case|case
literal|'$'
case|:
case|case
literal|'~'
case|:
endif|#
directive|endif
operator|*
name|build
operator|++
operator|=
operator|*
name|scan
expr_stmt|;
name|iswild
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
operator|*
name|build
operator|++
operator|=
operator|*
name|scan
expr_stmt|;
block|}
block|}
operator|*
name|build
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|CMD_BANG
operator|||
name|cmd
operator|==
name|CMD_READ
operator|&&
name|tmpblk
operator|.
name|c
index|[
literal|0
index|]
operator|==
literal|'!'
operator|||
name|cmd
operator|==
name|CMD_WRITE
operator|&&
name|tmpblk
operator|.
name|c
index|[
literal|0
index|]
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
name|didsub
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|MODE_EX
condition|)
block|{
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|addstr
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exrefresh
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|iswild
operator|&&
name|tmpblk
operator|.
name|c
index|[
literal|0
index|]
operator|!=
literal|'>'
condition|)
block|{
name|scan
operator|=
name|wildcard
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* no names given, maybe assume origname */
block|{
if|if
condition|(
operator|!
operator|(
name|argt
operator|&
name|NODFL
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
name|origname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tmpblk
operator|.
name|c
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|scan
operator|=
name|tmpblk
operator|.
name|c
expr_stmt|;
block|}
comment|/* bad arguments? */
if|if
condition|(
operator|!
operator|(
name|argt
operator|&
name|EXRCOK
operator|)
operator|&&
name|nlines
operator|<
literal|1L
condition|)
block|{
name|msg
argument_list|(
literal|"Can't use the \"%s\" command in a %s file"
argument_list|,
name|cmdnames
index|[
name|cmdidx
index|]
operator|.
name|name
argument_list|,
name|EXRC
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|argt
operator|&
operator|(
name|ZERO
operator||
name|EXRCOK
operator|)
operator|)
operator|&&
name|frommark
operator|==
name|MARK_UNSET
condition|)
block|{
name|msg
argument_list|(
literal|"Can't use address 0 with \"%s\" command."
argument_list|,
name|cmdnames
index|[
name|cmdidx
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|argt
operator|&
name|FROM
operator|)
operator|&&
name|frommark
operator|!=
name|cursor
operator|&&
name|nlines
operator|>=
literal|1L
condition|)
block|{
name|msg
argument_list|(
literal|"Can't use address with \"%s\" command."
argument_list|,
name|cmdnames
index|[
name|cmdidx
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|argt
operator|&
name|TO
operator|)
operator|&&
name|tomark
operator|!=
name|frommark
operator|&&
name|nlines
operator|>=
literal|1L
condition|)
block|{
name|msg
argument_list|(
literal|"Can't use a range with \"%s\" command."
argument_list|,
name|cmdnames
index|[
name|cmdidx
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|argt
operator|&
name|EXTRA
operator|)
operator|&&
operator|*
name|scan
condition|)
block|{
name|msg
argument_list|(
literal|"Extra characters after \"%s\" command."
argument_list|,
name|cmdnames
index|[
name|cmdidx
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|argt
operator|&
name|NOSPC
operator|)
operator|&&
operator|!
operator|(
name|cmd
operator|==
name|CMD_READ
operator|&&
operator|(
name|forceit
operator|||
operator|*
name|scan
operator|==
literal|'!'
operator|)
operator|)
condition|)
block|{
name|build
operator|=
name|scan
expr_stmt|;
ifndef|#
directive|ifndef
name|CRUNCH
if|if
condition|(
operator|(
name|argt
operator|&
name|PLUS
operator|)
operator|&&
operator|*
name|build
operator|==
literal|'+'
condition|)
block|{
while|while
condition|(
operator|*
name|build
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|build
argument_list|)
condition|)
block|{
name|build
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|build
operator|&&
name|isspace
argument_list|(
operator|*
name|build
argument_list|)
condition|)
block|{
name|build
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* not CRUNCH */
for|for
control|(
init|;
operator|*
name|build
condition|;
name|build
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|build
argument_list|)
condition|)
block|{
name|msg
argument_list|(
literal|"Too many %s to \"%s\" command."
argument_list|,
operator|(
name|argt
operator|&
name|XFILE
operator|)
condition|?
literal|"filenames"
else|:
literal|"arguments"
argument_list|,
name|cmdnames
index|[
name|cmdidx
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* some commands have special default ranges */
if|if
condition|(
name|isdfl
operator|&&
operator|(
name|argt
operator|&
name|DFLALL
operator|)
condition|)
block|{
name|frommark
operator|=
name|MARK_FIRST
expr_stmt|;
name|tomark
operator|=
name|MARK_LAST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdfl
operator|&&
operator|(
name|argt
operator|&
name|DFLNONE
operator|)
condition|)
block|{
name|frommark
operator|=
name|tomark
operator|=
literal|0L
expr_stmt|;
block|}
comment|/* write a newline if called from visual mode */
if|if
condition|(
operator|(
name|argt
operator|&
name|NL
operator|)
operator|&&
name|mode
operator|!=
name|MODE_EX
operator|&&
operator|!
name|exwrote
condition|)
block|{
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exrefresh
argument_list|()
expr_stmt|;
block|}
comment|/* act on the command */
operator|(
operator|*
name|cmdnames
index|[
name|cmdidx
index|]
operator|.
name|fn
operator|)
operator|(
name|frommark
operator|,
name|tomark
operator|,
name|cmd
operator|,
name|forceit
operator|,
name|scan
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function executes EX commands from a file.  It returns 1 normally, or  * 0 if the file could not be opened for reading.  */
end_comment

begin_function
name|int
name|doexrc
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* name of a ".exrc" file */
block|{
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
name|int
name|len
decl_stmt|;
comment|/* length of the ".exrc" file */
comment|/* !!! kludge: we use U_text as the buffer.  This has the side-effect 	 * of interfering with the shift-U visual command.  Disable shift-U. 	 */
name|U_line
operator|=
literal|0L
expr_stmt|;
comment|/* open the file, read it, and close */
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|len
operator|=
name|tread
argument_list|(
name|fd
argument_list|,
name|U_text
argument_list|,
name|BLKSIZE
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* execute the string */
name|exstring
argument_list|(
name|U_text
argument_list|,
name|len
argument_list|,
name|ctrl
argument_list|(
literal|'V'
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This function executes EX commands from a string.  The commands may be  * separated by newlines or by | characters.  It also handles quoting.  * Each individual command is limited to 132 bytes, but the total string  * may be longer.  */
end_comment

begin_function
name|void
name|exstring
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|,
name|qchar
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* the commands to execute */
name|int
name|len
decl_stmt|;
comment|/* the length of the string */
name|int
name|qchar
decl_stmt|;
comment|/* the quote character -- ^V for file, or \ for kbd */
block|{
name|char
name|single
index|[
literal|133
index|]
decl_stmt|;
comment|/* a single command */
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* find& do each command */
for|for
control|(
name|src
operator|=
name|buf
init|;
name|src
operator|<
operator|&
name|buf
index|[
name|len
index|]
condition|;
name|src
operator|++
control|)
block|{
comment|/* Copy a single command into single[].  Convert any quoted | 		 * into a normal |, and stop at a newline or unquoted |. 		 */
for|for
control|(
name|dest
operator|=
name|single
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|132
operator|&&
name|src
operator|<
operator|&
name|buf
index|[
name|len
index|]
operator|&&
operator|*
name|src
operator|!=
literal|'\n'
operator|&&
operator|*
name|src
operator|!=
literal|'|'
condition|;
name|src
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
name|qchar
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|'|'
condition|)
block|{
name|src
operator|++
expr_stmt|;
block|}
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
expr_stmt|;
block|}
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
comment|/* do it */
name|doexcmd
argument_list|(
name|single
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

