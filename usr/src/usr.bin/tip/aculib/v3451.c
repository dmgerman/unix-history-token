begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	v3451.c	4.1	83/06/15	*/
end_comment

begin_if
if|#
directive|if
name|VADIC
end_if

begin_comment
comment|/*  * Routines for calling up on a Vadic 3451 Modem  */
end_comment

begin_include
include|#
directive|include
file|"tip.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)v3451.c	4.1 %G%"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|va_delay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fudge
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for sleep in vawrite */
end_comment

begin_decl_stmt
name|jmp_buf
name|Sjbuf
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|vadic_dialer
argument_list|(
name|num
argument_list|,
name|acu
argument_list|)
specifier|register
name|char
operator|*
name|num
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|acu
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|lt
decl_stmt|;
name|int
name|ok
decl_stmt|;
name|char
name|phone
index|[
literal|50
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|ACULOG
name|char
name|line
index|[
literal|80
index|]
decl_stmt|;
endif|#
directive|endif
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
if|if
condition|(
name|number
argument_list|(
name|value
argument_list|(
name|BAUDRATE
argument_list|)
argument_list|)
operator|<
literal|1200
condition|)
name|fudge
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Get in synch 	 */
name|lt
operator|=
name|strlen
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|va_delay
operator|=
literal|15
operator|+
literal|3
operator|*
name|lt
expr_stmt|;
name|vawrite
argument_list|(
literal|"I\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vawrite
argument_list|(
literal|"I\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vawrite
argument_list|(
literal|"I\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vawrite
argument_list|(
literal|"\005\r"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ok
operator|=
name|expect
argument_list|(
literal|"READY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
name|printf
argument_list|(
literal|"can't synchronize with vadic 3451\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ACULOG
name|logent
argument_list|(
name|value
argument_list|(
name|HOST
argument_list|)
argument_list|,
name|num
argument_list|,
literal|"vadic"
argument_list|,
literal|"can't synch up"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ioctl
argument_list|(
name|FD
argument_list|,
name|TIOCHPCL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|vawrite
argument_list|(
literal|"D\r"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ok
operator|=
name|expect
argument_list|(
literal|"NUMBER?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
name|printf
argument_list|(
literal|"Vadic will not accept dial command\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ACULOG
name|logent
argument_list|(
name|value
argument_list|(
name|HOST
argument_list|)
argument_list|,
name|num
argument_list|,
literal|"vadic"
argument_list|,
literal|"will not accept dial"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|phone
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|phone
argument_list|,
literal|"\r"
argument_list|)
expr_stmt|;
name|vawrite
argument_list|(
name|phone
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ok
operator|=
name|expect
argument_list|(
name|phone
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
name|printf
argument_list|(
literal|"Vadic will not accept phone number\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ACULOG
name|logent
argument_list|(
name|value
argument_list|(
name|HOST
argument_list|)
argument_list|,
name|num
argument_list|,
literal|"vadic"
argument_list|,
literal|"will not accept number"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|func
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* You cannot interrupt the Vadic when its dialing */
comment|/* Even dropping DTR does not work /* 	/* Definitely a Brain Damaged Design */
name|vawrite
argument_list|(
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vawrite
argument_list|(
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ok
operator|=
name|expect
argument_list|(
literal|"DIALING:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
name|printf
argument_list|(
literal|"Vadic failed to dial\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ACULOG
name|logent
argument_list|(
name|value
argument_list|(
name|HOST
argument_list|)
argument_list|,
name|num
argument_list|,
literal|"vadic"
argument_list|,
literal|"failed to dial"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|printf
argument_list|(
literal|"dialing...\n"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|expect
argument_list|(
literal|"ON LINE"
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
name|printf
argument_list|(
literal|"call failed\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ACULOG
name|logent
argument_list|(
name|value
argument_list|(
name|HOST
argument_list|)
argument_list|,
name|num
argument_list|,
literal|"vadic"
argument_list|,
literal|"call failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ioctl
argument_list|(
name|FD
argument_list|,
name|TIOCFLUSH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|vadic_disconnect
argument_list|()
end_macro

begin_block
block|{
name|char
name|string
index|[
literal|100
index|]
decl_stmt|;
name|close
argument_list|(
name|FD
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* insure that the phone line is dropped */
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"/usr/lib/uucp/enable %s\n"
argument_list|,
name|rindex
argument_list|(
name|DV
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|vadic_abort
argument_list|()
end_macro

begin_block
block|{
name|vadic_disconnect
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|vawrite
argument_list|(
argument|str
argument_list|,
argument|delay
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|delay
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|str
condition|)
block|{
name|write
argument_list|(
name|FD
argument_list|,
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
name|delay
operator|+
name|fudge
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_define
define|#
directive|define
name|MR
value|300
end_define

begin_decl_stmt
name|int
name|Error
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***  *	expect(str)	look for expected string  *	char *str;  *  *	return codes:  *		0  -  found  *		FAIL  -  lost line or too many characters read  *		some character  -  timed out  */
end_comment

begin_macro
name|expect
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|rdvec
index|[
name|MR
index|]
decl_stmt|;
extern|extern alarmtr(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|char
modifier|*
name|rp
init|=
name|rdvec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nextch
init|=
literal|0
decl_stmt|,
name|kr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|alarm_tm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|expect_online
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"\"\""
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
end_if

begin_expr_stmt
operator|*
name|rp
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * If we are waiting for the Vadic to complete 	 * dialing and get a connection, allow more time 	 * Unfortunately, the Vadic times out 24 seconds after 	 * the last digit is dialed 	 */
end_comment

begin_if
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"ON LINE"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|alarm_tm
operator|=
name|number
argument_list|(
name|value
argument_list|(
name|DIALTIMEOUT
argument_list|)
argument_list|)
expr_stmt|;
name|expect_online
operator|++
expr_stmt|;
block|}
else|else
name|alarm_tm
operator|=
literal|30
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alarm
argument_list|(
name|alarm_tm
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|notin
argument_list|(
name|str
argument_list|,
name|rdvec
argument_list|)
condition|)
block|{
if|if
condition|(
name|expect_online
condition|)
if|if
condition|(
name|notin
argument_list|(
literal|"FAILED CALL"
argument_list|,
name|rdvec
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|kr
operator|=
name|read
argument_list|(
name|FD
argument_list|,
operator|&
name|nextch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|kr
operator|<=
literal|0
condition|)
block|{
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|nextch
operator|&
literal|0177
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|rp
operator|=
name|nextch
operator|&
literal|0177
operator|)
operator|!=
literal|'\0'
condition|)
name|rp
operator|++
expr_stmt|;
operator|*
name|rp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rp
operator|>=
name|rdvec
operator|+
name|MR
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_while

begin_expr_stmt
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_comment
unit|}
comment|/***  *	alarmtr()  -  catch alarm routine for "expect".  */
end_comment

begin_expr_stmt
unit|alarmtr
operator|(
operator|)
block|{
name|longjmp
argument_list|(
name|Sjbuf
argument_list|,
literal|1
argument_list|)
block|; }
comment|/***  *	notin(sh, lg)	check for occurrence of substring "sh"  *	char *sh, *lg;  *  *	return codes:  *		0  -  found the string  *		1  -  not in the string  */
name|notin
argument_list|(
argument|sh
argument_list|,
argument|lg
argument_list|)
name|char
operator|*
name|sh
operator|,
operator|*
name|lg
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|lg
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|prefix
argument_list|(
name|sh
argument_list|,
name|lg
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
name|lg
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******  *	prefix(s1, s2)	check s2 for prefix s1  *	char *s1, *s2;  *  *	return 0 - !=  *	return 1 - ==   */
end_comment

begin_macro
name|prefix
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s1
operator|++
operator|)
operator|==
operator|*
name|s2
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|c
operator|==
literal|'\0'
operator|)
return|;
block|}
end_block

end_unit

