begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Allocate registers within a basic block, for GNU compiler.    Copyright (C) 1987, 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Allocation of hard register numbers to pseudo registers is done in    two passes.  In this pass we consider only regs that are born and    die once within one basic block.  We do this one basic block at a    time.  Then the next pass allocates the registers that remain.    Two passes are used because this pass uses methods that work only    on linear code, but that do a better job than the general methods    used in global_alloc, and more quickly too.     The assignments made are recorded in the vector reg_renumber    whose space is allocated here.  The rtl code itself is not altered.     We assign each instruction in the basic block a number    which is its order from the beginning of the block.    Then we can represent the lifetime of a pseudo register with    a pair of numbers, and check for conflicts easily.    We can record the availability of hard registers with a    HARD_REG_SET for each instruction.  The HARD_REG_SET    contains 0 or 1 for each hard reg.     To avoid register shuffling, we tie registers together when one    dies by being copied into another, or dies in an instruction that    does arithmetic to produce another.  The tied registers are    allocated as one.  Registers with different reg class preferences    can never be tied unless the class preferred by one is a subclass    of the one preferred by the other.     Tying is represented with "quantity numbers".    A non-tied register is given a new quantity number.    Tied registers have the same quantity number.        We have provision to exempt registers, even when they are contained    within the block, that can be tied to others that are not contained in it.    This is so that global_alloc could process them both and tie them then.    But this is currently disabled since tying in global_alloc is not    yet implemented.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_comment
comment|/* What about hardware registers used and set within same insn?    Will that ever happen for a non-fixed register?    Our lifetime-tracking for hardware registers would lose.    [This caution is an old comment that may be obsolete;     I think there is no longer a problem, but I'm not sure.]  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Next quantity number available for allocation.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_qty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In all the following vectors indexed by quantity number,    only elements at indices>= FIRST_PSEUDO_REGISTER are actually used.  */
end_comment

begin_comment
comment|/* Element Q is the hard reg number chosen for quantity Q,    or -1 if none was found.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|qty_phys_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element Q is the hard reg number suggested for quantity Q,    or -1 if no specific suggestion.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|qty_phys_sugg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element Q is the number of refs to quantity Q.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|qty_n_refs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element Q is a reg class contained in (smaller than) the    preferred classes of all the pseudo regs that are tied in quantity Q.    This is the preferred class for allocating that quantity.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|reg_class
modifier|*
name|qty_min_class
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insn number (counting from head of basic block)    where quantity Q was born.  -1 if birth has not been recorded.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|qty_birth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insn number (counting from head of basic block)    where quantity Q died.  Due to the way tying is done,    and the fact that we consider in this pass only regs that die but once,    a quantity can die only once.  Each quantity's life span    is a set of consecutive insns.  -1 if death has not been recorded.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|qty_death
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of words needed to hold the data in quantity Q.    This depends on its machine mode.  It is used for these purposes:    1. If it is 0, the qty is not really in use and is not allocated.    2. It is used in computing the relative importances of qtys,       which determines the order in which we look for regs for them.    3. It is used in rules that prevent tying several registers of       different sizes in a way that is geometrically impossible       (see combine_regs).  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|qty_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This holds the mode of the registers that are tied to qty Q,    or VOIDmode if registers with differing modes are tied together.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
modifier|*
name|qty_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of times a reg tied to qty Q lives across a CALL_INSN.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|qty_n_calls_crossed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't allocate qty Q if we can't get its preferred class.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|qty_preferred_or_nothing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reg_qty[N] (where N is a pseudo reg number)    is the qty number of that reg (which is>= FIRST_PSEUDO_REGISTER),    or -1 if (REG N) is not local to the current basic block,    or -2 if not known yet.     If N is< FIRST_PSEUDO_REGISTER, reg_qty[N] is -1.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_qty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The offset (in words) of register N within its quantity.    This can be nonzero if register N is SImode, and has been tied    to a subreg of a DImode register.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector of substitutions of register numbers,    used to map pseudo regs into hardware regs.    This is set up as a result of register allocation.    Element N is the hard reg assigned to pseudo reg N,    or is -1 if no hard reg was assigned.    If N is a hard reg number, element N is N.  */
end_comment

begin_decl_stmt
name|short
modifier|*
name|reg_renumber
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of hard registers live at the current point in the scan    of the instructions in a basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|regs_live
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by insn-number-within-basic-block,    a set or hard registers live *after* that insn.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|regs_live_at
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if a CALL_INSN has been scanned    but we have not yet seen a reference to the value returned.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|call_seen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Communicate local vars `insn_number' and `insn'    from `block_alloc' to `reg_is_set' and `wipe_dead_reg'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|this_insn_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|this_insn
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|block_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|combine_regs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wipe_dead_reg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_free_reg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reg_is_born
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reg_is_set
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_life
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_mark_life
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|qty_compare
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|qty_compare_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reg_meets_class_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reg_class_subset_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reg_classes_overlap_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_qty_class
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Allocate a new quantity (new within current basic block)    for register number REGNO which is born in insn number INSN_NUMBER    within the block.  MODE and SIZE are info on reg REGNO.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_qty
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|,
name|size
parameter_list|,
name|insn_number
parameter_list|)
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|size
decl_stmt|,
name|insn_number
decl_stmt|;
block|{
specifier|register
name|int
name|qty
init|=
name|next_qty
operator|++
decl_stmt|;
name|reg_qty
index|[
name|regno
index|]
operator|=
name|qty
expr_stmt|;
name|reg_offset
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
name|qty_size
index|[
name|qty
index|]
operator|=
name|size
expr_stmt|;
name|qty_mode
index|[
name|qty
index|]
operator|=
name|mode
expr_stmt|;
name|qty_birth
index|[
name|qty
index|]
operator|=
name|insn_number
expr_stmt|;
name|qty_n_calls_crossed
index|[
name|qty
index|]
operator|=
name|reg_n_calls_crossed
index|[
name|regno
index|]
expr_stmt|;
name|qty_min_class
index|[
name|qty
index|]
operator|=
name|reg_preferred_class
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|qty_preferred_or_nothing
index|[
name|qty
index|]
operator|=
name|reg_preferred_or_nothing
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|qty_n_refs
index|[
name|qty
index|]
operator|=
name|reg_n_refs
index|[
name|regno
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Main entry point of this file.  */
end_comment

begin_function
name|void
name|local_alloc
parameter_list|()
block|{
specifier|register
name|int
name|b
decl_stmt|,
name|i
decl_stmt|;
comment|/* Allocate vectors of temporary data.      See the declarations of these variables, above,      for what they mean.  */
name|qty_phys_reg
operator|=
operator|(
name|short
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|qty_phys_sugg
operator|=
operator|(
name|short
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|qty_birth
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|qty_death
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|qty_size
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|qty_mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|machine_mode
argument_list|)
argument_list|)
expr_stmt|;
name|qty_n_calls_crossed
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|qty_min_class
operator|=
operator|(
expr|enum
name|reg_class
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|reg_class
argument_list|)
argument_list|)
expr_stmt|;
name|qty_preferred_or_nothing
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
argument_list|)
expr_stmt|;
name|qty_n_refs
operator|=
operator|(
name|short
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|reg_qty
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_offset
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_renumber
operator|=
operator|(
name|short
operator|*
operator|)
name|oballoc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
name|reg_renumber
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* This controls only how many elts of the `qty_...' vectors      need to be zero for the first basic block.  */
name|next_qty
operator|=
name|max_regno
expr_stmt|;
comment|/* Allocate each block's local registers, block by block.  */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|reg_qty
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
name|qty_phys_sugg
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|qty_birth
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|qty_death
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Set reg_qty to -2 for pseudos in this block, -1 for others.  */
if|if
condition|(
name|reg_basic_block
index|[
name|i
index|]
operator|==
name|b
operator|&&
name|reg_n_deaths
index|[
name|i
index|]
operator|==
literal|1
condition|)
name|reg_qty
index|[
name|i
index|]
operator|=
operator|-
literal|2
expr_stmt|;
else|else
name|reg_qty
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|bzero
argument_list|(
name|reg_offset
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NEXT_QTY indicates which elements of the `qty_...' 	 vectors might need to be initialized.  Initialize those, 	 with explicit loop if there are few, else with bzero.  */
if|if
condition|(
name|next_qty
operator|<
name|FIRST_PSEUDO_REGISTER
operator|+
literal|6
condition|)
block|{
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|next_qty
condition|;
name|i
operator|++
control|)
block|{
name|qty_size
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|qty_mode
index|[
name|i
index|]
operator|=
name|VOIDmode
expr_stmt|;
name|qty_min_class
index|[
name|i
index|]
operator|=
name|NO_REGS
expr_stmt|;
name|qty_preferred_or_nothing
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|qty_n_calls_crossed
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|qty_n_refs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|clear_length
init|=
name|next_qty
operator|-
name|FIRST_PSEUDO_REGISTER
decl_stmt|;
define|#
directive|define
name|CLEAR
parameter_list|(
name|vector
parameter_list|)
define|\
value|bzero ((vector) + FIRST_PSEUDO_REGISTER,    \ 	  (sizeof (*(vector))) * clear_length)
name|CLEAR
argument_list|(
name|qty_size
argument_list|)
expr_stmt|;
name|CLEAR
argument_list|(
name|qty_mode
argument_list|)
expr_stmt|;
name|CLEAR
argument_list|(
name|qty_min_class
argument_list|)
expr_stmt|;
name|CLEAR
argument_list|(
name|qty_preferred_or_nothing
argument_list|)
expr_stmt|;
name|CLEAR
argument_list|(
name|qty_n_calls_crossed
argument_list|)
expr_stmt|;
name|CLEAR
argument_list|(
name|qty_n_refs
argument_list|)
expr_stmt|;
block|}
name|next_qty
operator|=
name|FIRST_PSEUDO_REGISTER
expr_stmt|;
name|block_alloc
argument_list|(
name|b
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate hard regs to the pseudo regs used only within block number B.    Only the pseudos that die but once can be handled.  */
end_comment

begin_function
specifier|static
name|void
name|block_alloc
parameter_list|(
name|b
parameter_list|)
name|int
name|b
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|q
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|;
name|int
name|insn_number
init|=
literal|0
decl_stmt|;
name|int
name|insn_count
init|=
literal|0
decl_stmt|;
name|short
modifier|*
name|qty_order
decl_stmt|;
name|int
modifier|*
name|insn_map
decl_stmt|;
name|call_seen
operator|=
literal|0
expr_stmt|;
comment|/* Count the instructions in the basic block.  */
name|insn
operator|=
name|basic_block_end
index|[
name|b
index|]
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|insn_count
operator|++
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|basic_block_head
index|[
name|b
index|]
condition|)
break|break;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* +1 to leave room for a post_mark_life at the last insn.  */
name|regs_live_at
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|insn_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|regs_live_at
argument_list|,
operator|(
name|insn_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This will be a map from uids to insn-numbers within the block.  */
name|insn_map
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|get_max_uid
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize table of hardware registers currently live.  */
ifdef|#
directive|ifdef
name|HARD_REG_SET
name|regs_live
operator|=
operator|*
name|basic_block_live_at_start
index|[
name|b
index|]
expr_stmt|;
else|#
directive|else
name|COPY_HARD_REG_SET
argument_list|(
name|regs_live
argument_list|,
name|basic_block_live_at_start
index|[
name|b
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This loop scans the instructions of the basic block      and assigns quantities to registers.      It computes which registers to tie.  */
name|insn
operator|=
name|basic_block_head
index|[
name|b
index|]
expr_stmt|;
name|insn_number
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|insn_number
operator|++
expr_stmt|;
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|insn_number
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
specifier|register
name|rtx
name|link
decl_stmt|;
specifier|register
name|int
name|win
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|r0
decl_stmt|,
name|r1
decl_stmt|;
name|int
name|combined_regno
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|insn_code_number
init|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|commutative
init|=
literal|0
decl_stmt|;
name|this_insn_number
operator|=
name|insn_number
expr_stmt|;
name|this_insn
operator|=
name|insn
expr_stmt|;
comment|/* Set COMMUTATIVE if operands 1 and 2 are commutative.  */
if|if
condition|(
name|insn_code_number
operator|>=
literal|0
operator|&&
name|insn_n_operands
index|[
name|insn_code_number
index|]
operator|>
literal|2
operator|&&
name|insn_operand_constraint
index|[
name|insn_code_number
index|]
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
name|commutative
operator|=
literal|1
expr_stmt|;
comment|/* Is this insn suitable for tying two registers? 	     If so, try doing that. 	     Suitable insns are (set reg0 reg1) and 	     (set reg0 (arithop reg1 ...)). 	     For a commutative operation, try (set reg0 (arithop ... reg1)). 	     Subregs in place of regs are also ok. 	     An insn with parallel sets is ok if the first set is suitable.  	     If tying is done, WIN is set nonzero.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|r0
operator|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|r0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|r0
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
operator|(
name|r1
operator|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
name|win
operator|=
name|combine_regs
argument_list|(
name|r1
argument_list|,
name|r0
argument_list|,
name|b
argument_list|,
name|insn_number
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
condition|)
block|{
name|r0
operator|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|r0
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'e'
operator|&&
operator|(
name|r1
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
name|win
operator|=
name|combine_regs
argument_list|(
name|r1
argument_list|,
name|r0
argument_list|,
name|b
argument_list|,
name|insn_number
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|==
literal|0
operator|&&
name|commutative
operator|&&
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
operator|(
name|r1
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
name|win
operator|=
name|combine_regs
argument_list|(
name|r1
argument_list|,
name|r0
argument_list|,
name|b
argument_list|,
name|insn_number
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|rtx
name|set1
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set1
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|r0
operator|=
name|SET_DEST
argument_list|(
name|set1
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|r0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|r0
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set1
argument_list|)
argument_list|)
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'e'
operator|&&
operator|(
name|r1
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
name|win
operator|=
name|combine_regs
argument_list|(
name|r1
argument_list|,
name|r0
argument_list|,
name|b
argument_list|,
name|insn_number
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|==
literal|0
operator|&&
name|commutative
operator|&&
name|GET_CODE
argument_list|(
name|set1
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|r0
operator|=
name|SET_DEST
argument_list|(
name|set1
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|r0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|r0
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set1
argument_list|)
argument_list|)
argument_list|)
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
operator|(
name|r1
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set1
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
name|win
operator|=
name|combine_regs
argument_list|(
name|r1
argument_list|,
name|r0
argument_list|,
name|b
argument_list|,
name|insn_number
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* If registers were just tied, set COMBINED_REGNO 	     to the number of the register used in this insn 	     that was tied to the register set in this insn. 	     This register's qty should not be "killed".  */
if|if
condition|(
name|win
condition|)
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|SUBREG
condition|)
name|r1
operator|=
name|SUBREG_REG
argument_list|(
name|r1
argument_list|)
expr_stmt|;
name|combined_regno
operator|=
name|REGNO
argument_list|(
name|r1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
comment|/* Mark the death of everything that dies in this instruction, 		 except for anything that was just combined.  */
if|if
condition|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|&&
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|combined_regno
operator|!=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* The mechanism in reg_is_set that checks whether the qty dies here 	  ought to handle this case properly.  */
block|if (combined_regno>= 0&& 		      reg_qty[combined_regno] == reg_qty[REGNO (XEXP (link, 0))])
comment|/* Here for the death of the quotient in a divmod insn: 		       something that was born and dead in this insn 		       but combined with something else that also dies here. 		       Mark the qty as dying one instruction later.  */
block|wipe_dead_reg (XEXP (link, 0), insn_number, 				   insn_number + 1); 		  else
endif|#
directive|endif
name|wipe_dead_reg
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn_number
argument_list|,
name|insn_number
argument_list|)
expr_stmt|;
block|}
comment|/* Also, if this insn introduces a "constant" register, 		 that could just be replaced by the value it is given here 		 (which can legitimately be an immediate operand), 		 tell global-alloc not to allocate it 		 unless it is used at least twice more.  */
elseif|else
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_EQUIV
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
comment|/* Don't inhibit allocation of a "constant" register 			  that we have already tied to something else!  */
operator|&&
name|combined_regno
operator|<
literal|0
comment|/* Don't mess with things live during setjmp.  */
operator|&&
name|reg_live_length
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
index|]
operator|>=
literal|0
condition|)
block|{
name|i
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_n_sets
index|[
name|i
index|]
operator|>
literal|1
condition|)
block|{
comment|/* Register is set in another place => not really constant. 			 cse or flow can cause this to happen. 			 Ok, forget we ever thought it was constant.  */
name|GET_MODE
argument_list|(
name|link
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg_n_refs
index|[
name|i
index|]
operator|<=
literal|2
condition|)
block|{
comment|/* For a parameter copy, do let global-alloc 			 allocate it; otherwise we would be forced to 			 have a frame pointer.  */
if|if
condition|(
operator|!
name|frame_pointer_needed
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|reg_live_length
index|[
name|i
index|]
operator|=
operator|-
literal|2
expr_stmt|;
else|else
name|reg_live_length
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If value is not constant, we have a parameter 			 or a static chain pointer.  Tell local-alloc 			 as well not to allocate it.  */
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|reg_basic_block
index|[
name|i
index|]
operator|=
name|REG_BLOCK_GLOBAL
expr_stmt|;
name|reg_qty
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
comment|/* In any case, lower its priority for global-alloc.  */
name|reg_live_length
index|[
name|i
index|]
operator|*=
literal|2
expr_stmt|;
block|}
block|}
comment|/* Allocate qty numbers for all registers local to this block 	     that are born (set) in this instruction. 	     A pseudo that already has a qty is not changed.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg_is_set
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|call_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|basic_block_end
index|[
name|b
index|]
condition|)
break|break;
comment|/* We don't need this for the block's first instruction 	 since no regs we care about are live before that instruction. 	 Also we do not allocate space in regs_live_at for that instruction. */
name|IOR_HARD_REG_SET
argument_list|(
name|regs_live_at
index|[
name|insn_number
index|]
argument_list|,
name|regs_live
argument_list|)
expr_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Now every register that is local to this basic block      should have been given a quantity, or else -1 meaning ignore it.      Every quantity should have a known birth (verify this now).       If a qty's death has not been established, it indicates a dead store.      That is ok if the insn is not entirely dead.      So set the qty'd death to just after its birth.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_basic_block
index|[
name|i
index|]
operator|==
name|b
operator|&&
name|reg_qty
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
comment|/* In the case of a register that is used uninitialized, 	   the code above will miss the actual first use. 	   So count that first use as the birth.  */
if|if
condition|(
name|qty_birth
index|[
name|reg_qty
index|[
name|i
index|]
index|]
operator|>
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|reg_first_use
index|[
name|i
index|]
argument_list|)
index|]
condition|)
name|qty_birth
index|[
name|reg_qty
index|[
name|i
index|]
index|]
operator|=
name|insn_map
index|[
name|INSN_UID
argument_list|(
name|reg_first_use
index|[
name|i
index|]
argument_list|)
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|next_qty
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qty_birth
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|qty_death
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
name|qty_death
index|[
name|i
index|]
operator|=
name|qty_birth
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Now order the qtys so we assign them registers      in order of decreasing length of life.  */
name|qty_order
operator|=
operator|(
name|short
operator|*
operator|)
name|alloca
argument_list|(
name|next_qty
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|next_qty
condition|;
name|i
operator|++
control|)
name|qty_order
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
define|#
directive|define
name|EXCHANGE
parameter_list|(
name|I1
parameter_list|,
name|I2
parameter_list|)
define|\
value|{ i = qty_order[I1]; qty_order[I1] = qty_order[I2]; qty_order[I2] = i; }
if|if
condition|(
name|next_qty
operator|==
literal|2
operator|+
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|qty_compare
argument_list|(
name|FIRST_PSEUDO_REGISTER
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|+
literal|1
argument_list|)
operator|>
literal|0
condition|)
name|EXCHANGE
argument_list|(
name|FIRST_PSEUDO_REGISTER
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next_qty
operator|==
literal|3
operator|+
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|qty_compare
argument_list|(
name|FIRST_PSEUDO_REGISTER
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|+
literal|1
argument_list|)
operator|>
literal|0
condition|)
name|EXCHANGE
argument_list|(
name|FIRST_PSEUDO_REGISTER
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|qty_compare
argument_list|(
name|FIRST_PSEUDO_REGISTER
operator|+
literal|1
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|+
literal|2
argument_list|)
operator|>
literal|0
condition|)
name|EXCHANGE
argument_list|(
name|FIRST_PSEUDO_REGISTER
operator|+
literal|2
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|qty_compare
argument_list|(
name|FIRST_PSEUDO_REGISTER
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|+
literal|1
argument_list|)
operator|>
literal|0
condition|)
name|EXCHANGE
argument_list|(
name|FIRST_PSEUDO_REGISTER
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next_qty
operator|>
literal|3
operator|+
name|FIRST_PSEUDO_REGISTER
condition|)
name|qsort
argument_list|(
name|qty_order
operator|+
name|FIRST_PSEUDO_REGISTER
argument_list|,
name|next_qty
operator|-
name|FIRST_PSEUDO_REGISTER
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
name|qty_compare_1
argument_list|)
expr_stmt|;
comment|/* Now for each qty that is not a hardware register,      look for a hardware register to put it in.      First try the register class that is cheapest for this qty,      if there is more than one class.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|next_qty
condition|;
name|i
operator|++
control|)
block|{
name|q
operator|=
name|qty_order
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|qty_size
index|[
name|q
index|]
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|N_REG_CLASSES
operator|>
literal|1
condition|)
block|{
name|qty_phys_reg
index|[
name|q
index|]
operator|=
name|find_free_reg
argument_list|(
name|qty_min_class
index|[
name|q
index|]
argument_list|,
name|qty_mode
index|[
name|q
index|]
argument_list|,
name|q
argument_list|,
literal|0
argument_list|,
name|qty_birth
index|[
name|q
index|]
argument_list|,
name|qty_death
index|[
name|q
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|qty_phys_reg
index|[
name|q
index|]
operator|>=
literal|0
condition|)
continue|continue;
block|}
if|if
condition|(
operator|!
name|qty_preferred_or_nothing
index|[
name|q
index|]
condition|)
name|qty_phys_reg
index|[
name|q
index|]
operator|=
name|find_free_reg
argument_list|(
name|GENERAL_REGS
argument_list|,
name|qty_mode
index|[
name|q
index|]
argument_list|,
name|q
argument_list|,
literal|0
argument_list|,
name|qty_birth
index|[
name|q
index|]
argument_list|,
name|qty_death
index|[
name|q
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now propagate the register assignments      to the pseudo regs belonging to the qtys.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_qty
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
name|qty_phys_reg
index|[
name|reg_qty
index|[
name|i
index|]
index|]
operator|>=
literal|0
condition|)
block|{
name|reg_renumber
index|[
name|i
index|]
operator|=
name|qty_phys_reg
index|[
name|reg_qty
index|[
name|i
index|]
index|]
operator|+
name|reg_offset
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare two quantities' priority for getting real registers.    We give quantities with hard-reg suggestions priority over all others.    We give longer-lived quantities higher priority    so that the shorter-lived ones will tend to be in the same places    which gives in general the maximum room for the regs to    be allocated by global-alloc.    Regs with more references are also preferred.  */
end_comment

begin_function
specifier|static
name|int
name|qty_compare
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|int
name|q1
decl_stmt|,
name|q2
decl_stmt|;
block|{
specifier|register
name|int
name|tem
init|=
operator|(
name|qty_phys_sugg
index|[
name|q2
index|]
operator|>=
literal|0
operator|)
operator|-
operator|(
name|qty_phys_sugg
index|[
name|q1
index|]
operator|>=
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
return|return
operator|-
operator|(
operator|(
name|qty_n_refs
index|[
name|q1
index|]
operator|+
name|qty_death
index|[
name|q1
index|]
operator|-
name|qty_birth
index|[
name|q1
index|]
operator|)
operator|*
name|qty_size
index|[
name|q2
index|]
operator|-
operator|(
name|qty_n_refs
index|[
name|q2
index|]
operator|+
name|qty_death
index|[
name|q2
index|]
operator|-
name|qty_birth
index|[
name|q2
index|]
operator|)
operator|*
name|qty_size
index|[
name|q1
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|qty_compare_1
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|short
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|tem
init|=
operator|(
name|qty_phys_sugg
index|[
operator|*
name|q2
index|]
operator|>=
literal|0
operator|)
operator|-
operator|(
name|qty_phys_sugg
index|[
operator|*
name|q1
index|]
operator|>=
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
name|tem
operator|=
operator|-
operator|(
operator|(
name|qty_n_refs
index|[
operator|*
name|q1
index|]
operator|+
name|qty_death
index|[
operator|*
name|q1
index|]
operator|-
name|qty_birth
index|[
operator|*
name|q1
index|]
operator|)
operator|*
name|qty_size
index|[
operator|*
name|q2
index|]
operator|-
operator|(
name|qty_n_refs
index|[
operator|*
name|q2
index|]
operator|+
name|qty_death
index|[
operator|*
name|q2
index|]
operator|-
name|qty_birth
index|[
operator|*
name|q2
index|]
operator|)
operator|*
name|qty_size
index|[
operator|*
name|q1
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
comment|/* If qtys are equally good, sort by qty number,      so that the results of qsort leave nothing to chance.  */
return|return
operator|*
name|q1
operator|-
operator|*
name|q2
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Attempt to combine the two registers (rtx's) USEDREG and SETREG.    Returns 1 if have done so, or 0 if cannot.     Combining registers means marking them as having the same quantity    and adjusting the offsets within the quantity if either of    them is a SUBREG).     We don't actually combine a hard reg with a pseudo; instead    we just record the hard reg as the suggestion for the pseudo's quantity.    If we really combined them, we could lose if the pseudo lives    across an insn that clobbers the hard reg (eg, movstr).     There are elaborate checks for the validity of combining.  */
end_comment

begin_function
specifier|static
name|int
name|combine_regs
parameter_list|(
name|usedreg
parameter_list|,
name|setreg
parameter_list|,
name|b
parameter_list|,
name|insn_number
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|usedreg
decl_stmt|,
name|setreg
decl_stmt|;
name|int
name|b
decl_stmt|;
name|int
name|insn_number
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|int
name|ureg
decl_stmt|,
name|sreg
decl_stmt|;
specifier|register
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|usize
decl_stmt|,
name|ssize
decl_stmt|;
specifier|register
name|int
name|sqty
decl_stmt|;
comment|/* Determine the numbers and sizes of registers being used.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|usedreg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|+=
name|SUBREG_WORD
argument_list|(
name|usedreg
argument_list|)
expr_stmt|;
name|usedreg
operator|=
name|SUBREG_REG
argument_list|(
name|usedreg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|usedreg
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|ureg
operator|=
name|REGNO
argument_list|(
name|usedreg
argument_list|)
expr_stmt|;
name|usize
operator|=
name|REG_SIZE
argument_list|(
name|usedreg
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|setreg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|-=
name|SUBREG_WORD
argument_list|(
name|setreg
argument_list|)
expr_stmt|;
name|setreg
operator|=
name|SUBREG_REG
argument_list|(
name|setreg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|setreg
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|sreg
operator|=
name|REGNO
argument_list|(
name|setreg
argument_list|)
expr_stmt|;
name|ssize
operator|=
name|REG_SIZE
argument_list|(
name|setreg
argument_list|)
expr_stmt|;
comment|/* Do not combine registers unless one fits within the other.  */
if|if
condition|(
name|offset
operator|>
literal|0
operator|&&
name|usize
operator|+
name|offset
operator|>
name|ssize
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|offset
operator|<
literal|0
operator|&&
name|usize
operator|+
name|offset
operator|<
name|ssize
condition|)
return|return
literal|0
return|;
comment|/* Do not combine with a smaller already-assigned object      if that smaller object is already combined with something bigger      or if that smaller object is a hard reg.      In the latter case, we would implicitly be using consecutive      hard regs, and there is no code to keep track of that.      (This is overcautious; we could check that ssize actually      requires more hard regs at this spot.)  */
if|if
condition|(
name|ssize
operator|>
name|usize
operator|&&
name|reg_qty
index|[
name|ureg
index|]
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|usize
operator|<
name|qty_size
index|[
name|reg_qty
index|[
name|ureg
index|]
index|]
condition|)
return|return
literal|0
return|;
comment|/* Don't do anything with the non-allocatable registers.      Also, don't suggest a call-clobberable register      for something that must live across calls.      Also, don't suggest a hardware register for anything larger than it.  */
if|if
condition|(
name|ureg
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|fixed_regs
index|[
name|ureg
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reg_n_calls_crossed
index|[
name|sreg
index|]
operator|!=
literal|0
operator|&&
name|call_used_regs
index|[
name|ureg
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|usize
operator|<
name|ssize
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sreg
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|fixed_regs
index|[
name|sreg
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reg_n_calls_crossed
index|[
name|ureg
index|]
operator|!=
literal|0
operator|&&
name|call_used_regs
index|[
name|sreg
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ssize
operator|<
name|usize
condition|)
return|return
literal|0
return|;
block|}
comment|/* Don't tie something to itself.  In most cases it would make no      difference, but it would screw up if the reg being tied to itself      also dies in this insn.  */
if|if
condition|(
name|ureg
operator|==
name|sreg
condition|)
return|return
literal|0
return|;
comment|/* Don't try to connect two different hardware registers.  */
if|if
condition|(
name|ureg
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|sreg
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
comment|/* Don't connect two different machine modes if they have different      implications as to which registers may be used.  */
if|if
condition|(
operator|!
name|MODES_TIEABLE_P
argument_list|(
name|GET_MODE
argument_list|(
name|usedreg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|setreg
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Now, if one of UREG and SREG is a hard reg and the other is      a pseudo, record the hard reg as the qty_phys_sugg for the pseudo      instead of tying them.  */
comment|/* Return "failure" so that the lifespan of UREG is terminated here;      that way the two lifespans will be disjoint and nothing will prevent      the pseudo reg from being given this hard reg.  */
if|if
condition|(
name|ureg
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_qty
index|[
name|sreg
index|]
operator|==
operator|-
literal|2
condition|)
name|reg_is_born
argument_list|(
name|setreg
argument_list|,
name|insn_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_qty
index|[
name|ureg
index|]
operator|==
operator|-
literal|2
condition|)
name|reg_is_born
argument_list|(
name|usedreg
argument_list|,
name|insn_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_qty
index|[
name|sreg
index|]
operator|>=
literal|0
condition|)
name|qty_phys_sugg
index|[
name|reg_qty
index|[
name|sreg
index|]
index|]
operator|=
name|ureg
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sreg
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_qty
index|[
name|sreg
index|]
operator|==
operator|-
literal|2
condition|)
name|reg_is_born
argument_list|(
name|setreg
argument_list|,
name|insn_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_qty
index|[
name|ureg
index|]
operator|==
operator|-
literal|2
condition|)
name|reg_is_born
argument_list|(
name|usedreg
argument_list|,
name|insn_number
argument_list|)
expr_stmt|;
comment|/* If UREG already has a suggested hard reg, don't override it, 	 since the most likely case is on a risc machine 	 when a pseudo gets a subroutine result and is then returned by 	 this function.  In this case, the outgoing register window 	 is probably a better place to use.  */
if|if
condition|(
name|reg_qty
index|[
name|ureg
index|]
operator|>=
literal|0
operator|&&
operator|(
name|qty_phys_sugg
index|[
name|reg_qty
index|[
name|ureg
index|]
index|]
operator|<
literal|0
comment|/* If the old suggestion is no good, override it.  */
operator|||
operator|(
name|qty_n_calls_crossed
index|[
name|reg_qty
index|[
name|ureg
index|]
index|]
operator|!=
literal|0
operator|&&
name|call_used_regs
index|[
name|qty_phys_sugg
index|[
name|reg_qty
index|[
name|ureg
index|]
index|]
index|]
operator|)
operator|)
condition|)
name|qty_phys_sugg
index|[
name|reg_qty
index|[
name|ureg
index|]
index|]
operator|=
name|sreg
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Do nothing if SREG is a pseudo that already has a quantity      or if it isn't local to this basic block or dies more than once.  */
if|if
condition|(
name|reg_qty
index|[
name|sreg
index|]
operator|!=
operator|-
literal|2
condition|)
return|return
literal|0
return|;
comment|/* Do nothing if UREG isn't local to this block or dies more than once.      We do this because global_alloc has no idea of tying,      so there is no use noting those local pseudos that could      profitably be delayed till global_alloc and get tied to global ones.  */
if|if
condition|(
name|reg_qty
index|[
name|ureg
index|]
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
comment|/* We don't already know about SREG, so tie it to UREG      if this is the last use of UREG, provided the classes they want      are compatible.  */
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|ureg
argument_list|)
operator|&&
operator|(
name|reg_qty
index|[
name|ureg
index|]
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|?
name|reg_meets_class_p
argument_list|(
name|sreg
argument_list|,
name|qty_min_class
index|[
name|reg_qty
index|[
name|ureg
index|]
index|]
argument_list|)
else|:
name|reg_meets_class_p
argument_list|(
name|sreg
argument_list|,
name|reg_preferred_class
argument_list|(
name|ureg
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* If combining these two registers would leave no satisfactory 	 register available, don't do it.  */
if|if
condition|(
name|ureg
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|sreg
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|qty_preferred_or_nothing
index|[
name|reg_qty
index|[
name|ureg
index|]
index|]
operator|||
name|reg_preferred_or_nothing
argument_list|(
name|sreg
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|reg_classes_overlap_p
argument_list|(
name|reg_preferred_class
argument_list|(
name|ureg
argument_list|)
argument_list|,
name|reg_preferred_class
argument_list|(
name|sreg
argument_list|)
argument_list|,
name|reg_n_calls_crossed
index|[
name|ureg
index|]
operator|||
name|reg_n_calls_crossed
index|[
name|sreg
index|]
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reg_qty
index|[
name|ureg
index|]
operator|==
operator|-
literal|2
condition|)
name|reg_is_born
argument_list|(
name|usedreg
argument_list|,
name|insn_number
argument_list|)
expr_stmt|;
name|sqty
operator|=
name|reg_qty
index|[
name|sreg
index|]
operator|=
name|reg_qty
index|[
name|ureg
index|]
expr_stmt|;
if|if
condition|(
name|sqty
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If SREG's reg class is smaller, set qty_min_class[SQTY].  */
name|update_qty_class
argument_list|(
name|sqty
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|reg_offset
index|[
name|sreg
index|]
operator|=
name|reg_offset
index|[
name|ureg
index|]
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|sqty
operator|>=
literal|0
condition|)
block|{
name|qty_n_calls_crossed
index|[
name|sqty
index|]
operator|+=
name|reg_n_calls_crossed
index|[
name|sreg
index|]
expr_stmt|;
name|qty_n_refs
index|[
name|sqty
index|]
operator|+=
name|reg_n_refs
index|[
name|sreg
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|reg_preferred_or_nothing
argument_list|(
name|sreg
argument_list|)
condition|)
name|qty_preferred_or_nothing
index|[
name|sqty
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|usize
operator|<
name|ssize
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_qty
index|[
name|i
index|]
operator|==
name|sqty
condition|)
name|reg_offset
index|[
name|i
index|]
operator|-=
name|offset
expr_stmt|;
name|qty_size
index|[
name|sqty
index|]
operator|=
name|ssize
expr_stmt|;
name|qty_mode
index|[
name|sqty
index|]
operator|=
name|GET_MODE
argument_list|(
name|setreg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the preferred class of REG allows it to be tied    to a quantity or register whose class is CLASS.    True if REG's reg class either contains or is contained in CLASS.  */
end_comment

begin_function
specifier|static
name|int
name|reg_meets_class_p
parameter_list|(
name|reg
parameter_list|,
name|class
parameter_list|)
name|int
name|reg
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
block|{
specifier|register
name|enum
name|reg_class
name|rclass
init|=
name|reg_preferred_class
argument_list|(
name|reg
argument_list|)
decl_stmt|;
return|return
operator|(
name|reg_class_subset_p
argument_list|(
name|rclass
argument_list|,
name|class
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|rclass
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if R2's preferred class is the same as or contains    R1's preferred class.  R1 and R2 are pseudo-register numbers.  */
end_comment

begin_function
specifier|static
name|int
name|reg_class_subset_p
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
specifier|register
name|enum
name|reg_class
name|c1
decl_stmt|;
specifier|register
name|enum
name|reg_class
name|c2
decl_stmt|;
block|{
if|if
condition|(
name|c1
operator|==
name|c2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c2
operator|==
name|ALL_REGS
condition|)
name|win
label|:
return|return
literal|1
return|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|c1
index|]
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|c2
index|]
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the two specified classes have registers in common.    If CALL_SAVED, then consider only call-saved registers.  */
end_comment

begin_function
specifier|static
name|int
name|reg_classes_overlap_p
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|,
name|call_saved
parameter_list|)
specifier|register
name|enum
name|reg_class
name|c1
decl_stmt|;
specifier|register
name|enum
name|reg_class
name|c2
decl_stmt|;
name|int
name|call_saved
decl_stmt|;
block|{
name|HARD_REG_SET
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|c1
index|]
argument_list|)
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|c2
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|c
argument_list|,
name|i
argument_list|)
operator|&&
operator|(
operator|!
name|call_saved
operator|||
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Update the class of QTY assuming that REG is being tied to it.  */
end_comment

begin_function
specifier|static
name|void
name|update_qty_class
parameter_list|(
name|qty
parameter_list|,
name|reg
parameter_list|)
name|int
name|qty
decl_stmt|;
name|int
name|reg
decl_stmt|;
block|{
name|enum
name|reg_class
name|rclass
init|=
name|reg_preferred_class
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|rclass
argument_list|,
name|qty_min_class
index|[
name|qty
index|]
argument_list|)
condition|)
name|qty_min_class
index|[
name|qty
index|]
operator|=
name|rclass
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle something which alters the value of an rtx REG.    REG is whatever is set or clobbered.  (CLOBBER_FLAG says which.)    If it is not really a register, we do nothing.    The file-global variables `this_insn' and `this_insn_number'    carry info from `block_alloc'.  */
end_comment

begin_function
specifier|static
name|void
name|reg_is_set
parameter_list|(
name|reg
parameter_list|,
name|setter
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|setter
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
name|int
name|clobber_flag
init|=
name|GET_CODE
argument_list|(
name|setter
argument_list|)
operator|==
name|CLOBBER
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* A hard reg is set or clobbered. 	 Mark it as live at the moment immediately following this insn 	 so that no pseudo can live here at that time. 	 For a CLOBBER, mark it as live before this insn, 	 to make sure it is free during the entire insn.  */
specifier|register
name|int
name|lim
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|regs_live_at
index|[
name|this_insn_number
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|clobber_flag
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|regs_live_at
index|[
name|this_insn_number
operator|-
literal|1
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* If the hard reg is given a useful value 	 and it does not die in this insn, 	 mark it as live indefinitely afterward.  */
if|if
condition|(
operator|!
name|clobber_flag
operator|&&
operator|!
name|find_regno_note
argument_list|(
name|this_insn
argument_list|,
name|REG_DEAD
argument_list|,
name|regno
argument_list|)
condition|)
name|reg_is_born
argument_list|(
name|reg
argument_list|,
name|this_insn_number
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|clobber_flag
condition|)
block|{
comment|/* A pseudo-reg is set (not just clobbered).  */
name|reg_is_born
argument_list|(
name|reg
argument_list|,
name|this_insn_number
argument_list|)
expr_stmt|;
comment|/* If a pseudo register dies in the same insn that sets it, 	 say it dies in the following insn instead, 	 because it will have to be live right after this insn.  */
if|if
condition|(
name|qty_death
index|[
name|reg_qty
index|[
name|regno
index|]
index|]
operator|==
name|this_insn_number
condition|)
block|{
comment|/* Calls to post_mark_life and mark_life deleted here. 	     They only know how to handle hard regs.  */
name|qty_death
index|[
name|reg_qty
index|[
name|regno
index|]
index|]
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|reg_qty
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
name|qty_death
index|[
name|reg_qty
index|[
name|regno
index|]
index|]
operator|==
name|this_insn_number
operator|&&
name|qty_birth
index|[
name|reg_qty
index|[
name|regno
index|]
index|]
operator|==
name|this_insn_number
condition|)
block|{
comment|/* A psuedo-reg is clobbered by this insn and was born and dies here. 	 This is a temporary required for this insn and so will 	 conflict with any other live registers at this point.  We must 	 assume that this register is used before all the inputs of the 	 insn are dead.  So this register must not conflict with any of them. 	 Mark it as born at the previous insn.  */
name|qty_birth
index|[
name|reg_qty
index|[
name|regno
index|]
index|]
operator|--
expr_stmt|;
comment|/* It should also conflict with this insn's outputs.  */
name|qty_death
index|[
name|reg_qty
index|[
name|regno
index|]
index|]
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle beginning of the life of register REG.    INSN_NUMBER is the insn at which this is happening.  */
end_comment

begin_function
specifier|static
name|void
name|reg_is_born
parameter_list|(
name|reg
parameter_list|,
name|insn_number
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|int
name|insn_number
decl_stmt|;
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|mark_life
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_qty
index|[
name|regno
index|]
operator|==
operator|-
literal|2
condition|)
name|alloc_qty
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|PSEUDO_REGNO_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|,
name|insn_number
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the death in insn DEATH_INSN_NUMBER for the register REG.  */
end_comment

begin_function
specifier|static
name|void
name|wipe_dead_reg
parameter_list|(
name|reg
parameter_list|,
name|this_insn_number
parameter_list|,
name|death_insn_number
parameter_list|)
specifier|register
name|rtx
name|reg
decl_stmt|;
name|int
name|this_insn_number
decl_stmt|;
name|int
name|death_insn_number
decl_stmt|;
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|mark_life
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_insn_number
operator|!=
name|death_insn_number
condition|)
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Should never get here */
block|post_mark_life (regno, GET_MODE (reg), 1, 			this_insn_number, death_insn_number);
endif|#
directive|endif
block|}
else|else
block|{
comment|/* If a pseudo reg is referred to but was never set, 	 we will find here that its qty is -2. 	 Since these regs do not conflict with anything, 	 mark them as born and dead in the same place.  */
if|if
condition|(
name|reg_qty
index|[
name|regno
index|]
operator|==
operator|-
literal|2
condition|)
block|{
name|alloc_qty
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|REG_SIZE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|this_insn_number
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|this_insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_UNSET
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|this_insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg_qty
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|qty_death
index|[
name|reg_qty
index|[
name|regno
index|]
index|]
operator|=
name|death_insn_number
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find a block of SIZE words of hard regs in reg_class CLASS    that can hold something of machine-mode MODE      (but actually we test only the first of the block for holding MODE)    and still free between insn BORN_INSN and insn DEAD_INSN,    and return the number of the first of them.    Return -1 if such a block cannot be found.     If QTY crosses calls, insist on a register preserved by calls,    unless ACCEPT_CALL_CLOBBERED is nonzero.  */
end_comment

begin_function
specifier|static
name|int
name|find_free_reg
parameter_list|(
name|class
parameter_list|,
name|mode
parameter_list|,
name|qty
parameter_list|,
name|accept_call_clobbered
parameter_list|,
name|born_insn
parameter_list|,
name|dead_insn
parameter_list|)
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|accept_call_clobbered
decl_stmt|;
name|int
name|qty
decl_stmt|;
name|int
name|born_insn
decl_stmt|,
name|dead_insn
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|ins
decl_stmt|;
ifdef|#
directive|ifdef
name|HARD_REG_SET
specifier|register
comment|/* Declare it register if it's a scalar.  */
endif|#
directive|endif
name|HARD_REG_SET
name|used
decl_stmt|;
if|if
condition|(
name|accept_call_clobbered
condition|)
name|COPY_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|call_fixed_reg_set
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|qty_n_calls_crossed
index|[
name|qty
index|]
operator|==
literal|0
condition|)
name|COPY_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|fixed_reg_set
argument_list|)
expr_stmt|;
else|else
name|COPY_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
for|for
control|(
name|ins
operator|=
name|born_insn
init|;
name|ins
operator|<
name|dead_insn
condition|;
name|ins
operator|++
control|)
name|IOR_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|regs_live_at
index|[
name|ins
index|]
argument_list|)
expr_stmt|;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
comment|/* Don't use the frame pointer reg in local-alloc even if      we may omit the frame pointer, because if we do that and then we      need a frame pointer, reload won't know how to move the pseudo      to another hard reg.  It can move only regs made by global-alloc.  */
name|SET_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
comment|/* If quantity QTY has a suggested physical register,      try that one first.  */
if|if
condition|(
name|qty_phys_sugg
index|[
name|qty
index|]
operator|>=
literal|0
condition|)
block|{
name|i
operator|=
name|qty_phys_sugg
index|[
name|qty
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|i
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|size1
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|size1
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|i
operator|+
name|j
argument_list|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
name|size1
condition|)
block|{
name|post_mark_life
argument_list|(
name|i
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|born_insn
argument_list|,
name|dead_insn
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
block|}
comment|/* If that doesn't find one, test each hard reg.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
name|int
name|regno
init|=
name|reg_alloc_order
index|[
name|i
index|]
decl_stmt|;
else|#
directive|else
name|int
name|regno
init|=
name|i
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|regno
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|size1
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|size1
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|regno
operator|+
name|j
argument_list|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
name|size1
condition|)
block|{
name|post_mark_life
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|born_insn
argument_list|,
name|dead_insn
argument_list|)
expr_stmt|;
return|return
name|regno
return|;
block|}
ifndef|#
directive|ifndef
name|REG_ALLOC_ORDER
name|i
operator|+=
name|j
expr_stmt|;
comment|/* Skip starting points we know will lose */
endif|#
directive|endif
block|}
block|}
comment|/* If it would be profitable to allocate a call-clobbered register      and save and restore it around calls, do that.  */
if|if
condition|(
operator|!
name|accept_call_clobbered
operator|&&
name|flag_caller_saves
operator|&&
name|qty_n_calls_crossed
index|[
name|qty
index|]
operator|!=
literal|0
operator|&&
name|CALLER_SAVE_PROFITABLE
argument_list|(
name|qty_n_refs
index|[
name|qty
index|]
argument_list|,
name|qty_n_calls_crossed
index|[
name|qty
index|]
argument_list|)
condition|)
block|{
name|i
operator|=
name|find_free_reg
argument_list|(
name|class
argument_list|,
name|mode
argument_list|,
name|qty
argument_list|,
literal|1
argument_list|,
name|born_insn
argument_list|,
name|dead_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|caller_save_needed
operator|=
literal|1
expr_stmt|;
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mark_life
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|,
name|life
parameter_list|)
specifier|register
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|life
decl_stmt|;
block|{
specifier|register
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|life
condition|)
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|regs_live
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|regs_live
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_mark_life
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|,
name|life
parameter_list|,
name|birth
parameter_list|,
name|death
parameter_list|)
specifier|register
name|int
name|regno
decl_stmt|,
name|life
decl_stmt|,
name|birth
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|death
decl_stmt|;
block|{
specifier|register
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HARD_REG_SET
specifier|register
comment|/* Declare it register if it's a scalar.  */
endif|#
directive|endif
name|HARD_REG_SET
name|this_reg
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|this_reg
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|this_reg
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
comment|/* If a reg is born and dies in one insn,      consider it live after that insn.  */
if|if
condition|(
name|birth
operator|==
name|death
condition|)
name|death
operator|++
expr_stmt|;
if|if
condition|(
name|life
condition|)
while|while
condition|(
name|birth
operator|<
name|death
condition|)
block|{
name|IOR_HARD_REG_SET
argument_list|(
name|regs_live_at
index|[
name|birth
index|]
argument_list|,
name|this_reg
argument_list|)
expr_stmt|;
name|birth
operator|++
expr_stmt|;
block|}
else|else
while|while
condition|(
name|birth
operator|<
name|death
condition|)
block|{
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|regs_live_at
index|[
name|birth
index|]
argument_list|,
name|this_reg
argument_list|)
expr_stmt|;
name|birth
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dump_local_alloc
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; Register %d in %d.\n"
argument_list|,
name|i
argument_list|,
name|reg_renumber
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

