begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for assembler code output on the NS32000.    Copyright (C) 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Some output-actions in ns32k.md need these.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FP_REG_P
parameter_list|(
name|X
parameter_list|)
value|(GET_CODE (X) == REG&& REGNO (X)> 7&& REGNO (X)< 16)
end_define

begin_comment
comment|/* Generate the rtx that comes from an address expression in the md file */
end_comment

begin_comment
comment|/* The expression to be build is BASE[INDEX:SCALE].  To recognize this,    scale must be converted from an exponent (from ASHIFT) to a    muliplier (for MULT). */
end_comment

begin_function
name|rtx
name|gen_indexed_expr
parameter_list|(
name|base
parameter_list|,
name|index
parameter_list|,
name|scale
parameter_list|)
name|rtx
name|base
decl_stmt|,
name|index
decl_stmt|,
name|scale
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|;
comment|/* This generates an illegal addressing mode, if BASE is      fp or sp.  This is handled by PRINT_OPERAND_ADDRESS.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|base
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|SImode
argument_list|,
name|index
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
literal|1
operator|<<
name|INTVAL
argument_list|(
name|scale
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|SImode
argument_list|,
name|base
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid constant int. These can be modeless    (void mode), so we do not mess with their modes.     The main use of this function is as a predicate in match_operand    expressions in the machine description.  */
end_comment

begin_function
name|int
name|const_int
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand of mode MODE.  This    predicate rejects operands which do not have a mode    (such as CONST_INT which are VOIDmode).  */
end_comment

begin_function
name|int
name|reg_or_mem_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the best assembler insn template    for moving operands[1] into operands[0] as a fullword.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|singlemove_string
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|<=
literal|7
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|>=
operator|-
literal|8
condition|)
return|return
literal|"movqd %1,%0"
return|;
return|return
literal|"movd %1,%0"
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|output_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
enum|enum
name|anon1
block|{
name|REGOP
block|,
name|OFFSOP
block|,
name|POPOP
block|,
name|CNSTOP
block|,
name|RNDOP
block|}
name|optype0
enum|,
name|optype1
expr_stmt|;
name|rtx
name|latehalf
index|[
literal|2
index|]
decl_stmt|;
comment|/* First classify both operands.  */
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|optype0
operator|=
name|POPOP
expr_stmt|;
else|else
name|optype0
operator|=
name|RNDOP
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|optype1
operator|=
name|CNSTOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|optype1
operator|=
name|POPOP
expr_stmt|;
else|else
name|optype1
operator|=
name|RNDOP
expr_stmt|;
comment|/* Check for the cases that the operand constraints are not      supposed to allow to happen.  Abort if we get one,      because generating code for these cases is painful.  */
if|if
condition|(
name|optype0
operator|==
name|RNDOP
operator|||
name|optype1
operator|==
name|RNDOP
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Ok, we can do one word at a time.      Normally we do the low-numbered word first,      but if either operand is autodecrementing then we      do the high-numbered word first.       In either case, set up in LATEHALF the operands to use      for the high-numbered word and in some cases alter the      operands in OPERANDS to be suitable for the low-numbered word.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype0
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|latehalf
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|CNSTOP
condition|)
block|{
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|latehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
comment|/* If one or both operands autodecrementing,      do the two words, high-numbered first.  */
if|if
condition|(
name|optype0
operator|==
name|POPOP
operator|||
name|optype1
operator|==
name|POPOP
condition|)
block|{
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
comment|/* Not autodecrementing.  Do the two words, low-numbered first.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|latehalf
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|latehalf
index|[
literal|1
index|]
expr_stmt|;
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|check_reg
parameter_list|(
name|oper
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|oper
decl_stmt|;
name|int
name|reg
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|oper
operator|==
literal|0
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|oper
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
return|return
operator|(
name|REGNO
argument_list|(
name|oper
argument_list|)
operator|==
name|reg
operator|)
condition|?
literal|1
else|:
literal|0
return|;
case|case
name|MEM
case|:
return|return
name|check_reg
argument_list|(
name|XEXP
argument_list|(
name|oper
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
return|;
case|case
name|PLUS
case|:
case|case
name|MULT
case|:
return|return
name|check_reg
argument_list|(
name|XEXP
argument_list|(
name|oper
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
operator|||
name|check_reg
argument_list|(
name|XEXP
argument_list|(
name|oper
argument_list|,
literal|1
argument_list|)
argument_list|,
name|reg
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* PRINT_OPERAND_ADDRESS is defined to call this function,    which is easier to debug than putting all the code in    a macro definition in tm-ns32k.h .  */
end_comment

begin_comment
comment|/* Nonzero if we have printed a base register.    If zero, on some systems, it means `(sb)' must be printed.  */
end_comment

begin_decl_stmt
name|int
name|paren_base_reg_printed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|print_operand_address
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
specifier|register
name|FILE
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|rtx
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|rtx
name|reg1
decl_stmt|,
name|reg2
decl_stmt|,
name|breg
decl_stmt|,
name|ireg
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
specifier|static
name|char
name|scales
index|[]
init|=
block|{
literal|'b'
block|,
literal|'w'
block|,
literal|'d'
block|,
literal|0
block|,
literal|'q'
block|, }
decl_stmt|;
name|retry
label|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|MEM
case|:
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
if|if
condition|(
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"tos"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@0"
argument_list|)
expr_stmt|;
name|ireg
operator|=
name|addr
expr_stmt|;
goto|goto
name|print_index
goto|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|const0_rtx
expr_stmt|;
block|}
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"tos"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_DEC
case|:
case|case
name|POST_INC
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"tos"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@0"
argument_list|)
expr_stmt|;
name|ireg
operator|=
name|addr
expr_stmt|;
comment|/* [rX:Y] */
goto|goto
name|print_index
goto|;
break|break;
case|case
name|PLUS
case|:
name|reg1
operator|=
literal|0
expr_stmt|;
name|reg2
operator|=
literal|0
expr_stmt|;
name|ireg
operator|=
literal|0
expr_stmt|;
name|breg
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|PLUS
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* The case for memory is somewhat tricky:  to get 	 a MEM here, the only RTX formats that could 	 get here are either (modulo commutativity) 	   (PLUS (PLUS (REG *MEM)) CONST) -or- 	   (PLUS (PLUS (CONST REG/MULT)) *MEM) 	 We take advantage of that knowledge here.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|temp
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
condition|)
block|{
name|reg1
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|temp
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|temp
argument_list|)
operator|>=
name|FRAME_POINTER_REGNUM
condition|)
block|{
name|reg1
operator|=
name|addr
expr_stmt|;
name|addr
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|reg1
operator|=
name|temp
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|offset
argument_list|)
condition|)
name|offset
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|temp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|temp
argument_list|)
operator|>=
name|FRAME_POINTER_REGNUM
condition|)
block|{
name|reg1
operator|=
name|addr
expr_stmt|;
name|addr
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|reg1
operator|=
name|temp
expr_stmt|;
block|}
block|}
else|else
name|reg1
operator|=
name|temp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MULT
condition|)
block|{
if|if
condition|(
name|reg1
operator|==
literal|0
condition|)
name|reg1
operator|=
name|addr
expr_stmt|;
else|else
name|reg2
operator|=
name|addr
expr_stmt|;
name|addr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|addr
argument_list|)
operator|&&
name|reg1
condition|)
block|{
comment|/* OFFSET comes second, to prevent outputting 		 operands of the form INT+SYMBOL+INT. 		 The Genix assembler dies on them.  */
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
name|const0_rtx
condition|)
block|{
name|putc
argument_list|(
literal|'+'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|ireg
operator|=
name|reg1
expr_stmt|;
goto|goto
name|print_index
goto|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|offset
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SEQUENT_ADDRESS_BUG
name|putc
argument_list|(
literal|'('
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|paren_base_reg_printed
operator|=
literal|0
expr_stmt|;
name|output_address
argument_list|(
name|addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEQUENT_BASE_REGS
if|if
condition|(
operator|!
name|paren_base_reg_printed
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(sb)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|putc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SEQUENT_ADDRESS_BUG */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|reg1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[%s:b]"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putc
argument_list|(
literal|'('
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|paren_base_reg_printed
operator|=
literal|0
expr_stmt|;
name|output_address
argument_list|(
name|addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEQUENT_BASE_REGS
if|if
condition|(
operator|!
name|paren_base_reg_printed
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(sb)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|putc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SEQUENT_ADDRESS_BUG */
name|ireg
operator|=
name|reg1
expr_stmt|;
goto|goto
name|print_index
goto|;
block|}
else|else
name|addr
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|reg1
operator|&&
name|GET_CODE
argument_list|(
name|reg1
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|breg
operator|=
name|reg2
expr_stmt|;
name|ireg
operator|=
name|reg1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg2
operator|&&
name|GET_CODE
argument_list|(
name|reg2
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|breg
operator|=
name|reg1
expr_stmt|;
name|ireg
operator|=
name|reg2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg2
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|breg
operator|=
name|reg2
expr_stmt|;
name|ireg
operator|=
name|reg1
expr_stmt|;
block|}
else|else
block|{
name|breg
operator|=
name|reg1
expr_stmt|;
name|ireg
operator|=
name|reg2
expr_stmt|;
block|}
if|if
condition|(
name|ireg
operator|!=
literal|0
operator|&&
name|breg
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|int
name|scale
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ireg
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|scale
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>>
literal|1
expr_stmt|;
name|ireg
operator|=
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|scale
operator|=
literal|0
expr_stmt|;
name|output_asm_label
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[%s:%c]"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ireg
argument_list|)
index|]
argument_list|,
name|scales
index|[
name|scale
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ireg
operator|&&
name|breg
operator|&&
name|offset
operator|==
name|const0_rtx
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|breg
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ireg
operator|!=
literal|0
operator|&&
name|breg
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
name|putc
argument_list|(
literal|'@'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|breg
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|SEQUENT_ADDRESS_BUG
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|breg
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|paren_base_reg_printed
operator|=
operator|-
literal|1
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST
condition|)
block|{
if|if
condition|(
name|ireg
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[%s:b]"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|breg
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|breg
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|paren_base_reg_printed
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|print_index
label|:
if|if
condition|(
name|ireg
operator|!=
literal|0
condition|)
block|{
name|int
name|scale
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ireg
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|scale
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>>
literal|1
expr_stmt|;
name|ireg
operator|=
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|scale
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ireg
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[%s:%c]"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ireg
argument_list|)
index|]
argument_list|,
name|scales
index|[
name|scale
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* National 32032 shifting is so bad that we can get    better performance in many common cases by using other    techniques.  */
end_comment

begin_function
name|char
modifier|*
name|output_shift_insn
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|>
literal|0
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|<=
literal|3
condition|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|operands
index|[
literal|2
index|]
operator|==
name|const1_rtx
condition|)
return|return
literal|"addd %0,%0"
return|;
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
literal|2
condition|)
return|return
literal|"addd %0,%0\n\taddd %0,%0"
return|;
block|}
if|if
condition|(
name|operands
index|[
literal|2
index|]
operator|==
name|const1_rtx
condition|)
return|return
literal|"movd %1,%0\n\taddd %0,%0"
return|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_indexed_expr
argument_list|(
name|const0_rtx
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
literal|"addr %a1,%0"
return|;
block|}
if|if
condition|(
name|operands
index|[
literal|2
index|]
operator|==
name|const1_rtx
condition|)
return|return
literal|"movd %1,%0\n\taddd %0,%0"
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_indexed_expr
argument_list|(
name|const0_rtx
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
literal|"addr %a1,%0"
return|;
block|}
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
return|return
literal|"addd %0,%0"
return|;
block|}
else|else
return|return
literal|"ashd %2,%0"
return|;
return|return
literal|"ashd %2,%0"
return|;
block|}
end_function

end_unit

