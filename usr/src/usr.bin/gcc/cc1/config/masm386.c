begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Intel 80386 for masm assembler syntax.    Copyright (C) 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|aux_asm_out_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|implicit_declares
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|implicit_declares_max
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|implicit_declares_fillp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|add_to_implicit_list
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|tree
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|implicit_declares_max
operator|>
name|implicit_declares_fillp
condition|)
block|{
name|implicit_declares
index|[
name|implicit_declares_fillp
operator|++
index|]
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
name|tree
modifier|*
name|new
decl_stmt|;
name|int
name|i
decl_stmt|;
name|implicit_declares_max
operator|=
literal|2
operator|*
operator|(
name|implicit_declares_max
operator|+
literal|10
operator|)
expr_stmt|;
name|new
operator|=
operator|(
name|tree
operator|*
operator|)
operator|(
name|xmalloc
argument_list|(
name|implicit_declares_max
operator|*
sizeof|sizeof
argument_list|(
name|tree
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|implicit_declares_fillp
condition|;
name|i
operator|++
control|)
name|new
index|[
name|i
index|]
operator|=
name|implicit_declares
index|[
name|i
index|]
expr_stmt|;
name|implicit_declares
operator|=
name|new
expr_stmt|;
name|implicit_declares
index|[
name|implicit_declares_fillp
operator|++
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|write_implicit_declares
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|implicit_declares_fillp
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|implicit_declares
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|t
argument_list|)
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* avoid repeats */
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|aux_asm_out_file
argument_list|,
literal|"EXTRN "
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|aux_asm_out_file
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|aux_asm_out_file
argument_list|,
literal|":NEAR ; implicit\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function
name|void
name|asm_write_decls
parameter_list|(
name|decls
parameter_list|,
name|toplevel
parameter_list|)
name|int
name|toplevel
decl_stmt|;
name|tree
name|decls
decl_stmt|;
block|{
name|tree
name|tr
decl_stmt|,
name|t
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|,
modifier|*
name|size
decl_stmt|;
name|tr
operator|=
name|nreverse
argument_list|(
name|decls
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|tr
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|type
operator|=
literal|0
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
operator|!
name|toplevel
operator|||
name|TREE_ASM_WRITTEN
argument_list|(
name|t
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|toplevel
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|add_to_implicit_list
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|)
condition|)
name|type
operator|=
literal|"PUBLIC "
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_EXTERNAL
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|type
operator|=
literal|"EXTRN "
expr_stmt|;
name|size
operator|=
literal|"NEAR"
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
condition|)
name|type
operator|=
literal|"PUBLIC "
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_EXTERNAL
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|type
operator|=
literal|"EXTRN "
expr_stmt|;
switch|switch
condition|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|size
operator|=
literal|"BYTE"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|size
operator|=
literal|"WORD"
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|size
operator|=
literal|"DWORD"
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|size
operator|=
literal|"QWORD"
expr_stmt|;
break|break;
default|default:
name|size
operator|=
literal|"BYTE"
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|type
condition|)
block|{
name|fputs
argument_list|(
name|type
argument_list|,
name|aux_asm_out_file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|aux_asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|aux_asm_out_file
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
condition|)
name|fprintf
argument_list|(
name|aux_asm_out_file
argument_list|,
literal|":%s"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|aux_asm_out_file
argument_list|,
literal|"\t\t; %d,%d,%d,%d,%d"
argument_list|,
name|TREE_EXTERNAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
argument_list|,
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|aux_asm_out_file
argument_list|)
expr_stmt|;
block|}
block|}
name|nreverse
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  If we are using a library which does not follow the underscore convention, (which is absolutely necessary for masm, since it has hundreds of reserved  words), we do not put an underscore in front of the following names. It was produced by having a foo /tmp/foo.c which included standard library h   files, and then using   cat /tmp/foo.m | sed -e 's/EXTRN  /"/g' -e 's/:[a-zA-Z]+/",/g'  | sort> masm-lib.h It will be nice when we have our own libraries!  */
end_comment

begin_comment
comment|/* #include<string.h> */
end_comment

begin_decl_stmt
name|char
modifier|*
name|no_prefix_names
index|[]
init|=
block|{
include|#
directive|include
file|"masm-lib.h"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|node_compare
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|char
modifier|*
modifier|*
name|a
decl_stmt|,
decl|*
modifier|*
name|b
decl_stmt|;
end_function

begin_block
block|{
return|return
name|strcmp
argument_list|(
operator|*
name|a
argument_list|,
operator|*
name|b
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  Masm needs extrn references for ALL symbols written,     unless they are defined in this file.  However unnecessary extrn     references to functions, cause their code to be linked in.     To avoid this we mark function declarations whose names have been     written.     Make local varialbes     */
end_comment

begin_function
name|void
name|mark_name_used
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|tree
name|t
init|=
name|get_identifier
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_ASM_WRITTEN
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|number_no_prefix_names
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|use_prefix
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_macro
name|asm_output_labelref
argument_list|(
argument|file
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|ans
decl_stmt|;
name|char
modifier|*
name|test
index|[
literal|1
index|]
decl_stmt|;
name|mark_name_used
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ans
operator|=
literal|0
expr_stmt|;
name|test
index|[
literal|0
index|]
operator|=
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|number_no_prefix_names
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|*
operator|(
name|no_prefix_names
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|number_no_prefix_names
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|use_prefix
condition|)
name|ans
operator|=
operator|(
name|char
operator|*
operator|)
name|bsearch
argument_list|(
name|test
argument_list|,
name|no_prefix_names
argument_list|,
name|number_no_prefix_names
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|node_compare
argument_list|)
expr_stmt|;
if|if
condition|(
name|ans
operator|||
operator|!
name|use_prefix
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"_%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|asm_library_declare
parameter_list|(
name|fun
parameter_list|)
name|rtx
name|fun
decl_stmt|;
block|{
name|tree
name|iden
decl_stmt|;
name|iden
operator|=
name|get_identifier
argument_list|(
name|XSTR
argument_list|(
name|fun
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|iden
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|aux_asm_out_file
argument_list|,
literal|"EXTRN "
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|aux_asm_out_file
argument_list|,
name|XSTR
argument_list|(
name|fun
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|aux_asm_out_file
argument_list|,
literal|":NEAR ; library\n"
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|iden
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* list of implicit declares identifier_node uid's    We must track implicit declares, since we cannot call them extern,    until we are sure they will not be static defined in this file.  */
end_comment

end_unit

