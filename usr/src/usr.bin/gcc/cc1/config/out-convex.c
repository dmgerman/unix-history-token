begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Convex.    Copyright (C) 1989, 1990 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Boolean to keep track of whether the current section is .text or not.    Used by .align handler in tm-convex.h. */
end_comment

begin_decl_stmt
name|int
name|current_section_is_text
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  set_cmp (left_rtx, right_rtx, [bhwlsd])  *  gen_cmp (label_rtx, cmpop, [tf])  *  *  set_cmp saves the operands of a "cmp" insn,  *    along with the type character to be used in the compare instruction.  *  *  gen_cmp finds out what comparison is to be performed and  *    outputs the necessary instructions, eg,  *    "eq.w a1,a2 ! jbra.t L5"  *    for (cmpsi a1 a2) (beq L5)  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|xop0
decl_stmt|,
name|xop1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|typech
decl_stmt|,
name|regch
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|set_cmp
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|,
name|typechr
parameter_list|)
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|char
name|typechr
decl_stmt|;
block|{
name|xop0
operator|=
name|op0
expr_stmt|;
name|xop1
operator|=
name|op1
expr_stmt|;
name|typech
operator|=
name|typechr
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
name|regch
operator|=
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|?
literal|'a'
else|:
literal|'s'
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
condition|)
name|regch
operator|=
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|op1
argument_list|)
argument_list|)
condition|?
literal|'a'
else|:
literal|'s'
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|gen_cmp
parameter_list|(
name|label
parameter_list|,
name|cmpop
parameter_list|,
name|tf
parameter_list|)
name|rtx
name|label
decl_stmt|;
name|char
modifier|*
name|cmpop
decl_stmt|;
name|char
name|tf
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|char
name|revop
index|[
literal|4
index|]
decl_stmt|;
name|rtx
name|ops
index|[
literal|3
index|]
decl_stmt|;
name|ops
index|[
literal|2
index|]
operator|=
name|label
expr_stmt|;
comment|/* constant must be first; swap operands if necessary      if lt, le, ltu, leu are swapped, change to le, lt, leu, ltu      and reverse the sense of the jump */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|xop1
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|xop1
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|ops
index|[
literal|0
index|]
operator|=
name|xop1
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|xop0
expr_stmt|;
if|if
condition|(
name|cmpop
index|[
literal|0
index|]
operator|==
literal|'l'
condition|)
block|{
name|bcopy
argument_list|(
name|cmpop
argument_list|,
name|revop
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|revop
index|[
literal|1
index|]
operator|^=
literal|'e'
operator|^
literal|'t'
expr_stmt|;
name|tf
operator|^=
literal|'t'
operator|^
literal|'f'
expr_stmt|;
name|cmpop
operator|=
name|revop
expr_stmt|;
block|}
block|}
else|else
block|{
name|ops
index|[
literal|0
index|]
operator|=
name|xop0
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|xop1
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s.%c %%0,%%1\n\tjbr%c.%c %%l2"
argument_list|,
name|cmpop
argument_list|,
name|typech
argument_list|,
name|regch
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|buf
argument_list|,
name|ops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Routines to look at CONST_DOUBLEs without sinful knowledge of  * what the inside of u.d looks like  *  * const_double_high_int  -- high word of machine double or long long  * const_double_low_int   -- low word  * const_double_float_int -- the word of a machine float  */
end_comment

begin_function_decl
specifier|static
name|double
name|frexp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|float_extract
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|const_double_high_int
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DImode
condition|)
return|return
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
return|;
else|else
block|{
name|int
name|sign
decl_stmt|,
name|expd
decl_stmt|,
name|expf
decl_stmt|;
name|unsigned
name|fracdh
decl_stmt|,
name|fracdl
decl_stmt|,
name|fracf
decl_stmt|;
name|float_extract
argument_list|(
name|x
argument_list|,
operator|&
name|sign
argument_list|,
operator|&
name|expd
argument_list|,
operator|&
name|fracdh
argument_list|,
operator|&
name|fracdl
argument_list|,
operator|&
name|expf
argument_list|,
operator|&
name|fracf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fracdh
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|expd
operator|<
operator|-
literal|01777
operator|||
name|expd
operator|>
literal|01777
condition|)
return|return
literal|1
operator|<<
literal|31
return|;
return|return
name|sign
operator|<<
literal|31
operator||
operator|(
name|expd
operator|+
literal|02000
operator|)
operator|<<
literal|20
operator||
name|fracdh
operator|-
operator|(
literal|1
operator|<<
literal|20
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|const_double_low_int
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DImode
condition|)
return|return
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
return|;
else|else
block|{
name|int
name|sign
decl_stmt|,
name|expd
decl_stmt|,
name|expf
decl_stmt|;
name|unsigned
name|fracdh
decl_stmt|,
name|fracdl
decl_stmt|,
name|fracf
decl_stmt|;
name|float_extract
argument_list|(
name|x
argument_list|,
operator|&
name|sign
argument_list|,
operator|&
name|expd
argument_list|,
operator|&
name|fracdh
argument_list|,
operator|&
name|fracdl
argument_list|,
operator|&
name|expf
argument_list|,
operator|&
name|fracf
argument_list|)
expr_stmt|;
return|return
name|fracdl
return|;
block|}
block|}
end_function

begin_function
name|int
name|const_double_float_int
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|sign
decl_stmt|,
name|expd
decl_stmt|,
name|expf
decl_stmt|;
name|unsigned
name|fracdh
decl_stmt|,
name|fracdl
decl_stmt|,
name|fracf
decl_stmt|;
name|float_extract
argument_list|(
name|x
argument_list|,
operator|&
name|sign
argument_list|,
operator|&
name|expd
argument_list|,
operator|&
name|fracdh
argument_list|,
operator|&
name|fracdl
argument_list|,
operator|&
name|expf
argument_list|,
operator|&
name|fracf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fracf
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|expf
operator|<
operator|-
literal|0177
operator|||
name|expf
operator|>
literal|0177
condition|)
return|return
literal|1
operator|<<
literal|31
return|;
return|return
name|sign
operator|<<
literal|31
operator||
operator|(
name|expf
operator|+
literal|0200
operator|)
operator|<<
literal|20
operator||
name|fracf
operator|-
operator|(
literal|1
operator|<<
literal|23
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|T21
value|((double) (1<< 21))
end_define

begin_define
define|#
directive|define
name|T24
value|((double) (1<< 24))
end_define

begin_define
define|#
directive|define
name|T53
value|((double) (1<< 27) * (double) (1<< 26))
end_define

begin_function
specifier|static
name|void
name|float_extract
parameter_list|(
name|x
parameter_list|,
name|sign
parameter_list|,
name|expd
parameter_list|,
name|fracdh
parameter_list|,
name|fracdl
parameter_list|,
name|expf
parameter_list|,
name|fracf
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
modifier|*
name|sign
decl_stmt|,
decl|*
name|expd
decl_stmt|,
modifier|*
name|expf
decl_stmt|;
end_function

begin_decl_stmt
name|unsigned
modifier|*
name|fracdh
decl_stmt|,
modifier|*
name|fracdl
decl_stmt|,
modifier|*
name|fracf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|exp
decl_stmt|,
name|round
decl_stmt|;
name|double
name|d
decl_stmt|,
name|r
decl_stmt|;
name|union
name|real_extract
name|u
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
comment|/* Get sign and exponent.  */
if|if
condition|(
operator|*
name|sign
operator|=
name|u
operator|.
name|d
operator|<
literal|0
condition|)
name|u
operator|.
name|d
operator|=
operator|-
name|u
operator|.
name|d
expr_stmt|;
name|d
operator|=
name|frexp
argument_list|(
name|u
operator|.
name|d
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
comment|/* Get 21 fraction bits for high word and 32 for low word.  */
for|for
control|(
name|round
operator|=
literal|0
init|;
condition|;
name|round
operator|=
literal|1
control|)
block|{
name|r
operator|=
name|frexp
argument_list|(
name|round
condition|?
name|d
operator|+
literal|1.0
operator|/
name|T53
else|:
name|d
argument_list|,
name|expd
argument_list|)
expr_stmt|;
operator|*
name|expd
operator|+=
name|exp
expr_stmt|;
operator|*
name|fracdh
operator|=
name|r
operator|*
name|T21
expr_stmt|;
operator|*
name|fracdl
operator|=
operator|(
name|r
operator|-
operator|*
name|fracdh
operator|/
name|T21
operator|)
operator|*
name|T53
expr_stmt|;
if|if
condition|(
name|round
operator|||
operator|(
operator|(
name|r
operator|-
operator|*
name|fracdh
operator|/
name|T21
operator|)
operator|-
operator|*
name|fracdl
operator|/
name|T53
operator|)
operator|<
literal|0.5
operator|*
name|T53
condition|)
break|break;
block|}
comment|/* Get 24 bits for float fraction. */
for|for
control|(
name|round
operator|=
literal|0
init|;
condition|;
name|round
operator|=
literal|1
control|)
block|{
name|r
operator|=
name|frexp
argument_list|(
name|round
condition|?
name|d
operator|+
literal|1.0
operator|/
name|T24
else|:
name|d
argument_list|,
name|expf
argument_list|)
expr_stmt|;
operator|*
name|expf
operator|+=
name|exp
expr_stmt|;
operator|*
name|fracf
operator|=
name|r
operator|*
name|T24
expr_stmt|;
if|if
condition|(
name|round
operator|||
operator|(
name|r
operator|-
operator|*
name|fracf
operator|/
name|T24
operator|)
operator|<
literal|0.5
operator|*
name|T24
condition|)
break|break;
block|}
block|}
end_block

begin_function
specifier|static
name|double
name|frexp
parameter_list|(
name|d
parameter_list|,
name|exp
parameter_list|)
name|double
name|d
decl_stmt|;
name|int
modifier|*
name|exp
decl_stmt|;
block|{
name|int
name|e
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|d
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|d
operator|<
literal|0.5
condition|)
name|d
operator|*=
literal|2.0
operator|,
name|e
operator|--
expr_stmt|;
while|while
condition|(
name|d
operator|>=
literal|1.0
condition|)
name|d
operator|/=
literal|2.0
operator|,
name|e
operator|++
expr_stmt|;
block|}
operator|*
name|exp
operator|=
name|e
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

end_unit

