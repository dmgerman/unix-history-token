begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Data flow analysis for GNU compiler.    Copyright (C) 1987, 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file contains the data flow analysis pass of the compiler.    It computes data flow information    which tells combine_instructions which insns to consider combining    and controls register allocation.     Additional data flow information that is too bulky to record    is generated during the analysis, and is used at that time to    create autoincrement and autodecrement addressing.     The first step is dividing the function into basic blocks.    find_basic_blocks does this.  Then life_analysis determines    where each register is live and where it is dead.     ** find_basic_blocks **     find_basic_blocks divides the current function's rtl    into basic blocks.  It records the beginnings and ends of the    basic blocks in the vectors basic_block_head and basic_block_end,    and the number of blocks in n_basic_blocks.     find_basic_blocks also finds any unreachable loops    and deletes them.     ** life_analysis **     life_analysis is called immediately after find_basic_blocks.    It uses the basic block information to determine where each    hard or pseudo register is live.     ** live-register info **     The information about where each register is live is in two parts:    the REG_NOTES of insns, and the vector basic_block_live_at_start.     basic_block_live_at_start has an element for each basic block,    and the element is a bit-vector with a bit for each hard or pseudo    register.  The bit is 1 if the register is live at the beginning    of the basic block.     To each insn's REG_NOTES is added an element for each register    that is live before the insn or set by the insn, but is dead    after the insn.     To determine which registers are live after any insn, one can    start from the beginning of the basic block and scan insns, noting    which registers are set by each insn and which die there.     ** Other actions of life_analysis **     life_analysis sets up the LOG_LINKS fields of insns because the    information needed to do so is readily available.     life_analysis deletes insns whose only effect is to store a value    that is never used.     life_analysis notices cases where a reference to a register as    a memory address can be combined with a preceding or following    incrementation or decrementation of the register.  The separate    instruction to increment or decrement is deleted and the address    is changed to a POST_INC or similar rtx.     Each time an incrementing or decrementing address is created,    a REG_INC element is added to the insn's REG_NOTES list.     life_analysis fills in certain vectors containing information about    register usage: reg_n_refs, reg_n_deaths, reg_n_sets,    reg_live_length, reg_n_calls_crosses and reg_basic_block.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|extern
name|int
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Get the basic block number of an insn.    This info should not be expected to remain available    after the end of life_analysis.  */
end_comment

begin_define
define|#
directive|define
name|BLOCK_NUM
parameter_list|(
name|INSN
parameter_list|)
value|uid_block_number[INSN_UID (INSN)]
end_define

begin_comment
comment|/* This is where the BLOCK_NUM values are really stored.    This is set up by find_basic_blocks and used there and in life_analysis,    and then freed.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|uid_block_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INSN_VOLATILE (insn) is 1 if the insn refers to anything volatile.  */
end_comment

begin_define
define|#
directive|define
name|INSN_VOLATILE
parameter_list|(
name|INSN
parameter_list|)
value|uid_volatile[INSN_UID (INSN)]
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|uid_volatile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of basic blocks in the current function.  */
end_comment

begin_decl_stmt
name|int
name|n_basic_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum register number used in this function, plus one.  */
end_comment

begin_decl_stmt
name|int
name|max_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by n, gives number of basic block that  (REG n) is used in.    If the value is REG_BLOCK_GLOBAL (-2),    it means (REG n) is used in more than one basic block.    REG_BLOCK_UNKNOWN (-1) means it hasn't been seen yet so we don't know.    This information remains valid for the rest of the compilation    of the current function; it is used to control register allocation.  */
end_comment

begin_decl_stmt
name|short
modifier|*
name|reg_basic_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by n, gives number of times (REG n) is used or set, each    weighted by its loop-depth.    This information remains valid for the rest of the compilation    of the current function; it is used to control register allocation.  */
end_comment

begin_decl_stmt
name|short
modifier|*
name|reg_n_refs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by n, gives number of times (REG n) is set.    This information remains valid for the rest of the compilation    of the current function; it is used to control register allocation.  */
end_comment

begin_decl_stmt
name|short
modifier|*
name|reg_n_sets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by N, gives number of places register N dies.    This information remains valid for the rest of the compilation    of the current function; it is used to control register allocation.  */
end_comment

begin_decl_stmt
name|short
modifier|*
name|reg_n_deaths
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by N, gives 1 if that reg is live across any CALL_INSNs.    This information remains valid for the rest of the compilation    of the current function; it is used to control register allocation.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|reg_n_calls_crossed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by N, gives the uid of the first insn that mentions reg N,    provided that reg is local to one basic block.    The value here is undefined otherwise.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_first_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of instructions at which (REG n) is live.    The larger this is, the less priority (REG n) gets for    allocation in a real register.    This information remains valid for the rest of the compilation    of the current function; it is used to control register allocation.     local-alloc.c may alter this number to change the priority.     Negative values are special.    -1 is used to mark a pseudo reg which has a constant or memory equivalent    and is used infrequently enough that it should not get a hard register.    -2 is used to mark a pseudo reg for a parameter, when a frame pointer    is not required.  global-alloc.c makes an allocno for this but does    not try to assign a hard register to it.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|reg_live_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the next insn that uses (hard or pseudo) register number N    within the current basic block; or zero, if there is no such insn.    This is valid only during the final backward scan in propagate_block.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_next_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of a regset for the current function,    in (1) bytes and (2) elements.  */
end_comment

begin_decl_stmt
name|int
name|regset_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|regset_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is first insn in basic block N.    This info lasts until we finish compiling the function.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|basic_block_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is last insn in basic block N.    This info lasts until we finish compiling the function.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|basic_block_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is a regset describing the registers live    at the start of basic block N.    This info lasts until we finish compiling the function.  */
end_comment

begin_decl_stmt
name|regset
modifier|*
name|basic_block_live_at_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Regset of regs live when calls to `setjmp'-like functions happen.  */
end_comment

begin_decl_stmt
name|regset
name|regs_live_at_setjmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is nonzero if control can drop into basic block N    from the preceding basic block.  Freed after life_analysis.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|basic_block_drops_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is depth within loops of basic block number N.    Freed after life_analysis.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|basic_block_loop_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N nonzero if basic block N can actually be reached.    Vector exists only during find_basic_blocks.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|block_live_static
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Depth within loops of basic block being scanned for lifetime analysis,    plus one.  This is the weight attached to references to registers.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_depth
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Define AUTO_INC_DEC if machine has any kind of incrementing    or decrementing addressing.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PRE_DECREMENT
end_ifdef

begin_define
define|#
directive|define
name|AUTO_INC_DEC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PRE_INCREMENT
end_ifdef

begin_define
define|#
directive|define
name|AUTO_INC_DEC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_POST_DECREMENT
end_ifdef

begin_define
define|#
directive|define
name|AUTO_INC_DEC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_POST_INCREMENT
end_ifdef

begin_define
define|#
directive|define
name|AUTO_INC_DEC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Forward declarations */
end_comment

begin_function_decl
specifier|static
name|void
name|find_basic_blocks
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|life_analysis
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_label_ref
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|allocate_for_life_analysis
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Used also in stupid_life_analysis */
end_comment

begin_function_decl
specifier|static
name|void
name|init_regset_vector
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|propagate_block
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_set_regs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_used_regs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|insn_dead_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|libcall_dead_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|try_pre_increment
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|try_pre_increment_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|find_use_as_address
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dump_flow_info
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Find basic blocks of the current function and perform data flow analysis.    F is the first insn of the function and NREGS the number of register numbers    in use.  */
end_comment

begin_function
name|void
name|flow_analysis
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|,
name|file
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|max_uid
init|=
literal|0
decl_stmt|;
comment|/* Count the basic blocks.  Also find maximum insn uid value used.  */
block|{
specifier|register
name|RTX_CODE
name|prev_code
init|=
name|JUMP_INSN
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|max_uid
condition|)
name|max_uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
operator|||
operator|(
name|prev_code
operator|!=
name|INSN
operator|&&
name|prev_code
operator|!=
name|CALL_INSN
operator|&&
name|prev_code
operator|!=
name|CODE_LABEL
operator|&&
operator|(
name|code
operator|==
name|INSN
operator|||
name|code
operator|==
name|CALL_INSN
operator|||
name|code
operator|==
name|JUMP_INSN
operator|)
operator|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
name|prev_code
operator|=
name|code
expr_stmt|;
block|}
block|}
comment|/* Allocate some tables that last till end of compiling this function      and some needed only in find_basic_blocks and life_analysis.  */
name|n_basic_blocks
operator|=
name|i
expr_stmt|;
name|basic_block_head
operator|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|basic_block_end
operator|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|basic_block_drops_in
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|basic_block_loop_depth
operator|=
operator|(
name|short
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|uid_block_number
operator|=
operator|(
name|short
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_uid
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|uid_volatile
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|uid_volatile
argument_list|,
name|max_uid
operator|+
literal|1
argument_list|)
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|life_analysis
argument_list|(
name|f
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|dump_flow_info
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|basic_block_drops_in
operator|=
literal|0
expr_stmt|;
name|uid_block_number
operator|=
literal|0
expr_stmt|;
name|basic_block_loop_depth
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all basic blocks of the function whose first insn is F.    Store the correct data in the tables that describe the basic blocks,    set up the chains of references for each CODE_LABEL, and    delete any entire basic blocks that cannot be reached.  */
end_comment

begin_function
specifier|static
name|void
name|find_basic_blocks
parameter_list|(
name|f
parameter_list|)
name|rtx
name|f
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Initialize the ref chain of each label to 0.  */
comment|/* Record where all the blocks start and end and their depth in loops.  */
comment|/* For each insn, record the block it is in.  */
block|{
specifier|register
name|RTX_CODE
name|prev_code
init|=
name|JUMP_INSN
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
name|int
name|depth
init|=
literal|1
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
operator|-
literal|1
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|depth
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
operator|||
operator|(
name|prev_code
operator|!=
name|INSN
operator|&&
name|prev_code
operator|!=
name|CALL_INSN
operator|&&
name|prev_code
operator|!=
name|CODE_LABEL
operator|&&
operator|(
name|code
operator|==
name|INSN
operator|||
name|code
operator|==
name|CALL_INSN
operator|||
name|code
operator|==
name|JUMP_INSN
operator|)
operator|)
condition|)
block|{
name|basic_block_head
index|[
operator|++
name|i
index|]
operator|=
name|insn
expr_stmt|;
name|basic_block_end
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
name|basic_block_loop_depth
index|[
name|i
index|]
operator|=
name|depth
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
condition|)
name|LABEL_REFS
argument_list|(
name|insn
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|INSN
operator|||
name|code
operator|==
name|CALL_INSN
operator|||
name|code
operator|==
name|JUMP_INSN
condition|)
name|basic_block_end
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
name|prev_code
operator|=
name|code
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
literal|1
operator|!=
name|n_basic_blocks
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Record which basic blocks control can drop in to.  */
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|rtx
name|insn
init|=
name|PREV_INSN
argument_list|(
name|basic_block_head
index|[
name|i
index|]
argument_list|)
decl_stmt|;
comment|/* TEMP1 is used to avoid a bug in Sequent's compiler.  */
specifier|register
name|int
name|temp1
decl_stmt|;
while|while
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
expr_stmt|;
name|basic_block_drops_in
index|[
name|i
index|]
operator|=
name|temp1
expr_stmt|;
block|}
block|}
comment|/* Now find which basic blocks can actually be reached      and put all jump insns' LABEL_REFS onto the ref-chains      of their target labels.  */
if|if
condition|(
name|n_basic_blocks
operator|>
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|block_live
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|block_marked
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
argument_list|)
decl_stmt|;
name|int
name|something_marked
init|=
literal|1
decl_stmt|;
comment|/* Initialize with just block 0 reachable and no blocks marked.  */
name|bzero
argument_list|(
name|block_live
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|block_marked
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|block_live
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|block_live_static
operator|=
name|block_live
expr_stmt|;
comment|/* Pass over all blocks, marking each block that is reachable 	 and has not yet been marked. 	 Keep doing this until, in one pass, no blocks have been marked. 	 Then blocks_live and blocks_marked are identical and correct. 	 In addition, all jumps actually reachable have been marked.  */
while|while
condition|(
name|something_marked
condition|)
block|{
name|something_marked
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|block_live
index|[
name|i
index|]
operator|&&
operator|!
name|block_marked
index|[
name|i
index|]
condition|)
block|{
name|block_marked
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|something_marked
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|n_basic_blocks
operator|&&
name|basic_block_drops_in
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|block_live
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|basic_block_end
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|mark_label_ref
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now delete the code for any basic blocks that can't be reached. 	 They can occur because jump_optimize does not recognize 	 unreachable loops as unreachable.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|block_live
index|[
name|i
index|]
condition|)
block|{
name|insn
operator|=
name|basic_block_head
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|basic_block_end
index|[
name|i
index|]
condition|)
block|{
comment|/* BARRIERs are between basic blocks, not part of one. 		       Delete a BARRIER if the preceding jump is deleted. 		       We cannot alter a BARRIER into a NOTE 		       because it is too short; but we can really delete 		       it because it is not part of a basic block.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|BARRIER
condition|)
name|delete_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Each time we delete some basic blocks, 	       see if there is a jump around them that is 	       being turned into a no-op.  If so, delete it.  */
if|if
condition|(
name|block_live
index|[
name|i
operator|-
literal|1
index|]
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|n_basic_blocks
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|block_live
index|[
name|j
index|]
condition|)
block|{
name|rtx
name|label
decl_stmt|;
name|insn
operator|=
name|basic_block_end
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
comment|/* An unconditional jump is the only possibility 			     we must check for, since a conditional one 			     would make these blocks live.  */
operator|&&
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|label
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|,
literal|1
operator|)
operator|&&
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|!=
literal|0
operator|&&
name|BLOCK_NUM
argument_list|(
name|label
argument_list|)
operator|==
name|j
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|BARRIER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|delete_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check expression X for label references;    if one is found, add INSN to the label's chain of references.     CHECKDUP means check for and avoid creating duplicate references    from the same insn.  Such duplicates do no serious harm but    can slow life analysis.  CHECKDUP is set only when duplicates    are likely.  */
end_comment

begin_function
specifier|static
name|void
name|mark_label_ref
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|checkdup
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
name|int
name|checkdup
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
block|{
specifier|register
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|y
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the label was never emitted, this insn is junk, 	 but avoid a crash trying to refer to BLOCK_NUM (label). 	 This can happen as a result of a syntax error 	 and a diagnostic has already been printed.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|CONTAINING_INSN
argument_list|(
name|x
argument_list|)
operator|=
name|insn
expr_stmt|;
comment|/* if CHECKDUP is set, check for duplicate ref from same insn 	 and don't insert.  */
if|if
condition|(
name|checkdup
condition|)
for|for
control|(
name|y
operator|=
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
init|;
name|y
operator|!=
name|label
condition|;
name|y
operator|=
name|LABEL_NEXTREF
argument_list|(
name|y
argument_list|)
control|)
if|if
condition|(
name|CONTAINING_INSN
argument_list|(
name|y
argument_list|)
operator|==
name|insn
condition|)
return|return;
name|LABEL_NEXTREF
argument_list|(
name|x
argument_list|)
operator|=
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
operator|=
name|x
expr_stmt|;
name|block_live_static
index|[
name|BLOCK_NUM
argument_list|(
name|label
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|mark_label_ref
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_label_ref
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine the which registers are live at the start of each    basic block of the function whose first insn is F.    NREGS is the number of registers used in F.    We allocate the vector basic_block_live_at_start    and the regsets that it points to, and fill them with the data.    regset_size and regset_bytes are also set here.  */
end_comment

begin_function
specifier|static
name|void
name|life_analysis
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
specifier|register
name|regset
name|tem
decl_stmt|;
name|int
name|first_pass
decl_stmt|;
name|int
name|changed
decl_stmt|;
comment|/* For each basic block, a bitmask of regs      live on exit from the block.  */
name|regset
modifier|*
name|basic_block_live_at_end
decl_stmt|;
comment|/* For each basic block, a bitmask of regs      live on entry to a successor-block of this block.      If this does not match basic_block_live_at_end,      that must be updated, and the block must be rescanned.  */
name|regset
modifier|*
name|basic_block_new_live_at_end
decl_stmt|;
comment|/* For each basic block, a bitmask of regs      whose liveness at the end of the basic block      can make a difference in which regs are live on entry to the block.      These are the regs that are set within the basic block,      possibly excluding those that are used after they are set.  */
name|regset
modifier|*
name|basic_block_significant
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|obstack
name|flow_obstack
decl_stmt|;
name|obstack_init
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|max_regno
operator|=
name|nregs
expr_stmt|;
name|bzero
argument_list|(
name|regs_ever_live
argument_list|,
sizeof|sizeof
name|regs_ever_live
argument_list|)
expr_stmt|;
comment|/* Allocate and zero out many data structures      that will record the data from lifetime analysis.  */
name|allocate_for_life_analysis
argument_list|()
expr_stmt|;
name|reg_next_use
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_next_use
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up several regset-vectors used internally within this function.      Their meanings are documented above, with their declarations.  */
name|basic_block_live_at_end
operator|=
operator|(
name|regset
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|regset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't use alloca since that leads to a crash rather than an error message      if there isn't enough space.      Don't use oballoc since we may need to allocate other things during      this function on the temporary obstack.  */
name|tem
operator|=
operator|(
name|regset
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|flow_obstack
argument_list|,
name|n_basic_blocks
operator|*
name|regset_bytes
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|tem
argument_list|,
name|n_basic_blocks
operator|*
name|regset_bytes
argument_list|)
expr_stmt|;
name|init_regset_vector
argument_list|(
name|basic_block_live_at_end
argument_list|,
name|tem
argument_list|,
name|n_basic_blocks
argument_list|,
name|regset_bytes
argument_list|)
expr_stmt|;
name|basic_block_new_live_at_end
operator|=
operator|(
name|regset
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|regset
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
operator|(
name|regset
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|flow_obstack
argument_list|,
name|n_basic_blocks
operator|*
name|regset_bytes
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|tem
argument_list|,
name|n_basic_blocks
operator|*
name|regset_bytes
argument_list|)
expr_stmt|;
name|init_regset_vector
argument_list|(
name|basic_block_new_live_at_end
argument_list|,
name|tem
argument_list|,
name|n_basic_blocks
argument_list|,
name|regset_bytes
argument_list|)
expr_stmt|;
name|basic_block_significant
operator|=
operator|(
name|regset
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|regset
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
operator|(
name|regset
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|flow_obstack
argument_list|,
name|n_basic_blocks
operator|*
name|regset_bytes
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|tem
argument_list|,
name|n_basic_blocks
operator|*
name|regset_bytes
argument_list|)
expr_stmt|;
name|init_regset_vector
argument_list|(
name|basic_block_significant
argument_list|,
name|tem
argument_list|,
name|n_basic_blocks
argument_list|,
name|regset_bytes
argument_list|)
expr_stmt|;
comment|/* Record which insns refer to any volatile memory      or for any reason can't be deleted just because they are dead stores.      Also, delete any insns that copy a register to itself. */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|code1
operator|==
name|CALL_INSN
condition|)
name|INSN_VOLATILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|INSN
operator|||
name|code1
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
condition|)
name|INSN_VOLATILE
argument_list|(
name|insn
argument_list|)
operator|=
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A SET that makes space on the stack cannot be dead. 	     (Such SETs occur only for allocating variable-size data, 	     so they will always have a PLUS or MINUS according to the 	     direction of stack growth.) 	     Even if this function never uses this stack pointer value, 	     signal handlers do!  */
elseif|else
if|if
condition|(
name|code1
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|stack_pointer_rtx
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MINUS
else|#
directive|else
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PLUS
endif|#
directive|endif
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
name|INSN_VOLATILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n_basic_blocks
operator|>
literal|0
condition|)
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
if|if
condition|(
operator|!
operator|(
name|EXIT_IGNORE_STACK
operator|)
operator|||
operator|!
name|frame_pointer_needed
condition|)
endif|#
directive|endif
block|{
comment|/* If exiting needs the right stack value, 	   consider the stack pointer live at the end of the function.  */
name|basic_block_live_at_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
index|[
name|STACK_POINTER_REGNUM
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
literal|1
operator|<<
operator|(
name|STACK_POINTER_REGNUM
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
name|basic_block_new_live_at_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
index|[
name|STACK_POINTER_REGNUM
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
literal|1
operator|<<
operator|(
name|STACK_POINTER_REGNUM
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
block|}
comment|/* Propagate life info through the basic blocks      around the graph of basic blocks.       This is a relaxation process: each time a new register      is live at the end of the basic block, we must scan the block      to determine which registers are, as a consequence, live at the beginning      of that block.  These registers must then be marked live at the ends      of all the blocks that can transfer control to that block.      The process continues until it reaches a fixed point.  */
name|first_pass
operator|=
literal|1
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|consider
init|=
name|first_pass
decl_stmt|;
name|int
name|must_rescan
init|=
name|first_pass
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
comment|/* Set CONSIDER if this block needs thinking about at all 	     (that is, if the regs live now at the end of it 	     are not the same as were live at the end of it when 	     we last thought about it). 	     Set must_rescan if it needs to be thought about 	     instruction by instruction (that is, if any additional 	     reg that is live at the end now but was not live there before 	     is one of the significant regs of this basic block).  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|regset_size
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|int
name|x
init|=
name|basic_block_new_live_at_end
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
operator|~
name|basic_block_live_at_end
index|[
name|i
index|]
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|x
condition|)
name|consider
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|basic_block_significant
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
block|{
name|must_rescan
operator|=
literal|1
expr_stmt|;
name|consider
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|consider
condition|)
continue|continue;
comment|/* The live_at_start of this block may be changing, 	     so another pass will be required after this one.  */
name|changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|must_rescan
condition|)
block|{
comment|/* No complete rescan needed; 		 just record those variables newly known live at end 		 as live at start as well.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|regset_size
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|int
name|x
init|=
name|basic_block_new_live_at_end
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
operator|~
name|basic_block_live_at_end
index|[
name|i
index|]
index|[
name|j
index|]
decl_stmt|;
name|basic_block_live_at_start
index|[
name|i
index|]
index|[
name|j
index|]
operator||=
name|x
expr_stmt|;
name|basic_block_live_at_end
index|[
name|i
index|]
index|[
name|j
index|]
operator||=
name|x
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Update the basic_block_live_at_start 		 by propagation backwards through the block.  */
name|bcopy
argument_list|(
name|basic_block_new_live_at_end
index|[
name|i
index|]
argument_list|,
name|basic_block_live_at_end
index|[
name|i
index|]
argument_list|,
name|regset_bytes
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|basic_block_live_at_end
index|[
name|i
index|]
argument_list|,
name|basic_block_live_at_start
index|[
name|i
index|]
argument_list|,
name|regset_bytes
argument_list|)
expr_stmt|;
name|propagate_block
argument_list|(
name|basic_block_live_at_start
index|[
name|i
index|]
argument_list|,
name|basic_block_head
index|[
name|i
index|]
argument_list|,
name|basic_block_end
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|first_pass
condition|?
name|basic_block_significant
index|[
name|i
index|]
else|:
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|rtx
name|jump
decl_stmt|,
name|head
decl_stmt|;
comment|/* Update the basic_block_new_live_at_end's of the block 	       that falls through into this one (if any).  */
name|head
operator|=
name|basic_block_head
index|[
name|i
index|]
expr_stmt|;
name|jump
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|basic_block_drops_in
index|[
name|i
index|]
condition|)
block|{
specifier|register
name|int
name|from_block
init|=
name|BLOCK_NUM
argument_list|(
name|jump
argument_list|)
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|regset_size
condition|;
name|j
operator|++
control|)
name|basic_block_new_live_at_end
index|[
name|from_block
index|]
index|[
name|j
index|]
operator||=
name|basic_block_live_at_start
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
comment|/* Update the basic_block_new_live_at_end's of 	       all the blocks that jump to this one.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
for|for
control|(
name|jump
operator|=
name|LABEL_REFS
argument_list|(
name|head
argument_list|)
init|;
name|jump
operator|!=
name|head
condition|;
name|jump
operator|=
name|LABEL_NEXTREF
argument_list|(
name|jump
argument_list|)
control|)
block|{
specifier|register
name|int
name|from_block
init|=
name|BLOCK_NUM
argument_list|(
name|CONTAINING_INSN
argument_list|(
name|jump
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|regset_size
condition|;
name|j
operator|++
control|)
name|basic_block_new_live_at_end
index|[
name|from_block
index|]
index|[
name|j
index|]
operator||=
name|basic_block_live_at_start
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|first_pass
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This seems unnecessary; life at start of function shouldn't 	 mean that the reg is live in more than one basic block.  */
comment|/* Process the regs live at the beginning of the function.      Mark them as not local to any one basic block.  */
block|if (n_basic_blocks> 0)     for (i = FIRST_PSEUDO_REGISTER; i< max_regno; i++)       if (basic_block_live_at_start[0][i / REGSET_ELT_BITS]& (1<< (i % REGSET_ELT_BITS))) 	reg_basic_block[i] = REG_BLOCK_GLOBAL;
endif|#
directive|endif
comment|/* Now the life information is accurate.      Make one more pass over each basic block      to delete dead stores, create autoincrement addressing      and record how many times each register is used, is set, or dies.       To save time, we operate directly in basic_block_live_at_end[i],      thus destroying it (in fact, converting it into a copy of      basic_block_live_at_start[i]).  This is ok now because      basic_block_live_at_end[i] is no longer used past this point.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|propagate_block
argument_list|(
name|basic_block_live_at_end
index|[
name|i
index|]
argument_list|,
name|basic_block_head
index|[
name|i
index|]
argument_list|,
name|basic_block_end
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
literal|0
comment|/* Something live during a setjmp should not be put in a register      on certain machines which restore regs from stack frames      rather than from the jmpbuf.      But we don't need to do this for the user's variables, since      ANSI says only volatile variables need this.  */
ifdef|#
directive|ifdef
name|LONGJMP_RESTORE_FROM_STACK
block|for (i = FIRST_PSEUDO_REGISTER; i< nregs; i++)     if (regs_live_at_setjmp[i / REGSET_ELT_BITS]& (1<< (i % REGSET_ELT_BITS))&& regno_reg_rtx[i] != 0&& ! REG_USERVAR_P (regno_reg_rtx[i]))       { 	reg_live_length[i] = -1; 	reg_basic_block[i] = -1;       }
endif|#
directive|endif
endif|#
directive|endif
comment|/* We have a problem with any pseudoreg that      lives across the setjmp.  ANSI says that if a      user variable does not change in value      between the setjmp and the longjmp, then the longjmp preserves it.      This includes longjmp from a place where the pseudo appears dead.      (In principle, the value still exists if it is in scope.)      If the pseudo goes in a hard reg, some other value may occupy      that hard reg where this pseudo is dead, thus clobbering the pseudo.      Conclusion: such a pseudo must not go in a hard reg.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_live_at_setjmp
index|[
name|i
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
operator|&&
name|regno_reg_rtx
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|reg_live_length
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_basic_block
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|obstack_free
argument_list|(
operator|&
name|flow_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of life analysis.  */
end_comment

begin_comment
comment|/* Allocate the permanent data structures that represent the results    of life analysis.  Not static since used also for stupid life analysis.  */
end_comment

begin_function
name|void
name|allocate_for_life_analysis
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|regset
name|tem
decl_stmt|;
name|regset_size
operator|=
operator|(
operator|(
name|max_regno
operator|+
name|REGSET_ELT_BITS
operator|-
literal|1
operator|)
operator|/
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
name|regset_bytes
operator|=
name|regset_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|regset
operator|)
literal|0
argument_list|)
expr_stmt|;
name|reg_n_refs
operator|=
operator|(
name|short
operator|*
operator|)
name|oballoc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_n_refs
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|reg_n_sets
operator|=
operator|(
name|short
operator|*
operator|)
name|oballoc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_n_sets
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|reg_n_deaths
operator|=
operator|(
name|short
operator|*
operator|)
name|oballoc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_n_deaths
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|reg_first_use
operator|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_first_use
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_live_length
operator|=
operator|(
name|int
operator|*
operator|)
name|oballoc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_live_length
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_n_calls_crossed
operator|=
operator|(
name|int
operator|*
operator|)
name|oballoc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_n_calls_crossed
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_basic_block
operator|=
operator|(
name|short
operator|*
operator|)
name|oballoc
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
name|reg_basic_block
index|[
name|i
index|]
operator|=
name|REG_BLOCK_UNKNOWN
expr_stmt|;
name|basic_block_live_at_start
operator|=
operator|(
name|regset
operator|*
operator|)
name|oballoc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|regset
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
operator|(
name|regset
operator|)
name|oballoc
argument_list|(
name|n_basic_blocks
operator|*
name|regset_bytes
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|tem
argument_list|,
name|n_basic_blocks
operator|*
name|regset_bytes
argument_list|)
expr_stmt|;
name|init_regset_vector
argument_list|(
name|basic_block_live_at_start
argument_list|,
name|tem
argument_list|,
name|n_basic_blocks
argument_list|,
name|regset_bytes
argument_list|)
expr_stmt|;
name|regs_live_at_setjmp
operator|=
operator|(
name|regset
operator|)
name|oballoc
argument_list|(
name|regset_bytes
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|regs_live_at_setjmp
argument_list|,
name|regset_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make each element of VECTOR point at a regset,    taking the space for all those regsets from SPACE.    SPACE is of type regset, but it is really as long as NELTS regsets.    BYTES_PER_ELT is the number of bytes in one regset.  */
end_comment

begin_function
specifier|static
name|void
name|init_regset_vector
parameter_list|(
name|vector
parameter_list|,
name|space
parameter_list|,
name|nelts
parameter_list|,
name|bytes_per_elt
parameter_list|)
name|regset
modifier|*
name|vector
decl_stmt|;
name|regset
name|space
decl_stmt|;
name|int
name|nelts
decl_stmt|;
name|int
name|bytes_per_elt
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|regset
name|p
init|=
name|space
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|vector
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|bytes_per_elt
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the registers live at the beginning of a basic block    from those live at the end.     When called, OLD contains those live at the end.    On return, it contains those live at the beginning.    FIRST and LAST are the first and last insns of the basic block.     FINAL is nonzero if we are doing the final pass which is not    for computing the life info (since that has already been done)    but for acting on it.  On this pass, we delete dead stores,    set up the logical links and dead-variables lists of instructions,    and merge instructions for autoincrement and autodecrement addresses.     SIGNIFICANT is nonzero only the first time for each basic block.    If it is nonzero, it points to a regset in which we store    a 1 for each register that is set within the block.     BNUM is the number of the basic block.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_block
parameter_list|(
name|old
parameter_list|,
name|first
parameter_list|,
name|last
parameter_list|,
name|final
parameter_list|,
name|significant
parameter_list|,
name|bnum
parameter_list|)
specifier|register
name|regset
name|old
decl_stmt|;
name|rtx
name|first
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|int
name|final
decl_stmt|;
name|regset
name|significant
decl_stmt|;
name|int
name|bnum
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|rtx
name|prev
decl_stmt|;
name|regset
name|live
decl_stmt|;
name|regset
name|dead
decl_stmt|;
comment|/* The following variables are used only if FINAL is nonzero.  */
comment|/* This vector gets one element for each reg that has been live      at any point in the basic block that has been scanned so far.      SOMETIMES_MAX says how many elements are in use so far.      In each element, OFFSET is the byte-number within a regset      for the register described by the element, and BIT is a mask      for that register's bit within the byte.  */
specifier|register
struct|struct
name|foo
block|{
name|short
name|offset
decl_stmt|;
name|short
name|bit
decl_stmt|;
block|}
modifier|*
name|regs_sometimes_live
struct|;
name|int
name|sometimes_max
init|=
literal|0
decl_stmt|;
comment|/* This regset has 1 for each reg that we have seen live so far.      It and REGS_SOMETIMES_LIVE are updated together.  */
name|regset
name|maxlive
decl_stmt|;
name|loop_depth
operator|=
name|basic_block_loop_depth
index|[
name|bnum
index|]
expr_stmt|;
name|dead
operator|=
operator|(
name|regset
operator|)
name|alloca
argument_list|(
name|regset_bytes
argument_list|)
expr_stmt|;
name|live
operator|=
operator|(
name|regset
operator|)
name|alloca
argument_list|(
name|regset_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|final
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|,
name|bit
decl_stmt|;
name|maxlive
operator|=
operator|(
name|regset
operator|)
name|alloca
argument_list|(
name|regset_bytes
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|old
argument_list|,
name|maxlive
argument_list|,
name|regset_bytes
argument_list|)
expr_stmt|;
name|regs_sometimes_live
operator|=
operator|(
expr|struct
name|foo
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|foo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Process the regs live at the end of the block. 	 Enter them in MAXLIVE and REGS_SOMETIMES_LIVE. 	 Also mark them as not local to any one basic block.  */
for|for
control|(
name|offset
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|offset
operator|<
name|regset_size
condition|;
name|offset
operator|++
control|)
for|for
control|(
name|bit
operator|=
literal|1
init|;
name|bit
condition|;
name|bit
operator|<<=
literal|1
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|max_regno
condition|)
break|break;
if|if
condition|(
name|old
index|[
name|offset
index|]
operator|&
name|bit
condition|)
block|{
name|reg_basic_block
index|[
name|i
index|]
operator|=
name|REG_BLOCK_GLOBAL
expr_stmt|;
name|regs_sometimes_live
index|[
name|sometimes_max
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|regs_sometimes_live
index|[
name|sometimes_max
index|]
operator|.
name|bit
operator|=
name|i
operator|%
name|REGSET_ELT_BITS
expr_stmt|;
name|sometimes_max
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Include any notes at the end of the block in the scan.      This is in case the block ends with a call to setjmp.  */
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
name|NOTE
condition|)
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* Scan the block an insn at a time from end to beginning.  */
for|for
control|(
name|insn
operator|=
name|last
init|;
condition|;
name|insn
operator|=
name|prev
control|)
block|{
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If this is a call to `setjmp' et al, 	 warn if any non-volatile datum is live.  */
if|if
condition|(
name|final
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regset_size
condition|;
name|i
operator|++
control|)
name|regs_live_at_setjmp
index|[
name|i
index|]
operator||=
name|old
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Update the life-status of regs for this insn. 	 First DEAD gets which regs are set in this insn 	 then LIVE gets which regs are used in this insn. 	 Then the regs live before the insn 	 are those live after, with DEAD regs turned off, 	 and then LIVE regs turned on.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If an instruction consists of just dead store(s) on final pass, 	     "delete" it by turning it into a NOTE of type NOTE_INSN_DELETED. 	     We could really delete it with delete_insn, but that 	     can cause trouble for first or last insn in a basic block.  */
if|if
condition|(
name|final
operator|&&
name|insn_dead_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|old
argument_list|,
literal|1
argument_list|)
comment|/* Don't delete something that refers to volatile storage!  */
operator|&&
operator|!
name|INSN_VOLATILE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|oldpat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If this insn is copying the return value from a library call, 		 delete the entire library call.  */
if|if
condition|(
name|note
operator|&&
name|libcall_dead_p
argument_list|(
name|oldpat
argument_list|,
name|old
argument_list|)
condition|)
block|{
name|rtx
name|first
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|prev
init|=
name|insn
decl_stmt|;
while|while
condition|(
name|INSN_DELETED_P
argument_list|(
name|first
argument_list|)
condition|)
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
while|while
condition|(
name|prev
operator|!=
name|first
condition|)
block|{
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|prev
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|prev
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|prev
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
goto|goto
name|flushed
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regset_size
condition|;
name|i
operator|++
control|)
block|{
name|dead
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Faster than bzero here */
name|live
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* since regset_size is usually small */
block|}
comment|/* See if this is an increment or decrement that can be 	     merged into a following memory address.  */
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
block|{
specifier|register
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Does this instruction increment or decrement a register?  */
if|if
condition|(
name|final
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|)
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
comment|/* Ok, look for a following memory ref we can combine with. 		   If one is found, change the memory ref to a PRE_INC 		   or PRE_DEC, cancel this insn, and return 1. 		   Return 0 if nothing has been done.  */
operator|&&
name|try_pre_increment_1
argument_list|(
name|insn
argument_list|)
condition|)
goto|goto
name|flushed
goto|;
block|}
endif|#
directive|endif
comment|/* AUTO_INC_DEC */
comment|/* If this is not the final pass, and this insn is copying the 	     value of a library call and it's dead, don't scan the 	     insns that perform the library call, so that the call's 	     arguments are not marked live.  */
if|if
condition|(
name|note
operator|&&
name|insn_dead_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|old
argument_list|,
literal|1
argument_list|)
operator|&&
name|libcall_dead_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|old
argument_list|)
condition|)
block|{
comment|/* Mark the dest reg as `significant'.  */
name|mark_set_regs
argument_list|(
name|old
argument_list|,
name|dead
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|significant
argument_list|)
expr_stmt|;
name|insn
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
comment|/* We have an insn to pop a constant amount off the stack. 	       (Such insns use PLUS regardless of the direction of the stack, 	       and any insn to adjust the stack by a constant is always a pop.) 	       These insns, if not dead stores, have no effect on life.  */
empty_stmt|;
else|else
block|{
comment|/* LIVE gets the regs used in INSN; DEAD gets those set by it.  */
name|mark_set_regs
argument_list|(
name|old
argument_list|,
name|dead
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|final
condition|?
name|insn
else|:
literal|0
argument_list|,
name|significant
argument_list|)
expr_stmt|;
name|mark_used_regs
argument_list|(
name|old
argument_list|,
name|live
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Update OLD for the registers used or set.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regset_size
condition|;
name|i
operator|++
control|)
block|{
name|old
index|[
name|i
index|]
operator|&=
operator|~
name|dead
index|[
name|i
index|]
expr_stmt|;
name|old
index|[
name|i
index|]
operator||=
name|live
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Each call clobbers all call-clobbered regs. 		     Note that the function-value reg is one of these, and 		     mark_set_regs has already had a chance to handle it.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
condition|)
name|dead
index|[
name|i
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
expr_stmt|;
comment|/* The stack ptr is used (honorarily) by a CALL insn.  */
name|live
index|[
name|STACK_POINTER_REGNUM
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|STACK_POINTER_REGNUM
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Update OLD for the registers used or set.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regset_size
condition|;
name|i
operator|++
control|)
block|{
name|old
index|[
name|i
index|]
operator|&=
operator|~
name|dead
index|[
name|i
index|]
expr_stmt|;
name|old
index|[
name|i
index|]
operator||=
name|live
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|final
condition|)
block|{
comment|/* Any regs live at the time of a call instruction 		     must not go in a register clobbered by calls. 		     Find all regs now live and record this for them.  */
specifier|register
name|struct
name|foo
modifier|*
name|p
init|=
name|regs_sometimes_live
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sometimes_max
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|old
index|[
name|p
operator|->
name|offset
index|]
operator|&
operator|(
literal|1
operator|<<
name|p
operator|->
name|bit
operator|)
condition|)
name|reg_n_calls_crossed
index|[
name|p
operator|->
name|offset
operator|*
name|REGSET_ELT_BITS
operator|+
name|p
operator|->
name|bit
index|]
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/* On final pass, add any additional sometimes-live regs 	     into MAXLIVE and REGS_SOMETIMES_LIVE. 	     Also update counts of how many insns each reg is live at.  */
if|if
condition|(
name|final
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regset_size
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|diff
init|=
name|live
index|[
name|i
index|]
operator|&
operator|~
name|maxlive
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|diff
condition|)
block|{
specifier|register
name|int
name|regno
decl_stmt|;
name|maxlive
index|[
name|i
index|]
operator||=
name|diff
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|diff
operator|&&
name|regno
operator|<
name|REGSET_ELT_BITS
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|diff
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|regs_sometimes_live
index|[
name|sometimes_max
index|]
operator|.
name|offset
operator|=
name|i
expr_stmt|;
name|regs_sometimes_live
index|[
name|sometimes_max
index|]
operator|.
name|bit
operator|=
name|regno
expr_stmt|;
name|diff
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|regno
operator|)
expr_stmt|;
name|sometimes_max
operator|++
expr_stmt|;
block|}
block|}
block|}
block|{
specifier|register
name|struct
name|foo
modifier|*
name|p
init|=
name|regs_sometimes_live
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sometimes_max
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
name|old
index|[
name|p
operator|->
name|offset
index|]
operator|&
operator|(
literal|1
operator|<<
name|p
operator|->
name|bit
operator|)
condition|)
name|reg_live_length
index|[
name|p
operator|->
name|offset
operator|*
name|REGSET_ELT_BITS
operator|+
name|p
operator|->
name|bit
index|]
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
name|flushed
label|:
empty_stmt|;
if|if
condition|(
name|insn
operator|==
name|first
condition|)
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if X (the body of an insn, or part of it) is just dead stores    (SET expressions whose destinations are registers dead after the insn).    NEEDED is the regset that says which regs are alive after the insn.  */
end_comment

begin_function
specifier|static
name|int
name|insn_dead_p
parameter_list|(
name|x
parameter_list|,
name|needed
parameter_list|,
name|strict_low_ok
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|regset
name|needed
decl_stmt|;
name|int
name|strict_low_ok
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Make sure insns to set the stack pointer are never deleted.  */
block|needed[STACK_POINTER_REGNUM / REGSET_ELT_BITS]     |= 1<< (STACK_POINTER_REGNUM % REGSET_ELT_BITS);
endif|#
directive|endif
comment|/* If setting something that's a reg or part of one,      see if that register's altered value will be live.  */
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
specifier|register
name|rtx
name|r
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* A SET that is a subroutine call cannot be dead.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|SUBREG
operator|||
operator|(
name|strict_low_ok
operator|&&
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|)
operator|||
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|SIGN_EXTRACT
condition|)
name|r
operator|=
name|SUBREG_REG
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|r
argument_list|)
decl_stmt|;
specifier|register
name|int
name|offset
init|=
name|regno
operator|/
name|REGSET_ELT_BITS
decl_stmt|;
specifier|register
name|int
name|bit
init|=
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
decl_stmt|;
return|return
operator|(
operator|!
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|regno
index|]
operator|)
operator|&&
operator|(
name|needed
index|[
name|offset
index|]
operator|&
name|bit
operator|)
operator|==
literal|0
operator|)
return|;
block|}
block|}
comment|/* If performing several activities,      insn is dead if each activity is individually dead.      Also, CLOBBERs and USEs can be ignored; a CLOBBER or USE      that's inside a PARALLEL doesn't make the insn worth keeping.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
init|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|insn_dead_p
argument_list|(
name|elt
argument_list|,
name|needed
argument_list|,
name|strict_low_ok
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|USE
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
comment|/* We do not check CLOBBER or USE here.      An insn consisting of just a CLOBBER or just a USE      should not be deleted.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If X is the last insn in a libcall, and assuming X is dead,    return 1 if the entire library call is dead.    This is true if the source of X is a dead register    (as well as the destination, which we tested already).    If this insn doesn't just copy a register, then we don't    have an ordinary libcall.  In that case, cse could not have    managed to substitute the source for the dest later on,    so we can assume the libcall is dead.  */
end_comment

begin_function
specifier|static
name|int
name|libcall_dead_p
parameter_list|(
name|x
parameter_list|,
name|needed
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|regset
name|needed
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
specifier|register
name|rtx
name|r
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|r
argument_list|)
decl_stmt|;
specifier|register
name|int
name|offset
init|=
name|regno
operator|/
name|REGSET_ELT_BITS
decl_stmt|;
specifier|register
name|int
name|bit
init|=
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
decl_stmt|;
return|return
operator|(
name|needed
index|[
name|offset
index|]
operator|&
name|bit
operator|)
operator|==
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if register REGNO was used before it was set.    In other words, if it is live at function entry.  */
end_comment

begin_function
name|int
name|regno_uninitialized
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|basic_block_live_at_start
index|[
literal|0
index|]
index|[
name|regno
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* 1 if register REGNO was alive at a place where `setjmp' was called    and was set more than once.  Such regs may be clobbered by `longjmp'.  */
end_comment

begin_function
name|int
name|regno_clobbered_at_setjmp
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
return|return
operator|(
name|reg_n_sets
index|[
name|regno
index|]
operator|>
literal|1
operator|&&
operator|(
name|regs_live_at_setjmp
index|[
name|regno
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process the registers that are set within X.    Their bits are set to 1 in the regset DEAD,    because they are dead prior to this insn.     If INSN is nonzero, it is the insn being processed    and the fact that it is nonzero implies this is the FINAL pass    in propagate_block.  In this case, various info about register    usage is stored, LOG_LINKS fields of insns are set up.  */
end_comment

begin_function_decl
specifier|static
name|void
name|mark_set_1
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|mark_set_regs
parameter_list|(
name|needed
parameter_list|,
name|dead
parameter_list|,
name|x
parameter_list|,
name|insn
parameter_list|,
name|significant
parameter_list|)
name|regset
name|needed
decl_stmt|;
name|regset
name|dead
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|regset
name|significant
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|mark_set_1
argument_list|(
name|needed
argument_list|,
name|dead
argument_list|,
name|x
argument_list|,
name|insn
argument_list|,
name|significant
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|mark_set_1
argument_list|(
name|needed
argument_list|,
name|dead
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|significant
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Process a single SET rtx, X.  */
end_comment

begin_function
specifier|static
name|void
name|mark_set_1
parameter_list|(
name|needed
parameter_list|,
name|dead
parameter_list|,
name|x
parameter_list|,
name|insn
parameter_list|,
name|significant
parameter_list|)
name|regset
name|needed
decl_stmt|;
name|regset
name|dead
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|regset
name|significant
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|subreg_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
return|return;
comment|/* Modifying just one hardware register of a multi-reg value      or just a byte field of a register      does not mean the value from before this insn is now dead.      But it does mean liveness of that register at the end of the block      is significant.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_SIZE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|>
name|REG_SIZE
argument_list|(
name|reg
argument_list|)
operator|)
condition|)
name|subreg_p
operator|=
literal|1
expr_stmt|;
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|,
name|regno
operator|!=
name|FRAME_POINTER_REGNUM
operator|)
operator|&&
name|regno
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|regno
index|]
operator|)
condition|)
comment|/*&& regno != STACK_POINTER_REGNUM) -- let's try without this.  */
block|{
specifier|register
name|int
name|offset
init|=
name|regno
operator|/
name|REGSET_ELT_BITS
decl_stmt|;
specifier|register
name|int
name|bit
init|=
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
decl_stmt|;
name|int
name|is_needed
init|=
literal|0
decl_stmt|;
comment|/* Mark it as a significant register for this basic block.  */
if|if
condition|(
name|significant
condition|)
name|significant
index|[
name|offset
index|]
operator||=
name|bit
expr_stmt|;
comment|/* That's all we do, if we are setting only part of the register.  */
if|if
condition|(
name|subreg_p
condition|)
return|return;
comment|/* If entire register being set, mark it as as dead before this insn.  */
name|dead
index|[
name|offset
index|]
operator||=
name|bit
expr_stmt|;
comment|/* A hard reg in a wide mode may really be multiple registers. 	 If so, mark all of them just like the first.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
decl_stmt|;
comment|/* Nothing below is needed for the stack pointer; get out asap. 	     Eg, log links aren't needed, since combine won't use them.  */
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return;
name|n
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
block|{
name|dead
index|[
operator|(
name|regno
operator|+
name|n
operator|)
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|n
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
if|if
condition|(
name|significant
condition|)
name|significant
index|[
operator|(
name|regno
operator|+
name|n
operator|)
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|n
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
name|is_needed
operator||=
operator|(
name|needed
index|[
operator|(
name|regno
operator|+
name|n
operator|)
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|n
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
expr_stmt|;
block|}
block|}
comment|/* Additional data to record if this is the final pass.  */
if|if
condition|(
name|insn
condition|)
block|{
specifier|register
name|rtx
name|y
init|=
name|reg_next_use
index|[
name|regno
index|]
decl_stmt|;
specifier|register
name|int
name|blocknum
init|=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If this is a hard reg, record this function uses the reg. 	     `combine.c' will get confused if LOG_LINKs are made 	     for hard regs.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
do|do
name|regs_ever_live
index|[
name|regno
operator|+
operator|--
name|i
index|]
operator|=
literal|1
expr_stmt|;
do|while
condition|(
name|i
operator|>
literal|0
condition|)
do|;
if|if
condition|(
operator|!
operator|(
operator|(
name|needed
index|[
name|offset
index|]
operator|&
name|bit
operator|)
operator|||
name|is_needed
operator|)
condition|)
block|{
comment|/* Note that dead stores have already been deleted if poss. 		     If we get here, we have found a dead store that cannot 		     be eliminated (because the insn does something useful). 		     Indicate this by marking the reg set as dying here.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_DEAD
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|reg_n_deaths
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
operator|++
expr_stmt|;
block|}
return|return;
block|}
comment|/* Keep track of which basic blocks each reg appears in.  */
if|if
condition|(
name|reg_basic_block
index|[
name|regno
index|]
operator|==
name|REG_BLOCK_UNKNOWN
condition|)
name|reg_basic_block
index|[
name|regno
index|]
operator|=
name|blocknum
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_basic_block
index|[
name|regno
index|]
operator|!=
name|blocknum
condition|)
name|reg_basic_block
index|[
name|regno
index|]
operator|=
name|REG_BLOCK_GLOBAL
expr_stmt|;
comment|/* Record first insn to use this reg.  */
name|reg_first_use
index|[
name|regno
index|]
operator|=
name|insn
expr_stmt|;
comment|/* Count (weighted) references, stores, etc.  */
name|reg_n_refs
index|[
name|regno
index|]
operator|+=
name|loop_depth
expr_stmt|;
name|reg_n_sets
index|[
name|regno
index|]
operator|++
expr_stmt|;
comment|/* The next use is no longer "next", since a store intervenes.  */
name|reg_next_use
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
comment|/* The insns where a reg is live are normally counted elsewhere, 	     but we want the count to include the insn where the reg is set, 	     and the normal counting mechanism would not count it.  */
name|reg_live_length
index|[
name|regno
index|]
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|needed
index|[
name|offset
index|]
operator|&
name|bit
operator|)
operator|||
name|is_needed
condition|)
block|{
comment|/* Make a logical link from the next following insn 		 that uses this register, back to this insn. 		 The following insns have already been processed.  */
if|if
condition|(
name|y
operator|&&
operator|(
name|BLOCK_NUM
argument_list|(
name|y
argument_list|)
operator|==
name|blocknum
operator|)
condition|)
name|LOG_LINKS
argument_list|(
name|y
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|LOG_LINKS
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Note that dead stores have already been deleted when possible 		 If we get here, we have found a dead store that cannot 		 be eliminated (because the same insn does something useful). 		 Indicate this by marking the reg being set as dying here.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_DEAD
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|reg_n_deaths
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan expression X and store a 1-bit in LIVE for each reg it uses.    This is done assuming the registers needed from X    are those that have 1-bits in NEEDED.     On the final pass, FINAL is 1.  This means try for autoincrement    and count the uses and deaths of each pseudo-reg.     INSN is the containing instruction.  */
end_comment

begin_function
specifier|static
name|void
name|mark_used_regs
parameter_list|(
name|needed
parameter_list|,
name|live
parameter_list|,
name|x
parameter_list|,
name|final
parameter_list|,
name|insn
parameter_list|)
name|regset
name|needed
decl_stmt|;
name|regset
name|live
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|final
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|int
name|regno
decl_stmt|;
name|retry
label|:
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|CLOBBER
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|ASM_INPUT
case|:
return|return;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_POST_INCREMENT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_POST_DECREMENT
argument_list|)
case|case
name|MEM
case|:
comment|/* Here we detect use of an index register which might 	 be good for postincrement or postdecrement.  */
if|if
condition|(
name|final
condition|)
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|rtx
name|y
decl_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* Is the next use an increment that might make auto-increment? */
name|y
operator|=
name|reg_next_use
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
name|y
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|BLOCK_NUM
argument_list|(
name|y
argument_list|)
operator|==
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
comment|/* Can't add side effects to jumps; if reg is spilled and 		     reloaded, there's no way to store back the altered value.  */
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|&&
operator|(
name|y
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|y
argument_list|)
argument_list|)
operator|,
operator|(
literal|0
ifdef|#
directive|ifdef
name|HAVE_POST_INCREMENT
operator|||
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_POST_DECREMENT
operator|||
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|MINUS
endif|#
directive|endif
operator|)
operator|&&
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
operator|==
name|addr
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|size
operator|)
operator|&&
name|dead_or_set_p
argument_list|(
name|reg_next_use
index|[
name|regno
index|]
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|rtx
name|use
init|=
name|find_use_as_address
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Make sure this register appears only once in this insn.  */
if|if
condition|(
name|use
operator|!=
literal|0
operator|&&
name|use
operator|!=
operator|(
name|rtx
operator|)
literal|1
condition|)
block|{
comment|/* We have found a suitable auto-increment: 			 do POST_INC around the register here, 			 and patch out the increment instruction that follows. */
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
condition|?
name|POST_INC
else|:
name|POST_DEC
argument_list|,
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Record that this insn has an implicit side effect.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_INC
argument_list|,
name|addr
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Modify the old increment-insn to simply copy 			 the already-incremented value of our register.  */
name|y
operator|=
name|reg_next_use
index|[
name|regno
index|]
expr_stmt|;
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|y
argument_list|)
argument_list|)
operator|=
name|addr
expr_stmt|;
comment|/* If that makes it a no-op (copying the register 			 into itself) then change it to a simpler no-op 			 so it won't appear to be a "use" and a "set" 			 of this register.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
name|addr
condition|)
name|PATTERN
argument_list|(
name|y
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
comment|/* Count an extra reference to the reg for the increment. 			 When a reg is incremented. 			 spilling it is worse, so we want to make that 			 less likely.  */
name|reg_n_refs
index|[
name|regno
index|]
operator|+=
name|loop_depth
expr_stmt|;
comment|/* Count the increment as a setting of the register, 			 even though it isn't a SET in rtl.  */
name|reg_n_sets
index|[
name|regno
index|]
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
endif|#
directive|endif
comment|/* HAVE_POST_INCREMENT or HAVE_POST_DECREMENT */
case|case
name|REG
case|:
comment|/* See a register other than being set 	 => mark it as needed.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|!=
name|FRAME_POINTER_REGNUM
condition|)
comment|/*&& regno != ARG_POINTER_REGNUM) -- and without this.  */
comment|/*&& regno != STACK_POINTER_REGNUM) -- let's try without this.  */
block|{
specifier|register
name|int
name|offset
init|=
name|regno
operator|/
name|REGSET_ELT_BITS
decl_stmt|;
specifier|register
name|int
name|bit
init|=
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
decl_stmt|;
name|int
name|is_needed
init|=
literal|0
decl_stmt|;
name|live
index|[
name|offset
index|]
operator||=
name|bit
expr_stmt|;
comment|/* A hard reg in a wide mode may really be multiple registers. 	     If so, mark all of them just like the first.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
decl_stmt|;
comment|/* For stack ptr or arg pointer, 		 nothing below can be necessary, so waste no more time.  */
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|regno
operator|==
name|ARG_POINTER_REGNUM
condition|)
return|return;
comment|/* No death notes for global register variables; 		 their values are live after this function exits.  */
if|if
condition|(
name|global_regs
index|[
name|regno
index|]
condition|)
return|return;
name|n
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
block|{
name|live
index|[
operator|(
name|regno
operator|+
name|n
operator|)
operator|/
name|REGSET_ELT_BITS
index|]
operator||=
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|n
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
expr_stmt|;
name|is_needed
operator||=
operator|(
name|needed
index|[
operator|(
name|regno
operator|+
name|n
operator|)
operator|/
name|REGSET_ELT_BITS
index|]
operator|&
literal|1
operator|<<
operator|(
operator|(
name|regno
operator|+
name|n
operator|)
operator|%
name|REGSET_ELT_BITS
operator|)
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|final
condition|)
block|{
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* If a hard reg is being used, 		     record that this function does use it.  */
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
do|do
name|regs_ever_live
index|[
name|regno
operator|+
operator|--
name|i
index|]
operator|=
literal|1
expr_stmt|;
do|while
condition|(
name|i
operator|>
literal|0
condition|)
do|;
block|}
else|else
block|{
comment|/* Keep track of which basic block each reg appears in.  */
specifier|register
name|int
name|blocknum
init|=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_basic_block
index|[
name|regno
index|]
operator|==
name|REG_BLOCK_UNKNOWN
condition|)
name|reg_basic_block
index|[
name|regno
index|]
operator|=
name|blocknum
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_basic_block
index|[
name|regno
index|]
operator|!=
name|blocknum
condition|)
name|reg_basic_block
index|[
name|regno
index|]
operator|=
name|REG_BLOCK_GLOBAL
expr_stmt|;
comment|/* Record the earliest insn that uses this reg, 		     provided the reg is used only in one basic block. 		     Do this by recording each insn, and the one that 		     sticks is the last one scanned (the earliest insn).  */
name|reg_first_use
index|[
name|regno
index|]
operator|=
name|insn
expr_stmt|;
comment|/* Record where each reg is used, so when the reg 		     is set we know the next insn that uses it.  */
name|reg_next_use
index|[
name|regno
index|]
operator|=
name|insn
expr_stmt|;
comment|/* Count (weighted) number of uses of each reg.  */
name|reg_n_refs
index|[
name|regno
index|]
operator|+=
name|loop_depth
expr_stmt|;
block|}
comment|/* Record and count the insns in which a reg dies. 		 If it is used in this insn and was dead below the insn 		 then it dies in this insn.  */
if|if
condition|(
operator|!
operator|(
name|needed
index|[
name|offset
index|]
operator|&
name|bit
operator|)
operator|&&
operator|!
name|is_needed
operator|&&
operator|!
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_DEAD
argument_list|,
name|x
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|reg_n_deaths
index|[
name|regno
index|]
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return;
case|case
name|SET
case|:
block|{
specifier|register
name|rtx
name|testreg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|mark_dest
init|=
literal|0
decl_stmt|;
comment|/* Storing in STRICT_LOW_PART is like storing in a reg 	   in that this SET might be dead, so ignore it in TESTREG. 	   but in some other ways it is like using the reg.  */
comment|/* Storing in a SUBREG or a bit field is like storing the entire 	   register in that if the register's value is not used 	   then this SET is not needed.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* Modifying a single register in an alternate mode 	       does not use any of the old value.  But these other 	       ways of storing in a register do use the old value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|!
operator|(
name|REG_SIZE
argument_list|(
name|SUBREG_REG
argument_list|(
name|testreg
argument_list|)
argument_list|)
operator|>
name|REG_SIZE
argument_list|(
name|testreg
argument_list|)
operator|)
condition|)
empty_stmt|;
else|else
name|mark_dest
operator|=
literal|1
expr_stmt|;
name|testreg
operator|=
name|XEXP
argument_list|(
name|testreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a store into a register, 	   recursively scan the only value being stored, 	   and only if the register's value is live after this insn. 	   If the value being computed here would never be used 	   then the values it uses don't need to be computed either.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|testreg
argument_list|)
operator|,
name|regno
operator|!=
name|FRAME_POINTER_REGNUM
operator|)
operator|&&
name|regno
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|regno
index|]
operator|)
condition|)
if|#
directive|if
literal|0
comment|/* This was added in 1.25, but screws up death notes for hard regs. 	 It probably isn't really needed anyway.  */
then|&& (regno>= FIRST_PSEUDO_REGISTER 		|| INSN_VOLATILE (insn)))
endif|#
directive|endif
block|{
specifier|register
name|int
name|offset
init|=
name|regno
operator|/
name|REGSET_ELT_BITS
decl_stmt|;
specifier|register
name|int
name|bit
init|=
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|needed
index|[
name|offset
index|]
operator|&
name|bit
operator|)
comment|/* If insn refers to volatile, we mustn't delete it, 		   so its inputs are all needed.  */
operator|||
name|INSN_VOLATILE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_dest
condition|)
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* Tail recursive case: save a function call level.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_function
specifier|static
name|int
name|try_pre_increment_1
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* Find the next use of this reg.  If in same basic block,      make it do pre-increment or pre-decrement if appropriate.  */
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|amount
init|=
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
operator|*
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|y
init|=
name|reg_next_use
index|[
name|regno
index|]
decl_stmt|;
if|if
condition|(
name|y
operator|!=
literal|0
operator|&&
name|BLOCK_NUM
argument_list|(
name|y
argument_list|)
operator|==
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
operator|&&
name|try_pre_increment
argument_list|(
name|y
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|amount
argument_list|)
condition|)
block|{
comment|/* We have found a suitable auto-increment 	 and already changed insn Y to do it. 	 So flush this increment-instruction.  */
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Count a reference to this reg for the increment 	 insn we are deleting.  When a reg is incremented. 	 spilling it is worse, so we want to make that 	 less likely.  */
name|reg_n_refs
index|[
name|regno
index|]
operator|+=
name|loop_depth
expr_stmt|;
name|reg_n_sets
index|[
name|regno
index|]
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Try to change INSN so that it does pre-increment or pre-decrement    addressing on register REG in order to add AMOUNT to REG.    AMOUNT is negative for pre-decrement.    Returns 1 if the change could be made.    This checks all about the validity of the result of modifying INSN.  */
end_comment

begin_function
specifier|static
name|int
name|try_pre_increment
parameter_list|(
name|insn
parameter_list|,
name|reg
parameter_list|,
name|amount
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|amount
decl_stmt|;
block|{
specifier|register
name|rtx
name|use
decl_stmt|;
comment|/* Nonzero if we can try to make a pre-increment or pre-decrement.      For example, addl $4,r1; movl (r1),... can become movl +(r1),...  */
name|int
name|pre_ok
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if we can try to make a post-increment or post-decrement.      For example, addl $4,r1; movl -4(r1),... can become movl (r1)+,...      It is possible for both PRE_OK and POST_OK to be nonzero if the machine      supports both pre-inc and post-inc, or both pre-dec and post-dec.  */
name|int
name|post_ok
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if the opportunity actually requires post-inc or post-dec.  */
name|int
name|do_post
init|=
literal|0
decl_stmt|;
comment|/* From the sign of increment, see which possibilities are conceivable      on this target machine.  */
ifdef|#
directive|ifdef
name|HAVE_PRE_INCREMENT
if|if
condition|(
name|amount
operator|>
literal|0
condition|)
name|pre_ok
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_POST_INCREMENT
if|if
condition|(
name|amount
operator|>
literal|0
condition|)
name|post_ok
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PRE_DECREMENT
if|if
condition|(
name|amount
operator|<
literal|0
condition|)
name|pre_ok
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_POST_DECREMENT
if|if
condition|(
name|amount
operator|<
literal|0
condition|)
name|post_ok
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|pre_ok
operator|||
name|post_ok
operator|)
condition|)
return|return
literal|0
return|;
comment|/* It is not safe to add a side effect to a jump insn      because if the incremented register is spilled and must be reloaded      there would be no way to store the incremented value back in memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
return|return
literal|0
return|;
name|use
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pre_ok
condition|)
name|use
operator|=
name|find_use_as_address
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|post_ok
operator|&&
operator|(
name|use
operator|==
literal|0
operator|||
name|use
operator|==
operator|(
name|rtx
operator|)
literal|1
operator|)
condition|)
block|{
name|use
operator|=
name|find_use_as_address
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg
argument_list|,
operator|-
name|amount
argument_list|)
expr_stmt|;
name|do_post
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|use
operator|==
literal|0
operator|||
name|use
operator|==
operator|(
name|rtx
operator|)
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|use
argument_list|)
argument_list|)
operator|!=
operator|(
name|amount
operator|>
literal|0
condition|?
name|amount
else|:
operator|-
name|amount
operator|)
condition|)
return|return
literal|0
return|;
name|XEXP
argument_list|(
name|use
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|amount
operator|>
literal|0
condition|?
operator|(
name|do_post
condition|?
name|POST_INC
else|:
name|PRE_INC
operator|)
else|:
operator|(
name|do_post
condition|?
name|POST_DEC
else|:
name|PRE_DEC
operator|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Record that this insn now has an implicit side effect on X.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_INC
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTO_INC_DEC */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Find the place in the rtx X where REG is used as a memory address.    Return the MEM rtx that so uses it.    If PLUSCONST is nonzero, search instead for a memory address equivalent to    (plus REG (const_int PLUSCONST)).     If such an address does not appear, return 0.    If REG appears more than once, or is used other than in such an address,    return (rtx)1.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_use_as_address
parameter_list|(
name|x
parameter_list|,
name|reg
parameter_list|,
name|plusconst
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|int
name|plusconst
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
name|value
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
operator|&&
name|plusconst
operator|==
literal|0
condition|)
return|return
name|x
return|;
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|plusconst
condition|)
return|return
name|x
return|;
if|if
condition|(
name|code
operator|==
name|SIGN_EXTRACT
operator|||
name|code
operator|==
name|ZERO_EXTRACT
condition|)
block|{
comment|/* If REG occurs inside a MEM used in a bit-field reference, 	 that is unacceptable.  */
if|if
condition|(
name|find_use_as_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rtx
operator|)
literal|1
return|;
block|}
if|if
condition|(
name|x
operator|==
name|reg
condition|)
return|return
operator|(
name|rtx
operator|)
literal|1
return|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|tem
operator|=
name|find_use_as_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|reg
argument_list|,
name|plusconst
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
operator|(
name|rtx
operator|)
literal|1
return|;
block|}
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|tem
operator|=
name|find_use_as_address
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|reg
argument_list|,
name|plusconst
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
operator|(
name|rtx
operator|)
literal|1
return|;
block|}
block|}
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write information about registers and basic blocks into FILE.    This is part of making a debugging dump.  */
end_comment

begin_function
name|void
name|dump_flow_info
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|char
modifier|*
name|reg_class_names
index|[]
init|=
name|REG_CLASS_NAMES
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d registers.\n"
argument_list|,
name|max_regno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_n_refs
index|[
name|i
index|]
condition|)
block|{
name|enum
name|reg_class
name|class
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nRegister %d used %d times across %d insns"
argument_list|,
name|i
argument_list|,
name|reg_n_refs
index|[
name|i
index|]
argument_list|,
name|reg_live_length
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_basic_block
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" in block %d"
argument_list|,
name|reg_basic_block
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_n_deaths
index|[
name|i
index|]
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; dies in %d places"
argument_list|,
name|reg_n_deaths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_n_calls_crossed
index|[
name|i
index|]
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; crosses 1 call"
argument_list|,
name|reg_n_calls_crossed
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_n_calls_crossed
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; crosses %d calls"
argument_list|,
name|reg_n_calls_crossed
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|PSEUDO_REGNO_BYTES
argument_list|(
name|i
argument_list|)
operator|!=
name|UNITS_PER_WORD
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; %d bytes"
argument_list|,
name|PSEUDO_REGNO_BYTES
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|class
operator|=
name|reg_preferred_class
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|GENERAL_REGS
condition|)
block|{
if|if
condition|(
name|reg_preferred_or_nothing
argument_list|(
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; %s or none"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; pref %s"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|REGNO_POINTER_FLAG
argument_list|(
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; pointer"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%d basic blocks.\n"
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|rtx
name|head
decl_stmt|,
name|jump
decl_stmt|;
specifier|register
name|int
name|regno
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nBasic block %d: first insn %d, last %d.\n"
argument_list|,
name|i
argument_list|,
name|INSN_UID
argument_list|(
name|basic_block_head
index|[
name|i
index|]
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|basic_block_end
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The control flow graph's storage is freed 	 now when flow_analysis returns. 	 Don't try to print it if it is gone.  */
if|if
condition|(
name|basic_block_drops_in
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Reached from blocks: "
argument_list|)
expr_stmt|;
name|head
operator|=
name|basic_block_head
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
for|for
control|(
name|jump
operator|=
name|LABEL_REFS
argument_list|(
name|head
argument_list|)
init|;
name|jump
operator|!=
name|head
condition|;
name|jump
operator|=
name|LABEL_NEXTREF
argument_list|(
name|jump
argument_list|)
control|)
block|{
specifier|register
name|int
name|from_block
init|=
name|BLOCK_NUM
argument_list|(
name|CONTAINING_INSN
argument_list|(
name|jump
argument_list|)
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|from_block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|basic_block_drops_in
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" previous"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nRegisters live at start:"
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|max_regno
condition|;
name|regno
operator|++
control|)
block|{
specifier|register
name|int
name|offset
init|=
name|regno
operator|/
name|REGSET_ELT_BITS
decl_stmt|;
specifier|register
name|int
name|bit
init|=
literal|1
operator|<<
operator|(
name|regno
operator|%
name|REGSET_ELT_BITS
operator|)
decl_stmt|;
if|if
condition|(
name|basic_block_live_at_start
index|[
name|i
index|]
index|[
name|offset
index|]
operator|&
name|bit
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

