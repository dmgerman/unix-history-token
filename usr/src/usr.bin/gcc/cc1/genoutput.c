begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code from to output assembler insns as recognized from rtl.    Copyright (C) 1987, 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This program reads the machine description for the compiler target machine    and produces a file containing three things:     1, An array of strings `insn_template' which is indexed by insn code number    and contains the template for output of that insn,     2. An array of ints `insn_n_operands' which is indexed by insn code number    and contains the number of distinct operands in the pattern for that insn,     3. An array of ints `insn_n_dups' which is indexed by insn code number    and contains the number of match_dup's that appear in the insn's pattern.    This says how many elements of `recog_dup_loc' are significant    after an insn has been recognized.     4. An array of arrays of operand constraint strings,    `insn_operand_constraint',    indexed first by insn code number and second by operand number,    containing the constraint for that operand.     This array is generated only if register constraints appear in     match_operand rtx's.     5. An array of arrays of chars which indicate which operands of    which insn patterns appear within ADDRESS rtx's.  This array is    called `insn_operand_address_p' and is generated only if there    are *no* register constraints in the match_operand rtx's.     6. An array of arrays of machine modes, `insn_operand_mode',    indexed first by insn code number and second by operand number,    containing the machine mode that that operand is supposed to have.    Also `insn_operand_strict_low', which is nonzero for operands    contained in a STRICT_LOW_PART.     7. An array of arrays of int-valued functions, `insn_operand_predicate',    indexed first by insn code number and second by operand number,    containing the match_operand predicate for this operand.     8. An array of functions `insn_gen_function' which, indexed    by insn code number, gives the function to generate a body    for that patter, given operands as arguments.     9. A function `output_insn_hairy' which is called with two arguments    (an insn code number and a vector of operand value rtx's)    and returns a template to use for output of that insn.    This is used only in the cases where the template is not constant.    These cases are specified by a * at the beginning of the template string    in the machine description.  They are identified for the sake of    other parts of the compiler by a zero element in `insn_template'.       10. An array of structures, `insn_machine_info', that gives machine-specific    information about the insn.     11. An array of ints, `insn_n_alternatives', that gives the number    of alternatives in the constraints of each pattern.  The code number of an insn is simply its position in the machine description; code numbers are assigned sequentially to entries in the description, starting with code number 0.  Thus, the following entry in the machine description      (define_insn "clrdf"       [(set (match_operand:DF 0 "general_operand" "") 	    (const_int 0))]       ""       "clrd %0")  assuming it is the 25th entry present, would cause insn_template[24] to be "clrd %0", and insn_n_operands[24] to be 1. It would not make an case in output_insn_hairy because the template given in the entry is a constant (it does not start with `*').  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* No instruction can have more operands than this.    Sorry for this arbitrary limit, but what machine will    have an instruction with this many operands?  */
end_comment

begin_define
define|#
directive|define
name|MAX_MAX_OPERANDS
value|40
end_define

begin_decl_stmt
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|rtl_obstack
init|=
operator|&
name|obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|extern
name|int
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fatal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fancy_abort
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mybcopy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mybzero
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* insns in the machine description are assigned sequential code numbers    that are used by insn-recog.c (produced by genrecog) to communicate    to insn-output.c (produced by this program).  */
end_comment

begin_decl_stmt
name|int
name|next_code_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record in this chain all information that we will output,    associated with the code number of the insn.  */
end_comment

begin_struct
struct|struct
name|data
block|{
name|int
name|code_number
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|template
decl_stmt|;
comment|/* string such as "movl %1,%0" */
name|int
name|n_operands
decl_stmt|;
comment|/* Number of operands this insn recognizes */
name|int
name|n_dups
decl_stmt|;
comment|/* Number times match_dup appears in pattern */
name|int
name|n_alternatives
decl_stmt|;
comment|/* Number of alternatives in each constraint */
name|struct
name|data
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|constraints
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Number of alternatives in constraints of operand N.  */
name|int
name|op_n_alternatives
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
name|char
modifier|*
name|predicates
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
name|char
name|address_p
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
name|enum
name|machine_mode
name|modes
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
name|char
name|strict_low
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
name|char
name|outfun
decl_stmt|;
comment|/* Nonzero means this has an output function */
name|char
modifier|*
name|machine_info
decl_stmt|;
comment|/* machine-specific info string. */
block|}
struct|;
end_struct

begin_comment
comment|/* This variable points to the first link in the chain.  */
end_comment

begin_decl_stmt
name|struct
name|data
modifier|*
name|insn_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the last link in the chain, so new elements    can be added at the end.  */
end_comment

begin_decl_stmt
name|struct
name|data
modifier|*
name|end_of_insn_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if any match_operand has a constraint string;    implies that REGISTER_CONSTRAINTS will be defined    for this machine description.  */
end_comment

begin_decl_stmt
name|int
name|have_constraints
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|output_prologue
parameter_list|()
block|{
name|printf
argument_list|(
literal|"/* Generated automatically by the program `genoutput'\n\ from the machine description file `md'.  */\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"rtl.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"regs.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"hard-reg-set.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"real.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"conditions.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-flags.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-config.h\"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#ifndef __STDC__\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define const\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#endif\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"output.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"aux-output.c\"\n\n"
argument_list|)
expr_stmt|;
comment|/* Make sure there is at least a dummy definition of INSN_MACHINE_INFO.  */
name|printf
argument_list|(
literal|"#ifndef INSN_MACHINE_INFO\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define INSN_MACHINE_INFO struct dummy1 {int i;}\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#endif\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|output_epilogue
parameter_list|()
block|{
specifier|register
name|struct
name|data
modifier|*
name|d
decl_stmt|;
name|printf
argument_list|(
literal|"\nchar * const insn_template[] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|d
operator|->
name|template
condition|)
name|printf
argument_list|(
literal|"    \"%s\",\n"
argument_list|,
name|d
operator|->
name|template
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    0,\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nchar *(*const insn_outfun[])() =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|d
operator|->
name|outfun
condition|)
name|printf
argument_list|(
literal|"    output_%d,\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    0,\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nrtx (*const insn_gen_function[]) () =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|d
operator|->
name|name
condition|)
name|printf
argument_list|(
literal|"    gen_%s,\n"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"    0,\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nconst int insn_n_operands[] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"    %d,\n"
argument_list|,
name|d
operator|->
name|n_operands
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nconst int insn_n_dups[] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"    %d,\n"
argument_list|,
name|d
operator|->
name|n_dups
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_constraints
condition|)
block|{
name|printf
argument_list|(
literal|"\nchar *const insn_operand_constraint[][MAX_RECOG_OPERANDS] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|,
name|start
decl_stmt|;
name|printf
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
comment|/* Make sure all the operands have the same number of 	     alternatives in their constraints. 	     Let N be that number.  */
for|for
control|(
name|start
operator|=
literal|0
init|;
name|start
operator|<
name|d
operator|->
name|n_operands
condition|;
name|start
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|op_n_alternatives
index|[
name|start
index|]
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
name|d
operator|->
name|op_n_alternatives
index|[
name|start
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|!=
name|d
operator|->
name|op_n_alternatives
index|[
name|start
index|]
condition|)
name|error
argument_list|(
literal|"wrong number of alternatives in operand %d of insn number %d"
argument_list|,
name|start
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
block|}
comment|/* Record the insn's overall number of alternatives.  */
name|d
operator|->
name|n_alternatives
operator|=
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|->
name|constraints
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" \"\","
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" \"%s\","
argument_list|,
name|d
operator|->
name|constraints
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|n_operands
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" 0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\nconst char insn_operand_address_p[][MAX_RECOG_OPERANDS] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %d,"
argument_list|,
name|d
operator|->
name|address_p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|n_operands
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" 0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nconst enum machine_mode insn_operand_mode[][MAX_RECOG_OPERANDS] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %smode,"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|d
operator|->
name|modes
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|n_operands
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" VOIDmode"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nconst char insn_operand_strict_low[][MAX_RECOG_OPERANDS] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %d,"
argument_list|,
name|d
operator|->
name|strict_low
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|n_operands
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" 0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nint (*const insn_operand_predicate[][MAX_RECOG_OPERANDS])() =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|n_operands
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %s,"
argument_list|,
operator|(
operator|(
name|d
operator|->
name|predicates
index|[
name|i
index|]
operator|&&
name|d
operator|->
name|predicates
index|[
name|i
index|]
index|[
literal|0
index|]
operator|)
condition|?
name|d
operator|->
name|predicates
index|[
name|i
index|]
else|:
literal|"0"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|n_operands
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" 0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n#ifndef DEFAULT_MACHINE_INFO\n#define DEFAULT_MACHINE_INFO 0\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#endif\n\nconst INSN_MACHINE_INFO insn_machine_info[] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|d
operator|->
name|machine_info
condition|)
name|printf
argument_list|(
literal|"    {%s},\n"
argument_list|,
name|d
operator|->
name|machine_info
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"     { DEFAULT_MACHINE_INFO },\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nconst int insn_n_alternatives[] =\n  {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|insn_data
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|d
operator|->
name|n_alternatives
condition|)
name|printf
argument_list|(
literal|"    %d,\n"
argument_list|,
name|d
operator|->
name|n_alternatives
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"     0,\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  };\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* scan_operands (X) stores in max_opno the largest operand    number present in X, if that is larger than the previous    value of max_opno.  It stores all the constraints in `constraints'    and all the machine modes in `modes'.     THIS_ADDRESS_P is nonzero if the containing rtx was an ADDRESS.    THIS_STRICT_LOW is nonzero if the containing rtx was a STRICT_LOW_PART.  */
end_comment

begin_decl_stmt
name|int
name|max_opno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_dups
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|constraints
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|op_n_alternatives
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|predicates
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|address_p
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|machine_mode
name|modes
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|strict_low
index|[
name|MAX_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|scan_operands
parameter_list|(
name|part
parameter_list|,
name|this_address_p
parameter_list|,
name|this_strict_low
parameter_list|)
name|rtx
name|part
decl_stmt|;
name|int
name|this_address_p
decl_stmt|;
name|int
name|this_strict_low
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|part
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|part
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MATCH_OPERAND
condition|)
block|{
name|int
name|opno
init|=
name|XINT
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|opno
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|opno
expr_stmt|;
if|if
condition|(
name|max_opno
operator|>=
name|MAX_MAX_OPERANDS
condition|)
name|error
argument_list|(
literal|"Too many operands (%d) in one instruction pattern.\n"
argument_list|,
name|max_opno
operator|+
literal|1
argument_list|)
expr_stmt|;
name|modes
index|[
name|opno
index|]
operator|=
name|GET_MODE
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|strict_low
index|[
name|opno
index|]
operator|=
name|this_strict_low
expr_stmt|;
name|predicates
index|[
name|opno
index|]
operator|=
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|constraints
index|[
name|opno
index|]
operator|=
name|XSTR
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
operator|&&
operator|*
name|XSTR
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|op_n_alternatives
index|[
name|opno
index|]
operator|=
name|n_occurrences
argument_list|(
literal|','
argument_list|,
name|XSTR
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|have_constraints
operator|=
literal|1
expr_stmt|;
block|}
name|address_p
index|[
name|opno
index|]
operator|=
name|this_address_p
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|code
operator|==
name|MATCH_OPERATOR
condition|)
block|{
name|int
name|opno
init|=
name|XINT
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|opno
operator|>
name|max_opno
condition|)
name|max_opno
operator|=
name|opno
expr_stmt|;
if|if
condition|(
name|max_opno
operator|>=
name|MAX_MAX_OPERANDS
condition|)
name|error
argument_list|(
literal|"Too many operands (%d) in one instruction pattern.\n"
argument_list|,
name|max_opno
operator|+
literal|1
argument_list|)
expr_stmt|;
name|modes
index|[
name|opno
index|]
operator|=
name|GET_MODE
argument_list|(
name|part
argument_list|)
expr_stmt|;
name|strict_low
index|[
name|opno
index|]
operator|=
literal|0
expr_stmt|;
name|predicates
index|[
name|opno
index|]
operator|=
name|XSTR
argument_list|(
name|part
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|constraints
index|[
name|opno
index|]
operator|=
literal|0
expr_stmt|;
name|address_p
index|[
name|opno
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|part
argument_list|,
literal|2
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|XVECEXP
argument_list|(
name|part
argument_list|,
literal|2
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|code
operator|==
name|MATCH_DUP
condition|)
block|{
operator|++
name|num_dups
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|code
operator|==
name|ADDRESS
condition|)
block|{
name|scan_operands
argument_list|(
name|XEXP
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|code
operator|==
name|STRICT_LOW_PART
condition|)
block|{
name|scan_operands
argument_list|(
name|XEXP
argument_list|(
name|part
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|scan_operands
argument_list|(
name|XEXP
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|part
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|scan_operands
argument_list|(
name|XVECEXP
argument_list|(
name|part
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look at a define_insn just read.  Assign its code number.    Record on insn_data the template and the number of arguments.    If the insn has a hairy output action, output a function for now.  */
end_comment

begin_function
name|void
name|gen_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|struct
name|data
modifier|*
name|d
init|=
operator|(
expr|struct
name|data
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|data
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|d
operator|->
name|code_number
operator|=
name|next_code_number
operator|++
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
condition|)
name|d
operator|->
name|name
operator|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Build up the list in the same order as the insns are seen      in the machine description.  */
name|d
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|end_of_insn_data
condition|)
name|end_of_insn_data
operator|->
name|next
operator|=
name|d
expr_stmt|;
else|else
name|insn_data
operator|=
name|d
expr_stmt|;
name|end_of_insn_data
operator|=
name|d
expr_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|num_dups
operator|=
literal|0
expr_stmt|;
name|mybzero
argument_list|(
name|constraints
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|op_n_alternatives
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|predicates
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|address_p
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|modes
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|strict_low
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_operands
operator|=
name|max_opno
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|n_dups
operator|=
name|num_dups
expr_stmt|;
name|mybcopy
argument_list|(
name|constraints
argument_list|,
name|d
operator|->
name|constraints
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|mybcopy
argument_list|(
name|op_n_alternatives
argument_list|,
name|d
operator|->
name|op_n_alternatives
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|mybcopy
argument_list|(
name|predicates
argument_list|,
name|d
operator|->
name|predicates
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|mybcopy
argument_list|(
name|address_p
argument_list|,
name|d
operator|->
name|address_p
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|mybcopy
argument_list|(
name|modes
argument_list|,
name|d
operator|->
name|modes
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|mybcopy
argument_list|(
name|strict_low
argument_list|,
name|d
operator|->
name|strict_low
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
name|d
operator|->
name|machine_info
operator|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* We need to consider only the instructions whose assembler code template      starts with a *.  These are the ones where the template is really      C code to run to decide on a template to use.      So for all others just return now.  */
if|if
condition|(
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|3
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'*'
condition|)
block|{
name|d
operator|->
name|template
operator|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|d
operator|->
name|outfun
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|template
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|outfun
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"\nstatic char *\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"output_%d (operands, insn)\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx *operands;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
comment|/* The following is done in a funny way to get around problems in      VAX-11 "C" on VMS.  It is the equivalent of: 		printf ("%s\n",&(XSTR (insn, 3)[1])); */
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
operator|&
operator|(
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|3
argument_list|)
index|[
literal|1
index|]
operator|)
decl_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|putchar
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look at a define_peephole just read.  Assign its code number.    Record on insn_data the template and the number of arguments.    If the insn has a hairy output action, output it now.  */
end_comment

begin_function
name|void
name|gen_peephole
parameter_list|(
name|peep
parameter_list|)
name|rtx
name|peep
decl_stmt|;
block|{
specifier|register
name|struct
name|data
modifier|*
name|d
init|=
operator|(
expr|struct
name|data
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|data
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|d
operator|->
name|code_number
operator|=
name|next_code_number
operator|++
expr_stmt|;
name|d
operator|->
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Build up the list in the same order as the insns are seen      in the machine description.  */
name|d
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|end_of_insn_data
condition|)
name|end_of_insn_data
operator|->
name|next
operator|=
name|d
expr_stmt|;
else|else
name|insn_data
operator|=
name|d
expr_stmt|;
name|end_of_insn_data
operator|=
name|d
expr_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|mybzero
argument_list|(
name|constraints
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|op_n_alternatives
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
comment|/* Get the number of operands by scanning all the      patterns of the peephole optimizer.      But ignore all the rest of the information thus obtained.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|peep
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|XVECEXP
argument_list|(
name|peep
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_operands
operator|=
name|max_opno
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|n_dups
operator|=
literal|0
expr_stmt|;
name|mybcopy
argument_list|(
name|constraints
argument_list|,
name|d
operator|->
name|constraints
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|mybcopy
argument_list|(
name|op_n_alternatives
argument_list|,
name|d
operator|->
name|op_n_alternatives
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|d
operator|->
name|predicates
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|d
operator|->
name|address_p
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|d
operator|->
name|modes
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|d
operator|->
name|strict_low
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
name|d
operator|->
name|machine_info
operator|=
name|XSTR
argument_list|(
name|peep
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* We need to consider only the instructions whose assembler code template      starts with a *.  These are the ones where the template is really      C code to run to decide on a template to use.      So for all others just return now.  */
if|if
condition|(
name|XSTR
argument_list|(
name|peep
argument_list|,
literal|2
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'*'
condition|)
block|{
name|d
operator|->
name|template
operator|=
name|XSTR
argument_list|(
name|peep
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|d
operator|->
name|outfun
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|template
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|outfun
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"\nstatic char *\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"output_%d (operands, insn)\n"
argument_list|,
name|d
operator|->
name|code_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx *operands;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
operator|&
operator|(
name|XSTR
argument_list|(
name|peep
argument_list|,
literal|2
argument_list|)
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process a define_expand just read.  Assign its code number,    only for the purposes of `insn_gen_function'.  */
end_comment

begin_function
name|void
name|gen_expand
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|struct
name|data
modifier|*
name|d
init|=
operator|(
expr|struct
name|data
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|data
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|d
operator|->
name|code_number
operator|=
name|next_code_number
operator|++
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
condition|)
name|d
operator|->
name|name
operator|=
name|XSTR
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|name
operator|=
literal|0
expr_stmt|;
comment|/* Build up the list in the same order as the insns are seen      in the machine description.  */
name|d
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|end_of_insn_data
condition|)
name|end_of_insn_data
operator|->
name|next
operator|=
name|d
expr_stmt|;
else|else
name|insn_data
operator|=
name|d
expr_stmt|;
name|end_of_insn_data
operator|=
name|d
expr_stmt|;
name|max_opno
operator|=
operator|-
literal|1
expr_stmt|;
name|num_dups
operator|=
literal|0
expr_stmt|;
comment|/* Scan the operands to get the specified predicates and modes,      since expand_binop needs to know them.  */
name|mybzero
argument_list|(
name|predicates
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|modes
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
name|scan_operands
argument_list|(
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_operands
operator|=
name|max_opno
operator|+
literal|1
expr_stmt|;
name|mybcopy
argument_list|(
name|predicates
argument_list|,
name|d
operator|->
name|predicates
argument_list|,
sizeof|sizeof
name|predicates
argument_list|)
expr_stmt|;
name|mybcopy
argument_list|(
name|modes
argument_list|,
name|d
operator|->
name|modes
argument_list|,
sizeof|sizeof
name|modes
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|d
operator|->
name|constraints
argument_list|,
sizeof|sizeof
name|constraints
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|d
operator|->
name|op_n_alternatives
argument_list|,
sizeof|sizeof
name|op_n_alternatives
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|d
operator|->
name|address_p
argument_list|,
sizeof|sizeof
name|address_p
argument_list|)
expr_stmt|;
name|mybzero
argument_list|(
name|d
operator|->
name|strict_low
argument_list|,
sizeof|sizeof
name|strict_low
argument_list|)
expr_stmt|;
name|d
operator|->
name|n_dups
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|template
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|outfun
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|machine_info
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|xmalloc
parameter_list|(
name|size
parameter_list|)
block|{
specifier|register
name|int
name|val
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|int
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|result
init|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|mybzero
parameter_list|(
name|b
parameter_list|,
name|length
parameter_list|)
specifier|register
name|char
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
block|{
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
operator|*
name|b
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mybcopy
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|,
name|length
parameter_list|)
specifier|register
name|char
modifier|*
name|b1
decl_stmt|;
specifier|register
name|char
modifier|*
name|b2
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
block|{
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
operator|*
name|b2
operator|++
operator|=
operator|*
name|b1
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fatal
parameter_list|(
name|s
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"genoutput: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|error
parameter_list|(
name|s
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"genoutput: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|extern
name|rtx
name|read_rtx
parameter_list|()
function_decl|;
specifier|register
name|int
name|c
decl_stmt|;
name|obstack_init
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"No input file name."
argument_list|)
expr_stmt|;
name|infile
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|init_rtl
argument_list|()
expr_stmt|;
name|output_prologue
argument_list|()
expr_stmt|;
name|next_code_number
operator|=
literal|0
expr_stmt|;
name|have_constraints
operator|=
literal|0
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|desc
operator|=
name|read_rtx
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_INSN
condition|)
name|gen_insn
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_PEEPHOLE
condition|)
name|gen_peephole
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_EXPAND
condition|)
name|gen_expand
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
name|output_epilogue
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|n_occurrences
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|n
operator|+=
operator|(
operator|*
name|s
operator|++
operator|==
name|c
operator|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

end_unit

