begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Reload pseudo regs into hard regs for insns that require hard regs.    Copyright (C) 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|min
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)< (B) ? (A) : (B))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)> (B) ? (A) : (B))
end_define

begin_comment
comment|/* This file contains the reload pass of the compiler, which is    run after register allocation has been done.  It checks that    each insn is valid (operands required to be in registers really    are in registers of the proper class) and fixes up invalid ones    by copying values temporarily into registers for the insns    that need them.     The results of register allocation are described by the vector    reg_renumber; the insns still contain pseudo regs, but reg_renumber    can be used to find which hard reg, if any, a pseudo reg is in.     The technique we always use is to free up a few hard regs that are    called ``reload regs'', and for each place where a pseudo reg    must be in a hard reg, copy it temporarily into one of the reload regs.     All the pseudos that were formerly allocated to the hard regs that    are now in use as reload regs must be ``spilled''.  This means    that they go to other hard regs, or to stack slots if no other    available hard regs can be found.  Spilling can invalidate more    insns, requiring additional need for reloads, so we must keep checking    until the process stabilizes.     For machines with different classes of registers, we must keep track    of the register class needed for each reload, and make sure that    we allocate enough reload registers of each class.     The file reload.c contains the code that checks one insn for    validity and reports the reloads that it needs.  This file    is in charge of scanning the entire rtl code, accumulating the    reload needs, spilling, assigning reload registers to use for    fixing up each insn, and generating the new insns to copy values    into the reload registers.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* During reload_as_needed, element N contains a REG rtx for the hard reg    into which pseudo reg N has been reloaded (perhaps for a previous insn). */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_last_reload_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Elt N nonzero if reg_last_reload_reg[N] has been set in this insn    for an output reload that stores into reg N.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reg_has_output_reload
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Elt N nonzero if hard reg N is a reload-register for an output reload    in the current insn.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|reg_is_output_reload
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the constant value to which pseudo reg N is equivalent,    or zero if pseudo reg N is not equivalent to a constant.    find_reloads looks at this in order to replace pseudo reg N    with the constant it stands for.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_equiv_constant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the address of stack slot to which pseudo reg N is equivalent.    This is used when the address is not valid as a memory address    (because its displacement is too big for the machine.)  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_equiv_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the memory slot to which pseudo reg N is equivalent,    or zero if pseudo reg N is not equivalent to a memory slot.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|reg_equiv_mem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Widest width in which each pseudo reg is referred to (via subreg).  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_max_ref_width
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the insn that initialized reg N from its equivalent    constant or memory slot.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_equiv_init
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During reload_as_needed, element N contains the last pseudo regno    reloaded into the Nth reload register.  This vector is in parallel    with spill_regs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_reloaded_contents
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During reload_as_needed, element N contains the insn for which    the Nth reload register was last used.  This vector is in parallel    with spill_regs, and its contents are significant only when    reg_reloaded_contents is significant.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|reg_reloaded_insn
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of spill-regs so far; number of valid elements of spill_regs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_spills
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In parallel with spill_regs, contains REG rtx's for those regs.    Holds the last rtx used for any given reg, or 0 if it has never    been used for spilling yet.  This rtx is reused, provided it has    the proper mode.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|spill_reg_rtx
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In parallel with spill_regs, contains nonzero for a spill reg    that was stored after the last time it was used.    The precise value is the insn generated to do the store.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|spill_reg_store
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This table is the inverse mapping of spill_regs:    indexed by hard reg number,    it contains the position of that reg in spill_regs,    or -1 for something that is not in spill_regs.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|spill_reg_order
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This table contains 1 for a register that may not be used    for retrying global allocation, or -1 for a register that may be used.    The registers that may not be used include all spill registers    and the frame pointer (if we are using one).  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|forbidden_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Describes order of use of registers for reloading    of spilled pseudo-registers.  `spills' is the number of    elements that are actually valid; new ones are added at the end.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|spill_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Describes order of preference for putting regs into spill_regs.    Contains the numbers of all the hard regs, in order most preferred first.    This order is different for each function.    It is set up by order_regs_for_reload.    Empty elements at the end contain -1.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|potential_reload_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 for a hard register that appears explicitly in the rtl    (for example, function value registers, special registers    used by insns, structure value pointer registers).  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|regs_explicitly_used
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each register, 1 if it was counted against the need for    groups.  0 means it can count against max_nongroup instead.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|counted_for_groups
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each register, 1 if it was counted against the need for    non-groups.  0 means it can become part of a new group.    During choose_reload_regs, 1 here means don't use this reg    as part of a group, even if it seems to be otherwise ok.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|counted_for_nongroups
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if spilling (REG n) does not require reloading it into    a register in order to do (MEM (REG n)).  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|spill_indirect_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if an address (plus (reg frame_pointer) (reg ...)) is valid.  */
end_comment

begin_decl_stmt
name|char
name|double_reg_address_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the stack slot for each spilled hard register.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|spill_stack_slot
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Width allocated so far for that stack slot.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|spill_stack_slot_width
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by basic block number, nonzero if there is any need    for a spill register in that basic block.    The pointer is 0 if we did stupid allocation and don't know    the structure of basic blocks.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|basic_block_needs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First uid used by insns created by reload in this function.    Used in find_equiv_reg.  */
end_comment

begin_decl_stmt
name|int
name|reload_first_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag set by local-alloc or global-alloc if anything is live in    a call-clobbered reg across calls.  */
end_comment

begin_decl_stmt
name|int
name|caller_save_needed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 by alter_frame_pointer_addresses if it changes anything.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|frame_pointer_address_altered
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|mark_home_live
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|scan_paradoxical_subregs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reload_as_needed
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|modes_equiv_for_class_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|alter_frame_pointer_addresses
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|alter_reg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|new_spill_reg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spill_hard_reg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|choose_reload_regs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_reload_insns
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_output_reload
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|forget_old_reloads_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|order_regs_for_reload
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eliminate_frame_pointer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|inc_for_reload
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|constraint_accepts_reg_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|count_occurrences
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_input_reload
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|remove_death
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|rtx
name|adj_offsettable_operand
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Main entry point for the reload pass, and only entry point    in this file.     FIRST is the first insn of the function being compiled.     GLOBAL nonzero means we were called from global_alloc    and should attempt to reallocate any pseudoregs that we    displace from hard regs we will use for reloads.    If GLOBAL is zero, we do not have enough information to do that,    so any pseudo reg that is spilled must go to the stack.     DUMPFILE is the global-reg debugging dump file stream, or 0.    If it is nonzero, messages are written to it to describe    which registers are seized as reload regs, which pseudo regs    are spilled from them, and where the pseudo regs are reallocated to.  */
end_comment

begin_function
name|void
name|reload
parameter_list|(
name|first
parameter_list|,
name|global
parameter_list|,
name|dumpfile
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|int
name|global
decl_stmt|;
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
block|{
specifier|register
name|int
name|class
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|;
name|int
name|something_changed
decl_stmt|;
name|int
name|something_needs_reloads
decl_stmt|;
name|int
name|new_basic_block_needs
decl_stmt|;
comment|/* The basic block number currently being processed for INSN.  */
name|int
name|this_block
decl_stmt|;
comment|/* Often (MEM (REG n)) is still valid even if (REG n) is put on the stack.      Set spill_indirect_ok if so.  */
specifier|register
name|rtx
name|tem
init|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
literal|4
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|spill_indirect_ok
operator|=
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This way, we make sure that reg+reg is an offsettable address.  */
name|tem
operator|=
name|plus_constant
argument_list|(
name|tem
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|double_reg_address_ok
operator|=
name|memory_address_p
argument_list|(
name|QImode
argument_list|,
name|tem
argument_list|)
expr_stmt|;
comment|/* Enable find_equiv_reg to distinguish insns made by reload.  */
name|reload_first_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
name|basic_block_needs
operator|=
literal|0
expr_stmt|;
comment|/* Remember which hard regs appear explicitly      before we merge into `regs_ever_live' the ones in which      pseudo regs have been allocated.  */
name|bcopy
argument_list|(
name|regs_ever_live
argument_list|,
name|regs_explicitly_used
argument_list|,
sizeof|sizeof
name|regs_ever_live
argument_list|)
expr_stmt|;
comment|/* We don't have a stack slot for any spill reg yet.  */
name|bzero
argument_list|(
name|spill_stack_slot
argument_list|,
sizeof|sizeof
name|spill_stack_slot
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|spill_stack_slot_width
argument_list|,
sizeof|sizeof
name|spill_stack_slot_width
argument_list|)
expr_stmt|;
comment|/* Compute which hard registers are now in use      as homes for pseudo registers.      This is done here rather than (eg) in global_alloc      because this point is reached even if not optimizing.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
name|mark_home_live
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* Make sure that the last insn in the chain      is not something that needs reloading.  */
name|emit_note
argument_list|(
literal|0
argument_list|,
name|NOTE_INSN_DELETED
argument_list|)
expr_stmt|;
comment|/* Find all the pseudo registers that didn't get hard regs      but do have known equivalent constants or memory slots.      These include parameters (known equivalent to parameter slots)      and cse'd or loop-moved constant memory addresses.       Record constant equivalents in reg_equiv_constant      so they will be substituted by find_reloads.      Record memory equivalents in reg_mem_equiv so they can      be substituted eventually by altering the REG-rtx's.  */
name|reg_equiv_constant
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_equiv_constant
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_equiv_mem
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_equiv_mem
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_equiv_init
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_equiv_init
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_equiv_address
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_equiv_address
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_max_ref_width
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_max_ref_width
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Look for REG_EQUIV notes; record what each pseudo is equivalent to.      Also find all paradoxical subregs      and find largest such for each pseudo.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|rtx
name|x
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|i
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|reg_equiv_mem
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
else|else
name|reg_equiv_address
index|[
name|i
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|immediate_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|reg_equiv_constant
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
else|else
continue|continue;
name|reg_equiv_init
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|scan_paradoxical_subregs
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Does this function require a frame pointer?  */
name|frame_pointer_needed
operator||=
operator|(
operator|!
name|global
operator|||
name|FRAME_POINTER_REQUIRED
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
name|frame_pointer_needed
operator|=
name|check_frame_pointer_required
argument_list|(
name|reg_equiv_constant
argument_list|,
name|reg_equiv_mem
argument_list|,
name|reg_equiv_address
argument_list|)
expr_stmt|;
comment|/* Alter each pseudo-reg rtx to contain its hard reg number.      Delete initializations of pseudos that don't have hard regs      and do have equivalents.      Assign stack slots to the pseudos that lack hard regs or equivalents.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
name|alter_reg
argument_list|(
name|i
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|REGISTER_CONSTRAINTS
comment|/* If all the pseudo regs have hard regs,      except for those that are never referenced,      we know that no reloads are needed.  */
comment|/* But that is not true if there are register constraints, since      in that case some pseudos might be in the wrong kind of hard reg.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|==
operator|-
literal|1
operator|&&
name|reg_n_refs
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|max_regno
operator|&&
name|frame_pointer_needed
operator|&&
operator|!
name|caller_save_needed
condition|)
return|return;
endif|#
directive|endif
comment|/* Compute the order of preference for hard registers to spill.      Store them by decreasing preference in potential_reload_regs.  */
name|order_regs_for_reload
argument_list|()
expr_stmt|;
comment|/* So far, no hard regs have been spilled.  */
name|n_spills
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|spill_reg_order
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|forbidden_regs
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|caller_save_needed
condition|)
name|frame_pointer_needed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|forbidden_regs
index|[
name|FRAME_POINTER_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|spill_hard_reg
argument_list|(
name|FRAME_POINTER_REGNUM
argument_list|,
name|global
argument_list|,
name|dumpfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|global
condition|)
block|{
name|basic_block_needs
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|basic_block_needs
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
block|}
comment|/* This loop scans the entire function each go-round      and repeats until one repetition spills no additional hard regs.  */
comment|/* This flag is set when a psuedo reg is spilled,      to require another pass.  Note that getting an additional reload      reg does not necessarily imply any pseudo reg was spilled;      sometimes we find a reload reg that no pseudo reg was allocated in.  */
name|something_changed
operator|=
literal|1
expr_stmt|;
comment|/* This flag is set if there are any insns that require reloading.  */
name|something_needs_reloads
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|something_changed
condition|)
block|{
comment|/* For each class, number of reload regs needed in that class. 	 This is the maximum over all insns of the needs in that class 	 of the individual insn.  */
name|int
name|max_needs
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
comment|/* For each class, size of group of consecutive regs 	 that is needed for the reloads of this class.  */
name|int
name|group_size
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
comment|/* For each class, max number of consecutive groups needed. 	 (Each group contains max_needs_size[CLASS] consecutive registers.)  */
name|int
name|max_groups
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
comment|/* For each class, max number needed of regs that don't belong 	 to any of the groups.  */
name|int
name|max_nongroups
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
comment|/* For each class, the machine mode which requires consecutive 	 groups of regs of that class. 	 If two different modes ever require groups of one class, 	 they must be the same size and equally restrictive for that class, 	 otherwise we can't handle the complexity.  */
name|enum
name|machine_mode
name|group_mode
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
name|something_changed
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|max_needs
argument_list|,
sizeof|sizeof
name|max_needs
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|max_groups
argument_list|,
sizeof|sizeof
name|max_groups
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|max_nongroups
argument_list|,
sizeof|sizeof
name|max_nongroups
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|group_size
argument_list|,
sizeof|sizeof
name|group_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
name|group_mode
index|[
name|i
index|]
operator|=
name|VOIDmode
expr_stmt|;
comment|/* Keep track of which basic blocks are needing the reloads.  */
name|this_block
operator|=
literal|0
expr_stmt|;
comment|/* Remember whether any element of basic_block_needs 	 changes from 0 to 1 in this pass.  */
name|new_basic_block_needs
operator|=
literal|0
expr_stmt|;
comment|/* Compute the most additional registers needed by any instruction. 	 Collect information separately for each class of regs.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|after_call
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|global
operator|&&
name|this_block
operator|+
literal|1
operator|<
name|n_basic_blocks
operator|&&
name|insn
operator|==
name|basic_block_head
index|[
name|this_block
operator|+
literal|1
index|]
condition|)
operator|++
name|this_block
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
comment|/* Nonzero means don't use a reload reg that overlaps 		 the place where a function value can be returned.  */
name|rtx
name|avoid_return_reg
init|=
literal|0
decl_stmt|;
comment|/* Initially, count RELOAD_OTHER reloads. 		 Later, merge in the other kinds.  */
name|int
name|insn_needs
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
name|int
name|insn_groups
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
name|int
name|insn_total_groups
init|=
literal|0
decl_stmt|;
comment|/* Count RELOAD_FOR_INPUT_RELOAD_ADDRESS reloads.  */
name|int
name|insn_needs_for_inputs
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
name|int
name|insn_groups_for_inputs
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
name|int
name|insn_total_groups_for_inputs
init|=
literal|0
decl_stmt|;
comment|/* Count RELOAD_FOR_OUTPUT_RELOAD_ADDRESS reloads.  */
name|int
name|insn_needs_for_outputs
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
name|int
name|insn_groups_for_outputs
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
name|int
name|insn_total_groups_for_outputs
init|=
literal|0
decl_stmt|;
comment|/* Count RELOAD_FOR_OPERAND_ADDRESS reloads.  */
name|int
name|insn_needs_for_operands
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
name|int
name|insn_groups_for_operands
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
name|int
name|insn_total_groups_for_operands
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
name|insn_needs
index|[
name|i
index|]
operator|=
literal|0
operator|,
name|insn_groups
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|insn_needs_for_inputs
index|[
name|i
index|]
operator|=
literal|0
operator|,
name|insn_groups_for_inputs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|insn_needs_for_outputs
index|[
name|i
index|]
operator|=
literal|0
operator|,
name|insn_groups_for_outputs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|insn_needs_for_operands
index|[
name|i
index|]
operator|=
literal|0
operator|,
name|insn_groups_for_operands
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This wouldn't work nowadays, since optimize_bit_field 	  looks for non-strict memory addresses.  */
comment|/* Optimization: a bit-field instruction whose field 		 happens to be a byte or halfword in memory 		 can be changed to a move instruction.  */
block|if (GET_CODE (PATTERN (insn)) == SET) 		{ 		  rtx dest = SET_DEST (PATTERN (insn)); 		  rtx src = SET_SRC (PATTERN (insn));  		  if (GET_CODE (dest) == ZERO_EXTRACT 		      || GET_CODE (dest) == SIGN_EXTRACT) 		    optimize_bit_field (PATTERN (insn), insn, reg_equiv_mem); 		  if (GET_CODE (src) == ZERO_EXTRACT 		      || GET_CODE (src) == SIGN_EXTRACT) 		    optimize_bit_field (PATTERN (insn), insn, reg_equiv_mem); 		}
endif|#
directive|endif
comment|/* Set avoid_return_reg if this is an insn 		 that might use the value of a function call.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|after_call
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|after_call
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|after_call
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|after_call
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|stack_pointer_rtx
operator|)
condition|)
block|{
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|after_call
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|avoid_return_reg
operator|=
name|after_call
expr_stmt|;
name|after_call
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Analyze the instruction.  */
name|find_reloads
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|spill_indirect_ok
argument_list|,
name|global
argument_list|,
name|spill_reg_order
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_reloads
operator|==
literal|0
condition|)
continue|continue;
name|something_needs_reloads
operator|=
literal|1
expr_stmt|;
comment|/* Count each reload once in every class 		 containing the reload's own class.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
name|int
name|size
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
modifier|*
name|this_groups
decl_stmt|;
name|int
modifier|*
name|this_needs
decl_stmt|;
name|int
modifier|*
name|this_total_groups
decl_stmt|;
comment|/* Don't use dummy reloads in regs 		     being spilled in this block.  */
if|if
condition|(
name|reload_reg_rtx
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|global
operator|||
name|basic_block_needs
index|[
name|this_block
index|]
operator|)
operator|&&
name|spill_reg_order
index|[
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|i
index|]
argument_list|)
index|]
operator|>=
literal|0
condition|)
name|reload_reg_rtx
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Don't count the dummy reloads, for which one of the 		     regs mentioned in the insn can be used for reloading. 		     Don't count optional reloads. 		     Don't count reloads that got combined with others.  */
if|if
condition|(
name|reload_reg_rtx
index|[
name|i
index|]
operator|!=
literal|0
operator|||
name|reload_optional
index|[
name|i
index|]
operator|!=
literal|0
operator|||
operator|(
name|reload_out
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|reload_in
index|[
name|i
index|]
operator|==
literal|0
operator|)
condition|)
continue|continue;
comment|/* Decide which time-of-use to count this reload for.  */
switch|switch
condition|(
name|reload_when_needed
index|[
name|i
index|]
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
name|this_needs
operator|=
name|insn_needs
expr_stmt|;
name|this_groups
operator|=
name|insn_groups
expr_stmt|;
name|this_total_groups
operator|=
operator|&
name|insn_total_groups
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_RELOAD_ADDRESS
case|:
name|this_needs
operator|=
name|insn_needs_for_inputs
expr_stmt|;
name|this_groups
operator|=
name|insn_groups_for_inputs
expr_stmt|;
name|this_total_groups
operator|=
operator|&
name|insn_total_groups_for_inputs
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT_RELOAD_ADDRESS
case|:
name|this_needs
operator|=
name|insn_needs_for_outputs
expr_stmt|;
name|this_groups
operator|=
name|insn_groups_for_outputs
expr_stmt|;
name|this_total_groups
operator|=
operator|&
name|insn_total_groups_for_outputs
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
name|this_needs
operator|=
name|insn_needs_for_operands
expr_stmt|;
name|this_groups
operator|=
name|insn_groups_for_operands
expr_stmt|;
name|this_total_groups
operator|=
operator|&
name|insn_total_groups_for_operands
expr_stmt|;
break|break;
block|}
name|mode
operator|=
name|reload_inmode
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|reload_outmode
index|[
name|i
index|]
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
name|mode
operator|=
name|reload_outmode
index|[
name|i
index|]
expr_stmt|;
name|size
operator|=
name|CLASS_MAX_NREGS
argument_list|(
name|reload_reg_class
index|[
name|i
index|]
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|1
condition|)
block|{
comment|/* Count number of groups needed separately from 			 number of individual regs needed.  */
name|this_groups
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|i
index|]
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|this_groups
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|++
expr_stmt|;
operator|(
operator|*
name|this_total_groups
operator|)
operator|++
expr_stmt|;
comment|/* If a group of consecutive regs are needed, 			 record which machine mode needs them. 			 Crash if two dissimilar machine modes both need 			 groups of consecutive regs of the same class.  */
if|if
condition|(
name|group_mode
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|i
index|]
index|]
operator|!=
name|VOIDmode
operator|&&
operator|(
operator|!
name|modes_equiv_for_class_p
argument_list|(
name|group_mode
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|i
index|]
index|]
argument_list|,
name|mode
argument_list|,
name|reload_reg_class
index|[
name|i
index|]
argument_list|)
operator|||
name|group_size
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|i
index|]
index|]
operator|!=
name|size
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Record size and mode of a group of this class.  */
name|group_size
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|i
index|]
index|]
operator|=
name|size
expr_stmt|;
name|group_mode
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|i
index|]
index|]
operator|=
name|mode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|this_needs
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|i
index|]
index|]
operator|+=
literal|1
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|i
index|]
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|this_needs
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|+=
literal|1
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|global
condition|)
block|{
if|if
condition|(
operator|!
name|basic_block_needs
index|[
name|this_block
index|]
condition|)
name|new_basic_block_needs
operator|=
literal|1
expr_stmt|;
name|basic_block_needs
index|[
name|this_block
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* All reloads have been counted for this insn; 		 now merge the various times of use. 		 This sets insn_needs, etc., to the maximum total number 		 of registers needed at any point in this insn.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
name|int
name|this_max
decl_stmt|;
name|this_max
operator|=
name|insn_needs_for_inputs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|insn_needs_for_outputs
index|[
name|i
index|]
operator|>
name|this_max
condition|)
name|this_max
operator|=
name|insn_needs_for_outputs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|insn_needs_for_operands
index|[
name|i
index|]
operator|>
name|this_max
condition|)
name|this_max
operator|=
name|insn_needs_for_operands
index|[
name|i
index|]
expr_stmt|;
name|insn_needs
index|[
name|i
index|]
operator|+=
name|this_max
expr_stmt|;
name|this_max
operator|=
name|insn_groups_for_inputs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|insn_groups_for_outputs
index|[
name|i
index|]
operator|>
name|this_max
condition|)
name|this_max
operator|=
name|insn_groups_for_outputs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|insn_groups_for_operands
index|[
name|i
index|]
operator|>
name|this_max
condition|)
name|this_max
operator|=
name|insn_groups_for_operands
index|[
name|i
index|]
expr_stmt|;
name|insn_groups
index|[
name|i
index|]
operator|+=
name|this_max
expr_stmt|;
block|}
name|insn_total_groups
operator|+=
name|max
argument_list|(
name|insn_total_groups_for_inputs
argument_list|,
name|max
argument_list|(
name|insn_total_groups_for_outputs
argument_list|,
name|insn_total_groups_for_operands
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remember for later shortcuts which insns had any reloads.  */
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
name|n_reloads
condition|?
name|QImode
else|:
name|VOIDmode
argument_list|)
expr_stmt|;
comment|/* If this insn stores the value of a function call, 		 and that value is in a register that has been spilled, 		 and if the insn needs a reload in a class 		 that might use that register as the reload register, 		 then add add an extra need in that class. 		 This makes sure we have a register available that does 		 not overlap the return value.  */
if|if
condition|(
name|avoid_return_reg
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|avoid_return_reg
argument_list|)
decl_stmt|;
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|avoid_return_reg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|inc_groups
init|=
literal|0
decl_stmt|;
for|for
control|(
name|r
operator|=
name|regno
init|;
name|r
operator|<
name|regno
operator|+
name|nregs
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|spill_reg_order
index|[
name|r
index|]
operator|>=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|,
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|insn_needs
index|[
name|i
index|]
operator|>
literal|0
condition|)
name|insn_needs
index|[
name|i
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|insn_groups
index|[
name|i
index|]
operator|>
literal|0
operator|&&
name|nregs
operator|>
literal|1
condition|)
name|inc_groups
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|inc_groups
condition|)
name|insn_groups
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
comment|/* For each class, collect maximum need of any insn.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|max_needs
index|[
name|i
index|]
operator|<
name|insn_needs
index|[
name|i
index|]
condition|)
name|max_needs
index|[
name|i
index|]
operator|=
name|insn_needs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|max_groups
index|[
name|i
index|]
operator|<
name|insn_groups
index|[
name|i
index|]
condition|)
name|max_groups
index|[
name|i
index|]
operator|=
name|insn_groups
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|insn_total_groups
operator|>
literal|0
condition|)
if|if
condition|(
name|max_nongroups
index|[
name|i
index|]
operator|<
name|insn_needs
index|[
name|i
index|]
condition|)
name|max_nongroups
index|[
name|i
index|]
operator|=
name|insn_needs
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* Note that there is a continue statement above.  */
block|}
comment|/* Now deduct from the needs for the registers already 	 available (already spilled).  */
name|bzero
argument_list|(
name|counted_for_groups
argument_list|,
sizeof|sizeof
name|counted_for_groups
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|counted_for_nongroups
argument_list|,
sizeof|sizeof
name|counted_for_nongroups
argument_list|)
expr_stmt|;
comment|/* Find all consecutive groups of spilled registers 	 and mark each group off against the need for such groups.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|group_size
index|[
name|i
index|]
operator|>
literal|1
condition|)
block|{
name|char
name|regmask
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
name|bzero
argument_list|(
name|regmask
argument_list|,
sizeof|sizeof
name|regmask
argument_list|)
expr_stmt|;
comment|/* Make a mask of all the regs that are spill regs in class I.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_spills
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|,
name|spill_regs
index|[
name|j
index|]
argument_list|)
operator|&&
operator|!
name|counted_for_groups
index|[
name|spill_regs
index|[
name|j
index|]
index|]
condition|)
name|regmask
index|[
name|spill_regs
index|[
name|j
index|]
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Find each consecutive group of them.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|max_groups
index|[
name|i
index|]
operator|>
literal|0
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|regmask
index|[
name|j
index|]
operator|&&
name|j
operator|+
name|group_size
index|[
name|i
index|]
operator|<=
name|FIRST_PSEUDO_REGISTER
comment|/* Next line in case group-mode for this class 		     demands an even-odd pair.  */
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|j
argument_list|,
name|group_mode
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|group_size
index|[
name|i
index|]
condition|;
name|k
operator|++
control|)
if|if
condition|(
operator|!
name|regmask
index|[
name|j
operator|+
name|k
index|]
condition|)
break|break;
if|if
condition|(
name|k
operator|==
name|group_size
index|[
name|i
index|]
condition|)
block|{
comment|/* We found a group.  Mark it off against this class's 			 need for groups, and against each superclass too.  */
specifier|register
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
name|max_groups
index|[
name|i
index|]
operator|--
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|max_groups
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|--
expr_stmt|;
comment|/* Don't count these registers again.  */
name|counted_for_groups
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|group_size
index|[
name|i
index|]
condition|;
name|k
operator|++
control|)
name|counted_for_groups
index|[
name|j
operator|+
name|k
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|j
operator|+=
name|k
expr_stmt|;
block|}
block|}
comment|/* Now count all remaining spill regs against the individual need. 	 Those that weren't counted_for_groups in groups can also count against 	 the not-in-group need.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_spills
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
name|class
operator|=
operator|(
name|int
operator|)
name|REGNO_REG_CLASS
argument_list|(
name|spill_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|max_needs
index|[
name|class
index|]
operator|--
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|max_needs
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|counted_for_groups
index|[
name|spill_regs
index|[
name|i
index|]
index|]
condition|)
block|{
if|if
condition|(
name|max_nongroups
index|[
name|class
index|]
operator|>
literal|0
condition|)
name|counted_for_nongroups
index|[
name|spill_regs
index|[
name|i
index|]
index|]
operator|=
literal|1
expr_stmt|;
name|max_nongroups
index|[
name|class
index|]
operator|--
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
block|{
if|if
condition|(
name|max_nongroups
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|>
literal|0
condition|)
name|counted_for_nongroups
index|[
name|spill_regs
index|[
name|i
index|]
index|]
operator|=
literal|1
expr_stmt|;
name|max_nongroups
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|/* If all needs are met, we win.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|max_needs
index|[
name|i
index|]
operator|>
literal|0
operator|||
name|max_groups
index|[
name|i
index|]
operator|>
literal|0
operator|||
name|max_nongroups
index|[
name|i
index|]
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|N_REG_CLASSES
operator|&&
operator|!
name|new_basic_block_needs
condition|)
break|break;
comment|/* Not all needs are met; must spill more hard regs.  */
comment|/* If any element of basic_block_needs changed from 0 to 1, 	 re-spill all the regs already spilled.  This may spill 	 additional pseudos that didn't spill before.  */
if|if
condition|(
name|new_basic_block_needs
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_spills
condition|;
name|i
operator|++
control|)
name|something_changed
operator||=
name|spill_hard_reg
argument_list|(
name|spill_regs
index|[
name|i
index|]
argument_list|,
name|global
argument_list|,
name|dumpfile
argument_list|)
expr_stmt|;
comment|/* Now find more reload regs to satisfy the remaining need 	 Do it by ascending class number, since otherwise a reg 	 might be spilled for a big class and might fail to count 	 for a smaller class even though it belongs to that class.  	 Count spilled regs in `spills', and add entries to 	 `spill_regs' and `spill_reg_order'.  */
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|N_REG_CLASSES
condition|;
name|class
operator|++
control|)
block|{
comment|/* First get the groups of registers. 	     If we got single registers first, we might fragment 	     possible groups.  */
while|while
condition|(
name|max_groups
index|[
name|class
index|]
operator|>
literal|0
condition|)
block|{
comment|/* Groups of size 2 (the only groups used on most machines) 		 are treated specially.  */
if|if
condition|(
name|group_size
index|[
name|class
index|]
operator|==
literal|2
condition|)
block|{
comment|/* First, look for a register that will complete a group.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
name|potential_reload_regs
index|[
name|i
index|]
decl_stmt|;
name|int
name|other
decl_stmt|;
if|if
condition|(
name|j
operator|>=
literal|0
operator|&&
operator|!
name|fixed_regs
index|[
name|j
index|]
operator|&&
name|j
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
operator|!
name|regs_explicitly_used
index|[
name|j
index|]
operator|&&
operator|(
operator|(
name|j
operator|>
literal|0
operator|&&
operator|(
name|other
operator|=
name|j
operator|-
literal|1
operator|,
name|spill_reg_order
index|[
name|other
index|]
operator|>=
literal|0
operator|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|j
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|other
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|other
argument_list|,
name|group_mode
index|[
name|class
index|]
argument_list|)
operator|&&
operator|!
name|counted_for_nongroups
index|[
name|other
index|]
comment|/* We don't want one part of another group. 			       We could get "two groups" that overlap!  */
operator|&&
operator|!
name|counted_for_groups
index|[
name|other
index|]
operator|)
operator|||
operator|(
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
operator|&&
operator|(
name|other
operator|=
name|j
operator|+
literal|1
operator|,
name|spill_reg_order
index|[
name|other
index|]
operator|>=
literal|0
operator|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|j
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|other
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|j
argument_list|,
name|group_mode
index|[
name|class
index|]
argument_list|)
operator|&&
operator|!
name|counted_for_nongroups
index|[
name|other
index|]
operator|&&
operator|!
name|counted_for_groups
index|[
name|other
index|]
operator|)
operator|)
condition|)
block|{
specifier|register
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
comment|/* We have found one that will complete a group, 			     so count off one group as provided.  */
name|max_groups
index|[
name|class
index|]
operator|--
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|max_groups
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|--
expr_stmt|;
comment|/* Indicate both these regs are part of a group.  */
name|counted_for_groups
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
name|counted_for_groups
index|[
name|other
index|]
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* We can't complete a group, so start one.  */
if|if
condition|(
name|i
operator|==
name|FIRST_PSEUDO_REGISTER
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
name|potential_reload_regs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|j
operator|>=
literal|0
operator|&&
name|j
operator|+
literal|1
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|fixed_regs
index|[
name|j
index|]
operator|&&
name|j
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|spill_reg_order
index|[
name|j
index|]
operator|<
literal|0
operator|&&
name|spill_reg_order
index|[
name|j
operator|+
literal|1
index|]
operator|<
literal|0
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|j
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|j
operator|+
literal|1
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|j
argument_list|,
name|group_mode
index|[
name|class
index|]
argument_list|)
operator|&&
operator|!
name|counted_for_nongroups
index|[
name|j
operator|+
literal|1
index|]
condition|)
break|break;
block|}
comment|/* I should be the index in potential_reload_regs 		     of the new reload reg we have found.  */
name|something_changed
operator||=
name|new_spill_reg
argument_list|(
name|i
argument_list|,
name|class
argument_list|,
name|max_needs
argument_list|,
literal|0
argument_list|,
name|global
argument_list|,
name|dumpfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For groups of more than 2 registers, 		     look for a sufficient sequence of unspilled registers, 		     and spill them all at once.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
name|potential_reload_regs
index|[
name|i
index|]
decl_stmt|;
name|int
name|k
decl_stmt|;
if|if
condition|(
name|j
operator|>=
literal|0
operator|&&
name|j
operator|+
literal|1
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|j
argument_list|,
name|group_mode
index|[
name|class
index|]
argument_list|)
condition|)
block|{
comment|/* Check each reg in the sequence.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|group_size
index|[
name|class
index|]
condition|;
name|k
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|spill_reg_order
index|[
name|j
operator|+
name|k
index|]
operator|<
literal|0
operator|&&
operator|!
name|fixed_regs
index|[
name|j
operator|+
name|k
index|]
operator|&&
name|j
operator|+
name|k
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|j
operator|+
name|k
argument_list|)
operator|)
condition|)
break|break;
comment|/* We got a full sequence, so spill them all.  */
if|if
condition|(
name|k
operator|==
name|group_size
index|[
name|class
index|]
condition|)
block|{
specifier|register
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|group_size
index|[
name|class
index|]
condition|;
name|k
operator|++
control|)
block|{
name|int
name|idx
decl_stmt|;
name|counted_for_groups
index|[
name|j
operator|+
name|k
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|idx
operator|++
control|)
if|if
condition|(
name|potential_reload_regs
index|[
name|idx
index|]
operator|==
name|j
operator|+
name|k
condition|)
break|break;
name|something_changed
operator||=
name|new_spill_reg
argument_list|(
name|idx
argument_list|,
name|class
argument_list|,
name|max_needs
argument_list|,
literal|0
argument_list|,
name|global
argument_list|,
name|dumpfile
argument_list|)
expr_stmt|;
block|}
comment|/* We have found one that will complete a group, 				 so count off one group as provided.  */
name|max_groups
index|[
name|class
index|]
operator|--
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|max_groups
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|--
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/* Now similarly satisfy all need for single registers.  */
while|while
condition|(
name|max_needs
index|[
name|class
index|]
operator|>
literal|0
operator|||
name|max_nongroups
index|[
name|class
index|]
operator|>
literal|0
condition|)
block|{
comment|/* Consider the potential reload regs that aren't 		 yet in use as reload regs, in order of preference. 		 Find the most preferred one that's in this class.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|potential_reload_regs
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|potential_reload_regs
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
comment|/* I should be the index in potential_reload_regs 		 of the new reload reg we have found.  */
name|something_changed
operator||=
name|new_spill_reg
argument_list|(
name|i
argument_list|,
name|class
argument_list|,
name|max_needs
argument_list|,
name|max_nongroups
argument_list|,
name|global
argument_list|,
name|dumpfile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Insert code to save and restore call-clobbered hard regs      around calls.  */
if|if
condition|(
name|caller_save_needed
condition|)
name|save_call_clobbered_regs
argument_list|()
expr_stmt|;
comment|/* Now we know for certain whether we have a frame pointer.      If not, correct all references to go through the stack pointer.      This must be done before reloading, since reloading could generate      insns where sp+const cannot validly replace the frame pointer.      *This will lose if an insn might need more spill regs after      frame pointer elimination than it needed before.*  */
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
name|eliminate_frame_pointer
argument_list|(
name|first
argument_list|)
expr_stmt|;
comment|/* Use the reload registers where necessary      by generating move instructions to move the must-be-register      values into or out of the reload registers.  */
if|if
condition|(
name|something_needs_reloads
condition|)
name|reload_as_needed
argument_list|(
name|first
argument_list|,
name|global
argument_list|)
expr_stmt|;
comment|/* Now eliminate all pseudo regs by modifying them into      their equivalent memory references.      The REG-rtx's for the pseudos are modified in place,      so all insns that used to refer to them now refer to memory.       For a reg that has a reg_equiv_address, all those insns      were changed by reloading so that no insns refer to it any longer;      but the DECL_RTL of a variable decl may refer to it,      and if so this causes the debugging info to mention the variable.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|addr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reg_equiv_mem
index|[
name|i
index|]
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|reg_equiv_mem
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_equiv_address
index|[
name|i
index|]
condition|)
name|addr
operator|=
name|reg_equiv_address
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
name|FIX_FRAME_POINTER_ADDRESS
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
condition|)
block|{
name|rtx
name|reg
init|=
name|regno_reg_rtx
index|[
name|i
index|]
decl_stmt|;
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|=
name|addr
expr_stmt|;
name|REG_USERVAR_P
argument_list|(
name|reg
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PUT_CODE
argument_list|(
name|reg
argument_list|,
name|MEM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg_equiv_mem
index|[
name|i
index|]
condition|)
name|XEXP
argument_list|(
name|reg_equiv_mem
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
operator|=
name|addr
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* 1 if two machine modes MODE0 and MODE1 are equivalent    as far as HARD_REGNO_MODE_OK is concerned    for registers in class CLASS.  */
end_comment

begin_function
specifier|static
name|int
name|modes_equiv_for_class_p
parameter_list|(
name|mode0
parameter_list|,
name|mode1
parameter_list|,
name|class
parameter_list|)
name|enum
name|machine_mode
name|mode0
decl_stmt|,
name|mode1
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
block|{
comment|/* If any reg in CLASS allows one mode but not the other, fail. 	 Or if the two modes have different sizes in that reg, fail.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
argument_list|)
operator|&&
operator|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode0
argument_list|)
operator|!=
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode1
argument_list|)
operator|)
operator|&&
operator|(
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode0
argument_list|)
operator|!=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode1
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Add a new register to the tables of available spill-registers     (as well as spilling all pseudos allocated to the register).    I is the index of this register in potential_reload_regs.    CLASS is the regclass whose need is being satisfied.    MAX_NEEDS and MAX_NONGROUPS are the vectors of needs,     so that this register can count off against them.     MAX_NONGROUPS is 0 if this register is part of a group.    GLOBAL and DUMPFILE are the same as the args that `reload' got.  */
end_comment

begin_function
specifier|static
name|int
name|new_spill_reg
parameter_list|(
name|i
parameter_list|,
name|class
parameter_list|,
name|max_needs
parameter_list|,
name|max_nongroups
parameter_list|,
name|global
parameter_list|,
name|dumpfile
parameter_list|)
name|int
name|i
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
modifier|*
name|max_needs
decl_stmt|;
name|int
modifier|*
name|max_nongroups
decl_stmt|;
name|int
name|global
decl_stmt|;
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
block|{
specifier|register
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|regno
init|=
name|potential_reload_regs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Caller failed to find any register.  */
comment|/* Make reg REGNO an additional reload reg.  */
name|potential_reload_regs
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|spill_regs
index|[
name|n_spills
index|]
operator|=
name|regno
expr_stmt|;
name|spill_reg_order
index|[
name|regno
index|]
operator|=
name|n_spills
expr_stmt|;
name|forbidden_regs
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dumpfile
condition|)
name|fprintf
argument_list|(
name|dumpfile
argument_list|,
literal|"Spilling reg %d.\n"
argument_list|,
name|spill_regs
index|[
name|n_spills
index|]
argument_list|)
expr_stmt|;
comment|/* Clear off the needs we just satisfied.  */
name|max_needs
index|[
name|class
index|]
operator|--
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|max_needs
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|max_nongroups
operator|&&
name|max_nongroups
index|[
name|class
index|]
operator|>
literal|0
condition|)
block|{
name|counted_for_nongroups
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
name|max_nongroups
index|[
name|class
index|]
operator|--
expr_stmt|;
name|p
operator|=
name|reg_class_superclasses
index|[
name|class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|max_nongroups
index|[
operator|(
name|int
operator|)
operator|*
name|p
operator|++
index|]
operator|--
expr_stmt|;
block|}
comment|/* Spill every pseudo reg that was allocated to this reg      or to something that overlaps this reg.  */
name|val
operator|=
name|spill_hard_reg
argument_list|(
name|spill_regs
index|[
name|n_spills
index|]
argument_list|,
name|global
argument_list|,
name|dumpfile
argument_list|)
expr_stmt|;
name|regs_ever_live
index|[
name|spill_regs
index|[
name|n_spills
index|]
index|]
operator|=
literal|1
expr_stmt|;
name|n_spills
operator|++
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan all insns, computing the stack depth, and convert all    frame-pointer-relative references to stack-pointer-relative references.  */
end_comment

begin_function
specifier|static
name|void
name|eliminate_frame_pointer
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|int
name|max_uid
init|=
name|get_max_uid
argument_list|()
decl_stmt|;
name|int
modifier|*
name|label_depth
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_uid
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max_uid
condition|;
name|i
operator|++
control|)
name|label_depth
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* In this loop, for each forward branch we record the stack      depth of the label it jumps to.  We take advantage of the fact      that the stack depth at a label reached by a backward branch      is always, in GCC output, equal to the stack depth of the preceding      unconditional jump, because it was either a loop statement or      statement label.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|pattern
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|INSN
case|:
name|frame_pointer_address_altered
operator|=
literal|0
expr_stmt|;
name|alter_frame_pointer_addresses
argument_list|(
name|pattern
argument_list|,
name|depth
argument_list|)
expr_stmt|;
comment|/* Rerecognize insn if changed.  */
if|if
condition|(
name|frame_pointer_address_altered
condition|)
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Notice pushes and pops; update DEPTH.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SET
condition|)
block|{
ifdef|#
directive|ifdef
name|PUSH_ROUNDING
if|if
condition|(
name|push_operand
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
argument_list|)
condition|)
name|depth
operator|+=
name|PUSH_ROUNDING
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
condition|)
block|{
name|int
name|delta
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|delta
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|delta
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|depth
operator|-=
name|delta
expr_stmt|;
else|#
directive|else
name|depth
operator|+=
name|delta
expr_stmt|;
endif|#
directive|endif
block|}
block|}
break|break;
case|case
name|JUMP_INSN
case|:
name|frame_pointer_address_altered
operator|=
literal|0
expr_stmt|;
name|alter_frame_pointer_addresses
argument_list|(
name|pattern
argument_list|,
name|depth
argument_list|)
expr_stmt|;
comment|/* Rerecognize insn if changed.  */
if|if
condition|(
name|frame_pointer_address_altered
condition|)
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|ADDR_VEC
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|label_depth
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
name|depth
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
name|label_depth
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
name|depth
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
name|label_depth
index|[
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
name|depth
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
name|label_depth
index|[
name|INSN_UID
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
index|]
operator|=
name|depth
expr_stmt|;
else|else
break|break;
case|case
name|CODE_LABEL
case|:
if|if
condition|(
name|label_depth
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|>=
literal|0
condition|)
name|depth
operator|=
name|label_depth
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
name|CALL_INSN
case|:
name|frame_pointer_address_altered
operator|=
literal|0
expr_stmt|;
name|alter_frame_pointer_addresses
argument_list|(
name|pattern
argument_list|,
name|depth
argument_list|)
expr_stmt|;
comment|/* Rerecognize insn if changed.  */
if|if
condition|(
name|frame_pointer_address_altered
condition|)
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Walk the rtx X, converting all frame-pointer refs to stack-pointer refs    on the assumption that the current temporary stack depth is DEPTH.    (The size of saved registers must be added to DEPTH    to get the actual offset between the logical frame-pointer and the    stack pointer.  FIX_FRAME_POINTER_ADDRESS takes care of that.)  */
end_comment

begin_function
specifier|static
name|rtx
name|alter_frame_pointer_addresses
parameter_list|(
name|x
parameter_list|,
name|depth
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
return|return
name|x
return|;
case|case
name|REG
case|:
comment|/* Frame ptr can occur outside a PLUS if a stack slot 	 can occur with offset 0.  */
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
condition|)
block|{
name|rtx
name|oldx
init|=
name|x
decl_stmt|;
name|FIX_FRAME_POINTER_ADDRESS
argument_list|(
name|x
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|oldx
condition|)
name|frame_pointer_address_altered
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|x
return|;
case|case
name|MEM
case|:
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|rtx
name|old_addr
init|=
name|addr
decl_stmt|;
name|FIX_FRAME_POINTER_ADDRESS
argument_list|(
name|addr
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|old_addr
condition|)
name|frame_pointer_address_altered
operator|=
literal|1
expr_stmt|;
comment|/* These MEMs are normally shared.  Make a changed copy; 	   don't alter the shared MEM, since it needs to be altered 	   differently each time it occurs (since DEPTH varies).  */
name|mem
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
case|case
name|PLUS
case|:
block|{
name|rtx
name|oldx
init|=
name|x
decl_stmt|;
comment|/* Handle addresses being loaded or pushed, etc., 	   rather than referenced.  */
name|FIX_FRAME_POINTER_ADDRESS
argument_list|(
name|x
argument_list|,
name|depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|oldx
condition|)
name|frame_pointer_address_altered
operator|=
literal|1
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|alter_frame_pointer_addresses
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|depth
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|alter_frame_pointer_addresses
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Modify the home of pseudo-reg I.    The new home is present in reg_renumber[I].     FROM_REG may be the hard reg that the pseudo-reg is being spilled from;    or it may be -1, meaning there is none or it is not relevant.    This is used so that all pseudos spilled from a given hard reg    can share one stack slot.  */
end_comment

begin_function
specifier|static
name|void
name|alter_reg
parameter_list|(
name|i
parameter_list|,
name|from_reg
parameter_list|)
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|from_reg
decl_stmt|;
block|{
comment|/* When outputting an inline function, this can happen      for a reg that isn't actually used.  */
if|if
condition|(
name|regno_reg_rtx
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return;
comment|/* If the reg got changed to a MEM at rtl-generation time,      ignore it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
operator|!=
name|REG
condition|)
return|return;
comment|/* Modify the reg-rtx to contain the new hard reg      number or else to contain its pseudo reg number.  */
name|REGNO
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
operator|=
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|?
name|reg_renumber
index|[
name|i
index|]
else|:
name|i
expr_stmt|;
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_init
index|[
name|i
index|]
condition|)
block|{
comment|/* Delete the insn that loads the pseudo register.  */
name|PUT_CODE
argument_list|(
name|reg_equiv_init
index|[
name|i
index|]
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|reg_equiv_init
index|[
name|i
index|]
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|reg_equiv_init
index|[
name|i
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we have a pseudo that is needed but has no hard reg or equivalent,      allocate a stack slot for it.  */
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|reg_n_refs
index|[
name|i
index|]
operator|>
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|reg_equiv_mem
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|reg_equiv_address
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
specifier|register
name|rtx
name|x
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|inherent_size
init|=
name|PSEUDO_REGNO_BYTES
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|total_size
init|=
name|max
argument_list|(
name|inherent_size
argument_list|,
name|reg_max_ref_width
index|[
name|i
index|]
argument_list|)
decl_stmt|;
comment|/* Each pseudo reg has an inherent size which comes from its own mode, 	 and a total size which provides room for paradoxical subregs 	 which refer to the pseudo reg in wider modes.  	 We can use a slot already allocated if it provides both 	 enough inherent space and enough total space. 	 Otherwise, we allocate a new slot, making sure that it has no less 	 inherent space, and no less total space, then the previous slot.  */
if|if
condition|(
name|from_reg
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* No known place to spill from => no slot to reuse.  */
name|x
operator|=
name|assign_stack_local
argument_list|(
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
comment|/* Cancel the  big-endian correction done in assign_stack_local. 	     Get the address of the beginning of the slot. 	     This is so we can do a big-endian correction unconditionally 	     below.  */
name|x
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|inherent_size
operator|-
name|total_size
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Reuse a stack slot if possible.  */
elseif|else
if|if
condition|(
name|spill_stack_slot
index|[
name|from_reg
index|]
operator|!=
literal|0
operator|&&
name|spill_stack_slot_width
index|[
name|from_reg
index|]
operator|>=
name|total_size
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|spill_stack_slot
index|[
name|from_reg
index|]
argument_list|)
argument_list|)
operator|>=
name|inherent_size
operator|)
condition|)
name|x
operator|=
name|spill_stack_slot
index|[
name|from_reg
index|]
expr_stmt|;
comment|/* Allocate a new or bigger slot.  */
else|else
block|{
comment|/* Compute maximum size needed, both for inherent size 	     and for total size.  */
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|spill_stack_slot
index|[
name|from_reg
index|]
condition|)
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|spill_stack_slot
index|[
name|from_reg
index|]
argument_list|)
argument_list|)
operator|>
name|inherent_size
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|spill_stack_slot
index|[
name|from_reg
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|spill_stack_slot_width
index|[
name|from_reg
index|]
operator|>
name|total_size
condition|)
name|total_size
operator|=
name|spill_stack_slot_width
index|[
name|from_reg
index|]
expr_stmt|;
block|}
comment|/* Make a slot with that size.  */
name|x
operator|=
name|assign_stack_local
argument_list|(
name|mode
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
comment|/* Cancel the  big-endian correction done in assign_stack_local. 	     Get the address of the beginning of the slot. 	     This is so we can do a big-endian correction unconditionally 	     below.  */
name|x
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|total_size
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|spill_stack_slot
index|[
name|from_reg
index|]
operator|=
name|x
expr_stmt|;
name|spill_stack_slot_width
index|[
name|from_reg
index|]
operator|=
name|total_size
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
comment|/* On a big endian machine, the "address" of the slot 	 is the address of the low part that fits its inherent mode.  */
if|if
condition|(
name|inherent_size
operator|<
name|total_size
condition|)
name|x
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|total_size
operator|-
name|inherent_size
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BYTES_BIG_ENDIAN */
name|addr
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the stack slot is directly addressable, substitute 	 the MEM we just got directly for the old REG. 	 Otherwise, record the address; we will generate hairy code 	 to compute the address in a register each time it is needed.  */
if|if
condition|(
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|,
name|addr
argument_list|)
condition|)
name|reg_equiv_mem
index|[
name|i
index|]
operator|=
name|x
expr_stmt|;
else|else
name|reg_equiv_address
index|[
name|i
index|]
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark the slots in regs_ever_live for the hard regs    used by pseudo-reg number REGNO.  */
end_comment

begin_function
name|void
name|mark_home_live
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|lim
decl_stmt|;
name|i
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return;
name|lim
operator|=
name|i
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|lim
condition|)
name|regs_ever_live
index|[
name|i
operator|++
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Kick all pseudos out of hard register REGNO.    If GLOBAL is nonzero, try to find someplace else to put them.    If DUMPFILE is nonzero, log actions taken on that file.     Return nonzero if any pseudos needed to be kicked out    or if this hard reg may appear explicitly in some instructions.  */
end_comment

begin_function
specifier|static
name|int
name|spill_hard_reg
parameter_list|(
name|regno
parameter_list|,
name|global
parameter_list|,
name|dumpfile
parameter_list|)
specifier|register
name|int
name|regno
decl_stmt|;
name|int
name|global
decl_stmt|;
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
block|{
name|int
name|something_changed
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Spill every pseudo reg that was allocated to this reg      or to something that overlaps this reg.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
name|reg_renumber
index|[
name|i
index|]
operator|<=
name|regno
operator|&&
operator|(
name|reg_renumber
index|[
name|i
index|]
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|reg_renumber
index|[
name|i
index|]
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|i
argument_list|)
argument_list|)
operator|>
name|regno
operator|)
condition|)
block|{
comment|/* If this register belongs solely to a basic block 	   which needed no spilling, leave it be.  */
if|if
condition|(
name|regno
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|basic_block_needs
operator|&&
name|reg_basic_block
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
name|basic_block_needs
index|[
name|reg_basic_block
index|[
name|i
index|]
index|]
operator|==
literal|0
condition|)
continue|continue;
comment|/* Mark it as no longer having a hard register home.  */
name|reg_renumber
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We will need to scan everything again.  */
name|something_changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|global
condition|)
block|{
name|retry_global_alloc
argument_list|(
name|i
argument_list|,
name|forbidden_regs
argument_list|)
expr_stmt|;
comment|/* Update regs_ever_live for new home (if any).  */
name|mark_home_live
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* If something gets spilled to the stack, 	       we must have a frame pointer, so spill the frame pointer.  */
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|==
operator|-
literal|1
operator|&&
operator|!
name|frame_pointer_needed
condition|)
block|{
name|frame_pointer_needed
operator|=
literal|1
expr_stmt|;
name|forbidden_regs
index|[
name|FRAME_POINTER_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|spill_hard_reg
argument_list|(
name|FRAME_POINTER_REGNUM
argument_list|,
name|global
argument_list|,
name|dumpfile
argument_list|)
expr_stmt|;
block|}
block|}
name|alter_reg
argument_list|(
name|i
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|dumpfile
condition|)
block|{
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|dumpfile
argument_list|,
literal|" Register %d now on stack.\n\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dumpfile
argument_list|,
literal|" Register %d now in %d.\n\n"
argument_list|,
name|i
argument_list|,
name|reg_renumber
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|something_changed
operator|||
name|regs_explicitly_used
index|[
name|regno
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all paradoxical subregs within X and update reg_max_ref_width.  */
end_comment

begin_function
specifier|static
name|rtx
name|scan_paradoxical_subregs
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|REG
case|:
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
return|return;
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
condition|)
name|reg_max_ref_width
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|scan_paradoxical_subregs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|scan_paradoxical_subregs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|hard_reg_n_uses
block|{
name|int
name|regno
decl_stmt|;
name|int
name|uses
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|hard_reg_use_compare
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|struct
name|hard_reg_n_uses
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|tem
init|=
name|p1
operator|->
name|uses
operator|-
name|p2
operator|->
name|uses
decl_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
comment|/* If regs are equally good, sort by regno,      so that the results of qsort leave nothing to chance.  */
return|return
name|p1
operator|->
name|regno
operator|-
name|p2
operator|->
name|regno
return|;
block|}
end_block

begin_comment
comment|/* Choose the order to consider regs for use as reload registers    based on how much trouble would be caused by spilling one.    Store them in order of decreasing preference in potential_reload_regs.  */
end_comment

begin_function
specifier|static
name|void
name|order_regs_for_reload
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|o
init|=
literal|0
decl_stmt|;
name|int
name|large
init|=
literal|0
decl_stmt|;
name|struct
name|hard_reg_n_uses
name|hard_reg_n_uses
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|potential_reload_regs
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Count number of uses of each hard reg by pseudo regs allocated to it      and then order them by decreasing use.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|uses
operator|=
literal|0
expr_stmt|;
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|regno
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
name|int
name|regno
init|=
name|reg_renumber
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|int
name|lim
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|lim
condition|)
name|hard_reg_n_uses
index|[
name|regno
operator|++
index|]
operator|.
name|uses
operator|+=
name|reg_n_refs
index|[
name|i
index|]
expr_stmt|;
block|}
name|large
operator|+=
name|reg_n_refs
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Now fixed registers (which cannot safely be used for reloading)      get a very high use count so they will be considered least desirable.      Registers used explicitly in the rtl code are almost as bad.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fixed_regs
index|[
name|i
index|]
condition|)
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|uses
operator|+=
name|large
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|regs_explicitly_used
index|[
name|i
index|]
condition|)
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|uses
operator|+=
name|large
operator|+
literal|1
expr_stmt|;
block|}
name|hard_reg_n_uses
index|[
name|FRAME_POINTER_REGNUM
index|]
operator|.
name|uses
operator|+=
name|large
operator|+
literal|2
expr_stmt|;
name|qsort
argument_list|(
name|hard_reg_n_uses
argument_list|,
name|FIRST_PSEUDO_REGISTER
argument_list|,
sizeof|sizeof
name|hard_reg_n_uses
index|[
literal|0
index|]
argument_list|,
name|hard_reg_use_compare
argument_list|)
expr_stmt|;
comment|/* Prefer registers not so far used, for use in temporary loading.      Among them, prefer registers not preserved by calls.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
name|int
name|regno
init|=
name|reg_alloc_order
index|[
name|i
index|]
decl_stmt|;
else|#
directive|else
name|int
name|regno
init|=
name|i
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|==
literal|0
operator|&&
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
condition|)
name|potential_reload_regs
index|[
name|o
operator|++
index|]
operator|=
name|regno
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
name|int
name|regno
init|=
name|reg_alloc_order
index|[
name|i
index|]
decl_stmt|;
else|#
directive|else
name|int
name|regno
init|=
name|i
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|==
literal|0
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|&&
name|regno
operator|!=
name|FRAME_POINTER_REGNUM
condition|)
name|potential_reload_regs
index|[
name|o
operator|++
index|]
operator|=
name|regno
expr_stmt|;
block|}
comment|/* Now add the regs that are already used,      preferring those used less often.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|regno
index|]
operator|!=
literal|0
condition|)
name|potential_reload_regs
index|[
name|o
operator|++
index|]
operator|=
name|hard_reg_n_uses
index|[
name|i
index|]
operator|.
name|regno
expr_stmt|;
if|#
directive|if
literal|0
comment|/* For regs that are used, don't prefer those not preserved by calls      because those are likely to contain high priority things      that are live for short periods of time.  */
block|for (i = FIRST_PSEUDO_REGISTER - 1; i>= 0; i--)     if (regs_ever_live[i] != 0&& ! call_used_regs[i])       potential_reload_regs[o++] = i;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reload pseudo-registers into hard regs around each insn as needed.    Additional register load insns are output before the insn that needs it    and perhaps store insns after insns that modify the reloaded pseudo reg.     reg_last_reload_reg and reg_reloaded_contents keep track of    which pseudo-registers are already available in reload registers.    We update these for the reloads that we perform,    as the insns are scanned.  */
end_comment

begin_function
specifier|static
name|void
name|reload_as_needed
parameter_list|(
name|first
parameter_list|,
name|live_known
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|int
name|live_known
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|this_block
init|=
literal|0
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|after_call
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
name|spill_reg_rtx
argument_list|,
sizeof|sizeof
name|spill_reg_rtx
argument_list|)
expr_stmt|;
name|reg_last_reload_reg
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_last_reload_reg
argument_list|,
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_has_output_reload
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_spills
condition|;
name|i
operator|++
control|)
block|{
name|reg_reloaded_contents
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_reloaded_insn
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
control|)
block|{
specifier|register
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Notice when we move to a new basic block.  */
if|if
condition|(
name|basic_block_needs
operator|&&
name|this_block
operator|+
literal|1
operator|<
name|n_basic_blocks
operator|&&
name|insn
operator|==
name|basic_block_head
index|[
name|this_block
operator|+
literal|1
index|]
condition|)
operator|++
name|this_block
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|avoid_return_reg
init|=
literal|0
decl_stmt|;
comment|/* If insn has no reloads, we want these to be zero, down below.  */
name|bzero
argument_list|(
name|reg_has_output_reload
argument_list|,
name|max_regno
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_is_output_reload
argument_list|,
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
comment|/* Set avoid_return_reg if this is an insn 	     that might use the value of a function call.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|after_call
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|after_call
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|after_call
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|after_call
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|stack_pointer_rtx
operator|)
condition|)
block|{
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|after_call
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|avoid_return_reg
operator|=
name|after_call
expr_stmt|;
name|after_call
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|VOIDmode
condition|)
name|n_reloads
operator|=
literal|0
expr_stmt|;
comment|/* First find the pseudo regs that must be reloaded for this insn. 	     This info is returned in the tables reload_... (see reload.h). 	     Also modify the body of INSN by substituting RELOAD 	     rtx's for those pseudo regs.  */
else|else
name|find_reloads
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|spill_indirect_ok
argument_list|,
name|live_known
argument_list|,
name|spill_reg_order
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_reloads
operator|>
literal|0
condition|)
block|{
comment|/* If this block has not had spilling done, 		 deactivate any optional reloads lest they 		 try to use a spill-reg which isn't available here. 		 If we have any non-optionals that need a spill reg, abort.  */
if|if
condition|(
name|basic_block_needs
operator|!=
literal|0
operator|&&
name|basic_block_needs
index|[
name|this_block
index|]
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reload_optional
index|[
name|i
index|]
condition|)
name|reload_in
index|[
name|i
index|]
operator|=
name|reload_out
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|reload_reg_rtx
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Now compute which reload regs to reload them into.  Perhaps 		 reusing reload regs from previous insns, or else output 		 load insns to reload them.  Maybe output store insns too. 		 Record the choices of reload reg in reload_reg_rtx.  */
name|choose_reload_regs
argument_list|(
name|insn
argument_list|,
name|avoid_return_reg
argument_list|)
expr_stmt|;
comment|/* Generate the insns to reload operands into or out of 		 their reload regs.  */
name|emit_reload_insns
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Substitute the chosen reload regs from reload_reg_rtx 		 into the insn's body (or perhaps into the bodies of other 		 load and store insn that we just made for reloading 		 and that we moved the structure into).  */
name|subst_reloads
argument_list|()
expr_stmt|;
block|}
comment|/* Any previously reloaded spilled pseudo reg, stored in this insn, 	     is no longer validly lying around to save a future reload. 	     Note that this does not detect pseudos that were reloaded 	     for this insn in order to be stored in 	     (obeying register constraints).  That is correct; such reload 	     registers ARE still valid.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|forget_old_reloads_1
argument_list|)
expr_stmt|;
comment|/* Likewise for regs altered by auto-increment in this insn. 	     But note that the reg-notes are not changed by reloading: 	     they still contain the pseudo-regs, not the spill regs.  */
for|for
control|(
name|x
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|==
name|REG_INC
condition|)
block|{
comment|/* See if this pseudo reg was reloaded in this insn. 		   If so, its last-reload info is still valid 		   because it is based on this insn's reload.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reload_out
index|[
name|i
index|]
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|n_reloads
condition|)
name|forget_old_reloads_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* A reload reg's contents are unknown after a label.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_spills
condition|;
name|i
operator|++
control|)
block|{
name|reg_reloaded_contents
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_reloaded_insn
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Don't assume a reload reg is still good after a call insn 	 if it is a call-used reg.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_spills
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|spill_regs
index|[
name|i
index|]
index|]
condition|)
block|{
name|reg_reloaded_contents
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_reloaded_insn
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* In case registers overlap, allow certain insns to invalidate 	 particular hard registers.  */
ifdef|#
directive|ifdef
name|INSN_CLOBBERS_REGNO_P
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_spills
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|INSN_CLOBBERS_REGNO_P
argument_list|(
name|insn
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|reg_reloaded_contents
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_reloaded_insn
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|insn
operator|=
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Discard all record of any value reloaded from X,    or reloaded in X from someplace else;    unless X is an output reload reg of the current insn.     X may be a hard reg (the reload reg)    or it may be a pseudo reg that was reloaded from.     This function is not called for instructions generated by reload.  */
end_comment

begin_function
specifier|static
name|void
name|forget_old_reloads_1
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
name|int
name|nr
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|nr
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|nr
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Storing into a spilled-reg invalidates its contents. 	 This can happen if a block-local pseudo is allocated to that reg 	 and it wasn't spilled because this block's total need is 0. 	 Then some insn might have an optional reload and use this reg.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|spill_reg_order
index|[
name|regno
operator|+
name|i
index|]
operator|>=
literal|0
comment|/* But don't do this if the reg actually serves as an output 	       reload reg in the current instruction.  */
operator|&&
name|reg_is_output_reload
index|[
name|regno
operator|+
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|reg_reloaded_contents
index|[
name|spill_reg_order
index|[
name|regno
operator|+
name|i
index|]
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_reloaded_insn
index|[
name|spill_reg_order
index|[
name|regno
operator|+
name|i
index|]
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Since value of X has changed,      forget any value previously copied from it.  */
while|while
condition|(
name|nr
operator|--
operator|>
literal|0
condition|)
comment|/* But don't forget a copy if this is the output reload        that establishes the copy's validity.  */
if|if
condition|(
name|reg_has_output_reload
index|[
name|regno
operator|+
name|nr
index|]
operator|==
literal|0
condition|)
name|reg_last_reload_reg
index|[
name|regno
operator|+
name|nr
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Comparison function for qsort to decide which of two reloads    should be handled first.  *P1 and *P2 are the reload numbers.  */
end_comment

begin_function
specifier|static
name|int
name|reload_reg_class_lower
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|short
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|r1
init|=
operator|*
name|p1
decl_stmt|,
name|r2
init|=
operator|*
name|p2
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode1
decl_stmt|,
name|mode2
decl_stmt|;
comment|/* Consider required reloads before optional ones.  */
name|t
operator|=
name|reload_optional
index|[
name|r1
index|]
operator|-
name|reload_optional
index|[
name|r2
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
comment|/* Consider all multi-reg groups first.      This is safe because `reload' fills all group-need before      filling all non-group need.  */
name|mode1
operator|=
operator|(
name|reload_inmode
index|[
name|r1
index|]
operator|==
name|VOIDmode
condition|?
name|reload_outmode
index|[
name|r1
index|]
else|:
name|reload_inmode
index|[
name|r1
index|]
operator|)
expr_stmt|;
name|mode2
operator|=
operator|(
name|reload_inmode
index|[
name|r2
index|]
operator|==
name|VOIDmode
condition|?
name|reload_outmode
index|[
name|r2
index|]
else|:
name|reload_inmode
index|[
name|r2
index|]
operator|)
expr_stmt|;
name|t
operator|=
operator|(
name|CLASS_MAX_NREGS
argument_list|(
name|reload_reg_class
index|[
name|r2
index|]
argument_list|,
name|mode2
argument_list|)
operator|-
name|CLASS_MAX_NREGS
argument_list|(
name|reload_reg_class
index|[
name|r1
index|]
argument_list|,
name|mode1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
comment|/* Consider reloads in order of increasing reg-class number.  */
name|t
operator|=
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|r1
index|]
operator|-
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|r2
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
return|return
name|t
return|;
comment|/* If reloads are equally urgent, sort by reload number,      so that the results of qsort leave nothing to chance.  */
return|return
name|r1
operator|-
name|r2
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* The following tables are indexed by register number,    not by spill_regs index.  */
end_comment

begin_comment
comment|/* 1 if reg is in use as a reload reg for a RELOAD_OTHER reload.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|reload_reg_in_use
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if reg is in use for a RELOAD_FOR_INPUT_RELOAD_ADDRESS reload.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|reload_reg_in_use_for_inputs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if reg is in use for a RELOAD_FOR_OUTPUT_RELOAD_ADDRESS reload.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|reload_reg_in_use_for_outputs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if reg is in use for a RELOAD_FOR_OPERAND_ADDRESS reload.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|reload_reg_in_use_for_operands
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if reg is in use as a reload reg for any sort of reload.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|reload_reg_in_use_at_all
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mark reg REGNO as in use for a reload of the sort spec'd by WHEN_NEEDED.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reload_reg_in_use
parameter_list|(
name|regno
parameter_list|,
name|when_needed
parameter_list|)
name|int
name|regno
decl_stmt|;
name|enum
name|reload_when_needed
name|when_needed
decl_stmt|;
block|{
switch|switch
condition|(
name|when_needed
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
name|reload_reg_in_use
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_RELOAD_ADDRESS
case|:
name|reload_reg_in_use_for_inputs
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT_RELOAD_ADDRESS
case|:
name|reload_reg_in_use_for_outputs
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
name|reload_reg_in_use_for_operands
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|reload_reg_in_use_at_all
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 1 if reg REGNO is free as a reload reg for a reload of the sort    specified by WHEN_NEEDED.  */
end_comment

begin_function
specifier|static
name|int
name|reload_reg_free_p
parameter_list|(
name|regno
parameter_list|,
name|when_needed
parameter_list|)
name|int
name|regno
decl_stmt|;
name|enum
name|reload_when_needed
name|when_needed
decl_stmt|;
block|{
comment|/* In use for a RELOAD_OTHER means it's not available for anything.  */
if|if
condition|(
name|reload_reg_in_use
index|[
name|regno
index|]
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|when_needed
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
comment|/* In use for anything means not available for a RELOAD_OTHER.  */
return|return
operator|!
name|reload_reg_in_use_at_all
index|[
name|regno
index|]
return|;
comment|/* The other three kinds of use can share a register.  */
case|case
name|RELOAD_FOR_INPUT_RELOAD_ADDRESS
case|:
return|return
operator|!
name|reload_reg_in_use_for_inputs
index|[
name|regno
index|]
return|;
case|case
name|RELOAD_FOR_OUTPUT_RELOAD_ADDRESS
case|:
return|return
operator|!
name|reload_reg_in_use_for_outputs
index|[
name|regno
index|]
return|;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
return|return
operator|!
name|reload_reg_in_use_for_operands
index|[
name|regno
index|]
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if the value in reload reg REGNO, as used by a reload    needed for the part of the insn specified by WHEN_NEEDED,    is not in use for a reload in any prior part of the insn.  */
end_comment

begin_function
specifier|static
name|int
name|reload_reg_free_before_p
parameter_list|(
name|regno
parameter_list|,
name|when_needed
parameter_list|)
name|int
name|regno
decl_stmt|;
name|enum
name|reload_when_needed
name|when_needed
decl_stmt|;
block|{
switch|switch
condition|(
name|when_needed
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
comment|/* Since a RELOAD_OTHER reload claims the reg for the entire insn, 	 its use starts from the beginning, so nothing can use it earlier.  */
return|return
literal|1
return|;
comment|/* If this use is for part of the insn, 	 check the reg is not in use for any prior part.  */
case|case
name|RELOAD_FOR_OUTPUT_RELOAD_ADDRESS
case|:
if|if
condition|(
name|reload_reg_in_use_for_operands
index|[
name|regno
index|]
condition|)
return|return
literal|0
return|;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
if|if
condition|(
name|reload_reg_in_use_for_inputs
index|[
name|regno
index|]
condition|)
return|return
literal|0
return|;
case|case
name|RELOAD_FOR_INPUT_RELOAD_ADDRESS
case|:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if the value in reload reg REGNO, as used by a reload    needed for the part of the insn specified by WHEN_NEEDED,    is still available in REGNO at the end of the insn.  */
end_comment

begin_function
specifier|static
name|int
name|reload_reg_reaches_end_p
parameter_list|(
name|regno
parameter_list|,
name|when_needed
parameter_list|)
name|int
name|regno
decl_stmt|;
name|enum
name|reload_when_needed
name|when_needed
decl_stmt|;
block|{
switch|switch
condition|(
name|when_needed
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
comment|/* Since a RELOAD_OTHER reload claims the reg for the entire insn, 	 its value must reach the end.  */
return|return
literal|1
return|;
comment|/* If this use is for part of the insn, 	 its value reaches if no subsequent part uses the same register.  */
case|case
name|RELOAD_FOR_INPUT_RELOAD_ADDRESS
case|:
if|if
condition|(
name|reload_reg_in_use_for_operands
index|[
name|regno
index|]
condition|)
return|return
literal|0
return|;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
if|if
condition|(
name|reload_reg_in_use_for_outputs
index|[
name|regno
index|]
condition|)
return|return
literal|0
return|;
case|case
name|RELOAD_FOR_OUTPUT_RELOAD_ADDRESS
case|:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Vector of reload-numbers showing the order in which the reloads should    be processed.  */
end_comment

begin_decl_stmt
name|short
name|reload_order
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by reload number, 1 if incoming value    inherited from previous insns.  */
end_comment

begin_decl_stmt
name|char
name|reload_inherited
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For an inherited reload, this is the insn the reload was inherited from,    if we know it.  Otherwise, this is 0.  */
end_comment

begin_decl_stmt
name|rtx
name|reload_inheritance_insn
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, this is a place to get the value of the reload,    rather than using reload_in.  */
end_comment

begin_decl_stmt
name|rtx
name|reload_override_in
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each reload, the index in spill_regs of the spill register used,    or -1 if we did not need one of the spill registers for this reload.  */
end_comment

begin_decl_stmt
name|int
name|reload_spill_index
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assign hard reg targets for the pseudo-registers we must reload    into hard regs for this insn.    Also output the instructions to copy them in and out of the hard regs.     For machines with register classes, we are responsible for    finding a reload reg in the proper class.  */
end_comment

begin_function
specifier|static
name|void
name|choose_reload_regs
parameter_list|(
name|insn
parameter_list|,
name|avoid_return_reg
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|avoid_return_reg
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|int
name|have_groups
init|=
literal|0
decl_stmt|;
comment|/* Non-zero means we must reuse spill regs for multiple reloads in this insn      or we will not have enough spill regs.  */
name|int
name|must_reuse
init|=
literal|0
decl_stmt|;
name|rtx
name|original_reload_reg_rtx
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
comment|/* Don't bother with avoiding the return reg      if we have no mandatory reload that could use it.  */
if|if
condition|(
name|avoid_return_reg
condition|)
block|{
name|int
name|do_avoid
init|=
literal|0
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|avoid_return_reg
argument_list|)
decl_stmt|;
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|avoid_return_reg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|regno
init|;
name|r
operator|<
name|regno
operator|+
name|nregs
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|spill_reg_order
index|[
name|r
index|]
operator|>=
literal|0
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|reload_optional
index|[
name|j
index|]
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|==
literal|0
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|j
index|]
index|]
argument_list|,
name|r
argument_list|)
condition|)
name|do_avoid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|do_avoid
condition|)
name|avoid_return_reg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* See if we have more mandatory reloads than spill regs.      If so, then we cannot risk optimizations that could prevent      reloads from sharing one spill register.  */
block|{
name|int
name|tem
init|=
operator|(
name|avoid_return_reg
operator|!=
literal|0
operator|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|reload_optional
index|[
name|j
index|]
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|==
literal|0
condition|)
name|tem
operator|++
expr_stmt|;
if|if
condition|(
name|tem
operator|>
name|n_spills
condition|)
name|must_reuse
operator|=
literal|1
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|reload_reg_rtx
argument_list|,
name|original_reload_reg_rtx
argument_list|,
sizeof|sizeof
argument_list|(
name|reload_reg_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we fail to get enough regs without must_reuse,      set must_reuse and jump back here.  */
name|retry
label|:
name|bzero
argument_list|(
name|reload_inherited
argument_list|,
name|MAX_RELOADS
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reload_inheritance_insn
argument_list|,
name|MAX_RELOADS
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reload_override_in
argument_list|,
name|MAX_RELOADS
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reload_reg_in_use
argument_list|,
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reload_reg_in_use_at_all
argument_list|,
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reload_reg_in_use_for_inputs
argument_list|,
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reload_reg_in_use_for_outputs
argument_list|,
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reload_reg_in_use_for_operands
argument_list|,
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
comment|/* Don't use the subroutine call return reg for a reload      if we are supposed to avoid it.  */
if|if
condition|(
name|avoid_return_reg
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|avoid_return_reg
argument_list|)
decl_stmt|;
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|avoid_return_reg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|regno
init|;
name|r
operator|<
name|regno
operator|+
name|nregs
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|spill_reg_order
index|[
name|r
index|]
operator|>=
literal|0
condition|)
name|reload_reg_in_use
index|[
name|r
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* In order to be certain of getting the registers we need,      we must sort the reloads into order of increasing register class.      Then our grabbing of reload registers will parallel the process      that provided the reload registers.  */
comment|/* Also note whether any of the reloads wants a consecutive group of regs.      When that happens, we must when processing the non-group reloads      avoid (when possible) using a reload reg that would break up a group.  */
comment|/* This used to look for an existing reloaded home for all      of the reloads, and only then perform any new reloads.      But that could lose if the reloads were done out of reg-class order      because a later reload with a looser constraint might have an old      home in a register needed by an earlier reload with a tighter constraint.      It would be possible with even hairier code to detect such cases      and handle them, but it doesn't seem worth while yet.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|reload_order
index|[
name|j
index|]
operator|=
name|j
expr_stmt|;
name|reload_spill_index
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|mode
operator|=
operator|(
name|reload_inmode
index|[
name|j
index|]
operator|==
name|VOIDmode
operator|||
name|GET_MODE_SIZE
argument_list|(
name|reload_outmode
index|[
name|j
index|]
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|reload_inmode
index|[
name|j
index|]
argument_list|)
condition|?
name|reload_outmode
index|[
name|j
index|]
else|:
name|reload_inmode
index|[
name|j
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|CLASS_MAX_NREGS
argument_list|(
name|reload_reg_class
index|[
name|j
index|]
argument_list|,
name|mode
argument_list|)
operator|>
literal|1
condition|)
name|have_groups
operator|=
literal|1
expr_stmt|;
comment|/* If we have already decided to use a certain register, 	 don't use it in another way.  */
if|if
condition|(
name|reload_reg_rtx
index|[
name|j
index|]
condition|)
name|mark_reload_reg_in_use
argument_list|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_reloads
operator|>
literal|1
condition|)
name|qsort
argument_list|(
name|reload_order
argument_list|,
name|n_reloads
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
name|reload_reg_class_lower
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|int
name|r
init|=
name|reload_order
index|[
name|j
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
name|new
decl_stmt|;
name|enum
name|machine_mode
name|reload_mode
init|=
name|reload_inmode
index|[
name|r
index|]
decl_stmt|;
name|int
name|h1_ok
decl_stmt|,
name|h2_ok
decl_stmt|,
name|h3_ok
decl_stmt|;
comment|/* Ignore reloads that got marked inoperative.  */
if|if
condition|(
name|reload_out
index|[
name|r
index|]
operator|==
literal|0
operator|&&
name|reload_in
index|[
name|r
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|reload_outmode
index|[
name|r
index|]
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|reload_mode
argument_list|)
condition|)
name|reload_mode
operator|=
name|reload_outmode
index|[
name|r
index|]
expr_stmt|;
if|if
condition|(
name|reload_strict_low
index|[
name|r
index|]
condition|)
name|reload_mode
operator|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No need to find a reload-register if find_reloads chose one.  */
if|if
condition|(
name|reload_reg_rtx
index|[
name|r
index|]
operator|!=
literal|0
condition|)
continue|continue;
comment|/* First see if this pseudo is already available as reloaded 	 for a previous insn. 	 This feature is disabled for multi-register groups 	 because we haven't yet any way to tell whether the entire 	 value is properly preserved. 	 It is also disabled when there are other reloads for mult-register 	 groups, lest the inherited reload reg break up a needed group.  */
block|{
specifier|register
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|reload_in
index|[
name|r
index|]
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This won't work, since REGNO can be a pseudo reg number. 	   Also, it takes much more hair to keep track of all the things 	   that can invalidate an inherited reload of part of a pseudoreg.  */
block|else if (GET_CODE (reload_in[r]) == SUBREG&& GET_CODE (SUBREG_REG (reload_in[r])) == REG) 	  regno = REGNO (SUBREG_REG (reload_in[r])) + SUBREG_WORD (reload_in[r]);
endif|#
directive|endif
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|reg_last_reload_reg
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
operator|!
name|have_groups
comment|/* See comment at next use of must_reuse.  */
operator|&&
operator|!
name|must_reuse
condition|)
block|{
name|i
operator|=
name|spill_reg_order
index|[
name|REGNO
argument_list|(
name|reg_last_reload_reg
index|[
name|regno
index|]
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|reg_reloaded_contents
index|[
name|i
index|]
operator|==
name|regno
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|spill_regs
index|[
name|i
index|]
argument_list|,
name|reload_mode
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|r
index|]
index|]
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
operator|&&
name|reload_reg_free_p
argument_list|(
name|spill_regs
index|[
name|i
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
operator|&&
name|reload_reg_free_before_p
argument_list|(
name|spill_regs
index|[
name|i
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
condition|)
block|{
comment|/* Mark the register as in use for this part of the insn.  */
name|mark_reload_reg_in_use
argument_list|(
name|spill_regs
index|[
name|i
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|reload_reg_rtx
index|[
name|r
index|]
operator|=
name|reg_last_reload_reg
index|[
name|regno
index|]
expr_stmt|;
name|reload_inherited
index|[
name|r
index|]
operator|=
literal|1
expr_stmt|;
name|reload_inheritance_insn
index|[
name|r
index|]
operator|=
name|reg_reloaded_insn
index|[
name|i
index|]
expr_stmt|;
name|reload_spill_index
index|[
name|r
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
comment|/* Here's another way to see if the value is already lying around.  */
if|if
condition|(
name|reload_in
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
name|reload_reg_rtx
index|[
name|r
index|]
operator|==
literal|0
operator|&&
name|reload_out
index|[
name|r
index|]
operator|==
literal|0
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
operator|!
name|have_groups
comment|/* This optimization can prevent this reload from reusing 	     a spill reg used for another reload.  That could take away 	     a spill reg that another reload will need.  If we cannot 	     be sure there will still be enough spill regs, 	     don't do this optimization.  */
operator|&&
operator|!
name|must_reuse
condition|)
block|{
specifier|register
name|rtx
name|equiv
init|=
name|find_equiv_reg
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|,
name|insn
argument_list|,
name|reload_reg_class
index|[
name|r
index|]
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|reload_mode
argument_list|)
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|equiv
operator|!=
literal|0
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|equiv
argument_list|)
expr_stmt|;
comment|/* If we found a spill reg, reject it unless it is free 	     and of the desired class.  */
if|if
condition|(
name|equiv
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|equiv
argument_list|)
operator|==
name|REG
operator|&&
name|spill_reg_order
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
name|reload_reg_free_before_p
argument_list|(
name|regno
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|r
index|]
index|]
argument_list|,
name|regno
argument_list|)
condition|)
name|equiv
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|equiv
operator|!=
literal|0
operator|&&
name|reload_reg_in_use_at_all
index|[
name|regno
index|]
condition|)
name|equiv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|equiv
operator|!=
literal|0
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|reload_mode
argument_list|)
condition|)
name|equiv
operator|=
literal|0
expr_stmt|;
comment|/* We found a register that contains the value we need. 	     If this register is the same as an `earlyclobber' operand 	     of the current insn, just mark it as a place to reload from 	     since we can't use it as the reload register itself.  */
if|if
condition|(
name|equiv
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_earlyclobbers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|equiv
argument_list|,
name|reload_earlyclobbers
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|reload_override_in
index|[
name|r
index|]
operator|=
name|equiv
expr_stmt|;
name|equiv
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* If we found an equivalent reg, say no code need be generated 	     to load it, and use it as our reload reg.  */
if|if
condition|(
name|equiv
operator|!=
literal|0
operator|&&
name|REGNO
argument_list|(
name|equiv
argument_list|)
operator|!=
name|FRAME_POINTER_REGNUM
condition|)
block|{
name|reload_reg_rtx
index|[
name|r
index|]
operator|=
name|equiv
expr_stmt|;
name|reload_inherited
index|[
name|r
index|]
operator|=
literal|1
expr_stmt|;
comment|/* If it is a spill reg, 		 mark the spill reg as in use for this insn.  */
name|i
operator|=
name|spill_reg_order
index|[
name|REGNO
argument_list|(
name|equiv
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|int
name|nr
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|spill_regs
index|[
name|i
index|]
argument_list|,
name|reload_mode
argument_list|)
decl_stmt|;
while|while
condition|(
name|nr
operator|>
literal|0
condition|)
name|mark_reload_reg_in_use
argument_list|(
name|REGNO
argument_list|(
name|equiv
argument_list|)
operator|+
operator|--
name|nr
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If it isn't lying around, and isn't optional, 	 find a place to reload it into.  */
if|if
condition|(
name|reload_reg_rtx
index|[
name|r
index|]
operator|!=
literal|0
operator|||
name|reload_optional
index|[
name|r
index|]
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Value not lying around; find a register to reload it into. 	 Here I is not a regno, it is an index into spill_regs.  */
name|i
operator|=
name|n_spills
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The following is no longer needed now that all multi-register 	 (group) reloads are processed before all solitary register reloads 	 (due to changes in `reg_class_lower_p' and `reload'.  */
comment|/* The following also fails to test HARD_REGNO_MODE_OK appropriately, 	 which was hard to fix because we don't know the mode that the 	 group might have that would want this register.  */
comment|/* If we want just one reg, and other reloads want groups, 	 first try to find a reg that can't be part of a group.  */
block|if (have_groups&& CLASS_MAX_NREGS (reload_reg_class[r], reload_mode) == 1) 	for (i = 0; i< n_spills; i++) 	  { 	    int regno = spill_regs[i]; 	    int class = (int) reload_reg_class[r]; 	    if (reload_reg_in_use_at_all[regno] == 0&& TEST_HARD_REG_BIT (reg_class_contents[class], 				      regno)&& !(regno + 1< FIRST_PSEUDO_REGISTER&& spill_reg_order[regno + 1]>= 0&& reload_reg_in_use_at_all[regno + 1] == 0&& TEST_HARD_REG_BIT (reg_class_contents[class], 					   regno + 1))&& !(regno> 0&& spill_reg_order[regno - 1]>= 0&& reload_reg_in_use_at_all[regno - 1] == 0&& TEST_HARD_REG_BIT (reg_class_contents[class], 					   regno - 1))) 	      break; 	  }
comment|/* If that didn't work, try to find a register that has only one 	 neighbor that could make a group with it.  That way, if the 	 available registers are three consecutive ones, we avoid taking 	 the middle one (which would leave us with no possible groups).  */
block|if (have_groups&& CLASS_MAX_NREGS (reload_reg_class[r], reload_mode) == 1&& i == n_spills) 	for (i = 0; i< n_spills; i++) 	  { 	    int regno = spill_regs[i]; 	    int class = (int) reload_reg_class[r]; 	    if (reload_reg_in_use_at_all[regno] == 0&& TEST_HARD_REG_BIT (reg_class_contents[class], 				      regno)&& (!(regno + 1< FIRST_PSEUDO_REGISTER&& spill_reg_order[regno + 1]>= 0&& reload_reg_in_use_at_all[regno + 1] == 0&& TEST_HARD_REG_BIT (reg_class_contents[class], 					    regno + 1)) 		    || !(regno> 0&& spill_reg_order[regno - 1]>= 0&& reload_reg_in_use_at_all[regno - 1] == 0&& TEST_HARD_REG_BIT (reg_class_contents[class], 					       regno - 1)))) 	      break; 	  }
endif|#
directive|endif
comment|/* Now, if we want a single register and haven't yet found one, 	 take any reg in the right class and not in use. 	 If we want a consecutive group, here is where we look for it.  */
if|if
condition|(
name|i
operator|==
name|n_spills
condition|)
block|{
name|int
name|pass
decl_stmt|;
comment|/* If we put this reload ahead, thinking it is a group, 	     then insist on finding a group.  Otherwise we can grab a 	     reg that some other reload needs.  	     (That can happen when we have a 68000 DATA_OR_FP_REG 	     which is a group of data regs or one fp reg.) 	     ??? Really it would be nicer to have smarter handling 	     for that kind of reg class, where a problem like this is normal. 	     Perhaps those classes should be avoided for reloading 	     by use of more alternatives.  */
name|int
name|force_group
init|=
operator|(
name|CLASS_MAX_NREGS
argument_list|(
name|reload_reg_class
index|[
name|r
index|]
argument_list|,
name|reload_mode
argument_list|)
operator|>
literal|1
operator|)
decl_stmt|;
comment|/* We need not be so restrictive if there are no more reloads 	     for this insn.  */
if|if
condition|(
name|j
operator|+
literal|1
operator|==
name|n_reloads
condition|)
name|force_group
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_spills
condition|;
name|i
operator|++
control|)
block|{
name|int
name|class
init|=
operator|(
name|int
operator|)
name|reload_reg_class
index|[
name|r
index|]
decl_stmt|;
if|if
condition|(
name|reload_reg_free_p
argument_list|(
name|spill_regs
index|[
name|i
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
comment|/* Look first for regs to share, then for unshared.  */
operator|&&
operator|(
name|pass
operator|||
name|reload_reg_in_use_at_all
index|[
name|spill_regs
index|[
name|i
index|]
index|]
operator|)
condition|)
block|{
name|int
name|nr
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|spill_regs
index|[
name|i
index|]
argument_list|,
name|reload_mode
argument_list|)
decl_stmt|;
comment|/* Avoid the problem where spilling a GENERAL_OR_FP_REG 			 (on 68000) got us two FP regs.  If NR is 1, 			 we would reject both of them.  */
if|if
condition|(
name|force_group
condition|)
name|nr
operator|=
name|CLASS_MAX_NREGS
argument_list|(
name|reload_reg_class
index|[
name|r
index|]
argument_list|,
name|reload_mode
argument_list|)
expr_stmt|;
comment|/* If we need only one reg, we have already won.  */
if|if
condition|(
name|nr
operator|==
literal|1
condition|)
block|{
comment|/* But reject a single reg if we demand a group.  */
if|if
condition|(
name|force_group
condition|)
continue|continue;
break|break;
block|}
comment|/* Otherwise check that as many consecutive regs as we need 			 are available here. 			 Also, don't use for a group registers that are 			 needed for nongroups.  */
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|spill_regs
index|[
name|i
index|]
argument_list|,
name|reload_mode
argument_list|)
operator|&&
operator|!
name|counted_for_nongroups
index|[
name|spill_regs
index|[
name|i
index|]
index|]
condition|)
while|while
condition|(
name|nr
operator|>
literal|1
condition|)
block|{
name|int
name|regno
init|=
name|spill_regs
index|[
name|i
index|]
operator|+
name|nr
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|regno
argument_list|)
operator|&&
name|spill_reg_order
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
name|reload_reg_free_p
argument_list|(
name|regno
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
operator|&&
operator|!
name|counted_for_nongroups
index|[
name|regno
index|]
operator|)
condition|)
break|break;
name|nr
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|nr
operator|==
literal|1
condition|)
break|break;
block|}
block|}
comment|/* If find something on pass 1, omit pass 2.  */
if|if
condition|(
name|i
operator|<
name|n_spills
condition|)
break|break;
block|}
block|}
comment|/* We should have found a spill register by now.  */
if|if
condition|(
name|i
operator|==
name|n_spills
condition|)
block|{
if|if
condition|(
name|must_reuse
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
name|original_reload_reg_rtx
argument_list|,
name|reload_reg_rtx
argument_list|,
sizeof|sizeof
argument_list|(
name|reload_reg_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|must_reuse
operator|=
literal|1
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
comment|/* Mark as in use for this insn the reload regs we use for this.  */
block|{
name|int
name|nr
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|spill_regs
index|[
name|i
index|]
argument_list|,
name|reload_mode
argument_list|)
decl_stmt|;
while|while
condition|(
name|nr
operator|>
literal|0
condition|)
block|{
name|mark_reload_reg_in_use
argument_list|(
name|spill_regs
index|[
name|i
index|]
operator|+
operator|--
name|nr
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
expr_stmt|;
name|reg_reloaded_contents
index|[
name|spill_reg_order
index|[
name|spill_regs
index|[
name|i
index|]
operator|+
name|nr
index|]
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_reloaded_insn
index|[
name|spill_reg_order
index|[
name|spill_regs
index|[
name|i
index|]
operator|+
name|nr
index|]
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|new
operator|=
name|spill_reg_rtx
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|new
argument_list|)
operator|!=
name|reload_mode
condition|)
name|spill_reg_rtx
index|[
name|i
index|]
operator|=
name|new
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|reload_mode
argument_list|,
name|spill_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|reload_reg_rtx
index|[
name|r
index|]
operator|=
name|new
expr_stmt|;
name|reload_spill_index
index|[
name|r
index|]
operator|=
name|i
expr_stmt|;
comment|/* Detect when the reload reg can't hold the reload mode. 	 This used to be one `if', but Sequent compiler can't handle that.  */
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
argument_list|,
name|reload_mode
argument_list|)
condition|)
if|if
condition|(
operator|!
operator|(
name|reload_in
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
argument_list|)
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|reload_out
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* The reg is OK.  */
continue|continue;
comment|/* The reg is not OK.  */
block|{
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
comment|/* It's the compiler's fault.  */
name|abort
argument_list|()
expr_stmt|;
comment|/* It's the user's fault; the operand's mode and constraint 	   don't match.  Disable this reload so we don't crash in final.  */
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"`asm' operand constraint incompatible with operand size"
argument_list|)
expr_stmt|;
name|reload_in
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
name|reload_out
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
name|reload_reg_rtx
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
name|reload_optional
index|[
name|r
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If we thought we could inherit a reload, because it seemed that      nothing else wanted the same reload register earlier in the insn,      verify that assumption, now that all reloads have been assigned.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|int
name|r
init|=
name|reload_order
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|reload_inherited
index|[
name|r
index|]
operator|&&
name|reload_reg_rtx
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
operator|!
name|reload_reg_free_before_p
argument_list|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|r
index|]
argument_list|)
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
condition|)
name|reload_inherited
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If we found a better place to reload from, 	 validate it in the same fashion, if it is a reload reg.  */
if|if
condition|(
name|reload_override_in
index|[
name|r
index|]
operator|&&
name|GET_CODE
argument_list|(
name|reload_override_in
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|spill_reg_order
index|[
name|REGNO
argument_list|(
name|reload_override_in
index|[
name|r
index|]
argument_list|)
index|]
operator|>=
literal|0
operator|&&
operator|!
name|reload_reg_free_before_p
argument_list|(
name|REGNO
argument_list|(
name|reload_override_in
index|[
name|r
index|]
argument_list|)
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
condition|)
name|reload_override_in
index|[
name|r
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now that reload_override_in is known valid,      actually override reload_in.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reload_override_in
index|[
name|j
index|]
condition|)
name|reload_in
index|[
name|j
index|]
operator|=
name|reload_override_in
index|[
name|j
index|]
expr_stmt|;
comment|/* For all the spill regs newly reloaded in this instruction,      record what they were reloaded from, so subsequent instructions      can inherit the reloads.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|int
name|r
init|=
name|reload_order
index|[
name|j
index|]
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|reload_spill_index
index|[
name|r
index|]
decl_stmt|;
comment|/* I is nonneg if this reload used one of the spill regs. 	 If reload_reg_rtx[r] is 0, this is an optional reload 	 that we opted to ignore.  */
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|reload_reg_rtx
index|[
name|r
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* Maybe the spill reg contains a copy of reload_out.  */
if|if
condition|(
name|reload_out
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|nregno
init|=
name|REGNO
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
decl_stmt|;
name|reg_last_reload_reg
index|[
name|nregno
index|]
operator|=
name|reload_reg_rtx
index|[
name|r
index|]
expr_stmt|;
name|reg_reloaded_contents
index|[
name|i
index|]
operator|=
name|nregno
expr_stmt|;
name|reg_reloaded_insn
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
name|reg_has_output_reload
index|[
name|nregno
index|]
operator|=
literal|1
expr_stmt|;
name|reg_is_output_reload
index|[
name|spill_regs
index|[
name|i
index|]
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|reload_when_needed
index|[
name|r
index|]
operator|!=
name|RELOAD_OTHER
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Maybe the spill reg contains a copy of reload_in.  */
elseif|else
if|if
condition|(
name|reload_out
index|[
name|r
index|]
operator|==
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
operator|)
condition|)
block|{
specifier|register
name|int
name|nregno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
condition|)
name|nregno
operator|=
name|REGNO
argument_list|(
name|reload_in
index|[
name|r
index|]
argument_list|)
expr_stmt|;
else|else
name|nregno
operator|=
name|REGNO
argument_list|(
name|reload_in_reg
index|[
name|r
index|]
argument_list|)
expr_stmt|;
comment|/* If there are two separate reloads (one in and one out) 		 for the same (hard or pseudo) reg, 		 leave reg_last_reload_reg set  		 based on the output reload. 		 Otherwise, set it from this input reload.  */
if|if
condition|(
operator|!
name|reg_has_output_reload
index|[
name|nregno
index|]
condition|)
block|{
name|reg_last_reload_reg
index|[
name|nregno
index|]
operator|=
name|reload_reg_rtx
index|[
name|r
index|]
expr_stmt|;
name|reg_reloaded_contents
index|[
name|i
index|]
operator|=
name|nregno
expr_stmt|;
name|reg_reloaded_insn
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
comment|/* But don't do so if another input reload 		     will clobber this one's value.  */
if|if
condition|(
operator|!
name|reload_reg_reaches_end_p
argument_list|(
name|spill_regs
index|[
name|i
index|]
argument_list|,
name|reload_when_needed
index|[
name|r
index|]
argument_list|)
condition|)
block|{
name|reg_reloaded_contents
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_reloaded_insn
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Otherwise, the spill reg doesn't contain a copy of any reg. 	     Clear out its records, lest it be taken for a copy 	     of reload_in when that is no longer true.  */
else|else
block|{
name|reg_reloaded_contents
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_reloaded_insn
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* The following if-statement was #if 0'd in 1.34 (or before...). 	 It's reenabled in 1.35 because supposedly nothing else 	 deals with this problem.  */
comment|/* If a register gets output-reloaded from a non-spill register, 	 that invalidates any previous reloaded copy of it. 	 But forget_old_reloads_1 won't get to see it, because 	 it thinks only about the original insn.  So invalidate it here.  */
if|if
condition|(
name|i
operator|<
literal|0
operator|&&
name|reload_out
index|[
name|r
index|]
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|nregno
init|=
name|REGNO
argument_list|(
name|reload_out
index|[
name|r
index|]
argument_list|)
decl_stmt|;
name|reg_last_reload_reg
index|[
name|nregno
index|]
operator|=
literal|0
expr_stmt|;
name|reg_has_output_reload
index|[
name|nregno
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output insns to reload values in and out of the chosen reload regs.  */
end_comment

begin_function
specifier|static
name|void
name|emit_reload_insns
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|rtx
name|first_output_reload_insn
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|first_other_reload_insn
init|=
name|insn
decl_stmt|;
name|rtx
name|first_operand_address_reload_insn
init|=
name|insn
decl_stmt|;
name|int
name|special
decl_stmt|;
comment|/* Now output the instructions to copy the data into and out of the      reload registers.  Do these in the order that the reloads were reported,      since reloads of base and index registers precede reloads of operands      and the operands may need the base and index registers reloaded.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|rtx
name|old
decl_stmt|;
name|rtx
name|store_insn
decl_stmt|;
name|old
operator|=
name|reload_in
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|old
operator|!=
literal|0
operator|&&
operator|!
name|reload_inherited
index|[
name|j
index|]
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
name|old
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
specifier|register
name|rtx
name|reloadreg
init|=
name|reload_reg_rtx
index|[
name|j
index|]
decl_stmt|;
name|rtx
name|oldequiv
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|where
decl_stmt|;
name|rtx
name|this_reload_insn
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|0
comment|/* No longer done because these paradoxical subregs now occur 	     only for regs and for spilled stack slots, and in either case 	     we can safely reload in the nominal machine mode.  */
comment|/* Strip off of OLD any size-increasing SUBREGs such as 	     (SUBREG:SI foo:QI 0).  */
block|while (GET_CODE (old) == SUBREG&& SUBREG_WORD (old) == 0&& (GET_MODE_SIZE (GET_MODE (old))> GET_MODE_SIZE (GET_MODE (SUBREG_REG (old))))) 	    old = SUBREG_REG (old);
endif|#
directive|endif
comment|/* Determine the mode to reload in. 	     This is very tricky because we have three to choose from. 	     There is the mode the insn operand wants (reload_inmode[J]). 	     There is the mode of the reload register RELOADREG. 	     There is the intrinsic mode of the operand, which we could find 	     by stripping some SUBREGs. 	     It turns out that RELOADREG's mode is irrelevant: 	     we can change that arbitrarily.  	     Consider (SUBREG:SI foo:QI) as an operand that must be SImode; 	     then the reload reg may not support QImode moves, so use SImode. 	     If foo is in memory due to spilling a pseudo reg, this is safe, 	     because the QImode value is in the least significant part of a 	     slot big enough for a SImode.  If foo is some other sort of 	     memory reference, then it is impossible to reload this case, 	     so previous passes had better make sure this never happens.  	     Then consider a one-word union which has SImode and one of its 	     members is a float, being fetched as (SUBREG:SF union:SI). 	     We must fetch that as SFmode because we could be loading into 	     a float-only register.  In this case OLD's mode is correct.  	     Consider an immediate integer: it has VOIDmode.  Here we need 	     to get a mode from something else.  	     In some cases, there is a fourth mode, the operand's 	     containing mode.  If the insn specifies a containing mode for 	     this operand, it overrides all others.  	     I am not sure whether the algorithm here is always right, 	     but it does the right things in those cases.  */
name|mode
operator|=
name|GET_MODE
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|reload_inmode
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|reload_strict_low
index|[
name|j
index|]
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reload_in
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If reloading from memory, see if there is a register 	     that already holds the same value.  If so, reload from there. 	     We can pass 0 as the reload_reg_p argument because 	     any other reload has either already been emitted, 	     in which case find_equiv_reg will see the reload-insn, 	     or has yet to be emitted, in which case it doesn't matter 	     because we will use this equiv reg right away.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|old
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|old
argument_list|)
index|]
operator|<
literal|0
operator|)
condition|)
name|oldequiv
operator|=
name|find_equiv_reg
argument_list|(
name|old
argument_list|,
name|insn
argument_list|,
name|GENERAL_REGS
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* If OLDEQUIV is a spill register, don't use it for this 	     if any other reload needs it at an earlier stage of this insn 	     or at this stage.  */
if|if
condition|(
name|oldequiv
operator|&&
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|REG
operator|&&
name|spill_reg_order
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
operator|>=
literal|0
operator|&&
operator|(
operator|!
name|reload_reg_free_p
argument_list|(
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|)
operator|||
operator|!
name|reload_reg_free_before_p
argument_list|(
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
argument_list|,
name|reload_when_needed
index|[
name|j
index|]
argument_list|)
operator|)
condition|)
name|oldequiv
operator|=
literal|0
expr_stmt|;
comment|/* If OLDEQUIV is not a spill register, 	     don't use it if any other reload wants it.  */
if|if
condition|(
name|oldequiv
operator|&&
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|REG
operator|&&
name|spill_reg_order
index|[
name|REGNO
argument_list|(
name|oldequiv
argument_list|)
index|]
operator|<
literal|0
condition|)
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|n_reloads
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|reload_reg_rtx
index|[
name|k
index|]
operator|!=
literal|0
operator|&&
name|k
operator|!=
name|j
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reload_reg_rtx
index|[
name|k
index|]
argument_list|,
name|oldequiv
argument_list|)
condition|)
block|{
name|oldequiv
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|oldequiv
operator|==
literal|0
condition|)
name|oldequiv
operator|=
name|old
expr_stmt|;
comment|/* Encapsulate both RELOADREG and OLDEQUIV into that mode, 	     then load RELOADREG from OLDEQUIV.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|reloadreg
argument_list|)
operator|!=
name|mode
condition|)
name|reloadreg
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|mode
argument_list|,
name|reloadreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|oldequiv
argument_list|)
operator|!=
name|mode
condition|)
name|oldequiv
operator|=
name|SUBREG_REG
argument_list|(
name|oldequiv
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|oldequiv
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|oldequiv
argument_list|)
condition|)
name|oldequiv
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|mode
argument_list|,
name|oldequiv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Decide where to put reload insn for this reload.  */
switch|switch
condition|(
name|reload_when_needed
index|[
name|j
index|]
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
name|where
operator|=
name|first_operand_address_reload_insn
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPUT_RELOAD_ADDRESS
case|:
name|where
operator|=
name|first_other_reload_insn
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTPUT_RELOAD_ADDRESS
case|:
name|where
operator|=
name|first_output_reload_insn
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
name|where
operator|=
name|insn
expr_stmt|;
block|}
name|special
operator|=
literal|0
expr_stmt|;
comment|/* Auto-increment addresses must be reloaded in a special way.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|POST_DEC
operator|||
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|oldequiv
argument_list|)
operator|==
name|PRE_DEC
condition|)
block|{
comment|/* Prevent normal processing of this reload.  */
name|special
operator|=
literal|1
expr_stmt|;
comment|/* Output a special code sequence for this case.  */
name|this_reload_insn
operator|=
name|inc_for_reload
argument_list|(
name|reloadreg
argument_list|,
name|oldequiv
argument_list|,
name|reload_inc
index|[
name|j
index|]
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
comment|/* If we are reloading a pseudo-register that was set by the previous 	     insn, see if we can get rid of that pseudo-register entirely 	     by redirecting the previous insn into our reload register.  */
elseif|else
if|if
condition|(
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|old
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|old
argument_list|)
comment|/* This is unsafe if some other reload 		      uses the same reg first.  */
operator|&&
operator|(
name|reload_when_needed
index|[
name|j
index|]
operator|==
name|RELOAD_OTHER
operator|||
name|reload_when_needed
index|[
name|j
index|]
operator|==
name|RELOAD_FOR_INPUT_RELOAD_ADDRESS
operator|)
condition|)
block|{
name|rtx
name|temp
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|temp
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|NOTE
condition|)
name|temp
operator|=
name|PREV_INSN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&&
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|old
comment|/* Make sure we can access insn_operand_constraint.  */
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|<
literal|0
comment|/* This is unsafe if prev insn rejects our reload reg.  */
operator|&&
name|constraint_accepts_reg_p
argument_list|(
name|insn_operand_constraint
index|[
name|recog_memoized
argument_list|(
name|temp
argument_list|)
index|]
index|[
literal|0
index|]
argument_list|,
name|reloadreg
argument_list|)
comment|/* This is unsafe if operand occurs more than once in current 		     insn.  Perhaps some occurrences aren't reloaded.  */
operator|&&
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|old
argument_list|)
operator|==
literal|1
comment|/* Don't risk splitting a matching pair of operands.  */
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|old
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Store into the reload register instead of the pseudo.  */
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|=
name|reloadreg
expr_stmt|;
comment|/* If these are the only uses of the pseudo reg, 		     pretend for GDB it lives in the reload reg we used.  */
if|if
condition|(
name|reg_n_deaths
index|[
name|REGNO
argument_list|(
name|old
argument_list|)
index|]
operator|==
literal|1
operator|&&
name|reg_n_sets
index|[
name|REGNO
argument_list|(
name|old
argument_list|)
index|]
operator|==
literal|1
condition|)
block|{
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|old
argument_list|)
index|]
operator|=
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|alter_reg
argument_list|(
name|REGNO
argument_list|(
name|old
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|special
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* We can't do that, so output an insn to load RELOADREG. 	     Keep them in the following order: 	     all reloads for input reload addresses, 	     all reloads for ordinary input operands, 	     all reloads for addresses of non-reloaded operands, 	     the insn being reloaded, 	     all reloads for addresses of output reloads, 	     the output reloads.  */
if|if
condition|(
operator|!
name|special
condition|)
name|this_reload_insn
operator|=
name|gen_input_reload
argument_list|(
name|reloadreg
argument_list|,
name|oldequiv
argument_list|,
name|where
argument_list|)
expr_stmt|;
comment|/* Update where to put other reload insns.  */
if|if
condition|(
name|this_reload_insn
condition|)
switch|switch
condition|(
name|reload_when_needed
index|[
name|j
index|]
condition|)
block|{
case|case
name|RELOAD_OTHER
case|:
if|if
condition|(
name|first_other_reload_insn
operator|==
name|first_operand_address_reload_insn
condition|)
name|first_other_reload_insn
operator|=
name|this_reload_insn
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
if|if
condition|(
name|first_operand_address_reload_insn
operator|==
name|insn
condition|)
name|first_operand_address_reload_insn
operator|=
name|this_reload_insn
expr_stmt|;
if|if
condition|(
name|first_other_reload_insn
operator|==
name|insn
condition|)
name|first_other_reload_insn
operator|=
name|this_reload_insn
expr_stmt|;
block|}
comment|/* reload_inc[j] was formerly processed here.  */
block|}
comment|/* Add a note saying the input reload reg 	 dies in this insn, if anyone cares.  */
ifdef|#
directive|ifdef
name|PRESERVE_DEATH_INFO_REGNO_P
if|if
condition|(
name|old
operator|!=
literal|0
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
name|old
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|reload_out
index|[
name|j
index|]
operator|==
literal|0
operator|&&
name|PRESERVE_DEATH_INFO_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
argument_list|)
condition|)
block|{
specifier|register
name|rtx
name|reloadreg
init|=
name|reload_reg_rtx
index|[
name|j
index|]
decl_stmt|;
comment|/* The code below is incorrect except for RELOAD_OTHER.  */
if|if
condition|(
name|reload_when_needed
index|[
name|j
index|]
operator|!=
name|RELOAD_OTHER
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Add a death note to this insn, for an input reload.  */
if|if
condition|(
operator|!
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|reloadreg
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_DEAD
argument_list|,
name|reloadreg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ??? The following code is inadequate. 	 It handles regs inherited via reg_last_reloaded_contents 	 but not those inherited via find_equiv_reg. 	 Note that we can't expect spill_reg_store to contain anything 	 useful in the case of find_equiv_reg.  */
ifdef|#
directive|ifdef
name|PRESERVE_DEATH_INFO_REGNO_P
comment|/* For some registers it is important to keep the REG_DEATH 	 notes accurate for the final pass. 	 If we are inheriting an old output-reload out of such a reg, 	 the reg no longer dies there, so remove the death note.  */
if|if
condition|(
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|PRESERVE_DEATH_INFO_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
argument_list|)
operator|&&
name|reload_inherited
index|[
name|j
index|]
operator|&&
name|reload_spill_index
index|[
name|j
index|]
operator|>=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|j
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|spill_reg_store
index|[
name|reload_spill_index
index|[
name|j
index|]
index|]
operator|!=
literal|0
operator|&&
name|regno_dead_p
argument_list|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
argument_list|,
name|spill_reg_store
index|[
name|reload_spill_index
index|[
name|j
index|]
index|]
argument_list|)
condition|)
block|{
name|remove_death
argument_list|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
argument_list|,
name|spill_reg_store
index|[
name|reload_spill_index
index|[
name|j
index|]
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Likewise for input reloads that were inherited.  */
if|if
condition|(
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|PRESERVE_DEATH_INFO_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
argument_list|)
operator|&&
name|reload_inherited
index|[
name|j
index|]
operator|&&
name|reload_spill_index
index|[
name|j
index|]
operator|>=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|j
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|spill_reg_store
index|[
name|reload_spill_index
index|[
name|j
index|]
index|]
operator|==
literal|0
operator|&&
name|reload_inheritance_insn
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|regno_dead_p
argument_list|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
argument_list|,
name|reload_inheritance_insn
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|remove_death
argument_list|(
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
argument_list|,
name|reload_inheritance_insn
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If we are reloading a register that was recently stored in with an 	 output-reload, see if we can prove there was 	 actually no need to store the old value in it.  */
if|if
condition|(
name|optimize
operator|&&
name|reload_inherited
index|[
name|j
index|]
operator|&&
name|reload_spill_index
index|[
name|j
index|]
operator|>=
literal|0
comment|/* This is unsafe if some other reload uses the same reg first.  */
operator|&&
operator|(
name|reload_when_needed
index|[
name|j
index|]
operator|==
name|RELOAD_OTHER
operator|||
name|reload_when_needed
index|[
name|j
index|]
operator|==
name|RELOAD_FOR_INPUT_RELOAD_ADDRESS
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|reload_in
index|[
name|j
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|reload_in
index|[
name|j
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|spill_reg_store
index|[
name|reload_spill_index
index|[
name|j
index|]
index|]
operator|!=
literal|0
operator|&&
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|reload_in
index|[
name|j
index|]
argument_list|)
comment|/* This is unsafe if operand occurs more than once in current 	     insn.  Perhaps some occurrences weren't reloaded.  */
operator|&&
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reload_in
index|[
name|j
index|]
argument_list|)
operator|==
literal|1
condition|)
name|delete_output_reload
argument_list|(
name|insn
argument_list|,
name|j
argument_list|,
name|reload_spill_index
index|[
name|j
index|]
argument_list|)
expr_stmt|;
comment|/* Input-reloading is done.  Now do output-reloading, 	 storing the value from the reload-register after the main insn 	 if reload_out[j] is nonzero.  */
name|old
operator|=
name|reload_out
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|old
operator|!=
literal|0
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
name|old
operator|&&
name|reload_reg_rtx
index|[
name|j
index|]
operator|!=
literal|0
comment|/* An output operand that dies right away 	     does need a reload reg, but need not 	     be copied from it.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|REG
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|old
argument_list|)
operator|)
condition|)
block|{
specifier|register
name|rtx
name|reloadreg
init|=
name|reload_reg_rtx
index|[
name|j
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Strip off of OLD any size-increasing SUBREGs such as 	     (SUBREG:SI foo:QI 0).  */
block|while (GET_CODE (old) == SUBREG&& SUBREG_WORD (old) == 0&& (GET_MODE_SIZE (GET_MODE (old))> GET_MODE_SIZE (GET_MODE (SUBREG_REG (old))))) 	    old = SUBREG_REG (old);
endif|#
directive|endif
comment|/* Determine the mode to reload in. 	     See comments above (for input reloading).  */
name|mode
operator|=
name|GET_MODE
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen for an output.  */
if|#
directive|if
literal|0
block|mode = reload_inmode[j];
endif|#
directive|endif
if|if
condition|(
name|reload_strict_low
index|[
name|j
index|]
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reload_out
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Encapsulate both RELOADREG and OLD into that mode, 	     then load RELOADREG from OLD.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|reloadreg
argument_list|)
operator|!=
name|mode
condition|)
name|reloadreg
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|mode
argument_list|,
name|reloadreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If OLD is a subreg, then strip it, since the subreg will 	     be altered by this very reload (if it's a strict_low_part).  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|old
argument_list|)
operator|!=
name|mode
condition|)
name|old
operator|=
name|SUBREG_REG
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|old
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|old
argument_list|)
condition|)
name|old
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|mode
argument_list|,
name|old
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Output the reload insn.  */
name|store_insn
operator|=
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|old
argument_list|,
name|reloadreg
argument_list|)
argument_list|,
name|first_output_reload_insn
argument_list|)
expr_stmt|;
name|first_output_reload_insn
operator|=
name|store_insn
expr_stmt|;
comment|/* If this output reload doesn't come from a spill reg, 	     clear any memory of reloaded copies of the pseudo reg. 	     If this output reload comes from a spill reg, 	     reg_has_output_reload will make this do nothing.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|store_insn
argument_list|)
argument_list|,
name|forget_old_reloads_1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PRESERVE_DEATH_INFO_REGNO_P
comment|/* If final will look at death notes for this reg, 	     put one on the output-reload insn.  */
if|if
condition|(
name|PRESERVE_DEATH_INFO_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|store_insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_DEAD
argument_list|,
name|reloadreg
argument_list|,
name|REG_NOTES
argument_list|(
name|store_insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Move all death-notes from the insn being reloaded 	     to the output reload, if they are for things used 	     as inputs in this output reload.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|!=
name|REG
condition|)
block|{
comment|/* The note we will examine next.  */
name|rtx
name|reg_notes
init|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* The place that pointed to this note.  */
name|rtx
modifier|*
name|prev_reg_note
init|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|reg_notes
condition|)
block|{
name|rtx
name|next_reg_notes
init|=
name|XEXP
argument_list|(
name|reg_notes
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|reg_notes
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|reg_notes
argument_list|,
literal|0
argument_list|)
argument_list|,
name|old
argument_list|)
condition|)
block|{
operator|*
name|prev_reg_note
operator|=
name|next_reg_notes
expr_stmt|;
name|XEXP
argument_list|(
name|reg_notes
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|store_insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|store_insn
argument_list|)
operator|=
name|reg_notes
expr_stmt|;
block|}
else|else
name|prev_reg_note
operator|=
operator|&
name|XEXP
argument_list|(
name|reg_notes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|reg_notes
operator|=
name|next_reg_notes
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
else|else
name|store_insn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reload_spill_index
index|[
name|j
index|]
operator|>=
literal|0
condition|)
name|spill_reg_store
index|[
name|reload_spill_index
index|[
name|j
index|]
index|]
operator|=
name|store_insn
expr_stmt|;
block|}
comment|/* Move death notes from INSN to output-operand-address reload insns.  */
ifdef|#
directive|ifdef
name|PRESERVE_DEATH_INFO_REGNO_P
block|{
name|rtx
name|insn1
decl_stmt|;
comment|/* Loop over those insns, last ones first.  */
for|for
control|(
name|insn1
operator|=
name|PREV_INSN
argument_list|(
name|first_output_reload_insn
argument_list|)
init|;
name|insn1
operator|!=
name|insn
condition|;
name|insn1
operator|=
name|PREV_INSN
argument_list|(
name|insn1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn1
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn1
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|source
init|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* The note we will examine next.  */
name|rtx
name|reg_notes
init|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* The place that pointed to this note.  */
name|rtx
modifier|*
name|prev_reg_note
init|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If the note is for something used in the source of this 	     output address reload insn, move the note.  */
while|while
condition|(
name|reg_notes
condition|)
block|{
name|rtx
name|next_reg_notes
init|=
name|XEXP
argument_list|(
name|reg_notes
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|reg_notes
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|reg_notes
argument_list|,
literal|0
argument_list|)
argument_list|,
name|source
argument_list|)
condition|)
block|{
operator|*
name|prev_reg_note
operator|=
name|next_reg_notes
expr_stmt|;
name|XEXP
argument_list|(
name|reg_notes
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn1
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn1
argument_list|)
operator|=
name|reg_notes
expr_stmt|;
block|}
else|else
name|prev_reg_note
operator|=
operator|&
name|XEXP
argument_list|(
name|reg_notes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|reg_notes
operator|=
name|next_reg_notes
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit code before BEFORE_INSN to perform an input reload of IN to RELOADREG.    Handle case of reloading a PLUS expression (currently only happens for    stack slots with out-of-range offset).     Returns last insn emitted.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_input_reload
parameter_list|(
name|reloadreg
parameter_list|,
name|in
parameter_list|,
name|before_insn
parameter_list|)
name|rtx
name|reloadreg
decl_stmt|;
name|rtx
name|in
decl_stmt|;
name|rtx
name|before_insn
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* Install this in version 1.37.  Avoid risk for now.  */
block|if (GET_CODE (in) == PLUS)     {
comment|/* Don't use gen_move_insn to make what is actually an add insn.  */
block|emit_insn_before (gen_move_insn (reloadreg, XEXP (in, 0)), before_insn);       emit_insn_before (gen_add2_insn (reloadreg, XEXP (in, 1)), before_insn);     }   else
endif|#
directive|endif
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|reloadreg
argument_list|,
name|in
argument_list|)
argument_list|,
name|before_insn
argument_list|)
expr_stmt|;
return|return
name|PREV_INSN
argument_list|(
name|before_insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete a previously made output-reload    whose result we now believe is not needed.    First we double-check.     INSN is the insn now being processed.    J is the reload-number for this insn,    and SPILL_INDEX is the index in spill_regs of the reload-reg    being used for the reload.  */
end_comment

begin_function
specifier|static
name|void
name|delete_output_reload
parameter_list|(
name|insn
parameter_list|,
name|j
parameter_list|,
name|spill_index
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|spill_index
decl_stmt|;
block|{
specifier|register
name|rtx
name|i1
decl_stmt|;
comment|/* Get the raw pseudo-register referred to.  */
name|rtx
name|reg
init|=
name|reload_in
index|[
name|j
index|]
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* If the pseudo-reg we are reloading is no longer referenced      anywhere between the store into it and here,      and no jumps or labels intervene, then the value can get      here through the reload reg alone.      Otherwise, give up--return.  */
for|for
control|(
name|i1
operator|=
name|NEXT_INSN
argument_list|(
name|spill_reg_store
index|[
name|spill_index
index|]
argument_list|)
init|;
name|i1
operator|!=
name|insn
condition|;
name|i1
operator|=
name|NEXT_INSN
argument_list|(
name|i1
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|JUMP_INSN
condition|)
return|return;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|i1
argument_list|)
operator|==
name|CALL_INSN
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|i1
argument_list|)
argument_list|)
condition|)
return|return;
block|}
comment|/* If this insn will store in the pseudo again,      the previous store can be removed.  */
if|if
condition|(
name|reload_out
index|[
name|j
index|]
operator|==
name|reload_in
index|[
name|j
index|]
condition|)
name|delete_insn
argument_list|(
name|spill_reg_store
index|[
name|spill_index
index|]
argument_list|)
expr_stmt|;
comment|/* See if the pseudo reg has been completely replaced      with reload regs.  If so, delete the store insn      and forget we had a stack slot for the pseudo.  */
elseif|else
if|if
condition|(
name|reg_n_deaths
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
operator|==
literal|1
operator|&&
name|reg_basic_block
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
operator|>=
literal|0
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|i2
decl_stmt|;
comment|/* We know that it was used only between here 	 and the beginning of the current basic block. 	 (We also know that the last use before INSN was 	 the output reload we are thinking of deleting, but never mind that.) 	 Search that range; see if any ref remains.  */
for|for
control|(
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|i2
condition|;
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
control|)
block|{
comment|/* Uses which just store in the pseudo don't count, 	     since if they are the only uses, they are dead.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
operator|==
name|reg
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|CALL_INSN
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
condition|)
comment|/* Some other ref remains; 	       we can't do anything.  */
return|return;
block|}
comment|/* Delete the now-dead stores into this pseudo.  */
for|for
control|(
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|i2
condition|;
name|i2
operator|=
name|PREV_INSN
argument_list|(
name|i2
argument_list|)
control|)
block|{
comment|/* Uses which just store in the pseudo don't count, 	     since if they are the only uses, they are dead.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|i2
argument_list|)
argument_list|)
operator|==
name|reg
condition|)
name|delete_insn
argument_list|(
name|i2
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|i2
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
block|}
comment|/* For the debugging info, 	 say the pseudo lives in this reload reg.  */
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
operator|=
name|REGNO
argument_list|(
name|reload_reg_rtx
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|alter_reg
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output reload-insns to reload VALUE into RELOADREG.     VALUE is a autoincrement or autodecrement RTX whose operand    is a register or memory location;    so reloading involves incrementing that location.     INC_AMOUNT is the number to increment or decrement by (always positive).    This cannot be deduced from VALUE.     INSN is the insn before which the new insns should be emitted.     The return value is the first of the insns emitted.  */
end_comment

begin_function
specifier|static
name|rtx
name|inc_for_reload
parameter_list|(
name|reloadreg
parameter_list|,
name|value
parameter_list|,
name|inc_amount
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|reloadreg
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|int
name|inc_amount
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* REG or MEM to be copied and incremented.  */
name|rtx
name|incloc
init|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Nonzero if increment after copying.  */
name|int
name|post
init|=
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|POST_DEC
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|POST_INC
operator|)
decl_stmt|;
comment|/* No hard register is equivalent to this register after      inc/dec operation.  If REG_LAST_RELOAD_REG were non-zero,      we could inc/dec that register as well (maybe even using it for      the source), but I'm not sure it's worth worrying about.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|incloc
argument_list|)
operator|==
name|REG
condition|)
name|reg_last_reload_reg
index|[
name|REGNO
argument_list|(
name|incloc
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|POST_DEC
condition|)
name|inc_amount
operator|=
operator|-
name|inc_amount
expr_stmt|;
comment|/* First handle preincrement, which is simpler.  */
if|if
condition|(
operator|!
name|post
condition|)
block|{
comment|/* If incrementing a register, assume we can 	 output an insn to increment it directly.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|incloc
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|incloc
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|incloc
argument_list|)
index|]
operator|>=
literal|0
operator|)
condition|)
block|{
name|rtx
name|first_new
init|=
name|emit_insn_before
argument_list|(
name|gen_add2_insn
argument_list|(
name|incloc
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|inc_amount
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|reloadreg
argument_list|,
name|incloc
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|first_new
return|;
block|}
else|else
comment|/* Else we must not assume we can increment the location directly 	   (even though on many target machines we can); 	   copy it to the reload register, increment there, then save back.  */
block|{
name|rtx
name|first_new
init|=
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|reloadreg
argument_list|,
name|incloc
argument_list|)
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|emit_insn_before
argument_list|(
name|gen_add2_insn
argument_list|(
name|reloadreg
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|inc_amount
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|incloc
argument_list|,
name|reloadreg
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|first_new
return|;
block|}
block|}
comment|/* Postincrement.      Because this might be a jump insn or a compare, and because RELOADREG      may not be available after the insn in an input reload,      we must do the incrementation before the insn being reloaded for.  */
else|else
block|{
comment|/* Copy the value, then increment it.  */
name|rtx
name|first_new
init|=
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|reloadreg
argument_list|,
name|incloc
argument_list|)
argument_list|,
name|insn
argument_list|)
decl_stmt|;
comment|/* If incrementing a register, assume we can 	 output an insn to increment it directly.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|incloc
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|incloc
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|incloc
argument_list|)
index|]
operator|>=
literal|0
operator|)
condition|)
block|{
name|emit_insn_before
argument_list|(
name|gen_add2_insn
argument_list|(
name|incloc
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|inc_amount
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Else we must not assume we can increment INCLOC 	   (even though on many target machines we can); 	   increment the copy in the reload register, 	   save that back, then decrement the reload register 	   so it has the original value.  */
block|{
name|emit_insn_before
argument_list|(
name|gen_add2_insn
argument_list|(
name|reloadreg
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|inc_amount
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|incloc
argument_list|,
name|reloadreg
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_sub2_insn
argument_list|(
name|reloadreg
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|inc_amount
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|first_new
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if we are certain that the constraint-string STRING allows    the hard register REG.  Return 0 if we can't be sure of this.  */
end_comment

begin_function
specifier|static
name|int
name|constraint_accepts_reg_p
parameter_list|(
name|string
parameter_list|,
name|reg
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|int
name|value
init|=
literal|0
decl_stmt|;
name|int
name|regno
init|=
name|true_regnum
argument_list|(
name|reg
argument_list|)
decl_stmt|;
comment|/* We win if this register is a general register      and each alternative accepts all general registers.  */
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Initialize for first alternative.  */
name|value
operator|=
literal|0
expr_stmt|;
comment|/* Check that each alternative contains `g' or `r'.  */
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
operator|*
name|string
operator|++
condition|)
block|{
case|case
literal|0
case|:
comment|/* If an alternative lacks `g' or `r', we lose.  */
return|return
name|value
return|;
case|case
literal|','
case|:
comment|/* If an alternative lacks `g' or `r', we lose.  */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Initialize for next alternative.  */
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'r'
case|:
name|value
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of places FIND appears within X.  */
end_comment

begin_function
specifier|static
name|int
name|count_occurrences
parameter_list|(
name|x
parameter_list|,
name|find
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|,
name|find
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|find
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
literal|0
return|;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|count
operator|+=
name|count_occurrences
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|find
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|count
operator|+=
name|count_occurrences
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|find
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|count
return|;
block|}
end_function

end_unit

