begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Compute register class preferences for pseudo-registers.    Copyright (C) 1987, 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file contains two passes of the compiler: reg_scan and reg_class.    It also defines some tables of information about the hardware registers    and a function init_reg_sets to initialize the tables.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_define
define|#
directive|define
name|max
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)> (B) ? (A) : (B))
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)< (B) ? (A) : (B))
end_define

begin_escape
end_escape

begin_comment
comment|/* Register tables used by many passes.  */
end_comment

begin_comment
comment|/* Indexed by hard register number, contains 1 for registers    that are fixed use (stack pointer, pc, frame pointer, etc.).    These are the registers that cannot be used to allocate    a pseudo reg whose life does not cross calls.  */
end_comment

begin_decl_stmt
name|char
name|fixed_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Same info as a HARD_REG_SET.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|fixed_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data for initializing the above.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|initial_fixed_regs
index|[]
init|=
name|FIXED_REGISTERS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by hard register number, contains 1 for registers    that are fixed use or are clobbered by function calls.    These are the registers that cannot be used to allocate    a pseudo reg whose life crosses calls.  */
end_comment

begin_decl_stmt
name|char
name|call_used_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Same info as a HARD_REG_SET.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|call_used_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data for initializing the above.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|initial_call_used_regs
index|[]
init|=
name|CALL_USED_REGISTERS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by hard register number, contains 1 for registers that are    fixed use -- i.e. in fixed_regs -- or a function value return register    or STRUCT_VALUE_REGNUM or STATIC_CHAIN_REGNUM.  These are the    registers that cannot hold quantities across calls even if we are    willing to save and restore them.  */
end_comment

begin_decl_stmt
name|char
name|call_fixed_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The same info as a HARD_REG_SET.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|call_fixed_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by hard register number, contains 1 for registers    that are being used for global register decls.    These must be exempt from ordinary flow analysis    and are also considered fixed.  */
end_comment

begin_decl_stmt
name|char
name|global_regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of register numbers in the order in which to try to use them.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
end_ifdef

begin_decl_stmt
name|int
name|reg_alloc_order
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
name|REG_ALLOC_ORDER
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For each reg class, a HARD_REG_SET saying which registers are in it.  */
end_comment

begin_decl_stmt
name|HARD_REG_SET
name|reg_class_contents
index|[]
init|=
name|REG_CLASS_CONTENTS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each reg class, number of regs it contains.  */
end_comment

begin_decl_stmt
name|int
name|reg_class_size
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each reg class, table listing all the containing classes.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|reg_class_superclasses
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each reg class, table listing all the classes contained in it.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|reg_class_subclasses
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each pair of reg classes,    a largest reg class contained in their union.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|reg_class_subunion
index|[
name|N_REG_CLASSES
index|]
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array containing all of the register names */
end_comment

begin_decl_stmt
name|char
modifier|*
name|reg_names
index|[]
init|=
name|REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function called only once to initialize the above data on reg usage.    Once this is done, various switches may override.  */
end_comment

begin_function
name|void
name|init_reg_sets
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bcopy
argument_list|(
name|initial_fixed_regs
argument_list|,
name|fixed_regs
argument_list|,
sizeof|sizeof
name|fixed_regs
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|initial_call_used_regs
argument_list|,
name|call_used_regs
argument_list|,
sizeof|sizeof
name|call_used_regs
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|global_regs
argument_list|,
sizeof|sizeof
name|global_regs
argument_list|)
expr_stmt|;
comment|/* Compute number of hard regs in each class.  */
name|bzero
argument_list|(
name|reg_class_size
argument_list|,
sizeof|sizeof
name|reg_class_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|,
name|j
argument_list|)
condition|)
name|reg_class_size
index|[
name|i
index|]
operator|++
expr_stmt|;
comment|/* Initialize the table of subunions.      reg_class_subunion[I][J] gets the largest-numbered reg-class      that is contained in the union of classes I and J.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|HARD_REG_SET
specifier|register
comment|/* Declare it register if it's a scalar.  */
endif|#
directive|endif
name|HARD_REG_SET
name|c
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|c
argument_list|,
name|reg_class_contents
index|[
name|j
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|N_REG_CLASSES
condition|;
name|k
operator|++
control|)
block|{
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|reg_class_contents
index|[
name|k
index|]
argument_list|,
name|c
argument_list|,
name|subclass1
argument_list|)
expr_stmt|;
continue|continue;
name|subclass1
label|:
name|reg_class_subunion
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|k
expr_stmt|;
block|}
block|}
block|}
comment|/* Initialize the tables of subclasses and superclasses of each reg class.      First clear the whole table, then add the elements as they are found.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
block|{
name|reg_class_superclasses
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|LIM_REG_CLASSES
expr_stmt|;
name|reg_class_subclasses
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|LIM_REG_CLASSES
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_REG_CLASSES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|NO_REGS
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|N_REG_CLASSES
condition|;
name|j
operator|++
control|)
block|{
name|enum
name|reg_class
modifier|*
name|p
decl_stmt|;
name|GO_IF_HARD_REG_SUBSET
argument_list|(
name|reg_class_contents
index|[
name|i
index|]
argument_list|,
name|reg_class_contents
index|[
name|j
index|]
argument_list|,
name|subclass
argument_list|)
expr_stmt|;
continue|continue;
name|subclass
label|:
comment|/* Reg class I is a subclass of J. 	     Add J to the table of superclasses of I.  */
name|p
operator|=
operator|&
name|reg_class_superclasses
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|j
expr_stmt|;
comment|/* Add I to the table of superclasses of J.  */
name|p
operator|=
operator|&
name|reg_class_subclasses
index|[
name|j
index|]
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|LIM_REG_CLASSES
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|i
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* After switches have been processed, which perhaps alter    `fixed_regs' and `call_used_regs', convert them to HARD_REG_SETs.  */
end_comment

begin_function
name|void
name|init_reg_sets_1
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* This macro allows the fixed or call-used registers      to depend on target flags.  */
ifdef|#
directive|ifdef
name|CONDITIONAL_REGISTER_USAGE
name|CONDITIONAL_REGISTER_USAGE
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
condition|)
name|warning
argument_list|(
literal|"call-clobbered register used for global register variable"
argument_list|)
expr_stmt|;
name|fixed_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Prevent saving/restoring of this reg.  */
name|call_used_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Initialize "constant" tables.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|fixed_reg_set
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|call_used_reg_set
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|call_fixed_reg_set
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fixed_regs
argument_list|,
name|call_fixed_regs
argument_list|,
sizeof|sizeof
name|call_fixed_regs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STRUCT_VALUE_REGNUM
name|call_fixed_regs
index|[
name|STRUCT_VALUE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STATIC_CHAIN_REGNUM
name|call_fixed_regs
index|[
name|STATIC_CHAIN_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|FUNCTION_VALUE_REGNO_P
argument_list|(
name|i
argument_list|)
condition|)
name|call_fixed_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fixed_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|call_used_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_fixed_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|call_fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Specify the usage characteristics of the register named NAME.    It should be a fixed register if FIXED and a    call-used register if CALL_USED.  */
end_comment

begin_function
name|void
name|fix_register
parameter_list|(
name|name
parameter_list|,
name|fixed
parameter_list|,
name|call_used
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|fixed
decl_stmt|,
name|call_used
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Decode the name and update the primary form of      the register info.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|reg_names
index|[
name|i
index|]
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|fixed_regs
index|[
name|i
index|]
operator|=
name|fixed
expr_stmt|;
name|call_used_regs
index|[
name|i
index|]
operator|=
name|call_used
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|warning
argument_list|(
literal|"unknown register name: %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Now the data and code for the `regclass' pass, which happens    just before local-alloc.  */
end_comment

begin_comment
comment|/* savings[R].savings[CL] is twice the amount saved by putting register R    in class CL.  This data is used within `regclass' and freed    when it is finished.  */
end_comment

begin_struct
struct|struct
name|savings
block|{
name|short
name|savings
index|[
name|N_REG_CLASSES
index|]
decl_stmt|;
name|short
name|memcost
decl_stmt|;
name|short
name|nrefs
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|savings
modifier|*
name|savings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (enum reg_class) prefclass[R] is the preferred class for pseudo number R.    This is available after `regclass' is run.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prefclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* preferred_or_nothing[R] is nonzero if we should put pseudo number R    in memory if we can't get its perferred class.    This is available after `regclass' is run.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|preferred_or_nothing
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|reg_class_record
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|record_address_regs
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Return the reg_class in which pseudo reg number REGNO is best allocated.    This function is sometimes called before the info has been computed.    When that happens, just return GENERAL_REGS, which is innocuous.  */
end_comment

begin_function
name|enum
name|reg_class
name|reg_preferred_class
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|prefclass
operator|==
literal|0
condition|)
return|return
name|GENERAL_REGS
return|;
return|return
operator|(
expr|enum
name|reg_class
operator|)
name|prefclass
index|[
name|regno
index|]
return|;
block|}
end_function

begin_function
name|int
name|reg_preferred_or_nothing
parameter_list|(
name|regno
parameter_list|)
block|{
if|if
condition|(
name|prefclass
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|preferred_or_nothing
index|[
name|regno
index|]
return|;
block|}
end_function

begin_comment
comment|/* This prevents dump_flow_info from losing if called    before regclass is run.  */
end_comment

begin_function
name|int
name|regclass_init
parameter_list|()
block|{
name|prefclass
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is a pass of the compiler that scans all instructions    and calculates the preferred class for each pseudo-register.    This information can be accessed later by calling `reg_preferred_class'.    This pass comes just before local register allocation.  */
end_comment

begin_function
name|void
name|regclass
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|init_recog
argument_list|()
expr_stmt|;
comment|/* Zero out our accumulation of the cost of each class for each reg.  */
name|savings
operator|=
operator|(
expr|struct
name|savings
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|savings
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|savings
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|savings
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Scan the instructions and record each time it would      save code to put a certain register in a certain class.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ASM_INPUT
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
operator|)
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|int
name|noperands
init|=
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We don't use alloca because alloca would not free 	       any of the space until this function returns.  */
name|rtx
modifier|*
name|operands
init|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
name|noperands
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|constraints
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|oballoc
argument_list|(
name|noperands
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|decode_asm_operands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|operands
argument_list|,
literal|0
argument_list|,
name|constraints
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|noperands
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|reg_class_record
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|constraints
argument_list|)
expr_stmt|;
name|obfree
argument_list|(
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|insn_code_number
init|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|insn_extract
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|insn_n_operands
index|[
name|insn_code_number
index|]
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|reg_class_record
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|insn_operand_constraint
index|[
name|insn_code_number
index|]
argument_list|)
expr_stmt|;
comment|/* Improve handling of two-address insns such as 	       (set X (ashift CONST Y)) where CONST must be made to match X. 	       Change it into two insns: (set X CONST)  (set X (ashift X Y)). 	       If we left this for reloading, it would probably get three insns 	       because X and Y might go in the same place. 	       This prevents X and Y from receiving the same hard reg.  */
if|if
condition|(
name|optimize
operator|&&
name|insn_n_operands
index|[
name|insn_code_number
index|]
operator|>=
literal|3
operator|&&
name|insn_operand_constraint
index|[
name|insn_code_number
index|]
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|insn_operand_constraint
index|[
name|insn_code_number
index|]
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|recog_operand
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|recog_operand
index|[
literal|0
index|]
argument_list|,
name|recog_operand
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|recog_operand
index|[
literal|0
index|]
argument_list|,
name|recog_operand
index|[
literal|2
index|]
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|recog_operand
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|previnsn
init|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|newinsn
init|=
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|recog_operand
index|[
literal|0
index|]
argument_list|,
name|recog_operand
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|insn
argument_list|)
decl_stmt|;
comment|/* If this insn was the start of a basic block, 		   include the new insn in that block.  */
if|if
condition|(
name|previnsn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|previnsn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|int
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
if|if
condition|(
name|insn
operator|==
name|basic_block_head
index|[
name|b
index|]
condition|)
name|basic_block_head
index|[
name|b
index|]
operator|=
name|newinsn
expr_stmt|;
block|}
comment|/* This makes one more setting of new insns's destination.  */
name|reg_n_sets
index|[
name|REGNO
argument_list|(
name|recog_operand
index|[
literal|0
index|]
argument_list|)
index|]
operator|++
expr_stmt|;
operator|*
name|recog_operand_loc
index|[
literal|1
index|]
operator|=
name|recog_operand
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|insn_n_dups
index|[
name|insn_code_number
index|]
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|recog_dup_num
index|[
name|i
index|]
operator|==
literal|1
condition|)
operator|*
name|recog_dup_loc
index|[
name|i
index|]
operator|=
name|recog_operand
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/* Now for each register look at how desirable each class is      and find which class is preferred.  Store that in `prefclass[REGNO]'.  */
name|prefclass
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
name|nregs
argument_list|)
expr_stmt|;
name|preferred_or_nothing
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
name|nregs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|best_savings
init|=
literal|0
decl_stmt|;
name|enum
name|reg_class
name|best
init|=
name|ALL_REGS
decl_stmt|;
comment|/* This is an enum reg_class, but we call it an int 	 to save lots of casts.  */
specifier|register
name|int
name|class
decl_stmt|;
specifier|register
name|struct
name|savings
modifier|*
name|p
init|=
operator|&
name|savings
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|class
operator|=
operator|(
name|int
operator|)
name|ALL_REGS
operator|-
literal|1
init|;
name|class
operator|>
literal|0
condition|;
name|class
operator|--
control|)
block|{
if|if
condition|(
name|p
operator|->
name|savings
index|[
name|class
index|]
operator|>
name|best_savings
condition|)
block|{
name|best_savings
operator|=
name|p
operator|->
name|savings
index|[
name|class
index|]
expr_stmt|;
name|best
operator|=
operator|(
expr|enum
name|reg_class
operator|)
name|class
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|savings
index|[
name|class
index|]
operator|==
name|best_savings
condition|)
block|{
name|best
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|best
index|]
index|[
name|class
index|]
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* Note that best_savings is twice number of places something 	 is saved.  */
block|if ((best_savings - p->savings[(int) GENERAL_REGS]) * 5< reg_n_refs[i]) 	prefclass[i] = (int) GENERAL_REGS;       else 	prefclass[i] = (int) best;
else|#
directive|else
comment|/* We cast to (int) because (char) hits bugs in some compilers.  */
name|prefclass
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|best
expr_stmt|;
endif|#
directive|endif
comment|/* reg_n_refs + p->memcost measures the cost of putting in memory. 	 If a GENERAL_REG is no better, don't even try for one. 	 Since savings and memcost are 2 * number of refs, 	 this effectively counts each memory operand not needing reloading 	 as costing 1/2 of a reload insn.  */
if|if
condition|(
name|reg_n_refs
operator|!=
literal|0
condition|)
name|preferred_or_nothing
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|best_savings
operator|-
name|p
operator|->
name|savings
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
operator|)
operator|>=
name|p
operator|->
name|nrefs
operator|+
name|p
operator|->
name|memcost
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* REGISTER_CONSTRAINTS */
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
end_ifdef

begin_comment
comment|/* Scan an operand OP for register class preferences.    OPNO is the operand number, and CONSTRAINTS is the constraint    vector for the insn.     Record the preferred register classes from the constraint for OP    if OP is a register.  If OP is a memory reference, record suitable    preferences for registers used in the address.  */
end_comment

begin_function
name|void
name|reg_class_record
parameter_list|(
name|op
parameter_list|,
name|opno
parameter_list|,
name|constraints
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|int
name|opno
decl_stmt|;
name|char
modifier|*
modifier|*
name|constraints
decl_stmt|;
block|{
name|char
modifier|*
name|constraint
init|=
name|constraints
index|[
name|opno
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|enum
name|reg_class
name|class
init|=
name|NO_REGS
decl_stmt|;
name|char
modifier|*
name|next
init|=
literal|0
decl_stmt|;
name|int
name|memok
init|=
literal|0
decl_stmt|;
name|int
name|double_cost
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
comment|/* Memory reference: scan the address.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
name|record_address_regs
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
block|{
comment|/* If the constraint says the operand is supposed to BE an address, 	 scan it as one.  */
if|if
condition|(
name|constraint
operator|!=
literal|0
operator|&&
name|constraint
index|[
literal|0
index|]
operator|==
literal|'p'
condition|)
name|record_address_regs
argument_list|(
name|op
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Operand is a register: examine the constraint for specified classes.  */
for|for
control|(
name|p
operator|=
name|constraint
init|;
operator|*
name|p
operator|||
name|next
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|next
expr_stmt|;
name|next
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'?'
case|:
case|case
literal|'#'
case|:
case|case
literal|'&'
case|:
case|case
literal|'!'
case|:
case|case
literal|'%'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'s'
case|:
case|case
literal|'p'
case|:
case|case
literal|','
case|:
break|break;
case|case
literal|'+'
case|:
comment|/* An input-output operand is twice as costly if it loses.  */
name|double_cost
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
case|case
literal|'o'
case|:
name|memok
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* * means ignore following letter 	     when choosing register preferences.  */
case|case
literal|'*'
case|:
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'r'
case|:
name|class
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|class
index|]
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
comment|/* If constraint says "match another operand", 	     use that operand's constraint to choose preferences.  */
name|next
operator|=
name|constraints
index|[
operator|*
name|p
operator|-
literal|'0'
index|]
expr_stmt|;
break|break;
default|default:
name|class
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|class
index|]
index|[
operator|(
name|int
operator|)
name|REG_CLASS_FROM_LETTER
argument_list|(
operator|*
name|p
argument_list|)
index|]
expr_stmt|;
block|}
block|}
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|savings
modifier|*
name|pp
decl_stmt|;
specifier|register
name|enum
name|reg_class
name|class1
decl_stmt|;
name|int
name|cost
init|=
literal|2
operator|*
operator|(
literal|1
operator|+
name|double_cost
operator|)
decl_stmt|;
name|pp
operator|=
operator|&
name|savings
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
index|]
expr_stmt|;
comment|/* Increment the savings for this reg        for each class contained in the one the constraint asks for.  */
if|if
condition|(
name|class
operator|!=
name|NO_REGS
operator|&&
name|class
operator|!=
name|ALL_REGS
condition|)
block|{
name|pp
operator|->
name|savings
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|+=
name|cost
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|class1
operator|=
name|reg_class_subclasses
index|[
operator|(
name|int
operator|)
name|class
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|class1
operator|==
name|LIM_REG_CLASSES
condition|)
break|break;
name|pp
operator|->
name|savings
index|[
operator|(
name|int
operator|)
name|class1
index|]
operator|+=
name|cost
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|memok
condition|)
name|pp
operator|->
name|memcost
operator|+=
literal|1
operator|+
literal|2
operator|*
name|double_cost
expr_stmt|;
name|pp
operator|->
name|nrefs
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record the pseudo registers we must reload into hard registers    in a subexpression of a memory address, X.    BCOST is the cost if X is a register and it fails to be in BASE_REG_CLASS.    ICOST is the cost if it fails to be in INDEX_REG_CLASS. */
end_comment

begin_function
name|void
name|record_address_regs
parameter_list|(
name|x
parameter_list|,
name|bcost
parameter_list|,
name|icost
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|bcost
decl_stmt|,
name|icost
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return;
case|case
name|PLUS
case|:
comment|/* When we have an address that is a sum, 	 we must determine whether registers are "base" or "index" regs. 	 If there is a sum of two registers, we must choose one to be 	 the "base".  Luckily, we can use the REGNO_POINTER_FLAG 	 to make a good choice most of the time.  */
block|{
name|rtx
name|arg0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|arg1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code0
init|=
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|int
name|icost0
init|=
literal|0
decl_stmt|;
name|int
name|icost1
init|=
literal|0
decl_stmt|;
name|int
name|suppress1
init|=
literal|0
decl_stmt|;
name|int
name|suppress0
init|=
literal|0
decl_stmt|;
comment|/* Look inside subregs.  */
while|while
condition|(
name|code0
operator|==
name|SUBREG
condition|)
name|arg0
operator|=
name|SUBREG_REG
argument_list|(
name|arg0
argument_list|)
operator|,
name|code0
operator|=
name|GET_CODE
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
while|while
condition|(
name|code1
operator|==
name|SUBREG
condition|)
name|arg1
operator|=
name|SUBREG_REG
argument_list|(
name|arg1
argument_list|)
operator|,
name|code1
operator|=
name|GET_CODE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code0
operator|==
name|MULT
operator|||
name|code1
operator|==
name|MEM
condition|)
name|icost0
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|MULT
operator|||
name|code0
operator|==
name|MEM
condition|)
name|icost1
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|CONST_INT
condition|)
name|suppress0
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_INT
condition|)
name|suppress1
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|REG
operator|&&
name|code1
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
name|icost1
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|icost0
operator|=
literal|2
expr_stmt|;
else|else
name|icost0
operator|=
name|icost1
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|PLUS
operator|&&
operator|!
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|)
name|icost0
operator|=
literal|2
expr_stmt|;
else|else
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|code0
operator|==
name|PLUS
operator|&&
operator|!
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
name|icost1
operator|=
literal|2
expr_stmt|;
else|else
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* ICOST0 determines whether we are treating operand 0 	   as a base register or as an index register. 	   SUPPRESS0 nonzero means it isn't a register at all. 	   ICOST1 and SUPPRESS1 are likewise for operand 1.  */
if|if
condition|(
operator|!
name|suppress0
condition|)
name|record_address_regs
argument_list|(
name|arg0
argument_list|,
literal|2
operator|-
name|icost0
argument_list|,
name|icost0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|suppress1
condition|)
name|record_address_regs
argument_list|(
name|arg1
argument_list|,
literal|2
operator|-
name|icost1
argument_list|,
name|icost1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|POST_INC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_DEC
case|:
comment|/* Double the importance of a pseudo register that is incremented 	 or decremented, since it would take two extra insns 	 if it ends up in the wrong place.  */
name|record_address_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|2
operator|*
name|bcost
argument_list|,
literal|2
operator|*
name|icost
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
block|{
specifier|register
name|struct
name|savings
modifier|*
name|pp
decl_stmt|;
specifier|register
name|enum
name|reg_class
name|class
decl_stmt|,
name|class1
decl_stmt|;
name|pp
operator|=
operator|&
name|savings
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
expr_stmt|;
name|pp
operator|->
name|nrefs
operator|++
expr_stmt|;
comment|/* We have an address (or part of one) that is just one register.  */
comment|/* Record BCOST worth of savings for classes contained 	   in BASE_REG_CLASS.  */
name|class
operator|=
name|BASE_REG_CLASS
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|NO_REGS
operator|&&
name|class
operator|!=
name|ALL_REGS
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|pp
operator|->
name|savings
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|+=
name|bcost
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|class1
operator|=
name|reg_class_subclasses
index|[
operator|(
name|int
operator|)
name|class
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|class1
operator|==
name|LIM_REG_CLASSES
condition|)
break|break;
name|pp
operator|->
name|savings
index|[
operator|(
name|int
operator|)
name|class1
index|]
operator|+=
name|bcost
expr_stmt|;
block|}
block|}
comment|/* Record ICOST worth of savings for classes contained 	   in INDEX_REG_CLASS.  */
name|class
operator|=
name|INDEX_REG_CLASS
expr_stmt|;
if|if
condition|(
name|icost
operator|!=
literal|0
operator|&&
name|class
operator|!=
name|NO_REGS
operator|&&
name|class
operator|!=
name|ALL_REGS
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|pp
operator|->
name|savings
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|+=
name|icost
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|class1
operator|=
name|reg_class_subclasses
index|[
operator|(
name|int
operator|)
name|class
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|class1
operator|==
name|LIM_REG_CLASSES
condition|)
break|break;
name|pp
operator|->
name|savings
index|[
operator|(
name|int
operator|)
name|class1
index|]
operator|+=
name|icost
expr_stmt|;
block|}
block|}
block|}
break|break;
default|default:
block|{
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|record_address_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|bcost
argument_list|,
name|icost
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REGISTER_CONSTRAINTS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This is the `regscan' pass of the compiler, run just before cse    and again just before loop.     It finds the first and last use of each pseudo-register    and records them in the vectors regno_first_uid, regno_last_uid.    REPEAT is nonzero the second time this is called.  */
end_comment

begin_comment
comment|/* Indexed by pseudo register number, gives uid of first insn using the reg    (as of the time reg_scan is called).  */
end_comment

begin_decl_stmt
name|short
modifier|*
name|regno_first_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by pseudo register number, gives uid of last insn using the reg    (as of the time reg_scan is called).  */
end_comment

begin_decl_stmt
name|short
modifier|*
name|regno_last_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of parallel sets and clobbers in any insn in this fn.    Always at least 3, since the combiner could put that many togetherm    and we want this to remain correct for all the remaining passes.  */
end_comment

begin_decl_stmt
name|int
name|max_parallel
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|reg_scan_mark_refs
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|reg_scan
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|,
name|repeat
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|int
name|repeat
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|repeat
condition|)
name|regno_first_uid
operator|=
operator|(
name|short
operator|*
operator|)
name|oballoc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|regno_first_uid
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|repeat
condition|)
name|regno_last_uid
operator|=
operator|(
name|short
operator|*
operator|)
name|oballoc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|regno_last_uid
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|max_parallel
operator|=
literal|3
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>
name|max_parallel
condition|)
name|max_parallel
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg_scan_mark_refs
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|reg_scan_mark_refs
parameter_list|(
name|x
parameter_list|,
name|uid
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|uid
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return;
case|case
name|REG
case|:
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|regno_last_uid
index|[
name|regno
index|]
operator|=
name|uid
expr_stmt|;
if|if
condition|(
name|regno_first_uid
index|[
name|regno
index|]
operator|==
literal|0
condition|)
name|regno_first_uid
index|[
name|regno
index|]
operator|=
name|uid
expr_stmt|;
block|}
break|break;
default|default:
block|{
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|reg_scan_mark_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|uid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
operator|&&
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|reg_scan_mark_refs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|uid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

end_unit

