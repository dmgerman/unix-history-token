begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Fold a constant sub-tree into a single node for C-compiler    Copyright (C) 1987, 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*@@ Fix lossage on folding division of big integers.  */
end_comment

begin_comment
comment|/*@@ This file should be rewritten to use an arbitary precision   @@ representation for "struct tree_int_cst" and "struct tree_real_cst".   @@ Perhaps the routines could also be used for bc/dc, and made a lib.   @@ The routines that translate from the ap rep should   @@ warn if precision et. al. is lost.   @@ This would also make life easier when this technology is used   @@ for cross-compilers.  */
end_comment

begin_comment
comment|/* There are only two entry points in this file:    fold and combine.     fold takes a tree as argument and returns a simplified tree.     combine takes a tree code for an arithmetic operation    and two operands that are trees for constant values    and returns the result of the specified operation on those values,    also as a tree.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_function_decl
specifier|static
name|void
name|lshift_double
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rshift_double
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lrotate_double
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rrotate_double
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* To do constant folding on INTEGER_CST nodes requires 64-bit arithmetic.    We do that by representing the 64-bit integer as 8 shorts,    with only 8 bits stored in each short, as a positive number.  */
end_comment

begin_comment
comment|/* Unpack a 64-bit integer into 8 shorts.    LOW and HI are the integer, as two `int' pieces.    SHORTS points to the array of shorts.  */
end_comment

begin_function
specifier|static
name|void
name|encode
parameter_list|(
name|shorts
parameter_list|,
name|low
parameter_list|,
name|hi
parameter_list|)
name|short
modifier|*
name|shorts
decl_stmt|;
name|int
name|low
decl_stmt|,
name|hi
decl_stmt|;
block|{
name|shorts
index|[
literal|0
index|]
operator|=
name|low
operator|&
literal|0xff
expr_stmt|;
name|shorts
index|[
literal|1
index|]
operator|=
operator|(
name|low
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|shorts
index|[
literal|2
index|]
operator|=
operator|(
name|low
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|shorts
index|[
literal|3
index|]
operator|=
operator|(
name|low
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|shorts
index|[
literal|4
index|]
operator|=
name|hi
operator|&
literal|0xff
expr_stmt|;
name|shorts
index|[
literal|5
index|]
operator|=
operator|(
name|hi
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|shorts
index|[
literal|6
index|]
operator|=
operator|(
name|hi
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|shorts
index|[
literal|7
index|]
operator|=
operator|(
name|hi
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pack an array of 8 shorts into a 64-bit integer.    SHORTS points to the array of shorts.    The integer is stored into *LOW and *HI as two `int' pieces.  */
end_comment

begin_function
specifier|static
name|void
name|decode
parameter_list|(
name|shorts
parameter_list|,
name|low
parameter_list|,
name|hi
parameter_list|)
name|short
modifier|*
name|shorts
decl_stmt|;
name|int
modifier|*
name|low
decl_stmt|,
decl|*
name|hi
decl_stmt|;
end_function

begin_block
block|{
operator|*
name|low
operator|=
operator|(
name|shorts
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|shorts
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|shorts
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|shorts
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|hi
operator|=
operator|(
name|shorts
index|[
literal|7
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|shorts
index|[
literal|6
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|shorts
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|shorts
index|[
literal|4
index|]
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Make the integer constant T valid for its type    by setting to 0 or 1 all the bits in the constant    that don't belong in the type.  */
end_comment

begin_function
specifier|static
name|void
name|force_fit_type
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
specifier|register
name|int
name|prec
init|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|prec
operator|=
name|BITS_PER_WORD
expr_stmt|;
comment|/* First clear all bits that are beyond the type's precision.  */
if|if
condition|(
name|prec
operator|==
literal|2
operator|*
name|HOST_BITS_PER_INT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|prec
operator|>
name|HOST_BITS_PER_INT
condition|)
block|{
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|&=
operator|~
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_INT
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prec
operator|<
name|HOST_BITS_PER_INT
condition|)
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|&=
operator|~
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
name|prec
operator|)
expr_stmt|;
block|}
comment|/* If it's a signed type and value's sign bit is set, extend the sign.  */
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|prec
operator|!=
literal|2
operator|*
name|HOST_BITS_PER_INT
operator|&&
operator|(
name|prec
operator|>
name|HOST_BITS_PER_INT
condition|?
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_INT
operator|-
literal|1
operator|)
operator|)
else|:
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|prec
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Value is negative: 	 set to 1 all the bits that are outside this type's precision.  */
if|if
condition|(
name|prec
operator|>
name|HOST_BITS_PER_INT
condition|)
block|{
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator||=
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
operator|(
name|prec
operator|-
name|HOST_BITS_PER_INT
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|prec
operator|<
name|HOST_BITS_PER_INT
condition|)
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator||=
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
name|prec
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add two 64-bit integers with 64-bit result.    Each argument is given as two `int' pieces.    One argument is L1 and H1; the other, L2 and H2.    The value is stored as two `int' pieces in *LV and *HV.    We use the 8-shorts representation internally.  */
end_comment

begin_function
specifier|static
name|void
name|add_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|l2
parameter_list|,
name|h2
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|)
name|int
name|l1
decl_stmt|,
name|h1
decl_stmt|,
name|l2
decl_stmt|,
name|h2
decl_stmt|;
name|int
modifier|*
name|lv
decl_stmt|,
decl|*
name|hv
decl_stmt|;
end_function

begin_block
block|{
name|short
name|arg1
index|[
literal|8
index|]
decl_stmt|;
name|short
name|arg2
index|[
literal|8
index|]
decl_stmt|;
specifier|register
name|int
name|carry
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|encode
argument_list|(
name|arg1
argument_list|,
name|l1
argument_list|,
name|h1
argument_list|)
expr_stmt|;
name|encode
argument_list|(
name|arg2
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|carry
operator|+=
name|arg1
index|[
name|i
index|]
operator|+
name|arg2
index|[
name|i
index|]
expr_stmt|;
name|arg1
index|[
name|i
index|]
operator|=
name|carry
operator|&
literal|0xff
expr_stmt|;
name|carry
operator|>>=
literal|8
expr_stmt|;
block|}
name|decode
argument_list|(
name|arg1
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Negate a 64-bit integers with 64-bit result.    The argument is given as two `int' pieces in L1 and H1.    The value is stored as two `int' pieces in *LV and *HV.    We use the 8-shorts representation internally.  */
end_comment

begin_function
specifier|static
name|void
name|neg_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|)
name|int
name|l1
decl_stmt|,
name|h1
decl_stmt|;
name|int
modifier|*
name|lv
decl_stmt|,
decl|*
name|hv
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|l1
operator|==
literal|0
condition|)
block|{
operator|*
name|lv
operator|=
literal|0
expr_stmt|;
operator|*
name|hv
operator|=
operator|-
name|h1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|lv
operator|=
operator|-
name|l1
expr_stmt|;
operator|*
name|hv
operator|=
operator|~
name|h1
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Multiply two 64-bit integers with 64-bit result.    Each argument is given as two `int' pieces.    One argument is L1 and H1; the other, L2 and H2.    The value is stored as two `int' pieces in *LV and *HV.    We use the 8-shorts representation internally.  */
end_comment

begin_function
specifier|static
name|void
name|mul_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|l2
parameter_list|,
name|h2
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|)
name|int
name|l1
decl_stmt|,
name|h1
decl_stmt|,
name|l2
decl_stmt|,
name|h2
decl_stmt|;
name|int
modifier|*
name|lv
decl_stmt|,
decl|*
name|hv
decl_stmt|;
end_function

begin_block
block|{
name|short
name|arg1
index|[
literal|8
index|]
decl_stmt|;
name|short
name|arg2
index|[
literal|8
index|]
decl_stmt|;
name|short
name|prod
index|[
literal|16
index|]
decl_stmt|;
specifier|register
name|int
name|carry
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/* These two cases are used extensively, arising from pointer      combinations.  */
if|if
condition|(
name|h2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|l2
operator|==
literal|2
condition|)
block|{
name|unsigned
name|temp
init|=
name|l1
operator|+
name|l1
decl_stmt|;
operator|*
name|hv
operator|=
name|h1
operator|*
literal|2
operator|+
operator|(
name|temp
operator|<
name|l1
operator|)
expr_stmt|;
operator|*
name|lv
operator|=
name|temp
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|l2
operator|==
literal|4
condition|)
block|{
name|unsigned
name|temp
init|=
name|l1
operator|+
name|l1
decl_stmt|;
name|h1
operator|=
name|h1
operator|*
literal|4
operator|+
operator|(
name|temp
operator|<
name|l1
operator|)
operator|<<
literal|1
expr_stmt|;
name|l1
operator|=
name|temp
expr_stmt|;
name|temp
operator|+=
name|temp
expr_stmt|;
name|h1
operator|+=
operator|(
name|temp
operator|<
name|l1
operator|)
expr_stmt|;
operator|*
name|lv
operator|=
name|temp
expr_stmt|;
operator|*
name|hv
operator|=
name|h1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|l2
operator|==
literal|8
condition|)
block|{
name|unsigned
name|temp
init|=
name|l1
operator|+
name|l1
decl_stmt|;
name|h1
operator|=
name|h1
operator|*
literal|8
operator|+
operator|(
name|temp
operator|<
name|l1
operator|)
operator|<<
literal|2
expr_stmt|;
name|l1
operator|=
name|temp
expr_stmt|;
name|temp
operator|+=
name|temp
expr_stmt|;
name|h1
operator|+=
operator|(
name|temp
operator|<
name|l1
operator|)
operator|<<
literal|1
expr_stmt|;
name|l1
operator|=
name|temp
expr_stmt|;
name|temp
operator|+=
name|temp
expr_stmt|;
name|h1
operator|+=
operator|(
name|temp
operator|<
name|l1
operator|)
expr_stmt|;
operator|*
name|lv
operator|=
name|temp
expr_stmt|;
operator|*
name|hv
operator|=
name|h1
expr_stmt|;
return|return;
block|}
block|}
name|encode
argument_list|(
name|arg1
argument_list|,
name|l1
argument_list|,
name|h1
argument_list|)
expr_stmt|;
name|encode
argument_list|(
name|arg2
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|prod
argument_list|,
sizeof|sizeof
name|prod
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|i
operator|+
name|j
expr_stmt|;
name|carry
operator|=
name|arg1
index|[
name|i
index|]
operator|*
name|arg2
index|[
name|j
index|]
expr_stmt|;
while|while
condition|(
name|carry
condition|)
block|{
name|carry
operator|+=
name|prod
index|[
name|k
index|]
expr_stmt|;
name|prod
index|[
name|k
index|]
operator|=
name|carry
operator|&
literal|0xff
expr_stmt|;
name|carry
operator|>>=
literal|8
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
block|}
name|decode
argument_list|(
name|prod
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|)
expr_stmt|;
comment|/* @@decode ignores prod[8] -> prod[15] */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Shift the 64-bit integer in L1, H1 left by COUNT places    keeping only PREC bits of result.    Shift right if COUNT is negative.    ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.    Store the value as two `int' pieces in *LV and *HV.  */
end_comment

begin_function
specifier|static
name|void
name|lshift_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|count
parameter_list|,
name|prec
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|,
name|arith
parameter_list|)
name|int
name|l1
decl_stmt|,
name|h1
decl_stmt|,
name|count
decl_stmt|,
name|prec
decl_stmt|;
name|int
modifier|*
name|lv
decl_stmt|,
decl|*
name|hv
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|arith
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|arg1
index|[
literal|8
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|carry
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rshift_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
operator|-
name|count
argument_list|,
name|prec
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|,
name|arith
argument_list|)
expr_stmt|;
return|return;
block|}
name|encode
argument_list|(
name|arg1
argument_list|,
name|l1
argument_list|,
name|h1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|prec
condition|)
name|count
operator|=
name|prec
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|carry
operator|+=
name|arg1
index|[
name|i
index|]
operator|<<
literal|1
expr_stmt|;
name|arg1
index|[
name|i
index|]
operator|=
name|carry
operator|&
literal|0xff
expr_stmt|;
name|carry
operator|>>=
literal|8
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
block|}
name|decode
argument_list|(
name|arg1
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Shift the 64-bit integer in L1, H1 right by COUNT places    keeping only PREC bits of result.  COUNT must be positive.    ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.    Store the value as two `int' pieces in *LV and *HV.  */
end_comment

begin_function
specifier|static
name|void
name|rshift_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|count
parameter_list|,
name|prec
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|,
name|arith
parameter_list|)
name|int
name|l1
decl_stmt|,
name|h1
decl_stmt|,
name|count
decl_stmt|,
name|prec
decl_stmt|;
name|int
modifier|*
name|lv
decl_stmt|,
decl|*
name|hv
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|arith
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|arg1
index|[
literal|8
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|carry
decl_stmt|;
name|encode
argument_list|(
name|arg1
argument_list|,
name|l1
argument_list|,
name|h1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|prec
condition|)
name|count
operator|=
name|prec
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|carry
operator|=
name|arith
operator|&&
name|arg1
index|[
literal|7
index|]
operator|>>
literal|7
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|carry
operator|<<=
literal|8
expr_stmt|;
name|carry
operator|+=
name|arg1
index|[
name|i
index|]
expr_stmt|;
name|arg1
index|[
name|i
index|]
operator|=
operator|(
name|carry
operator|>>
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
block|}
name|decode
argument_list|(
name|arg1
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Rotate the 64-bit integer in L1, H1 left by COUNT places    keeping only PREC bits of result.    Rotate right if COUNT is negative.    Store the value as two `int' pieces in *LV and *HV.  */
end_comment

begin_function
specifier|static
name|void
name|lrotate_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|count
parameter_list|,
name|prec
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|)
name|int
name|l1
decl_stmt|,
name|h1
decl_stmt|,
name|count
decl_stmt|,
name|prec
decl_stmt|;
name|int
modifier|*
name|lv
decl_stmt|,
decl|*
name|hv
decl_stmt|;
end_function

begin_block
block|{
name|short
name|arg1
index|[
literal|8
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|carry
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rrotate_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
operator|-
name|count
argument_list|,
name|prec
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|)
expr_stmt|;
return|return;
block|}
name|encode
argument_list|(
name|arg1
argument_list|,
name|l1
argument_list|,
name|h1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|prec
condition|)
name|count
operator|=
name|prec
expr_stmt|;
name|carry
operator|=
name|arg1
index|[
literal|7
index|]
operator|>>
literal|7
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|carry
operator|+=
name|arg1
index|[
name|i
index|]
operator|<<
literal|1
expr_stmt|;
name|arg1
index|[
name|i
index|]
operator|=
name|carry
operator|&
literal|0xff
expr_stmt|;
name|carry
operator|>>=
literal|8
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
block|}
name|decode
argument_list|(
name|arg1
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Rotate the 64-bit integer in L1, H1 left by COUNT places    keeping only PREC bits of result.  COUNT must be positive.    Store the value as two `int' pieces in *LV and *HV.  */
end_comment

begin_function
specifier|static
name|void
name|rrotate_double
parameter_list|(
name|l1
parameter_list|,
name|h1
parameter_list|,
name|count
parameter_list|,
name|prec
parameter_list|,
name|lv
parameter_list|,
name|hv
parameter_list|)
name|int
name|l1
decl_stmt|,
name|h1
decl_stmt|,
name|count
decl_stmt|,
name|prec
decl_stmt|;
name|int
modifier|*
name|lv
decl_stmt|,
decl|*
name|hv
decl_stmt|;
end_function

begin_block
block|{
name|short
name|arg1
index|[
literal|8
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|carry
decl_stmt|;
name|encode
argument_list|(
name|arg1
argument_list|,
name|l1
argument_list|,
name|h1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|prec
condition|)
name|count
operator|=
name|prec
expr_stmt|;
name|carry
operator|=
name|arg1
index|[
literal|0
index|]
operator|&
literal|1
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|carry
operator|<<=
literal|8
expr_stmt|;
name|carry
operator|+=
name|arg1
index|[
name|i
index|]
expr_stmt|;
name|arg1
index|[
name|i
index|]
operator|=
operator|(
name|carry
operator|>>
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
block|}
name|decode
argument_list|(
name|arg1
argument_list|,
name|lv
argument_list|,
name|hv
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Divide 64 bit integer LNUM, HNUM by 64 bit integer LDEN, HDEN    for a quotient (stored in *LQUO, *HQUO) and remainder (in *LREM, *HREM).    CODE is a tree code for a kind of division, one of    TRUNC_DIV_EXPR, FLOOR_DIV_EXPR, CEIL_DIV_EXPR, ROUND_DIV_EXPR    or EXACT_DIV_EXPR    It controls how the quotient is rounded to a integer.    UNS nonzero says do unsigned division.  */
end_comment

begin_function
specifier|static
name|void
name|div_and_round_double
parameter_list|(
name|code
parameter_list|,
name|uns
parameter_list|,
name|lnum_orig
parameter_list|,
name|hnum_orig
parameter_list|,
name|lden_orig
parameter_list|,
name|hden_orig
parameter_list|,
name|lquo
parameter_list|,
name|hquo
parameter_list|,
name|lrem
parameter_list|,
name|hrem
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|uns
decl_stmt|;
name|int
name|lnum_orig
decl_stmt|,
name|hnum_orig
decl_stmt|;
comment|/* num == numerator == dividend */
name|int
name|lden_orig
decl_stmt|,
name|hden_orig
decl_stmt|;
comment|/* den == denominator == divisor */
name|int
modifier|*
name|lquo
decl_stmt|,
decl|*
name|hquo
decl_stmt|,
modifier|*
name|lrem
decl_stmt|,
modifier|*
name|hrem
decl_stmt|;
end_function

begin_block
block|{
name|int
name|quo_neg
init|=
literal|0
decl_stmt|;
name|short
name|num
index|[
literal|9
index|]
decl_stmt|,
name|den
index|[
literal|8
index|]
decl_stmt|,
name|quo
index|[
literal|8
index|]
decl_stmt|;
comment|/* extra element for scaling.  */
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|work
decl_stmt|;
specifier|register
name|int
name|carry
init|=
literal|0
decl_stmt|;
name|int
name|lnum
init|=
name|lnum_orig
decl_stmt|,
name|hnum
init|=
name|hnum_orig
decl_stmt|;
name|int
name|lden
init|=
name|lden_orig
decl_stmt|,
name|hden
init|=
name|hden_orig
decl_stmt|;
if|if
condition|(
operator|(
name|hden
operator|==
literal|0
operator|)
operator|&&
operator|(
name|lden
operator|==
literal|0
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* calculate quotient sign and convert operands to unsigned.  */
if|if
condition|(
operator|!
name|uns
condition|)
block|{
if|if
condition|(
name|hden
operator|<
literal|0
condition|)
block|{
name|quo_neg
operator|=
operator|~
name|quo_neg
expr_stmt|;
name|neg_double
argument_list|(
name|lden
argument_list|,
name|hden
argument_list|,
operator|&
name|lden
argument_list|,
operator|&
name|hden
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hnum
operator|<
literal|0
condition|)
block|{
name|quo_neg
operator|=
operator|~
name|quo_neg
expr_stmt|;
name|neg_double
argument_list|(
name|lnum
argument_list|,
name|hnum
argument_list|,
operator|&
name|lnum
argument_list|,
operator|&
name|hnum
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hnum
operator|==
literal|0
operator|&&
name|hden
operator|==
literal|0
condition|)
block|{
comment|/* single precision */
operator|*
name|hquo
operator|=
operator|*
name|hrem
operator|=
literal|0
expr_stmt|;
operator|*
name|lquo
operator|=
operator|(
name|unsigned
operator|)
name|lnum
operator|/
name|lden
expr_stmt|;
comment|/* rounds toward zero since positive args */
goto|goto
name|finish_up
goto|;
block|}
if|if
condition|(
name|hnum
operator|==
literal|0
condition|)
block|{
comment|/* trivial case: dividend< divisor */
comment|/* hden != 0 already checked.  */
operator|*
name|hquo
operator|=
operator|*
name|lquo
operator|=
literal|0
expr_stmt|;
operator|*
name|hrem
operator|=
name|hnum
expr_stmt|;
operator|*
name|lrem
operator|=
name|lnum
expr_stmt|;
goto|goto
name|finish_up
goto|;
block|}
name|bzero
argument_list|(
name|quo
argument_list|,
sizeof|sizeof
name|quo
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|num
argument_list|,
sizeof|sizeof
name|num
argument_list|)
expr_stmt|;
comment|/* to zero 9th element */
name|bzero
argument_list|(
name|den
argument_list|,
sizeof|sizeof
name|den
argument_list|)
expr_stmt|;
name|encode
argument_list|(
name|num
argument_list|,
name|lnum
argument_list|,
name|hnum
argument_list|)
expr_stmt|;
name|encode
argument_list|(
name|den
argument_list|,
name|lden
argument_list|,
name|hden
argument_list|)
expr_stmt|;
if|if
condition|(
name|hden
operator|==
literal|0
condition|)
block|{
comment|/* simpler algorithm */
comment|/* hnum != 0 already checked.  */
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|work
operator|=
name|num
index|[
name|i
index|]
operator|+
operator|(
name|carry
operator|<<
literal|8
operator|)
expr_stmt|;
name|quo
index|[
name|i
index|]
operator|=
name|work
operator|/
name|lden
expr_stmt|;
name|carry
operator|=
name|work
operator|%
name|lden
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* full double precision, 				   with thanks to Don Knuth's 				   "Semi-Numericial Algorithms".  */
define|#
directive|define
name|BASE
value|256
name|int
name|quo_est
decl_stmt|,
name|scale
decl_stmt|,
name|num_hi_sig
decl_stmt|,
name|den_hi_sig
decl_stmt|,
name|quo_hi_sig
decl_stmt|;
comment|/* Find the highest non-zero divisor digit.  */
for|for
control|(
name|i
operator|=
literal|7
init|;
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|den
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|den_hi_sig
operator|=
name|i
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|7
init|;
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|num
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|num_hi_sig
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|quo_hi_sig
operator|=
name|num_hi_sig
operator|-
name|den_hi_sig
operator|+
literal|1
expr_stmt|;
comment|/* Insure that the first digit of the divisor is at least BASE/2.        This is required by the quotient digit estimation algorithm.  */
name|scale
operator|=
name|BASE
operator|/
operator|(
name|den
index|[
name|den_hi_sig
index|]
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|scale
operator|>
literal|1
condition|)
block|{
comment|/* scale divisor and dividend */
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|work
operator|=
operator|(
name|num
index|[
name|i
index|]
operator|*
name|scale
operator|)
operator|+
name|carry
expr_stmt|;
name|num
index|[
name|i
index|]
operator|=
name|work
operator|&
literal|0xff
expr_stmt|;
name|carry
operator|=
name|work
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|num
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|num_hi_sig
operator|=
name|i
expr_stmt|;
block|}
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|work
operator|=
operator|(
name|den
index|[
name|i
index|]
operator|*
name|scale
operator|)
operator|+
name|carry
expr_stmt|;
name|den
index|[
name|i
index|]
operator|=
name|work
operator|&
literal|0xff
expr_stmt|;
name|carry
operator|=
name|work
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|den
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|den_hi_sig
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* Main loop */
for|for
control|(
name|i
operator|=
name|quo_hi_sig
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* quess the next quotient digit, quo_est, by dividing the first 	 two remaining dividend digits by the high order quotient digit. 	 quo_est is never low and is at most 2 high.  */
name|int
name|num_hi
decl_stmt|;
comment|/* index of highest remaining dividend digit */
name|num_hi
operator|=
name|i
operator|+
name|den_hi_sig
expr_stmt|;
name|work
operator|=
operator|(
name|num
index|[
name|num_hi
index|]
operator|*
name|BASE
operator|)
operator|+
operator|(
name|num_hi
condition|?
literal|0
else|:
name|num
index|[
name|num_hi
operator|-
literal|1
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|num
index|[
name|num_hi
index|]
operator|!=
name|den
index|[
name|den_hi_sig
index|]
condition|)
block|{
name|quo_est
operator|=
name|work
operator|/
name|den
index|[
name|den_hi_sig
index|]
expr_stmt|;
block|}
else|else
block|{
name|quo_est
operator|=
name|BASE
operator|-
literal|1
expr_stmt|;
block|}
comment|/* refine quo_est so it's usually correct, and at most one high.   */
while|while
condition|(
operator|(
name|den
index|[
name|den_hi_sig
operator|-
literal|1
index|]
operator|*
name|quo_est
operator|)
operator|>
operator|(
operator|(
operator|(
name|work
operator|-
operator|(
name|quo_est
operator|*
name|den
index|[
name|den_hi_sig
index|]
operator|)
operator|)
operator|*
name|BASE
operator|)
operator|+
operator|(
operator|(
name|num_hi
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|num
index|[
name|num_hi
operator|-
literal|2
index|]
operator|)
operator|)
condition|)
block|{
name|quo_est
operator|--
expr_stmt|;
block|}
comment|/* try quo_est as the quotient digit, by multiplying the          divisor by quo_est and subtracting from the remaining dividend.  */
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|den_hi_sig
condition|;
name|j
operator|++
control|)
block|{
name|int
name|digit
decl_stmt|;
name|work
operator|=
name|num
index|[
name|i
operator|+
name|j
index|]
operator|-
operator|(
name|quo_est
operator|*
name|den
index|[
name|j
index|]
operator|)
operator|+
name|carry
expr_stmt|;
name|digit
operator|=
name|work
operator|&
literal|0xff
expr_stmt|;
name|carry
operator|=
name|work
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|digit
operator|<
literal|0
condition|)
block|{
name|digit
operator|+=
name|BASE
expr_stmt|;
name|carry
operator|--
expr_stmt|;
block|}
name|num
index|[
name|i
operator|+
name|j
index|]
operator|=
name|digit
expr_stmt|;
block|}
comment|/* if quo_est was high by one, then num[i] went negative and 	 we need to correct things.  */
if|if
condition|(
name|num
index|[
name|num_hi
index|]
operator|<
literal|0
condition|)
block|{
name|quo_est
operator|--
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
comment|/* add divisor back in */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|den_hi_sig
condition|;
name|j
operator|++
control|)
block|{
name|work
operator|=
name|num
index|[
name|i
operator|+
name|j
index|]
operator|+
name|den
index|[
name|j
index|]
operator|+
name|carry
expr_stmt|;
if|if
condition|(
name|work
operator|>
name|BASE
condition|)
block|{
name|work
operator|-=
name|BASE
expr_stmt|;
name|carry
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|carry
operator|=
literal|0
expr_stmt|;
block|}
name|num
index|[
name|i
operator|+
name|j
index|]
operator|=
name|work
expr_stmt|;
block|}
name|num
index|[
name|num_hi
index|]
operator|+=
name|carry
expr_stmt|;
block|}
comment|/* store the quotient digit.  */
name|quo
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|quo_est
expr_stmt|;
block|}
block|}
name|decode
argument_list|(
name|quo
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
name|finish_up
label|:
comment|/* if result is negative, make it so.  */
if|if
condition|(
name|quo_neg
condition|)
name|neg_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
comment|/* compute trial remainder:  rem = num - (quo * den)  */
name|mul_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
name|lden_orig
argument_list|,
name|hden_orig
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|neg_double
argument_list|(
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|lnum_orig
argument_list|,
name|hnum_orig
argument_list|,
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
comment|/* round toward zero */
case|case
name|EXACT_DIV_EXPR
case|:
comment|/* for this one, it shouldn't matter */
return|return;
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
comment|/* round toward negative infinity */
if|if
condition|(
name|quo_neg
operator|&&
operator|(
operator|*
name|lrem
operator|!=
literal|0
operator|||
operator|*
name|hrem
operator|!=
literal|0
operator|)
condition|)
comment|/* ratio< 0&& rem != 0 */
block|{
comment|/* quo = quo - 1;  */
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
block|}
else|else
return|return;
break|break;
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
comment|/* round toward positive infinity */
if|if
condition|(
operator|!
name|quo_neg
operator|&&
operator|(
operator|*
name|lrem
operator|!=
literal|0
operator|||
operator|*
name|hrem
operator|!=
literal|0
operator|)
condition|)
comment|/* ratio> 0&& rem != 0 */
block|{
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
block|}
else|else
return|return;
break|break;
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
comment|/* round to closest integer */
block|{
name|int
name|labs_rem
init|=
operator|*
name|lrem
decl_stmt|,
name|habs_rem
init|=
operator|*
name|hrem
decl_stmt|;
name|int
name|labs_den
init|=
name|lden
decl_stmt|,
name|habs_den
init|=
name|hden
decl_stmt|,
name|ltwice
decl_stmt|,
name|htwice
decl_stmt|;
comment|/* get absolute values */
if|if
condition|(
operator|*
name|hrem
operator|<
literal|0
condition|)
name|neg_double
argument_list|(
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
operator|&
name|labs_rem
argument_list|,
operator|&
name|habs_rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|hden
operator|<
literal|0
condition|)
name|neg_double
argument_list|(
name|lden
argument_list|,
name|hden
argument_list|,
operator|&
name|labs_den
argument_list|,
operator|&
name|habs_den
argument_list|)
expr_stmt|;
comment|/* if (2 * abs (lrem)>= abs (lden)) */
name|mul_double
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|labs_rem
argument_list|,
name|habs_rem
argument_list|,
operator|&
name|ltwice
argument_list|,
operator|&
name|htwice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|unsigned
operator|)
name|habs_den
operator|<
operator|(
name|unsigned
operator|)
name|htwice
operator|)
operator|||
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|habs_den
operator|==
operator|(
name|unsigned
operator|)
name|htwice
operator|)
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|labs_den
operator|<
operator|(
name|unsigned
operator|)
name|ltwice
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|hquo
operator|<
literal|0
condition|)
comment|/* quo = quo - 1;  */
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
else|else
comment|/* quo = quo + 1; */
name|add_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|lquo
argument_list|,
name|hquo
argument_list|)
expr_stmt|;
block|}
else|else
return|return;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* compute true remainder:  rem = num - (quo * den)  */
name|mul_double
argument_list|(
operator|*
name|lquo
argument_list|,
operator|*
name|hquo
argument_list|,
name|lden_orig
argument_list|,
name|hden_orig
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|neg_double
argument_list|(
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|lnum_orig
argument_list|,
name|hnum_orig
argument_list|,
operator|*
name|lrem
argument_list|,
operator|*
name|hrem
argument_list|,
name|lrem
argument_list|,
name|hrem
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Split a tree IN into a constant and a variable part    that could be combined with CODE to make IN.    CODE must be a commutative arithmetic operation.    Store the constant part into *CONP and the variable in&VARP.    Return 1 if this was done; zero means the tree IN did not decompose    this way.     If CODE is PLUS_EXPR we also split trees that use MINUS_EXPR.    Therefore, we must tell the caller whether the variable part    was subtracted.  We do this by storing 1 or -1 into *VARSIGNP.    The value stored is the coefficient for the variable term.    The constant term we return should always be added;    we negate it if necessary.  */
end_comment

begin_function
specifier|static
name|int
name|split_tree
parameter_list|(
name|in
parameter_list|,
name|code
parameter_list|,
name|varp
parameter_list|,
name|conp
parameter_list|,
name|varsignp
parameter_list|)
name|tree
name|in
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
modifier|*
name|varp
decl_stmt|,
decl|*
name|conp
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|varsignp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|tree
name|outtype
init|=
name|TREE_TYPE
argument_list|(
name|in
argument_list|)
decl_stmt|;
operator|*
name|varp
operator|=
literal|0
expr_stmt|;
operator|*
name|conp
operator|=
literal|0
expr_stmt|;
comment|/* Strip any conversions that don't change the machine mode.  */
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|in
operator|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|code
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|in
argument_list|)
argument_list|)
operator|!=
name|REAL_TYPE
comment|/* We can associate addition and subtraction together 	     (even though the C standard doesn't say so) 	     for integers because the value is not affected. 	     For reals, the value might be affected, so we can't.  */
operator|&&
operator|(
operator|(
name|code
operator|==
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|||
operator|(
name|code
operator|==
name|MINUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|PLUS_EXPR
operator|)
operator|)
operator|)
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|INTEGER_CST
condition|)
block|{
operator|*
name|conp
operator|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|varp
operator|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
operator|*
name|varp
argument_list|)
operator|!=
name|outtype
condition|)
operator|*
name|varp
operator|=
name|convert
argument_list|(
name|outtype
argument_list|,
operator|*
name|varp
argument_list|)
expr_stmt|;
operator|*
name|varsignp
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|TREE_LITERAL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|conp
operator|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|varp
operator|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|varsignp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
operator|*
name|varp
argument_list|)
operator|!=
name|outtype
condition|)
operator|*
name|varp
operator|=
name|convert
argument_list|(
name|outtype
argument_list|,
operator|*
name|varp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
block|{
comment|/* If operation is subtraction and constant is second, 		 must negate it to get an additive constant. 		 And this cannot be done unless it is a manifest constant. 		 It could also be the address of a static variable. 		 We cannot negate that, so give up.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|conp
argument_list|)
operator|==
name|INTEGER_CST
condition|)
operator|*
name|conp
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|conp
argument_list|)
argument_list|,
operator|*
name|conp
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
name|TREE_LITERAL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|conp
operator|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|varp
operator|=
name|TREE_OPERAND
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
operator|*
name|varp
argument_list|)
operator|!=
name|outtype
condition|)
operator|*
name|varp
operator|=
name|convert
argument_list|(
name|outtype
argument_list|,
operator|*
name|varp
argument_list|)
expr_stmt|;
operator|*
name|varsignp
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Combine two constants NUM and ARG2 under operation CODE    to produce a new constant.    We assume ARG1 and ARG2 have the same data type,    or at least are the same kind of constant and the same machine mode.  */
end_comment

begin_comment
comment|/* Handle floating overflow for `combine'.  */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|combine_error
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|combine
parameter_list|(
name|code
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
specifier|register
name|tree
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
specifier|register
name|int
name|int1l
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
specifier|register
name|int
name|int1h
init|=
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|int
name|int2l
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|int
name|int2h
init|=
name|TREE_INT_CST_HIGH
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|int
name|low
decl_stmt|,
name|hi
decl_stmt|;
name|int
name|garbagel
decl_stmt|,
name|garbageh
decl_stmt|;
specifier|register
name|tree
name|t
decl_stmt|;
name|int
name|uns
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BIT_IOR_EXPR
case|:
name|t
operator|=
name|build_int_2
argument_list|(
name|int1l
operator||
name|int2l
argument_list|,
name|int1h
operator||
name|int2h
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_XOR_EXPR
case|:
name|t
operator|=
name|build_int_2
argument_list|(
name|int1l
operator|^
name|int2l
argument_list|,
name|int1h
operator|^
name|int2h
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
name|t
operator|=
name|build_int_2
argument_list|(
name|int1l
operator|&
name|int2l
argument_list|,
name|int1h
operator|&
name|int2h
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_ANDTC_EXPR
case|:
name|t
operator|=
name|build_int_2
argument_list|(
name|int1l
operator|&
operator|~
name|int2l
argument_list|,
name|int1h
operator|&
operator|~
name|int2h
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSHIFT_EXPR
case|:
name|int2l
operator|=
operator|-
name|int2l
expr_stmt|;
case|case
name|LSHIFT_EXPR
case|:
name|lshift_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|,
operator|!
name|uns
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|RROTATE_EXPR
case|:
name|int2l
operator|=
operator|-
name|int2l
expr_stmt|;
case|case
name|LROTATE_EXPR
case|:
name|lrotate_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
name|int1h
operator|==
literal|0
condition|)
block|{
name|int2l
operator|+=
name|int1l
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|int2l
operator|<
name|int1l
condition|)
name|int2h
operator|+=
literal|1
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|int2l
argument_list|,
name|int2h
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|int2h
operator|==
literal|0
condition|)
block|{
name|int1l
operator|+=
name|int2l
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|int1l
operator|<
name|int2l
condition|)
name|int1h
operator|+=
literal|1
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|)
expr_stmt|;
break|break;
block|}
name|add_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
name|int1h
operator|==
literal|0
operator|&&
name|int1l
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|build_int_2
argument_list|(
operator|-
name|int2l
argument_list|,
operator|-
name|int2h
operator|-
operator|(
name|int2l
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|int2h
operator|==
literal|0
operator|&&
name|int2l
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|build_int_2
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|)
expr_stmt|;
break|break;
block|}
name|neg_double
argument_list|(
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|int2l
argument_list|,
operator|&
name|int2h
argument_list|)
expr_stmt|;
name|add_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
comment|/* Optimize simple cases.  */
if|if
condition|(
name|int1h
operator|==
literal|0
condition|)
block|{
name|unsigned
name|temp
decl_stmt|;
switch|switch
condition|(
name|int1l
condition|)
block|{
case|case
literal|0
case|:
name|t
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|got_it
goto|;
case|case
literal|1
case|:
name|t
operator|=
name|build_int_2
argument_list|(
name|int2l
argument_list|,
name|int2h
argument_list|)
expr_stmt|;
goto|goto
name|got_it
goto|;
case|case
literal|2
case|:
name|temp
operator|=
name|int2l
operator|+
name|int2l
expr_stmt|;
name|int2h
operator|=
name|int2h
operator|*
literal|2
operator|+
operator|(
name|temp
operator|<
name|int2l
operator|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|temp
argument_list|,
name|int2h
argument_list|)
expr_stmt|;
goto|goto
name|got_it
goto|;
case|case
literal|3
case|:
name|temp
operator|=
name|int2l
operator|+
name|int2l
operator|+
name|int2l
expr_stmt|;
name|int2h
operator|=
name|int2h
operator|*
literal|3
operator|+
operator|(
name|temp
operator|<
name|int2l
operator|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|temp
argument_list|,
name|int2h
argument_list|)
expr_stmt|;
goto|goto
name|got_it
goto|;
case|case
literal|4
case|:
name|temp
operator|=
name|int2l
operator|+
name|int2l
expr_stmt|;
name|int2h
operator|=
name|int2h
operator|*
literal|4
operator|+
operator|(
name|temp
operator|<
name|int2l
operator|)
operator|<<
literal|1
expr_stmt|;
name|int2l
operator|=
name|temp
expr_stmt|;
name|temp
operator|+=
name|temp
expr_stmt|;
name|int2h
operator|+=
operator|(
name|temp
operator|<
name|int2l
operator|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|temp
argument_list|,
name|int2h
argument_list|)
expr_stmt|;
goto|goto
name|got_it
goto|;
case|case
literal|8
case|:
name|temp
operator|=
name|int2l
operator|+
name|int2l
expr_stmt|;
name|int2h
operator|=
name|int2h
operator|*
literal|8
operator|+
operator|(
name|temp
operator|<
name|int2l
operator|)
operator|<<
literal|2
expr_stmt|;
name|int2l
operator|=
name|temp
expr_stmt|;
name|temp
operator|+=
name|temp
expr_stmt|;
name|int2h
operator|+=
operator|(
name|temp
operator|<
name|int2l
operator|)
operator|<<
literal|1
expr_stmt|;
name|int2l
operator|=
name|temp
expr_stmt|;
name|temp
operator|+=
name|temp
expr_stmt|;
name|int2h
operator|+=
operator|(
name|temp
operator|<
name|int2l
operator|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|temp
argument_list|,
name|int2h
argument_list|)
expr_stmt|;
goto|goto
name|got_it
goto|;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|int2h
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|int2l
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|int2l
operator|==
literal|1
condition|)
block|{
name|t
operator|=
name|build_int_2
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|mul_double
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
if|if
condition|(
name|int2h
operator|==
literal|0
operator|&&
name|int2l
operator|==
literal|1
condition|)
block|{
name|t
operator|=
name|build_int_2
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|int1l
operator|==
name|int2l
operator|&&
name|int1h
operator|==
name|int2h
condition|)
block|{
if|if
condition|(
operator|(
name|int1l
operator||
name|int1h
operator|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|div_and_round_double
argument_list|(
name|code
argument_list|,
name|uns
argument_list|,
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|garbagel
argument_list|,
operator|&
name|garbageh
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
name|div_and_round_double
argument_list|(
name|code
argument_list|,
name|uns
argument_list|,
name|int1l
argument_list|,
name|int1h
argument_list|,
name|int2l
argument_list|,
name|int2h
argument_list|,
operator|&
name|garbagel
argument_list|,
operator|&
name|garbageh
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|hi
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
if|if
condition|(
name|uns
condition|)
block|{
name|low
operator|=
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|int1h
operator|<
operator|(
name|unsigned
operator|)
name|int2h
operator|)
operator|||
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|int1h
operator|==
operator|(
name|unsigned
operator|)
name|int2h
operator|)
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|int1l
operator|<
operator|(
name|unsigned
operator|)
name|int2l
operator|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|low
operator|=
operator|(
operator|(
name|int1h
operator|<
name|int2h
operator|)
operator|||
operator|(
operator|(
name|int1h
operator|==
name|int2h
operator|)
operator|&&
operator|(
operator|(
name|unsigned
operator|)
name|int1l
operator|<
operator|(
name|unsigned
operator|)
name|int2l
operator|)
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|low
operator|==
operator|(
name|code
operator|==
name|MIN_EXPR
operator|)
condition|)
name|t
operator|=
name|build_int_2
argument_list|(
name|int1l
argument_list|,
name|int1h
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|build_int_2
argument_list|(
name|int2l
argument_list|,
name|int2h
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|got_it
label|:
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|force_fit_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
specifier|register
name|REAL_VALUE_TYPE
name|d1
init|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
specifier|register
name|REAL_VALUE_TYPE
name|d2
init|=
name|TREE_REAL_CST
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
specifier|register
name|REAL_VALUE_TYPE
name|value
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|combine_error
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"floating overflow in constant folding"
argument_list|)
expr_stmt|;
return|return
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
block|}
name|set_float_handler
argument_list|(
name|combine_error
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
name|REAL_ARITHMETIC
argument_list|(
name|value
argument_list|,
name|code
argument_list|,
name|d1
argument_list|,
name|d2
argument_list|)
expr_stmt|;
else|#
directive|else
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
name|value
operator|=
name|d1
operator|+
name|d2
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|value
operator|=
name|d1
operator|-
name|d2
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|value
operator|=
name|d1
operator|*
name|d2
expr_stmt|;
break|break;
case|case
name|RDIV_EXPR
case|:
if|if
condition|(
name|d2
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|value
operator|=
name|d1
operator|/
name|d2
expr_stmt|;
break|break;
case|case
name|MIN_EXPR
case|:
name|value
operator|=
name|d1
operator|<
name|d2
condition|?
name|d1
else|:
name|d2
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
name|value
operator|=
name|d1
operator|>
name|d2
condition|?
name|d1
else|:
name|d2
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* no REAL_ARITHMETIC */
name|set_float_handler
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|build_real
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|COMPLEX_CST
condition|)
block|{
specifier|register
name|tree
name|r1
init|=
name|TREE_REALPART
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|i1
init|=
name|TREE_IMAGPART
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|r2
init|=
name|TREE_REALPART
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|i2
init|=
name|TREE_IMAGPART
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|t
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
name|t
operator|=
name|build_complex
argument_list|(
name|combine
argument_list|(
name|PLUS_EXPR
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
argument_list|,
name|combine
argument_list|(
name|PLUS_EXPR
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|t
operator|=
name|build_complex
argument_list|(
name|combine
argument_list|(
name|MINUS_EXPR
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
argument_list|,
name|combine
argument_list|(
name|MINUS_EXPR
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|t
operator|=
name|build_complex
argument_list|(
name|combine
argument_list|(
name|MINUS_EXPR
argument_list|,
name|combine
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
argument_list|,
name|combine
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|)
argument_list|)
argument_list|,
name|combine
argument_list|(
name|PLUS_EXPR
argument_list|,
name|combine
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|i2
argument_list|)
argument_list|,
name|combine
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|r2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDIV_EXPR
case|:
block|{
specifier|register
name|tree
name|magsquared
init|=
name|combine
argument_list|(
name|PLUS_EXPR
argument_list|,
name|combine
argument_list|(
name|MULT_EXPR
argument_list|,
name|r2
argument_list|,
name|r2
argument_list|)
argument_list|,
name|combine
argument_list|(
name|MULT_EXPR
argument_list|,
name|i2
argument_list|,
name|i2
argument_list|)
argument_list|)
decl_stmt|;
name|t
operator|=
name|build_complex
argument_list|(
name|combine
argument_list|(
name|RDIV_EXPR
argument_list|,
name|combine
argument_list|(
name|PLUS_EXPR
argument_list|,
name|combine
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
argument_list|,
name|combine
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|i2
argument_list|)
argument_list|)
argument_list|,
name|magsquared
argument_list|)
argument_list|,
name|combine
argument_list|(
name|RDIV_EXPR
argument_list|,
name|combine
argument_list|(
name|MINUS_EXPR
argument_list|,
name|combine
argument_list|(
name|MULT_EXPR
argument_list|,
name|i1
argument_list|,
name|r2
argument_list|)
argument_list|,
name|combine
argument_list|(
name|MULT_EXPR
argument_list|,
name|r1
argument_list|,
name|i2
argument_list|)
argument_list|)
argument_list|,
name|magsquared
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given T, a tree representing type conversion of a constant,    return a constant tree representing the result of conversion.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_convert
parameter_list|(
name|t
parameter_list|)
specifier|register
name|tree
name|t
decl_stmt|;
block|{
specifier|register
name|tree
name|arg1
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* Given an integer constant, make new constant with new type, 	     appropriately sign-extended or truncated.  */
name|t
operator|=
name|build_int_2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|force_fit_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
if|if
condition|(
name|REAL_VALUES_LESS
argument_list|(
name|real_value_from_int_cst
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|||
name|REAL_VALUES_LESS
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|real_value_from_int_cst
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"real constant out of range for integer conversion"
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
ifndef|#
directive|ifndef
name|REAL_ARITHMETIC
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
name|int
name|half_word
init|=
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_INT
operator|/
literal|2
operator|)
decl_stmt|;
name|d
operator|=
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|d
operator|=
operator|-
name|d
expr_stmt|;
name|high
operator|=
call|(
name|int
call|)
argument_list|(
name|d
operator|/
name|half_word
operator|/
name|half_word
argument_list|)
expr_stmt|;
name|d
operator|-=
operator|(
name|REAL_VALUE_TYPE
operator|)
name|high
operator|*
name|half_word
operator|*
name|half_word
expr_stmt|;
name|low
operator|=
operator|(
name|unsigned
operator|)
name|d
expr_stmt|;
if|if
condition|(
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
operator|<
literal|0
condition|)
name|neg_double
argument_list|(
name|low
argument_list|,
name|high
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
block|{
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
name|REAL_VALUE_TO_INT
argument_list|(
name|low
argument_list|,
name|high
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|force_fit_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|build_real_from_int_cst
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
return|return
name|build_real
argument_list|(
name|type
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
block|}
name|TREE_LITERAL
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if two constants (that are not manifest constants)    are necessarily equal.  It detects only the easiest, common case of    equality.  */
end_comment

begin_function
specifier|static
name|int
name|operand_equal_p
parameter_list|(
name|arg0
parameter_list|,
name|arg1
parameter_list|)
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
block|{
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
end_if

begin_comment
comment|/* Return 1 if ARG is a real constant with value zero.    This function is not defined in the case where it is impossible    to tell whether a real constant is zero (for cross-compilation).  */
end_comment

begin_function
specifier|static
name|int
name|real_zerop
parameter_list|(
name|arg
parameter_list|)
name|tree
name|arg
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|REAL_IS_NOT_DOUBLE
name|tree
name|t1
init|=
name|build_real_from_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
decl_stmt|;
return|return
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|t1
argument_list|)
argument_list|)
return|;
else|#
directive|else
return|return
name|TREE_REAL_CST
argument_list|(
name|arg
argument_list|)
operator|==
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Perform constant folding and related simplification of EXPR.    The related simplifications include x*1 => x, x*0 => 0, etc.,    and application of the associative law.    NOP_EXPR conversions may be removed freely (as long as we    are careful not to change the C type of the overall expression)    We cannot simplify through a CONVERT_EXPR, FIX_EXPR or FLOAT_EXPR,    but we can constant-fold them if they have constant operands.  */
end_comment

begin_function
name|tree
name|fold
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|t
init|=
name|expr
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
specifier|register
name|int
name|kind
decl_stmt|;
comment|/* WINS will be nonzero when the switch is done      if all operands are constant.       LOSES will be nonzero when the switch is done      if any operand is volatile.      This inhibits optimizations such as  (foo () * 0) => 0.      But identity-element optimizations such as      (foo () * 1) => (foo ()) can be done even if LOSES is set.  */
name|int
name|wins
init|=
literal|1
decl_stmt|;
name|int
name|loses
init|=
literal|0
decl_stmt|;
comment|/* Return right away if already constant.  */
if|if
condition|(
name|TREE_LITERAL
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|CONST_DECL
condition|)
return|return
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
return|;
return|return
name|t
return|;
block|}
name|kind
operator|=
operator|*
name|tree_code_type
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
if|if
condition|(
name|kind
operator|==
literal|'e'
operator|||
name|kind
operator|==
literal|'r'
condition|)
block|{
specifier|register
name|int
name|len
init|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Valid for CALL_EXPR, at least.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|REAL_CST
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
condition|)
comment|/* Note that TREE_LITERAL isn't enough: 	       static var addresses are constant but we can't 	       do arithmetic on them.  */
name|wins
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_VOLATILE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
name|loses
operator|=
literal|1
expr_stmt|;
block|}
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|1
condition|)
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now WINS and LOSES are set as described above,      ARG0 is the first operand of EXPR,      and ARG1 is the second operand (if it has more than one operand).  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|COMPLEX_CST
case|:
case|case
name|CONSTRUCTOR
case|:
return|return
name|t
return|;
case|case
name|CONST_DECL
case|:
return|return
name|fold
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
comment|/* Other kinds of FIX are not handled properly by fold_convert.  */
if|if
condition|(
operator|!
name|wins
condition|)
block|{
name|TREE_LITERAL
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_LITERAL
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
return|return
name|fold_convert
argument_list|(
name|t
argument_list|)
return|;
if|#
directive|if
literal|0
comment|/* This loses on&"foo"[0].  */
block|case ARRAY_REF: 	{ 	  int i;
comment|/* Fold an expression like: "foo"[2] */
block|if (TREE_CODE (arg0) == STRING_CST&& TREE_CODE (arg1) == INTEGER_CST&& !TREE_INT_CST_HIGH (arg1)&& (i = TREE_INT_CST_LOW (arg1))< TREE_STRING_LENGTH (arg0)) 	    { 	      t = build_int_2 (TREE_STRING_POINTER (arg0)[i], 0); 	      TREE_TYPE (t) = TREE_TYPE (TREE_TYPE (arg0)); 	      force_fit_type (t); 	    } 	}       return t;
endif|#
directive|endif
comment|/* 0 */
case|case
name|RANGE_EXPR
case|:
name|TREE_LITERAL
argument_list|(
name|t
argument_list|)
operator|=
name|wins
expr_stmt|;
return|return
name|t
return|;
case|case
name|NEGATE_EXPR
case|:
if|if
condition|(
name|wins
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
operator|==
literal|0
condition|)
name|t
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
operator|-
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|build_int_2
argument_list|(
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
argument_list|,
operator|~
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|force_fit_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
condition|)
name|t
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|REAL_VALUE_NEGATE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
return|return
name|t
return|;
case|case
name|ABS_EXPR
case|:
if|if
condition|(
name|wins
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
operator|==
literal|0
condition|)
name|t
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
operator|-
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|build_int_2
argument_list|(
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
argument_list|,
operator|~
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
if|if
condition|(
if|#
directive|if
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
name|REAL_VALUES_LESS
argument_list|(
argument|TREE_REAL_CST (arg0)
argument_list|,
argument|REAL_VALUE_ATOF (
literal|"0.0"
argument|)
argument_list|)
else|#
directive|else
name|REAL_VALUES_LESS
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|,
literal|0
argument_list|)
endif|#
directive|endif
condition|)
name|t
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|REAL_VALUE_NEGATE
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
return|return
name|t
return|;
case|case
name|BIT_NOT_EXPR
case|:
if|if
condition|(
name|wins
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|t
operator|=
name|build_int_2
argument_list|(
operator|~
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
argument_list|,
operator|~
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|force_fit_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
name|associate
label|:
comment|/* In most languages, can't associate operations on floats 	 through parentheses.  Rather than remember where the parentheses 	 were, we don't associate floats at all.  It shouldn't matter much.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
goto|goto
name|binary
goto|;
comment|/* The varsign == -1 cases happen only for addition and subtraction. 	 It says that the arg that was split was really CON minus VAR. 	 The rest of the code applies to all associative operations.  */
if|if
condition|(
operator|!
name|wins
condition|)
block|{
name|tree
name|var
decl_stmt|,
name|con
decl_stmt|,
name|tem
decl_stmt|;
name|int
name|varsign
decl_stmt|;
if|if
condition|(
name|split_tree
argument_list|(
name|arg0
argument_list|,
name|code
argument_list|,
operator|&
name|var
argument_list|,
operator|&
name|con
argument_list|,
operator|&
name|varsign
argument_list|)
condition|)
block|{
if|if
condition|(
name|varsign
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* EXPR is (CON-VAR) +- ARG1.  */
comment|/* If it is + and VAR==ARG1, return just CONST.  */
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|var
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|con
argument_list|)
return|;
comment|/* Otherwise return (CON +- ARG1) - VAR.  */
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|MINUS_EXPR
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|var
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|con
argument_list|,
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* EXPR is (VAR+CON) +- ARG1.  */
comment|/* If it is - and VAR==ARG1, return just CONST.  */
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|var
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|con
argument_list|)
return|;
comment|/* Otherwise return VAR +- (ARG1 +- CON).  */
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|tem
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|arg1
argument_list|,
name|con
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|var
expr_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|tem
argument_list|)
operator|&&
operator|(
name|code
operator|==
name|PLUS_EXPR
operator|||
name|code
operator|==
name|MINUS_EXPR
operator|)
condition|)
return|return
name|var
return|;
comment|/* If we have x +/- (c - d) [c an explicit integer] 		     change it to x -/+ (d - c) since if d is relocatable 		     then the latter can be a single immediate insn 		     and the former cannot.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|MINUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|tree
name|tem1
init|=
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
operator|=
name|tem1
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
operator|(
name|code
operator|==
name|PLUS_EXPR
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|t
return|;
block|}
if|if
condition|(
name|split_tree
argument_list|(
name|arg1
argument_list|,
name|code
argument_list|,
operator|&
name|var
argument_list|,
operator|&
name|con
argument_list|,
operator|&
name|varsign
argument_list|)
condition|)
block|{
comment|/* EXPR is ARG0 +- (CON +- VAR).  */
if|if
condition|(
name|varsign
operator|==
operator|-
literal|1
condition|)
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
operator|(
name|code
operator|==
name|PLUS_EXPR
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MINUS_EXPR
operator|&&
name|operand_equal_p
argument_list|(
name|var
argument_list|,
name|arg0
argument_list|)
condition|)
block|{
comment|/* If VAR and ARG0 cancel, return just CON or -CON.  */
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|con
argument_list|)
return|;
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|con
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|code
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|arg0
argument_list|,
name|con
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|var
expr_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|var
argument_list|)
return|;
return|return
name|t
return|;
block|}
block|}
name|binary
label|:
if|#
directive|if
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
return|return
name|t
return|;
endif|#
directive|endif
comment|/* REAL_IS_NOT_DOUBLE, and no REAL_ARITHMETIC */
block|{
specifier|register
name|tree
name|t1
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|wins
condition|)
name|t1
operator|=
name|combine
argument_list|(
name|code
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|NULL_TREE
condition|)
return|return
name|t1
return|;
return|return
name|t
return|;
block|}
case|case
name|MINUS_EXPR
case|:
if|if
condition|(
operator|!
name|wins
operator|&&
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
comment|/* Fold&x -&x.  This can happen from&x.foo -&x.  */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
return|;
goto|goto
name|associate
goto|;
case|case
name|MULT_EXPR
case|:
if|if
condition|(
operator|!
name|loses
operator|&&
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
operator|!
name|loses
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|integer_onep
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
goto|goto
name|associate
goto|;
case|case
name|BIT_IOR_EXPR
case|:
if|if
condition|(
operator|!
name|loses
operator|&&
name|integer_all_onesp
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
operator|!
name|loses
operator|&&
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
case|case
name|BIT_XOR_EXPR
case|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
goto|goto
name|associate
goto|;
case|case
name|BIT_AND_EXPR
case|:
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
operator|!
name|loses
operator|&&
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
operator|!
name|loses
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
comment|/* Simplify ((int)c& 0x377) into (int)c, if c is unsigned char.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|prec
init|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|prec
operator|<
name|BITS_PER_WORD
operator|&&
name|prec
operator|<
name|HOST_BITS_PER_INT
operator|&&
operator|(
operator|~
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|prec
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|build
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|prec
init|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|prec
operator|<
name|BITS_PER_WORD
operator|&&
name|prec
operator|<
name|HOST_BITS_PER_INT
operator|&&
operator|(
operator|~
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|prec
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|build
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|arg0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
goto|goto
name|associate
goto|;
case|case
name|BIT_ANDTC_EXPR
case|:
if|if
condition|(
name|integer_all_onesp
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
operator|!
name|loses
operator|&&
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
operator|!
name|loses
operator|&&
name|integer_all_onesp
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|combine
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|arg1
argument_list|)
return|;
goto|goto
name|binary
goto|;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|EXACT_DIV_EXPR
case|:
case|case
name|RDIV_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|t
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|real_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|t
return|;
endif|#
directive|endif
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
goto|goto
name|binary
goto|;
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
if|if
condition|(
operator|!
name|loses
operator|&&
name|integer_onep
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|combine
argument_list|(
name|code
argument_list|,
name|arg1
argument_list|,
name|arg1
argument_list|)
return|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|t
return|;
goto|goto
name|binary
goto|;
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|arg0
argument_list|)
return|;
goto|goto
name|binary
goto|;
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
goto|goto
name|associate
goto|;
case|case
name|TRUTH_NOT_EXPR
case|:
comment|/* Note that the operand of this must be an int 	 and its values must be 0 or 1. 	 ("true" is a fixed value perhaps depending on the language, 	 but we don't handle values other than 1 correctly yet.)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|t
operator|=
name|build_int_2
argument_list|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
operator|==
literal|0
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
return|return
name|t
return|;
case|case
name|TRUTH_ANDIF_EXPR
case|:
comment|/* Note that the operands of this must be ints 	 and their values must be 0 or 1. 	 ("true" is a fixed value perhaps depending on the language.)  */
comment|/* If first arg is constant zero, return it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|arg0
return|;
case|case
name|TRUTH_AND_EXPR
case|:
comment|/* If either arg is constant true, drop it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|arg1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|arg0
return|;
comment|/* Both known to be zero => return zero.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|arg0
return|;
return|return
name|t
return|;
case|case
name|TRUTH_ORIF_EXPR
case|:
comment|/* Note that the operands of this must be ints 	 and their values must be 0 or true. 	 ("true" is a fixed value perhaps depending on the language.)  */
comment|/* If first arg is constant true, return it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|arg0
return|;
case|case
name|TRUTH_OR_EXPR
case|:
comment|/* If either arg is constant zero, drop it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|arg1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
condition|)
return|return
name|arg0
return|;
comment|/* Both known to be true => return true.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|arg0
return|;
return|return
name|t
return|;
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
comment|/* If one arg is a constant integer, put it last.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|arg1
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|arg0
expr_stmt|;
name|arg0
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT_EXPR
case|:
name|code
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|code
operator|=
name|LE_EXPR
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
name|code
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|code
operator|=
name|GE_EXPR
expr_stmt|;
break|break;
block|}
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Convert foo++ == CONST into ++foo == CONST + INCR. 	 First, see if one arg is constant; find the constant arg 	 and the other one.  */
block|{
name|tree
name|constop
init|=
literal|0
decl_stmt|,
name|varop
decl_stmt|;
name|tree
modifier|*
name|constoploc
decl_stmt|;
if|if
condition|(
name|TREE_LITERAL
argument_list|(
name|arg1
argument_list|)
condition|)
name|constoploc
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|,
name|constop
operator|=
name|arg1
operator|,
name|varop
operator|=
name|arg0
expr_stmt|;
if|if
condition|(
name|TREE_LITERAL
argument_list|(
name|arg0
argument_list|)
condition|)
name|constoploc
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|,
name|constop
operator|=
name|arg0
operator|,
name|varop
operator|=
name|arg1
expr_stmt|;
if|if
condition|(
name|constop
operator|&&
name|TREE_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|POSTINCREMENT_EXPR
condition|)
block|{
name|tree
name|newconst
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|constop
argument_list|)
argument_list|,
name|constop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* This optimization is invalid for ordered comparisons 	       if CONST+INCR overflows or if foo+incr might overflow. 	       For pointer types we assume overflow doesn't happen.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
condition|)
block|{
name|TREE_SET_CODE
argument_list|(
name|varop
argument_list|,
name|PREINCREMENT_EXPR
argument_list|)
expr_stmt|;
operator|*
name|constoploc
operator|=
name|newconst
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|constop
operator|&&
name|TREE_CODE
argument_list|(
name|varop
argument_list|)
operator|==
name|POSTDECREMENT_EXPR
condition|)
block|{
name|tree
name|newconst
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|constop
argument_list|)
argument_list|,
name|constop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|varop
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|varop
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
condition|)
block|{
name|TREE_SET_CODE
argument_list|(
name|varop
argument_list|,
name|PREDECREMENT_EXPR
argument_list|)
expr_stmt|;
operator|*
name|constoploc
operator|=
name|newconst
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
block|}
comment|/* Change X>= CST to X> (CST - 1) if CST is positive.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
operator|!
name|tree_int_cst_lt
argument_list|(
name|arg1
argument_list|,
name|integer_one_node
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|GE_EXPR
case|:
name|code
operator|=
name|GT_EXPR
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|combine
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|arg1
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
name|code
operator|=
name|LE_EXPR
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|combine
argument_list|(
name|MINUS_EXPR
argument_list|,
name|arg1
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|arg1
expr_stmt|;
block|}
block|}
comment|/* An unsigned comparison against 0 can be simplified.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|arg1
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|GT_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|NE_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|EQ_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg0
argument_list|,
name|integer_one_node
argument_list|)
return|;
case|case
name|LT_EXPR
case|:
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|arg0
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
block|}
comment|/* To compute GT, swap the arguments and do LT. 	 To compute GE, do LT and invert the result. 	 To compute LE, swap the arguments, do LT and invert the result. 	 To compute NE, do EQ and invert the result.  */
if|if
condition|(
name|code
operator|==
name|LE_EXPR
operator|||
name|code
operator|==
name|GT_EXPR
condition|)
block|{
specifier|register
name|tree
name|temp
init|=
name|arg0
decl_stmt|;
name|arg0
operator|=
name|arg1
expr_stmt|;
name|arg1
operator|=
name|temp
expr_stmt|;
block|}
comment|/* Compute a result for LT or EQ if args permit; 	 otherwise return T.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
condition|)
name|t
operator|=
name|build_int_2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|arg0
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|arg1
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|arg0
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|arg1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|build_int_2
argument_list|(
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
condition|?
name|INT_CST_LT_UNSIGNED
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
else|:
name|INT_CST_LT
argument_list|(
name|arg0
argument_list|,
name|arg1
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_LITERAL
argument_list|(
name|arg0
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
operator|)
condition|)
block|{
name|t
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg0
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|TREE_CODE
argument_list|(
name|arg1
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
condition|)
name|t
operator|=
name|build_int_2
argument_list|(
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|build_int_2
argument_list|(
name|REAL_VALUES_LESS
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|t
return|;
comment|/* If what we want is other than LT or EQ, invert the result.  */
if|if
condition|(
name|code
operator|==
name|GE_EXPR
operator|||
name|code
operator|==
name|LE_EXPR
operator|||
name|code
operator|==
name|NE_EXPR
condition|)
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|^=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|t
return|;
case|case
name|COND_EXPR
case|:
if|if
condition|(
name|TREE_LITERAL
argument_list|(
name|arg0
argument_list|)
condition|)
return|return
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
operator|(
name|integer_zerop
argument_list|(
name|arg0
argument_list|)
condition|?
literal|2
else|:
literal|1
operator|)
argument_list|)
return|;
return|return
name|t
return|;
default|default:
return|return
name|t
return|;
block|}
comment|/* switch (code) */
block|}
end_function

end_unit

