begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert RTL to assembler code and output it, for GNU compiler.    Copyright (C) 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This is the final pass of the compiler.    It looks at the rtl code for a function and outputs assembler code.     Call `final_start_function' to output the assembler code for function entry,    `final' to output assembler code for some RTL code,    `final_end_function' to output assembler code for function exit.    If a function is compiled in several pieces, each piece is    output separately with `final'.     Some optimizations are also done at this level.    Move instructions that were made unnecessary by good register allocation    are detected and omitted from the output.  (Though most of these    are removed by the last jump pass.)     Instructions to set the condition codes are omitted when it can be    seen that the condition codes already had the desired values.     In some cases it is sufficient if the inherited condition codes    have related values, but this may require the following insn    (the one that tests the condition codes) to be modified.     The code for the function prologue and epilogue are generated    directly as assembler code by the macros FUNCTION_PROLOGUE and    FUNCTION_EPILOGUE.  Those instructions never exist as rtl.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"gdbfiles.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_comment
comment|/* Get N_SLINE and N_SOL from stab.h if we can expect the file to exist.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|"stab.h"
end_include

begin_comment
comment|/* If doing DBX on sysV, use our own stab.h.  */
end_comment

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_comment
comment|/* On BSD, use the system's stab.h.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not USG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBX_DEBUGGING_INFO */
end_comment

begin_comment
comment|/* .stabd code for line number.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_SLINE
end_ifndef

begin_define
define|#
directive|define
name|N_SLINE
value|0x44
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* .stabs code for included file name.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_SOL
end_ifndef

begin_define
define|#
directive|define
name|N_SOL
value|0x84
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|min
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)< (B) ? (A) : (B))
end_define

begin_function_decl
name|rtx
name|peephole
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|output_asm_insn
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|rtx
name|alter_subreg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alter_cond
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|output_asm_label
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_operand
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|output_address
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|output_addr_const
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_source_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|rtx
name|final_scan_insn
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* the sdb debugger needs the line given as an offset from the beginning    of the current function -wfs*/
end_comment

begin_decl_stmt
specifier|extern
name|int
name|sdb_begin_function_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line number of last NOTE.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_linenum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of basic blocks seen so far;    used if profile_block_flag is set.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|count_basic_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero while outputting an `asm' with operands.    This means that inconsistencies are the user's fault, so don't abort.    The precise value is the insn being output, to pass to error_for_asm.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|this_is_asm_operands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of operands of this insn, for an `asm' with operands.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|insn_noperands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File in which assembler code is being written.  */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compare optimization flag. */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_ignored_compare
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating this insn is the start of a new basic block. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|new_block
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All the symbol-blocks (levels of scoping) in the compilation    are assigned sequence numbers in order of appearance of the    beginnings of the symbol-blocks.  Both final and dbxout do this,    and assume that they will both give the same number to each block.    Final uses these sequence numbers to generate assembler label names    LBBnnn and LBEnnn for the beginning and end of the symbol-block.    Dbxout uses the sequence nunbers to generate references to the same labels    from the dbx debugging information.     Sdb records this level at the beginning    of each function, so that when it recurses down the declarations, it may    find the current level, since it outputs the block beginning and endings    at the point in the asm file, where the blocks would begin and end.  */
end_comment

begin_decl_stmt
name|int
name|next_block_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of all `struct gdbfile's.  */
end_comment

begin_decl_stmt
name|struct
name|gdbfile
modifier|*
name|gdbfiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* `struct gdbfile' for the last file we wrote a line number for.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|gdbfile
modifier|*
name|current_gdbfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filenum to assign to the next distinct source file encountered.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_gdb_filenum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This variable contains machine-dependent flags (defined in tm-...h)    set and examined by output routines    that describe how to interpret the condition codes properly.  */
end_comment

begin_decl_stmt
name|CC_STATUS
name|cc_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During output of an insn, this contains a copy of cc_status    from before the insn.  */
end_comment

begin_decl_stmt
name|CC_STATUS
name|cc_prev_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last source file name mentioned in a NOTE insn.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lastfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by hardware reg number, is 1 if that register is ever    used in the current function.     In life_analysis, or in stupid_life_analysis, this is set    up to record the hard regs used explicitly.  Reload adds    in the hard regs used for holding pseudo regs.  Final uses    it to generate the code in the function prologue and epilogue    to save and restore registers as needed.  */
end_comment

begin_decl_stmt
name|char
name|regs_ever_live
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means current function must be given a frame pointer.    Set in stmt.c if anything is allocated on the stack there.    Set in reload1.c if anything is allocated on the stack there.  */
end_comment

begin_decl_stmt
name|int
name|frame_pointer_needed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assign unique numbers to labels generated for profiling.  */
end_comment

begin_decl_stmt
name|int
name|profile_label_no
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length so far allocated in PENDING_BLOCKS.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_block_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of sequence numbers of symbol-blocks of which we have seen the    beginning but not yet the end.  Sequence numbers are assigned at    the beginning; this stack allows us to find the sequence number    of a block that is ending.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|pending_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently in use in PENDING_BLOCKS.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|block_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if have enabled APP processing of our assembler output.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|app_on
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we are outputting an insn sequence, this contains the sequence rtx.    Zero otherwise.  */
end_comment

begin_decl_stmt
name|rtx
name|final_sequence
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize data in final at the beginning of a compilation.  */
end_comment

begin_function
name|void
name|init_final
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|next_block_index
operator|=
literal|2
expr_stmt|;
name|lastfile
operator|=
name|filename
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
name|max_block_depth
operator|=
literal|20
expr_stmt|;
name|pending_blocks
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
operator|*
sizeof|sizeof
expr|*
name|pending_blocks
argument_list|)
expr_stmt|;
name|gdbfiles
operator|=
literal|0
expr_stmt|;
name|next_gdb_filenum
operator|=
literal|0
expr_stmt|;
name|final_sequence
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at end of source file,    to output the block-profiling table for this entire compilation.  */
end_comment

begin_function
name|void
name|end_final
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|profile_block_flag
condition|)
block|{
name|char
name|name
index|[
literal|12
index|]
decl_stmt|;
name|data_section
argument_list|()
expr_stmt|;
comment|/* Output the main header, of 6 words: 	 0:  1 if this file's initialized, else 0. 	 1:  address of file name. 	 2:  address of table of counts. 	 4:  number of counts in the table. 	 5:  always 0, for compatibility with Sun. 	 6:  extra word added by GNU: address of address table 	      which contains addresses of basic blocks, 	      in parallel with the table of counts.  */
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|exact_log2
argument_list|(
name|min
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBX"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assemble_integer_zero
argument_list|()
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT
argument_list|(
name|asm_out_file
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT
argument_list|(
name|asm_out_file
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT
argument_list|(
name|asm_out_file
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|count_basic_blocks
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_integer_zero
argument_list|()
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT
argument_list|(
name|asm_out_file
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the file name.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBX"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|char
modifier|*
name|data_file
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|3
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|data_file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".c"
argument_list|,
name|data_file
operator|+
name|len
operator|-
literal|2
argument_list|)
condition|)
name|data_file
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".i"
argument_list|,
name|data_file
operator|+
name|len
operator|-
literal|2
argument_list|)
condition|)
name|data_file
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>
literal|3
operator|&&
operator|!
name|strcmp
argument_list|(
literal|".co"
argument_list|,
name|data_file
operator|+
name|len
operator|-
literal|3
argument_list|)
condition|)
name|data_file
index|[
name|len
operator|-
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|data_file
argument_list|,
literal|".d"
argument_list|)
expr_stmt|;
name|assemble_string
argument_list|(
name|data_file
argument_list|,
name|strlen
argument_list|(
name|data_file
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Realign data section.  */
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|exact_log2
argument_list|(
name|min
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make space for the table of counts.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBX"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SKIP
argument_list|(
name|asm_out_file
argument_list|,
name|UNITS_PER_WORD
operator|*
name|count_basic_blocks
argument_list|)
expr_stmt|;
comment|/* Output the table of addresses.  */
name|text_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBX"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|char
name|name
index|[
literal|12
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPB"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT
argument_list|(
name|asm_out_file
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* End with the address of the table of addresses, 	 so we can find it easily, as the last word in the file's text.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT
argument_list|(
name|asm_out_file
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Enable APP processing of subsequent output.    Used before the output from an `asm' statement.  */
end_comment

begin_function
name|void
name|app_enable
parameter_list|()
block|{
if|if
condition|(
operator|!
name|app_on
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
name|ASM_APP_ON
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Enable APP processing of subsequent output.    Called from varasm.c before most kinds of output.  */
end_comment

begin_function
name|void
name|app_disable
parameter_list|()
block|{
if|if
condition|(
name|app_on
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
name|ASM_APP_OFF
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of slots filled in the current     delayed branch sequence. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DELAYED_BRANCH
end_ifdef

begin_function
name|int
name|dbr_sequence_length
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|slots
init|=
literal|0
decl_stmt|;
comment|/* It's zero if we are not scheduling or not in a sequence.       (We never count the first insn.)                  */
if|if
condition|(
name|flag_delayed_branch
operator|&&
name|final_sequence
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|final_sequence
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|slots
operator|+=
name|DBR_INSN_SLOTS
argument_list|(
name|XVECEXP
argument_list|(
name|final_sequence
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|slots
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Output assembler code for the start of a function,    and initialize some of the variables in this file    for the new function.  The label for the function and associated    assembler pseudo-ops have already been output in `assemble_function'.     FIRST is the first insn of the rtl for the function being compiled.    FILE is the file to write assembler code to.    WRITE_SYMBOLS says which kind of debugging info to write (or none).    OPTIMIZE is nonzero if we should eliminate redundant      test and compare insns.  */
end_comment

begin_function
name|void
name|final_start_function
parameter_list|(
name|first
parameter_list|,
name|file
parameter_list|,
name|write_symbols
parameter_list|,
name|optimize
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|enum
name|debugger
name|write_symbols
decl_stmt|;
name|int
name|optimize
decl_stmt|;
block|{
name|block_depth
operator|=
literal|0
expr_stmt|;
name|this_is_asm_operands
operator|=
literal|0
expr_stmt|;
comment|/* Record beginning of the symbol-block that's the entire function.  */
if|if
condition|(
name|write_symbols
operator|==
name|GDB_DEBUG
condition|)
block|{
name|pending_blocks
index|[
name|block_depth
operator|++
index|]
operator|=
name|next_block_index
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.gdbbeg %d\n"
argument_list|,
name|next_block_index
operator|++
argument_list|)
expr_stmt|;
block|}
comment|/* Initial line number is supposed to be output      before the function's prologue and label      so that the function's address will not appear to be      in the last statement of the preceding function.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|first
argument_list|)
operator|!=
name|NOTE_INSN_DELETED
condition|)
block|{
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
comment|/* For sdb, let's not, but say we did. 	   We need to set last_linenum for sdbout_function_begin, 	   but we can't have an actual line number before the .bf symbol. 	   (sdb_begin_function_line is not set, 	   and other compilers don't do it.)  */
name|last_linenum
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|first
argument_list|)
expr_stmt|;
else|else
name|output_source_line
argument_list|(
name|file
argument_list|,
name|first
argument_list|,
name|write_symbols
argument_list|)
expr_stmt|;
block|}
comment|/* The Sun386i and perhaps other machines don't work right      if the profiling code comes after the prologue.  */
ifdef|#
directive|ifdef
name|PROFILE_BEFORE_PROLOGUE
if|if
condition|(
name|profile_flag
condition|)
name|profile_function
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PROFILE_BEFORE_PROLOGUE */
ifdef|#
directive|ifdef
name|FUNCTION_PROLOGUE
comment|/* First output the function prologue: code to set up the stack frame.  */
name|FUNCTION_PROLOGUE
argument_list|(
name|file
argument_list|,
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
name|next_block_index
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FUNCTION_BLOCK_PROFILER
if|if
condition|(
name|profile_block_flag
condition|)
block|{
name|FUNCTION_BLOCK_PROFILER
argument_list|(
name|file
argument_list|,
name|profile_label_no
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FUNCTION_BLOCK_PROFILER */
ifndef|#
directive|ifndef
name|PROFILE_BEFORE_PROLOGUE
if|if
condition|(
name|profile_flag
condition|)
name|profile_function
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not PROFILE_BEFORE_PROLOGUE */
name|profile_label_no
operator|++
expr_stmt|;
block|}
end_function

begin_macro
name|profile_function
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|align
init|=
name|min
argument_list|(
name|BIGGEST_ALIGNMENT
argument_list|,
name|BITS_PER_WORD
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|current_function_returns_struct
decl_stmt|;
specifier|extern
name|int
name|current_function_needs_context
decl_stmt|;
name|int
name|sval
init|=
name|current_function_returns_struct
decl_stmt|;
name|int
name|cxt
init|=
name|current_function_needs_context
decl_stmt|;
name|data_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"LP"
argument_list|,
name|profile_label_no
argument_list|)
expr_stmt|;
name|assemble_integer_zero
argument_list|()
expr_stmt|;
name|text_section
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|STRUCT_VALUE_INCOMING_REGNUM
if|if
condition|(
name|sval
condition|)
name|ASM_OUTPUT_REG_PUSH
argument_list|(
name|file
argument_list|,
name|STRUCT_VALUE_INCOMING_REGNUM
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|STRUCT_VALUE_REGNUM
if|if
condition|(
name|sval
condition|)
name|ASM_OUTPUT_REG_PUSH
argument_list|(
name|file
argument_list|,
name|STRUCT_VALUE_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|STATIC_CHAIN_INCOMING_REGNUM
block|if (cxt)     ASM_OUTPUT_REG_PUSH (file, STATIC_CHAIN_INCOMING_REGNUM);
else|#
directive|else
ifdef|#
directive|ifdef
name|STATIC_CHAIN_REGNUM
block|if (cxt)     ASM_OUTPUT_REG_PUSH (file, STATIC_CHAIN_REGNUM);
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* 0 */
name|FUNCTION_PROFILER
argument_list|(
name|file
argument_list|,
name|profile_label_no
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|STATIC_CHAIN_INCOMING_REGNUM
block|if (cxt)     ASM_OUTPUT_REG_POP (file, STATIC_CHAIN_INCOMING_REGNUM);
else|#
directive|else
ifdef|#
directive|ifdef
name|STATIC_CHAIN_REGNUM
block|if (cxt)     ASM_OUTPUT_REG_POP (file, STATIC_CHAIN_REGNUM);
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* 0 */
ifdef|#
directive|ifdef
name|STRUCT_VALUE_INCOMING_REGNUM
if|if
condition|(
name|sval
condition|)
name|ASM_OUTPUT_REG_POP
argument_list|(
name|file
argument_list|,
name|STRUCT_VALUE_INCOMING_REGNUM
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|STRUCT_VALUE_REGNUM
if|if
condition|(
name|sval
condition|)
name|ASM_OUTPUT_REG_POP
argument_list|(
name|file
argument_list|,
name|STRUCT_VALUE_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Output assembler code for the end of a function.    For clarity, args are same as those of `final_start_function'    even though not all of them are needed.  */
end_comment

begin_function
name|void
name|final_end_function
parameter_list|(
name|first
parameter_list|,
name|file
parameter_list|,
name|write_symbols
parameter_list|,
name|optimize
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|enum
name|debugger
name|write_symbols
decl_stmt|;
name|int
name|optimize
decl_stmt|;
block|{
if|if
condition|(
name|app_on
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|ASM_APP_OFF
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|write_symbols
operator|==
name|GDB_DEBUG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.gdbend %d\n"
argument_list|,
name|pending_blocks
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_end_function
argument_list|(
name|last_linenum
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FUNCTION_EPILOGUE
comment|/* Finally, output the function epilogue:      code to restore the stack frame and return to the caller.  */
name|FUNCTION_EPILOGUE
argument_list|(
name|file
argument_list|,
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_end_epilogue
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* If FUNCTION_EPILOGUE is not defined, then the function body      itself contains return instructions wherever needed.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code for some insns: all or part of a function.    For description of args, see `final_start_function', above.     PRESCAN is 1 if we are not really outputting,      just scanning as if we were outputting.    Prescanning deletes and rearranges insns just like ordinary output.    PRESCAN is -2 if we are outputting after having prescanned.    In this case, don't try to delete or rearrange insns    because that has already been done.    Prescanning is done only on certain machines.  */
end_comment

begin_function
name|void
name|final
parameter_list|(
name|first
parameter_list|,
name|file
parameter_list|,
name|write_symbols
parameter_list|,
name|optimize
parameter_list|,
name|prescan
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|enum
name|debugger
name|write_symbols
decl_stmt|;
name|int
name|optimize
decl_stmt|;
name|int
name|prescan
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|last_ignored_compare
operator|=
literal|0
expr_stmt|;
name|new_block
operator|=
literal|1
expr_stmt|;
name|init_recog
argument_list|()
expr_stmt|;
name|CC_STATUS_INIT
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
init|;
name|insn
condition|;
control|)
name|insn
operator|=
name|final_scan_insn
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
name|write_symbols
argument_list|,
name|optimize
argument_list|,
name|prescan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The final scan for one insn, INSN.    Args are same as in `final', except that INSN    is the insn being scanned.    Value returned is the next insn to be scanned.     NOPEEPHOLES is the flag to disallow peephole processing (currently    used for within delayed branch sequence output).  */
end_comment

begin_function
name|rtx
name|final_scan_insn
parameter_list|(
name|insn
parameter_list|,
name|file
parameter_list|,
name|write_symbols
parameter_list|,
name|optimize
parameter_list|,
name|prescan
parameter_list|,
name|nopeepholes
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|enum
name|debugger
name|write_symbols
decl_stmt|;
name|int
name|optimize
decl_stmt|;
name|int
name|prescan
decl_stmt|;
name|int
name|nopeepholes
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|write_symbols
operator|==
name|NO_DEBUG
condition|)
break|break;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
condition|)
block|{
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_begin_function
argument_list|(
name|last_linenum
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
break|break;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED
condition|)
break|break;
comment|/* An insn that was "deleted" */
if|if
condition|(
name|app_on
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|ASM_APP_OFF
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
condition|)
block|{
comment|/* Beginning of a symbol-block.  Assign it a sequence number 	     and push the number onto the stack PENDING_BLOCKS.  */
if|if
condition|(
name|block_depth
operator|==
name|max_block_depth
condition|)
block|{
comment|/* PENDING_BLOCKS is full; make it longer.  */
name|max_block_depth
operator|*=
literal|2
expr_stmt|;
name|pending_blocks
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|pending_blocks
argument_list|,
name|max_block_depth
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pending_blocks
index|[
name|block_depth
operator|++
index|]
operator|=
name|next_block_index
expr_stmt|;
comment|/* Output debugging info about the symbol-block beginning.  */
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_begin_block
argument_list|(
name|file
argument_list|,
name|last_linenum
argument_list|,
name|next_block_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"LBB"
argument_list|,
name|next_block_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|write_symbols
operator|==
name|GDB_DEBUG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.gdbbeg %d\n"
argument_list|,
name|next_block_index
argument_list|)
expr_stmt|;
name|next_block_index
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
condition|)
block|{
comment|/* End of a symbol-block.  Pop its sequence number off 	     PENDING_BLOCKS and output debugging info based on that.  */
operator|--
name|block_depth
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|&&
name|block_depth
operator|>=
literal|0
condition|)
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"LBE"
argument_list|,
name|pending_blocks
index|[
name|block_depth
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|block_depth
operator|>=
literal|0
condition|)
name|sdbout_end_block
argument_list|(
name|file
argument_list|,
name|last_linenum
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|write_symbols
operator|==
name|GDB_DEBUG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.gdbend %d\n"
argument_list|,
name|pending_blocks
index|[
name|block_depth
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
comment|/* This note is a line-number.  */
name|output_source_line
argument_list|(
name|file
argument_list|,
name|insn
argument_list|,
name|write_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|BARRIER
case|:
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGN_CODE
name|ASM_OUTPUT_ALIGN_CODE
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CODE_LABEL
case|:
name|CC_STATUS_INIT
expr_stmt|;
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
name|new_block
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|app_on
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|ASM_APP_OFF
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_CASE_LABEL
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|nextbody
init|=
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If this label is followed by a jump-table, 	     output the two of them together in a special way.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|nextbody
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|nextbody
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
name|ASM_OUTPUT_CASE_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
specifier|register
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|insn_code_number
decl_stmt|;
name|char
modifier|*
name|template
decl_stmt|;
comment|/* An INSN, JUMP_INSN or CALL_INSN. 	   First check for special kinds that recog doesn't recognize.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|USE
comment|/* These are just declarations */
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|CLOBBER
condition|)
break|break;
if|if
condition|(
name|profile_block_flag
operator|&&
name|new_block
condition|)
block|{
name|rtx
name|real_body
init|=
name|body
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|real_body
operator|=
name|PATTERN
argument_list|(
name|next_real_insn
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't add instructions in front of jump tables.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|real_body
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|real_body
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
condition|)
block|{
name|new_block
operator|=
literal|0
expr_stmt|;
comment|/* Enable the table of basic-block use counts 		   to point at the code it applies to.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"LPB"
argument_list|,
name|count_basic_blocks
argument_list|)
expr_stmt|;
comment|/* Before first insn of this basic block, increment the 		   count of times it was entered.  */
ifdef|#
directive|ifdef
name|BLOCK_PROFILER
name|BLOCK_PROFILER
argument_list|(
name|file
argument_list|,
name|count_basic_blocks
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|count_basic_blocks
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_INPUT
condition|)
block|{
comment|/* There's no telling what that did to the condition codes.  */
name|CC_STATUS_INIT
expr_stmt|;
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|app_on
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|ASM_APP_ON
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\n"
argument_list|,
name|XSTR
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Detect `asm' construct with operands.  */
if|if
condition|(
name|asm_noperands
argument_list|(
name|body
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|int
name|noperands
init|=
name|asm_noperands
argument_list|(
name|body
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|ops
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
comment|/* There's no telling what that did to the condition codes.  */
name|CC_STATUS_INIT
expr_stmt|;
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
comment|/* alloca won't do here, since only return from `final' 	       would free it.  */
if|if
condition|(
name|noperands
operator|>
literal|0
condition|)
name|ops
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|noperands
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|app_on
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|ASM_APP_ON
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Get out the operand values.  */
name|string
operator|=
name|decode_asm_operands
argument_list|(
name|body
argument_list|,
name|ops
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Inhibit aborts on what would otherwise be compiler bugs.  */
name|insn_noperands
operator|=
name|noperands
expr_stmt|;
name|this_is_asm_operands
operator|=
name|insn
expr_stmt|;
comment|/* Output the insn using them.  */
name|output_asm_insn
argument_list|(
name|string
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|this_is_asm_operands
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|noperands
operator|>
literal|0
condition|)
name|free
argument_list|(
name|ops
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|prescan
operator|<=
literal|0
operator|&&
name|app_on
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|ASM_APP_OFF
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Detect insns that are really jump-tables 	   and output them as such.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_VEC
condition|)
block|{
specifier|register
name|int
name|vlen
decl_stmt|,
name|idx
decl_stmt|;
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
name|vlen
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|vlen
condition|;
name|idx
operator|++
control|)
name|ASM_OUTPUT_ADDR_VEC_ELT
argument_list|(
name|file
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|idx
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_CASE_END
name|ASM_OUTPUT_CASE_END
argument_list|(
name|file
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
specifier|register
name|int
name|vlen
decl_stmt|,
name|idx
decl_stmt|;
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
name|vlen
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|vlen
condition|;
name|idx
operator|++
control|)
name|ASM_OUTPUT_ADDR_DIFF_ELT
argument_list|(
name|file
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|1
argument_list|,
name|idx
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_CASE_END
name|ASM_OUTPUT_CASE_END
argument_list|(
name|file
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SEQUENCE
condition|)
comment|/* A delayed-branch sequence */
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
name|final_sequence
operator|=
name|body
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|final_scan_insn
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|file
argument_list|,
name|write_symbols
argument_list|,
name|optimize
argument_list|,
name|prescan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|final_sequence
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DBR_OUTPUT_SEQEND
name|DBR_OUTPUT_SEQEND
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/* We have a real machine instruction as rtl.  */
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Check for redundant test and compare instructions 	   (when the condition codes are already set up as desired). 	   This is done only when optimizing; if not optimizing, 	   it should be possible for the user to alter a variable 	   with the debugger in between statements 	   and the next statement should reexamine the variable 	   to compute the condition codes.  */
if|if
condition|(
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|CC0
operator|&&
name|insn
operator|!=
name|last_ignored_compare
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|=
name|alter_subreg
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc_status
operator|.
name|value1
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value1
argument_list|)
operator|)
operator|||
operator|(
name|cc_status
operator|.
name|value2
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value2
argument_list|)
operator|)
condition|)
block|{
comment|/* Don't delete insn if has an addressing side-effect */
if|if
condition|(
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_INC
argument_list|,
literal|0
argument_list|)
comment|/* or if anything in it is volatile.  */
operator|&&
operator|!
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We don't really delete the insn; just ignore it.  */
name|last_ignored_compare
operator|=
name|insn
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Following a conditional branch, we have a new basic block.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
condition|)
name|new_block
operator|=
literal|1
expr_stmt|;
comment|/* If this is a conditional branch, maybe modify it 	   if the cc's are in a nonstandard state 	   so that it accomplishes the same thing that it would 	   do straightforwardly if the cc's were set up normally.  */
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|body
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
comment|/* This is done during prescan; it is not done again 	       in final scan when prescan has been done.  */
operator|&&
name|prescan
operator|>=
literal|0
condition|)
block|{
comment|/* This function may alter the contents of its argument 	       and clear some of the cc_status.flags bits. 	       It may also return 1 meaning condition now always true 	       or -1 meaning condition now always false 	       or 2 meaning condition nontrivial but altered.  */
specifier|register
name|int
name|result
init|=
name|alter_cond
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If condition now has fixed value, replace the IF_THEN_ELSE 	       with its then-operand or its else-operand.  */
if|if
condition|(
name|result
operator|==
literal|1
condition|)
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* The jump is now either unconditional or a no-op. 	       If it has become a no-op, don't try to output it. 	       (It would not be recognized.)  */
if|if
condition|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|==
name|pc_rtx
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Rerecognize the instruction if it has changed.  */
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STORE_FLAG_VALUE
comment|/* Make same adjustments to instructions that examine the 	   condition codes without jumping (if this machine has them).  */
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|GTU
case|:
case|case
name|GT
case|:
case|case
name|LTU
case|:
case|case
name|LT
case|:
case|case
name|GEU
case|:
case|case
name|GE
case|:
case|case
name|LEU
case|:
case|case
name|LE
case|:
case|case
name|EQ
case|:
case|case
name|NE
case|:
block|{
specifier|register
name|int
name|result
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|CC0
condition|)
break|break;
name|result
operator|=
name|alter_cond
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|STORE_FLAG_VALUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* STORE_FLAG_VALUE */
comment|/* Do machine-specific peephole optimizations if desired.  */
if|if
condition|(
name|optimize
operator|&&
operator|!
name|flag_no_peephole
operator|&&
operator|!
name|nopeepholes
condition|)
block|{
name|rtx
name|next
init|=
name|peephole
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* When peepholing, if there were notes within the peephole, 	       emit them before the peephole.  */
if|if
condition|(
name|next
operator|!=
literal|0
operator|&&
name|next
operator|!=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|note
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|note
operator|!=
name|next
condition|)
block|{
name|final_scan_insn
argument_list|(
name|note
argument_list|,
name|file
argument_list|,
name|write_symbols
argument_list|,
name|optimize
argument_list|,
name|prescan
argument_list|,
name|nopeepholes
argument_list|)
expr_stmt|;
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
expr_stmt|;
block|}
comment|/* In case this is prescan, put the notes 		   in proper position for later rescan.  */
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|prev
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|note
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|next
expr_stmt|;
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
comment|/* PEEPHOLE might have changed this.  */
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Try to recognize the instruction. 	   If successful, verify that the operands satisfy the 	   constraints for the instruction.  Crash if they don't, 	   since `reload' should have changed them so that they do.  */
name|insn_code_number
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn_extract
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn_n_operands
index|[
name|insn_code_number
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
name|recog_operand
index|[
name|i
index|]
operator|=
name|alter_subreg
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
name|insn_code_number
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Some target machines need to prescan each insn before 	   it is output.  */
ifdef|#
directive|ifdef
name|FINAL_PRESCAN_INSN
name|FINAL_PRESCAN_INSN
argument_list|(
name|insn
argument_list|,
name|recog_operand
argument_list|,
name|insn_n_operands
index|[
name|insn_code_number
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cc_prev_status
operator|=
name|cc_status
expr_stmt|;
comment|/* Update `cc_status' for this instruction. 	   The instruction's output routine may change it further. 	   If the output routine for a jump insn needs to depend 	   on the cc status, it should look at cc_prev_status.  */
name|NOTICE_UPDATE_CC
argument_list|(
name|body
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* If the proper template needs to be chosen by some C code, 	   run that code and get the real template.  */
name|template
operator|=
name|insn_template
index|[
name|insn_code_number
index|]
expr_stmt|;
if|if
condition|(
name|template
operator|==
literal|0
condition|)
block|{
name|template
operator|=
call|(
modifier|*
name|insn_outfun
index|[
name|insn_code_number
index|]
call|)
argument_list|(
name|recog_operand
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* If the C code returns 0, it means that it is a jump insn 	       which follows a deleted test insn, and that test insn 	       needs to be reinserted.  */
if|if
condition|(
name|template
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
name|last_ignored_compare
condition|)
name|abort
argument_list|()
expr_stmt|;
name|new_block
operator|=
literal|0
expr_stmt|;
return|return
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
comment|/* Output assembler code from the template.  */
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|recog_operand
argument_list|)
expr_stmt|;
comment|/* Mark this insn as having been output.  */
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up FILENAME as the current file for GDB line-number output.  */
end_comment

begin_function
name|void
name|set_current_gdbfile
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|register
name|struct
name|gdbfile
modifier|*
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
name|gdbfiles
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|f
operator|->
name|name
argument_list|,
name|filename
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|f
operator|=
operator|(
expr|struct
name|gdbfile
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gdbfile
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|next
operator|=
name|gdbfiles
expr_stmt|;
name|gdbfiles
operator|=
name|f
expr_stmt|;
name|f
operator|->
name|name
operator|=
name|filename
expr_stmt|;
name|f
operator|->
name|filenum
operator|=
name|next_gdb_filenum
operator|++
expr_stmt|;
name|f
operator|->
name|nlines
operator|=
literal|0
expr_stmt|;
block|}
name|current_gdbfile
operator|=
name|f
expr_stmt|;
name|lastfile
operator|=
name|filename
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output debugging info to the assembler file FILE    based on the NOTE-insn INSN, assumed to be a line number.  */
end_comment

begin_function
specifier|static
name|void
name|output_source_line
parameter_list|(
name|file
parameter_list|,
name|insn
parameter_list|,
name|write_symbols
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|enum
name|debugger
name|write_symbols
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|filename
init|=
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|last_linenum
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|==
name|GDB_DEBUG
condition|)
block|{
comment|/* Output GDB-format line number info.  */
comment|/* If this is not the same source file as last time, 	 find or assign a GDB-file-number to this file.  */
if|if
condition|(
name|filename
operator|&&
operator|(
name|lastfile
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|filename
argument_list|,
name|lastfile
argument_list|)
operator|||
name|current_gdbfile
operator|==
literal|0
operator|)
condition|)
name|set_current_gdbfile
argument_list|(
name|filename
argument_list|)
expr_stmt|;
operator|++
name|current_gdbfile
operator|->
name|nlines
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.gdbline %d,%d\n"
argument_list|,
name|current_gdbfile
operator|->
name|filenum
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|||
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
block|{
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
if|#
directive|if
literal|0
comment|/* People like having line numbers even in wrong file!  */
comment|/* COFF can't handle multiple source files--lose, lose.  */
expr|&& !strcmp (filename, main_input_filename)
endif|#
directive|endif
comment|/* COFF relative line numbers must be positive.  */
operator|&&
name|last_linenum
operator|>
name|sdb_begin_function_line
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SOURCE_LINE
name|ASM_OUTPUT_SOURCE_LINE
argument_list|(
name|file
argument_list|,
name|last_linenum
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.ln\t%d\n"
argument_list|,
operator|(
name|sdb_begin_function_line
condition|?
name|last_linenum
operator|-
name|sdb_begin_function_line
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
block|{
comment|/* Write DBX line number data.  */
if|if
condition|(
name|filename
operator|&&
operator|(
name|lastfile
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|filename
argument_list|,
name|lastfile
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SOURCE_FILENAME
name|ASM_OUTPUT_SOURCE_FILENAME
argument_list|(
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.stabs \"%s\",%d,0,0,Ltext\n"
argument_list|,
name|filename
argument_list|,
name|N_SOL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lastfile
operator|=
name|filename
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SOURCE_LINE
name|ASM_OUTPUT_SOURCE_LINE
argument_list|(
name|file
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.stabd %d,0,%d\n"
argument_list|,
name|N_SLINE
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* DBX_DEBUGGING_INFO */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X is a SUBREG, replace it with a REG or a MEM,    based on the thing it is a subreg of.  */
end_comment

begin_function
name|rtx
name|alter_subreg
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|rtx
name|y
init|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SUBREG
condition|)
name|y
operator|=
name|alter_subreg
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* If the containing reg really gets a hard reg, so do we.  */
name|PUT_CODE
argument_list|(
name|x
argument_list|,
name|REG
argument_list|)
expr_stmt|;
name|REGNO
argument_list|(
name|x
argument_list|)
operator|=
name|REGNO
argument_list|(
name|y
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|MEM
condition|)
block|{
specifier|register
name|int
name|offset
init|=
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|*
name|UNITS_PER_WORD
decl_stmt|;
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
name|offset
operator|-=
operator|(
name|min
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|-
name|min
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|PUT_CODE
argument_list|(
name|x
argument_list|,
name|MEM
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
name|y
return|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Do alter_subreg on all the SUBREGs contained in X.  */
end_comment

begin_function
specifier|static
name|rtx
name|walk_alter_subreg
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MULT
case|:
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|walk_alter_subreg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|walk_alter_subreg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|walk_alter_subreg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBREG
case|:
return|return
name|alter_subreg
argument_list|(
name|x
argument_list|)
return|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given BODY, the body of a jump instruction, alter the jump condition    as required by the bits that are set in cc_status.flags.    Not all of the bits there can be handled at this level in all cases.     The value is normally 0.    1 means that the condition has become always true.    -1 means that the condition has become always false.    2 means that COND has been altered.  */
end_comment

begin_function
specifier|static
name|int
name|alter_cond
parameter_list|(
name|cond
parameter_list|)
specifier|register
name|rtx
name|cond
decl_stmt|;
block|{
name|int
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_REVERSED
condition|)
block|{
name|value
operator|=
literal|2
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|LE
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|GE
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|LE
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|GT
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|LT
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|GEU
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|LEU
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|GTU
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|LTU
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_NOT_POSITIVE
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|LE
case|:
case|case
name|LEU
case|:
case|case
name|GEU
case|:
comment|/* Jump becomes unconditional.  */
return|return
literal|1
return|;
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|LTU
case|:
comment|/* Jump becomes no-op.  */
return|return
operator|-
literal|1
return|;
case|case
name|GE
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|EQ
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|NE
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_NOT_NEGATIVE
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|GE
case|:
case|case
name|GEU
case|:
comment|/* Jump becomes unconditional.  */
return|return
literal|1
return|;
case|case
name|LT
case|:
case|case
name|LTU
case|:
comment|/* Jump becomes no-op.  */
return|return
operator|-
literal|1
return|;
case|case
name|LE
case|:
case|case
name|LEU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|EQ
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GT
case|:
case|case
name|GTU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|NE
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_NO_OVERFLOW
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|GEU
case|:
comment|/* Jump becomes unconditional.  */
return|return
literal|1
return|;
case|case
name|LEU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|EQ
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|NE
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|LTU
case|:
comment|/* Jump becomes no-op.  */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
operator|(
name|CC_Z_IN_NOT_N
operator||
name|CC_Z_IN_N
operator|)
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|LE
case|:
case|case
name|LEU
case|:
case|case
name|GE
case|:
case|case
name|GEU
case|:
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|GT
case|:
case|case
name|GTU
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|NE
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|cc_status
operator|.
name|flags
operator|&
name|CC_Z_IN_N
condition|?
name|GE
else|:
name|LT
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|cc_status
operator|.
name|flags
operator|&
name|CC_Z_IN_N
condition|?
name|LT
else|:
name|GE
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Report inconsistency between the assembler template and the operands.    In an `asm', it's the user's fault; otherwise, the compiler's fault.  */
end_comment

begin_function
specifier|static
name|void
name|output_operand_lossage
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|this_is_asm_operands
condition|)
name|error_for_asm
argument_list|(
name|this_is_asm_operands
argument_list|,
literal|"invalid `asm': %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output of assembler code from a template, and its subroutines.  */
end_comment

begin_comment
comment|/* Output text from TEMPLATE to the assembler output file,    obeying %-directions to substitute operands taken from    the vector OPERANDS.     %N (for N a digit) means print operand N in usual manner.    %lN means require operand N to be a CODE_LABEL or LABEL_REF       and print the label name with no punctuation.    %cN means require operand N to be a constant       and print the constant expression with no punctuation.    %aN means expect operand N to be a memory address       (not a memory reference!) and print a reference       to that address.    %nN means expect operand N to be a constant       and print a constant expression for minus the value       of the operand, with no other punctuation.  */
end_comment

begin_function
name|void
name|output_asm_insn
parameter_list|(
name|template
parameter_list|,
name|operands
parameter_list|)
name|char
modifier|*
name|template
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* An insn may return a null string template      in a case where no assembler code is needed.  */
if|if
condition|(
operator|*
name|template
operator|==
literal|0
condition|)
return|return;
name|p
operator|=
name|template
expr_stmt|;
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_OPCODE
name|ASM_OUTPUT_OPCODE
argument_list|(
name|asm_out_file
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_OPCODE
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|==
literal|'\t'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|ASM_OUTPUT_OPCODE
argument_list|(
name|asm_out_file
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|c
operator|!=
literal|'%'
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* %% outputs a single %.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* % followed by a letter and some digits 	     outputs an operand in a special way depending on the letter. 	     Letters `acln' are implemented here. 	     Other letters are passed to `output_operand' so that 	     the PRINT_OPERAND macro can define them.  */
elseif|else
if|if
condition|(
operator|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'z'
operator|)
operator|||
operator|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
operator|)
condition|)
block|{
name|int
name|letter
init|=
operator|*
name|p
operator|++
decl_stmt|;
name|c
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
operator|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"operand number missing after %-letter"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|this_is_asm_operands
operator|&&
name|c
operator|>=
operator|(
name|unsigned
operator|)
name|insn_noperands
condition|)
name|output_operand_lossage
argument_list|(
literal|"operand number out of range"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'l'
condition|)
name|output_asm_label
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'a'
condition|)
name|output_address
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|)
condition|)
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|operands
index|[
name|c
index|]
argument_list|)
expr_stmt|;
else|else
name|output_operand
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%d"
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|putc
argument_list|(
literal|'-'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|operands
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|output_operand
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|,
name|letter
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
block|}
comment|/* % followed by a digit outputs an operand the default way.  */
elseif|else
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
block|{
name|c
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_asm_operands
operator|&&
name|c
operator|>=
operator|(
name|unsigned
operator|)
name|insn_noperands
condition|)
name|output_operand_lossage
argument_list|(
literal|"operand number out of range"
argument_list|)
expr_stmt|;
else|else
name|output_operand
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
block|}
comment|/* % followed by punctuation: output something for that 	     punctuation character alone, with no operand. 	     The PRINT_OPERAND macro decides what is actually done.  */
ifdef|#
directive|ifdef
name|PRINT_OPERAND_PUNCT_VALID_P
elseif|else
if|if
condition|(
name|PRINT_OPERAND_PUNCT_VALID_P
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|output_operand
argument_list|(
literal|0
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%-code"
argument_list|)
expr_stmt|;
block|}
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a LABEL_REF, or a bare CODE_LABEL, as an assembler symbol.  */
end_comment

begin_function
name|void
name|output_asm_label
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"`%l' operand isn't a label"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print operand X using machine-dependent assembler syntax.    The macro PRINT_OPERAND is defined just to control this function.    CODE is a non-digit that preceded the operand-number in the % spec,    such as 'z' if the spec was `%z3'.  CODE is 0 if there was no char    between the % and the digits.    When CODE is a non-letter, X is 0.     The meanings of the letters are machine-dependent and controlled    by PRINT_OPERAND.  */
end_comment

begin_function
specifier|static
name|void
name|output_operand
parameter_list|(
name|x
parameter_list|,
name|code
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|x
operator|=
name|alter_subreg
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|PRINT_OPERAND
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a memory reference operand for address X    using machine-dependent assembler syntax.    The macro PRINT_OPERAND_ADDRESS exists just to control this function.  */
end_comment

begin_function
name|void
name|output_address
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|walk_alter_subreg
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|PRINT_OPERAND_ADDRESS
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an integer constant expression in assembler syntax.    Addition and subtraction are the only arithmetic    that may appear in these expressions.  */
end_comment

begin_function
name|void
name|output_addr_const
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|restart
label|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
name|assemble_name
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DImode
condition|)
block|{
comment|/* We can use %d if the number is<32 bits and positive.  */
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|||
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%x%08x"
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We can't handle floating point constants; 	   PRINT_OPERAND must handle them.  */
name|output_operand_lossage
argument_list|(
literal|"floating constant misused"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* Some assemblers need integer constants to appear last (eg masm).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MINUS
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid expression as operand"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

