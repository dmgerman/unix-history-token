begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Emit RTL for the GNU C-Compiler expander.    Copyright (C) 1987, 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Middle-to-low level generation of rtx code and insns.     This file contains the functions `gen_rtx', `gen_reg_rtx'    and `gen_label_rtx' that are the usual ways of creating rtl    expressions for most purposes.     It also has the functions for creating insns and linking    them in the doubly-linked chain.     The patterns of the insns are created by machine-dependent    routines in insn-emit.c, which is generated automatically from    the machine description.  These routines use `gen_rtx' to make    the individual rtx's of the pattern; what is machine dependent    is the kind of rtx's they make and what arguments they use.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"gvarargs.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_define
define|#
directive|define
name|max
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)> (B) ? (A) : (B))
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)< (B) ? (A) : (B))
end_define

begin_comment
comment|/* This is reset to FIRST_PSEUDO_REGISTER at the start each function.    After rtl generation, it is 1 plus the largest register number used.  */
end_comment

begin_decl_stmt
name|int
name|reg_rtx_no
init|=
name|FIRST_PSEUDO_REGISTER
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is *not* reset after each function.  It gives each CODE_LABEL    in the entire compilation a unique label number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|label_num
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value of `label_num' at start of current function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_label_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do not generate NOTEs for source line numbers.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_line_numbers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Commonly used rtx's, so that we only need space for one copy.    These are initialized once for the entire compilation.    All of these except perhaps fconst0_rtx and dconst0_rtx    are unique; no other rtx-object will be equal to any of these.  */
end_comment

begin_decl_stmt
name|rtx
name|pc_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (PC) */
end_comment

begin_decl_stmt
name|rtx
name|cc0_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (CC0) */
end_comment

begin_decl_stmt
name|rtx
name|cc1_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (CC1) (not actually used nowadays) */
end_comment

begin_decl_stmt
name|rtx
name|const0_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (CONST_INT 0) */
end_comment

begin_decl_stmt
name|rtx
name|const1_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (CONST_INT 1) */
end_comment

begin_decl_stmt
name|rtx
name|fconst0_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (CONST_DOUBLE:SF 0) */
end_comment

begin_decl_stmt
name|rtx
name|dconst0_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (CONST_DOUBLE:DF 0) */
end_comment

begin_comment
comment|/* All references to the following fixed hard registers go through    these unique rtl objects.  On machines where the frame-pointer and    arg-pointer are the same register, they use the same unique object.     After register allocation, other rtl objects which used to be pseudo-regs    may be clobbered to refer to the frame-pointer register.    But references that were originally to the frame-pointer can be    distinguished from the others because they contain frame_pointer_rtx.     In an inline procedure, the stack and frame pointer rtxs may not be    used for anything else.  */
end_comment

begin_decl_stmt
name|rtx
name|stack_pointer_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode STACK_POINTER_REGNUM) */
end_comment

begin_decl_stmt
name|rtx
name|frame_pointer_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode FRAME_POINTER_REGNUM) */
end_comment

begin_decl_stmt
name|rtx
name|arg_pointer_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode ARG_POINTER_REGNUM) */
end_comment

begin_decl_stmt
name|rtx
name|struct_value_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode STRUCT_VALUE_REGNUM) */
end_comment

begin_decl_stmt
name|rtx
name|struct_value_incoming_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode STRUCT_VALUE_INCOMING_REGNUM) */
end_comment

begin_decl_stmt
name|rtx
name|static_chain_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode STATIC_CHAIN_REGNUM) */
end_comment

begin_decl_stmt
name|rtx
name|static_chain_incoming_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (REG:Pmode STATIC_CHAIN_INCOMING_REGNUM) */
end_comment

begin_comment
comment|/* The ends of the doubly-linked chain of rtl for the current function.    Both are reset to null at the start of rtl generation for the function.        start_sequence saves both of these on `sequence_stack' and then    starts a new, nested sequence of insns.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|first_insn
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|last_insn
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of pending (incomplete) sequences saved by `start_sequence'.    This looks like    (INSN_LIST saved-first-insn               (INSN_LIST saved-last-insn ...more saved sequences...)).    The main insn-chain is saved in the last two links of the chain,    unless the chain is empty.  */
end_comment

begin_decl_stmt
name|rtx
name|sequence_stack
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INSN_UID for next insn emitted.    Reset to 1 for each function compiled.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cur_insn_uid
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line number and source file of the last line-number NOTE emitted.    This is used to avoid generating duplicates.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_linenum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_filename
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vector indexed by pseudo reg number.  The allocated length    of this vector is regno_pointer_flag_length.  Since this    vector is needed during the expansion phase when the total    number of registers in the function is not yet known,    it is copied and made bigger when necessary.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|regno_pointer_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|regno_pointer_flag_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by pseudo register number, gives the rtx for that pseudo.    Allocated in parallel with regno_pointer_flag.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|regno_reg_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filename and line number of last line-number note,    whether we actually emitted it or not.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|emit_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|emit_lineno
decl_stmt|;
end_decl_stmt

begin_function_decl
name|rtx
name|change_address
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* rtx gen_rtx (code, mode, [element1, ..., elementn]) ** **	    This routine generates an RTX of the size specified by **<code>, which is an RTX code.   The RTX structure is initialized **	from the arguments<element1> through<elementn>, which are **	interpreted according to the specific RTX type's format.   The **	special machine mode associated with the rtx (if any) is specified **	in<mode>. ** **	    gen_rtx() can be invoked in a way which resembles the lisp-like **	rtx it will generate.   For example, the following rtx structure: ** **	      (plus:QI (mem:QI (reg:SI 1)) **		       (mem:QI (plusw:SI (reg:SI 2) (reg:SI 3)))) ** **		...would be generated by the following C code: ** **	    	gen_rtx (PLUS, QImode, **		    gen_rtx (MEM, QImode, **			gen_rtx (REG, SImode, 1)), **		    gen_rtx (MEM, QImode, **			gen_rtx (PLUS, SImode, **			    gen_rtx (REG, SImode, 2), **			    gen_rtx (REG, SImode, 3)))), */
end_comment

begin_comment
comment|/*VARARGS2*/
end_comment

begin_function
name|rtx
name|gen_rtx
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|p
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Array indices...			*/
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Current rtx's format...		*/
specifier|register
name|rtx
name|rt_val
decl_stmt|;
comment|/* RTX to return to caller...		*/
name|va_start
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|code
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
expr|enum
name|rtx_code
argument_list|)
expr_stmt|;
name|mode
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
expr|enum
name|machine_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|arg
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|int
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|arg
operator|==
literal|1
condition|)
return|return
name|const1_rtx
return|;
name|rt_val
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|INTVAL
argument_list|(
name|rt_val
argument_list|)
operator|=
name|arg
expr_stmt|;
block|}
else|else
block|{
name|rt_val
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Allocate the storage space.  */
name|rt_val
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
comment|/* Store the machine mode...  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Find the right format...  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'0'
case|:
comment|/* Unused field.  */
break|break;
case|case
literal|'i'
case|:
comment|/* An integer?  */
name|XINT
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* A string?  */
name|XSTR
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* An expression?  */
case|case
literal|'u'
case|:
comment|/* An insn?  Same except when printing.  */
name|XEXP
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* An RTX vector?  */
name|XVEC
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtvec
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|rt_val
return|;
comment|/* Return the new RTX...		*/
block|}
end_function

begin_comment
comment|/* gen_rtvec (n, [rt1, ..., rtn]) ** **	    This routine creates an rtvec and stores within it the **	pointers to rtx's which are its arguments. */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|rtvec
name|gen_rtvec
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
name|va_list
name|p
decl_stmt|;
name|rtx
modifier|*
name|vector
decl_stmt|;
name|va_start
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|n
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|NULL_RTVEC
return|;
comment|/* Don't allocate an empty rtvec...	*/
name|vector
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|vector
index|[
name|i
index|]
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|gen_rtvec_v
argument_list|(
name|n
argument_list|,
name|vector
argument_list|)
return|;
block|}
end_function

begin_function
name|rtvec
name|gen_rtvec_v
parameter_list|(
name|n
parameter_list|,
name|argp
parameter_list|)
name|int
name|n
decl_stmt|;
name|rtx
modifier|*
name|argp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtvec
name|rt_val
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|NULL_RTVEC
return|;
comment|/* Don't allocate an empty rtvec...	*/
name|rt_val
operator|=
name|rtvec_alloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* Allocate an rtvec...			*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|rt_val
operator|->
name|elem
index|[
name|i
index|]
operator|.
name|rtx
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
return|return
name|rt_val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a REG rtx for a new pseudo register of mode MODE.    This pseudo is assigned the next sequential register number.  */
end_comment

begin_function
name|rtx
name|gen_reg_rtx
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|rtx
name|val
decl_stmt|;
comment|/* Make sure regno_pointer_flag and regno_reg_rtx are large      enough to have an element for this pseudo reg number.  */
if|if
condition|(
name|reg_rtx_no
operator|==
name|regno_pointer_flag_length
condition|)
block|{
name|rtx
modifier|*
name|new1
decl_stmt|;
name|char
modifier|*
name|new
init|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
name|regno_pointer_flag_length
operator|*
literal|2
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|new
argument_list|,
name|regno_pointer_flag_length
operator|*
literal|2
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regno_pointer_flag
argument_list|,
name|new
argument_list|,
name|regno_pointer_flag_length
argument_list|)
expr_stmt|;
name|regno_pointer_flag
operator|=
name|new
expr_stmt|;
name|new1
operator|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
name|regno_pointer_flag_length
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|new1
argument_list|,
name|regno_pointer_flag_length
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regno_reg_rtx
argument_list|,
name|new1
argument_list|,
name|regno_pointer_flag_length
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|regno_reg_rtx
operator|=
name|new1
expr_stmt|;
name|regno_pointer_flag_length
operator|*=
literal|2
expr_stmt|;
block|}
name|val
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|reg_rtx_no
argument_list|)
expr_stmt|;
name|regno_reg_rtx
index|[
name|reg_rtx_no
operator|++
index|]
operator|=
name|val
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Identify REG as a probable pointer register.  */
end_comment

begin_function
name|void
name|mark_reg_pointer
parameter_list|(
name|reg
parameter_list|)
name|rtx
name|reg
decl_stmt|;
block|{
name|REGNO_POINTER_FLAG
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 plus largest pseudo reg number used in the current function.  */
end_comment

begin_function
name|int
name|max_reg_num
parameter_list|()
block|{
return|return
name|reg_rtx_no
return|;
block|}
end_function

begin_comment
comment|/* Return 1 + the largest label number used so far.  */
end_comment

begin_function
name|int
name|max_label_num
parameter_list|()
block|{
return|return
name|label_num
return|;
block|}
end_function

begin_comment
comment|/* Return first label number used in this function (if any were used).  */
end_comment

begin_function
name|int
name|get_first_label_num
parameter_list|()
block|{
return|return
name|first_label_num
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assuming that X is an rtx (MEM, REG or SUBREG) for a fixed-point number,    return a MEM or SUBREG rtx that refers to the least-significant part of X.    MODE specifies how big a part of X to return;    it must not be larger than a word.    If X is a MEM whose address is a QUEUED, the value may be so also.  */
end_comment

begin_function
name|rtx
name|gen_lowpart
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
comment|/* This case loses if X is a subreg.  To catch bugs early,      complain if an invalid MODE is used even in other cases.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|!=
name|GET_MODE_UNIT_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|mode
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
comment|/* In version 1.37, try this: */
comment|/*  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT) abort (); */
comment|/* Assume it's an int, so ..._LOW means the low-order word.  */
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|&
name|GET_MODE_MASK
argument_list|(
name|mode
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
specifier|register
name|int
name|offset
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|WORDS_BIG_ENDIAN
name|offset
operator|=
operator|(
name|max
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|-
name|max
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
comment|/* Adjust the address so that the address-after-the-data 	 is unchanged.  */
name|offset
operator|-=
operator|(
name|min
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|-
name|min
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
name|change_address
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
return|return
operator|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|mode
operator|&&
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|?
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
else|:
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|mode
argument_list|,
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
ifdef|#
directive|ifdef
name|WORDS_BIG_ENDIAN
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
block|{
return|return
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
name|max
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
argument_list|)
return|;
block|}
endif|#
directive|endif
return|return
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like `gen_lowpart', but refer to the most significant part.  */
end_comment

begin_function
name|rtx
name|gen_highpart
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
specifier|register
name|int
name|offset
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|WORDS_BIG_ENDIAN
name|offset
operator|=
operator|(
name|max
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|-
name|max
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|BYTES_BIG_ENDIAN
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
name|offset
operator|-=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|min
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
name|change_address
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
ifndef|#
directive|ifndef
name|WORDS_BIG_ENDIAN
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
block|{
return|return
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
name|max
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
argument_list|)
return|;
block|}
endif|#
directive|endif
return|return
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 iff X, assumed to be a SUBREG,    refers to the least significant part of its containing reg.    If X is not a SUBREG, always return 1 (it is its own low part!).  */
end_comment

begin_function
name|int
name|subreg_lowpart_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SUBREG
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|WORDS_BIG_ENDIAN
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
block|{
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
name|max
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
return|;
block|}
endif|#
directive|endif
return|return
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a memory reference like MEMREF, but with its mode changed    to MODE and its address changed to ADDR.    (VOIDmode means don't change the mode.    NULL for ADDR means don't change the address.)  */
end_comment

begin_function
name|rtx
name|change_address
parameter_list|(
name|memref
parameter_list|,
name|mode
parameter_list|,
name|addr
parameter_list|)
name|rtx
name|memref
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
name|rtx
name|new
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|memref
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|memref
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|memory_address
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|new
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|memref
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|memref
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|new
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|memref
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a newly created CODE_LABEL rtx with a unique label number.  */
end_comment

begin_function
name|rtx
name|gen_label_rtx
parameter_list|()
block|{
specifier|register
name|rtx
name|label
init|=
name|gen_rtx
argument_list|(
name|CODE_LABEL
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|label_num
operator|++
argument_list|)
decl_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For procedure integration.  */
end_comment

begin_comment
comment|/* Return a newly created INLINE_HEADER rtx.  Should allocate this    from a permanent obstack when the opportunity arises.  */
end_comment

begin_function
name|rtx
name|gen_inline_header_rtx
parameter_list|(
name|insn
parameter_list|,
name|last_insn
parameter_list|,
name|first_labelno
parameter_list|,
name|last_labelno
parameter_list|,
name|max_parm_regnum
parameter_list|,
name|max_regnum
parameter_list|,
name|args_size
parameter_list|,
name|stack_slots
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|last_insn
decl_stmt|;
name|int
name|first_labelno
decl_stmt|,
name|last_labelno
decl_stmt|,
name|max_parm_regnum
decl_stmt|,
name|max_regnum
decl_stmt|,
name|args_size
decl_stmt|;
name|rtx
name|stack_slots
decl_stmt|;
block|{
name|rtx
name|header
init|=
name|gen_rtx
argument_list|(
name|INLINE_HEADER
argument_list|,
name|VOIDmode
argument_list|,
name|cur_insn_uid
operator|++
argument_list|,
name|NULL
argument_list|,
name|insn
argument_list|,
name|last_insn
argument_list|,
name|first_labelno
argument_list|,
name|last_labelno
argument_list|,
name|max_parm_regnum
argument_list|,
name|max_regnum
argument_list|,
name|args_size
argument_list|,
name|stack_slots
argument_list|)
decl_stmt|;
return|return
name|header
return|;
block|}
end_function

begin_comment
comment|/* Install new pointers to the first and last insns in the chain.    Used for an inline-procedure after copying the insn chain.  */
end_comment

begin_function
name|void
name|set_new_first_and_last_insn
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|rtx
name|first
decl_stmt|,
name|last
decl_stmt|;
block|{
name|first_insn
operator|=
name|first
expr_stmt|;
name|last_insn
operator|=
name|last
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Go through all the RTL insn bodies and copy any invalid shared structure.    It does not work to do this twice, because the mark bits set here    are not cleared afterwards.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unshare_copies
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count rtx's that were copied.  */
end_comment

begin_function_decl
specifier|static
name|rtx
name|copy_rtx_if_shared
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|unshare_all_rtl
parameter_list|(
name|insn
parameter_list|)
specifier|register
name|rtx
name|insn
decl_stmt|;
block|{
specifier|extern
name|rtx
name|stack_slot_list
decl_stmt|;
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure the addresses of stack slots are not shared      with anything in the insn chain.  That could happen if      the stack slot is referenced only by its address.  */
name|copy_rtx_if_shared
argument_list|(
name|stack_slot_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark ORIG as in use, and return a copy of it if it was already in use.    Recursively does the same for subexpressions.  */
end_comment

begin_function
specifier|static
name|rtx
name|copy_rtx_if_shared
parameter_list|(
name|orig
parameter_list|)
name|rtx
name|orig
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
init|=
name|orig
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|copied
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* These types may be freely shared.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|x
return|;
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|NOTE
case|:
case|case
name|LABEL_REF
case|:
case|case
name|BARRIER
case|:
comment|/* The chain of insns is not being copied.  */
return|return
name|x
return|;
case|case
name|MEM
case|:
comment|/* A MEM is allowed to be shared if its address is constant 	 or is a constant plus one of the special registers.  */
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
operator|||
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
operator|)
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This MEM can appear in more than one place, 	     but its address better not be shared with anything else.  */
if|if
condition|(
operator|!
name|x
operator|->
name|used
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|->
name|used
operator|=
literal|1
expr_stmt|;
return|return
name|x
return|;
block|}
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
operator|||
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
condition|)
return|return
name|x
return|;
block|}
comment|/* This rtx may not be shared.  If it has already been seen,      replace it with a copy of itself.  */
if|if
condition|(
name|x
operator|->
name|used
condition|)
block|{
specifier|register
name|rtx
name|copy
decl_stmt|;
name|unshare_copies
operator|++
expr_stmt|;
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|x
argument_list|,
name|copy
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|copy
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|copy
operator|->
name|fld
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|copy
operator|->
name|fld
index|[
literal|0
index|]
argument_list|)
operator|*
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|copy
expr_stmt|;
name|copied
operator|=
literal|1
expr_stmt|;
block|}
name|x
operator|->
name|used
operator|=
literal|1
expr_stmt|;
comment|/* Now scan the subexpressions recursively.      We can store any replaced subexpressions directly into X      since we know X is not shared!  Any vectors in X      must be copied if X was copied.  */
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
name|copied
condition|)
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtvec_v
argument_list|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_rtx_if_shared
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy X if necessary so that it won't be altered by changes in OTHER.    Return X or the rtx for the pseudo reg the value of X was copied into.    OTHER must be valid as a SET_DEST.  */
end_comment

begin_function
name|rtx
name|make_safe_from
parameter_list|(
name|x
parameter_list|,
name|other
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|other
decl_stmt|;
block|{
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|other
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
name|other
operator|=
name|SUBREG_REG
argument_list|(
name|other
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRICT_LOW_PART
case|:
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
name|other
operator|=
name|XEXP
argument_list|(
name|other
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|done
goto|;
block|}
name|done
label|:
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|other
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SUBREG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|other
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|other
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|reg_mentioned_p
argument_list|(
name|other
argument_list|,
name|x
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emission of insns (adding them to the doubly-linked list).  */
end_comment

begin_comment
comment|/* Return the first insn of the current sequence or current function.  */
end_comment

begin_function
name|rtx
name|get_insns
parameter_list|()
block|{
return|return
name|first_insn
return|;
block|}
end_function

begin_comment
comment|/* Return the last insn emitted in current sequence or current function.  */
end_comment

begin_function
name|rtx
name|get_last_insn
parameter_list|()
block|{
return|return
name|last_insn
return|;
block|}
end_function

begin_comment
comment|/* Specify a new insn as the last in the chain.  */
end_comment

begin_function
name|void
name|set_last_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|last_insn
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a number larger than any instruction's uid in this function.  */
end_comment

begin_function
name|int
name|get_max_uid
parameter_list|()
block|{
return|return
name|cur_insn_uid
return|;
block|}
end_function

begin_function
name|rtx
name|next_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|insn
condition|)
return|return
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|rtx
name|previous_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|insn
condition|)
return|return
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make and return an INSN rtx, initializing all its slots.    Store PATTERN in the pattern slots.    PAT_FORMALS is an idea that never really went anywhere.  */
end_comment

begin_function
specifier|static
name|rtx
name|make_insn_raw
parameter_list|(
name|pattern
parameter_list|,
name|pat_formals
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
name|rtvec
name|pat_formals
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|insn
operator|=
name|rtx_alloc
argument_list|(
name|INSN
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pattern
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Like `make_insn' but make a JUMP_INSN instead of an insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|make_jump_insn_raw
parameter_list|(
name|pattern
parameter_list|,
name|pat_formals
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
name|rtvec
name|pat_formals
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|insn
operator|=
name|rtx_alloc
argument_list|(
name|JUMP_INSN
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|pattern
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add INSN to the end of the doubly-linked list.    INSN may be an INSN, JUMP_INSN, CALL_INSN, CODE_LABEL, BARRIER or NOTE.  */
end_comment

begin_function
specifier|static
name|void
name|add_insn
parameter_list|(
name|insn
parameter_list|)
specifier|register
name|rtx
name|insn
decl_stmt|;
block|{
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|last_insn
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|last_insn
condition|)
name|NEXT_INSN
argument_list|(
name|last_insn
argument_list|)
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|first_insn
condition|)
name|first_insn
operator|=
name|insn
expr_stmt|;
name|last_insn
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add INSN, an rtx of code INSN, into the doubly-linked list    after insn AFTER.  */
end_comment

begin_function
specifier|static
name|void
name|add_insn_after
parameter_list|(
name|insn
parameter_list|,
name|after
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|after
decl_stmt|;
block|{
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|after
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
elseif|else
if|if
condition|(
name|last_insn
operator|==
name|after
condition|)
name|last_insn
operator|=
name|insn
expr_stmt|;
else|else
block|{
name|rtx
name|stack
init|=
name|sequence_stack
decl_stmt|;
comment|/* Scan all pending sequences too.  */
for|for
control|(
init|;
name|stack
condition|;
name|stack
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|stack
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|after
operator|==
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|stack
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|stack
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete all insns made since FROM.    FROM becomes the new last instruction.  */
end_comment

begin_function
name|void
name|delete_insns_since
parameter_list|(
name|from
parameter_list|)
name|rtx
name|from
decl_stmt|;
block|{
if|if
condition|(
name|from
operator|==
literal|0
condition|)
name|first_insn
operator|=
literal|0
expr_stmt|;
else|else
name|NEXT_INSN
argument_list|(
name|from
argument_list|)
operator|=
literal|0
expr_stmt|;
name|last_insn
operator|=
name|from
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move a consecutive bunch of insns to a different place in the chain.    The insns to be moved are those between FROM and TO.    They are moved to a new position after the insn AFTER.  */
end_comment

begin_function
name|void
name|reorder_insns
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|after
parameter_list|)
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|,
name|after
decl_stmt|;
block|{
comment|/* Splice this bunch out of where it is now.  */
if|if
condition|(
name|PREV_INSN
argument_list|(
name|from
argument_list|)
condition|)
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|from
argument_list|)
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
condition|)
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_insn
operator|==
name|to
condition|)
name|last_insn
operator|=
name|PREV_INSN
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_insn
operator|==
name|from
condition|)
name|first_insn
operator|=
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
expr_stmt|;
comment|/* Make the new neighbors point to it and it to them.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
condition|)
block|{
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
argument_list|)
operator|=
name|to
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|to
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
expr_stmt|;
block|}
name|PREV_INSN
argument_list|(
name|from
argument_list|)
operator|=
name|after
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
operator|=
name|from
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|last_insn
condition|)
name|last_insn
operator|=
name|to
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit an insn of given code and pattern    at a specified place within the doubly-linked list.  */
end_comment

begin_comment
comment|/* Make an instruction with body PATTERN    and output it before the instruction BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_insn_before
parameter_list|(
name|pattern
parameter_list|,
name|before
parameter_list|)
specifier|register
name|rtx
name|pattern
decl_stmt|,
name|before
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* For an empty sequence, emit nothing.  */
if|if
condition|(
name|XVEC
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|add_insn_after
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|before
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|PREV_INSN
argument_list|(
name|before
argument_list|)
return|;
block|}
name|insn
operator|=
name|make_insn_raw
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|before
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|before
expr_stmt|;
if|if
condition|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
else|else
name|first_insn
operator|=
name|insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|before
argument_list|)
operator|=
name|insn
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Make an instruction with body PATTERN and code JUMP_INSN    and output it before the instruction BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_jump_insn_before
parameter_list|(
name|pattern
parameter_list|,
name|before
parameter_list|)
specifier|register
name|rtx
name|pattern
decl_stmt|,
name|before
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
init|=
name|make_jump_insn_raw
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|before
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|before
expr_stmt|;
if|if
condition|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
else|else
name|first_insn
operator|=
name|insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|before
argument_list|)
operator|=
name|insn
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Make an instruction with body PATTERN and code CALL_INSN    and output it before the instruction BEFORE.  */
end_comment

begin_function
name|rtx
name|emit_call_insn_before
parameter_list|(
name|pattern
parameter_list|,
name|before
parameter_list|)
specifier|register
name|rtx
name|pattern
decl_stmt|,
name|before
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|emit_insn_before
argument_list|(
name|pattern
argument_list|,
name|before
argument_list|)
decl_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|CALL_INSN
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make an insn of code INSN with body PATTERN    and output it after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_insn_after
parameter_list|(
name|pattern
parameter_list|,
name|after
parameter_list|)
specifier|register
name|rtx
name|pattern
decl_stmt|,
name|after
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* For an empty sequence, emit nothing.  */
if|if
condition|(
name|XVEC
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|add_insn_after
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|after
operator|=
name|NEXT_INSN
argument_list|(
name|after
argument_list|)
expr_stmt|;
block|}
return|return
name|after
return|;
block|}
else|else
block|{
specifier|register
name|rtx
name|insn
init|=
name|make_insn_raw
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|add_insn_after
argument_list|(
name|insn
argument_list|,
name|after
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
block|}
end_function

begin_comment
comment|/* Make an insn of code JUMP_INSN with body PATTERN    and output it after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_jump_insn_after
parameter_list|(
name|pattern
parameter_list|,
name|after
parameter_list|)
specifier|register
name|rtx
name|pattern
decl_stmt|,
name|after
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
init|=
name|make_jump_insn_raw
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|add_insn_after
argument_list|(
name|insn
argument_list|,
name|after
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code BARRIER    and output it after the insn AFTER.  */
end_comment

begin_function
name|rtx
name|emit_barrier_after
parameter_list|(
name|after
parameter_list|)
specifier|register
name|rtx
name|after
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
init|=
name|rtx_alloc
argument_list|(
name|BARRIER
argument_list|)
decl_stmt|;
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn_after
argument_list|(
name|insn
argument_list|,
name|after
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Emit the label LABEL after the insn AFTER.  */
end_comment

begin_function
name|void
name|emit_label_after
parameter_list|(
name|label
parameter_list|,
name|after
parameter_list|)
name|rtx
name|label
decl_stmt|,
name|after
decl_stmt|;
block|{
comment|/* This can be called twice for the same label      as a result of the confusion that follows a syntax error!      So make it harmless.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn_after
argument_list|(
name|label
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit a note of subtype SUBTYPE after the insn AFTER.  */
end_comment

begin_function
name|void
name|emit_note_after
parameter_list|(
name|subtype
parameter_list|,
name|after
parameter_list|)
name|int
name|subtype
decl_stmt|;
name|rtx
name|after
decl_stmt|;
block|{
specifier|register
name|rtx
name|note
init|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
decl_stmt|;
name|INSN_UID
argument_list|(
name|note
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|XSTR
argument_list|(
name|note
argument_list|,
literal|3
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XINT
argument_list|(
name|note
argument_list|,
literal|4
argument_list|)
operator|=
name|subtype
expr_stmt|;
name|add_insn_after
argument_list|(
name|note
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make an insn of code INSN with pattern PATTERN    and add it to the end of the doubly-linked list.    If PATTERN is a SEQUENCE, take the elements of it    and emit an insn for each element.     Returns the last insn emitted.  */
end_comment

begin_function
name|rtx
name|emit_insn
parameter_list|(
name|pattern
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* For an empty sequence, emit nothing.  */
if|if
condition|(
name|XVEC
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|add_insn
argument_list|(
name|insn
operator|=
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insn
operator|=
name|make_insn_raw
argument_list|(
name|pattern
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Emit the insns in a chain starting with INSN.  */
end_comment

begin_function
name|rtx
name|emit_insns
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|insn
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make an insn of code JUMP_INSN with pattern PATTERN    and add it to the end of the doubly-linked list.  */
end_comment

begin_function
name|rtx
name|emit_jump_insn
parameter_list|(
name|pattern
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
return|return
name|emit_insn
argument_list|(
name|pattern
argument_list|)
return|;
else|else
block|{
specifier|register
name|rtx
name|insn
init|=
name|make_jump_insn_raw
argument_list|(
name|pattern
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
block|}
end_function

begin_comment
comment|/* Make an insn of code CALL_INSN with pattern PATTERN    and add it to the end of the doubly-linked list.  */
end_comment

begin_function
name|rtx
name|emit_call_insn
parameter_list|(
name|pattern
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
condition|)
return|return
name|emit_insn
argument_list|(
name|pattern
argument_list|)
return|;
else|else
block|{
specifier|register
name|rtx
name|insn
init|=
name|make_insn_raw
argument_list|(
name|pattern
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|add_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|CALL_INSN
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
block|}
end_function

begin_comment
comment|/* Add the label LABEL to the end of the doubly-linked list.  */
end_comment

begin_function
name|rtx
name|emit_label
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
comment|/* This can be called twice for the same label      as a result of the confusion that follows a syntax error!      So make it harmless.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
block|{
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code BARRIER    and add it to the end of the doubly-linked list.  */
end_comment

begin_function
name|rtx
name|emit_barrier
parameter_list|()
block|{
specifier|register
name|rtx
name|barrier
init|=
name|rtx_alloc
argument_list|(
name|BARRIER
argument_list|)
decl_stmt|;
name|INSN_UID
argument_list|(
name|barrier
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|add_insn
argument_list|(
name|barrier
argument_list|)
expr_stmt|;
return|return
name|barrier
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code NOTE    with data-fields specified by FILE and LINE    and add it to the end of the doubly-linked list,    but only if line-numbers are desired for debugging info.  */
end_comment

begin_function
name|rtx
name|emit_line_note
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|emit_filename
operator|=
name|file
expr_stmt|;
name|emit_lineno
operator|=
name|line
expr_stmt|;
if|#
directive|if
literal|0
block|if (no_line_numbers)     return 0;
endif|#
directive|endif
return|return
name|emit_note
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make an insn of code NOTE    with data-fields specified by FILE and LINE    and add it to the end of the doubly-linked list.    If it is a line-number NOTE, omit it if it matches the previous one.  */
end_comment

begin_function
name|rtx
name|emit_note
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
specifier|register
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|line
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|file
operator|&&
name|last_filename
operator|&&
operator|!
name|strcmp
argument_list|(
name|file
argument_list|,
name|last_filename
argument_list|)
operator|&&
name|line
operator|==
name|last_linenum
condition|)
return|return
literal|0
return|;
name|last_filename
operator|=
name|file
expr_stmt|;
name|last_linenum
operator|=
name|line
expr_stmt|;
block|}
if|if
condition|(
name|no_line_numbers
operator|&&
name|line
operator|>
literal|0
condition|)
block|{
name|cur_insn_uid
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|note
operator|=
name|rtx_alloc
argument_list|(
name|NOTE
argument_list|)
expr_stmt|;
name|INSN_UID
argument_list|(
name|note
argument_list|)
operator|=
name|cur_insn_uid
operator|++
expr_stmt|;
name|XSTR
argument_list|(
name|note
argument_list|,
literal|3
argument_list|)
operator|=
name|file
expr_stmt|;
name|XINT
argument_list|(
name|note
argument_list|,
literal|4
argument_list|)
operator|=
name|line
expr_stmt|;
name|add_insn
argument_list|(
name|note
argument_list|)
expr_stmt|;
return|return
name|note
return|;
block|}
end_function

begin_comment
comment|/* Emit a NOTE, and don't omit it even if LINE it the previous note.  */
end_comment

begin_function
name|rtx
name|emit_line_note_force
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|last_linenum
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|emit_line_note
argument_list|(
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Cause next statement to emit a line note even if the line number    has not changed.  This is used at the beginning of a function.  */
end_comment

begin_function
name|void
name|force_next_line_note
parameter_list|()
block|{
name|last_linenum
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an indication of which type of insn should have X as a body.    The value is CODE_LABEL, INSN, CALL_INSN or JUMP_INSN.  */
end_comment

begin_function
name|enum
name|rtx_code
name|classify_insn
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
name|CODE_LABEL
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CALL
condition|)
return|return
name|CALL_INSN
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|RETURN
condition|)
return|return
name|JUMP_INSN
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return
name|JUMP_INSN
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
return|return
name|CALL_INSN
return|;
else|else
return|return
name|INSN
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
return|return
name|CALL_INSN
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return
name|JUMP_INSN
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
return|return
name|CALL_INSN
return|;
block|}
return|return
name|INSN
return|;
block|}
end_function

begin_comment
comment|/* Emit the rtl pattern X as an appropriate kind of insn.    If X is a label, it is simply added into the insn chain.  */
end_comment

begin_function
name|void
name|emit
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|classify_insn
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
condition|)
name|emit_label
argument_list|(
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|INSN
condition|)
name|emit_insn
argument_list|(
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|JUMP_INSN
condition|)
block|{
specifier|register
name|rtx
name|insn
init|=
name|emit_jump_insn
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|RETURN
condition|)
name|emit_barrier
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CALL_INSN
condition|)
name|emit_call_insn
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin emitting insns to a sequence which can be packaged in an RTL_EXPR.    Return an rtx containing data on any sequence already in progress.  */
end_comment

begin_function
name|rtx
name|start_sequence
parameter_list|()
block|{
name|sequence_stack
operator|=
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|first_insn
argument_list|,
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|last_insn
argument_list|,
name|sequence_stack
argument_list|)
argument_list|)
expr_stmt|;
name|first_insn
operator|=
literal|0
expr_stmt|;
name|last_insn
operator|=
literal|0
expr_stmt|;
return|return
name|sequence_stack
return|;
block|}
end_function

begin_comment
comment|/* Set up the insn chain starting with FIRST    as the current sequence, saving the previously current one.  */
end_comment

begin_function
name|void
name|push_to_sequence
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|rtx
name|last
decl_stmt|;
for|for
control|(
name|last
operator|=
name|first
init|;
name|last
operator|&&
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|;
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
control|)
empty_stmt|;
name|sequence_stack
operator|=
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|first_insn
argument_list|,
name|gen_rtx
argument_list|(
name|INSN_LIST
argument_list|,
name|VOIDmode
argument_list|,
name|last_insn
argument_list|,
name|sequence_stack
argument_list|)
argument_list|)
expr_stmt|;
name|first_insn
operator|=
name|first
expr_stmt|;
name|last_insn
operator|=
name|last
expr_stmt|;
block|}
end_function

begin_comment
comment|/* After emitting to a sequence, restore previous saved state.    The argument SAVED is no longer used.     To get the contents of the sequence just made,    you must call `gen_sequence' *before* calling here.  */
end_comment

begin_function
name|void
name|end_sequence
parameter_list|(
name|saved
parameter_list|)
name|rtx
name|saved
decl_stmt|;
block|{
name|first_insn
operator|=
name|XEXP
argument_list|(
name|sequence_stack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last_insn
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|sequence_stack
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sequence_stack
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|sequence_stack
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a SEQUENCE rtx containing the insns already emitted    to the current sequence.     This is how the gen_... function from a DEFINE_EXPAND    constructs the SEQUENCE that it returns.  */
end_comment

begin_function
name|rtx
name|gen_sequence
parameter_list|()
block|{
name|rtx
name|tem
decl_stmt|;
name|rtvec
name|newvec
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Count the insns in the chain.  */
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tem
operator|=
name|first_insn
init|;
name|tem
condition|;
name|tem
operator|=
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
control|)
name|len
operator|++
expr_stmt|;
comment|/* For an empty sequence... */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|gen_rtx
argument_list|(
name|SEQUENCE
argument_list|,
name|VOIDmode
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* If only one insn, return its pattern rather than a SEQUENCE.  */
if|if
condition|(
name|len
operator|==
literal|1
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|first_insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|first_insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|first_insn
argument_list|)
operator|==
name|CALL_INSN
operator|)
condition|)
return|return
name|PATTERN
argument_list|(
name|first_insn
argument_list|)
return|;
comment|/* Put them in a vector.  */
name|newvec
operator|=
name|rtvec_alloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tem
operator|=
name|first_insn
init|;
name|tem
condition|;
name|tem
operator|=
name|NEXT_INSN
argument_list|(
name|tem
argument_list|)
operator|,
name|i
operator|++
control|)
name|newvec
operator|->
name|elem
index|[
name|i
index|]
operator|.
name|rtx
operator|=
name|tem
expr_stmt|;
comment|/* Make a SEQUENCE from this vector.  */
return|return
name|gen_rtx
argument_list|(
name|SEQUENCE
argument_list|,
name|VOIDmode
argument_list|,
name|newvec
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up regno_reg_rtx, reg_rtx_no and regno_pointer_flag    according to the chain of insns starting with FIRST.     Also set cur_insn_uid to exceed the largest uid in that chain.     This is used when an inline function's rtl is saved    and passed to rest_of_compilation later.  */
end_comment

begin_function_decl
specifier|static
name|void
name|restore_reg_data_1
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|restore_reg_data
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|max_uid
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>=
name|max_uid
condition|)
name|max_uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|BARRIER
case|:
break|break;
case|case
name|JUMP_INSN
case|:
case|case
name|CALL_INSN
case|:
case|case
name|INSN
case|:
name|restore_reg_data_1
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Don't duplicate the uids already in use.  */
name|cur_insn_uid
operator|=
name|max_uid
operator|+
literal|1
expr_stmt|;
comment|/* If any regs are missing, make them up.  */
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|reg_rtx_no
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regno_reg_rtx
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|regno_reg_rtx
index|[
name|i
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|restore_reg_data_1
parameter_list|(
name|orig
parameter_list|)
name|rtx
name|orig
decl_stmt|;
block|{
specifier|register
name|rtx
name|x
init|=
name|orig
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|LABEL_REF
case|:
return|return;
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Make sure regno_pointer_flag and regno_reg_rtx are large 	     enough to have an element for this pseudo reg number.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|reg_rtx_no
condition|)
block|{
name|reg_rtx_no
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_rtx_no
operator|>=
name|regno_pointer_flag_length
condition|)
block|{
name|int
name|newlen
init|=
name|max
argument_list|(
name|regno_pointer_flag_length
operator|*
literal|2
argument_list|,
name|reg_rtx_no
operator|+
literal|30
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|new1
decl_stmt|;
name|char
modifier|*
name|new
init|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
name|newlen
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|new
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regno_pointer_flag
argument_list|,
name|new
argument_list|,
name|regno_pointer_flag_length
argument_list|)
expr_stmt|;
name|new1
operator|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
name|newlen
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|new1
argument_list|,
name|newlen
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regno_reg_rtx
argument_list|,
name|new1
argument_list|,
name|regno_pointer_flag_length
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|regno_pointer_flag
operator|=
name|new
expr_stmt|;
name|regno_reg_rtx
operator|=
name|new1
expr_stmt|;
name|regno_pointer_flag_length
operator|=
name|newlen
expr_stmt|;
block|}
name|reg_rtx_no
operator|++
expr_stmt|;
block|}
name|regno_reg_rtx
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|x
expr_stmt|;
block|}
return|return;
case|case
name|MEM
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|mark_reg_pointer
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|restore_reg_data_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now scan the subexpressions recursively.  */
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|restore_reg_data_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|restore_reg_data_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize data structures and variables in this file    before generating rtl for each function.    WRITE_SYMBOLS is nonzero if any kind of debugging info    is to be generated.  */
end_comment

begin_function
name|void
name|init_emit
parameter_list|(
name|write_symbols
parameter_list|)
name|int
name|write_symbols
decl_stmt|;
block|{
name|first_insn
operator|=
name|NULL
expr_stmt|;
name|last_insn
operator|=
name|NULL
expr_stmt|;
name|sequence_stack
operator|=
name|NULL
expr_stmt|;
name|cur_insn_uid
operator|=
literal|1
expr_stmt|;
name|reg_rtx_no
operator|=
name|FIRST_PSEUDO_REGISTER
expr_stmt|;
name|last_linenum
operator|=
literal|0
expr_stmt|;
name|last_filename
operator|=
literal|0
expr_stmt|;
name|first_label_num
operator|=
name|label_num
expr_stmt|;
name|no_line_numbers
operator|=
operator|!
name|write_symbols
expr_stmt|;
comment|/* Init the tables that describe all the pseudo regs.  */
name|regno_pointer_flag_length
operator|=
name|FIRST_PSEUDO_REGISTER
operator|+
literal|100
expr_stmt|;
name|regno_pointer_flag
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
name|regno_pointer_flag_length
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|regno_pointer_flag
argument_list|,
name|regno_pointer_flag_length
argument_list|)
expr_stmt|;
name|regno_reg_rtx
operator|=
operator|(
name|rtx
operator|*
operator|)
name|oballoc
argument_list|(
name|regno_pointer_flag_length
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|regno_reg_rtx
argument_list|,
name|regno_pointer_flag_length
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create some permanent unique rtl objects shared between all functions.  */
end_comment

begin_function
name|void
name|init_emit_once
parameter_list|()
block|{
comment|/* Create the unique rtx's for certain rtx codes and operand values.  */
name|pc_rtx
operator|=
name|gen_rtx
argument_list|(
name|PC
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
name|cc0_rtx
operator|=
name|gen_rtx
argument_list|(
name|CC0
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
comment|/* Don't use gen_rtx here since gen_rtx in this case      tries to use these variables.  */
name|const0_rtx
operator|=
name|rtx_alloc
argument_list|(
name|CONST_INT
argument_list|)
expr_stmt|;
name|INTVAL
argument_list|(
name|const0_rtx
argument_list|)
operator|=
literal|0
expr_stmt|;
name|const1_rtx
operator|=
name|rtx_alloc
argument_list|(
name|CONST_INT
argument_list|)
expr_stmt|;
name|INTVAL
argument_list|(
name|const1_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|fconst0_rtx
operator|=
name|rtx_alloc
argument_list|(
name|CONST_DOUBLE
argument_list|)
expr_stmt|;
name|dconst0_rtx
operator|=
name|rtx_alloc
argument_list|(
name|CONST_DOUBLE
argument_list|)
expr_stmt|;
block|{
name|union
name|real_extract
name|u
decl_stmt|;
ifdef|#
directive|ifdef
name|REAL_IS_NOT_DOUBLE
name|bzero
argument_list|(
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
name|u
operator|.
name|d
operator|=
name|REAL_VALUE_ATOF
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
else|#
directive|else
name|u
operator|.
name|d
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
operator|&
name|u
argument_list|,
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|fconst0_rtx
argument_list|)
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
name|CONST_DOUBLE_MEM
argument_list|(
name|fconst0_rtx
argument_list|)
operator|=
name|cc0_rtx
expr_stmt|;
name|PUT_MODE
argument_list|(
name|fconst0_rtx
argument_list|,
name|SFmode
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|u
argument_list|,
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|dconst0_rtx
argument_list|)
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
name|CONST_DOUBLE_MEM
argument_list|(
name|dconst0_rtx
argument_list|)
operator|=
name|cc0_rtx
expr_stmt|;
name|PUT_MODE
argument_list|(
name|dconst0_rtx
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
block|}
name|stack_pointer_rtx
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|frame_pointer_rtx
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STRUCT_VALUE
name|struct_value_rtx
operator|=
name|STRUCT_VALUE
expr_stmt|;
else|#
directive|else
name|struct_value_rtx
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|STRUCT_VALUE_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STRUCT_VALUE_INCOMING
name|struct_value_incoming_rtx
operator|=
name|STRUCT_VALUE_INCOMING
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|STRUCT_VALUE_INCOMING_REGNUM
name|struct_value_incoming_rtx
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|STRUCT_VALUE_INCOMING_REGNUM
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct_value_incoming_rtx
operator|=
name|struct_value_rtx
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|static_chain_rtx
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|STATIC_CHAIN_REGNUM
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATIC_CHAIN_INCOMING_REGNUM
if|if
condition|(
name|STATIC_CHAIN_INCOMING_REGNUM
operator|!=
name|STATIC_CHAIN_REGNUM
condition|)
name|static_chain_incoming_rtx
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|STATIC_CHAIN_INCOMING_REGNUM
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|static_chain_incoming_rtx
operator|=
name|static_chain_rtx
expr_stmt|;
if|if
condition|(
name|FRAME_POINTER_REGNUM
operator|==
name|ARG_POINTER_REGNUM
condition|)
name|arg_pointer_rtx
operator|=
name|frame_pointer_rtx
expr_stmt|;
else|else
name|arg_pointer_rtx
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|ARG_POINTER_REGNUM
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

