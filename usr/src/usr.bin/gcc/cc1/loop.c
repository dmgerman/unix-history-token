begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Move constant computations out of loops.    Copyright (C) 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This is the loop optimization pass of the compiler.    It finds invariant computations within loops and moves them    to the beginning of the loop.  Then it identifies basic and     general induction variables.  Strength reduction is applied to the general    induction variables, and induction variable elimination is applied to    the basic induction variables.     It also finds cases where    a register is set within the loop by zero-extending a narrower value    and changes these to zero the entire register once before the loop    and merely copy the low part within the loop.     Most of the complexity is in heuristics to decide when it is worth    while to do these things.  */
end_comment

begin_comment
comment|/* ??? verify_loop would run faster if we made one table    of the minimum and maximum luids from which each label is reached.    Also, it would be faster if loop_store_addrs were a hash table.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* Vector mapping INSN_UIDs to luids.    The luids are like uids but increase monononically always.    We use them to see whether a jump comes from outside a given loop.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|uid_luid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the luid of an insn.  */
end_comment

begin_define
define|#
directive|define
name|INSN_LUID
parameter_list|(
name|INSN
parameter_list|)
value|(uid_luid[INSN_UID (INSN)])
end_define

begin_comment
comment|/* 1 + largest uid of any insn.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 + luid of last insn.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_luid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if somewhere in the current loop    there is either a subroutine call,    or a store into a memory address that is not fixed,    or a store in a BLKmode memory operand,    or too many different fixed addresses stored in    to record them all in `loop_store_addrs'.     In any of these cases, no memory location can be regarded    as invariant.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unknown_address_altered
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if somewhere in the current loop there is a store    into a memory address that is not fixed but is known to be    part of an aggregate.     In this case, no memory reference in an aggregate may be    considered invariant.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unknown_aggregate_altered
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if somewhere in the current loop there is a store    into a memory address other than a fixed address not in an aggregate.     In this case, no memory reference in an aggregate at a varying address    may be considered invariant.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fixed_aggregate_altered
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if there is a subroutine call in the current loop.    (unknown_address_altered is also nonzero in this case.)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_has_call
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Added loop_continue which is the NOTE_INSN_LOOP_CONT of the    current loop.  A continue statement will generate a branch to    NEXT_INSN (loop_continue).  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|loop_continue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by register number, contains the number of times the reg    is set during the loop being scanned.    During code motion, -1 indicates a reg that has been made a candidate.    After code motion, regs moved have 0 (which is accurate now)    while the failed candidates have the original number of times set.     Therefore, at all times, 0 indicates an invariant register;    -1 a conditionally invariant one.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|n_times_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Original value of n_times_set; same except that this value    is not set to -1 for a reg whose sets have been made candidates    and not set to 0 for a reg that is moved.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|n_times_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index by register number, 1 indicates that the register    cannot be moved or strength reduced.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|may_not_optimize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means reg N has already been moved out of one loop.    This reduces the desire to move it out of another.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|moved_once
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of fixed memory addresses that are stored in this loop.    If there are too many to fit here,    we just turn on unknown_address_altered.  */
end_comment

begin_define
define|#
directive|define
name|NUM_STORES
value|10
end_define

begin_decl_stmt
specifier|static
name|rtx
name|loop_store_addrs
index|[
name|NUM_STORES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|loop_store_widths
index|[
name|NUM_STORES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of first available slot in above array.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_store_addrs_idx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of movable (i.e. invariant) instructions discovered in the loop.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_movables
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of memory write instructions discovered in the loop.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_mem_sets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of loops contained within the current one, including itself.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loops_enclosed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bound on pseudo register number before loop optimization.    A pseudo has valid regscan info if its number is< old_max_reg.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|old_max_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During the analysis of a loop, a chain of `struct movable's    is made to record all the movable insns found.    Then the entire chain can be scanned to decide which to move.  */
end_comment

begin_struct
struct|struct
name|movable
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* A movable insn */
name|rtx
name|set_src
decl_stmt|;
comment|/* The expression this reg is set from. 				   Either SET_SRC (body) or a REG_EQUAL.  */
name|int
name|consec
decl_stmt|;
comment|/* Number of consecutive following insns  				   that must be moved with this one.  */
name|int
name|regno
decl_stmt|;
comment|/* The register it sets */
name|short
name|lifetime
decl_stmt|;
comment|/* lifetime of that register; 				   may be adjusted when matching movables 				   that load the same value are found.  */
name|short
name|savings
decl_stmt|;
comment|/* Number of insns we can move for this reg, 				   including other movables that force this 				   or match this one.  */
name|unsigned
name|int
name|cond
range|:
literal|1
decl_stmt|;
comment|/* 1 if only conditionally movable */
name|unsigned
name|int
name|force
range|:
literal|1
decl_stmt|;
comment|/* 1 means MUST move this insn */
name|unsigned
name|int
name|global
range|:
literal|1
decl_stmt|;
comment|/* 1 means reg is live outside this loop */
comment|/* If PARTIAL is 1, GLOBAL means something different: 		   that the reg is live outside the range from where it is set 		   to the following label.  */
name|unsigned
name|int
name|done
range|:
literal|1
decl_stmt|;
comment|/* 1 inhibits further processing of this */
comment|/* 1 in PARTIAL means this reg is used for zero-extending.      In particular, moving it does not make it invariant.  */
name|unsigned
name|int
name|partial
range|:
literal|1
decl_stmt|;
name|enum
name|machine_mode
name|savemode
decl_stmt|;
comment|/* Nonzero means it is a mode for a low part 				   that we should avoid changing when clearing 				   the rest of the reg.  */
name|struct
name|movable
modifier|*
name|match
decl_stmt|;
comment|/* First entry for same value */
name|struct
name|movable
modifier|*
name|forces
decl_stmt|;
comment|/* An insn that must be moved if this is */
name|struct
name|movable
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|loop_dump_stream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_struct_decl
struct_decl|struct
name|induction
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|iv_class
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|rtx
name|loop_find_reg_equal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reg_in_basic_block_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|verify_loop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|invariant_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|consec_sets_invariant_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|can_jump_into_range_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|labels_in_range_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|count_loop_regs_set
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|note_addr_stored
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|loop_reg_used_before_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|constant_high_bytes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scan_loop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|replace_regs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|replace_call_address
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|skip_consec_insns
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ignore_some_movables
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|force_movables
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|combine_movables
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtx_equal_for_loop_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|move_movables
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|strength_reduce
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_mem_givs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_giv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_insn_forces
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|basic_induction_var
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|general_induction_var
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|consec_sets_giv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_dbra_loop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_iv_init_code
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|product_cheap_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_iv_inc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_eliminate_biv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|can_eliminate_biv_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eliminate_biv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|final_biv_value
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|last_use_this_basic_block
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Entry point of this file.  Perform loop optimization    on the current function.  F is the first insn of the function    and DUMPFILE is a stream for output of a trace of actions taken    (or 0 if none should be output).  */
end_comment

begin_function
name|void
name|loop_optimize
parameter_list|(
name|f
parameter_list|,
name|dumpfile
parameter_list|)
comment|/* f is the first instruction of a chain of insns for one function */
name|rtx
name|f
decl_stmt|;
name|FILE
modifier|*
name|dumpfile
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|end
decl_stmt|;
name|rtx
name|last_insn
decl_stmt|;
name|loop_dump_stream
operator|=
name|dumpfile
expr_stmt|;
name|init_recog
argument_list|()
expr_stmt|;
name|old_max_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|moved_once
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|old_max_reg
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|moved_once
argument_list|,
name|old_max_reg
argument_list|)
expr_stmt|;
comment|/* First find the last real insn, and count the number of insns,      and assign insns their luids.  */
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|i
condition|)
name|i
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|max_uid
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|uid_luid
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|uid_luid
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute the mapping from uids to luids.      LUIDs are numbers assigned to insns, like uids,      except that luids increase monotonically through the code.      Don't assign luids to line-number NOTEs, so that the distance in luids      between two insns is not affected by -g.  */
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|last_insn
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|=
operator|++
name|i
expr_stmt|;
else|else
comment|/* Give a line number note the same luid as preceding insn.  */
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|=
name|i
expr_stmt|;
block|}
name|max_luid
operator|=
name|i
expr_stmt|;
comment|/* Don't leave gaps in uid_luid for insns that have been      deleted.  It is possible that the first or last insn      using some register has been deleted by cross-jumping.      Make sure that uid_luid for that former insn's uid      points to the general area where that insn used to be.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_uid
condition|;
name|i
operator|++
control|)
block|{
name|uid_luid
index|[
literal|0
index|]
operator|=
name|uid_luid
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|uid_luid
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_uid
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|uid_luid
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|uid_luid
index|[
name|i
index|]
operator|=
name|uid_luid
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Find and process each loop.      We scan from the end, and process each loop when its start is seen,      so we process innermost loops first.  */
for|for
control|(
name|insn
operator|=
name|last_insn
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
block|{
comment|/* Make sure it really is a loop -- no jumps in from outside.  */
name|end
operator|=
name|verify_loop
argument_list|(
name|f
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|!=
literal|0
condition|)
comment|/* If so, optimize this loop.  */
name|scan_loop
argument_list|(
name|insn
argument_list|,
name|end
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\nLoop at %d ignored due to multiple entry points.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Optimize one loop whose start is LOOP_START and end is END.    LOOP_START is the NOTE_INSN_LOOP_BEG and END is the matching    NOTE_INSN_LOOP_END.  */
end_comment

begin_comment
comment|/* ??? can also move memory writes out of loop if destination    address is invariant? */
end_comment

begin_function
specifier|static
name|void
name|scan_loop
parameter_list|(
name|loop_start
parameter_list|,
name|end
parameter_list|,
name|nregs
parameter_list|)
name|rtx
name|loop_start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
name|p
init|=
name|NEXT_INSN
argument_list|(
name|loop_start
argument_list|)
decl_stmt|;
comment|/* 1 if we are scanning insns that could be executed zero times.  */
name|int
name|maybe_never
init|=
literal|0
decl_stmt|;
comment|/* 1 if we are scanning insns that might never be executed      due to a subroutine call which might exit before they are reached.  */
name|int
name|call_passed
init|=
literal|0
decl_stmt|;
comment|/* For a rotated loop that is entered near the bottom,      this is the label at the top.  Otherwise it is zero.  */
name|rtx
name|loop_top
init|=
literal|0
decl_stmt|;
comment|/* Jump insn that enters the loop, or 0 if control drops in.  */
name|rtx
name|loop_entry_jump
init|=
literal|0
decl_stmt|;
comment|/* Place in the loop where control enters.  */
name|rtx
name|scan_start
decl_stmt|;
comment|/* Number of insns in the loop.  */
name|int
name|insn_count
decl_stmt|;
name|int
name|tem
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* Chain describing insns movable in current loop.  */
name|struct
name|movable
modifier|*
name|movables
init|=
literal|0
decl_stmt|;
comment|/* Last element in `movables' -- so we can add elements at the end.  */
name|struct
name|movable
modifier|*
name|last_movable
init|=
literal|0
decl_stmt|;
comment|/* Ratio of extra register life span we can justify      for saving an instruction.  More if loop doesn't call subroutines      since in that case saving an insn makes more difference      and more registers are available.  */
name|int
name|threshold
init|=
name|loop_has_call
condition|?
literal|15
else|:
literal|30
decl_stmt|;
comment|/* Nonzero if the insn that jumps into the real loop      is not the very first thing after the loop-beginning note.  */
name|int
name|something_before_entry_jump
init|=
literal|0
decl_stmt|;
name|n_times_set
operator|=
operator|(
name|short
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|n_times_used
operator|=
operator|(
name|short
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|may_not_optimize
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
argument_list|)
expr_stmt|;
comment|/* Determine whether this loop starts with a jump down      to a test at the end.  */
while|while
condition|(
name|p
operator|!=
name|end
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
condition|)
name|something_before_entry_jump
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* "Loop" contains neither jumps nor labels;      it must have been a dummy.  Think no more about it.  */
if|if
condition|(
name|p
operator|==
name|end
condition|)
return|return;
name|scan_start
operator|=
name|p
expr_stmt|;
comment|/* If loop has a jump before the first label,      the true entry is the target of that jump.      Start scan from there.      But record in LOOP_TOP the place where the end-test jumps      back to so we can scan that after the end of the loop.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|loop_entry_jump
operator|=
name|p
expr_stmt|;
name|loop_top
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Loop entry will never be a conditional jump. 	 If we see one, this must not be a real loop. 	 Also, a return-insn isn't a jump to enter the loop.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|loop_top
argument_list|)
operator|!=
name|BARRIER
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
return|return;
comment|/* Get the label at which the loop is entered.  */
name|p
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check to see whether the jump actually 	 jumps out of the loop (meaning it's no loop). 	 This case can happen for things like 	 do {..} while (0).  */
if|if
condition|(
name|p
operator|==
literal|0
operator|||
name|INSN_LUID
argument_list|(
name|p
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|loop_start
argument_list|)
operator|||
name|INSN_LUID
argument_list|(
name|p
argument_list|)
operator|>=
name|INSN_LUID
argument_list|(
name|end
argument_list|)
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\nLoop from %d to %d is phony.\n\n"
argument_list|,
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|end
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find the first label after the entry-jump.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|loop_top
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
name|loop_top
operator|=
name|NEXT_INSN
argument_list|(
name|loop_top
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_top
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Maybe rearrange the loop to drop straight in 	 with a new test to jump around it entirely. 	 (The latter is considered outside the loop.) 	 If this is done, we no longer enter with a jump.  */
if|if
condition|(
operator|!
name|something_before_entry_jump
operator|&&
name|loop_skip_over
argument_list|(
name|loop_start
argument_list|,
name|end
argument_list|,
name|loop_entry_jump
argument_list|)
condition|)
block|{
name|scan_start
operator|=
name|loop_top
expr_stmt|;
name|loop_top
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* We really do enter with a jump; 	   scan the loop from the place where the jump jumps to.  */
name|scan_start
operator|=
name|p
expr_stmt|;
block|}
comment|/* Count number of times each reg is set during this loop.      Set may_not_optimize[I] if it is not safe to move out      the setting of register I.  */
name|bzero
argument_list|(
name|n_times_set
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|may_not_optimize
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|count_loop_regs_set
argument_list|(
name|loop_top
condition|?
name|loop_top
else|:
name|loop_start
argument_list|,
name|end
argument_list|,
name|may_not_optimize
argument_list|,
operator|&
name|insn_count
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|may_not_optimize
index|[
name|i
index|]
operator|=
literal|1
operator|,
name|n_times_set
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|n_times_set
argument_list|,
name|n_times_used
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\nLoop from %d to %d: %d real insns.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|end
argument_list|)
argument_list|,
name|insn_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_continue
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Continue at insn %d.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|loop_continue
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Scan through the loop finding insns that are safe to move.      In each such insn, store QImode as the mode, to mark it.      Then set n_times_set to -1 for the reg being set, so that      this reg will be considered invariant for subsequent insns.      We consider whether subsequent insns use the reg      in deciding whether it is worth actually moving.       MAYBE_NEVER is nonzero if we have passed a conditional jump insn      and therefore it is possible that the insns we are scanning      would never be executed.  At such times, we must make sure      that it is safe to execute the insn once instead of zero times.      When MAYBE_NEVER is 0, all insns will be executed at least once      so that is not a problem.  */
name|p
operator|=
name|scan_start
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* At end of a straight-in loop, we are done. 	 At end of a loop entered at the bottom, scan the top.  */
if|if
condition|(
name|p
operator|==
name|scan_start
condition|)
break|break;
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
if|if
condition|(
name|loop_top
operator|!=
literal|0
condition|)
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|loop_top
argument_list|)
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|p
operator|==
name|scan_start
condition|)
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|may_not_optimize
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
index|]
condition|)
block|{
name|int
name|tem1
init|=
literal|0
decl_stmt|;
comment|/* Don't try to optimize a register that was made 	     by loop-optimization for an inner loop. 	     We don't know its life-span, so we can't compute the benefit.  */
if|if
condition|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|old_max_reg
condition|)
empty_stmt|;
comment|/* IN order to move a register, we need to have one of three cases: 	     (1) it is used only in the same basic block as the set 	     (2) it is not a user variable. 	     (3) the set is guaranteed to be executed once the loop starts, 	         and the reg is not used until after that.  */
elseif|else
if|if
condition|(
operator|!
operator|(
operator|(
operator|!
name|maybe_never
operator|&&
operator|!
name|loop_reg_used_before_p
argument_list|(
name|p
argument_list|,
name|loop_start
argument_list|,
name|scan_start
argument_list|,
name|end
argument_list|)
operator|)
operator|||
operator|!
name|REG_USERVAR_P
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|||
name|reg_in_basic_block_p
argument_list|(
name|p
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|tem
operator|=
name|invariant_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|temp
operator|=
name|loop_find_reg_equal
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
operator|(
name|tem
operator|=
name|invariant_p
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|(
name|n_times_set
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
index|]
operator|==
literal|1
operator|||
operator|(
name|tem1
operator|=
name|consec_sets_invariant_p
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
name|n_times_set
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
index|]
argument_list|,
name|p
argument_list|)
operator|)
operator|)
comment|/* If the insn can cause a trap (such as divide by zero), 		      can't move it unless it's guaranteed to be executed 		      once loop is entered.  Even a function call might 		      prevent the trap insn from being reached 		      (since it might exit!)  */
operator|&&
operator|!
operator|(
operator|(
name|maybe_never
operator|||
name|call_passed
operator|)
operator|&&
operator|(
name|may_trap_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|||
operator|(
operator|(
name|temp
operator|=
name|loop_find_reg_equal
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
name|may_trap_p
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|count
decl_stmt|;
name|m
operator|=
operator|(
expr|struct
name|movable
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|movable
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|insn
operator|=
name|p
expr_stmt|;
name|temp
operator|=
name|loop_find_reg_equal
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|m
operator|->
name|set_src
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|m
operator|->
name|set_src
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|force
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|consec
operator|=
name|n_times_set
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
index|]
operator|-
literal|1
expr_stmt|;
name|m
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|forces
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|partial
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|savemode
operator|=
name|VOIDmode
expr_stmt|;
name|m
operator|->
name|regno
operator|=
name|regno
expr_stmt|;
comment|/* Set M->cond if either invariant_p or consec_sets_invariant_p 		 returned 2 (only conditionally invariant).  */
name|m
operator|->
name|cond
operator|=
operator|(
operator|(
name|tem
operator||
name|tem1
operator|)
operator|>
literal|1
operator|)
expr_stmt|;
name|m
operator|->
name|global
operator|=
operator|(
name|uid_luid
index|[
name|regno_last_uid
index|[
name|regno
index|]
index|]
operator|>
name|INSN_LUID
argument_list|(
name|end
argument_list|)
operator|||
name|uid_luid
index|[
name|regno_first_uid
index|[
name|regno
index|]
index|]
operator|<
name|INSN_LUID
argument_list|(
name|loop_start
argument_list|)
operator|)
expr_stmt|;
name|m
operator|->
name|match
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|lifetime
operator|=
operator|(
name|uid_luid
index|[
name|regno_last_uid
index|[
name|regno
index|]
index|]
operator|-
name|uid_luid
index|[
name|regno_first_uid
index|[
name|regno
index|]
index|]
operator|)
expr_stmt|;
name|m
operator|->
name|savings
operator|=
name|n_times_used
index|[
name|regno
index|]
expr_stmt|;
name|n_times_set
index|[
name|regno
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Add M to the end of the chain MOVABLES.  */
if|if
condition|(
name|movables
operator|==
literal|0
condition|)
name|movables
operator|=
name|m
expr_stmt|;
else|else
name|last_movable
operator|->
name|next
operator|=
name|m
expr_stmt|;
name|last_movable
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|consec
operator|>
literal|0
condition|)
block|{
comment|/* Skip this insn, not checking REG_LIBCALL notes.  */
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Skip the consecutive insns, if there are any.  */
name|p
operator|=
name|skip_consec_insns
argument_list|(
name|p
argument_list|,
name|m
operator|->
name|consec
argument_list|)
expr_stmt|;
comment|/* Back up, so the main loop will advance to the right place.  */
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this register is always set within a STRICT_LOW_PART 	     or set to zero, then its high bytes are constant. 	     So clear them outside the loop and within the loop 	     just load the low bytes. 	     We must check that the machine has an instruction to do so. 	     Also, if the value loaded into the register 	     depends on the same register, this cannot be done.  */
elseif|else
if|if
condition|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|const0_rtx
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
operator|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n_times_set
index|[
name|regno
index|]
operator|==
literal|2
condition|)
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
name|int
name|count
decl_stmt|;
name|m
operator|=
operator|(
expr|struct
name|movable
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|movable
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|insn
operator|=
name|p
expr_stmt|;
name|m
operator|->
name|force
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|consec
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|forces
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|partial
operator|=
literal|1
expr_stmt|;
comment|/* If the insn may not be executed on some cycles, 		     we can't clear the whole reg; clear just high part. 		     Not even if the reg is used only within this loop. 		     Consider this: 		     while (1) 		       while (s != t) { 		         if (foo ()) x = *s; 			 use (x); 		       } 		     Clearing x before the inner loop could clobber a value 		     being saved from the last time around the outer loop. 		     However, if the reg is not used outside this loop 		     and all uses of the register are in the same 		     basic block as the store, there is no problem.  */
name|m
operator|->
name|global
operator|=
operator|(
name|uid_luid
index|[
name|regno_last_uid
index|[
name|regno
index|]
index|]
operator|>
name|INSN_LUID
argument_list|(
name|end
argument_list|)
operator|||
name|uid_luid
index|[
name|regno_first_uid
index|[
name|regno
index|]
index|]
operator|<
name|INSN_LUID
argument_list|(
name|p
argument_list|)
operator|||
operator|(
name|labels_in_range_p
argument_list|(
name|p
argument_list|,
name|uid_luid
index|[
name|regno_first_uid
index|[
name|regno
index|]
index|]
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|maybe_never
operator|&&
name|m
operator|->
name|global
condition|)
name|m
operator|->
name|savemode
operator|=
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|m
operator|->
name|savemode
operator|=
name|VOIDmode
expr_stmt|;
name|m
operator|->
name|regno
operator|=
name|regno
expr_stmt|;
name|m
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|match
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|lifetime
operator|=
operator|(
name|uid_luid
index|[
name|regno_last_uid
index|[
name|regno
index|]
index|]
operator|-
name|uid_luid
index|[
name|regno_first_uid
index|[
name|regno
index|]
index|]
operator|)
expr_stmt|;
name|m
operator|->
name|savings
operator|=
literal|1
expr_stmt|;
name|n_times_set
index|[
name|regno
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Add M to the end of the chain MOVABLES.  */
if|if
condition|(
name|movables
operator|==
literal|0
condition|)
name|movables
operator|=
name|m
expr_stmt|;
else|else
name|last_movable
operator|->
name|next
operator|=
name|m
expr_stmt|;
name|last_movable
operator|=
name|m
expr_stmt|;
block|}
block|}
block|}
comment|/* Past a call insn, we get to insns which might not be executed 	 because the call might exit.  This matters for insns that trap.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|call_passed
operator|=
literal|1
expr_stmt|;
comment|/* Past a label or a jump, we get to insns for which we 	 can't count on whether or how many times they will be 	 executed during each iteration.  Therefore, we can 	 only move out sets of trivial variables 	 (those not used after the loop).  */
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|)
comment|/* If we enter the loop in the middle, and scan around 		  to the beginning, don't set maybe_never for that.  */
operator|&&
operator|!
operator|(
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
operator|==
name|end
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|simplejump_p
argument_list|(
name|p
argument_list|)
operator|)
condition|)
name|maybe_never
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If one movable subsumes another, ignore that other.  */
name|ignore_some_movables
argument_list|(
name|movables
argument_list|)
expr_stmt|;
comment|/* For each movable insn, see if the reg that it loads      leads when it dies right into another conditionally movable insn.      If so, record that the second insn "forces" the first one,      since the second can be moved only if the first is.  */
name|force_movables
argument_list|(
name|movables
argument_list|)
expr_stmt|;
comment|/* See if there are multiple movable insns that load the same value.      If there are, make all but the first point at the first one      through the `match' field, and add the priorities of them      all together as the priority of the first.  */
name|combine_movables
argument_list|(
name|movables
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
comment|/* Now consider each movable insn to decide whether it is worth moving.      Store 0 in n_times_set for each reg that is moved.  */
name|move_movables
argument_list|(
name|movables
argument_list|,
name|threshold
argument_list|,
name|insn_count
argument_list|,
name|loop_start
argument_list|,
name|end
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
comment|/* Now candidates that still have -1 are those not moved.      Change n_times_set to indicate that those are not actually invariant.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|n_times_set
index|[
name|i
index|]
operator|<
literal|0
condition|)
name|n_times_set
index|[
name|i
index|]
operator|=
name|n_times_used
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|flag_strength_reduce
condition|)
name|strength_reduce
argument_list|(
name|scan_start
argument_list|,
name|end
argument_list|,
name|loop_top
argument_list|,
name|insn_count
argument_list|,
name|loop_start
argument_list|,
name|end
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if all uses of REG    are between INSN and the end of the basic block.  */
end_comment

begin_function
specifier|static
name|int
name|reg_in_basic_block_p
parameter_list|(
name|insn
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|reg
decl_stmt|;
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|p
decl_stmt|;
if|if
condition|(
name|regno_first_uid
index|[
name|regno
index|]
operator|!=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Search this basic block for the already recorded last use of the reg.  */
for|for
control|(
name|p
operator|=
name|insn
init|;
name|p
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
break|break;
case|case
name|INSN
case|:
case|case
name|CALL_INSN
case|:
comment|/* Ordinary insn: if this is the last use, we win.  */
if|if
condition|(
name|regno_last_uid
index|[
name|regno
index|]
operator|==
name|INSN_UID
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|JUMP_INSN
case|:
comment|/* Jump insn: if this is the last use, we win.  */
if|if
condition|(
name|regno_last_uid
index|[
name|regno
index|]
operator|==
name|INSN_UID
argument_list|(
name|p
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Otherwise, it's the end of the basic block, so we lose.  */
return|return
literal|0
return|;
case|case
name|CODE_LABEL
case|:
case|case
name|BARRIER
case|:
comment|/* It's the end of the basic block, so we lose.  */
return|return
literal|0
return|;
block|}
block|}
comment|/* The "last use" doesn't follow the "first use"??  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Skip COUNT insns from INSN, counting library calls as 1 insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|skip_consec_insns
parameter_list|(
name|insn
parameter_list|,
name|count
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
block|{
name|rtx
name|i1
decl_stmt|,
name|temp
decl_stmt|;
comment|/* If first insn of gnulib call sequence, skip to end.  */
comment|/* Do this at start of loop, since INSN is guaranteed to  	     be an insn here.  */
if|if
condition|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
literal|0
argument_list|)
condition|)
name|insn
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
do|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
do|;
block|}
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Find a REG_EQUAL note in INSN but only if it is safe to use for our    purposes.  Those put in by CSE are not safe since they may fail to    use the registers that appear in the actual insn source.  */
end_comment

begin_function
specifier|static
name|rtx
name|loop_find_reg_equal
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
return|return
operator|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
literal|0
argument_list|)
condition|?
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
literal|0
argument_list|)
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Ignore any movable whose insn falls within a libcall    which is part of another movable.    We make use of the fact that the movable for the libcall value    was made later and so appears later on the chain.  */
end_comment

begin_function
specifier|static
name|void
name|ignore_some_movables
parameter_list|(
name|movables
parameter_list|)
name|struct
name|movable
modifier|*
name|movables
decl_stmt|;
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|,
modifier|*
name|m1
decl_stmt|;
for|for
control|(
name|m
operator|=
name|movables
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
comment|/* Is this a movable for the value of a libcall?  */
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|m
operator|->
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
block|{
comment|/* Find the beginning of that libcall.  */
name|rtx
name|first_insn
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Check for earlier movables inside that range, 	     and mark them invalid.  */
for|for
control|(
name|m1
operator|=
name|movables
init|;
name|m1
operator|!=
name|m
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
if|if
condition|(
name|INSN_LUID
argument_list|(
name|m1
operator|->
name|insn
argument_list|)
operator|>=
name|INSN_LUID
argument_list|(
name|first_insn
argument_list|)
operator|&&
name|INSN_LUID
argument_list|(
name|m1
operator|->
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|m
operator|->
name|insn
argument_list|)
condition|)
name|m1
operator|->
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* For each movable insn, see if the reg that it loads    leads when it dies right into another conditionally movable insn.    If so, record that the second insn "forces" the first one,    since the second can be moved only if the first is.  */
end_comment

begin_function
specifier|static
name|void
name|force_movables
parameter_list|(
name|movables
parameter_list|)
name|struct
name|movable
modifier|*
name|movables
decl_stmt|;
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|,
modifier|*
name|m1
decl_stmt|;
for|for
control|(
name|m1
operator|=
name|movables
init|;
name|m1
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
comment|/* Omit this if moving just the (SET (REG) 0) of a zero-extend.  */
if|if
condition|(
operator|!
name|m1
operator|->
name|partial
operator|&&
operator|!
name|m1
operator|->
name|done
condition|)
block|{
name|int
name|regno
init|=
name|m1
operator|->
name|regno
decl_stmt|;
for|for
control|(
name|m
operator|=
name|m1
operator|->
name|next
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
comment|/* ??? Could this be a bug?  What if CSE caused the 	     register of M1 to be used after this insn? 	     Since CSE does not update regno_last_uid, 	     this insn M->insn might not be where it dies. 	     But very likely this doesn't matter; what matters is 	     that M's reg is computed from M1's reg.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|m
operator|->
name|insn
argument_list|)
operator|==
name|regno_last_uid
index|[
name|regno
index|]
operator|&&
operator|!
name|m
operator|->
name|done
condition|)
break|break;
if|if
condition|(
name|m
operator|!=
literal|0
operator|&&
name|m
operator|->
name|set_src
operator|==
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|m1
operator|->
name|insn
argument_list|)
argument_list|)
condition|)
name|m
operator|=
literal|0
expr_stmt|;
comment|/* Increase the priority of the moving the first insn 	   since it permits the second to be moved as well.  */
if|if
condition|(
name|m
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|forces
operator|=
name|m1
expr_stmt|;
name|m1
operator|->
name|lifetime
operator|+=
name|m
operator|->
name|lifetime
expr_stmt|;
name|m1
operator|->
name|savings
operator|+=
name|m1
operator|->
name|savings
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find invariant expressions that are equal and can be combined into    one register.  */
end_comment

begin_function
specifier|static
name|void
name|combine_movables
parameter_list|(
name|movables
parameter_list|,
name|nregs
parameter_list|)
name|struct
name|movable
modifier|*
name|movables
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|matched_regs
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Regs that are set more than once are not allowed to match      or be matched.  I'm no longer sure why not.  */
comment|/* Perhaps testing m->consec_sets would be more appropriate here?  */
for|for
control|(
name|m
operator|=
name|movables
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|match
operator|==
literal|0
operator|&&
name|n_times_used
index|[
name|m
operator|->
name|regno
index|]
operator|==
literal|1
operator|&&
operator|!
name|m
operator|->
name|partial
condition|)
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m1
decl_stmt|;
name|int
name|regno
init|=
name|m
operator|->
name|regno
decl_stmt|;
name|bzero
argument_list|(
name|matched_regs
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|matched_regs
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|m1
operator|=
name|m
operator|->
name|next
init|;
name|m1
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
if|if
condition|(
name|m1
operator|->
name|match
operator|==
literal|0
operator|&&
name|n_times_used
index|[
name|m1
operator|->
name|regno
index|]
operator|==
literal|1
comment|/* A reg used outside the loop mustn't be eliminated.  */
operator|&&
operator|!
name|m1
operator|->
name|global
comment|/* A reg used for zero-extending mustn't be eliminated.  */
operator|&&
operator|!
name|m1
operator|->
name|partial
operator|&&
operator|(
name|matched_regs
index|[
name|m1
operator|->
name|regno
index|]
operator|||
operator|(
comment|/* Can't combine regs with different modes 		      even if loaded from the same constant.  */
operator|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|m1
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|)
comment|/* See if the source of M1 says it matches M.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|m1
operator|->
name|set_src
argument_list|)
operator|==
name|REG
operator|&&
name|matched_regs
index|[
name|REGNO
argument_list|(
name|m1
operator|->
name|set_src
argument_list|)
index|]
operator|)
operator|||
name|rtx_equal_for_loop_p
argument_list|(
name|m
operator|->
name|set_src
argument_list|,
name|m1
operator|->
name|set_src
argument_list|,
name|movables
argument_list|)
operator|||
operator|(
name|REG_NOTES
argument_list|(
name|m
operator|->
name|insn
argument_list|)
operator|&&
name|REG_NOTES
argument_list|(
name|m1
operator|->
name|insn
argument_list|)
operator|&&
name|REG_NOTE_KIND
argument_list|(
name|REG_NOTES
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|)
operator|==
name|REG_EQUIV
operator|&&
name|REG_NOTE_KIND
argument_list|(
name|REG_NOTES
argument_list|(
name|m1
operator|->
name|insn
argument_list|)
argument_list|)
operator|==
name|REG_EQUIV
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|REG_NOTES
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|REG_NOTES
argument_list|(
name|m1
operator|->
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|m
operator|->
name|lifetime
operator|+=
name|m1
operator|->
name|lifetime
expr_stmt|;
name|m
operator|->
name|savings
operator|+=
name|m1
operator|->
name|savings
expr_stmt|;
name|m1
operator|->
name|match
operator|=
name|m
expr_stmt|;
name|matched_regs
index|[
name|m1
operator|->
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Now combine the regs used for zero-extension.      This can be done for those not marked `global'      provided their lives don't overlap.  */
for|for
control|(
name|mode
operator|=
name|VOIDmode
init|;
operator|(
name|int
operator|)
name|mode
operator|<
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
condition|;
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|mode
operator|+
literal|1
operator|)
control|)
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m0
init|=
literal|0
decl_stmt|;
comment|/* Combine all the registers for extension from mode MODE. 	   Don't combine any that are used outside this loop.  */
for|for
control|(
name|m
operator|=
name|movables
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|partial
operator|&&
operator|!
name|m
operator|->
name|global
operator|&&
name|mode
operator|==
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
specifier|register
name|struct
name|movable
modifier|*
name|m1
decl_stmt|;
name|int
name|first
init|=
name|uid_luid
index|[
name|regno_first_uid
index|[
name|m
operator|->
name|regno
index|]
index|]
decl_stmt|;
name|int
name|last
init|=
name|uid_luid
index|[
name|regno_last_uid
index|[
name|m
operator|->
name|regno
index|]
index|]
decl_stmt|;
if|if
condition|(
name|m0
operator|==
literal|0
condition|)
block|{
comment|/* First one: don't check for overlap, just record it.  */
name|m0
operator|=
name|m
expr_stmt|;
continue|continue;
block|}
comment|/* Make sure they extend to the same mode. 		 (Almost always true.)  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|m0
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* We already have one: check for overlap with those 		 already combined together.  */
for|for
control|(
name|m1
operator|=
name|movables
init|;
name|m1
operator|!=
name|m
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
if|if
condition|(
name|m1
operator|==
name|m0
operator|||
operator|(
name|m1
operator|->
name|partial
operator|&&
name|m1
operator|->
name|match
operator|==
name|m0
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|uid_luid
index|[
name|regno_first_uid
index|[
name|m1
operator|->
name|regno
index|]
index|]
operator|>
name|last
operator|||
name|uid_luid
index|[
name|regno_last_uid
index|[
name|m1
operator|->
name|regno
index|]
index|]
operator|<
name|first
operator|)
condition|)
goto|goto
name|overlap
goto|;
comment|/* No overlap: we can combine this with the others.  */
name|m0
operator|->
name|lifetime
operator|+=
name|m
operator|->
name|lifetime
expr_stmt|;
name|m0
operator|->
name|savings
operator|+=
name|m
operator|->
name|savings
expr_stmt|;
name|m
operator|->
name|match
operator|=
name|m0
expr_stmt|;
name|overlap
label|:
empty_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if regs X and Y will become the same if moved.  */
end_comment

begin_function
specifier|static
name|int
name|regs_match_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|movables
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|struct
name|movable
modifier|*
name|movables
decl_stmt|;
block|{
name|int
name|xn
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|yn
init|=
name|REGNO
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|struct
name|movable
modifier|*
name|mx
decl_stmt|,
modifier|*
name|my
decl_stmt|;
for|for
control|(
name|mx
operator|=
name|movables
init|;
name|mx
condition|;
name|mx
operator|=
name|mx
operator|->
name|next
control|)
if|if
condition|(
name|mx
operator|->
name|regno
operator|==
name|xn
condition|)
break|break;
for|for
control|(
name|my
operator|=
name|movables
init|;
name|my
condition|;
name|my
operator|=
name|my
operator|->
name|next
control|)
if|if
condition|(
name|my
operator|->
name|regno
operator|==
name|yn
condition|)
break|break;
return|return
operator|(
name|mx
operator|&&
name|my
operator|&&
operator|(
operator|(
name|mx
operator|->
name|match
operator|==
name|my
operator|->
name|match
operator|&&
name|mx
operator|->
name|match
operator|!=
literal|0
operator|)
operator|||
name|mx
operator|->
name|match
operator|==
name|my
operator|||
name|mx
operator|==
name|my
operator|->
name|match
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X and Y are identical-looking rtx's.    This is the Lisp function EQUAL for rtx arguments.  */
end_comment

begin_function
specifier|static
name|int
name|rtx_equal_for_loop_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|movables
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|struct
name|movable
modifier|*
name|movables
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Rtx's of different codes cannot be equal.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.      (REG:SI x) and (REG:HI x) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* These three types of rtx's can be compared nonrecursively.  */
comment|/* Until the end of reload,      don't consider the a reference to the return register of the current      function the same as the return from a called function.  This eases      the job of function integration.  Once the distinction no longer      matters, the insn will be deleted.  */
if|if
condition|(
name|code
operator|==
name|REG
condition|)
return|return
operator|(
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
operator|&&
name|REG_FUNCTION_VALUE_P
argument_list|(
name|x
argument_list|)
operator|==
name|REG_FUNCTION_VALUE_P
argument_list|(
name|y
argument_list|)
operator|)
operator|||
name|regs_match_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|movables
argument_list|)
operator|)
return|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
condition|)
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'E'
case|:
comment|/* Two vectors must have the same length.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* And the corresponding elements must match.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_equal_for_loop_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|movables
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|rtx_equal_for_loop_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|,
name|movables
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'u'
case|:
comment|/* These are just backpointers, so they don't matter.  */
break|break;
case|case
literal|'0'
case|:
break|break;
comment|/* It is believed that rtx's at this level will never 	     contain anything but integers and other rtx's, 	     except for within LABEL_REFs and SYMBOL_REFs.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan MOVABLES, and move the insns that deserve to be moved.    If two matching movables are combined, replace one reg with the    other throughout.  */
end_comment

begin_function
specifier|static
name|void
name|move_movables
parameter_list|(
name|movables
parameter_list|,
name|threshold
parameter_list|,
name|insn_count
parameter_list|,
name|loop_start
parameter_list|,
name|end
parameter_list|,
name|nregs
parameter_list|)
name|struct
name|movable
modifier|*
name|movables
decl_stmt|;
name|int
name|threshold
decl_stmt|;
name|int
name|insn_count
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|;
name|rtx
name|end
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
name|rtx
name|new_start
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|movable
modifier|*
name|m
decl_stmt|;
specifier|register
name|rtx
name|p
decl_stmt|;
comment|/* Map of pseudo-register replacements to handle combining      when we move several insns that load the same value      into different pseudo-registers.  */
name|rtx
modifier|*
name|reg_map
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|already_moved
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|already_moved
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_map
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|num_movables
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|movables
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
comment|/* Describe this movable insn.  */
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Insn %d: regno %d (life %d), "
argument_list|,
name|INSN_UID
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|,
name|m
operator|->
name|regno
argument_list|,
name|m
operator|->
name|lifetime
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|consec
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"consec %d, "
argument_list|,
name|m
operator|->
name|consec
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|cond
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"cond "
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|force
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"force "
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|global
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"global "
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|done
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"done "
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|match
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"matches %d "
argument_list|,
name|INSN_UID
argument_list|(
name|m
operator|->
name|match
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|forces
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"forces %d "
argument_list|,
name|INSN_UID
argument_list|(
name|m
operator|->
name|forces
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Count movables.  Value used in heuristics in strength_reduce.  */
name|num_movables
operator|++
expr_stmt|;
comment|/* Ignore the insn if it's already done (it matched something else). 	 Otherwise, see if it is now safe to move.  */
if|if
condition|(
operator|!
name|m
operator|->
name|done
operator|&&
operator|(
operator|!
name|m
operator|->
name|cond
operator|||
operator|(
literal|1
operator|==
name|invariant_p
argument_list|(
name|m
operator|->
name|set_src
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|consec
operator|==
literal|0
operator|||
literal|1
operator|==
name|consec_sets_invariant_p
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|,
name|m
operator|->
name|consec
operator|+
literal|1
argument_list|,
name|m
operator|->
name|insn
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|!
name|m
operator|->
name|forces
operator|||
name|m
operator|->
name|forces
operator|->
name|done
operator|)
condition|)
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|rtx
name|p
decl_stmt|;
name|int
name|savings
init|=
name|m
operator|->
name|savings
decl_stmt|;
comment|/* We have an insn that is safe to move. 	     Compute its desirability.  */
name|p
operator|=
name|m
operator|->
name|insn
expr_stmt|;
name|regno
operator|=
name|m
operator|->
name|regno
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"savings %d "
argument_list|,
name|savings
argument_list|)
expr_stmt|;
if|if
condition|(
name|moved_once
index|[
name|regno
index|]
condition|)
block|{
name|insn_count
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"halved since already moved "
argument_list|)
expr_stmt|;
block|}
comment|/* An insn MUST be moved if we already moved something else 	     which is safe only if this one is moved too: that is, 	     if already_moved[REGNO] is nonzero.  */
comment|/* An insn is desirable to move if the new lifetime of the 	     register is no more than THRESHOLD times the old lifetime. 	     If it's not desirable, it means the loop is so big 	     that moving won't speed things up much, 	     and it is liable to make register usage worse.  */
comment|/* It is also desirable to move if it can be moved at no 	     extra cost because something else was already moved.  */
if|if
condition|(
name|already_moved
index|[
name|regno
index|]
operator|||
operator|(
name|threshold
operator|*
name|savings
operator|*
name|m
operator|->
name|lifetime
operator|)
operator|>=
name|insn_count
operator|||
operator|(
name|m
operator|->
name|forces
operator|&&
name|m
operator|->
name|forces
operator|->
name|done
operator|&&
name|n_times_used
index|[
name|m
operator|->
name|forces
operator|->
name|regno
index|]
operator|==
literal|1
operator|)
condition|)
block|{
name|int
name|count
decl_stmt|;
specifier|register
name|struct
name|movable
modifier|*
name|m1
decl_stmt|;
name|rtx
name|first
decl_stmt|;
comment|/* Now move the insns that set the reg.  */
for|for
control|(
name|count
operator|=
name|m
operator|->
name|consec
init|;
name|count
operator|>=
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|rtx
name|i1
decl_stmt|,
name|temp
decl_stmt|;
comment|/* If first insn of gnulib call sequence, skip to end.  */
comment|/* Do this at start of loop, since p is guaranteed to  		     be an insn here.  */
if|if
condition|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
literal|0
argument_list|)
condition|)
name|p
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If last insn of gnulib call sequence, move all 		     insns except the last before the loop.  The last insn is 		     handled in the normal manner.  */
if|if
condition|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_RETVAL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rtx
name|fn_address
init|=
literal|0
decl_stmt|;
name|rtx
name|fn_reg
init|=
literal|0
decl_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
init|;
name|temp
operator|!=
name|p
condition|;
name|temp
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
control|)
block|{
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|temp
argument_list|)
decl_stmt|;
name|rtx
name|n
decl_stmt|;
comment|/* Extract the function address from the insn 			     that loads it into a register. 			     If this insn was cse'd, we get incorrect code. 			     So delete it and stick the fn address right 			     into the call insn.  Since the moved insns 			     won't be cse'd, that does no harm.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|n
operator|=
name|find_reg_note
argument_list|(
name|temp
argument_list|,
name|REG_EQUIV
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|fn_reg
operator|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|fn_reg
argument_list|)
operator|!=
name|REG
condition|)
name|fn_reg
operator|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|fn_address
operator|=
name|XEXP
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* We have the call insn. 			     Substitute the fn address for the reg 			     that we believe this insn will use.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|fn_address
operator|!=
literal|0
condition|)
name|replace_call_address
argument_list|(
name|body
argument_list|,
name|fn_reg
argument_list|,
name|fn_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|i1
operator|=
name|emit_call_insn_before
argument_list|(
name|body
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
else|else
name|i1
operator|=
name|emit_insn_before
argument_list|(
name|body
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|0
condition|)
name|first
operator|=
name|i1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|->
name|savemode
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* P sets REG to zero; but we should clear only the bits 			 that are not covered by the mode m->savemode.  */
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|i1
operator|=
name|emit_insn_before
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|AND
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|(
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|m
operator|->
name|savemode
argument_list|)
operator|)
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|i1
operator|=
name|emit_call_insn_before
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
else|else
name|i1
operator|=
name|emit_insn_before
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_start
operator|==
literal|0
condition|)
name|new_start
operator|=
name|i1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" moved to %d"
argument_list|,
name|INSN_UID
argument_list|(
name|i1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the moved, invariant reg as being equivalent to 		     its constant value.  */
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|m
operator|->
name|partial
comment|/* But not if it's a zero-extend clr. */
operator|&&
operator|!
name|m
operator|->
name|global
comment|/* and not if used outside the loop 					(since it might get set outside).  */
operator|&&
name|CONSTANT_P
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUIV
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|i1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If library call, now fix the REG_NOTES that contain 		     insn pointers, namely REG_LIBCALL on FIRST 		     and REG_RETVAL on I1.  */
if|if
condition|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|i1
argument_list|,
name|REG_RETVAL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|=
name|first
expr_stmt|;
name|temp
operator|=
name|find_reg_note
argument_list|(
name|first
argument_list|,
name|REG_LIBCALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|=
name|i1
expr_stmt|;
block|}
name|delete_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
do|do
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
do|while
condition|(
name|p
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
do|;
block|}
comment|/* The more regs we move, the less we like moving them.  */
name|threshold
operator|-=
literal|3
expr_stmt|;
comment|/* Any other movable that loads the same register 		 MUST be moved.  */
name|already_moved
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* This reg has been moved out of one loop.  */
name|moved_once
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* The reg set here is now invariant.  */
if|if
condition|(
operator|!
name|m
operator|->
name|partial
condition|)
name|n_times_set
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|done
operator|=
literal|1
expr_stmt|;
comment|/* Change the length-of-life info for the register 		 to say it lives at least the full length of this loop. 		 This will help guide optimizations in outer loops.  */
if|if
condition|(
name|uid_luid
index|[
name|regno_first_uid
index|[
name|regno
index|]
index|]
operator|>
name|INSN_LUID
argument_list|(
name|loop_start
argument_list|)
condition|)
comment|/* This is the old insn before all the moved insns. 		   We can't use the moved insn because it is out of range 		   in uid_luid.  Only the old insns have luids.  */
name|regno_first_uid
index|[
name|regno
index|]
operator|=
name|INSN_UID
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid_luid
index|[
name|regno_last_uid
index|[
name|regno
index|]
index|]
operator|<
name|INSN_LUID
argument_list|(
name|end
argument_list|)
condition|)
name|regno_last_uid
index|[
name|regno
index|]
operator|=
name|INSN_UID
argument_list|(
name|end
argument_list|)
expr_stmt|;
comment|/* Combine with this moved insn any other matching movables.  */
for|for
control|(
name|m1
operator|=
name|m
operator|->
name|next
init|;
name|m1
condition|;
name|m1
operator|=
name|m1
operator|->
name|next
control|)
if|if
condition|(
name|m1
operator|->
name|match
operator|==
name|m
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
comment|/* Schedule the reg loaded by M1 		       for replacement so that shares the reg of M.  */
name|reg_map
index|[
name|m1
operator|->
name|regno
index|]
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|m
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get rid of the matching insn 		       and prevent further processing of it.  */
name|m1
operator|->
name|done
operator|=
literal|1
expr_stmt|;
comment|/* if library call, delete all insn except last, which 		       is deleted below */
if|if
condition|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|m1
operator|->
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
for|for
control|(
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
init|;
name|temp
operator|!=
name|m1
operator|->
name|insn
condition|;
name|temp
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
control|)
name|delete_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|delete_insn
argument_list|(
name|m1
operator|->
name|insn
argument_list|)
expr_stmt|;
comment|/* Any other movable that loads the same register 		       MUST be moved.  */
name|already_moved
index|[
name|m1
operator|->
name|regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* The reg merged here is now invariant, 		       if the reg it matches is invariant.  */
if|if
condition|(
operator|!
name|m
operator|->
name|partial
condition|)
name|n_times_set
index|[
name|m1
operator|->
name|regno
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"not desirable"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|loop_dump_stream
operator|&&
operator|!
name|m
operator|->
name|match
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"not safe"
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_start
operator|==
literal|0
condition|)
name|new_start
operator|=
name|loop_start
expr_stmt|;
comment|/* Go through all the instructions in the loop, making      all the register substitutions scheduled in REG_MAP.  */
for|for
control|(
name|p
operator|=
name|new_start
init|;
name|p
operator|!=
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|tail
decl_stmt|;
name|replace_regs
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
comment|/* Subsitute registers in the equivalent expression also.  */
for|for
control|(
name|tail
operator|=
name|REG_NOTES
argument_list|(
name|p
argument_list|)
init|;
name|tail
condition|;
name|tail
operator|=
name|XEXP
argument_list|(
name|tail
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|tail
argument_list|)
operator|==
name|REG_EQUAL
operator|||
name|REG_NOTE_KIND
argument_list|(
name|tail
argument_list|)
operator|==
name|REG_EQUIV
condition|)
name|replace_regs
argument_list|(
name|XEXP
argument_list|(
name|tail
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Optionally change a loop which enters just before the endtest    to one which falls straight in    after skipping around the entire loop if the endtest would drop out.    Returns 1 if the change was made, 0 if the loop was not really suitable.  */
end_comment

begin_function
name|int
name|loop_skip_over
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|,
name|loop_entry_jump
parameter_list|)
name|rtx
name|start
decl_stmt|;
name|rtx
name|end
decl_stmt|;
name|rtx
name|loop_entry_jump
decl_stmt|;
block|{
name|rtx
name|entry_insn
decl_stmt|;
name|rtx
name|endtest
decl_stmt|;
name|rtx
name|endtestjump
decl_stmt|;
specifier|register
name|rtx
name|p
init|=
name|JUMP_LABEL
argument_list|(
name|loop_entry_jump
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|CALL_INSN
condition|)
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|entry_insn
operator|=
name|p
expr_stmt|;
comment|/* Skip any ordinary arithmetic insns to find the compare.  */
for|for
control|(
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
condition|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|INSN
operator|||
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|p
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|INSN
condition|)
return|return
literal|0
return|;
name|endtest
operator|=
name|p
expr_stmt|;
name|endtestjump
operator|=
name|next_real_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Check that (1) we have reached a compare insn and (2)      the insn (presumably a jump) following that compare      is the last in the loop and jumps back to the loop beginning.  */
if|if
condition|(
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|endtest
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
name|endtestjump
operator|==
name|prev_real_insn
argument_list|(
name|end
argument_list|)
operator|&&
name|prev_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|endtestjump
argument_list|)
argument_list|)
operator|==
name|loop_entry_jump
condition|)
block|{
name|rtx
name|newlab
decl_stmt|;
comment|/* This is the jump that we insert.  */
name|rtx
name|new_jump
decl_stmt|;
comment|/* Duplicate the ordinary arith insns before the compare.  */
for|for
control|(
name|p
operator|=
name|entry_insn
init|;
name|p
operator|!=
name|endtest
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
condition|)
block|{
name|rtx
name|new
init|=
name|emit_insn_before
argument_list|(
name|copy_rtx
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
name|start
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_NOTES
argument_list|(
name|p
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|new
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|REG_NOTES
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Ok, duplicate that test before start of loop.  */
name|emit_insn_before
argument_list|(
name|copy_rtx
argument_list|(
name|PATTERN
argument_list|(
name|endtest
argument_list|)
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/* Make a new entry-jump (before the original one) 	 whose condition is opposite to the loop-around endtest 	 and which jumps around the loop (to just after the ending NOTE).  */
name|newlab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label_after
argument_list|(
name|newlab
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|emit_jump_insn_before
argument_list|(
name|copy_rtx
argument_list|(
name|PATTERN
argument_list|(
name|endtestjump
argument_list|)
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|new_jump
operator|=
name|PREV_INSN
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|new_jump
argument_list|)
operator|=
name|JUMP_LABEL
argument_list|(
name|endtestjump
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|endtestjump
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|invert_jump
argument_list|(
name|new_jump
argument_list|,
name|newlab
argument_list|)
expr_stmt|;
comment|/* Delete the original entry-jump.  */
name|delete_insn
argument_list|(
name|loop_entry_jump
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Throughout the rtx X, replace many registers according to REG_MAP.    Return the replacement for X (which may be X with altered contents).    REG_MAP[R] is the replacement for register R, or 0 for don't replace.    NREGS is the length of REG_MAP; regs>= NREGS are not mapped.  */
end_comment

begin_function
specifier|static
name|rtx
name|replace_regs
parameter_list|(
name|x
parameter_list|,
name|reg_map
parameter_list|,
name|nregs
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|reg_map
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
name|x
return|;
case|case
name|REG
case|:
comment|/* Verify that the register has an entry before trying to access it.  */
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|nregs
operator|&&
name|reg_map
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|!=
literal|0
condition|)
return|return
name|reg_map
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
return|;
return|return
name|x
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|replace_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|replace_regs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan X and replace the address of any MEM in it with ADDR.    REG is the address that MEM should have before the replacement.  */
end_comment

begin_function
specifier|static
name|void
name|replace_call_address
parameter_list|(
name|x
parameter_list|,
name|reg
parameter_list|,
name|addr
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|reg
decl_stmt|,
name|addr
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|REG
case|:
return|return;
case|case
name|SET
case|:
comment|/* Short cut for very common case.  */
name|replace_call_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return;
case|case
name|CALL
case|:
comment|/* Short cut for very common case.  */
name|replace_call_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return;
case|case
name|MEM
case|:
comment|/* If this MEM uses a reg other than the one we expected, 	 something is wrong.  */
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
name|reg
condition|)
name|abort
argument_list|()
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|addr
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|replace_call_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|replace_call_address
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of memory refs to addresses that vary    in the rtx X.  */
end_comment

begin_function
specifier|static
name|int
name|count_nonfixed_reads
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|value
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|REG
case|:
return|return
literal|0
return|;
case|case
name|MEM
case|:
return|return
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|+
name|count_nonfixed_reads
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
name|value
operator|=
literal|0
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|value
operator|+=
name|count_nonfixed_reads
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|value
operator|+=
name|count_nonfixed_reads
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* P is an instruction that sets a register to the result of a ZERO_EXTEND.    Replace it with an instruction to load just the low bytes    if the machine supports such an instruction,    and insert above LOOP_START an instruction to clear the register.  */
end_comment

begin_comment
unit|static void constant_high_bytes (p, loop_start)      rtx p, loop_start; {   register rtx new;   register int insn_code_number;
comment|/* Try to change (SET (REG ...) (ZERO_EXTEND (..:B ...)))      to (SET (STRICT_LOW_PART (SUBREG:B (REG...))) ...).  */
end_comment

begin_comment
unit|new = gen_rtx (SET, VOIDmode, 		 gen_rtx (STRICT_LOW_PART, VOIDmode, 			  gen_rtx (SUBREG, GET_MODE (XEXP (SET_SRC (PATTERN (p)), 0)), 				   SET_DEST (PATTERN (p)), 				   0)), 		 XEXP (SET_SRC (PATTERN (p)), 0));   insn_code_number = recog (new, p);    if (insn_code_number)     {       register int i;
comment|/* Clear destination register before the loop.  */
end_comment

begin_comment
unit|emit_insn_before (gen_rtx (SET, VOIDmode, 				 SET_DEST (PATTERN (p)), 				 const0_rtx), 			loop_start);
comment|/* Inside the loop, just load the low part.  */
end_comment

begin_endif
unit|PATTERN (p) = new;     } }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Verify that the ostensible loop starting at START    really is a loop: nothing jumps into it from outside.    Return the marker for the end of the loop, or zero if not a real loop.     Also set the variables `unknown_*_altered' and `loop_has_call',    and fill in the array `loop_store_addrs'.  */
end_comment

begin_function
specifier|static
name|rtx
name|verify_loop
parameter_list|(
name|f
parameter_list|,
name|start
parameter_list|)
name|rtx
name|f
decl_stmt|,
name|start
decl_stmt|;
block|{
specifier|register
name|int
name|level
init|=
literal|1
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|,
name|end
decl_stmt|;
comment|/* First find the LOOP_END that matches.      Also check each insn for storing in memory and record where.  */
name|unknown_address_altered
operator|=
literal|0
expr_stmt|;
name|unknown_aggregate_altered
operator|=
literal|0
expr_stmt|;
name|fixed_aggregate_altered
operator|=
literal|0
expr_stmt|;
name|loop_has_call
operator|=
literal|0
expr_stmt|;
name|loop_store_addrs_idx
operator|=
literal|0
expr_stmt|;
name|num_mem_sets
operator|=
literal|0
expr_stmt|;
name|loops_enclosed
operator|=
literal|1
expr_stmt|;
name|loop_continue
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|start
argument_list|)
init|;
name|level
operator|>
literal|0
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
comment|/* Parse errors can cause a loop-beg with no loop-end.  */
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
block|{
operator|++
name|level
expr_stmt|;
comment|/* Count number of loops contained in this one.  */
name|loops_enclosed
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
block|{
operator|--
name|level
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
name|end
operator|=
name|insn
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_CONT
condition|)
block|{
if|if
condition|(
name|level
operator|==
literal|1
condition|)
name|loop_continue
operator|=
name|insn
expr_stmt|;
block|}
comment|/* Don't optimize loops containing setjmps. 	     On some machines, longjmp does not restore the reg 	     values as of the time of the setjmp.  */
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|unknown_address_altered
operator|=
literal|1
expr_stmt|;
name|loop_has_call
operator|=
literal|1
expr_stmt|;
block|}
comment|/* ???       else if (! unknown_address_altered) */
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|note_addr_stored
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now scan all jumps in the function and see if any of them can      reach a label within the range of the loop.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
comment|/* Don't get fooled by jumps inserted by loop-optimize. 	   They don't have valid LUIDs, and they never jump into loops.  */
operator|&&
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|<
name|max_uid
operator|&&
operator|(
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|<
name|INSN_LUID
argument_list|(
name|start
argument_list|)
operator|||
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|end
argument_list|)
operator|)
comment|/* We have a jump that is outside the loop. 	   Does it jump into the loop?  */
operator|&&
name|can_jump_into_range_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_LUID
argument_list|(
name|start
argument_list|)
argument_list|,
name|INSN_LUID
argument_list|(
name|end
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|#
directive|if
literal|0
comment|/* Now scan all labels between them and check for any jumps from outside.      This uses the ref-chains set up by find_basic_blocks.      This code is not used because it's more convenient for other reasons      to do the loop optimization before find_basic_blocks.  */
block|for (insn = start; insn != end; insn = NEXT_INSN (insn))     if (GET_CODE (insn) == CODE_LABEL)       { 	register rtx y; 	for (y = LABEL_REFS (insn); y != insn; y = LABEL_NEXTREF (y)) 	  if (INSN_LUID (CONTAINING_INSN (y))< INSN_LUID (start) 	      || INSN_LUID (CONTAINING_INSN (y))> INSN_LUID (end)) 	    return 0;       }
endif|#
directive|endif
return|return
name|end
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if somewhere in X is a LABEL_REF to a label    located between BEG and END.  */
end_comment

begin_function
specifier|static
name|int
name|can_jump_into_range_p
parameter_list|(
name|x
parameter_list|,
name|beg
parameter_list|,
name|end
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|beg
decl_stmt|,
name|end
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
block|{
specifier|register
name|int
name|luid
init|=
name|INSN_LUID
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|luid
operator|>
name|beg
operator|&&
name|luid
operator|<
name|end
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|can_jump_into_range_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|beg
argument_list|,
name|end
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|can_jump_into_range_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|beg
argument_list|,
name|end
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if there is a label in the range from    insn INSN to the insn whose luid is END.  */
end_comment

begin_function
specifier|static
name|int
name|labels_in_range_p
parameter_list|(
name|insn
parameter_list|,
name|end
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|end
decl_stmt|;
block|{
while|while
condition|(
name|insn
operator|&&
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|<=
name|end
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|0
return|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Record that a memory reference X is being set.  */
end_comment

begin_function
specifier|static
name|void
name|note_addr_stored
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return;
comment|/* Count number of memory writes.      This affects heuristics in strength_reduce.  */
name|num_mem_sets
operator|++
expr_stmt|;
if|if
condition|(
name|unknown_address_altered
condition|)
return|return;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
condition|)
name|unknown_address_altered
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_addr_varies_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|unknown_aggregate_altered
operator|=
literal|1
expr_stmt|;
else|else
name|unknown_address_altered
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
condition|)
name|fixed_aggregate_altered
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop_store_addrs_idx
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|loop_store_addrs
index|[
name|i
index|]
argument_list|,
name|addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|loop_store_widths
index|[
name|i
index|]
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|loop_store_widths
index|[
name|i
index|]
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|NUM_STORES
condition|)
name|unknown_address_altered
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|loop_store_addrs_idx
condition|)
block|{
name|loop_store_widths
index|[
name|i
index|]
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|loop_store_addrs
index|[
name|loop_store_addrs_idx
operator|++
index|]
operator|=
name|addr
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if the rtx X is invariant over the current loop.     The value is 2 if we refer to something only conditionally invariant.     If `unknown_address_altered' is nonzero, no memory ref is invariant.    Otherwise if `unknown_aggregate_altered' is nonzero,    a memory ref is invariant if it is not part of an aggregate    and its address is fixed and not in `loop_store_addrs'.    Otherwise if `fixed_aggregate_altered' is nonzero,    a memory ref is invariant    if its address is fixed and not in `loop_store_addrs'.    Otherwise, a memory ref is invariant if its address is fixed and not in    `loop_store_addrs' or if it is not an aggregate.  */
end_comment

begin_function
specifier|static
name|int
name|invariant_p
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|conditional
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
return|return
literal|1
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
literal|0
return|;
case|case
name|REG
case|:
comment|/* We used to check RTX_UNCHANGING_P (x) here, but that is invalid 	 since the reg might be set by initialization within the loop.  */
if|if
condition|(
name|x
operator|==
name|frame_pointer_rtx
operator|||
name|x
operator|==
name|arg_pointer_rtx
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|n_times_set
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|==
operator|-
literal|1
condition|)
return|return
literal|2
return|;
return|return
name|n_times_set
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|==
literal|0
return|;
case|case
name|MEM
case|:
comment|/* Constants in the constant pool are invariant. 	 ?? Really we should detect any constant address in the 	 text section.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* A store in a varying-address scalar (or a subroutine call) 	 could clobber anything in memory.  */
if|if
condition|(
name|unknown_address_altered
condition|)
return|return
literal|0
return|;
comment|/* Don't mess with volatile memory references.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
if|#
directive|if
literal|0
comment|/* If it's declared read-only, it is invariant 	 if its address is invariant.  */
block|if (RTX_UNCHANGING_P (x)) 	return invariant_p (XEXP (x, 0));
endif|#
directive|endif
comment|/* A store in a varying-address aggregate component 	 could clobber anything except a scalar with a fixed address.  */
if|if
condition|(
name|unknown_aggregate_altered
operator|&&
operator|(
operator|(
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|)
operator|||
name|rtx_addr_varies_p
argument_list|(
name|x
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* A store in a fixed-address aggregate component 	 could clobber anything whose address is not fixed, 	 even an aggregate component.  */
if|if
condition|(
name|fixed_aggregate_altered
operator|&&
name|rtx_addr_varies_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Any store could clobber a varying-address scalar.  */
if|if
condition|(
name|loop_store_addrs_idx
operator|&&
operator|!
operator|(
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|)
operator|&&
name|rtx_addr_varies_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* A store in a fixed address clobbers overlapping references.  */
for|for
control|(
name|i
operator|=
name|loop_store_addrs_idx
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|addr_overlap_p
argument_list|(
name|x
argument_list|,
name|loop_store_addrs
index|[
name|i
index|]
argument_list|,
name|loop_store_widths
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* It's not invalidated by a store in memory 	 but we must still verify the address is invariant.  */
break|break;
case|case
name|ASM_OPERANDS
case|:
comment|/* Don't mess with insns declared volatile.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|int
name|tem
init|=
name|invariant_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|tem
operator|==
literal|2
condition|)
name|conditional
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|int
name|tem
init|=
name|invariant_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|tem
operator|==
literal|2
condition|)
name|conditional
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
literal|1
operator|+
name|conditional
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OTHER (a mem ref) overlaps the area of memory    which is SIZE bytes starting at BASE.  */
end_comment

begin_function
name|int
name|addr_overlap_p
parameter_list|(
name|other
parameter_list|,
name|base
parameter_list|,
name|size
parameter_list|)
name|rtx
name|other
decl_stmt|;
name|rtx
name|base
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|start
init|=
literal|0
decl_stmt|,
name|end
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|CONST
condition|)
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|start
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|end
operator|=
name|start
operator|+
name|size
expr_stmt|;
return|return
name|refers_to_mem_p
argument_list|(
name|other
argument_list|,
name|base
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if all the insns in the loop that set REG    are INSN and the immediately following insns,    and if each of those insns sets REG in an invariant way    (not counting uses of REG in them).     The value is 2 if some of these insns are only conditionally invariant.     We assume that INSN itself is the first set of REG    and that its source is invariant.  */
end_comment

begin_function
specifier|static
name|int
name|consec_sets_invariant_p
parameter_list|(
name|reg
parameter_list|,
name|n_sets
parameter_list|,
name|insn
parameter_list|)
name|int
name|n_sets
decl_stmt|;
name|rtx
name|reg
decl_stmt|,
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|p
init|=
name|insn
decl_stmt|;
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* Number of sets we have to insist on finding after INSN.  */
name|int
name|count
init|=
name|n_sets
operator|-
literal|1
decl_stmt|;
name|int
name|old
init|=
name|n_times_set
index|[
name|regno
index|]
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
name|int
name|this
decl_stmt|;
comment|/* If N_SETS hit the limit, we can't rely on its value.  */
if|if
condition|(
name|n_sets
operator|==
literal|127
condition|)
return|return
literal|0
return|;
name|n_times_set
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* If library call, skip to end of of it.  */
if|if
condition|(
name|code
operator|==
name|INSN
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|p
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|==
name|regno
condition|)
block|{
name|this
operator|=
name|invariant_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|!=
literal|0
condition|)
name|value
operator||=
name|this
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|=
name|loop_find_reg_equal
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|this
operator|=
name|invariant_p
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|!=
literal|0
condition|)
name|value
operator||=
name|this
expr_stmt|;
block|}
block|}
if|if
condition|(
name|this
operator|!=
literal|0
condition|)
name|count
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
block|{
name|n_times_set
index|[
name|regno
index|]
operator|=
name|old
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|n_times_set
index|[
name|regno
index|]
operator|=
name|old
expr_stmt|;
comment|/* If invariant_p ever returned 2, we return 2.  */
return|return
literal|1
operator|+
operator|(
name|value
operator|&
literal|2
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* I don't think this condition is sufficient to allow INSN    to be moved, so we no longer test it.  */
end_comment

begin_comment
comment|/* Return 1 if all insns in the basic block of INSN and following INSN    that set REG are invariant according to TABLE.  */
end_comment

begin_endif
unit|static int all_sets_invariant_p (reg, insn, table)      rtx reg, insn;      short *table; {   register rtx p = insn;   register int regno = REGNO (reg);    while (1)     {       register enum rtx_code code;       p = NEXT_INSN (p);       code = GET_CODE (p);       if (code == CODE_LABEL || code == JUMP_INSN) 	return 1;       if (code == INSN&& GET_CODE (PATTERN (p)) == SET&& GET_CODE (SET_DEST (PATTERN (p))) == REG&& REGNO (SET_DEST (PATTERN (p))) == regno) 	{ 	  if (!invariant_p (SET_SRC (PATTERN (p)), table)) 	    return 0; 	}     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Increment N_TIMES_SET at the index of each register    that is modified by an insn between FROM and TO.    If the value of an element of N_TIMES_SET becomes 127 or more,    stop incrementing it, to avoid overflow.     Store in *COUNT_PTR the number of actual instruction    in the loop.  We use this to decide what is worth moving out.  */
end_comment

begin_comment
comment|/* last_set[n] is nonzero iff reg n has been set in the current basic block.    In that case, it is the insn that last set reg n.  */
end_comment

begin_function
specifier|static
name|void
name|count_loop_regs_set
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|may_not_move
parameter_list|,
name|count_ptr
parameter_list|,
name|nregs
parameter_list|)
specifier|register
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|;
name|char
modifier|*
name|may_not_move
decl_stmt|;
name|int
modifier|*
name|count_ptr
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
specifier|register
name|rtx
modifier|*
name|last_set
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|dest
decl_stmt|;
name|bzero
argument_list|(
name|last_set
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|from
init|;
name|insn
operator|!=
name|to
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
comment|/* If a register is used as a subroutine address, 	     don't allow this register's setting to be moved out of the loop. 	     This condition is not at all logically correct 	     but it averts a very common lossage pattern 	     and creates lossage much less often.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CALL
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|may_not_move
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CALL
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|may_not_move
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* The call insn itself sets a reg, which cannot be moved.  */
name|may_not_move
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n_times_set
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
index|]
operator|<
literal|127
condition|)
name|n_times_set
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
index|]
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
comment|/* Don't move a reg that has an explicit clobber. 	       We might do so sometimes, but it's not worth the pain.  */
name|may_not_move
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|dest
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
comment|/* If this is the first setting of this reg 		     in current basic block, and it was set before, 		     it must be set in two basic blocks, so it cannot 		     be moved out of the loop.  */
if|if
condition|(
name|n_times_set
index|[
name|regno
index|]
operator|>
literal|0
operator|&&
name|last_set
index|[
name|regno
index|]
operator|==
literal|0
condition|)
name|may_not_move
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* If this is not first setting in current basic block, 		     see if reg was used in between previous one and this. 		     If so, neither one can be moved.  */
if|if
condition|(
name|last_set
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
name|reg_used_between_p
argument_list|(
name|dest
argument_list|,
name|last_set
index|[
name|regno
index|]
argument_list|,
name|insn
argument_list|)
condition|)
name|may_not_move
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n_times_set
index|[
name|regno
index|]
operator|<
literal|127
condition|)
operator|++
name|n_times_set
index|[
name|regno
index|]
expr_stmt|;
name|last_set
index|[
name|regno
index|]
operator|=
name|insn
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|register
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
comment|/* Don't move a reg that has an explicit clobber. 		       It's not worth the pain to try to do it correctly.  */
name|may_not_move
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
block|{
name|dest
operator|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|n_times_set
index|[
name|regno
index|]
operator|<
literal|127
condition|)
operator|++
name|n_times_set
index|[
name|regno
index|]
expr_stmt|;
name|may_not_move
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
name|last_set
index|[
name|regno
index|]
operator|=
name|insn
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|bzero
argument_list|(
name|last_set
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|count_ptr
operator|=
name|count
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a loop that is bounded by LOOP_START and LOOP_END    and that is entered at SCAN_START,    return 1 if the register set by insn INSN is used by    any insn that precedes INSN in cyclic order starting    from the loop entry point.  */
end_comment

begin_function
specifier|static
name|int
name|loop_reg_used_before_p
parameter_list|(
name|insn
parameter_list|,
name|loop_start
parameter_list|,
name|scan_start
parameter_list|,
name|loop_end
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|loop_start
decl_stmt|,
name|scan_start
decl_stmt|,
name|loop_end
decl_stmt|;
block|{
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|INSN_LUID
argument_list|(
name|scan_start
argument_list|)
operator|>
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
condition|)
return|return
operator|(
name|reg_used_between_p
argument_list|(
name|reg
argument_list|,
name|scan_start
argument_list|,
name|loop_end
argument_list|)
operator|||
name|reg_used_between_p
argument_list|(
name|reg
argument_list|,
name|loop_start
argument_list|,
name|insn
argument_list|)
operator|)
return|;
else|else
return|return
name|reg_used_between_p
argument_list|(
name|reg
argument_list|,
name|scan_start
argument_list|,
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A "basic induction variable" or biv is a pseudo reg that is set    (within this loop) only by incrementing or decrementing it.  */
end_comment

begin_comment
comment|/* A "general induction variable" or giv is a pseudo reg whose    value is a linear function of a biv.  */
end_comment

begin_comment
comment|/* Bivs are recognized by `basic_induction_var';    Givs by `general_induct_var'.  */
end_comment

begin_comment
comment|/* An enum for the two different types of givs, those that are used    as memory addresses and those that are calculated into registers.  */
end_comment

begin_enum
enum|enum
name|g_types
block|{
name|DEST_ADDR
block|,
name|DEST_REG
block|}
enum|;
end_enum

begin_comment
comment|/* A `struct induction' is created for every instruction that sets    an induction variable (either a biv or a giv).  */
end_comment

begin_struct
struct|struct
name|induction
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* The insn that sets a biv or giv */
name|rtx
name|new_reg
decl_stmt|;
comment|/* New register, containing strength reduced 				  version of this giv.  */
name|int
name|src_regno
decl_stmt|;
comment|/* Biv from which this giv is computed. 				  (If this is a biv, then this is the biv.)  */
name|enum
name|g_types
name|giv_type
decl_stmt|;
comment|/* Indicate whether DEST_ADDR or DEST_REG giv */
name|int
name|dest_regno
decl_stmt|;
comment|/* Destination register for insn: this is the 				  register which was the biv or giv. 				  For a biv, this equals src_reg. 				  For a DEST_ADDR type giv, this is 0.  */
name|rtx
modifier|*
name|location
decl_stmt|;
comment|/* Place in the insn where this giv occurs. 				  If GIV_TYPE is DEST_REG, this is 0.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* The mode of this biv or giv */
name|rtx
name|mult_val
decl_stmt|;
comment|/* Multiplicative factor for src_reg.  */
name|rtx
name|add_val
decl_stmt|;
comment|/* Additive constant for that product.  */
name|int
name|benefit
decl_stmt|;
comment|/* Gain from eliminating this insn.  */
name|int
name|consec
decl_stmt|;
comment|/* The number of consecutive insn that set this 				  register; they are all eliminated if this 				  one is.  */
name|char
name|replaceable
decl_stmt|;
comment|/* 1 if we can substitute the strength-reduced 				  variable for the original variable. 				  0 means they must be kept separate and the 				  new one must be copied into the old pseudo 				  reg each time the old one is set.  */
name|char
name|ignore
decl_stmt|;
comment|/* 1 prohibits further processing of this giv */
name|int
name|lifetime
decl_stmt|;
comment|/* Length of life of this giv */
name|int
name|times_used
decl_stmt|;
comment|/* # times this giv is used. */
name|struct
name|induction
modifier|*
name|family
decl_stmt|;
comment|/* Links together all induction variables that 				  have the same src register.  */
name|struct
name|induction
modifier|*
name|forces
decl_stmt|;
comment|/* Points to an induction variable insn which 				  is used only once, to compute this giv, 				  and hence can be deleted if this insn is 				  strength reduced.  */
name|struct
name|induction
modifier|*
name|forces2
decl_stmt|;
comment|/* Likewise.  */
name|struct
name|induction
modifier|*
name|same
decl_stmt|;
comment|/* Links together all induction variables that 				  have the same tuple (src, mult, add).  */
block|}
struct|;
end_struct

begin_comment
comment|/* A `struct iv_class' is created for each biv.  */
end_comment

begin_struct
struct|struct
name|iv_class
block|{
name|int
name|regno
decl_stmt|;
comment|/* Pseudo reg which is the biv.  */
name|int
name|biv_count
decl_stmt|;
comment|/* Number of insns setting this reg.  */
name|struct
name|induction
modifier|*
name|biv
decl_stmt|;
comment|/* List of all insns that set this reg.  */
name|int
name|giv_count
decl_stmt|;
comment|/* Number of DEST_REG givs computed from this 				  biv.  The resulting count is only used in  				  check_dbra_loop.  */
name|struct
name|induction
modifier|*
name|giv
decl_stmt|;
comment|/* List of all insns that compute a giv 				  from this reg.  */
name|int
name|total_benefit
decl_stmt|;
comment|/* Sum of BENEFITs of all those givs */
name|rtx
name|initial_value
decl_stmt|;
comment|/* Value of reg at loop start */
name|struct
name|iv_class
modifier|*
name|next
decl_stmt|;
comment|/* Links all class structures together */
name|rtx
name|init_insn
decl_stmt|;
comment|/* insn which intializes biv, 0 if none seen. */
name|char
name|eliminable
decl_stmt|;
comment|/* 1 if plausible candidate for elimination.  */
name|char
name|nonneg
decl_stmt|;
comment|/* 1 if we added a REG_NONNEG note for this.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Definitions used by the basic induction variable discovery code.  */
end_comment

begin_enum
enum|enum
name|iv_mode
block|{
name|UNKNOWN_INDUCT
block|,
name|BASIC_INDUCT
block|,
name|NOT_BASIC_INDUCT
block|,
name|GENERAL_INDUCT
block|}
enum|;
end_enum

begin_comment
comment|/* Relative gain of eliminating various kinds of operations.  */
end_comment

begin_define
define|#
directive|define
name|NO_BENEFIT
value|0
end_define

begin_define
define|#
directive|define
name|ADD_BENEFIT
value|1
end_define

begin_define
define|#
directive|define
name|SHIFT_BENEFIT
value|2
end_define

begin_define
define|#
directive|define
name|MULT_BENEFIT
value|4
end_define

begin_define
define|#
directive|define
name|LIBCALL_BENEFIT
value|15
end_define

begin_comment
comment|/* Benefit penalty, if a giv is not replaceable, i.e. must emit an insn to    copy the value of the strength reduced giv to its original register.  */
end_comment

begin_define
define|#
directive|define
name|COPY_PENALTY
value|2
end_define

begin_comment
comment|/* Indexed by register number, indicates whether or not register is an    induction variable, and if so what type.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|iv_mode
modifier|*
name|induct_var
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by register number, contains pointer to `struct induction'    if register is a general induction variable.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|induction
modifier|*
modifier|*
name|induct_struct
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by register number, contains pointer to `struct iv_class'    if register is a basic induction variable.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|iv_class
modifier|*
modifier|*
name|class_struct
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************/
end_comment

begin_comment
comment|/* ??? Unfinished optimizations, wilson@ji.Berkeley.EDU */
end_comment

begin_comment
comment|/* strength reduce addresses found in sources (set () (mem ())*/
end_comment

begin_comment
comment|/* There is one more optimization you might be interested in doing: to    allocate pseudo registers for frequently-accessed memory locations.    If the same memory location is referenced each time around, it might    be possible to copy it into a register before and out after.    This is especially useful when the memory location is a variable which    is in a stack slot because somewhere its address is taken.  If the    loop doesn't contain a function call and the variable isn't volatile,    it is safe to keep the value in a register for the duration of the    loop. One tricky thing is that the copying of the value back from the    register has to be done on all exits from the loop.  You need to check that    all the exits from the loop go to the same place. */
end_comment

begin_comment
comment|/* WARNING: the interaction of biv elimination, and recognizing 'constant'    bivs may cause problems */
end_comment

begin_comment
comment|/* add heuristic so that DEST_ADDR strength reduction does not cause    performance problems */
end_comment

begin_comment
comment|/* don't eliminate things that can be combined with an addressing mode?    find all giv that have same biv and mult_val (now must also have    same add_val), then for each giv, check to see if its only use    dies in a following memory address, generate a new memory address    and check to see if valid, if valid then store modified mem addr,    else if not valid addr mark giv as not done so that it will get its    own iv */
end_comment

begin_comment
comment|/* consec_sets_giv does not calculate replaceable and forces correctly,    forces should be a more general linked list instead of two entries */
end_comment

begin_comment
comment|/* try to optimize branches when it is known that a biv is always positive */
end_comment

begin_comment
comment|/* when replace biv in compare insn, should replace with closest giv so that    an optimized branch can still be recognized by combiner, i.e. VAXen acb */
end_comment

begin_comment
comment|/* should merge final_value calculation in check_dbra_loop with the     new final_biv_value function */
end_comment

begin_comment
comment|/* many of the checks involving uid_luid could be simplified if regscan    was rerun in loop_optimize() whenever a register was added or moved,    also some of the optimizations could be a little less conservative */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Perform strength reduction and induction variable elimination.  */
end_comment

begin_comment
comment|/* Pseudo registers created during this function will be beyond the last    valid index in several tables including n_times_set and regno_last_uid.    This does not cause a problem here, because the added registers cannot be    givs outside of their loop, and hence will never be reconsidered.    But scan_loop must check regnos to make sure they are in bounds.  */
end_comment

begin_function
specifier|static
name|void
name|strength_reduce
parameter_list|(
name|scan_start
parameter_list|,
name|end
parameter_list|,
name|loop_top
parameter_list|,
name|insn_count
parameter_list|,
name|loop_start
parameter_list|,
name|loop_end
parameter_list|,
name|nregs
parameter_list|)
name|rtx
name|scan_start
decl_stmt|;
name|rtx
name|end
decl_stmt|;
name|rtx
name|loop_top
decl_stmt|;
name|int
name|insn_count
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|;
name|rtx
name|loop_end
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|;
name|rtx
name|inc_val
decl_stmt|;
name|rtx
name|mult_val
decl_stmt|;
name|int
name|dest_regno
decl_stmt|;
name|int
name|biv_found
decl_stmt|;
comment|/* This is 1 if current insn could be executed zero times in the loop.  */
name|int
name|maybe_never
init|=
literal|0
decl_stmt|;
comment|/* List of all possible basic induction variables.  */
name|struct
name|iv_class
modifier|*
name|iv_list
init|=
literal|0
decl_stmt|;
comment|/* Temporary list pointers for traversing iv_list.  */
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|,
modifier|*
name|backbl
decl_stmt|;
comment|/* Ratio of extra register life span we can justify      for saving an instruction.  More if loop doesn't call subroutines      since in that case saving an insn makes more difference      and more registers are available.  */
comment|/* ??? could set this to last value of threshold in move_movables */
name|int
name|threshold
init|=
name|loop_has_call
condition|?
literal|17
else|:
literal|34
decl_stmt|;
comment|/* Map of pseudo-register replacements.  */
name|rtx
modifier|*
name|reg_map
decl_stmt|;
name|int
name|call_seen
decl_stmt|;
name|induct_var
operator|=
operator|(
expr|enum
name|iv_mode
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|induct_var
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|induct_var
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|induct_var
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|induct_struct
operator|=
operator|(
expr|struct
name|induction
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|induction
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|induct_struct
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|induction
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|class_struct
operator|=
operator|(
expr|struct
name|iv_class
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iv_class
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|class_struct
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iv_class
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Scan through loop to find all possible bivs.  */
for|for
control|(
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|loop_start
argument_list|)
init|;
name|p
operator|!=
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|induct_var
index|[
name|dest_regno
index|]
operator|!=
name|NOT_BASIC_INDUCT
operator|&&
name|dest_regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|basic_induction_var
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
name|dest_regno
argument_list|,
operator|&
name|inc_val
argument_list|,
operator|&
name|mult_val
argument_list|)
condition|)
block|{
comment|/* It is a possible basic induction variable. 		     Create and initialize an induction structure for it.  */
name|struct
name|induction
modifier|*
name|v
init|=
operator|(
expr|struct
name|induction
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|induction
argument_list|)
argument_list|)
decl_stmt|;
name|v
operator|->
name|insn
operator|=
name|p
expr_stmt|;
name|v
operator|->
name|src_regno
operator|=
name|dest_regno
expr_stmt|;
name|v
operator|->
name|dest_regno
operator|=
name|dest_regno
expr_stmt|;
name|v
operator|->
name|mult_val
operator|=
name|mult_val
expr_stmt|;
name|v
operator|->
name|add_val
operator|=
name|inc_val
expr_stmt|;
name|v
operator|->
name|mode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add this to the reg's iv_class, creating a class 		     if this is the first incrementation of the reg.  */
name|bl
operator|=
name|class_struct
index|[
name|dest_regno
index|]
expr_stmt|;
if|if
condition|(
name|bl
condition|)
block|{
name|v
operator|->
name|family
operator|=
name|bl
operator|->
name|biv
expr_stmt|;
name|bl
operator|->
name|biv
operator|=
name|v
expr_stmt|;
name|bl
operator|->
name|biv_count
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Create and initialize new iv_class.  */
name|bl
operator|=
operator|(
expr|struct
name|iv_class
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iv_class
argument_list|)
argument_list|)
expr_stmt|;
name|bl
operator|->
name|regno
operator|=
name|dest_regno
expr_stmt|;
name|bl
operator|->
name|biv
operator|=
name|v
expr_stmt|;
name|v
operator|->
name|family
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|giv
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|biv_count
operator|=
literal|1
expr_stmt|;
name|bl
operator|->
name|giv_count
operator|=
literal|0
expr_stmt|;
comment|/* Set initial value to the reg itself.  */
name|bl
operator|->
name|initial_value
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We haven't seen the intializing insn yet */
name|bl
operator|->
name|init_insn
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|eliminable
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|nonneg
operator|=
literal|0
expr_stmt|;
comment|/* Add this insn to iv_list.  */
name|bl
operator|->
name|next
operator|=
name|iv_list
expr_stmt|;
name|iv_list
operator|=
name|bl
expr_stmt|;
comment|/* Put it in the array of iv_lists.  */
name|class_struct
index|[
name|dest_regno
index|]
operator|=
name|bl
expr_stmt|;
block|}
name|induct_var
index|[
name|dest_regno
index|]
operator|=
name|BASIC_INDUCT
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Insn %d: possible biv, reg %d,"
argument_list|,
name|INSN_UID
argument_list|(
name|p
argument_list|)
argument_list|,
name|dest_regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|inc_val
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" const = %d\n"
argument_list|,
name|INTVAL
argument_list|(
name|inc_val
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" const = "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|inc_val
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|induct_var
index|[
name|dest_regno
index|]
operator|=
name|NOT_BASIC_INDUCT
expr_stmt|;
block|}
block|}
block|}
comment|/* Scan iv_list to remove all regs that proved not to be bivs.      Make a sanity check against n_times_set.  */
name|biv_found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|backbl
operator|=
name|bl
operator|=
name|iv_list
init|;
name|bl
condition|;
name|backbl
operator|=
name|bl
operator|,
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|induct_var
index|[
name|bl
operator|->
name|regno
index|]
operator|!=
name|BASIC_INDUCT
condition|)
block|{
comment|/* Not a basic induction variable, remove this iv_class.  */
if|if
condition|(
name|backbl
operator|==
name|bl
condition|)
name|iv_list
operator|=
name|bl
operator|->
name|next
expr_stmt|;
else|else
name|backbl
operator|->
name|next
operator|=
name|bl
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Reg %d: biv discarded, not induct\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n_times_set
index|[
name|bl
operator|->
name|regno
index|]
operator|!=
name|bl
operator|->
name|biv_count
condition|)
block|{
comment|/* This happens if register modified by subreg, etc.  */
comment|/* Make sure it is not recognized as a basic induction var: */
comment|/* remove this iv_class from iv_list.  */
name|induct_var
index|[
name|bl
operator|->
name|regno
index|]
operator|=
name|NOT_BASIC_INDUCT
expr_stmt|;
if|if
condition|(
name|backbl
operator|==
name|bl
condition|)
name|iv_list
operator|=
name|bl
operator|->
name|next
expr_stmt|;
else|else
name|backbl
operator|->
name|next
operator|=
name|bl
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Reg %d: biv discarded, count error\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a valid basic induction variable.  */
name|biv_found
operator|++
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Reg %d: biv verified\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Exit if there are no bivs.  */
if|if
condition|(
operator|!
name|iv_list
condition|)
return|return;
comment|/* Find initial value for each biv.  */
comment|/* Search backwards from loop_start, halting at first label      or when all bivs have been seen.  */
name|call_seen
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|loop_start
expr_stmt|;
while|while
condition|(
name|biv_found
condition|)
block|{
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|call_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|dest_regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|induct_var
index|[
name|dest_regno
index|]
operator|==
name|BASIC_INDUCT
operator|&&
name|class_struct
index|[
name|dest_regno
index|]
operator|->
name|init_insn
operator|==
literal|0
condition|)
block|{
comment|/* This is the first modification found for this reg.  */
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Record the intializing INSN */
name|class_struct
index|[
name|dest_regno
index|]
operator|->
name|init_insn
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Biv %d initialized at insn %d: "
argument_list|,
name|dest_regno
argument_list|,
name|INSN_UID
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save value if it is a constant or register.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
comment|/* Don't try to use a value in a hard reg 			     across a call which clobbers it.  */
operator|&&
operator|!
operator|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|call_used_regs
index|[
name|REGNO
argument_list|(
name|src
argument_list|)
index|]
operator|&&
name|call_seen
operator|)
operator|&&
operator|!
name|reg_set_between_p
argument_list|(
name|src
argument_list|,
name|p
argument_list|,
name|loop_start
argument_list|)
operator|)
condition|)
block|{
name|class_struct
index|[
name|dest_regno
index|]
operator|->
name|initial_value
operator|=
name|src
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"initial value "
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"%d\n"
argument_list|,
name|INTVAL
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Biv initial value is not simple move, 			 so let it keep intial value of "itself".  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"complex initial value\n"
argument_list|)
expr_stmt|;
block|}
name|biv_found
operator|--
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
block|}
comment|/* Search the loop for general induction variables.  */
comment|/* A register is a giv if: it is only set once, it is a function of a      biv and a constant (or invariant), and it is not a biv.  */
name|p
operator|=
name|scan_start
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* At end of a straight-in loop, we are done. 	 At end of a loop entered at the bottom, scan the top.  */
if|if
condition|(
name|p
operator|==
name|scan_start
condition|)
break|break;
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
if|if
condition|(
name|loop_top
operator|!=
literal|0
condition|)
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|loop_top
argument_list|)
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|p
operator|==
name|scan_start
condition|)
break|break;
block|}
comment|/* Look for a general induction variable in a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|may_not_optimize
index|[
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
index|]
condition|)
block|{
name|int
name|src_regno
decl_stmt|;
name|rtx
name|add_val
decl_stmt|;
name|rtx
name|mult_val
decl_stmt|;
name|int
name|benefit
decl_stmt|;
name|rtx
name|regnote
init|=
literal|0
decl_stmt|;
name|struct
name|induction
modifier|*
name|forces
init|=
literal|0
decl_stmt|;
name|struct
name|induction
modifier|*
name|forces2
init|=
literal|0
decl_stmt|;
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
continue|continue;
if|if
condition|(
comment|/* Normal giv.  */
operator|(
operator|(
name|benefit
operator|=
name|general_induction_var
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
operator|&
name|src_regno
argument_list|,
operator|&
name|add_val
argument_list|,
operator|&
name|mult_val
argument_list|,
operator|&
name|forces
argument_list|,
operator|&
name|forces2
argument_list|)
operator|)
comment|/* Giv set with call to a library routine.  */
operator|||
operator|(
operator|(
name|regnote
operator|=
name|loop_find_reg_equal
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
operator|(
name|benefit
operator|=
name|general_induction_var
argument_list|(
name|XEXP
argument_list|(
name|regnote
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|src_regno
argument_list|,
operator|&
name|add_val
argument_list|,
operator|&
name|mult_val
argument_list|,
operator|&
name|forces
argument_list|,
operator|&
name|forces2
argument_list|)
operator|)
operator|)
operator|)
comment|/* Don't try to handle any regs made by loop optimization. 		 We have nothing on them in regno_first_uid, etc.  */
operator|&&
name|dest_regno
operator|<
name|old_max_reg
comment|/* Don't recognize a BASIC_INDUCT_VAR here.  */
operator|&&
name|dest_regno
operator|!=
name|src_regno
comment|/* This must be the only place where the register is set.  */
operator|&&
operator|(
name|n_times_set
index|[
name|dest_regno
index|]
operator|==
literal|1
operator|||
operator|(
name|benefit
operator|=
name|consec_sets_giv
argument_list|(
name|benefit
argument_list|,
name|p
argument_list|,
name|src_regno
argument_list|,
name|dest_regno
argument_list|,
operator|&
name|add_val
argument_list|,
operator|&
name|mult_val
argument_list|)
operator|)
operator|)
condition|)
block|{
name|int
name|count
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
init|=
operator|(
expr|struct
name|induction
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|induction
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|record_giv
argument_list|(
name|v
argument_list|,
name|p
argument_list|,
name|src_regno
argument_list|,
name|dest_regno
argument_list|,
name|mult_val
argument_list|,
name|add_val
argument_list|,
name|benefit
argument_list|,
name|forces
argument_list|,
name|forces2
argument_list|,
name|DEST_REG
argument_list|,
name|maybe_never
argument_list|,
literal|0
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
comment|/* Skip the consecutive insns, if there are any.  */
for|for
control|(
name|count
operator|=
name|v
operator|->
name|consec
operator|-
literal|1
init|;
name|count
operator|>=
literal|0
condition|;
name|count
operator|--
control|)
block|{
comment|/* If first insn of libcall sequence, skip to end.  */
comment|/* Do this at start of loop, since INSN is guaranteed to 		     be an insn here.  */
if|if
condition|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Eliminating a libcall does more good than 			 eliminating a single insn to do the same job.  */
name|benefit
operator|+=
name|LIBCALL_BENEFIT
expr_stmt|;
name|p
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|do
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
do|while
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|NOTE
condition|)
do|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|DONT_REDUCE_ADDR
comment|/* Look for givs which are memory addresses.  */
comment|/* This resulted in worse code on a VAX 8600.  I wonder if it 	 still does.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
condition|)
name|find_mem_givs
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
argument_list|,
name|maybe_never
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Past a label or a jump, we get to insns for which we can't count 	 on whether or how many times they will be executed during each 	 iteration.  Givs found afterwards cannot be marked replaceable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|maybe_never
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Try to prove that the loop counter variable (if any) is always      nonnegative; if so, record that fact with a REG_NONNEG note      so that "decrement and branch until zero" insn can be used.  */
name|check_dbra_loop
argument_list|(
name|loop_end
argument_list|,
name|iv_list
argument_list|,
name|insn_count
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
comment|/* Create reg_map to hold substitutions for replaceable giv regs.  */
name|reg_map
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_map
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Examine each iv class for feasibility of strength reduction/induction      variable elimination.  */
for|for
control|(
name|bl
operator|=
name|iv_list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|int
name|benefit
decl_stmt|;
name|int
name|replaceable
decl_stmt|;
name|int
name|all_reduced
decl_stmt|;
name|rtx
name|final_value
init|=
literal|0
decl_stmt|;
comment|/* Test whether it will be possible to eliminate this biv 	 provided all givs are reduced.  This is possible if either 	 the reg is not used outside the loop, or we can compute 	 what its final value will be.  	 Don't try if we put a REG_NONNEG note on the endtest for this biv. 	 ??? That should be only on machines that have dbra insns.  */
comment|/* Compare against bl->init_insn rather than loop_start. 	 We aren't concerned with any uses of the biv between 	 init_insn and loop_start since these won't be affected 	 by the value of the biv elsewhere in the function, so 	 long as init_insn doesn't use the biv itself. 	 March 14, 1989 -- self@bayes.arc.nasa.gov */
if|if
condition|(
operator|(
name|uid_luid
index|[
name|regno_last_uid
index|[
name|bl
operator|->
name|regno
index|]
index|]
operator|<
name|INSN_LUID
argument_list|(
name|loop_end
argument_list|)
operator|&&
name|bl
operator|->
name|init_insn
operator|&&
name|INSN_UID
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
operator|<
name|max_uid
operator|&&
name|uid_luid
index|[
name|regno_first_uid
index|[
name|bl
operator|->
name|regno
index|]
index|]
operator|>=
name|INSN_LUID
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|bl
operator|->
name|init_insn
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|bl
operator|->
name|nonneg
operator|)
operator|||
operator|(
name|final_value
operator|=
name|final_biv_value
argument_list|(
name|bl
argument_list|,
name|loop_end
argument_list|)
operator|)
condition|)
name|check_eliminate_biv
argument_list|(
name|bl
argument_list|,
name|loop_start
argument_list|,
name|end
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Cannot eliminate biv %d.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"First use: insn %d, last use: insn %d.\n"
argument_list|,
name|regno_first_uid
index|[
name|bl
operator|->
name|regno
index|]
argument_list|,
name|regno_last_uid
index|[
name|bl
operator|->
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* This will be true at the end, if all givs which depend on this 	 biv have been strength reduced. 	 We can't (currently) eliminate the biv unless this is so.  */
name|all_reduced
operator|=
literal|1
expr_stmt|;
comment|/* Check each giv in this class.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|family
control|)
block|{
name|struct
name|induction
modifier|*
name|tv
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|ignore
condition|)
continue|continue;
name|benefit
operator|=
name|v
operator|->
name|benefit
expr_stmt|;
name|replaceable
operator|=
name|v
operator|->
name|replaceable
expr_stmt|;
comment|/* Reduce benefit if not replaceable, since we will insert 	     a move-insn to replace the insn that calculates this giv.  */
if|if
condition|(
operator|!
name|replaceable
operator|&&
operator|!
name|bl
operator|->
name|eliminable
condition|)
name|benefit
operator|-=
name|COPY_PENALTY
expr_stmt|;
comment|/* Decrease the benefit to count the add-insns that we will 	     insert to increment the reduced reg for the giv.  */
name|benefit
operator|-=
name|ADD_BENEFIT
operator|*
name|bl
operator|->
name|biv_count
expr_stmt|;
comment|/* Find all equivalent givs (that bear same relation to the biv). 	     Link them via the `same' field and add their benefits together. 	     They can be replaced with a single register.  */
for|for
control|(
name|tv
operator|=
name|v
operator|->
name|family
init|;
name|tv
condition|;
name|tv
operator|=
name|tv
operator|->
name|family
control|)
block|{
if|if
condition|(
name|tv
operator|->
name|ignore
operator|==
literal|0
operator|&&
name|tv
operator|->
name|src_regno
operator|==
name|v
operator|->
name|src_regno
operator|&&
name|rtx_equal_p
argument_list|(
name|tv
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|mult_val
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|tv
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|)
condition|)
block|{
name|benefit
operator|+=
name|tv
operator|->
name|benefit
expr_stmt|;
if|if
condition|(
operator|!
name|tv
operator|->
name|replaceable
condition|)
name|benefit
operator|-=
name|COPY_PENALTY
expr_stmt|;
name|v
operator|->
name|lifetime
operator|+=
name|tv
operator|->
name|lifetime
expr_stmt|;
name|v
operator|->
name|times_used
operator|+=
name|tv
operator|->
name|times_used
expr_stmt|;
name|tv
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
comment|/* Link them together via `same' field.  */
name|tv
operator|->
name|same
operator|=
name|v
operator|->
name|same
expr_stmt|;
name|v
operator|->
name|same
operator|=
name|tv
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv of insn %d combined with that of %d.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|tv
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Decide whether to strength-reduce this giv 	     or to leave the code unchanged 	     (recompute it from the biv each time it is used). 	     This decision can be made independently for each giv.  */
comment|/* ??? Perhaps attempt to guess whether autoincrement will handle 	     some of the new add insns; if so, can increase BENEFIT 	     (undo the subtraction of ADD_BENEFIT that was done above).  */
comment|/* If an insn is not to be strength reduced, then set its ignore 	     flag, and clear all_reduced.  */
comment|/* Is it right to consider times_used?  */
comment|/* ??? What about the insns that are 'forced' by this one? 	     Although this insn is not worthwhile to reduce, it may be 	     worthwhile to reduce the simpler givs used to compute this  	     complex giv.  */
comment|/* ??? Hey! If a giv has its forces field set, then that means 	     it is not computed directly from the biv, it is instead computed 	     from a simpler giv.  If we define UNFORCE_INSNS, then the simpler 	     giv will be considered for strength reduction, and this giv should 	     not cause all_reduced to be cleared because it DOESN'T use the 	     biv!!!  If the simpler giv can not be reduced, then that simpler 	     biv will still cause all_reduced to be cleared.  */
if|if
condition|(
name|benefit
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv of insn %d, no benefit\n"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
name|all_reduced
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|lifetime
operator|*
name|threshold
operator|*
name|benefit
operator|<
name|insn_count
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv of insn %d not worth while, %d vs %d.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|,
name|v
operator|->
name|lifetime
operator|*
name|threshold
operator|*
name|benefit
argument_list|,
name|insn_count
argument_list|)
expr_stmt|;
name|v
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
name|all_reduced
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now check that we can increment the reduced giv 	     without needing a multiply insn.  If not, reject it.  */
if|if
condition|(
operator|!
name|v
operator|->
name|ignore
condition|)
block|{
name|int
name|success
init|=
literal|1
decl_stmt|;
for|for
control|(
name|tv
operator|=
name|bl
operator|->
name|biv
init|;
name|tv
condition|;
name|tv
operator|=
name|tv
operator|->
name|family
control|)
if|if
condition|(
name|tv
operator|->
name|mult_val
operator|==
name|const1_rtx
condition|)
name|success
operator|&=
name|product_cheap_p
argument_list|(
name|tv
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|mult_val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv of insn %d: would need a multiply.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
name|all_reduced
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Reduce each giv that we decided to reduce.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|family
control|)
block|{
name|struct
name|induction
modifier|*
name|tv
decl_stmt|;
if|if
condition|(
operator|!
name|v
operator|->
name|ignore
condition|)
block|{
name|rtx
name|new_reg
decl_stmt|;
comment|/* Note Iris compiler dies if ?: is used inside gen_reg_rtx. */
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_ADDR
condition|)
name|new_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
else|else
name|new_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|v
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For each place where the biv is incremented, 		 add an insn to increment the new, reduced reg for the giv. 		 Insert it before the insn that sets the biv, 		 so that the biv increment remains last before the endtest, 		 so that dbra will still be recognized.  */
for|for
control|(
name|tv
operator|=
name|bl
operator|->
name|biv
init|;
name|tv
condition|;
name|tv
operator|=
name|tv
operator|->
name|family
control|)
block|{
name|struct
name|induction
modifier|*
name|iv
decl_stmt|;
name|rtx
name|before_insn
init|=
name|tv
operator|->
name|insn
decl_stmt|;
comment|/* If this increment is between the setting of the giv and 		     its use, don't increment until after the use.  */
for|for
control|(
name|iv
operator|=
name|v
init|;
name|iv
condition|;
name|iv
operator|=
name|iv
operator|->
name|same
control|)
block|{
if|if
condition|(
name|INSN_LUID
argument_list|(
name|tv
operator|->
name|insn
argument_list|)
operator|<=
name|INSN_LUID
argument_list|(
name|iv
operator|->
name|insn
argument_list|)
operator|&&
operator|(
operator|(
name|iv
operator|->
name|forces
operator|&&
operator|(
name|INSN_LUID
argument_list|(
name|tv
operator|->
name|insn
argument_list|)
operator|>=
name|INSN_LUID
argument_list|(
name|iv
operator|->
name|forces
operator|->
name|insn
argument_list|)
operator|)
operator|||
operator|(
name|iv
operator|->
name|forces2
operator|&&
operator|(
name|INSN_LUID
argument_list|(
name|tv
operator|->
name|insn
argument_list|)
operator|>=
name|INSN_LUID
argument_list|(
name|iv
operator|->
name|forces2
operator|->
name|insn
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|before_insn
operator|=
name|NEXT_INSN
argument_list|(
name|iv
operator|->
name|insn
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tv
operator|->
name|mult_val
operator|==
name|const1_rtx
condition|)
name|emit_iv_inc
argument_list|(
name|tv
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|new_reg
argument_list|,
name|before_insn
argument_list|)
expr_stmt|;
else|else
comment|/* tv->mult_val == const0_rtx */
comment|/* A multiply is acceptable here 		       since this is presumed to be seldom executed.  */
name|emit_iv_init_code
argument_list|(
name|tv
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|new_reg
argument_list|,
name|before_insn
argument_list|)
expr_stmt|;
block|}
comment|/* Add code at loop start to initialize giv's reduced reg.  */
name|emit_iv_init_code
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|new_reg
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
comment|/* If the initial value uses a register, 		 then we may have just extended its range of appearance. 		 Update this conservatively for the sake of outer loops.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|uid_luid
index|[
name|regno_last_uid
index|[
name|REGNO
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
index|]
index|]
operator|<
name|INSN_LUID
argument_list|(
name|loop_start
argument_list|)
operator|)
condition|)
name|uid_luid
index|[
name|regno_last_uid
index|[
name|REGNO
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
index|]
index|]
operator|=
name|INSN_LUID
argument_list|(
name|loop_start
argument_list|)
expr_stmt|;
comment|/* For each giv register that can be reduced now: 		 delete old insn that modifies the giv, 		 if replaceable, substitute reduced reg 		   wherever the old giv occurs; 		 else add new move insn "giv_reg = reduced_reg".  */
for|for
control|(
name|tv
operator|=
name|v
init|;
name|tv
condition|;
name|tv
operator|=
name|tv
operator|->
name|same
control|)
block|{
comment|/* Record the identity of the reduced reg.  */
name|tv
operator|->
name|new_reg
operator|=
name|new_reg
expr_stmt|;
if|if
condition|(
name|tv
operator|->
name|giv_type
operator|==
name|DEST_ADDR
condition|)
block|{
comment|/* Store reduced reg as the address in the memref 			 where we found this giv.  */
operator|*
name|tv
operator|->
name|location
operator|=
name|new_reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tv
operator|->
name|replaceable
condition|)
block|{
name|reg_map
index|[
name|tv
operator|->
name|dest_regno
index|]
operator|=
name|new_reg
expr_stmt|;
comment|/* If giv lives after end of loop, 			 emit insn to copy reduced reg into old reg, 			 at the end of the loop. 			 ?? insufficient; used before loop could 			 mean live after loop, due to surrounding loop.  */
comment|/* Currently a giv used outside 			 the loop will not be marked replaceable, 			 so these deficiencies don't really hurt.  */
if|if
condition|(
name|uid_luid
index|[
name|regno_last_uid
index|[
name|tv
operator|->
name|dest_regno
index|]
index|]
operator|>
name|uid_luid
index|[
name|INSN_UID
argument_list|(
name|loop_end
argument_list|)
index|]
condition|)
block|{
comment|/* ?? This won't work.  We need to do this at 			     ALL exits.  */
name|emit_insn_after
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|tv
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|,
name|new_reg
argument_list|)
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Not replaceable; emit an insn to set the 			 original giv reg from the reduced giv.  */
name|int
name|count
decl_stmt|;
name|rtx
name|after_insn
init|=
name|tv
operator|->
name|insn
decl_stmt|;
for|for
control|(
name|count
operator|=
name|tv
operator|->
name|consec
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
name|after_insn
operator|=
name|next_real_insn
argument_list|(
name|after_insn
argument_list|)
expr_stmt|;
comment|/* Put new insn after, not before, in case 			 after_insn is the end of a libcall.  */
name|emit_insn_after
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|tv
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|,
name|new_reg
argument_list|)
argument_list|,
name|after_insn
argument_list|)
expr_stmt|;
block|}
comment|/* Delete the insn that used to set the old giv reg, 		     unless we modified an address in it. 		     In any case, delete the other insns used for this one.  */
name|delete_insn_forces
argument_list|(
name|tv
argument_list|,
name|tv
operator|->
name|giv_type
operator|!=
name|DEST_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"giv at %d reduced to reg %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|tv
operator|->
name|insn
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|new_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* One set of equivalent givs has been strength-reduced.  */
block|}
if|#
directive|if
literal|0
block|else if (v->new_reg == 0) 	    {
comment|/* This giv wasn't reduced and is not worth reducing.  */
block|for (tv = v; tv; tv = tv->same) 		if (loop_dump_stream) 		  fprintf (loop_dump_stream, "giv at %d not reduced\n", 			   INSN_UID (tv->insn));  	      all_reduced = 0; 	    }
endif|#
directive|endif
block|}
comment|/* All the givs in this family have been reduced if they merit it.  */
comment|/* Try to eliminate the biv, if it is a candidate. 	 This won't work if ! all_reduced, 	 since the givs we planned to use might not have been reduced.  */
if|if
condition|(
name|all_reduced
operator|==
literal|1
operator|&&
name|bl
operator|->
name|eliminable
condition|)
block|{
comment|/* Get the REG rtx for the biv.  */
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
operator|!=
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|==
name|INSN
operator|||
name|code
operator|==
name|JUMP_INSN
operator|||
name|code
operator|==
name|CALL_INSN
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|cc0_rtx
condition|)
comment|/* Found a compare instruction using this biv; 		   rewrite it to use a related giv.  */
block|{
name|struct
name|induction
modifier|*
name|v1
decl_stmt|;
comment|/* If this is an insn which uses the biv ONLY in the 		     calculation of a giv which is in the family of this 		     biv, it's ok becuase it will go away when the giv is 		     reduced.  */
for|for
control|(
name|v1
operator|=
name|bl
operator|->
name|giv
init|;
name|v1
condition|;
name|v1
operator|=
name|v1
operator|->
name|family
control|)
if|if
condition|(
name|v1
operator|->
name|insn
operator|==
name|p
condition|)
block|{
if|if
condition|(
name|v1
operator|->
name|giv_type
operator|==
name|DEST_REG
operator|||
operator|(
name|v1
operator|->
name|giv_type
operator|==
name|DEST_ADDR
comment|/* I thought the test was backwards, 				   but then I found the real problem 				   was in the subroutine.  */
operator|&&
operator|!
name|other_reg_use_p
argument_list|(
name|reg
argument_list|,
operator|*
operator|(
name|v1
operator|->
name|location
operator|)
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|v1
condition|)
name|eliminate_biv
argument_list|(
name|p
argument_list|,
name|bl
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Biv is no longer really needed inside the loop, 	     so delete all insns that set the biv.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|biv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|family
control|)
name|delete_insn
argument_list|(
name|v
operator|->
name|insn
argument_list|)
expr_stmt|;
comment|/* ?? If we created a new test to bypass the loop entirely, 	     or otherwise drop straight in, based on this test, then 	     we might want to rewrite it also.  This way some later 	     pass has more hope of removing the intialization of this 	     biv entirely. */
comment|/* If final_value != 0, then biv may be used after loop end 	     and we must emit an insn to set it just in case.  */
if|if
condition|(
name|final_value
operator|!=
literal|0
condition|)
name|emit_insn_after
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|final_value
argument_list|)
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Reg %d: biv eliminated\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Go through all the instructions in the loop, making all the      register substitutions scheduled in REG_MAP.  */
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
operator|!=
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|replace_regs
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|reg_map
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if register REG appears somewhere within IN, other than in    subexpressions EQ to EXPR.  This is a modification of reg_mentioned_p.  */
end_comment

begin_function
name|int
name|other_reg_use_p
parameter_list|(
name|reg
parameter_list|,
name|expr
parameter_list|,
name|in
parameter_list|)
specifier|register
name|rtx
name|reg
decl_stmt|,
name|expr
decl_stmt|,
name|in
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|in
operator|==
literal|0
operator|||
name|in
operator|==
name|expr
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reg
operator|==
name|in
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|in
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Compare registers by number.  */
case|case
name|REG
case|:
return|return
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|in
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg
argument_list|)
return|;
comment|/* These codes have no constituent expressions 	 and are unique.  */
case|case
name|CC0
case|:
case|case
name|PC
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
return|return
literal|0
return|;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|other_reg_use_p
argument_list|(
name|reg
argument_list|,
name|expr
argument_list|,
name|XVECEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|other_reg_use_p
argument_list|(
name|reg
argument_list|,
name|expr
argument_list|,
name|XEXP
argument_list|(
name|in
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan X for memory refs and check each memory address    as a possible giv.  INSN is the insn whose pattern X comes from.    MAYBE_NEVER is 1 if the loop might execute INSN zero times.  */
end_comment

begin_function
specifier|static
name|void
name|find_mem_givs
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|maybe_never
parameter_list|,
name|loop_end
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|maybe_never
decl_stmt|;
name|rtx
name|loop_end
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|USE
case|:
case|case
name|CLOBBER
case|:
return|return;
case|case
name|MEM
case|:
block|{
name|int
name|src_regno
decl_stmt|;
name|rtx
name|add_val
decl_stmt|;
name|rtx
name|mult_val
decl_stmt|;
name|int
name|benefit
decl_stmt|;
name|struct
name|induction
modifier|*
name|forces
init|=
literal|0
decl_stmt|;
name|struct
name|induction
modifier|*
name|forces2
init|=
literal|0
decl_stmt|;
name|benefit
operator|=
name|general_induction_var
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|src_regno
argument_list|,
operator|&
name|add_val
argument_list|,
operator|&
name|mult_val
argument_list|,
operator|&
name|forces
argument_list|,
operator|&
name|forces2
argument_list|)
expr_stmt|;
if|if
condition|(
name|benefit
operator|>
literal|0
condition|)
block|{
comment|/* Found one; record it.  */
name|struct
name|induction
modifier|*
name|v
init|=
operator|(
expr|struct
name|induction
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|induction
argument_list|)
argument_list|)
decl_stmt|;
name|record_giv
argument_list|(
name|v
argument_list|,
name|insn
argument_list|,
name|src_regno
argument_list|,
literal|0
argument_list|,
name|mult_val
argument_list|,
name|add_val
argument_list|,
name|benefit
argument_list|,
name|forces
argument_list|,
name|forces2
argument_list|,
name|DEST_ADDR
argument_list|,
name|maybe_never
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
comment|/* Recursively scan the subexpressions for other mem refs.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|find_mem_givs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|maybe_never
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|find_mem_givs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|maybe_never
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fill in the data about one giv.    V is the `struct induction' in which we record the giv.  (It is    allocated by the caller, with alloca.)    INSN is the insn that sets it.    BENEFIT estimates the savings from deleting this insn.    TYPE is DEST_REG or DEST_ADDR; it says whether the giv is computed    into a register or is used as a memory address.     SRC_REGNO is the biv reg number which the giv is computed from.    DEST_REGNO is the giv's reg number (if the giv is stored in a reg).    MULT_VAL and ADD_VAL are the coefficients used to compute the giv.    FORCES and FORCES2, if nonzero, are other `struct induction's for    other givs which are used to compute this giv indirectly.    LOCATION points to the place where this giv's value appears in INSN.  */
end_comment

begin_function
specifier|static
name|void
name|record_giv
parameter_list|(
name|v
parameter_list|,
name|insn
parameter_list|,
name|src_regno
parameter_list|,
name|dest_regno
parameter_list|,
name|mult_val
parameter_list|,
name|add_val
parameter_list|,
name|benefit
parameter_list|,
name|forces
parameter_list|,
name|forces2
parameter_list|,
name|type
parameter_list|,
name|maybe_never
parameter_list|,
name|location
parameter_list|,
name|loop_end
parameter_list|)
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|src_regno
decl_stmt|,
name|dest_regno
decl_stmt|;
name|rtx
name|mult_val
decl_stmt|,
name|add_val
decl_stmt|;
name|int
name|benefit
decl_stmt|;
name|struct
name|induction
modifier|*
name|forces
decl_stmt|,
decl|*
name|forces2
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|g_types
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maybe_never
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
modifier|*
name|location
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|loop_end
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|induction
modifier|*
name|b
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|v
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|v
operator|->
name|src_regno
operator|=
name|src_regno
expr_stmt|;
name|v
operator|->
name|giv_type
operator|=
name|type
expr_stmt|;
name|v
operator|->
name|dest_regno
operator|=
name|dest_regno
expr_stmt|;
name|v
operator|->
name|mult_val
operator|=
name|mult_val
expr_stmt|;
name|v
operator|->
name|add_val
operator|=
name|add_val
expr_stmt|;
name|v
operator|->
name|benefit
operator|=
name|benefit
expr_stmt|;
name|v
operator|->
name|location
operator|=
name|location
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DEST_ADDR
condition|)
block|{
name|v
operator|->
name|mode
operator|=
name|GET_MODE
argument_list|(
operator|*
name|location
argument_list|)
expr_stmt|;
name|v
operator|->
name|consec
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|lifetime
operator|=
literal|1
expr_stmt|;
name|v
operator|->
name|times_used
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* type == DEST_REG */
block|{
name|v
operator|->
name|mode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|consec
operator|=
name|n_times_set
index|[
name|dest_regno
index|]
operator|-
literal|1
expr_stmt|;
name|v
operator|->
name|lifetime
operator|=
operator|(
name|uid_luid
index|[
name|regno_last_uid
index|[
name|dest_regno
index|]
index|]
operator|-
name|uid_luid
index|[
name|regno_first_uid
index|[
name|dest_regno
index|]
index|]
operator|)
expr_stmt|;
name|v
operator|->
name|times_used
operator|=
name|n_times_used
index|[
name|dest_regno
index|]
expr_stmt|;
block|}
name|v
operator|->
name|same
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|forces
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|forces2
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|ignore
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|new_reg
operator|=
literal|0
expr_stmt|;
comment|/* Mark giv as forced if it is only used to compute another giv.  */
comment|/* This check is not sufficient as INSN may have been moved giving      it a new uid, so make another check by calculating lifetimes.      This is overconservative but seems to be correct.  */
if|if
condition|(
name|forces
condition|)
block|{
name|v
operator|->
name|benefit
operator|+=
name|forces
operator|->
name|benefit
expr_stmt|;
if|if
condition|(
operator|(
name|regno_last_uid
index|[
name|forces
operator|->
name|dest_regno
index|]
operator|==
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
operator|(
name|uid_luid
index|[
name|regno_last_uid
index|[
name|forces
operator|->
name|dest_regno
index|]
index|]
operator|-
name|uid_luid
index|[
name|regno_first_uid
index|[
name|forces
operator|->
name|dest_regno
index|]
index|]
operator|)
operator|==
operator|(
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|-
name|INSN_LUID
argument_list|(
name|forces
operator|->
name|insn
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|!
name|reg_used_between_p
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|forces
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|,
name|forces
operator|->
name|insn
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|v
operator|->
name|forces
operator|=
name|forces
expr_stmt|;
name|forces
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|forces2
condition|)
block|{
name|v
operator|->
name|benefit
operator|+=
name|forces2
operator|->
name|benefit
expr_stmt|;
if|if
condition|(
operator|(
name|regno_last_uid
index|[
name|forces2
operator|->
name|dest_regno
index|]
operator|==
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
operator|(
name|uid_luid
index|[
name|regno_last_uid
index|[
name|forces2
operator|->
name|dest_regno
index|]
index|]
operator|-
name|uid_luid
index|[
name|regno_first_uid
index|[
name|forces2
operator|->
name|dest_regno
index|]
index|]
operator|)
operator|==
operator|(
name|INSN_LUID
argument_list|(
name|insn
argument_list|)
operator|-
name|INSN_LUID
argument_list|(
name|forces2
operator|->
name|insn
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|!
name|reg_used_between_p
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|forces2
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|,
name|forces2
operator|->
name|insn
argument_list|,
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|forces
condition|)
name|v
operator|->
name|forces2
operator|=
name|forces2
expr_stmt|;
else|else
name|v
operator|->
name|forces
operator|=
name|forces2
expr_stmt|;
name|forces2
operator|->
name|ignore
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type
operator|==
name|DEST_REG
condition|)
block|{
name|induct_var
index|[
name|dest_regno
index|]
operator|=
name|GENERAL_INDUCT
expr_stmt|;
name|induct_struct
index|[
name|dest_regno
index|]
operator|=
name|v
expr_stmt|;
block|}
comment|/* Add the giv to the class of givs computed from one biv.  */
name|bl
operator|=
name|class_struct
index|[
name|src_regno
index|]
expr_stmt|;
if|if
condition|(
name|bl
condition|)
block|{
name|v
operator|->
name|family
operator|=
name|bl
operator|->
name|giv
expr_stmt|;
name|bl
operator|->
name|giv
operator|=
name|v
expr_stmt|;
comment|/* Don't count DEST_ADDR.  This is supposed to count the number of 	 insns that calculate givs.  */
if|if
condition|(
name|type
operator|==
name|DEST_REG
condition|)
name|bl
operator|->
name|giv_count
operator|++
expr_stmt|;
name|bl
operator|->
name|total_benefit
operator|+=
name|benefit
expr_stmt|;
block|}
else|else
comment|/* Fatal error, biv missing for this giv?  */
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DEST_ADDR
condition|)
name|v
operator|->
name|replaceable
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* The giv can be replaced outright by the reduced register if  	 - the insn that sets the giv is always executed on any iteration 	   on which the giv is used at all 	   (there are two ways to deduce this: 	    either the insn is executed on every iteration, 	    or all uses follow that insn in the same basic block),  	 - the giv is not used before the insn that sets it,  	    i.e. no definition outside loop reaches into loop 	 - no assignments to the biv occur during the giv's lifetime.  */
comment|/* Is this right?  Don't we need to make sure the giv is not used 	 outside the loop.  Someday we will know where all the loop exits 	 are so we can do better, but until then.... 	 March 18, 1989 -- self@bayes.arc.nasa.gov */
if|if
condition|(
name|regno_first_uid
index|[
name|dest_regno
index|]
operator|==
name|INSN_UID
argument_list|(
name|insn
argument_list|)
comment|/* Previous line always fails if INSN was moved by loop opt.  */
operator|&&
name|uid_luid
index|[
name|regno_last_uid
index|[
name|dest_regno
index|]
index|]
operator|<
name|INSN_LUID
argument_list|(
name|loop_end
argument_list|)
operator|&&
operator|(
operator|!
name|maybe_never
operator|||
name|last_use_this_basic_block
argument_list|(
name|dest_regno
argument_list|,
name|insn
argument_list|)
operator|)
condition|)
block|{
name|v
operator|->
name|replaceable
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|b
operator|=
name|bl
operator|->
name|biv
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|family
control|)
block|{
if|if
condition|(
operator|(
name|uid_luid
index|[
name|INSN_UID
argument_list|(
name|b
operator|->
name|insn
argument_list|)
index|]
operator|>=
name|uid_luid
index|[
name|regno_first_uid
index|[
name|dest_regno
index|]
index|]
operator|)
operator|&&
operator|(
name|uid_luid
index|[
name|INSN_UID
argument_list|(
name|b
operator|->
name|insn
argument_list|)
index|]
operator|<=
name|uid_luid
index|[
name|regno_last_uid
index|[
name|dest_regno
index|]
index|]
operator|)
condition|)
block|{
name|v
operator|->
name|replaceable
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
name|v
operator|->
name|replaceable
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|loop_dump_stream
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|DEST_REG
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Insn %d: giv reg %d"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|dest_regno
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Insn %d: dest address"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" src reg %d benefit %d"
argument_list|,
name|src_regno
argument_list|,
name|v
operator|->
name|benefit
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" used %d lifetime %d"
argument_list|,
name|v
operator|->
name|times_used
argument_list|,
name|v
operator|->
name|lifetime
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|replaceable
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" replaceable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|mult_val
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" mult %d"
argument_list|,
name|INTVAL
argument_list|(
name|mult_val
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" mult "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|mult_val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|add_val
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" add %d"
argument_list|,
name|INTVAL
argument_list|(
name|add_val
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" add "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|loop_dump_stream
argument_list|,
name|add_val
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|loop_dump_stream
operator|&&
name|v
operator|->
name|forces
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" forces insn %d"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|forces
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
operator|&&
name|v
operator|->
name|forces2
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" forces insn %d"
argument_list|,
name|INSN_UID
argument_list|(
name|v
operator|->
name|forces2
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
operator|&&
name|v
operator|->
name|consec
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|" consec %d"
argument_list|,
name|v
operator|->
name|consec
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Delete the insns forced by the insn described by V.    If THIS_TOO is nonzero, delete that insn itself as well.  */
end_comment

begin_function
specifier|static
name|void
name|delete_insn_forces
parameter_list|(
name|v
parameter_list|,
name|this_too
parameter_list|)
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|int
name|this_too
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|,
name|p
decl_stmt|;
name|int
name|count
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|this_too
condition|)
block|{
name|insn
operator|=
name|v
operator|->
name|insn
expr_stmt|;
for|for
control|(
name|count
operator|=
name|v
operator|->
name|consec
init|;
name|count
operator|>=
literal|0
condition|;
name|count
operator|--
control|)
block|{
comment|/* If first insn of libcall sequence, skip to end.  */
comment|/* Do this at start of loop, since p is guaranteed to 	     be an insn here.  */
if|if
condition|(
name|x
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
literal|0
argument_list|)
condition|)
name|insn
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* This is a library call; delete all insns backward until get to 		 first insn in this group.  */
name|rtx
name|first
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|insn
init|;
name|p
operator|!=
name|first
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
name|delete_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Delete first insn also.  */
name|delete_insn
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
do|do
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
do|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
do|;
block|}
block|}
if|if
condition|(
name|v
operator|->
name|forces
condition|)
name|delete_insn_forces
argument_list|(
name|v
operator|->
name|forces
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|forces2
condition|)
name|delete_insn_forces
argument_list|(
name|v
operator|->
name|forces2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check whether an insn is an increment legitimate for a basic induction var.    X is the source of the insn.    DEST_REG is the putative biv, also the destination of the insn.    We accept patterns of these forms:      REG = REG + INVARIANT      REG = INVARIANT + REG      REG = REG - CONSTANT     If X is suitable, we return 1,    and store the factor multiplying REF in X into *MULT_VAL    and the additive term into *INC_VAL.    Otherwise we return 0.  */
end_comment

begin_function
specifier|static
name|int
name|basic_induction_var
parameter_list|(
name|x
parameter_list|,
name|dest_regno
parameter_list|,
name|inc_val
parameter_list|,
name|mult_val
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|int
name|dest_regno
decl_stmt|;
name|rtx
modifier|*
name|inc_val
decl_stmt|;
name|rtx
modifier|*
name|mult_val
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|arg
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|dest_regno
condition|)
name|arg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|dest_regno
condition|)
name|arg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
if|if
condition|(
name|invariant_p
argument_list|(
name|arg
argument_list|)
operator|==
literal|1
condition|)
operator|*
name|inc_val
operator|=
name|arg
expr_stmt|;
else|else
return|return
literal|0
return|;
operator|*
name|mult_val
operator|=
name|const1_rtx
expr_stmt|;
return|return
literal|1
return|;
case|case
name|MINUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|dest_regno
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
operator|*
name|inc_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
operator|*
name|mult_val
operator|=
name|const1_rtx
expr_stmt|;
return|return
literal|1
return|;
comment|/* Can accept constant setting of biv only when inside inner most loop.   	 Otherwise, a biv of an inner loop may be incorrectly recognized 	 as a biv of the outer loop, 	 causing code to be moved INTO the inner loop.  */
case|case
name|REG
case|:
if|if
condition|(
operator|!
name|invariant_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
if|if
condition|(
name|loops_enclosed
operator|==
literal|1
condition|)
block|{
operator|*
name|inc_val
operator|=
name|x
expr_stmt|;
operator|*
name|mult_val
operator|=
name|const0_rtx
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A general induction variable (giv) is any quantity that is a linear function    of a basic induction variable, i.e. giv = biv * mult_val + add_val.    The coefficients can be any loop invariant quantity.    A giv need not be computed directly from the biv;    it can be computed by way of other givs.  */
end_comment

begin_comment
comment|/* Determine whether X computes a giv.    If it does, return a nonzero value      which is the benefit from eliminating the computation of X;    set *SRC_REGNO to the register number of the biv that it is computed from;    set *ADD_VAL and *MULT_VAL to the coefficients,      such that the value of X is biv * mult + add;    set forces (and forces2) to identify any other givs that are used      solely to compute this one.  */
end_comment

begin_comment
comment|/* This routine recognizes four types of patterns that generate givs:    - giv = biv op invariant             v = 0,    g = 0    - giv1 = giv2 op invariant           v = 0,    g = giv2        where giv1 and giv2 are functions of the same biv    - giv1 = biv op giv2                 v = giv2, g = 0        where giv2 is a function of biv    - giv1 = giv2 op giv3                v = giv3, g = giv2        where giv2 and giv3 are functions of the save biv  */
end_comment

begin_function
specifier|static
name|int
name|general_induction_var
parameter_list|(
name|x
parameter_list|,
name|src_regno
parameter_list|,
name|add_val
parameter_list|,
name|mult_val
parameter_list|,
name|forces
parameter_list|,
name|forces2
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
modifier|*
name|src_regno
decl_stmt|;
name|rtx
modifier|*
name|add_val
decl_stmt|;
name|rtx
modifier|*
name|mult_val
decl_stmt|;
name|struct
name|induction
modifier|*
modifier|*
name|forces
decl_stmt|;
name|struct
name|induction
modifier|*
modifier|*
name|forces2
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|arg
decl_stmt|;
name|struct
name|induction
modifier|*
name|g
init|=
literal|0
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
init|=
literal|0
decl_stmt|;
name|int
name|subexp
init|=
literal|0
decl_stmt|;
name|int
name|tem
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NEG
case|:
comment|/* This can generate givs also, but it is not handled.  */
return|return
literal|0
return|;
case|case
name|MULT
case|:
case|case
name|UMULT
case|:
comment|/* Reject widening multiply in version 1. 	 That is safer than trying to handle it.  */
block|{
name|enum
name|machine_mode
name|m0
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|m1
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|m0
operator|!=
name|VOIDmode
operator|&&
name|m0
operator|!=
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|m1
operator|!=
name|VOIDmode
operator|&&
name|m1
operator|!=
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
comment|/* Result is linear in both operands.  */
comment|/* Determine which operand is the biv, and put the other in ARG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|induct_var
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|==
name|BASIC_INDUCT
condition|)
block|{
operator|*
name|src_regno
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|induct_var
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
operator|==
name|BASIC_INDUCT
condition|)
block|{
operator|*
name|src_regno
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Check for an rtl subexpression that is a giv.  Memory address 	 givs often look like (plus (reg) (mult (biv) (const))).  */
comment|/* Do this before checking for a giv operand, as this function will 	 fail if this special operand is not recognized.  */
ifndef|#
directive|ifndef
name|DONT_REDUCE_ADDR
elseif|else
if|if
condition|(
name|tem
operator|=
name|general_induction_var
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|src_regno
argument_list|,
name|add_val
argument_list|,
name|mult_val
argument_list|,
name|forces
argument_list|,
name|forces2
argument_list|)
operator|&&
name|code
operator|!=
name|MINUS
condition|)
block|{
comment|/* Set subexp true so that this can be handled a little 	     differently from the normal case of g set.  */
comment|/* Note that SRC_REGNO is already set.  */
name|subexp
operator|=
name|TRUE
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|induction
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|induction
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|mult_val
operator|=
operator|*
name|mult_val
expr_stmt|;
name|g
operator|->
name|add_val
operator|=
operator|*
name|add_val
expr_stmt|;
comment|/* Fake out the test below.  */
name|g
operator|->
name|replaceable
operator|=
literal|1
expr_stmt|;
comment|/* Count this multiply as a shift, since that's what it 	     really will do.  */
if|if
condition|(
name|tem
operator|==
name|MULT_BENEFIT
condition|)
name|g
operator|->
name|benefit
operator|=
name|SHIFT_BENEFIT
expr_stmt|;
else|else
name|g
operator|->
name|benefit
operator|=
name|tem
expr_stmt|;
name|arg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tem
operator|=
name|general_induction_var
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|src_regno
argument_list|,
name|add_val
argument_list|,
name|mult_val
argument_list|,
name|forces
argument_list|,
name|forces2
argument_list|)
condition|)
block|{
comment|/* Set subexp true so that this can be handled a little 	     differently from the normal case of g set.  */
comment|/* Note that SRC_REGNO is already set.  */
name|subexp
operator|=
name|TRUE
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|induction
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|induction
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|mult_val
operator|=
operator|*
name|mult_val
expr_stmt|;
name|g
operator|->
name|add_val
operator|=
operator|*
name|add_val
expr_stmt|;
comment|/* Fake out the test below.  */
name|g
operator|->
name|replaceable
operator|=
literal|1
expr_stmt|;
comment|/* Count this multiply as a shift, since that's what it 	     really will do.  */
if|if
condition|(
name|tem
operator|==
name|MULT_BENEFIT
condition|)
name|g
operator|->
name|benefit
operator|=
name|SHIFT_BENEFIT
expr_stmt|;
else|else
name|g
operator|->
name|benefit
operator|=
name|tem
expr_stmt|;
name|arg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Also allow general induction variables. 	 Could have a mult followed by an add (i.e. an address calculation), 	 thereby generating two related general induction variables 	 of which only the second is actually used.  */
comment|/* Do this after checking both args for basic induction variables.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|induct_var
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|==
name|GENERAL_INDUCT
condition|)
block|{
name|g
operator|=
name|induct_struct
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
operator|*
name|src_regno
operator|=
name|g
operator|->
name|src_regno
expr_stmt|;
name|arg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|induct_var
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
operator|==
name|GENERAL_INDUCT
operator|&&
name|code
operator|!=
name|MINUS
condition|)
block|{
name|g
operator|=
name|induct_struct
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
index|]
expr_stmt|;
operator|*
name|src_regno
operator|=
name|g
operator|->
name|src_regno
expr_stmt|;
name|arg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
comment|/* Overall form of expression looks good.  */
break|break;
comment|/* Could handle these also.  */
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
comment|/* For a 68020 could handle these? */
case|case
name|LSHIFT
case|:
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
comment|/* These operations are linear only in first operand. 	 Check for a biv or giv there; if found, put other operand in ARG.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|induct_var
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|==
name|BASIC_INDUCT
condition|)
block|{
operator|*
name|src_regno
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Also allow general induction variable.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|induct_var
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|==
name|GENERAL_INDUCT
condition|)
block|{
name|g
operator|=
name|induct_struct
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
expr_stmt|;
operator|*
name|src_regno
operator|=
name|g
operator|->
name|src_regno
expr_stmt|;
name|arg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
comment|/* Overall form of expression looks good.  */
break|break;
default|default:
return|return
literal|0
return|;
block|}
comment|/* ARG is the operand that is NOT a biv or giv.      Test it for superficial validity.  */
comment|/* This is just a special case of invariant values,      it is not really needed, but it's a shortcut.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONST_INT
condition|)
empty_stmt|;
comment|/* Depends on previous general induction variable, which has      the same basic induction variable */
comment|/* This code detects mults that have been generated as shift and add.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REG
operator|&&
name|induct_var
index|[
name|REGNO
argument_list|(
name|arg
argument_list|)
index|]
operator|==
name|GENERAL_INDUCT
operator|&&
name|induct_struct
index|[
name|REGNO
argument_list|(
name|arg
argument_list|)
index|]
operator|->
name|src_regno
operator|==
operator|*
name|src_regno
condition|)
block|{
name|v
operator|=
name|induct_struct
index|[
name|REGNO
argument_list|(
name|arg
argument_list|)
index|]
expr_stmt|;
comment|/* Dependence indicated by forces, sort of kludgey.  */
block|}
comment|/* Invariant expression, could be a constant-valued register. */
elseif|else
if|if
condition|(
name|invariant_p
argument_list|(
name|arg
argument_list|)
operator|==
literal|1
condition|)
empty_stmt|;
comment|/* Failure */
else|else
return|return
literal|0
return|;
comment|/* Until we can do the correct thing, suppress use of nonreplaceable givs      as sources for other givs.  */
if|if
condition|(
operator|(
name|g
operator|&&
operator|!
name|g
operator|->
name|replaceable
operator|)
operator|||
operator|(
name|v
operator|&&
operator|!
name|v
operator|->
name|replaceable
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Now we know looks like a giv; extract the coefficients.      We can still fail if the coefficients are not what we can handle.  */
comment|/* Only succeed if result mult_val and add_val are only one level of rtl,      for example, (NEG:SI (REG:SI 34)) is not accepted.      This mainly causes problems with the MINUS code.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
if|if
condition|(
name|v
operator|&&
name|g
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|g
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|mult_val
operator|==
name|const0_rtx
condition|)
operator|*
name|mult_val
operator|=
name|v
operator|->
name|mult_val
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
condition|)
operator|*
name|mult_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|g
operator|->
name|mult_val
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|mult_val
operator|==
name|const0_rtx
condition|)
operator|*
name|mult_val
operator|=
name|g
operator|->
name|mult_val
expr_stmt|;
else|else
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|g
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|add_val
operator|==
name|const0_rtx
condition|)
operator|*
name|add_val
operator|=
name|v
operator|->
name|add_val
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
condition|)
operator|*
name|add_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|g
operator|->
name|add_val
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|add_val
operator|==
name|const0_rtx
condition|)
operator|*
name|add_val
operator|=
name|g
operator|->
name|add_val
expr_stmt|;
else|else
return|return
literal|0
return|;
if|if
condition|(
name|subexp
condition|)
block|{
comment|/* g deleted when return, can't return pointer to it */
if|if
condition|(
operator|*
name|forces2
operator|==
literal|0
condition|)
operator|*
name|forces2
operator|=
name|v
expr_stmt|;
return|return
name|ADD_BENEFIT
operator|+
name|g
operator|->
name|benefit
return|;
block|}
else|else
block|{
operator|*
name|forces
operator|=
name|g
expr_stmt|;
operator|*
name|forces2
operator|=
name|v
expr_stmt|;
return|return
name|ADD_BENEFIT
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|v
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
condition|)
operator|*
name|mult_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
operator|*
name|add_val
operator|=
name|v
operator|->
name|add_val
expr_stmt|;
operator|*
name|forces
operator|=
name|v
expr_stmt|;
return|return
name|ADD_BENEFIT
return|;
block|}
elseif|else
if|if
condition|(
name|g
condition|)
block|{
operator|*
name|mult_val
operator|=
name|g
operator|->
name|mult_val
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|g
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|nonmemory_operand
argument_list|(
name|arg
argument_list|,
name|GET_MODE
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
operator|*
name|add_val
operator|=
name|plus_constant
argument_list|(
name|arg
argument_list|,
name|INTVAL
argument_list|(
name|g
operator|->
name|add_val
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|nonmemory_operand
argument_list|(
name|g
operator|->
name|add_val
argument_list|,
name|GET_MODE
argument_list|(
name|g
operator|->
name|add_val
argument_list|)
argument_list|)
condition|)
operator|*
name|add_val
operator|=
name|plus_constant
argument_list|(
name|g
operator|->
name|add_val
argument_list|,
name|INTVAL
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Could succeed if arg == 0, but that will never occur.  */
return|return
literal|0
return|;
if|if
condition|(
name|subexp
condition|)
comment|/* g deleted when return, can't return pointer to it */
return|return
name|ADD_BENEFIT
operator|+
name|g
operator|->
name|benefit
return|;
else|else
block|{
operator|*
name|forces
operator|=
name|g
expr_stmt|;
return|return
name|ADD_BENEFIT
return|;
block|}
block|}
else|else
block|{
operator|*
name|mult_val
operator|=
name|const1_rtx
expr_stmt|;
operator|*
name|add_val
operator|=
name|arg
expr_stmt|;
return|return
name|ADD_BENEFIT
return|;
block|}
comment|/* Takes a lot of code and will rarely succeed.  */
case|case
name|MINUS
case|:
if|if
condition|(
name|v
operator|&&
name|g
condition|)
block|{
comment|/* G is the first argument of MINUS.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|g
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|mult_val
operator|==
name|const0_rtx
condition|)
if|#
directive|if
literal|0
comment|/* Should not have to fail here */
then|*mult_val = gen_rtx (NEG, SImode, v->mult_val);
endif|#
directive|endif
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
condition|)
operator|*
name|mult_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|g
operator|->
name|mult_val
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|mult_val
operator|==
name|const0_rtx
condition|)
operator|*
name|mult_val
operator|=
name|g
operator|->
name|mult_val
expr_stmt|;
else|else
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|g
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|add_val
operator|==
name|const0_rtx
condition|)
if|#
directive|if
literal|0
comment|/* should not have to fail here */
then|*add_val = v->add_val;
endif|#
directive|endif
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
condition|)
operator|*
name|add_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|g
operator|->
name|add_val
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|add_val
operator|==
name|const0_rtx
condition|)
operator|*
name|add_val
operator|=
name|g
operator|->
name|add_val
expr_stmt|;
else|else
return|return
literal|0
return|;
if|if
condition|(
name|subexp
condition|)
block|{
comment|/* G deleted when return, can't return pointer to it */
if|if
condition|(
operator|*
name|forces2
operator|==
literal|0
condition|)
operator|*
name|forces2
operator|=
name|v
expr_stmt|;
return|return
name|ADD_BENEFIT
operator|+
name|g
operator|->
name|benefit
return|;
block|}
else|else
block|{
operator|*
name|forces
operator|=
name|g
expr_stmt|;
operator|*
name|forces2
operator|=
name|v
expr_stmt|;
return|return
name|ADD_BENEFIT
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|v
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|arg
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* giv1 = giv2 - biv */
block|{
operator|*
name|mult_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|add_val
operator|=
name|v
operator|->
name|add_val
expr_stmt|;
block|}
else|else
comment|/* giv1 = biv - giv2 */
block|{
operator|*
name|mult_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
literal|1
operator|-
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
condition|)
operator|*
name|add_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
operator|*
name|forces
operator|=
name|v
expr_stmt|;
return|return
name|ADD_BENEFIT
return|;
block|}
elseif|else
if|if
condition|(
name|g
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
operator|*
name|mult_val
operator|=
name|g
operator|->
name|mult_val
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|g
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
condition|)
operator|*
name|mult_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|g
operator|->
name|mult_val
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|g
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|add_val
operator|==
name|const0_rtx
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* giv1 = giv2 - arg */
block|{
comment|/* Fail unless arg is a constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONST_INT
condition|)
operator|*
name|add_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
else|else
comment|/* giv1 = arg - giv2 */
operator|*
name|add_val
operator|=
name|arg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* giv1 = giv2 - arg */
operator|*
name|add_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|g
operator|->
name|add_val
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* giv1 = arg - giv2 */
operator|*
name|add_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|arg
argument_list|)
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|g
operator|->
name|add_val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
else|else
comment|/* Could succeed if arg == 0, but that will never occur.  */
return|return
literal|0
return|;
if|if
condition|(
name|subexp
condition|)
comment|/* G deleted when return, can't return pointer to it.  */
return|return
name|ADD_BENEFIT
operator|+
name|g
operator|->
name|benefit
return|;
else|else
block|{
operator|*
name|forces
operator|=
name|g
expr_stmt|;
return|return
name|ADD_BENEFIT
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
operator|*
name|add_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|mult_val
operator|=
name|const1_rtx
expr_stmt|;
block|}
else|else
block|{
operator|*
name|add_val
operator|=
name|arg
expr_stmt|;
operator|*
name|mult_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|ADD_BENEFIT
return|;
block|}
else|else
return|return
literal|0
return|;
comment|/* UMULT can be handled like MULT since C ignores overflows.  */
case|case
name|MULT
case|:
case|case
name|UMULT
case|:
if|if
condition|(
name|v
operator|&&
name|g
condition|)
block|{
comment|/* Quadratic term, just fail.  */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|v
condition|)
block|{
comment|/* Quadratic term, just fail.  */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|g
condition|)
block|{
comment|/* Takes a lot of code and will rarely succeed.  */
comment|/* dest = m * arg * b + a * arg */
if|if
condition|(
name|GET_CODE
argument_list|(
name|g
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|mult_val
operator|==
name|const0_rtx
condition|)
operator|*
name|mult_val
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|g
operator|->
name|mult_val
operator|==
name|const1_rtx
condition|)
operator|*
name|mult_val
operator|=
name|arg
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONST_INT
condition|)
operator|*
name|mult_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|g
operator|->
name|mult_val
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
else|else
comment|/* Could suceed if arg == 1 or 0, but this will never occur.  */
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|g
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|add_val
operator|==
name|const0_rtx
condition|)
operator|*
name|add_val
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|g
operator|->
name|add_val
operator|==
name|const1_rtx
condition|)
operator|*
name|add_val
operator|=
name|arg
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONST_INT
condition|)
operator|*
name|add_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|g
operator|->
name|add_val
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
else|else
comment|/* Could suceed if arg == 1 or 0, but this will never occur.  */
return|return
literal|0
return|;
if|if
condition|(
name|subexp
condition|)
comment|/* G deleted when return, can't return pointer to it.  */
return|return
name|MULT_BENEFIT
operator|+
name|g
operator|->
name|benefit
return|;
else|else
block|{
operator|*
name|forces
operator|=
name|g
expr_stmt|;
return|return
name|MULT_BENEFIT
return|;
block|}
block|}
else|else
block|{
operator|*
name|mult_val
operator|=
name|arg
expr_stmt|;
operator|*
name|add_val
operator|=
name|const0_rtx
expr_stmt|;
return|return
name|MULT_BENEFIT
return|;
block|}
comment|/* These are not worth the trouble.  */
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
return|return
literal|0
return|;
comment|/* Handle these, but only for left shift.  */
case|case
name|LSHIFT
case|:
case|case
name|ASHIFT
case|:
if|if
condition|(
name|v
operator|&&
name|g
condition|)
block|{
comment|/* Quadratic term, just fail.  */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|v
condition|)
block|{
comment|/* Quadratic term, just fail.  */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|g
condition|)
block|{
comment|/* Takes a lot of code and will rarely succeed.  */
comment|/* dest = ((m * b)<< arg) + (a<< arg) */
if|if
condition|(
name|GET_CODE
argument_list|(
name|g
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|mult_val
operator|==
name|const0_rtx
condition|)
operator|*
name|mult_val
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|arg
argument_list|)
operator|>=
literal|0
condition|)
operator|*
name|mult_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|g
operator|->
name|mult_val
argument_list|)
operator|*
operator|(
literal|1
operator|<<
name|INTVAL
argument_list|(
name|arg
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
else|else
comment|/* Could suceed if arg == 0, but this will never occur.  */
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|g
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|add_val
operator|==
name|const0_rtx
condition|)
operator|*
name|add_val
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONST_INT
condition|)
operator|*
name|add_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|INTVAL
argument_list|(
name|g
operator|->
name|add_val
argument_list|)
operator|*
operator|(
literal|1
operator|<<
name|INTVAL
argument_list|(
name|arg
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
else|else
comment|/* Could suceed if arg == 0, but this will never occur.  */
return|return
literal|0
return|;
if|if
condition|(
name|subexp
condition|)
comment|/* G deleted when return, can't return pointer to it.  */
return|return
name|SHIFT_BENEFIT
operator|+
name|g
operator|->
name|benefit
return|;
else|else
block|{
operator|*
name|forces
operator|=
name|g
expr_stmt|;
return|return
name|SHIFT_BENEFIT
return|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|arg
argument_list|)
operator|>=
literal|0
condition|)
operator|*
name|mult_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
literal|1
operator|<<
name|INTVAL
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
operator|*
name|add_val
operator|=
name|const0_rtx
expr_stmt|;
return|return
name|SHIFT_BENEFIT
return|;
comment|/* These are not worth the trouble.  */
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
return|return
literal|0
return|;
comment|/* should never reach here */
default|default:
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Help detect a giv that is calculated by several consecutive insns;    for example,       giv = biv * M       giv = giv + A    The caller has already identified the first insn P as having a giv as dest;    we check that all other insns that set the same register follow    immediately after P, that they alter nothing else,    and that the result of the last is still a giv.     The value is 0 if the reg set in P is not really a giv.    Otherwise, the value is the amount gained by eliminating    all the consecutive insns that compute the value.     FIRST_BENEFIT is the amount gained by eliminating the first insn, P.    SRC_REGNO is the regno of the biv; DEST_REGNO is that of the giv.     The coefficients of the ultimate giv value are stored in    *MULT_VAL and *ADD_VAL.  */
end_comment

begin_function
specifier|static
name|int
name|consec_sets_giv
parameter_list|(
name|first_benefit
parameter_list|,
name|p
parameter_list|,
name|src_regno
parameter_list|,
name|dest_regno
parameter_list|,
name|add_val
parameter_list|,
name|mult_val
parameter_list|)
name|int
name|first_benefit
decl_stmt|;
name|rtx
name|p
decl_stmt|;
name|int
name|src_regno
decl_stmt|;
name|int
name|dest_regno
decl_stmt|;
name|rtx
modifier|*
name|add_val
decl_stmt|;
name|rtx
modifier|*
name|mult_val
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
name|int
name|benefit
init|=
name|first_benefit
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|struct
name|induction
modifier|*
name|forces
decl_stmt|,
modifier|*
name|forces2
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|int
name|tem
decl_stmt|;
comment|/* Initialize info used by general_induction_var.  */
name|struct
name|induction
modifier|*
name|v
init|=
operator|(
expr|struct
name|induction
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|induction
argument_list|)
argument_list|)
decl_stmt|;
name|v
operator|->
name|src_regno
operator|=
name|src_regno
expr_stmt|;
name|v
operator|->
name|mult_val
operator|=
operator|*
name|mult_val
expr_stmt|;
name|v
operator|->
name|add_val
operator|=
operator|*
name|add_val
expr_stmt|;
name|induct_var
index|[
name|dest_regno
index|]
operator|=
name|GENERAL_INDUCT
expr_stmt|;
name|induct_struct
index|[
name|dest_regno
index|]
operator|=
name|v
expr_stmt|;
name|count
operator|=
name|n_times_set
index|[
name|dest_regno
index|]
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* If libcall, skip to end of call sequence.  */
if|if
condition|(
name|code
operator|==
name|INSN
operator|&&
operator|(
name|temp
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_LIBCALL
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
name|p
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|==
name|dest_regno
operator|&&
operator|(
operator|(
name|tem
operator|=
name|general_induction_var
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
operator|&
name|src_regno
argument_list|,
name|add_val
argument_list|,
name|mult_val
argument_list|,
operator|&
name|forces
argument_list|,
operator|&
name|forces2
argument_list|)
operator|)
comment|/* Giv created by call to library routine.  */
operator|||
operator|(
operator|(
name|temp
operator|=
name|loop_find_reg_equal
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
operator|(
name|tem
operator|=
name|general_induction_var
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|src_regno
argument_list|,
name|add_val
argument_list|,
name|mult_val
argument_list|,
operator|&
name|forces
argument_list|,
operator|&
name|forces2
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|src_regno
operator|==
name|v
operator|->
name|src_regno
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|benefit
operator|+=
name|tem
expr_stmt|;
name|v
operator|->
name|mult_val
operator|=
operator|*
name|mult_val
expr_stmt|;
name|v
operator|->
name|add_val
operator|=
operator|*
name|add_val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
block|{
name|induct_var
index|[
name|dest_regno
index|]
operator|=
name|UNKNOWN_INDUCT
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|benefit
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a SEQUENCE to multiply OP0 and OP1 with result in TARGET.    Use expand_mult to "optimally" do the multiply.    This also works for machines that do not have multiply insns.    If one of the operands is a constant, it must be the second.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_iv_mult
parameter_list|(
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|target
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|target
decl_stmt|;
block|{
specifier|extern
name|rtx
name|gen_sequence
parameter_list|()
function_decl|;
specifier|extern
name|rtx
name|start_sequence
parameter_list|()
function_decl|;
name|rtx
name|saved
decl_stmt|,
name|result
decl_stmt|,
name|temp
decl_stmt|;
name|saved
operator|=
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* ??? It is very unmodular to use expand_mult here!      This should be redesigned.  */
comment|/* UNSIGNEDP arg can be zero since operands/target always same width.  */
name|temp
operator|=
name|expand_mult
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Move to target register, if expand_mult did not put it there.  */
if|if
condition|(
name|target
operator|!=
literal|0
operator|&&
name|temp
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|result
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|(
name|saved
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Emit code to initialize an induction variable created by strength    reduction.    More precisely, emit code before INSERT_BEFORE    to set REG = B * M + A.  */
end_comment

begin_function
specifier|static
name|void
name|emit_iv_init_code
parameter_list|(
name|b
parameter_list|,
name|m
parameter_list|,
name|a
parameter_list|,
name|reg
parameter_list|,
name|insert_before
parameter_list|)
name|rtx
name|b
decl_stmt|;
comment|/* initial value of basic induction variable */
name|rtx
name|m
decl_stmt|;
comment|/* multiplicative constant */
name|rtx
name|a
decl_stmt|;
comment|/* additive constant */
name|rtx
name|reg
decl_stmt|;
comment|/* destination register */
name|rtx
name|insert_before
decl_stmt|;
block|{
name|rtx
name|seq
decl_stmt|;
name|rtx
name|result
decl_stmt|;
comment|/* Prevent unexpected sharing of these rtx.  */
name|a
operator|=
name|copy_rtx
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|b
operator|=
name|copy_rtx
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|result
operator|=
name|expand_mult_add
argument_list|(
name|b
argument_list|,
name|m
argument_list|,
name|a
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|result
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insert_before
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code to increment the induction variable inside the loop.    Try to emit optimal code for the expression    REG = REG + BIV_ADD * GIV_MULT.  */
end_comment

begin_function
specifier|static
name|void
name|emit_iv_inc
parameter_list|(
name|biv_add
parameter_list|,
name|giv_mult
parameter_list|,
name|reg
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|biv_add
decl_stmt|;
comment|/* increment value for biv */
name|rtx
name|giv_mult
decl_stmt|;
comment|/* multiply value of giv */
name|rtx
name|reg
decl_stmt|;
comment|/* create insn to set this reg */
name|rtx
name|insn
decl_stmt|;
comment|/* where to insert the new insn */
block|{
name|emit_iv_init_code
argument_list|(
name|biv_add
argument_list|,
name|giv_mult
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Test whethen BIV_ADD * GIV_MULT can be computed without    an actual multiply insn.  Value is 1 if so.  */
end_comment

begin_function
specifier|static
name|int
name|product_cheap_p
parameter_list|(
name|biv_add
parameter_list|,
name|giv_mult
parameter_list|)
name|rtx
name|biv_add
decl_stmt|;
name|rtx
name|giv_mult
decl_stmt|;
block|{
comment|/* Indicates which of MULT/ADD are constants.  */
name|int
name|status
init|=
literal|0
decl_stmt|;
name|int
name|const_val
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|biv_add
argument_list|)
operator|==
name|CONST_INT
condition|)
name|status
operator||=
literal|0x1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|giv_mult
argument_list|)
operator|==
name|CONST_INT
condition|)
name|status
operator||=
literal|0x2
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
literal|0
case|:
comment|/* Neither is constant: would need a multiply insn, so fail.  */
return|return
literal|0
return|;
case|case
literal|1
case|:
comment|/* BIV_ADD value is constant */
comment|/* Equivalent to state 2, just switch values of BIV_ADD and GIV_MULT 	 and fall through.  */
name|tmp
operator|=
name|biv_add
expr_stmt|;
name|biv_add
operator|=
name|giv_mult
expr_stmt|;
name|giv_mult
operator|=
name|tmp
expr_stmt|;
case|case
literal|2
case|:
comment|/* GIV_MULT value is constant. 	 If it is 1, 0 or -1 then we win.  */
name|const_val
operator|=
name|INTVAL
argument_list|(
name|giv_mult
argument_list|)
expr_stmt|;
if|if
condition|(
name|const_val
operator|<
operator|-
literal|1
operator|||
name|const_val
operator|>
literal|1
condition|)
block|{
name|tmp
operator|=
name|gen_iv_mult
argument_list|(
name|GET_MODE
argument_list|(
name|biv_add
argument_list|)
argument_list|,
name|biv_add
argument_list|,
name|giv_mult
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't emit a multiply insn, just fail instead.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|MULT
operator|)
comment|/* Also fail if library call (which generates more 		    then two insn) is needed.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SEQUENCE
operator|&&
name|XVECLEN
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
operator|>
literal|2
operator|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
case|case
literal|3
case|:
comment|/* Both BIV_ADD and GIV_MULT are constant; 	 can compute the product at compile time.  */
return|return
literal|1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check to see if loop can be terminated by a "decrement and branch until    zero" instruction.  If so, add a REG_NONNEG note to the branch insn if so.    Also try reversing an increment loop to a decrement loop    to see if the optimization can be performed.    Value is nonzero if optimization was performed.  */
end_comment

begin_function
specifier|static
name|int
name|check_dbra_loop
parameter_list|(
name|loop_end
parameter_list|,
name|iv_list
parameter_list|,
name|insn_count
parameter_list|,
name|loop_start
parameter_list|)
name|rtx
name|loop_end
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|iv_list
decl_stmt|;
name|int
name|insn_count
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|;
block|{
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|jump_label
decl_stmt|;
name|rtx
name|final_value
decl_stmt|;
name|rtx
name|start_value
decl_stmt|;
name|enum
name|rtx_code
name|branch_code
decl_stmt|;
name|rtx
name|new_add_val
decl_stmt|;
name|rtx
name|tested_before_loop
init|=
literal|0
decl_stmt|;
name|rtx
name|p
decl_stmt|;
comment|/* See if the loop is contained in  `if (X>= 0)' for some reg X.      If so, then we know X is initially nonnegative even though      we don't know its initial value.      Record X in TESTED_BEFORE_LOOP.  */
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|!=
name|NOTE
condition|)
break|break;
comment|/* See if a conditional branch preceeds the loop.      There may be no other insns or labels between it and      the beginning of the loop.  */
if|if
condition|(
name|p
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|condjump_p
argument_list|(
name|p
argument_list|)
operator|&&
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
name|pc_rtx
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LT
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|==
name|pc_rtx
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GE
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
operator|)
operator|)
operator|&&
name|next_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|next_real_insn
argument_list|(
name|loop_end
argument_list|)
condition|)
block|{
comment|/* Before the branch should be a test or compare. 	 See if we are comparing something against zero.  */
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|cc0_rtx
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|tested_before_loop
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|==
name|COMPARE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
name|tested_before_loop
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
operator|==
name|COMPARE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|const0_rtx
condition|)
name|tested_before_loop
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If last insn is a conditional branch, and the insn before tests a register      value, then try to optimize it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CC0
operator|)
condition|)
block|{
comment|/* Check all of the bivs to see if the compare uses one of them.  */
for|for
control|(
name|bl
operator|=
name|iv_list
init|;
name|bl
condition|;
name|bl
operator|=
name|bl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
block|}
comment|/* If biv set more than once, then give up. 	 We can't guarantee that it will be zero on the last iteration. 	 Also give up if the biv is used between its update and the test 	 insn.  */
if|if
condition|(
name|bl
operator|&&
name|bl
operator|->
name|biv_count
operator|==
literal|1
operator|&&
operator|!
name|reg_used_between_p
argument_list|(
name|regno_reg_rtx
index|[
name|bl
operator|->
name|regno
index|]
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|,
name|PREV_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Look for the case where the basic induction variable is always 	     nonnegative, and equals zero on the last iteration. 	     In this case, add a reg_note REG_NONNEG, which allows the 	     m68k DBRA instruction to be used.  */
comment|/* the decrement case */
if|if
condition|(
name|GET_CODE
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Initial value must be greater than 0, 		 init_val % -dec_value == 0 to ensure that it equals zero on 		    the last iteration */
if|if
condition|(
name|GET_CODE
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|INTVAL
argument_list|(
name|bl
operator|->
name|initial_value
argument_list|)
operator|%
operator|(
operator|-
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* register always nonnegative, add REG_NOTE to branch */
name|REG_NOTES
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_NONNEG
argument_list|,
literal|0
argument_list|,
name|REG_NOTES
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bl
operator|->
name|nonneg
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* If the decrement is 1 and the value was tested as>= 0 before 		 the loop, then we can safely optimize.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
argument_list|)
operator|==
name|tested_before_loop
operator|&&
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|REG_NOTES
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_NONNEG
argument_list|,
literal|0
argument_list|,
name|REG_NOTES
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bl
operator|->
name|nonneg
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|num_mem_sets
operator|<=
literal|1
condition|)
block|{
comment|/* Try to change inc to dec, so can apply above optimization.  */
comment|/* Can do this if: 		 all registers modified are induction variables or invariant, 		 all memory references have non-overlapping addresses                        (obviously true if only one write) 	         allow 2 insns for the compare/jump at the end of the loop.  */
name|int
name|num_nonfixed_reads
init|=
literal|0
decl_stmt|;
name|rtx
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
operator|!=
name|loop_end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|num_nonfixed_reads
operator|+=
name|count_nonfixed_reads
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This code only acts for innermost loops.  Also it simplifies 		 the memory address check by only reversing loops with 		 zero or one memory access. 		 Two memory accesses could involve parts of the same array, 		 and that can't be reversed.  */
if|if
condition|(
name|num_nonfixed_reads
operator|<=
literal|1
operator|&&
operator|!
name|loop_has_call
operator|&&
operator|(
name|bl
operator|->
name|giv_count
operator|+
name|bl
operator|->
name|biv_count
operator|+
name|num_mem_sets
operator|+
name|num_movables
operator|+
literal|2
operator|==
name|insn_count
operator|)
condition|)
block|{
name|rtx
name|src_two_before_end
decl_stmt|;
name|int
name|constant
decl_stmt|;
name|int
name|win
decl_stmt|;
comment|/* Loop can be reversed.  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Can reverse loop\n"
argument_list|)
expr_stmt|;
comment|/* Now check other conditions: 		     initial_value must be zero, 		     final_value % add_val == 0, so that when reversed, the 		     biv will be zero on the last iteration.  */
comment|/* Calculating the final value non trivial. 		     If branch is (LT (CC0) (CONST 0), 		     then value in compare is final value. 		     If branch is (LE (CC0) (CONST 0), 		     then value in compare is final_value - add_val */
name|branch_code
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src_two_before_end
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|win
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_two_before_end
argument_list|)
operator|==
name|REG
condition|)
name|constant
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src_two_before_end
argument_list|)
operator|==
name|COMPARE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src_two_before_end
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|constant
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src_two_before_end
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|win
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|win
operator|&&
name|bl
operator|->
name|initial_value
operator|==
name|const0_rtx
operator|&&
operator|(
name|branch_code
operator|==
name|LT
operator|||
name|branch_code
operator|==
name|LE
operator|)
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
operator|&&
operator|(
name|constant
operator|%
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Register will always be nonnegative, with value 			 0 on last iteration if loop reversed */
comment|/* Save some info needed to produce the new insns.  */
name|reg
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|jump_label
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_add_val
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch_code
operator|==
name|LT
condition|)
block|{
name|final_value
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|constant
argument_list|)
expr_stmt|;
name|start_value
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|constant
operator|-
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* branch_code == LE */
block|{
name|start_value
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|constant
argument_list|)
expr_stmt|;
name|final_value
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|constant
operator|+
name|INTVAL
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|add_val
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize biv to start_value before loop start. 			 The old initializing insn will be deleted as a 			 dead store by flow.c.  */
name|emit_insn_before
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|start_value
argument_list|)
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
comment|/* Add insn to decrement register, and delete insn 			 that incremented the register.  */
name|emit_insn_before
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|reg
argument_list|,
name|new_add_val
argument_list|)
argument_list|)
argument_list|,
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
expr_stmt|;
comment|/* Update biv info to reflect its new status.  */
name|bl
operator|->
name|biv
operator|->
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Inc LABEL_NUSES so that delete_insn will 			 not delete the label.  */
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|jump_label
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|regno_last_uid
index|[
name|bl
operator|->
name|regno
index|]
operator|!=
name|INSN_UID
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
condition|)
name|emit_insn_after
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|final_value
argument_list|)
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
comment|/* Delete compare/branch at end of loop.  */
name|delete_insn
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add new compare/branch insn at end of loop.  */
name|emit_insn_before
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|cc0_rtx
argument_list|,
name|reg
argument_list|)
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
name|emit_jump_insn_before
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|IF_THEN_ELSE
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|GE
argument_list|,
name|VOIDmode
argument_list|,
name|cc0_rtx
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|jump_label
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
argument_list|,
name|loop_end
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
operator|=
name|XEXP
argument_list|(
name|jump_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Increment of LABEL_NUSES done above. */
comment|/* Register is now always nonnegative, 			 so add REG_NONNEG note to the branch.  */
name|REG_NOTES
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_NONNEG
argument_list|,
literal|0
argument_list|,
name|REG_NOTES
argument_list|(
name|PREV_INSN
argument_list|(
name|loop_end
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bl
operator|->
name|nonneg
operator|=
literal|1
expr_stmt|;
comment|/* Update rest of biv info.  */
name|bl
operator|->
name|initial_value
operator|=
name|start_value
expr_stmt|;
name|bl
operator|->
name|biv
operator|->
name|add_val
operator|=
name|new_add_val
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Reversed loop and added reg_nonneg\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Verify whether the biv BL appears to be eliminable,    based on the insns in the loop that refer to it.    LOOP_START is the first insn of the loop, and END is the end insn.  */
end_comment

begin_function
specifier|static
name|void
name|check_eliminate_biv
parameter_list|(
name|bl
parameter_list|,
name|loop_start
parameter_list|,
name|end
parameter_list|)
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|;
name|rtx
name|end
decl_stmt|;
block|{
comment|/* Get the REG rtx for the biv.  */
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|bl
operator|->
name|biv
operator|->
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|p
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
decl_stmt|;
name|bl
operator|->
name|eliminable
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|loop_start
init|;
name|p
operator|!=
name|end
condition|;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
control|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|==
name|INSN
operator|||
name|code
operator|==
name|JUMP_INSN
operator|||
name|code
operator|==
name|CALL_INSN
operator|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This insn uses the biv.  If we can't understand it, 	     then we can't eliminate the biv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
block|{
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Cannot eliminate biv %d: cannot understand insn %d.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|,
name|INSN_UID
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* The insns that increment the biv are no problem.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|reg
condition|)
continue|continue;
comment|/* If this is an insn which uses the biv ONLY in the 	     calculation of a giv which is in the family of this 	     biv, it's ok becuase it will go away when the giv is 	     reduced.  March 14, 1989 -- self@bayes.arc.nasa.gov */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|family
control|)
if|if
condition|(
name|v
operator|->
name|insn
operator|==
name|p
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_REG
operator|||
operator|(
name|v
operator|->
name|giv_type
operator|==
name|DEST_ADDR
operator|&&
operator|!
name|other_reg_use_p
argument_list|(
name|reg
argument_list|,
operator|*
operator|(
name|v
operator|->
name|location
operator|)
argument_list|,
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|v
condition|)
continue|continue;
comment|/* If can rewrite this insn not to use the biv, it's ok.  */
if|if
condition|(
name|can_eliminate_biv_p
argument_list|(
name|p
argument_list|,
name|bl
argument_list|)
condition|)
continue|continue;
comment|/* Biv is used in a way we cannot eliminate.  */
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Cannot eliminate biv %d: biv used in insn %d.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|,
name|INSN_UID
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
name|bl
operator|->
name|eliminable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Can eliminate biv %d.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if INSN, a compare insn which tests the biv described by BL,    can be rewritten to use instead some reduced giv related to that biv.    Does not change the rtl.     We make the assumption that all the givs depending on this biv    will be reduced, since only in that case will an attempt to eliminate    the biv actually be made.     The following function is very parallel to this one.  */
end_comment

begin_function
specifier|static
name|int
name|can_eliminate_biv_p
parameter_list|(
name|insn
parameter_list|,
name|bl
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
block|{
name|rtx
name|src
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
decl_stmt|,
modifier|*
name|tv
decl_stmt|;
name|rtx
name|arg
decl_stmt|;
name|int
name|arg_operand
decl_stmt|;
comment|/* Mode of this biv.  */
name|enum
name|machine_mode
name|mode
init|=
name|bl
operator|->
name|biv
operator|->
name|mode
decl_stmt|;
if|if
condition|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|cc0_rtx
condition|)
return|return
literal|0
return|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|src
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* a test insn */
case|case
name|REG
case|:
comment|/* Can replace with any giv that has (MULT_VAL != 0) and (ADD_VAL == 0) 	 Require a constant integer for MULT_VAL, so we know it's nonzero.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|family
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|v
operator|->
name|mult_val
operator|!=
name|const0_rtx
operator|&&
name|v
operator|->
name|add_val
operator|==
name|const0_rtx
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
condition|)
return|return
literal|1
return|;
comment|/* Look for a giv with (MULT_VAL != 0) and (ADD_VAL != 0) 	 where ADD_VAL is a constant or a register; 	 can replace test insn with a compare insn (cmp REDUCED_GIV ADD_VAL). 	 Require a constant integer for MULT_VAL, so we know it's nonzero.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|family
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|v
operator|->
name|mult_val
operator|!=
name|const0_rtx
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|loop_dump_stream
condition|)
name|fprintf
argument_list|(
name|loop_dump_stream
argument_list|,
literal|"Cannot eliminate biv %d in test insn %d: no appropriate giv.\n"
argument_list|,
name|bl
operator|->
name|regno
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* a compare insn */
case|case
name|COMPARE
case|:
comment|/* Figure out which operand is the biv.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|bl
operator|->
name|regno
operator|)
condition|)
block|{
name|arg
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arg_operand
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|bl
operator|->
name|regno
operator|)
condition|)
block|{
name|arg
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg_operand
operator|=
literal|0
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* Can replace with any giv that has constant coefficients.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|family
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
condition|)
return|return
literal|1
return|;
comment|/* Look for giv with constant mult_val and nonconst add_val, 	     since we can insert add insn before loop 	     to calculate new compare value.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|family
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Comparing against invariant register or memref can be handled.  */
if|if
condition|(
name|invariant_p
argument_list|(
name|arg
argument_list|)
condition|)
block|{
comment|/* Look for giv with constant mult_val and nonconst add_val. 		 Insert add-insn before loop to compute new compare value.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|family
control|)
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|!
name|v
operator|->
name|ignore
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
condition|)
return|return
literal|1
return|;
block|}
comment|/* Otherwise, only comparing against a biv can be handled.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|REG
operator|||
name|induct_var
index|[
name|REGNO
argument_list|(
name|arg
argument_list|)
index|]
operator|!=
name|BASIC_INDUCT
condition|)
return|return
literal|0
return|;
comment|/* Look for a giv for each biv that have identical 	     values for mult_val and add_val.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|family
control|)
if|if
condition|(
name|v
operator|->
name|mode
operator|==
name|mode
operator|&&
operator|!
name|v
operator|->
name|ignore
condition|)
block|{
for|for
control|(
name|tv
operator|=
name|class_struct
index|[
name|REGNO
argument_list|(
name|arg
argument_list|)
index|]
operator|->
name|giv
init|;
name|tv
condition|;
name|tv
operator|=
name|tv
operator|->
name|family
control|)
if|if
condition|(
operator|(
name|tv
operator|->
name|new_reg
operator|!=
literal|0
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|tv
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|mult_val
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|tv
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|mult_val
argument_list|)
operator|&&
operator|!
name|tv
operator|->
name|ignore
operator|&&
name|tv
operator|->
name|mode
operator|==
name|mode
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Rewrite a compare insn INSN which uses the biv described by BL    so that it doesn't use that biv any more.    Instead it will use some reduced giv related to that biv.     The preceding function is very parallel to this one.  */
end_comment

begin_function
specifier|static
name|void
name|eliminate_biv
parameter_list|(
name|insn
parameter_list|,
name|bl
parameter_list|,
name|loop_start
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|rtx
name|loop_start
decl_stmt|;
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|struct
name|induction
modifier|*
name|v
decl_stmt|,
modifier|*
name|tv
decl_stmt|;
name|rtx
name|arg
decl_stmt|,
name|temp
decl_stmt|;
name|int
name|arg_operand
decl_stmt|;
comment|/* Mode of this biv.  */
name|enum
name|machine_mode
name|mode
init|=
name|bl
operator|->
name|biv
operator|->
name|mode
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* a test insn */
case|case
name|REG
case|:
comment|/* Can replace with any giv that was reduced and 	 that has (MULT_VAL != 0) and (ADD_VAL == 0). 	 Require a constant integer for MULT_VAL, so we know it's nonzero.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|family
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|v
operator|->
name|mult_val
operator|!=
name|const0_rtx
operator|&&
name|v
operator|->
name|add_val
operator|==
name|const0_rtx
operator|&&
name|v
operator|->
name|new_reg
operator|!=
literal|0
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
condition|)
break|break;
if|if
condition|(
name|v
condition|)
block|{
comment|/* We can test the sign of that giv's reduced reg.  */
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|v
operator|->
name|new_reg
expr_stmt|;
comment|/* If the giv has the opposite direction of change, 	     then reverse the comparison.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|<
literal|0
condition|)
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|COMPARE
argument_list|,
name|GET_MODE
argument_list|(
name|v
operator|->
name|new_reg
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|v
operator|->
name|new_reg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Look for a giv with (MULT_VAL != 0) and (ADD_VAL != 0) 	 where ADD_VAL is a constant or a register; 	 replace test insn with a compare insn (cmp REDUCED_GIV ADD_VAL). 	 Require a constant integer for MULT_VAL, so we know it's nonzero.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|family
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|v
operator|->
name|mult_val
operator|!=
name|const0_rtx
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
name|v
operator|->
name|new_reg
operator|!=
literal|0
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
condition|)
break|break;
if|if
condition|(
name|v
condition|)
block|{
comment|/* Replace biv with the giv's reduced register.  */
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|COMPARE
argument_list|,
name|GET_MODE
argument_list|(
name|v
operator|->
name|new_reg
argument_list|)
argument_list|,
name|v
operator|->
name|new_reg
argument_list|,
name|copy_rtx
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the giv has the opposite direction of change, 	     then reverse the comparison.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|<
literal|0
condition|)
block|{
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|v
operator|->
name|new_reg
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* add_val must be invariant, so don't bother storing in a register */
comment|/* calculate the appropriate constant to compare against */
block|emit_insn_before (gen_rtx (SET, VOIDmode, compare_value, 				     copy_rtx (v->add_val)), 			    loop_start);
endif|#
directive|endif
return|return;
block|}
name|abort
argument_list|()
expr_stmt|;
break|break;
comment|/* a compare insn */
case|case
name|COMPARE
case|:
comment|/* Figure out which operand is the biv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|bl
operator|->
name|regno
condition|)
block|{
name|arg
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arg_operand
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|bl
operator|->
name|regno
condition|)
block|{
name|arg
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg_operand
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* Can replace with any giv that has constant mult_val and add_val. 	     Make sure it was strength reduced by checking new_reg != 0.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|family
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|v
operator|->
name|new_reg
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
condition|)
break|break;
if|if
condition|(
name|v
condition|)
block|{
name|rtx
name|newval
decl_stmt|;
comment|/* Replace biv with the giv's reduced reg.  */
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
operator|-
name|arg_operand
argument_list|)
operator|=
name|v
operator|->
name|new_reg
expr_stmt|;
comment|/* Calculate the appropriate constant to compare against.  */
name|newval
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|arg
argument_list|)
operator|*
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|+
name|INTVAL
argument_list|(
name|v
operator|->
name|add_val
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|src
argument_list|,
name|arg_operand
argument_list|)
operator|=
name|newval
expr_stmt|;
comment|/* If that constant is no good in a compare, 		 put it in a register.  */
if|if
condition|(
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|)
operator|<
literal|0
condition|)
block|{
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_iv_init_code
argument_list|(
name|arg
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|temp
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|src
argument_list|,
name|arg_operand
argument_list|)
operator|=
name|temp
expr_stmt|;
block|}
comment|/* If the giv has the opposite direction of change, 		 then reverse the comparison.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|<
literal|0
condition|)
block|{
name|temp
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|=
name|temp
expr_stmt|;
block|}
return|return;
block|}
comment|/* Look for giv with constant mult_val and nonconst add_val. 	     Insert add insn before loop to calculate new compare value.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|family
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|v
operator|->
name|new_reg
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
condition|)
break|break;
if|if
condition|(
name|v
condition|)
block|{
name|rtx
name|compare_value
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* Replace biv with giv's reduced register.  */
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
operator|-
name|arg_operand
argument_list|)
operator|=
name|v
operator|->
name|new_reg
expr_stmt|;
comment|/* At start of loop, compute value to compare against.  */
name|emit_iv_init_code
argument_list|(
name|arg
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|compare_value
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
comment|/* Use it in this insn.  */
name|XEXP
argument_list|(
name|src
argument_list|,
name|arg_operand
argument_list|)
operator|=
name|compare_value
expr_stmt|;
comment|/* If the giv has the opposite direction of change, 		 then reverse the comparison.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|<
literal|0
condition|)
block|{
name|temp
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|=
name|temp
expr_stmt|;
block|}
return|return;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|invariant_p
argument_list|(
name|arg
argument_list|)
condition|)
block|{
comment|/* Look for giv with constant mult_val and nonconst add_val. 		 Insert add-insn before loop to compute new compare value.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|family
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|v
operator|->
name|new_reg
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
condition|)
break|break;
if|if
condition|(
name|v
condition|)
block|{
name|rtx
name|compare_value
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* Replace biv with giv's reduced register.  */
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
operator|-
name|arg_operand
argument_list|)
operator|=
name|v
operator|->
name|new_reg
expr_stmt|;
comment|/* At start of loop, compute value to compare against.  */
name|emit_iv_init_code
argument_list|(
name|arg
argument_list|,
name|v
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|,
name|compare_value
argument_list|,
name|loop_start
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|src
argument_list|,
name|arg_operand
argument_list|)
operator|=
name|compare_value
expr_stmt|;
comment|/* If the giv has the opposite direction of change, 		     then reverse the comparison.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|<
literal|0
condition|)
block|{
name|temp
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|=
name|temp
expr_stmt|;
block|}
return|return;
block|}
block|}
comment|/* Otherwise the reg compared with had better be a biv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|REG
operator|||
name|induct_var
index|[
name|REGNO
argument_list|(
name|arg
argument_list|)
index|]
operator|!=
name|BASIC_INDUCT
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Look for a pair of givs, one for each biv, 	     with identical coefficients.  */
for|for
control|(
name|v
operator|=
name|bl
operator|->
name|giv
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|family
control|)
block|{
if|if
condition|(
operator|!
name|v
operator|->
name|new_reg
operator|&&
name|v
operator|->
name|mode
operator|==
name|mode
condition|)
continue|continue;
for|for
control|(
name|tv
operator|=
name|class_struct
index|[
name|REGNO
argument_list|(
name|arg
argument_list|)
index|]
operator|->
name|giv
init|;
name|tv
condition|;
name|tv
operator|=
name|tv
operator|->
name|family
control|)
if|if
condition|(
operator|(
name|tv
operator|->
name|new_reg
operator|!=
literal|0
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|tv
operator|->
name|mult_val
argument_list|,
name|v
operator|->
name|mult_val
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|tv
operator|->
name|add_val
argument_list|,
name|v
operator|->
name|add_val
argument_list|)
operator|&&
name|tv
operator|->
name|mode
operator|==
name|mode
condition|)
break|break;
if|if
condition|(
name|tv
condition|)
break|break;
block|}
if|if
condition|(
name|v
condition|)
block|{
comment|/* Replace biv with its giv's reduced reg.  */
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
operator|-
name|arg_operand
argument_list|)
operator|=
name|v
operator|->
name|new_reg
expr_stmt|;
comment|/* Replace other operand with the other giv's reduced reg.  */
name|XEXP
argument_list|(
name|src
argument_list|,
name|arg_operand
argument_list|)
operator|=
name|tv
operator|->
name|new_reg
expr_stmt|;
comment|/* If the giv has the opposite direction of change, 		 then reverse the comparison.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|v
operator|->
name|mult_val
argument_list|)
operator|<
literal|0
condition|)
block|{
name|temp
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|=
name|temp
expr_stmt|;
block|}
return|return;
block|}
block|}
name|abort
argument_list|()
expr_stmt|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to calculate the final value of the biv,    the value it will have at the end of the loop.    If we can do it, return that value.  */
end_comment

begin_comment
comment|/* ??? One case that should be simple to handle    is when the biv is incremented by an invariant    exactly once each time around the loop,    and when the number of iterations can be determined    (as the value of some invariant).    Then the final value would be BIV + (INCREMENT * NUM_ITERATIONS).     Once that case is handled, it would become desirable to detect empty    loops and delete them, since this optimization could make empty loops.  */
end_comment

begin_function
specifier|static
name|rtx
name|final_biv_value
parameter_list|(
name|bl
parameter_list|,
name|loop_end
parameter_list|)
name|struct
name|iv_class
modifier|*
name|bl
decl_stmt|;
name|rtx
name|loop_end
decl_stmt|;
block|{
comment|/* wimpy, but guaranteed to work */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the last use of reg REGNO    is in an insn following INSN in the same basic block.  */
end_comment

begin_function
specifier|static
name|int
name|last_use_this_basic_block
parameter_list|(
name|regno
parameter_list|,
name|insn
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|insn
init|;
name|n
operator|&&
name|GET_CODE
argument_list|(
name|n
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
name|GET_CODE
argument_list|(
name|n
argument_list|)
operator|!=
name|JUMP_INSN
condition|;
name|n
operator|=
name|NEXT_INSN
argument_list|(
name|n
argument_list|)
control|)
block|{
if|if
condition|(
name|regno_last_uid
index|[
name|regno
index|]
operator|==
name|INSN_UID
argument_list|(
name|n
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

