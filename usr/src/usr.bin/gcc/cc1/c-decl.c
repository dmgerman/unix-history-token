begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)c-decl.c	6.3 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Process declarations and variables for C compiler.    Copyright (C) 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Process declarations and symbol lookup for C front end.    Also constructs types; the standard scalar types at initialization,    and structure, union, array and enum types when they are declared.  */
end_comment

begin_comment
comment|/* ??? not all decl nodes are given the most useful possible    line numbers.  For example, the CONST_DECLs for enum values.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"c-parse.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* In grokdeclarator, distinguish syntactic contexts of declarators.  */
end_comment

begin_enum
enum|enum
name|decl_context
block|{
name|NORMAL
block|,
comment|/* Ordinary declaration */
name|FUNCDEF
block|,
comment|/* Function definition */
name|PARM
block|,
comment|/* Declaration of parm before function body */
name|FIELD
block|,
comment|/* Declaration inside struct or union */
name|TYPENAME
block|}
enum|;
end_enum

begin_comment
comment|/* Typename (inside cast or sizeof)  */
end_comment

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|((X)< (Y) ? (X) : (Y))
end_define

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|((X)> (Y) ? (X) : (Y))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|CHAR_TYPE_SIZE
value|BITS_PER_UNIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SHORT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|SHORT_TYPE_SIZE
value|(BITS_PER_UNIT * MIN ((UNITS_PER_WORD + 1) / 2, 2))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|INT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_LONG_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|FLOAT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* a node which has tree code ERROR_MARK, and whose type is itself.    All erroneous expressions are replaced with this node.  All functions    that accept nodes as arguments should avoid generating error messages    if this node is one of the arguments, since it is undesirable to get    multiple error messages from one error in the input.  */
end_comment

begin_decl_stmt
name|tree
name|error_mark_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INTEGER_TYPE and REAL_TYPE nodes for the standard data types */
end_comment

begin_decl_stmt
name|tree
name|short_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_long_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|short_unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_long_unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_char_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|signed_char_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|char_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|float_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|double_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_double_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a VOID_TYPE node.  */
end_comment

begin_decl_stmt
name|tree
name|void_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A node for type `void *'.  */
end_comment

begin_decl_stmt
name|tree
name|ptr_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A node for type `char *'.  */
end_comment

begin_decl_stmt
name|tree
name|string_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type `char[256]' or something like it.    Used when an array of char is needed and the size is irrelevant.  */
end_comment

begin_decl_stmt
name|tree
name|char_array_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type `int[256]' or something like it.    Used when an array of int needed and the size is irrelevant.  */
end_comment

begin_decl_stmt
name|tree
name|int_array_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type `int ()' -- used for implicit declaration of functions.  */
end_comment

begin_decl_stmt
name|tree
name|default_function_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function types `double (double)' and `double (double, double)', etc.  */
end_comment

begin_decl_stmt
name|tree
name|double_ftype_double
decl_stmt|,
name|double_ftype_double_double
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|int_ftype_int
decl_stmt|,
name|long_ftype_long
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function type `void (void *, void *, int)' and similar ones */
end_comment

begin_decl_stmt
name|tree
name|void_ftype_ptr_ptr_int
decl_stmt|,
name|int_ftype_ptr_ptr_int
decl_stmt|,
name|void_ftype_ptr_int_int
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Two expressions that are constants with value zero.    The first is of type `int', the second of type `void *'.  */
end_comment

begin_decl_stmt
name|tree
name|integer_zero_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|null_pointer_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A node for the integer constant 1.  */
end_comment

begin_decl_stmt
name|tree
name|integer_one_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An identifier whose name is<value>.  This is used as the "name"    of the RESULT_DECLs for values of functions.  */
end_comment

begin_decl_stmt
name|tree
name|value_identifier
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* While defining an enum type, this is 1 plus the last enumerator    constant value.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|enum_next_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsing a function declarator leaves a list of parameter names    or a chain or parameter decls here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_function_parms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsing a function declarator leaves here a chain of structure    and enum types declared in the parmlist.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_function_parm_tags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* After parsing the declarator that starts a function definition,    `start_function' puts here the list of parameter names or chain of decls.    `store_parm_decls' finds it here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_function_parms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, for last_function_parm_tags.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_function_parm_tags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list (chain of TREE_LIST nodes) of all LABEL_STMTs in the function    that have names.  Here so we can clear out their names' definitions    at the end of the function.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|named_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The FUNCTION_DECL for the function currently being compiled,    or 0 if between functions.  */
end_comment

begin_decl_stmt
name|tree
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a return statement that specifies a return value is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a return statement with no argument is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_null
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to nonzero by `grokdeclarator' for a function    whose return type is defaulted, if warnings for this are desired.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_about_return_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero when starting a function delcared `extern inline'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_extern_inline
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* For each binding contour we allocate a binding_level structure  * which records the names defined in that contour.  * Contours include:  *  0) the global one  *  1) one for each function definition,  *     where internal declarations of the parameters appear.  *  2) one for each compound statement,  *     to record its declarations.  *  * The current meaning of a name can be found by searching the levels from  * the current one out to the global one.  */
end_comment

begin_comment
comment|/* Note that the information in the `names' component of the global contour    is duplicated in the IDENTIFIER_GLOBAL_VALUEs of all identifiers.  */
end_comment

begin_struct
struct|struct
name|binding_level
block|{
comment|/* A chain of _DECL nodes for all variables, constants, functions,        and typedef types.  These are in the reverse of the order supplied.      */
name|tree
name|names
decl_stmt|;
comment|/* A list of structure, union and enum definitions,      * for looking up tag names.      * It is a chain of TREE_LIST nodes, each of whose TREE_PURPOSE is a name,      * or NULL_TREE; and whose TREE_VALUE is a RECORD_TYPE, UNION_TYPE,      * or ENUMERAL_TYPE node.      */
name|tree
name|tags
decl_stmt|;
comment|/* For each level, a list of shadowed outer-level local definitions        to be restored when this level is popped.        Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and        whose TREE_VALUE is its old definition (a kind of ..._DECL node).  */
name|tree
name|shadowed
decl_stmt|;
comment|/* For each level (except not the global one),        a chain of LET_STMT nodes for all the levels        that were entered and exited one level down.  */
name|tree
name|blocks
decl_stmt|;
comment|/* The binding level which this one is contained in (inherits from).  */
name|struct
name|binding_level
modifier|*
name|level_chain
decl_stmt|;
comment|/* Nonzero for the level that holds the parameters of a function.  */
name|char
name|parm_flag
decl_stmt|;
comment|/* Nonzero if this level "doesn't exist" for tags.  */
name|char
name|tag_transparent
decl_stmt|;
comment|/* Nonzero means make a LET_STMT for this level regardless of all else.  */
name|char
name|keep
decl_stmt|;
comment|/* Nonzero means make a LET_STMT if this level has any subblocks.  */
name|char
name|keep_if_subblocks
decl_stmt|;
comment|/* Number of decls in `names' that have incomplete         structure or union types.  */
name|int
name|n_incomplete
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NULL_BINDING_LEVEL
value|(struct binding_level *) NULL
end_define

begin_comment
comment|/* The binding level currently in effect.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|current_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A chain of binding_level structures awaiting reuse.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|free_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The outermost binding level, for names of file scope.    This is created when the compiler is started and exists    through the entire run.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|global_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Binding level structures are initialized by copying this one.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
name|clear_binding_level
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means unconditionally make a LET_STMT for the next level pushed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|keep_next_level_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means make a LET_STMT for the next level pushed    if it has subblocks.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|keep_next_if_subblocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|grokparms
argument_list|()
decl_stmt|,
name|grokdeclarator
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|tree
name|pushdecl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|builtin_function
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_tag
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_tag_reverse
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_name_current_level
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|redeclaration_error_message
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|layout_array_type
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* C-specific option variables.  */
end_comment

begin_comment
comment|/* Nonzero means allow type mismatches in conditional expressions;    just make their values `void'.   */
end_comment

begin_decl_stmt
name|int
name|flag_cond_mismatch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize the keyword `asm'.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_asm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do some things the same way PCC does.  */
end_comment

begin_decl_stmt
name|int
name|flag_traditional
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about implicit declarations.  */
end_comment

begin_decl_stmt
name|int
name|warn_implicit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about function definitions that default the return type    or that use a null return and have a return-type other than void.  */
end_comment

begin_decl_stmt
name|int
name|warn_return_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give string constants the type `const char *'    to get extra warnings from them.  These warnings will be too numerous    to be useful, except in thoroughly ANSIfied programs.  */
end_comment

begin_decl_stmt
name|int
name|warn_write_strings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about pointer casts that can drop a type qualifier    from the pointer target type.  */
end_comment

begin_decl_stmt
name|int
name|warn_cast_qual
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about sizeof(function) or addition/subtraction    of function pointers.  */
end_comment

begin_decl_stmt
name|int
name|warn_pointer_arith
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn for all old-style non-prototype function decls.  */
end_comment

begin_decl_stmt
name|int
name|warn_strict_prototypes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means `$' can be in an identifier.    See cccp.c for reasons why this breaks some obscure ANSI C programs.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DOLLARS_IN_IDENTIFIERS
end_ifndef

begin_define
define|#
directive|define
name|DOLLARS_IN_IDENTIFIERS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|dollars_in_ident
init|=
name|DOLLARS_IN_IDENTIFIERS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|language_string
init|=
literal|"GNU C"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Decode the string P as a language-specific option.    Return 1 if it is recognized (and handle it);    return 0 if not recognized.  */
end_comment

begin_function
name|int
name|lang_decode_option
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-ftraditional"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-traditional"
argument_list|)
condition|)
name|flag_traditional
operator|=
literal|1
operator|,
name|dollars_in_ident
operator|=
literal|1
operator|,
name|flag_writable_strings
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fsigned-char"
argument_list|)
condition|)
name|flag_signed_char
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-funsigned-char"
argument_list|)
condition|)
name|flag_signed_char
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fno-signed-char"
argument_list|)
condition|)
name|flag_signed_char
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fno-unsigned-char"
argument_list|)
condition|)
name|flag_signed_char
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fshort-enums"
argument_list|)
condition|)
name|flag_short_enums
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fno-short-enums"
argument_list|)
condition|)
name|flag_short_enums
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fcond-mismatch"
argument_list|)
condition|)
name|flag_cond_mismatch
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fno-cond-mismatch"
argument_list|)
condition|)
name|flag_cond_mismatch
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fasm"
argument_list|)
condition|)
name|flag_no_asm
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fno-asm"
argument_list|)
condition|)
name|flag_no_asm
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-ansi"
argument_list|)
condition|)
name|flag_no_asm
operator|=
literal|1
operator|,
name|dollars_in_ident
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wimplicit"
argument_list|)
condition|)
name|warn_implicit
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wreturn-type"
argument_list|)
condition|)
name|warn_return_type
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wwrite-strings"
argument_list|)
condition|)
name|warn_write_strings
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wcast-qual"
argument_list|)
condition|)
name|warn_cast_qual
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wpointer-arith"
argument_list|)
condition|)
name|warn_pointer_arith
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wstrict-prototypes"
argument_list|)
condition|)
name|warn_strict_prototypes
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wcomment"
argument_list|)
condition|)
empty_stmt|;
comment|/* cpp handles this one.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wcomments"
argument_list|)
condition|)
empty_stmt|;
comment|/* cpp handles this one.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wtrigraphs"
argument_list|)
condition|)
empty_stmt|;
comment|/* cpp handles this one.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wall"
argument_list|)
condition|)
block|{
name|extra_warnings
operator|=
literal|1
expr_stmt|;
name|warn_implicit
operator|=
literal|1
expr_stmt|;
name|warn_return_type
operator|=
literal|1
expr_stmt|;
name|warn_unused
operator|=
literal|1
expr_stmt|;
name|warn_switch
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|print_lang_identifier
parameter_list|(
name|file
parameter_list|,
name|node
parameter_list|,
name|indent
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|node
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{
name|print_node
argument_list|(
name|file
argument_list|,
literal|"global"
argument_list|,
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"local"
argument_list|,
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"label"
argument_list|,
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"implicit"
argument_list|,
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"error locus"
argument_list|,
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a new `struct binding_level'.  */
end_comment

begin_function
specifier|static
name|struct
name|binding_level
modifier|*
name|make_binding_level
parameter_list|()
block|{
comment|/* NOSTRICT */
return|return
operator|(
expr|struct
name|binding_level
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|binding_level
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if we are currently in the global binding level.  */
end_comment

begin_function
name|int
name|global_bindings_p
parameter_list|()
block|{
return|return
name|current_binding_level
operator|==
name|global_binding_level
return|;
block|}
end_function

begin_function
name|void
name|keep_next_level
parameter_list|()
block|{
name|keep_next_level_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero if the current level needs to have a LET_STMT made.  */
end_comment

begin_function
name|int
name|kept_level_p
parameter_list|()
block|{
return|return
operator|(
operator|(
name|current_binding_level
operator|->
name|keep_if_subblocks
operator|&&
name|current_binding_level
operator|->
name|blocks
operator|!=
literal|0
operator|)
operator|||
name|current_binding_level
operator|->
name|keep
operator|||
name|current_binding_level
operator|->
name|names
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Identify this binding level as a level of parameters.  */
end_comment

begin_function
name|void
name|declare_parm_level
parameter_list|()
block|{
name|current_binding_level
operator|->
name|parm_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero if currently making parm declarations.  */
end_comment

begin_macro
name|in_parm_level_p
argument_list|()
end_macro

begin_block
block|{
return|return
name|current_binding_level
operator|->
name|parm_flag
return|;
block|}
end_block

begin_comment
comment|/* Enter a new binding level.    If TAG_TRANSPARENT is nonzero, do so only for the name space of variables,    not for that of tags.  */
end_comment

begin_function
name|void
name|pushlevel
parameter_list|(
name|tag_transparent
parameter_list|)
name|int
name|tag_transparent
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|newlevel
init|=
name|NULL_BINDING_LEVEL
decl_stmt|;
comment|/* If this is the top level of a function,      just make sure that NAMED_LABELS is 0.      They should have been set to 0 at the end of the previous function.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
if|if
condition|(
name|named_labels
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Reuse or create a struct for this binding level.  */
if|if
condition|(
name|free_binding_level
condition|)
block|{
name|newlevel
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|free_binding_level
operator|->
name|level_chain
expr_stmt|;
block|}
else|else
block|{
name|newlevel
operator|=
name|make_binding_level
argument_list|()
expr_stmt|;
block|}
comment|/* Add this level to the front of the chain (stack) of levels that      are active.  */
operator|*
name|newlevel
operator|=
name|clear_binding_level
expr_stmt|;
name|newlevel
operator|->
name|level_chain
operator|=
name|current_binding_level
expr_stmt|;
name|current_binding_level
operator|=
name|newlevel
expr_stmt|;
name|newlevel
operator|->
name|tag_transparent
operator|=
name|tag_transparent
expr_stmt|;
name|newlevel
operator|->
name|keep
operator|=
name|keep_next_level_flag
expr_stmt|;
name|keep_next_level_flag
operator|=
literal|0
expr_stmt|;
name|newlevel
operator|->
name|keep_if_subblocks
operator|=
name|keep_next_if_subblocks
expr_stmt|;
name|keep_next_if_subblocks
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Exit a binding level.    Pop the level off, and restore the state of the identifier-decl mappings    that were in effect when this level was entered.     If KEEP is nonzero, this level had explicit declarations, so    and create a "block" (a LET_STMT node) for the level    to record its declarations and subblocks for symbol table output.     If FUNCTIONBODY is nonzero, this level is the body of a function,    so create a block as if KEEP were set and also clear out all    label names.     If REVERSE is nonzero, reverse the order of decls before putting    them into the LET_STMT.  */
end_comment

begin_function
name|tree
name|poplevel
parameter_list|(
name|keep
parameter_list|,
name|reverse
parameter_list|,
name|functionbody
parameter_list|)
name|int
name|keep
decl_stmt|;
name|int
name|reverse
decl_stmt|;
name|int
name|functionbody
decl_stmt|;
block|{
specifier|register
name|tree
name|link
decl_stmt|;
comment|/* The chain of decls was accumulated in reverse order.      Put it into forward order, just for cleanliness.  */
name|tree
name|decls
decl_stmt|;
name|tree
name|tags
init|=
name|current_binding_level
operator|->
name|tags
decl_stmt|;
name|tree
name|subblocks
init|=
name|current_binding_level
operator|->
name|blocks
decl_stmt|;
name|tree
name|block
init|=
literal|0
decl_stmt|;
name|keep
operator||=
name|current_binding_level
operator|->
name|keep
expr_stmt|;
comment|/* This warning is turned off because it causes warnings for      declarations like `extern struct foo *x'.  */
if|#
directive|if
literal|0
comment|/* Warn about incomplete structure types in this level.  */
block|for (link = tags; link; link = TREE_CHAIN (link))     if (TYPE_SIZE (TREE_VALUE (link)) == 0)       { 	tree type = TREE_VALUE (link); 	char *errmsg; 	switch (TREE_CODE (type)) 	  { 	  case RECORD_TYPE: 	    errmsg = "`struct %s' incomplete in scope ending here"; 	    break; 	  case UNION_TYPE: 	    errmsg = "`union %s' incomplete in scope ending here"; 	    break; 	  case ENUMERAL_TYPE: 	    errmsg = "`enum %s' incomplete in scope ending here"; 	    break; 	  } 	if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE) 	  error (errmsg, IDENTIFIER_POINTER (TYPE_NAME (type))); 	else
comment|/* If this type has a typedef-name, the TYPE_NAME is a TYPE_DECL.  */
block|error (errmsg, IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));       }
endif|#
directive|endif
comment|/* 0 */
comment|/* Get the decls in the order they were written.      Usually current_binding_level->names is in reverse order.      But parameter decls were previously put in forward order.  */
if|if
condition|(
name|reverse
condition|)
name|current_binding_level
operator|->
name|names
operator|=
name|decls
operator|=
name|nreverse
argument_list|(
name|current_binding_level
operator|->
name|names
argument_list|)
expr_stmt|;
else|else
name|decls
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
comment|/* If there were any declarations or structure tags in that level,      or if this level is a function body,      create a LET_STMT to record them for the life of this function.  */
if|if
condition|(
name|keep
operator|||
name|functionbody
operator|||
operator|(
name|current_binding_level
operator|->
name|keep_if_subblocks
operator|&&
name|subblocks
operator|!=
literal|0
operator|)
condition|)
name|block
operator|=
name|build_let
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|keep
condition|?
name|decls
else|:
literal|0
argument_list|,
name|subblocks
argument_list|,
literal|0
argument_list|,
name|keep
condition|?
name|tags
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* In each subblock, record that this is its superior.  */
for|for
control|(
name|link
operator|=
name|subblocks
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|STMT_SUPERCONTEXT
argument_list|(
name|link
argument_list|)
operator|=
name|block
expr_stmt|;
comment|/* Clear out the meanings of the local variables of this level;      also record in each decl which block it belongs to.  */
for|for
control|(
name|link
operator|=
name|decls
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* If the ident. was used via a local extern decl, 	     don't forget that fact.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|link
argument_list|)
operator|&&
name|TREE_EXTERNAL
argument_list|(
name|link
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|DECL_CONTEXT
argument_list|(
name|link
argument_list|)
operator|=
name|block
expr_stmt|;
block|}
comment|/* Restore all name-meanings of the outer levels      that were shadowed by this level.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
comment|/* If the level being exited is the top level of a function,      check over all the labels.  */
if|if
condition|(
name|functionbody
condition|)
block|{
comment|/* Clear out the definitions of all label names, 	 since their scopes end here.  */
for|for
control|(
name|link
operator|=
name|named_labels
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"label `%s' used somewhere above but not defined"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Avoid crashing later.  */
name|define_label
argument_list|(
name|input_filename
argument_list|,
literal|1
argument_list|,
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn_unused
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
literal|"label `%s' defined but not used"
argument_list|)
expr_stmt|;
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|named_labels
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Pop the current level, and free the structure for reuse.  */
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
init|=
name|current_binding_level
decl_stmt|;
name|current_binding_level
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
name|level
operator|->
name|level_chain
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|level
expr_stmt|;
block|}
if|if
condition|(
name|functionbody
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|block
expr_stmt|;
comment|/* If this is the top level block of a function, 	 the vars are the function's parameters. 	 Don't leave them in the LET_STMT because they are 	 found in the FUNCTION_DECL instead.  */
name|STMT_VARS
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|block
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
comment|/* If we did not make a block for the level just exited,      any blocks made for inner levels      (since they cannot be recorded as subblocks in that level)      must be carried forward so they will later become subblocks      of something else.  */
elseif|else
if|if
condition|(
name|subblocks
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|subblocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
condition|)
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Push a definition of struct, union or enum tag "name".    "type" should be the type node.    We assume that the tag "name" is not already defined.     Note that the definition may really be just a forward reference.    In that case, the TYPE_SIZE will be zero.  */
end_comment

begin_function
name|void
name|pushtag
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|tree
name|name
decl_stmt|,
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
while|while
condition|(
name|b
operator|->
name|tag_transparent
condition|)
name|b
operator|=
name|b
operator|->
name|level_chain
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
comment|/* Record the identifier as the type's name if it has none.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|global_binding_level
condition|)
name|b
operator|->
name|tags
operator|=
name|perm_tree_cons
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
operator|->
name|tags
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|tags
operator|=
name|saveable_tree_cons
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
operator|->
name|tags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle when a new declaration NEWDECL    has the same name as an old one OLDDECL    in the same binding contour.    Prints an error message if appropriate.     If safely possible, alter OLDDECL to look like NEWDECL, and return 1.    Otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|duplicate_decls
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
specifier|register
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
name|int
name|types_match
init|=
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
name|types_match
operator|=
literal|0
expr_stmt|;
comment|/* If this decl has linkage, and the old one does too, maybe no error.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"`%s' redeclared as different kind of symbol"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"previous declaration of `%s'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flag_traditional
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_NAME
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|olddecl
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
condition|)
comment|/* If -traditional, avoid error for redeclaring fcn 	   after implicit decl.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|NOT_BUILT_IN
condition|)
block|{
if|if
condition|(
operator|!
name|types_match
condition|)
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"conflicting types for built-in function `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|extra_warnings
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"built-in function `%s' redeclared"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"conflicting types for `%s'"
argument_list|)
expr_stmt|;
comment|/* Check for function type mismatch 	     involving an empty arglist vs a nonempty one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Classify the problem further.  */
specifier|register
name|tree
name|t
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
name|t
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|type
operator|!=
name|void_type_node
condition|)
block|{
name|error
argument_list|(
literal|"A parameter list with an ellipsis can't match"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"an empty parameter name list declaration."
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|==
name|float_type_node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"An argument type that has a default promotion"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"can't match an empty parameter name list declaration."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"previous declaration of `%s'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|errmsg
init|=
name|redeclaration_error_message
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|errmsg
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"here is the previous declaration of `%s'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Prototype decl follows defn w/o prototype.  */
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"prototype for `%s'"
argument_list|)
expr_stmt|;
name|warning_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"follows non-prototype definition here"
argument_list|)
expr_stmt|;
block|}
comment|/* These bits are logically part of the type.  */
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"type qualifiers for `%s' conflict with previous decl"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|int
name|new_is_definition
init|=
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
literal|0
operator|)
decl_stmt|;
comment|/* Copy all the DECL_... slots specified in the new decl 	 except for any that we copy here from the old type.  */
if|if
condition|(
name|types_match
condition|)
block|{
name|tree
name|oldtype
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
comment|/* Merge the data types specified in the two decls.  */
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|commontype
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Lay the type out, unless already done.  */
if|if
condition|(
name|oldtype
operator|!=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|CONST_DECL
condition|)
name|layout_decl
argument_list|(
name|newdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Since the type is OLDDECL's, make OLDDECL's size go with.  */
name|DECL_SIZE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SIZE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SIZE_UNIT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ALIGN
argument_list|(
name|olddecl
argument_list|)
operator|>
name|DECL_ALIGN
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_ALIGN
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ALIGN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the type qualifiers.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Merge the initialization information.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Keep the old rtl since we can safely use it.  */
name|DECL_RTL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* If cannot merge, then use the new type and qualifiers, 	 and don't preserve the old rtl.  */
else|else
block|{
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_VOLATILE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the storage class information.  */
if|if
condition|(
name|TREE_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* For functions, static overrides non-static.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|&=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* This is since we don't automatically 		 copy the attributes of NEWDECL into OLDDECL.  */
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
comment|/* If this clears `static', clear it in the identifier too.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* If either decl says `inline', this fn is inline, 	 unless its definition was passed already.  */
if|if
condition|(
name|TREE_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
condition|)
name|TREE_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If redeclaring a builtin function, and not a definition, 	 it stays built in. 	 Also preserve various other info from the definition.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|new_is_definition
condition|)
block|{
name|DECL_SET_FUNCTION_CODE
argument_list|(
name|newdecl
argument_list|,
name|DECL_FUNCTION_CODE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SAVED_INSNS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_RESULT_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RESULT_TYPE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_FRAME_SIZE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_FRAME_SIZE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Don't lose track of having output OLDDECL as GDB symbol.  */
name|DECL_BLOCK_SYMTAB_ADDRESS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_BLOCK_SYMTAB_ADDRESS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* New decl is completely inconsistent with the old one =>      tell caller to replace the old one.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Record a decl-node X as belonging to the current lexical scope.    Check for errors (such as an incompatible declaration for the same    name already seen in the same scope).     Returns either X or an old decl for the same name.    If an old decl is returned, it may have been smashed    to agree with what X says.  */
end_comment

begin_function
name|tree
name|pushdecl
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|t
operator|=
name|lookup_name_current_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
operator|&&
name|t
operator|==
name|error_mark_node
condition|)
comment|/* error_mark_node is 0 for a while during initialization!  */
block|{
name|t
operator|=
literal|0
expr_stmt|;
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"`%s' used prior to declaration"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
block|{
name|file
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|line
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
literal|0
operator|&&
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
block|{
comment|/* If this decl is `static' and an implicit decl was seen previously, 	     warn.  But don't complain if -traditional, 	     since traditional compilers don't complain.  */
if|if
condition|(
operator|!
name|flag_traditional
operator|&&
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TREE_EXTERNAL
argument_list|(
name|x
argument_list|)
comment|/* We used to warn also for explicit extern followed by static, 		 but sometimes you need to do it that way.  */
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' was declared implicitly `extern' and later `static'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|warning_with_file_and_line
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"previous declaration of `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
comment|/* If declaring a type as a typedef, and the type has no known 	 typedef name, install this TYPE_DECL as its typedef name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
comment|/* Multiple external decls of the same identifier ought to match.  */
if|if
condition|(
name|TREE_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_EXTERNAL
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|warning_with_decl
argument_list|(
name|x
argument_list|,
literal|"type mismatch with previous external decl"
argument_list|)
expr_stmt|;
name|warning_with_decl
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"previous external decl of `%s'"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* In PCC-compatibility mode, extern decls of vars with no current decl 	 take effect at top level no matter where they are.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|TREE_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|lookup_name
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
name|b
operator|=
name|global_binding_level
expr_stmt|;
comment|/* This name is new in its binding level. 	 Install the new declaration and return it.  */
if|if
condition|(
name|b
operator|==
name|global_binding_level
condition|)
block|{
comment|/* Install a global value.  */
comment|/* If the first global decl has external linkage, 	     warn if we later see static one.  */
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
comment|/* Don't forget if the function was used via an implicit decl.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|x
argument_list|)
operator|=
literal|1
operator|,
name|TREE_USED
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Don't forget if its address was taken in that way.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Warn about mismatches against previous implicit decl.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
comment|/* If this real decl matches the implicit, don't complain.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|integer_type_node
operator|)
condition|)
name|warning
argument_list|(
literal|"`%s' was previously implicitly declared to return `int'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this decl is `static' and an `extern' was seen previously, 	     that is erroneous.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|TREE_EXTERNAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
condition|)
name|warning
argument_list|(
literal|"`%s' was declared implicitly `extern' and later `static'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"`%s' was declared `extern' and later `static'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Here to install a non-global value.  */
name|tree
name|oldlocal
init|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|oldglobal
init|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
comment|/* If this is an extern function declaration, see if we 	     have a global definition for the function.  */
if|if
condition|(
name|oldlocal
operator|==
literal|0
operator|&&
name|oldglobal
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|oldglobal
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* We have one.  Their types must agree.  */
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|x
argument_list|,
literal|"local declaration of `%s' doesn't match global one"
argument_list|)
expr_stmt|;
comment|/* If the global one is inline, make the local one inline.  */
elseif|else
if|if
condition|(
name|TREE_INLINE
argument_list|(
name|oldglobal
argument_list|)
operator|||
name|DECL_FUNCTION_CODE
argument_list|(
name|oldglobal
argument_list|)
operator|!=
name|NOT_BUILT_IN
operator|||
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldglobal
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|oldglobal
expr_stmt|;
block|}
comment|/* If we have a local external declaration, 	     and no file-scope declaration has yet been seen, 	     then if we later have a file-scope decl it must not be static.  */
if|if
condition|(
name|oldlocal
operator|==
literal|0
operator|&&
name|oldglobal
operator|==
literal|0
operator|&&
name|TREE_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Warn if shadowing an argument at the top level of the body.  */
if|if
condition|(
name|oldlocal
operator|!=
literal|0
operator|&&
operator|!
name|TREE_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
name|current_binding_level
operator|->
name|level_chain
operator|->
name|parm_flag
condition|)
name|warning
argument_list|(
literal|"declaration of `%s' shadows a parameter"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Maybe warn if shadowing something else.  */
elseif|else
if|if
condition|(
name|warn_shadow
operator|&&
operator|!
name|TREE_EXTERNAL
argument_list|(
name|x
argument_list|)
comment|/* No shadow warnings for vars made for inlining.  */
operator|&&
operator|!
name|TREE_INLINE
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|char
modifier|*
name|warnstring
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|oldlocal
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows a parameter"
expr_stmt|;
elseif|else
if|if
condition|(
name|oldlocal
operator|!=
literal|0
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows previous local"
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows global declaration"
expr_stmt|;
if|if
condition|(
name|warnstring
condition|)
name|warning
argument_list|(
name|warnstring
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If storing a local value, there may already be one (inherited). 	     If so, record it for restoration when this binding level ends.  */
if|if
condition|(
name|oldlocal
operator|!=
literal|0
condition|)
name|b
operator|->
name|shadowed
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|oldlocal
argument_list|,
name|b
operator|->
name|shadowed
argument_list|)
expr_stmt|;
block|}
comment|/* Keep count of variables in this level with incomplete type.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
operator|++
name|b
operator|->
name|n_incomplete
expr_stmt|;
block|}
comment|/* Put decls on list in reverse order.      We will reverse them later if necessary.  */
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|b
operator|->
name|names
expr_stmt|;
name|b
operator|->
name|names
operator|=
name|x
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate an implicit declaration for identifier FUNCTIONID    as a function of type int ().  Print a warning if appropriate.  */
end_comment

begin_function
name|tree
name|implicitly_declare
parameter_list|(
name|functionid
parameter_list|)
name|tree
name|functionid
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
comment|/* Save the decl permanently so we can warn if definition follows.  */
if|#
directive|if
literal|0
comment|/* A temporary implicit decl causes a crash in pushdecl. 	  In 1.38, fix pushdecl.  */
block|if (flag_traditional || !warn_implicit       || current_binding_level == global_binding_level)
endif|#
directive|endif
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* We used to reuse an old implicit decl here,      but this loses with inline functions because it can clobber      the saved decl chains.  */
comment|/*  if (IDENTIFIER_IMPLICIT_DECL (functionid) != 0)     decl = IDENTIFIER_IMPLICIT_DECL (functionid);   else  */
name|decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|functionid
argument_list|,
name|default_function_type
argument_list|)
expr_stmt|;
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ANSI standard says implicit declarations are in the innermost block.      So we record the decl in the standard fashion.      If flag_traditional is set, pushdecl does it top-level.  */
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_implicit
comment|/* Only one warning per identifier.  */
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|functionid
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"implicit declaration of function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|functionid
argument_list|)
argument_list|)
expr_stmt|;
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|functionid
argument_list|)
operator|=
name|decl
expr_stmt|;
if|#
directive|if
literal|0
block|if (flag_traditional || ! warn_implicit       || current_binding_level == global_binding_level)
endif|#
directive|endif
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Return zero if the declaration NEWDECL is valid    when the declaration OLDDECL (assumed to be for the same name)    has already been seen.    Otherwise return an error message format string with a %s    where the identifier should go.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|redeclaration_error_message
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|flag_traditional
operator|&&
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|"redefinition of `%s'"
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Declarations of functions can insist on internal linkage 	 but they can't be inconsistent with internal linkage, 	 so there can be no error on that account. 	 However defining the same name twice is no good.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
literal|0
comment|/* However, defining once as extern inline and a second 	     time in another way is ok.  */
operator|&&
operator|!
operator|(
name|TREE_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|TREE_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|"redefinition of `%s'"
return|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
comment|/* Objects declared at top level:  */
comment|/* If at least one is a reference, it's ok.  */
if|if
condition|(
name|TREE_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|||
name|TREE_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Reject two definitions.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|"redefinition of `%s'"
return|;
comment|/* Now we have two tentative defs, or one tentative and one real def.  */
comment|/* Insist that the linkage match.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|"conflicting declarations of `%s'"
return|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Objects declared with block scope:  */
comment|/* Reject two definitions, and reject a definition 	 together with an external reference.  */
if|if
condition|(
operator|!
operator|(
name|TREE_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|TREE_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
return|return
literal|"redeclaration of `%s'"
return|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the LABEL_DECL corresponding to identifier ID as a label.    Create one if none exists so far for the current function.    This function is called for both label definitions and label references.  */
end_comment

begin_function
name|tree
name|lookup_label
parameter_list|(
name|id
parameter_list|)
name|tree
name|id
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|!=
literal|0
condition|)
return|return
name|decl
return|;
name|decl
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|id
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
comment|/* Mark that the label's definition has not been seen.  */
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|decl
expr_stmt|;
name|named_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|named_labels
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Define a label, specifying the location in the source file.    Return the LABEL_DECL node for the label, if the definition is valid.    Otherwise return 0.  */
end_comment

begin_function
name|tree
name|define_label
parameter_list|(
name|filename
parameter_list|,
name|line
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|lookup_label
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"duplicate label `%s'"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Mark label as having been defined.  */
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
operator|=
name|filename
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
name|line
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the list of declarations of the current level.    Note that this list is in reverse order unless/until    you nreverse it; and when you do nreverse it, you must    store the result back using `storedecls' or you will lose.  */
end_comment

begin_function
name|tree
name|getdecls
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|names
return|;
block|}
end_function

begin_comment
comment|/* Return the list of type-tags (for structs, etc) of the current level.  */
end_comment

begin_function
name|tree
name|gettags
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|tags
return|;
block|}
end_function

begin_comment
comment|/* Store the list of declarations of the current level.    This is done for the parameter declarations of a function being defined,    after they are modified in the light of any missing parameters.  */
end_comment

begin_function
specifier|static
name|void
name|storedecls
parameter_list|(
name|decls
parameter_list|)
name|tree
name|decls
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|names
operator|=
name|decls
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similarly, store the list of tags of the current level.  */
end_comment

begin_function
specifier|static
name|void
name|storetags
parameter_list|(
name|tags
parameter_list|)
name|tree
name|tags
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|tags
operator|=
name|tags
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given NAME, an IDENTIFIER_NODE,    return the structure (or union or enum) definition for that name.    Searches binding levels from BINDING_LEVEL up to the global level.    If THISLEVEL_ONLY is nonzero, searches only the specified context    (but skips any tag-transparent contexts to find one that is    meaningful for tags).    FORM says which kind of type the caller wants;    it is RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE.    If the wrong kind of type is found, an error is reported.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tag
parameter_list|(
name|form
parameter_list|,
name|name
parameter_list|,
name|binding_level
parameter_list|,
name|thislevel_only
parameter_list|)
name|enum
name|tree_code
name|form
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|binding_level
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|int
name|thislevel_only
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|binding_level
init|;
name|level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|==
name|name
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|!=
name|form
condition|)
block|{
comment|/* Definition isn't the kind we were looking for.  */
name|error
argument_list|(
literal|"`%s' defined as wrong kind of tag"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|thislevel_only
operator|&&
operator|!
name|level
operator|->
name|tag_transparent
condition|)
return|return
name|NULL_TREE
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Given a type, find the tag that was defined for it and return the tag name.    Otherwise return 0.  However, the value can never be 0    in the cases in which this is used.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tag_reverse
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|current_binding_level
init|;
name|level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|==
name|type
condition|)
return|return
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look up NAME in the current binding level and its superiors    in the namespace of variables, functions and typedefs.    Return a ..._DECL node of some kind representing its definition,    or return 0 if it is undefined.  */
end_comment

begin_function
name|tree
name|lookup_name
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|val
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
operator|&&
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
name|val
operator|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Similar to `lookup_name' but look only at current binding level.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_name_current_level
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
return|return
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
return|;
if|if
condition|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|t
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|name
condition|)
break|break;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the predefined scalar types of C,    and some nodes representing standard constants (0, 1, (void *)0).    Initialize the global binding level.    Make definitions for built-in primitive functions.  */
end_comment

begin_function
name|void
name|init_decl_processing
parameter_list|()
block|{
specifier|register
name|tree
name|endlink
decl_stmt|;
comment|/* Make identifier nodes long enough for the language-specific slots.  */
name|set_identifier_size
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_identifier
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
name|named_labels
operator|=
name|NULL
expr_stmt|;
name|current_binding_level
operator|=
name|NULL_BINDING_LEVEL
expr_stmt|;
name|free_binding_level
operator|=
name|NULL_BINDING_LEVEL
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* make the binding_level structure for global names */
name|global_binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|value_identifier
operator|=
name|get_identifier
argument_list|(
literal|"<value>"
argument_list|)
expr_stmt|;
comment|/* Define `int' and `char' first so that dbx will output them first.  */
name|integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|INT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|,
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Define `char', which is like either `signed char' or `unsigned char'      but not the same as either.  */
name|char_type_node
operator|=
operator|(
name|flag_signed_char
condition|?
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
else|:
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
operator|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"char"
argument_list|)
argument_list|,
name|char_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|long_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long int"
argument_list|)
argument_list|,
name|long_integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|INT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"unsigned int"
argument_list|)
argument_list|,
name|unsigned_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|long_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long unsigned int"
argument_list|)
argument_list|,
name|long_unsigned_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* `unsigned long' or `unsigned int' is the standard type for sizeof.      Traditionally, use a signed type.  */
if|if
condition|(
name|INT_TYPE_SIZE
operator|!=
name|LONG_TYPE_SIZE
condition|)
name|sizetype
operator|=
name|flag_traditional
condition|?
name|long_integer_type_node
else|:
name|long_unsigned_type_node
expr_stmt|;
else|else
name|sizetype
operator|=
name|flag_traditional
condition|?
name|integer_type_node
else|:
name|unsigned_type_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|unsigned_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|long_unsigned_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|long_integer_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|error_mark_node
operator|=
name|make_node
argument_list|(
name|ERROR_MARK
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|error_mark_node
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|short_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|SHORT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"short int"
argument_list|)
argument_list|,
name|short_integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|long_long_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|LONG_LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long long int"
argument_list|)
argument_list|,
name|long_long_integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|short_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|SHORT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"short unsigned int"
argument_list|)
argument_list|,
name|short_unsigned_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|long_long_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|LONG_LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long long unsigned int"
argument_list|)
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Define both `signed char' and `unsigned char'.  */
name|signed_char_type_node
operator|=
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"signed char"
argument_list|)
argument_list|,
name|signed_char_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_char_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"unsigned char"
argument_list|)
argument_list|,
name|unsigned_char_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|float_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|float_type_node
argument_list|)
operator|=
name|FLOAT_TYPE_SIZE
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FLOAT
index|]
argument_list|,
name|float_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|float_type_node
argument_list|)
expr_stmt|;
name|double_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|=
name|DOUBLE_TYPE_SIZE
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_DOUBLE
index|]
argument_list|,
name|double_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|double_type_node
argument_list|)
expr_stmt|;
name|long_double_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|long_double_type_node
argument_list|)
operator|=
name|LONG_DOUBLE_TYPE_SIZE
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long double"
argument_list|)
argument_list|,
name|long_double_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|long_double_type_node
argument_list|)
expr_stmt|;
name|integer_zero_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_zero_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|integer_one_node
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_one_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|size_zero_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|size_zero_node
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|size_one_node
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|size_one_node
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|void_type_node
operator|=
name|make_node
argument_list|(
name|VOID_TYPE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
argument_list|,
name|void_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* Uses integer_zero_node */
name|null_pointer_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
argument_list|)
expr_stmt|;
name|string_type_node
operator|=
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
expr_stmt|;
comment|/* make a type for arrays of 256 characters.      256 is picked randomly because we have a type for integers from 0 to 255.      With luck nothing will ever really depend on the length of this      array type.  */
name|char_array_type_node
operator|=
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
comment|/* Likewise for arrays of ints.  */
name|int_array_type_node
operator|=
name|build_array_type
argument_list|(
name|integer_type_node
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
name|default_function_type
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|endlink
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|double_ftype_double
operator|=
name|build_function_type
argument_list|(
name|double_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|double_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|double_ftype_double_double
operator|=
name|build_function_type
argument_list|(
name|double_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|double_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|double_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|int_ftype_int
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|long_ftype_long
operator|=
name|build_function_type
argument_list|(
name|long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|void_ftype_ptr_ptr_int
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|int_ftype_ptr_ptr_int
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|void_ftype_ptr_int_int
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_alloca"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|,
name|BUILT_IN_ALLOCA
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_abs"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_ABS
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_fabs"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_FABS
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_labs"
argument_list|,
name|long_ftype_long
argument_list|,
name|BUILT_IN_LABS
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_ffs"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_FFS
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_saveregs"
argument_list|,
name|default_function_type
argument_list|,
name|BUILT_IN_SAVEREGS
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_classify_type"
argument_list|,
name|default_function_type
argument_list|,
name|BUILT_IN_CLASSIFY_TYPE
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_next_arg"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|,
name|BUILT_IN_NEXT_ARG
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Support for these has not been written in either expand_builtin      or build_function_call.  */
block|builtin_function ("__builtin_div", default_ftype, BUILT_IN_DIV);   builtin_function ("__builtin_ldiv", default_ftype, BUILT_IN_LDIV);   builtin_function ("__builtin_ffloor", double_ftype_double, BUILT_IN_FFLOOR);   builtin_function ("__builtin_fceil", double_ftype_double, BUILT_IN_FCEIL);   builtin_function ("__builtin_fmod", double_ftype_double_double, BUILT_IN_FMOD);   builtin_function ("__builtin_frem", double_ftype_double_double, BUILT_IN_FREM);   builtin_function ("__builtin_memcpy", void_ftype_ptr_ptr_int, BUILT_IN_MEMCPY);   builtin_function ("__builtin_memcmp", int_ftype_ptr_ptr_int, BUILT_IN_MEMCMP);   builtin_function ("__builtin_memset", void_ftype_ptr_int_int, BUILT_IN_MEMSET);   builtin_function ("__builtin_fsqrt", double_ftype_double, BUILT_IN_FSQRT);   builtin_function ("__builtin_getexp", double_ftype_double, BUILT_IN_GETEXP);   builtin_function ("__builtin_getman", double_ftype_double, BUILT_IN_GETMAN);
endif|#
directive|endif
name|start_identifier_warnings
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a definition for a builtin function named NAME and whose data type    is TYPE.  TYPE should be a function type with argument types.    FUNCTION_CODE tells later passes how to compile calls to this function.    See tree.h for its possible values.  */
end_comment

begin_function
specifier|static
name|void
name|builtin_function
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|function_code
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|enum
name|built_in_function
name|function_code
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_SET_FUNCTION_CODE
argument_list|(
name|decl
argument_list|,
name|function_code
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called when a declaration is seen that contains no names to declare.    If its type is a reference to a structure, union or enum inherited    from a containing scope, shadow that tag name for the current scope    with a forward reference.    If its type defines a new named structure or union    or defines an enum, it is valid but we need not do anything here.    Otherwise, it is an error.  */
end_comment

begin_function
name|void
name|shadow_tag
parameter_list|(
name|declspecs
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
block|{
name|int
name|found_tag
init|=
literal|0
decl_stmt|;
name|int
name|warned
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|declspecs
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
specifier|register
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|int
name|ok
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
comment|/* Used to test also that TYPE_SIZE (value) != 0. 	   That caused warning for `struct foo;' at top level in the file.  */
block|{
specifier|register
name|tree
name|name
init|=
name|lookup_tag_reverse
argument_list|(
name|value
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|t
init|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|current_binding_level
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|!=
literal|0
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
name|found_tag
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|warned
condition|)
name|warning
argument_list|(
literal|"useless keyword or type name in declaration"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|warned
condition|)
block|{
if|if
condition|(
name|found_tag
operator|>
literal|1
condition|)
name|warning
argument_list|(
literal|"multiple types in one declaration"
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_tag
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"empty declaration"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode a "typename", such as "int **", returning a ..._TYPE node.  */
end_comment

begin_function
name|tree
name|groktypename
parameter_list|(
name|typename
parameter_list|)
name|tree
name|typename
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typename
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
name|typename
return|;
return|return
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|TYPENAME
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Decode a declarator in an ordinary declaration or data definition.    This is called as soon as the type information and variable name    have been parsed, before parsing the initializer if any.    Here we create the ..._DECL node, fill in its type,    and put it on the list of decls for the current context.    The ..._DECL node is returned as the value.     Exception: for arrays where the length is not specified,    the type is left null, to be filled in by `finish_decl'.     Function definitions do not come here; they go to start_function    instead.  However, external and forward declarations of functions    do go through here.  Structure field declarations are done by    grokfield and not through here.  */
end_comment

begin_comment
comment|/* Set this to zero to debug not using the temporary obstack    to parse initializers.  */
end_comment

begin_decl_stmt
name|int
name|debug_temp_inits
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|start_decl
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|initialized
parameter_list|)
name|tree
name|declspecs
decl_stmt|,
name|declarator
decl_stmt|;
name|int
name|initialized
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
name|initialized
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|tem
decl_stmt|;
name|int
name|init_written
init|=
name|initialized
decl_stmt|;
if|if
condition|(
name|initialized
condition|)
comment|/* Is it valid for this decl to have an initializer at all?        If not, set INITIALIZED to zero, which will indirectly        tell `finish_decl' to ignore the initializer once it is parsed.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
comment|/* typedef foo = bar  means give foo the same type as bar. 	   We haven't parsed bar yet, so `finish_decl' will fix that up. 	   Any other case of an initialization in a TYPE_DECL is an error.  */
if|if
condition|(
name|pedantic
operator|||
name|list_length
argument_list|(
name|declspecs
argument_list|)
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"typedef `%s' is initialized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
name|error
argument_list|(
literal|"function `%s' is initialized like a variable"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* Don't allow initializations for incomplete types 	   except for arrays which might be completed by the initialization.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
comment|/* A complete type is ok.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"variable `%s' has initializer but incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"elements of array `%s' have incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|initialized
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Seems redundant.  */
block|if (current_binding_level != global_binding_level&& TREE_EXTERNAL (decl)&& TREE_CODE (decl) != FUNCTION_DECL) 	warning ("declaration of `%s' has `extern' and is initialized", 		 IDENTIFIER_POINTER (DECL_NAME (decl)));
endif|#
directive|endif
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Tell `pushdecl' this is an initialized decl 	 even though we don't yet have the initializer expression. 	 Also tell `finish_decl' it may store the real initializer.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Add this decl to the current binding level.      TEM may equal DECL or it may be a previous decl of the same name.  */
name|tem
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* For a local variable, define the RTL now.  */
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
comment|/* But not if this is a duplicate decl 	 and we preserved the rtl from the previous one 	 (which may or may not happen).  */
operator|&&
name|DECL_RTL
argument_list|(
name|tem
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|expand_decl
argument_list|(
name|tem
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|DECL_INITIAL
argument_list|(
name|tem
argument_list|)
operator|!=
literal|0
condition|)
name|expand_decl
argument_list|(
name|tem
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init_written
condition|)
block|{
comment|/* When parsing and digesting the initializer, 	 use temporary storage.  Do this even if we will ignore the value.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
name|debug_temp_inits
condition|)
name|temporary_allocation
argument_list|()
expr_stmt|;
block|}
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Finish processing of a declaration;    install its line number and initial value.    If the length of an array type is not known before,    it must be determined now, from the initial value, or it is an error.  */
end_comment

begin_function
name|void
name|finish_decl
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|,
name|asmspec_tree
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
name|tree
name|asmspec_tree
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|was_incomplete
init|=
operator|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
name|int
name|temporary
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
name|char
modifier|*
name|asmspec
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|asmspec_tree
condition|)
name|asmspec
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|asmspec_tree
argument_list|)
expr_stmt|;
comment|/* If `start_decl' didn't like having an initialization, ignore it now.  */
if|if
condition|(
name|init
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|init
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|store_init_value
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* typedef foo = bar; store the type of bar as the type of foo.  */
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* For top-level declaration, the initial value was read in      the temporary obstack.  MAXINDEX, rtl, etc. to be made below      must go in the permanent obstack; but don't discard the      temporary data yet.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
name|temporary
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* Deduce size of array from initialization, if not already known */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
if|#
directive|if
literal|0
block|int do_default = ! ((!pedantic&& TREE_STATIC (decl)) 			  || TREE_EXTERNAL (decl));
endif|#
directive|endif
name|int
name|do_default
init|=
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
comment|/* Even if pedantic, an external linkage array 	      may have incomplete type at first.  */
condition|?
name|pedantic
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
else|:
operator|!
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
decl_stmt|;
name|int
name|failure
init|=
name|complete_array_type
argument_list|(
name|type
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|do_default
argument_list|)
decl_stmt|;
if|if
condition|(
name|failure
operator|==
literal|1
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"initializer fails to determine size of `%s'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|failure
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|do_default
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"array size missing in `%s'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|pedantic
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|tree_int_cst_lt
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"zero-size array `%s'"
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* A static variable with an incomplete type: 	     that is an error if it is initialized or `static'. 	     Otherwise, let it through, but if it is not `extern' 	     then it may cause an error message later.  */
if|if
condition|(
operator|!
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"storage size of `%s' isn't known"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* An automatic variable with an incomplete type: 	     that is an error.  */
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"storage size of `%s' isn't known"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|TREE_LITERAL
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"storage size of `%s' isn't constant"
argument_list|)
expr_stmt|;
block|}
comment|/* Output the assembler code and/or RTL code for variables and functions,      unless the type is an undefined structure or union.      If not, it will get done when the type is completed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|flag_traditional
operator|&&
name|allocation_temporary_p
argument_list|()
condition|)
block|{
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|current_binding_level
operator|==
name|global_binding_level
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
block|}
else|else
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|current_binding_level
operator|==
name|global_binding_level
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
condition|)
block|{
comment|/* Recompute the RTL of a local array now 	     if it used to be an incomplete type.  */
if|if
condition|(
name|was_incomplete
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If we used it already as memory, it must stay in memory.  */
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If it's still incomplete now, no init will save it.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|expand_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* Compute and store the initial value.  */
name|expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
name|current_binding_level
operator|==
name|global_binding_level
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Resume permanent allocation, if not within a function.  */
if|if
condition|(
name|temporary
operator|&&
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
name|permanent_allocation
argument_list|()
expr_stmt|;
comment|/* We need to remember that this array HAD an initialization, 	 but discard the actual nodes, since they are temporary anyway.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* At the end of a declaration, throw away any variable type sizes      of types defined inside that declaration.  There is no use      computing them in the following function definition.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|get_pending_sizes
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a parsed parameter declaration,    decode it into a PARM_DECL and push that on the current binding level.  */
end_comment

begin_function
name|void
name|push_parm_decl
parameter_list|(
name|parm
parameter_list|)
name|tree
name|parm
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|PARM
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Add this decl to the current binding level.  */
name|finish_decl
argument_list|(
name|pushdecl
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make TYPE a complete type based on INITIAL_VALUE.    Return 0 if successful, 1 if INITIAL_VALUE can't be decyphered,    2 if there was no information (in which case assume 1 if DO_DEFAULT).  */
end_comment

begin_function
name|int
name|complete_array_type
parameter_list|(
name|type
parameter_list|,
name|initial_value
parameter_list|,
name|do_default
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|initial_value
decl_stmt|;
name|int
name|do_default
decl_stmt|;
block|{
specifier|register
name|tree
name|maxindex
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
name|int
name|temporary
init|=
operator|(
name|TREE_PERMANENT
argument_list|(
name|type
argument_list|)
operator|&&
name|allocation_temporary_p
argument_list|()
operator|)
decl_stmt|;
comment|/* Don't put temporary nodes in permanent type.  */
if|if
condition|(
name|temporary
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|initial_value
condition|)
block|{
comment|/* Note MAXINDEX  is really the maximum index, 	 one less than the size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|int
name|eltsize
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|initial_value
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|maxindex
operator|=
name|build_int_2
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|initial_value
argument_list|)
operator|/
name|eltsize
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
specifier|register
name|int
name|nelts
init|=
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|initial_value
argument_list|)
argument_list|)
decl_stmt|;
name|maxindex
operator|=
name|build_int_2
argument_list|(
name|nelts
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make an error message unless that happened already.  */
if|if
condition|(
name|initial_value
operator|!=
name|error_mark_node
condition|)
name|value
operator|=
literal|1
expr_stmt|;
comment|/* Prevent further error messages.  */
name|maxindex
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|maxindex
condition|)
block|{
if|if
condition|(
name|do_default
condition|)
name|maxindex
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|maxindex
condition|)
block|{
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|=
name|build_index_type
argument_list|(
name|maxindex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
operator|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Lay out the type now that we can get the real answer.  */
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|temporary
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given declspecs and a declarator,    determine the name and type of the object declared    and construct a ..._DECL node for it.    (In one case we can return a ..._TYPE node instead.     For invalid input we sometimes return 0.)     DECLSPECS is a chain of tree_list nodes whose value fields     are the storage classes and type specifiers.     DECL_CONTEXT says which syntactic context this declaration is in:      NORMAL for most contexts.  Make a VAR_DECL or FUNCTION_DECL or TYPE_DECL.      FUNCDEF for a function definition.  Like NORMAL but a few different       error messages in each case.  Return value may be zero meaning       this definition is too screwy to try to parse.      PARM for a parameter declaration (either within a function prototype       or before a function body).  Make a PARM_DECL, or return void_type_node.      TYPENAME if for a typename (in a cast or sizeof).       Don't make a DECL node; just return the ..._TYPE node.      FIELD for a struct or union field; make a FIELD_DECL.    INITIALIZED is 1 if the decl has an initializer.     In the TYPENAME case, DECLARATOR is really an absolute declarator.    It may also be so in the PARM case, for a prototype where the    argument type is specified but not the name.     This function is where the complicated C meanings of `static'    and `extern' are intrepreted.  */
end_comment

begin_function
specifier|static
name|tree
name|grokdeclarator
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|decl_context
parameter_list|,
name|initialized
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|enum
name|decl_context
name|decl_context
decl_stmt|;
name|int
name|initialized
decl_stmt|;
block|{
name|int
name|specbits
init|=
literal|0
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|longlong
init|=
literal|0
decl_stmt|;
name|int
name|constp
decl_stmt|;
name|int
name|volatilep
decl_stmt|;
name|int
name|inlinep
decl_stmt|;
name|int
name|explicit_int
init|=
literal|0
decl_stmt|;
name|int
name|explicit_char
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|typedef_type
init|=
literal|0
decl_stmt|;
name|int
name|funcdef_flag
init|=
literal|0
decl_stmt|;
name|int
name|resume_temporary
init|=
literal|0
decl_stmt|;
name|enum
name|tree_code
name|innermost_code
init|=
name|ERROR_MARK
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FUNCDEF
condition|)
name|funcdef_flag
operator|=
literal|1
operator|,
name|decl_context
operator|=
name|NORMAL
expr_stmt|;
if|if
condition|(
name|flag_traditional
operator|&&
name|allocation_temporary_p
argument_list|()
condition|)
block|{
name|resume_temporary
operator|=
literal|1
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
block|}
comment|/* Look inside a declarator for the name being declared      and get it as a string, for an error message.  */
block|{
specifier|register
name|tree
name|decl
init|=
name|declarator
decl_stmt|;
name|name
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|decl
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|ARRAY_REF
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|CALL_EXPR
case|:
name|innermost_code
operator|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|name
operator|=
literal|"type name"
expr_stmt|;
block|}
comment|/* A function definition's declarator must have the form of      a function declarator.  */
if|if
condition|(
name|funcdef_flag
operator|&&
name|innermost_code
operator|!=
name|CALL_EXPR
condition|)
return|return
literal|0
return|;
comment|/* Anything declared one level down from the top level      must be one of the parameters of a function      (because the body is at least two levels down).  */
if|if
condition|(
name|decl_context
operator|==
name|NORMAL
operator|&&
name|current_binding_level
operator|->
name|level_chain
operator|==
name|global_binding_level
condition|)
name|decl_context
operator|=
name|PARM
expr_stmt|;
comment|/* Look through the decl specs and record which ones appear.      Some typespecs are defined as built-in typenames.      Others, the ones that are modifiers of other types,      are represented by bits in SPECBITS: set the bits for      the modifiers that appear.  Storage class keywords are also in SPECBITS.       If there is a typedef name or a type, store the type in TYPE.      This includes builtin typedefs such as `int'.       Set EXPLICIT_INT if the type is `int' or `char' and did not      come from a user typedef.       Set LONGLONG if `long' is mentioned twice.  */
for|for
control|(
name|spec
operator|=
name|declspecs
init|;
name|spec
condition|;
name|spec
operator|=
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|tree
name|id
init|=
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
condition|)
name|explicit_int
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
condition|)
name|explicit_char
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|RID_FIRST_MODIFIER
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|RID_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ridpointers
index|[
name|i
index|]
operator|==
name|id
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|RID_LONG
operator|&&
name|specbits
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"duplicate `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|longlong
condition|)
name|warning
argument_list|(
literal|"`long long long' is too long for GCC"
argument_list|)
expr_stmt|;
else|else
name|longlong
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|warning
argument_list|(
literal|"duplicate `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|specbits
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"two or more data types in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
specifier|register
name|tree
name|t
init|=
name|lookup_name
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|error
argument_list|(
literal|"`%s' fails to be a typedef or built in type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
name|type
operator|=
name|id
expr_stmt|;
name|found
label|:
block|{}
block|}
name|typedef_type
operator|=
name|type
expr_stmt|;
comment|/* No type at all: default to `int', and set EXPLICIT_INT      because it was not a user-defined typedef.  */
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|funcdef_flag
operator|&&
name|warn_return_type
operator|&&
operator|!
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
operator|)
operator|)
condition|)
name|warn_about_return_type
operator|=
literal|1
expr_stmt|;
name|explicit_int
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Now process the modifiers that were specified      and check for invalid combinations.  */
comment|/* Long double is a special combination.  */
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|&&
name|type
operator|==
name|double_type_node
condition|)
block|{
name|specbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
expr_stmt|;
name|type
operator|=
name|long_double_type_node
expr_stmt|;
block|}
comment|/* Check all other uses of type modifiers.  */
if|if
condition|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|explicit_int
operator|&&
operator|!
name|explicit_char
operator|&&
operator|!
name|pedantic
condition|)
name|error
argument_list|(
literal|"long, short, signed or unsigned used invalidly for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|&&
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
condition|)
name|error
argument_list|(
literal|"long and short specified together for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|||
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator|)
operator|&&
name|explicit_char
condition|)
name|error
argument_list|(
literal|"long or short specified with char for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|&&
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
condition|)
name|error
argument_list|(
literal|"signed and unsigned given together for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
condition|)
block|{
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
condition|)
name|type
operator|=
name|long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
condition|)
name|type
operator|=
name|short_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|unsigned_char_type_node
expr_stmt|;
else|else
name|type
operator|=
name|unsigned_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|&&
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|signed_char_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
condition|)
name|type
operator|=
name|long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
condition|)
name|type
operator|=
name|short_integer_type_node
expr_stmt|;
block|}
block|}
comment|/* Set CONSTP if this declaration is `const', whether by      explicit specification or via a typedef.      Likewise for VOLATILEP.  */
name|constp
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_CONST
operator|)
operator|+
name|TREE_READONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|volatilep
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_VOLATILE
operator|)
operator|+
name|TREE_VOLATILE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|inlinep
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_INLINE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|constp
operator|>
literal|1
condition|)
name|warning
argument_list|(
literal|"duplicate `const'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
operator|>
literal|1
condition|)
name|warning
argument_list|(
literal|"duplicate `volatile'"
argument_list|)
expr_stmt|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Warn if two storage classes are given. Default to `auto'.  */
block|{
name|int
name|nclasses
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
condition|)
name|nclasses
operator|++
expr_stmt|;
comment|/* Warn about storage classes that are invalid for certain        kinds of declarations (parameters, typenames, etc.).  */
if|if
condition|(
name|nclasses
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"multiple storage classes in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|funcdef_flag
operator|&&
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
condition|)
name|error
argument_list|(
literal|"function definition declared `auto'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
condition|)
name|error
argument_list|(
literal|"function definition declared `auto'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
condition|)
name|error
argument_list|(
literal|"function definition declared `typedef'"
argument_list|)
expr_stmt|;
name|specbits
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|!=
name|NORMAL
operator|&&
name|nclasses
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|PARM
operator|&&
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
condition|)
empty_stmt|;
else|else
block|{
name|error
argument_list|(
operator|(
name|decl_context
operator|==
name|FIELD
condition|?
literal|"storage class specified for structure field `%s'"
else|:
operator|(
name|decl_context
operator|==
name|PARM
condition|?
literal|"storage class specified for parameter `%s'"
else|:
literal|"storage class specified for typename"
operator|)
operator|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|specbits
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|&&
name|initialized
operator|&&
operator|!
name|funcdef_flag
condition|)
name|warning
argument_list|(
literal|"`%s' initialized and declared `extern'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
condition|)
name|error
argument_list|(
literal|"top-level declaration of `%s' specifies `auto'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Now figure out the structure of the declarator proper.      Descend through it, creating more complex types, until we reach      the declared identifier (or NULL_TREE, in an absolute declarator).  */
while|while
condition|(
name|declarator
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Each level of DECLARATOR is either an ARRAY_REF (for ...[..]), 	 an INDIRECT_REF (for *...), 	 a CALL_EXPR (for ...(...)), 	 an identifier (for the name being declared) 	 or a null pointer (for the place in an absolute declarator 	 where the name was omitted). 	 For the last two cases, we have just exited the loop.  	 At this point, TYPE is the type of elements of an array, 	 or for a function to return, or for a pointer to point to. 	 After this sequence of ifs, TYPE is the type of the 	 array or function or pointer, and DECLARATOR has had its 	 outermost layer removed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
specifier|register
name|tree
name|itype
init|=
name|NULL_TREE
decl_stmt|;
specifier|register
name|tree
name|size
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check for some types that there cannot be arrays of.  */
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
block|{
name|error
argument_list|(
literal|"declaration of `%s' as array of voids"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"declaration of `%s' as array of functions"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
name|error_mark_node
condition|)
name|type
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
comment|/* If size was specified, set ITYPE to a range-type for that size. 	     Otherwise, ITYPE remains null.  finish_decl may figure it out 	     from an initial value.  */
if|if
condition|(
name|size
condition|)
block|{
comment|/* might be a cast */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|size
operator|=
name|TREE_OPERAND
argument_list|(
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"size of array `%s' has non-integer type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
name|integer_zerop
argument_list|(
name|size
argument_list|)
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids zero-size array `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|INT_CST_LT
argument_list|(
name|size
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"size of array `%s' is negative"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
name|itype
operator|=
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|size
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids variable-size array `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|itype
operator|=
name|build_binary_op
argument_list|(
name|MINUS_EXPR
argument_list|,
name|size
argument_list|,
name|integer_one_node
argument_list|)
expr_stmt|;
name|itype
operator|=
name|build_index_type
argument_list|(
name|itype
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Complain about arrays of incomplete types, except in typedefs.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
operator|)
condition|)
name|warning
argument_list|(
literal|"array type has incomplete element type"
argument_list|)
expr_stmt|;
comment|/* Build the array type itself. 	     Merge any constancy or volatility into the target type.  */
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|type
operator|=
name|c_build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* don't clear these; leave them set so that the array type 	   or the variable is itself const or volatile.  */
block|constp = 0; 	  volatilep = 0;
endif|#
directive|endif
name|type
operator|=
name|build_array_type
argument_list|(
name|type
argument_list|,
name|itype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|tree
name|arg_types
decl_stmt|;
comment|/* Declaring a function type. 	     Make sure we have a valid type for the function to return.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|constp
operator|||
name|volatilep
operator|)
condition|)
name|warning
argument_list|(
literal|"function declared to return const or volatile result"
argument_list|)
expr_stmt|;
comment|/* Warn about some types functions can't return.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as function returning a function"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as function returning an array"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Traditionally, declaring return type float means double.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|type
operator|==
name|float_type_node
condition|)
name|type
operator|=
name|double_type_node
expr_stmt|;
comment|/* Construct the function type and go to the next 	     inner layer of declarator.  */
name|arg_types
operator|=
name|grokparms
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
argument_list|,
name|funcdef_flag
comment|/* Say it's a definition 				    only for the CALL_EXPR 				    closest to the identifier.  */
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This seems to be false.  We turn off temporary allocation 	 above in this function if -traditional. 	 And this code caused inconsistent results with prototypes: 	 callers would ignore them, and pass arguments wrong.  */
comment|/* Omit the arg types if -traditional, since the arg types 	     and the list links might not be permanent.  */
block|type = build_function_type (type, flag_traditional ? 0 : arg_types);
endif|#
directive|endif
name|type
operator|=
name|build_function_type
argument_list|(
name|type
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* Merge any constancy or volatility into the target type 	     for the pointer.  */
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|type
operator|=
name|c_build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Process a list of type modifier keywords 	     (such as const or volatile) that were given inside the `*'.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|typemodlist
decl_stmt|;
name|int
name|erred
init|=
literal|0
decl_stmt|;
for|for
control|(
name|typemodlist
operator|=
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
init|;
name|typemodlist
condition|;
name|typemodlist
operator|=
name|TREE_CHAIN
argument_list|(
name|typemodlist
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|typemodlist
argument_list|)
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
condition|)
name|constp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|typemodlist
argument_list|)
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
condition|)
name|volatilep
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|erred
condition|)
block|{
name|erred
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"invalid type modifier within pointer declarator"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|constp
operator|>
literal|1
condition|)
name|warning
argument_list|(
literal|"duplicate `const'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
operator|>
literal|1
condition|)
name|warning
argument_list|(
literal|"duplicate `volatile'"
argument_list|)
expr_stmt|;
block|}
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/*      layout_type (type);  */
comment|/* @@ Should perhaps replace the following code by changes in        * @@ stor_layout.c. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* A function variable in C should be Pmode rather than EPmode 	     because it has just the address of a function, no static chain.*/
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|=
name|Pmode
expr_stmt|;
block|}
block|}
comment|/* Now TYPE has the actual type.  */
comment|/* If this is declaring a typedef name, return a TYPE_DECL.  */
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
condition|)
block|{
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters */
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|type
operator|=
name|c_build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|resume_temporary
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
return|return
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
return|;
block|}
comment|/* Detect the case of an array type of unspecified size      which came, as such, direct from a typedef name.      We must copy the type, so that each identifier gets      a distinct type, so that each identifier's size can be      controlled separately by its own initializer.  */
if|if
condition|(
name|type
operator|!=
literal|0
operator|&&
name|typedef_type
operator|!=
literal|0
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|typedef_type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
name|build_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is a type name (such as, in a cast or sizeof),      compute the type and return it now.  */
if|if
condition|(
name|decl_context
operator|==
name|TYPENAME
condition|)
block|{
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters */
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|type
operator|=
name|c_build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|resume_temporary
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
comment|/* `void' at top level (not within pointer)      is allowed only in typedefs or type names.      We don't complain about parms either, but that is because      a better error message can be made later.  */
if|if
condition|(
name|type
operator|==
name|void_type_node
operator|&&
name|decl_context
operator|!=
name|PARM
condition|)
block|{
name|error
argument_list|(
literal|"variable or field `%s' declared void"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Now create the decl, which may be a VAR_DECL, a PARM_DECL      or a FUNCTION_DECL, depending on DECL_CONTEXT and TYPE.  */
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
block|{
comment|/* A parameter declared as an array of T is really a pointer to T. 	   One declared as a function is really a pointer to a function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Transfer const-ness of array into that of type pointed to.  */
name|type
operator|=
name|build_pointer_type
argument_list|(
name|c_build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|)
expr_stmt|;
name|volatilep
operator|=
name|constp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|constp
operator|||
name|volatilep
operator|)
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids const or volatile function types"
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|c_build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|)
expr_stmt|;
name|volatilep
operator|=
name|constp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|initialized
condition|)
name|error
argument_list|(
literal|"parameter `%s' is initialized"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Compute the type actually passed in the parmlist, 	   for the case where there is no prototype. 	   (For example, shorts and chars are passed as ints.) 	   When there is a prototype, this is overridden later.  */
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|float_type_node
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|double_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
comment|/* ANSI C says short and char are promoted to int 		    or unsigned int, even if that is not wider.  */
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|||
name|type
operator|==
name|short_integer_type_node
operator|||
name|type
operator|==
name|short_unsigned_type_node
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|unsigned_type_node
expr_stmt|;
else|else
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
comment|/* Structure field.  It may not be a function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"field `%s' declared as a function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"field `%s' has incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Move type qualifiers down to element of an array.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|(
name|constp
operator|||
name|volatilep
operator|)
condition|)
block|{
name|type
operator|=
name|c_build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
name|constp
operator|=
name|volatilep
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Note that the grammar rejects storage classes 	   in typenames, fields or parameters */
name|decl
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator|)
condition|)
name|error
argument_list|(
literal|"invalid storage class for function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Function declaration not at top level. 	   Storage classes other than `extern' are not allowed 	   and `extern' makes no difference.  */
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
operator|&&
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_INLINE
operator|)
operator|)
operator|)
operator|&&
name|pedantic
condition|)
name|warning
argument_list|(
literal|"invalid storage class for function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record presence of `static'.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator|)
expr_stmt|;
comment|/* Record presence of `inline', if it is reasonable.  */
if|if
condition|(
name|inlinep
condition|)
block|{
name|tree
name|last
init|=
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|,
literal|"main"
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cannot inline function `main'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last
operator|&&
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
operator|!=
name|void_type_node
condition|)
name|warning
argument_list|(
literal|"inline declaration ignored for function with `...'"
argument_list|)
expr_stmt|;
else|else
comment|/* Assume that otherwise the function can be inlined.  */
name|TREE_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
condition|)
name|current_extern_inline
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It's a variable.  */
comment|/* Move type qualifiers down to element of an array.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|(
name|constp
operator|||
name|volatilep
operator|)
condition|)
block|{
name|type
operator|=
name|c_build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* but a variable whose type is const should still have TREE_READONLY.  */
block|constp = volatilep = 0;
endif|#
directive|endif
block|}
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|inlinep
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"variable `%s' declared `inline'"
argument_list|)
expr_stmt|;
comment|/* An uninitialized decl with `extern' is a reference.  */
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|initialized
operator|&&
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
operator|)
expr_stmt|;
comment|/* At top level, either `static' or no s.c. makes a definition 	   (perhaps tentative), and absence of `static' makes it public.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Not at top level, only `static' makes a static definition.  */
else|else
block|{
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* `extern' with initialization is invalid if not at top level.  */
if|if
condition|(
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
operator|)
operator|&&
name|initialized
condition|)
name|error
argument_list|(
literal|"`%s' has both `extern' and initializer"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Record `register' declaration for warnings on&        and in case doing stupid register allocation.  */
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
condition|)
name|TREE_REGDECL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record constancy and volatility.  */
if|if
condition|(
name|constp
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|volatilep
condition|)
block|{
name|TREE_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|resume_temporary
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a variant type in the proper way for C, propagating qualifiers    down to the element type of an array.  */
end_comment

begin_function
name|tree
name|c_build_type_variant
parameter_list|(
name|type
parameter_list|,
name|constp
parameter_list|,
name|volatilep
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|constp
decl_stmt|,
name|volatilep
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
return|return
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
return|;
return|return
name|build_array_type
argument_list|(
name|c_build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode the parameter-list info for a function type or function definition.    The argument is the value returned by `get_parm_info' (or made in parse.y    if there is an identifier list instead of a parameter decl list).    These two functions are separate because when a function returns    or receives functions then each is called multiple times but the order    of calls is different.  The last call to `grokparms' is always the one    that contains the formal parameter names of a function definition.     Store in `last_function_parms' a chain of the decls of parms.    Also store in `last_function_parm_tags' a chain of the struct and union    tags declared among the parms.     Return a list of arg types to use in the FUNCTION_TYPE for this function.     FUNCDEF_FLAG is nonzero for a function definition, 0 for    a mere declaration.  A nonempty identifier-list gets an error message    when FUNCDEF_FLAG is zero.  */
end_comment

begin_function
specifier|static
name|tree
name|grokparms
parameter_list|(
name|parms_info
parameter_list|,
name|funcdef_flag
parameter_list|)
name|tree
name|parms_info
decl_stmt|;
name|int
name|funcdef_flag
decl_stmt|;
block|{
name|tree
name|first_parm
init|=
name|TREE_CHAIN
argument_list|(
name|parms_info
argument_list|)
decl_stmt|;
name|last_function_parms
operator|=
name|TREE_PURPOSE
argument_list|(
name|parms_info
argument_list|)
expr_stmt|;
name|last_function_parm_tags
operator|=
name|TREE_VALUE
argument_list|(
name|parms_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_strict_prototypes
operator|&&
name|first_parm
operator|==
literal|0
operator|&&
operator|!
name|funcdef_flag
condition|)
name|warning
argument_list|(
literal|"function declaration isn't a prototype"
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_parm
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|first_parm
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
operator|!
name|funcdef_flag
condition|)
name|warning
argument_list|(
literal|"parameter names (without types) in function declaration"
argument_list|)
expr_stmt|;
name|last_function_parms
operator|=
name|first_parm
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|tree
name|parm
decl_stmt|;
name|tree
name|typelt
decl_stmt|;
comment|/* We no longer test FUNCDEF_FLAG. 	 If the arg types are incomplete in a declaration, 	 they must include undefined tags. 	 These tags can never be defined in the scope of the declaration, 	 so the types can never be completed, 	 and no call can be compiled successfully.  */
if|#
directive|if
literal|0
comment|/* In a fcn definition, arg types must be complete.  */
block|if (funcdef_flag)
endif|#
directive|endif
for|for
control|(
name|parm
operator|=
name|last_function_parms
operator|,
name|typelt
operator|=
name|first_parm
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
comment|/* Skip over any enumeration constants declared here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
comment|/* Barf if the parameter itself has an incomplete type.  */
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|typelt
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|funcdef_flag
operator|&&
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"parameter `%s' has incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"parameter has incomplete type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcdef_flag
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|typelt
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* This has been replaced by parm_tags_warning 	  which uses a more accurate criterion for what to warn about.  */
block|else 		{
comment|/* Now warn if is a pointer to an incomplete type.  */
block|while (TREE_CODE (type) == POINTER_TYPE 			 || TREE_CODE (type) == REFERENCE_TYPE) 		    type = TREE_TYPE (type); 		  type = TYPE_MAIN_VARIANT (type); 		  if (TYPE_SIZE (type) == 0) 		    { 		      if (DECL_NAME (parm) != 0) 			warning ("parameter `%s' points to incomplete type", 				 IDENTIFIER_POINTER (DECL_NAME (parm))); 		      else 			warning ("parameter points to incomplete type"); 		    } 		}
endif|#
directive|endif
name|typelt
operator|=
name|TREE_CHAIN
argument_list|(
name|typelt
argument_list|)
expr_stmt|;
block|}
return|return
name|first_parm
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a tree_list node with info on a parameter list just parsed.    The TREE_PURPOSE is a chain of decls of those parms.    The TREE_VALUE is a list of structure, union and enum tags defined.    The TREE_CHAIN is a list of argument types to go in the FUNCTION_TYPE.    This tree_list node is later fed to `grokparms'.     VOID_AT_END nonzero means append `void' to the end of the type-list.    Zero means the parmlist ended with an ellipsis so don't append `void'.  */
end_comment

begin_function
name|tree
name|get_parm_info
parameter_list|(
name|void_at_end
parameter_list|)
name|int
name|void_at_end
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
specifier|register
name|tree
name|types
init|=
literal|0
decl_stmt|;
name|int
name|erred
init|=
literal|0
decl_stmt|;
name|tree
name|tags
init|=
name|gettags
argument_list|()
decl_stmt|;
name|tree
name|parms
init|=
name|nreverse
argument_list|(
name|getdecls
argument_list|()
argument_list|)
decl_stmt|;
comment|/* Just `void' (and no ellipsis) is special.  There are really no parms.  */
if|if
condition|(
name|void_at_end
operator|&&
name|parms
operator|!=
literal|0
operator|&&
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
operator|==
name|void_type_node
operator|&&
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
operator|==
literal|0
condition|)
block|{
name|parms
operator|=
name|NULL_TREE
expr_stmt|;
name|storedecls
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|saveable_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|saveable_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
return|;
block|}
name|storedecls
argument_list|(
name|parms
argument_list|)
expr_stmt|;
for|for
control|(
name|decl
operator|=
name|parms
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
comment|/* There may also be declarations for enumerators if an enumeration        type is declared among the parms.  Ignore them here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
comment|/* Since there is a prototype, 	   args are passed in their declared types.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
endif|#
directive|endif
name|types
operator|=
name|saveable_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|types
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|types
argument_list|)
operator|==
name|void_type_node
operator|&&
operator|!
name|erred
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"`void' in parameter list must be the entire list"
argument_list|)
expr_stmt|;
name|erred
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|void_at_end
condition|)
return|return
name|saveable_tree_cons
argument_list|(
name|parms
argument_list|,
name|tags
argument_list|,
name|nreverse
argument_list|(
name|saveable_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|,
name|types
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|saveable_tree_cons
argument_list|(
name|parms
argument_list|,
name|tags
argument_list|,
name|nreverse
argument_list|(
name|types
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* At end of parameter list, warn about any struct, union or enum tags    defined within.  Do so because these types cannot ever become complete.  */
end_comment

begin_function
name|void
name|parmlist_tags_warning
parameter_list|()
block|{
name|tree
name|elt
decl_stmt|;
specifier|static
name|int
name|already
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|current_binding_level
operator|->
name|tags
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|)
decl_stmt|;
name|warning
argument_list|(
literal|"`%s %s' declared inside parameter list"
argument_list|,
operator|(
name|code
operator|==
name|RECORD_TYPE
condition|?
literal|"struct"
else|:
name|code
operator|==
name|UNION_TYPE
condition|?
literal|"union"
else|:
literal|"enum"
operator|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|already
condition|)
block|{
name|warning
argument_list|(
literal|"its scope is only this definition or declaration,"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"which is probably not what you want."
argument_list|)
expr_stmt|;
name|already
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the struct, enum or union (CODE says which) with tag NAME.    Define the tag as a forward-reference if it is not defined.  */
end_comment

begin_function
name|tree
name|xref_tag
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
name|int
name|temporary
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
comment|/* If a cross reference is requested, look up the type      already defined for this tag and return it.  */
specifier|register
name|tree
name|ref
init|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|current_binding_level
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
condition|)
return|return
name|ref
return|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
name|temporary
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* If no such tag is yet defined, create a forward-reference node      and record it as the "definition".      When a real declaration of this type is found,      the forward-reference will be altered into a real type.  */
name|ref
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
comment|/* (In ANSI, Enums can be referred to only if already defined.)  */
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids forward references to `enum' types"
argument_list|)
expr_stmt|;
comment|/* Give the type a default layout like unsigned int 	 to avoid crashing if it does not get defined.  */
name|TYPE_MODE
argument_list|(
name|ref
argument_list|)
operator|=
name|SImode
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
block|}
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
name|temporary
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make sure that the tag NAME is defined *in the current binding level*    at least as a forward reference.    CODE says which kind of tag NAME ought to be.  */
end_comment

begin_function
name|tree
name|start_struct
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
comment|/* If there is already a tag defined at this binding level      (as a forward reference), just return it.  */
specifier|register
name|tree
name|ref
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
operator|!=
literal|0
condition|)
name|ref
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|current_binding_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|code
condition|)
block|{
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|ref
argument_list|)
condition|)
name|error
argument_list|(
operator|(
name|code
operator|==
name|UNION_TYPE
condition|?
literal|"redefinition of `union %s'"
else|:
literal|"redefinition of `struct %s'"
operator|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
comment|/* Otherwise create a forward-reference just so the tag is in scope.  */
name|ref
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_comment
comment|/* Process the specs, declarator (NULL if omitted) and width (NULL if omitted)    of a structure component, returning a FIELD_DECL node.    WIDTH is non-NULL for bit fields only, and is an INTEGER_CST node.     This is done during the parsing of the struct declaration.    The FIELD_DECL nodes are chained together and the lot of them    are ultimately passed to `build_struct' to make the RECORD_TYPE node.  */
end_comment

begin_function
name|tree
name|grokfield
parameter_list|(
name|filename
parameter_list|,
name|line
parameter_list|,
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|width
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|,
name|width
decl_stmt|;
block|{
specifier|register
name|tree
name|value
init|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|FIELD
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|finish_decl
argument_list|(
name|value
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
operator|=
name|width
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fill in the fields of a RECORD_TYPE or UNION_TYPE node, T.    FIELDLIST is a chain of FIELD_DECL nodes for the fields.  */
end_comment

begin_function
name|tree
name|finish_struct
parameter_list|(
name|t
parameter_list|,
name|fieldlist
parameter_list|)
specifier|register
name|tree
name|t
decl_stmt|,
name|fieldlist
decl_stmt|;
block|{
specifier|register
name|tree
name|x
decl_stmt|;
name|int
name|old_momentary
decl_stmt|;
name|int
name|round_up_size
init|=
literal|1
decl_stmt|;
comment|/* If this type was previously laid out as a forward reference,      make sure we lay it out again.  */
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|extra_warnings
operator|&&
name|in_parm_level_p
argument_list|()
condition|)
name|warning
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|?
literal|"union defined inside parms"
else|:
literal|"structure defined inside parms"
operator|)
argument_list|)
expr_stmt|;
name|old_momentary
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
if|if
condition|(
name|fieldlist
operator|==
literal|0
operator|&&
name|pedantic
condition|)
name|warning
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|?
literal|"union has no members"
else|:
literal|"structure has no members"
operator|)
argument_list|)
expr_stmt|;
comment|/* Install struct as DECL_CONTEXT of each field decl.      Also process specified field sizes.      Set DECL_SIZE_UNIT to the specified size, or 0 if none specified.      The specified size is found in the DECL_INITIAL.      Store 0 there, except for ": 0" fields (so we can find them      and delete them, below).  */
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If any field is const, the structure type is pseudo-const.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|x
argument_list|)
condition|)
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* A field that is pseudo-const makes the structure likewise.  */
name|tree
name|t1
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|t1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t1
argument_list|)
condition|)
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Detect invalid bit-field size.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"bit-field `%s' width not an integer constant"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Detect invalid bit-field type.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"bit-field `%s' has invalid type"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|&&
name|pedantic
operator|&&
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|!=
name|integer_type_node
operator|&&
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|!=
name|unsigned_type_node
condition|)
name|warning_with_decl
argument_list|(
name|x
argument_list|,
literal|"bit-field `%s' type invalid in ANSI C"
argument_list|)
expr_stmt|;
comment|/* Detect and ignore out of range field width.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
specifier|register
name|int
name|width
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|warning_with_decl
argument_list|(
name|x
argument_list|,
literal|"negative width in bit-field `%s'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|==
literal|0
operator|&&
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"zero width for bit-field `%s'"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|warning_with_decl
argument_list|(
name|x
argument_list|,
literal|"width of `%s' exceeds its type"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process valid field width.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
specifier|register
name|int
name|width
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
block|{
comment|/* field size 0 => mark following field as "aligned" */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_ALIGN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|EMPTY_FIELD_BOUNDARY
argument_list|)
expr_stmt|;
comment|/* field of size 0 at the end => round up the size.  */
else|else
name|round_up_size
operator|=
name|EMPTY_FIELD_BOUNDARY
expr_stmt|;
block|}
else|else
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|x
argument_list|)
operator|=
name|width
expr_stmt|;
name|TREE_PACKED
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Traditionally a bit field is unsigned 		 even if declared signed.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|unsigned_type_node
expr_stmt|;
block|}
block|}
else|else
comment|/* Non-bit-fields are aligned for their type.  */
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now DECL_INITIAL is null on all members except for zero-width bit-fields.      And they have already done their work.  */
comment|/* Delete all zero-width bit-fields from the front of the fieldlist */
while|while
condition|(
name|fieldlist
operator|&&
name|DECL_INITIAL
argument_list|(
name|fieldlist
argument_list|)
condition|)
name|fieldlist
operator|=
name|TREE_CHAIN
argument_list|(
name|fieldlist
argument_list|)
expr_stmt|;
comment|/* Delete all such members from the rest of the fieldlist */
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Delete all duplicate fields from the fieldlist */
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
operator|&&
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
condition|;
control|)
comment|/* Anonymous fields aren't duplicates.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|tree
name|y
init|=
name|fieldlist
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|y
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|y
operator|==
name|x
condition|)
break|break;
name|y
operator|=
name|TREE_CHAIN
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|y
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|,
literal|"duplicate member `%s'"
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Now we have the final fieldlist.  Record it,      then lay out the structure or union (including the fields).  */
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|fieldlist
expr_stmt|;
comment|/* If there's a :0 field at the end, round the size to the      EMPTY_FIELD_BOUNDARY.  */
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
name|round_up_size
expr_stmt|;
for|for
control|(
name|x
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|x
argument_list|)
control|)
block|{
name|TYPE_FIELDS
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Promote each bit-field's type to int if it is narrower than that.  */
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|TREE_PACKED
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|*
name|DECL_SIZE_UNIT
argument_list|(
name|x
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
comment|/* If this structure or union completes the type of any previous      variable declaration, lay it out and output its rtl.  */
if|if
condition|(
name|current_binding_level
operator|->
name|n_incomplete
operator|!=
literal|0
condition|)
block|{
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|int
name|toplevel
init|=
name|global_binding_level
operator|==
name|current_binding_level
decl_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
name|toplevel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toplevel
condition|)
name|expand_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
operator|--
name|current_binding_level
operator|->
name|n_incomplete
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|element
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|element
operator|=
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|==
name|t
condition|)
name|layout_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|resume_momentary
argument_list|(
name|old_momentary
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Lay out the type T, and its element type, and so on.  */
end_comment

begin_function
specifier|static
name|void
name|layout_array_type
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|layout_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin compiling the definition of an enumeration type.    NAME is its name (or null if anonymous).    Returns the type object, as yet incomplete.    Also records info about it so that build_enumerator    may be used to declare the individual values as they are read.  */
end_comment

begin_function
name|tree
name|start_enum
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|enumtype
init|=
literal|0
decl_stmt|;
comment|/* If this is the real definition for a previous forward reference,      fill in the contents in the same object that used to be the      forward reference.  */
if|if
condition|(
name|name
operator|!=
literal|0
condition|)
name|enumtype
operator|=
name|lookup_tag
argument_list|(
name|ENUMERAL_TYPE
argument_list|,
name|name
argument_list|,
name|current_binding_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|enumtype
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|enumtype
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|enumtype
operator|=
name|make_node
argument_list|(
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|enumtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* This enum is a named one that has been declared already.  */
name|error
argument_list|(
literal|"redeclaration of `enum %s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Completely replace its old definition. 	 The old enumerators remain defined, however.  */
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Initially, set up this enum as like `int'      so that we can create the enumerators' declarations and values.      Later on, the precision of the type may be changed and      it may be laid out again.  */
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|0
expr_stmt|;
name|fixup_unsigned_type
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|enum_next_value
operator|=
name|integer_zero_node
expr_stmt|;
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* After processing and defining all the values of an enumeration type,    install their decls in the enumeration type and finish it off.    ENUMTYPE is the type object and VALUES a list of name-value pairs.    Returns ENUMTYPE.  */
end_comment

begin_function
name|tree
name|finish_enum
parameter_list|(
name|enumtype
parameter_list|,
name|values
parameter_list|)
specifier|register
name|tree
name|enumtype
decl_stmt|,
name|values
decl_stmt|;
block|{
specifier|register
name|tree
name|pair
decl_stmt|;
specifier|register
name|long
name|maxvalue
init|=
literal|0
decl_stmt|;
specifier|register
name|long
name|minvalue
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|in_parm_level_p
argument_list|()
condition|)
name|warning
argument_list|(
literal|"enum defined inside parms"
argument_list|)
expr_stmt|;
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
name|values
expr_stmt|;
comment|/* Calculate the maximum value of any enumerator in this type.  */
for|for
control|(
name|pair
operator|=
name|values
init|;
name|pair
condition|;
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|pair
argument_list|)
control|)
block|{
name|int
name|value
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
name|values
condition|)
name|minvalue
operator|=
name|maxvalue
operator|=
name|value
expr_stmt|;
else|else
block|{
if|if
condition|(
name|value
operator|>
name|maxvalue
condition|)
name|maxvalue
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|<
name|minvalue
condition|)
name|minvalue
operator|=
name|value
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_short_enums
condition|)
block|{
comment|/* Determine the precision this type needs, lay it out, and define it.  */
for|for
control|(
name|i
operator|=
name|maxvalue
init|;
name|i
condition|;
name|i
operator|>>=
literal|1
control|)
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
condition|)
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Cancel the laying out previously done for the enum type, 	 so that fixup_unsigned_type will do it over.  */
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|0
expr_stmt|;
name|fixup_unsigned_type
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
block|}
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|enumtype
argument_list|)
argument_list|)
operator|=
name|maxvalue
expr_stmt|;
comment|/* An enum can have some negative values; then it is signed.  */
if|if
condition|(
name|minvalue
operator|<
literal|0
condition|)
block|{
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|enumtype
argument_list|)
argument_list|)
operator|=
name|minvalue
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|enumtype
argument_list|)
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* Build and install a CONST_DECL for one value of the    current enumeration type (one that was begun with start_enum).    Return a tree-list containing the name and its value.    Assignment of sequential values by default is handled here.  */
end_comment

begin_function
name|tree
name|build_enumerator
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|tree
name|name
decl_stmt|,
name|value
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
comment|/* Validate and default VALUE.  */
comment|/* Remove no-op casts from the value.  */
while|while
condition|(
name|value
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|value
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"enumerator value for `%s' not integer constant"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Default based on previous value.  */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
name|enum_next_value
expr_stmt|;
comment|/* Might as well enforce the ANSI restriction, since      values outside this range don't work in version 1.  */
if|if
condition|(
operator|!
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|integer_type_node
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"enumerator value outside range of `int'"
argument_list|)
expr_stmt|;
name|value
operator|=
name|integer_zero_node
expr_stmt|;
block|}
comment|/* Set basis for default for next value.  */
name|enum_next_value
operator|=
name|build_binary_op_nodefault
argument_list|(
name|PLUS_EXPR
argument_list|,
name|value
argument_list|,
name|integer_one_node
argument_list|,
name|PLUS_EXPR
argument_list|)
expr_stmt|;
comment|/* Now create a declaration for the enum value name.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|name
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|saveable_tree_cons
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the FUNCTION_DECL for a function definition.    DECLSPECS and DECLARATOR are the parts of the declaration;    they describe the function's name and the type it returns,    but twisted together in a fashion that parallels the syntax of C.     This function creates a binding context for the function body    as well as setting up the FUNCTION_DECL in current_function_decl.     Returns 1 on success.  If the DECLARATOR is not suitable for a function    (it defines a datum instead), we return 0, which tells    yyparse to report a parse error.  */
end_comment

begin_function
name|int
name|start_function
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|;
block|{
name|tree
name|decl1
decl_stmt|,
name|old_decl
decl_stmt|;
name|tree
name|restype
decl_stmt|;
name|current_function_returns_value
operator|=
literal|0
expr_stmt|;
comment|/* Assume, until we see it does. */
name|current_function_returns_null
operator|=
literal|0
expr_stmt|;
name|warn_about_return_type
operator|=
literal|0
expr_stmt|;
name|current_extern_inline
operator|=
literal|0
expr_stmt|;
name|decl1
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|FUNCDEF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If the declarator is not suitable for a function definition,      cause a syntax error.  */
if|if
condition|(
name|decl1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|current_function_decl
operator|=
name|decl1
expr_stmt|;
name|announce_function
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"return-type is an incomplete type"
argument_list|)
expr_stmt|;
comment|/* Make it return void instead.  */
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|warn_about_return_type
condition|)
name|warning
argument_list|(
literal|"return-type defaults to `int'"
argument_list|)
expr_stmt|;
comment|/* Save the parm names or decls from this function's declarator      where store_parm_decls will find them.  */
name|current_function_parms
operator|=
name|last_function_parms
expr_stmt|;
name|current_function_parm_tags
operator|=
name|last_function_parm_tags
expr_stmt|;
comment|/* Make the init_value nonzero so pushdecl knows this is not tentative.      error_mark_node is replaced below (in poplevel) with the LET_STMT.  */
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* If this definition isn't a prototype and we had a prototype declaration      before, copy the arg type info from that prototype.  */
name|old_decl
operator|=
name|lookup_name_current_level
argument_list|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_decl
operator|!=
literal|0
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
argument_list|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
comment|/* This is a definition, not a reference.      So normally clear TREE_EXTERNAL.      However, `extern inline' acts like a declaration      except for defining how to inline.  So set TREE_EXTERNAL in that case.  */
name|TREE_EXTERNAL
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|current_extern_inline
expr_stmt|;
comment|/* This function exists in static storage.      (This does not mean `static' in the C sense!)  */
name|TREE_STATIC
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record the decl so that the function name is defined.      If we already have a decl for this name, and it is a FUNCTION_DECL,      use the old decl.  */
name|current_function_decl
operator|=
name|pushdecl
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|declare_parm_level
argument_list|()
expr_stmt|;
name|make_function_rtl
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|restype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Promote the value to int before returning it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|restype
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|restype
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|restype
operator|=
name|integer_type_node
expr_stmt|;
name|DECL_RESULT_TYPE
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|restype
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
name|value_identifier
argument_list|,
name|restype
argument_list|)
expr_stmt|;
comment|/* Allocate further tree nodes temporarily during compilation      of this function only.  */
name|temporary_allocation
argument_list|()
expr_stmt|;
comment|/* If this fcn was already referenced via a block-scope `extern' decl      (or an implicit decl), propagate certain information about the usage.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store the parameter declarations into the current function declaration.    This is called after parsing the parameter declarations, before    digesting the body of the function.  */
end_comment

begin_function
name|void
name|store_parm_decls
parameter_list|()
block|{
specifier|register
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
specifier|register
name|tree
name|parm
decl_stmt|;
comment|/* This is either a chain of PARM_DECLs (if a prototype was used)      or a list of IDENTIFIER_NODEs (for an old-fashioned C definition).  */
name|tree
name|specparms
init|=
name|current_function_parms
decl_stmt|;
comment|/* This is a list of types declared among parms in a prototype.  */
name|tree
name|parmtags
init|=
name|current_function_parm_tags
decl_stmt|;
comment|/* This is a chain of PARM_DECLs from old-style parm declarations.  */
specifier|register
name|tree
name|parmdecls
init|=
name|getdecls
argument_list|()
decl_stmt|;
comment|/* This is a chain of any other decls that came in among the parm      declarations.  If a parm is declared with  enum {foo, bar} x;      then CONST_DECLs for foo and bar are put here.  */
name|tree
name|nonparms
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|specparms
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|specparms
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
comment|/* This case is when the function was defined with an ANSI prototype. 	 The parms already have decls, so we need not do anything here 	 except record them as in effect 	 and complain if any redundant old-style parm decls were written.  */
specifier|register
name|tree
name|next
decl_stmt|;
name|tree
name|others
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|parmdecls
operator|!=
literal|0
condition|)
name|error_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"parm types given both in parmlist and separately"
argument_list|)
expr_stmt|;
name|specparms
operator|=
name|nreverse
argument_list|(
name|specparms
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|specparms
init|;
name|parm
condition|;
name|parm
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
condition|)
name|error_with_decl
argument_list|(
name|parm
argument_list|,
literal|"parameter name omitted"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|==
name|void_type_node
condition|)
name|error_with_decl
argument_list|(
name|parm
argument_list|,
literal|"parameter `%s' declared void"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If we find an enum constant, put it aside for the moment.  */
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
name|others
operator|=
name|chainon
argument_list|(
name|others
argument_list|,
name|parm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get the decls in their original chain order 	 and record in the function.  */
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|getdecls
argument_list|()
expr_stmt|;
comment|/* Now pushdecl the enum constants.  */
for|for
control|(
name|parm
operator|=
name|others
init|;
name|parm
condition|;
name|parm
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|==
name|void_type_node
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
name|storetags
argument_list|(
name|chainon
argument_list|(
name|parmtags
argument_list|,
name|gettags
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* SPECPARMS is an identifier list--a chain of TREE_LIST nodes 	 each with a parm name as the TREE_VALUE.  	 PARMDECLS is a list of declarations for parameters. 	 Warning! It can also contain CONST_DECLs which are not parameters 	 but are names of enumerators of any enum types 	 declared among the parameters.  	 First match each formal parameter name with its declaration. 	 Associate decls with the names and store the decls 	 into the TREE_PURPOSE slots.  */
for|for
control|(
name|parm
operator|=
name|specparms
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
specifier|register
name|tree
name|tail
decl_stmt|,
name|found
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"parameter name missing from parameter list"
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* See if any of the parmdecls specifies this parm by name. 	     Ignore any enumerator decls.  */
for|for
control|(
name|tail
operator|=
name|parmdecls
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|tail
argument_list|)
operator|==
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|tail
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|found
operator|=
name|tail
expr_stmt|;
break|break;
block|}
comment|/* If declaration already marked, we have a duplicate name. 	     Complain, and don't use this decl twice.   */
if|if
condition|(
name|found
operator|&&
name|DECL_CONTEXT
argument_list|(
name|found
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|found
argument_list|,
literal|"multiple parameters named `%s'"
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If the declaration says "void", complain and ignore it.  */
if|if
condition|(
name|found
operator|&&
name|TREE_TYPE
argument_list|(
name|found
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|error_with_decl
argument_list|(
name|found
argument_list|,
literal|"parameter `%s' declared void"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|found
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|found
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|layout_decl
argument_list|(
name|found
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If no declaration found, default to int.  */
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|found
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|found
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|found
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|found
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|warning_with_decl
argument_list|(
name|found
argument_list|,
literal|"type of `%s' defaults to `int'"
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|found
argument_list|)
expr_stmt|;
block|}
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|=
name|found
expr_stmt|;
comment|/* Mark this decl as "already found" -- see test, above. 	     It is safe to clobber DECL_CONTEXT temporarily 	     because the final values are not stored until 	     the `poplevel' in `finish_function'.  */
name|DECL_CONTEXT
argument_list|(
name|found
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Complain about declarations not matched with any names. 	 Put any enumerator constants onto the list NONPARMS.  */
name|nonparms
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|parmdecls
init|;
name|parm
condition|;
control|)
block|{
name|tree
name|next
init|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Complain about args with incomplete types.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|parm
argument_list|,
literal|"parameter `%s' has incomplete type"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|nonparms
operator|=
name|chainon
argument_list|(
name|nonparms
argument_list|,
name|parm
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|parm
argument_list|,
literal|"declaration for parameter `%s' but no such parameter"
argument_list|)
expr_stmt|;
comment|/* Pretend the parameter was not missing. 		 This gets us to a standard state and minimizes 		 further error messages.  */
name|specparms
operator|=
name|chainon
argument_list|(
name|specparms
argument_list|,
name|tree_cons
argument_list|(
name|parm
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|parm
operator|=
name|next
expr_stmt|;
block|}
comment|/* Chain the declarations together in the order of the list of names.  */
comment|/* Store that chain in the function decl, replacing the list of names.  */
name|parm
operator|=
name|specparms
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|{
specifier|register
name|tree
name|last
decl_stmt|;
for|for
control|(
name|last
operator|=
literal|0
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
if|if
condition|(
name|last
operator|==
literal|0
condition|)
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|last
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|last
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If there was a previous prototype, 	 set the DECL_ARG_TYPE of each argument according to 	 the type previously specified, and report any mismatches.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|type
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|,
name|type
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
init|;
name|parm
operator|||
operator|(
name|type
operator|&&
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
operator|!=
name|void_type_node
operator|)
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|,
name|type
operator|=
name|TREE_CHAIN
argument_list|(
name|type
argument_list|)
control|)
block|{
if|if
condition|(
name|parm
operator|==
literal|0
operator|||
name|type
operator|==
literal|0
operator|||
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|error
argument_list|(
literal|"number of arguments doesn't match prototype"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Type for passing arg must be consistent 		 with that declared for the arg.  */
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"argument `%s' doesn't match function prototype"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|==
name|integer_type_node
operator|&&
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"a formal parameter type that promotes to `int'"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"can match only `int' in the prototype"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|==
name|double_type_node
operator|&&
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"a formal parameter type that promotes to `double'"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"can match only `double' in the prototype"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Now store the final chain of decls for the arguments 	 as the decl-chain of the current lexical scope. 	 Put the enumerators in as well, at the front so that 	 DECL_ARGUMENTS is not modified.  */
name|storedecls
argument_list|(
name|chainon
argument_list|(
name|nonparms
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure the binding level for the top of the function body      gets a LET_STMT if there are any in the function.      Otherwise, the dbx output is wrong.  */
name|keep_next_if_subblocks
operator|=
literal|1
expr_stmt|;
comment|/* Initialize the RTL code for the function.  */
name|init_function_start
argument_list|(
name|fndecl
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
comment|/* Set up parameters and prepare for return, for the function.  */
name|expand_function_start
argument_list|(
name|fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Finish up a function declaration and compile that function    all the way to assembler language output.  The free the storage    for the function definition.     This is called after parsing the body of the function definition.    LINENO is the current line number.  */
end_comment

begin_function
name|void
name|finish_function
parameter_list|(
name|lineno
parameter_list|)
name|int
name|lineno
decl_stmt|;
block|{
specifier|register
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
comment|/*  TREE_READONLY (fndecl) = 1;     This caused&foo to be of type ptr-to-const-function     which then got a warning when stored in a ptr-to-function variable.  */
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Must mark the RESULT_DECL as being in this function.  */
name|DECL_CONTEXT
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Obey `register' declarations if `setjmp' is called in this fn.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|current_function_calls_setjmp
condition|)
name|setjmp_protect
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generate rtl for function exit.  */
name|expand_function_end
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
comment|/* So we can tell if jump_optimize sets it to 1.  */
name|current_function_returns_null
operator|=
literal|0
expr_stmt|;
comment|/* Run the optimizers and output the assembler code for this function.  */
name|rest_of_compilation
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|current_function_returns_null
condition|)
name|warning
argument_list|(
literal|"`volatile' function does return"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_return_type
operator|&&
name|current_function_returns_null
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
comment|/* If this function returns non-void and control can drop through,        complain.  */
name|warning
argument_list|(
literal|"control reaches end of non-void function"
argument_list|)
expr_stmt|;
comment|/* With just -W, complain only if function returns both with      and without a value.  */
elseif|else
if|if
condition|(
name|extra_warnings
operator|&&
name|current_function_returns_value
operator|&&
name|current_function_returns_null
condition|)
name|warning
argument_list|(
literal|"this function may return with or without a value"
argument_list|)
expr_stmt|;
comment|/* Free all the tree nodes making up this function.  */
comment|/* Switch back to allocating nodes permanently      until we start another function.  */
name|permanent_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Stop pointing to the local nodes about to be freed.  */
comment|/* But DECL_INITIAL must remain nonzero so we know this 	 was an actual function definition.  */
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Let the error reporting routines know that we're outside a function.  */
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

