begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Save and restore call-clobbered registers which are live across a call.    Copyright (C) 1989 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_comment
comment|/* Set of hard regs currently live (during scan of all insns).  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|hard_regs_live
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The block of storage on the stack where regs are saved */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|save_block_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|save_block_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A REG rtx for each hard register that has been saved.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|save_reg_rtx
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|set_reg_live
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_reg_live
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insert_call_saves
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_mult_save
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_mult_restore
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|grow_save_block
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|machine_mode
name|choose_hard_reg_mode
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Find the places where hard regs are live across calls and save them.  */
end_comment

begin_macro
name|save_call_clobbered_regs
argument_list|()
end_macro

begin_block
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|b
decl_stmt|;
if|if
condition|(
name|obey_regdecls
condition|)
return|return;
name|save_block_size
operator|=
literal|0
expr_stmt|;
name|save_block_addr
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|save_reg_rtx
argument_list|,
sizeof|sizeof
name|save_reg_rtx
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
block|{
name|regset
name|regs_live
init|=
name|basic_block_live_at_start
index|[
name|b
index|]
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|bit
decl_stmt|,
name|i
decl_stmt|;
comment|/* Compute hard regs live at start of block -- this is the 	 real hard regs marked live, plus live pseudo regs that 	 have been renumbered to hard regs.  */
ifdef|#
directive|ifdef
name|HARD_REG_SET
name|hard_regs_live
operator|=
operator|*
name|regs_live
expr_stmt|;
else|#
directive|else
name|COPY_HARD_REG_SET
argument_list|(
name|hard_regs_live
argument_list|,
name|regs_live
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|offset
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|offset
operator|<
name|regset_size
condition|;
name|offset
operator|++
control|)
block|{
if|if
condition|(
name|regs_live
index|[
name|offset
index|]
operator|==
literal|0
condition|)
name|i
operator|+=
name|HOST_BITS_PER_INT
expr_stmt|;
else|else
for|for
control|(
name|bit
operator|=
literal|1
init|;
name|bit
operator|&&
name|i
operator|<
name|max_regno
condition|;
name|bit
operator|<<=
literal|1
operator|,
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regs_live
index|[
name|offset
index|]
operator|&
name|bit
operator|)
operator|&&
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|reg_renumber
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Now scan the insns in the block, keeping track of what hard 	 regs are live as we go.  When we see a call, save the live 	 call-clobbered hard regs.  */
for|for
control|(
name|insn
operator|=
name|basic_block_head
index|[
name|b
index|]
init|;
name|TRUE
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|CALL_INSN
condition|)
name|insert_call_saves
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INSN
operator|||
name|code
operator|==
name|CALL_INSN
operator|||
name|code
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|link
decl_stmt|;
comment|/* NB: the normal procedure is to first enliven any 		 registers set by insn, then deaden any registers that 		 had their last use at insn.  This is incorrect now, 		 since multiple pseudos may have been mapped to the 		 same hard reg, and the death notes are ambiguous.  So 		 it must be done in the other, safe, order.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
condition|)
name|clear_reg_live
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|set_reg_live
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|basic_block_end
index|[
name|b
index|]
condition|)
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Here from note_stores when an insn stores a value in a register.    Set the proper bit or bits in hard_regs_live.  */
end_comment

begin_function
specifier|static
name|void
name|set_reg_live
parameter_list|(
name|reg
parameter_list|,
name|setter
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|setter
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
comment|/* WORD is which word of a multi-register group is being stored.      For the case where the store is actually into a SUBREG of REG.      Except we don't use it; I believe the entire REG needs to be      live.  */
name|int
name|word
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|word
operator|=
name|SUBREG_WORD
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* For pseudo reg, see if it has been assigned a hardware reg.  */
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
comment|/* + word */
expr_stmt|;
comment|/* Handle hardware regs (and pseudos allocated to hard regs).  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|call_fixed_regs
index|[
name|regno
index|]
condition|)
block|{
specifier|register
name|int
name|last
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|last
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Here when a REG_DEAD note records the last use of a reg.  Clear    the appropriate bit or bits in hard_regs_live.  */
end_comment

begin_function
specifier|static
name|void
name|clear_reg_live
parameter_list|(
name|reg
parameter_list|)
name|rtx
name|reg
decl_stmt|;
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
comment|/* For pseudo reg, see if it has been assigned a hardware reg.  */
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
comment|/* Handle hardware regs (and pseudos allocated to hard regs).  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|call_fixed_regs
index|[
name|regno
index|]
condition|)
block|{
comment|/* Pseudo regs already assigned hardware regs are treated 	 almost the same as explicit hardware regs.  */
specifier|register
name|int
name|last
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|regno
operator|<
name|last
condition|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Insert insns to save and restore live call-clobbered regs around    call insn INSN.  */
end_comment

begin_function
specifier|static
name|void
name|insert_call_saves
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
name|int
name|save_block_size_needed
decl_stmt|;
name|int
name|save_block_offset
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|save_block_size_needed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|regno
control|)
block|{
name|save_block_offset
index|[
name|regno
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|call_fixed_regs
index|[
name|regno
index|]
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|choose_hard_reg_mode
argument_list|(
name|regno
argument_list|)
decl_stmt|;
name|int
name|align
init|=
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|align
operator|>
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
condition|)
name|align
operator|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|save_block_size_needed
operator|=
operator|(
operator|(
name|save_block_size_needed
operator|+
name|align
operator|-
literal|1
operator|)
operator|/
name|align
operator|)
operator|*
name|align
expr_stmt|;
name|save_block_offset
index|[
name|regno
index|]
operator|=
name|save_block_size_needed
expr_stmt|;
name|save_block_size_needed
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|save_reg_rtx
index|[
name|regno
index|]
condition|)
name|save_reg_rtx
index|[
name|regno
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|save_block_size
operator|<
name|save_block_size_needed
condition|)
name|save_block_addr
operator|=
name|grow_save_block
argument_list|(
name|save_block_addr
argument_list|,
name|save_block_size_needed
argument_list|)
expr_stmt|;
name|emit_mult_save
argument_list|(
name|insn
argument_list|,
name|save_block_addr
argument_list|,
name|save_block_offset
argument_list|)
expr_stmt|;
name|emit_mult_restore
argument_list|(
name|insn
argument_list|,
name|save_block_addr
argument_list|,
name|save_block_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit a string of stores to save the hard regs listed in    OFFSET[] at address ADDR.  Emit them before INSN.    OFFSET[reg] is -1 if reg should not be saved, or a    suitably-aligned offset from ADDR.      The offsets actually used do not have to be those listed    in OFFSET, but should fit in a block of the same size.  */
end_comment

begin_function
specifier|static
name|void
name|emit_mult_save
parameter_list|(
name|insn
parameter_list|,
name|addr
parameter_list|,
name|offset
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|offset
index|[]
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
comment|/* A register to use as a temporary for address calculations.  */
name|rtx
name|tempreg
decl_stmt|;
comment|/* A register that could be used as that temp if we save and restore it.  */
name|rtx
name|can_push_reg
decl_stmt|;
comment|/* Nonzero means we need to save a register to use it as TEMPREG.  */
name|int
name|needpush
decl_stmt|;
comment|/* The amount the stack is decremented to save that register (if we do).  */
name|int
name|decrement
decl_stmt|;
comment|/* Record which regs we save, in case we branch to retry.  */
name|char
name|already_saved
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|bzero
argument_list|(
name|already_saved
argument_list|,
sizeof|sizeof
name|already_saved
argument_list|)
expr_stmt|;
comment|/* Hair is needed because sometimes the addresses to save in are      not valid (offsets too big).      So we need a reg, TEMPREG, to compute addresses in.       We look first for an empty reg to use.      Sometimes no reg is empty.  Then we push a reg, use it, and pop it.       Sometimes the only reg to push and pop this way is one we want to save.      We can't save it while using it as a temporary.      So we save all the other registers, pop it, and go back to `retry'.      At that point, only this reg remains to be saved;      all the others already saved are empty.      So one of them can be the temporary for this one.  */
comment|/* Sometimes we can't save all the regs conveniently at once, just some.      If that happens, we branch back here to save the rest.  */
name|retry
label|:
name|needpush
operator|=
literal|0
expr_stmt|;
name|tempreg
operator|=
literal|0
expr_stmt|;
name|can_push_reg
operator|=
literal|0
expr_stmt|;
comment|/* Set NEEDPUSH if any save-addresses are not valid memory addresses.      If any register is available, record it in TEMPREG.      If any register doesn't need saving here, record it in CAN_PUSH_REG.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|regno
control|)
block|{
if|if
condition|(
name|offset
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
operator|!
name|already_saved
index|[
name|regno
index|]
condition|)
block|{
name|rtx
name|reg
init|=
name|save_reg_rtx
index|[
name|regno
index|]
decl_stmt|;
name|rtx
name|addr1
init|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|offset
index|[
name|regno
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|addr1
argument_list|)
condition|)
name|needpush
operator|=
literal|1
expr_stmt|;
block|}
comment|/* A call-clobbered reg that is dead, or already saved, 	 can be used as a temporary for sure, at no extra cost.  */
if|if
condition|(
name|tempreg
operator|==
literal|0
operator|&&
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|&&
operator|!
operator|(
name|offset
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
operator|!
name|already_saved
index|[
name|regno
index|]
operator|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
name|tempreg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Don't use it if not valid for addressing.  */
if|if
condition|(
operator|!
name|strict_memory_address_p
argument_list|(
name|QImode
argument_list|,
name|tempreg
argument_list|)
condition|)
name|tempreg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* A call-saved reg can be a temporary if we push and pop it.  */
if|if
condition|(
name|can_push_reg
operator|==
literal|0
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
name|can_push_reg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Don't use it if not valid for addressing.  */
if|if
condition|(
operator|!
name|strict_memory_address_p
argument_list|(
name|QImode
argument_list|,
name|can_push_reg
argument_list|)
condition|)
name|can_push_reg
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Clear NEEDPUSH if we already found an empty reg.  */
if|if
condition|(
name|tempreg
operator|!=
literal|0
condition|)
name|needpush
operator|=
literal|0
expr_stmt|;
comment|/* If we need a temp reg and none is free, make one free.  */
if|if
condition|(
name|needpush
condition|)
block|{
comment|/* Choose a reg, preferably not among those it is our job to save.  */
if|if
condition|(
name|can_push_reg
operator|!=
literal|0
condition|)
name|tempreg
operator|=
name|can_push_reg
expr_stmt|;
else|else
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|offset
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
operator|!
name|already_saved
index|[
name|regno
index|]
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
name|tempreg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Don't use it if not valid for addressing.  */
if|if
condition|(
operator|!
name|strict_memory_address_p
argument_list|(
name|QImode
argument_list|,
name|tempreg
argument_list|)
condition|)
name|tempreg
operator|=
literal|0
expr_stmt|;
else|else
break|break;
block|}
block|}
comment|/* Push it on the stack.  */
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|decrement
operator|=
name|UNITS_PER_WORD
expr_stmt|;
else|#
directive|else
name|decrement
operator|=
operator|-
name|UNITS_PER_WORD
expr_stmt|;
endif|#
directive|endif
name|emit_insn_before
argument_list|(
name|gen_add2_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|decrement
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|,
name|tempreg
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Save the regs we are supposed to save, aside from TEMPREG.      Use TEMPREG for address calculations when needed.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|offset
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
operator|!
name|already_saved
index|[
name|regno
index|]
operator|&&
name|tempreg
operator|!=
literal|0
operator|&&
name|REGNO
argument_list|(
name|tempreg
argument_list|)
operator|!=
name|regno
condition|)
block|{
name|rtx
name|reg
init|=
name|save_reg_rtx
index|[
name|regno
index|]
decl_stmt|;
name|rtx
name|addr1
init|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|offset
index|[
name|regno
index|]
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|addr1
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr1
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|tempreg
argument_list|,
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_add2_insn
argument_list|(
name|tempreg
argument_list|,
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|addr1
operator|=
name|tempreg
expr_stmt|;
block|}
name|temp
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|addr1
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|temp
argument_list|,
name|reg
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|already_saved
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we pushed TEMPREG to make it free, pop it.  */
if|if
condition|(
name|needpush
condition|)
block|{
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|tempreg
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_add2_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|decrement
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* If TEMPREG itself needs saving, go back and save it.      There are plenty of free regs now, those already saved.  */
if|if
condition|(
name|tempreg
operator|!=
literal|0
operator|&&
name|offset
index|[
name|REGNO
argument_list|(
name|tempreg
argument_list|)
index|]
operator|>=
literal|0
operator|&&
operator|!
name|already_saved
index|[
name|REGNO
argument_list|(
name|tempreg
argument_list|)
index|]
condition|)
goto|goto
name|retry
goto|;
block|}
end_function

begin_comment
comment|/* Emit a string of loads to restore the hard regs listed in    OFFSET[] from address ADDR; insert the loads after INSN.    OFFSET[reg] is -1 if reg should not be loaded, or a    suitably-aligned offset from ADDR.      The offsets actually used do not need to be those provided in    OFFSET, but should agree with whatever emit_mult_save does.  */
end_comment

begin_function
specifier|static
name|void
name|emit_mult_restore
parameter_list|(
name|insn
parameter_list|,
name|addr
parameter_list|,
name|offset
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|offset
index|[]
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
comment|/* Number of regs now needing to be restored.  */
name|int
name|restore_count
decl_stmt|;
comment|/* A register to use as a temporary for address calculations.  */
name|rtx
name|tempreg
decl_stmt|;
comment|/* A register available for that purpose but less desirable.  */
name|rtx
name|maybe_tempreg
decl_stmt|;
comment|/* A register that could be used as that temp if we push and pop it.  */
name|rtx
name|can_push_reg
decl_stmt|;
comment|/* Nonzero means we need to push and pop a register to use it as TEMPREG.  */
name|int
name|needpush
decl_stmt|;
comment|/* The amount the stack is decremented to save that register (if we do).  */
name|int
name|decrement
decl_stmt|;
comment|/* Record which regs we restore, in case we branch to retry.  */
name|char
name|already_restored
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|bzero
argument_list|(
name|already_restored
argument_list|,
sizeof|sizeof
name|already_restored
argument_list|)
expr_stmt|;
comment|/* Note: INSN can't be the last insn, since if it were,      no regs would live across it.  */
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Now we can insert before INSN.      That is convenient because we can insert them in the order      that they should ultimately appear.  */
comment|/* Hair is needed because sometimes the addresses to restore from are      not valid (offsets too big).      So we need a reg, TEMPREG, to compute addresses in.       We look first for an empty reg to use.      Sometimes no reg is empty.  Then we push a reg, use it, and pop it.       If all the suitable regs need to be restored,      that strategy won't work.  So we restore all but one, using that one      as a temporary.  Then we jump to `retry' to restore that one,      pushing and popping another (already restored) as a temporary.  */
name|retry
label|:
name|needpush
operator|=
literal|0
expr_stmt|;
name|tempreg
operator|=
literal|0
expr_stmt|;
name|can_push_reg
operator|=
literal|0
expr_stmt|;
name|restore_count
operator|=
literal|0
expr_stmt|;
comment|/* Set NEEDPUSH if any restore-addresses are not valid memory addresses.      If any register is available, record it in TEMPREG.      Otherwise, one register yet to be restored goes in MAYBE_TEMPREG,      and can be used as TEMPREG for any other regs to be restored.      If any register doesn't need restoring, record it in CAN_PUSH_REG.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|regno
control|)
block|{
if|if
condition|(
name|offset
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
operator|!
name|already_restored
index|[
name|regno
index|]
condition|)
block|{
name|rtx
name|reg
init|=
name|save_reg_rtx
index|[
name|regno
index|]
decl_stmt|;
name|rtx
name|addr1
init|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|offset
index|[
name|regno
index|]
argument_list|)
decl_stmt|;
name|restore_count
operator|++
expr_stmt|;
if|if
condition|(
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|addr1
argument_list|)
condition|)
name|needpush
operator|=
literal|1
expr_stmt|;
comment|/* Find a call-clobbered reg that needs restoring. 	     We can use it as a temporary if we defer restoring it.  */
if|if
condition|(
name|maybe_tempreg
operator|==
literal|0
condition|)
block|{
name|maybe_tempreg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Don't use it if not valid for addressing.  */
if|if
condition|(
operator|!
name|strict_memory_address_p
argument_list|(
name|QImode
argument_list|,
name|maybe_tempreg
argument_list|)
condition|)
name|maybe_tempreg
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If any call-clobbered reg is dead, put it in TEMPREG. 	 It can be used as a temporary at no extra cost.  */
if|if
condition|(
name|tempreg
operator|==
literal|0
operator|&&
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|offset
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
name|tempreg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Don't use it if not valid for addressing.  */
if|if
condition|(
operator|!
name|strict_memory_address_p
argument_list|(
name|QImode
argument_list|,
name|tempreg
argument_list|)
condition|)
name|tempreg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Any non-call-clobbered reg, put in CAN_PUSH_REG. 	 It can be used as a temporary if we push and pop it.  */
if|if
condition|(
name|can_push_reg
operator|==
literal|0
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
name|can_push_reg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Don't use it if not valid for addressing.  */
if|if
condition|(
operator|!
name|strict_memory_address_p
argument_list|(
name|QImode
argument_list|,
name|can_push_reg
argument_list|)
condition|)
name|can_push_reg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Any reg we already restored can be a temporary 	 if we push and pop it.  */
if|if
condition|(
name|can_push_reg
operator|==
literal|0
operator|&&
name|already_restored
index|[
name|regno
index|]
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
name|can_push_reg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|Pmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Don't use it if not valid for addressing.  */
if|if
condition|(
operator|!
name|strict_memory_address_p
argument_list|(
name|QImode
argument_list|,
name|can_push_reg
argument_list|)
condition|)
name|can_push_reg
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If 2 or more regs need to be restored, use one as a temp reg      for the rest (if we need a tempreg).  */
if|if
condition|(
name|tempreg
operator|==
literal|0
operator|&&
name|maybe_tempreg
operator|!=
literal|0
operator|&&
name|restore_count
operator|>
literal|1
condition|)
name|tempreg
operator|=
name|maybe_tempreg
expr_stmt|;
comment|/* Clear NEEDPUSH if we already found an empty reg.  */
if|if
condition|(
name|tempreg
operator|!=
literal|0
condition|)
name|needpush
operator|=
literal|0
expr_stmt|;
comment|/* If we need a temp reg and none is free, make one free.  */
if|if
condition|(
name|needpush
condition|)
block|{
name|tempreg
operator|=
name|can_push_reg
expr_stmt|;
comment|/* Push it on the stack.  */
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|decrement
operator|=
name|UNITS_PER_WORD
expr_stmt|;
else|#
directive|else
name|decrement
operator|=
operator|-
name|UNITS_PER_WORD
expr_stmt|;
endif|#
directive|endif
name|emit_insn_before
argument_list|(
name|gen_add2_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|decrement
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|,
name|tempreg
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the regs we are supposed to restore, aside from TEMPREG.      Use TEMPREG for address calculations when needed.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|offset
index|[
name|regno
index|]
operator|>=
literal|0
operator|&&
operator|!
name|already_restored
index|[
name|regno
index|]
operator|&&
name|tempreg
operator|!=
literal|0
operator|&&
name|REGNO
argument_list|(
name|tempreg
argument_list|)
operator|!=
name|regno
condition|)
block|{
name|rtx
name|reg
init|=
name|save_reg_rtx
index|[
name|regno
index|]
decl_stmt|;
name|rtx
name|addr1
init|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|offset
index|[
name|regno
index|]
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|addr1
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr1
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|tempreg
argument_list|,
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_add2_insn
argument_list|(
name|tempreg
argument_list|,
name|XEXP
argument_list|(
name|addr1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|addr1
operator|=
name|tempreg
expr_stmt|;
block|}
name|temp
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|addr1
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|reg
argument_list|,
name|temp
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|already_restored
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we pushed TEMPREG to make it free, pop it.  */
if|if
condition|(
name|needpush
condition|)
block|{
name|emit_insn_before
argument_list|(
name|gen_move_insn
argument_list|(
name|tempreg
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_add2_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|decrement
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* If TEMPREG itself needs restoring, go back and restore it.      We can find a reg already restored to push and use as a temporary.  */
if|if
condition|(
name|tempreg
operator|!=
literal|0
operator|&&
name|offset
index|[
name|REGNO
argument_list|(
name|tempreg
argument_list|)
index|]
operator|>=
literal|0
operator|&&
operator|!
name|already_restored
index|[
name|REGNO
argument_list|(
name|tempreg
argument_list|)
index|]
condition|)
goto|goto
name|retry
goto|;
block|}
end_function

begin_comment
comment|/* Return the address of a new block of size SIZE on the stack.    The old save block is at ADDR; ADDR is 0 if no block exists yet.  */
end_comment

begin_function
specifier|static
name|rtx
name|grow_save_block
parameter_list|(
name|addr
parameter_list|,
name|size
parameter_list|)
name|rtx
name|addr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|rtx
name|newaddr
decl_stmt|;
comment|/* Keep the size a multiple of the main allocation unit.  */
name|size
operator|=
operator|(
operator|(
operator|(
name|size
operator|+
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
operator|)
operator|/
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
comment|/* If no save block exists yet, create one and return it.  */
if|if
condition|(
operator|!
name|addr
condition|)
block|{
name|save_block_size
operator|=
name|size
expr_stmt|;
return|return
name|XEXP
argument_list|(
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|size
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* Get a new block and coalesce it with the old one.  */
name|newaddr
operator|=
name|XEXP
argument_list|(
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|size
operator|-
name|save_block_size
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|newaddr
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|newaddr
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|newaddr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|newaddr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|size
operator|-
name|save_block_size
operator|)
operator|||
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|newaddr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|size
operator|-
name|save_block_size
operator|)
operator|)
condition|)
block|{
name|save_block_size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|newaddr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|newaddr
return|;
else|else
return|return
name|addr
return|;
block|}
comment|/* They didn't coalesce, find out why */
name|abort
argument_list|()
expr_stmt|;
name|save_block_size
operator|=
name|size
expr_stmt|;
return|return
name|XEXP
argument_list|(
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
name|size
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a machine mode that is legitimate for hard reg REGNO    and large enough to save the whole register.  */
end_comment

begin_function
specifier|static
name|enum
name|machine_mode
name|choose_hard_reg_mode
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|enum
name|reg_class
name|class
init|=
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|CLASS_MAX_NREGS
argument_list|(
name|class
argument_list|,
name|DImode
argument_list|)
operator|==
literal|1
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|DImode
argument_list|)
condition|)
return|return
name|DImode
return|;
elseif|else
if|if
condition|(
name|CLASS_MAX_NREGS
argument_list|(
name|class
argument_list|,
name|DFmode
argument_list|)
operator|==
literal|1
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|DFmode
argument_list|)
condition|)
return|return
name|DFmode
return|;
elseif|else
if|if
condition|(
name|CLASS_MAX_NREGS
argument_list|(
name|class
argument_list|,
name|SImode
argument_list|)
operator|==
literal|1
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|SImode
argument_list|)
condition|)
return|return
name|SImode
return|;
elseif|else
if|if
condition|(
name|CLASS_MAX_NREGS
argument_list|(
name|class
argument_list|,
name|SFmode
argument_list|)
operator|==
literal|1
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|SFmode
argument_list|)
condition|)
return|return
name|SFmode
return|;
elseif|else
if|if
condition|(
name|CLASS_MAX_NREGS
argument_list|(
name|class
argument_list|,
name|HImode
argument_list|)
operator|==
literal|1
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|HImode
argument_list|)
condition|)
return|return
name|HImode
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

