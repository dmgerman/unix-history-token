begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)cc.c	6.7 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*-    Copyright (C) 1987,1989 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  This paragraph is here to try to keep Sun CC from dying. The number of chars here seems crucial!!!!  */
end_comment

begin_function_decl
name|void
name|record_temp_file
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* This program is the user interface to the C compiler and possibly to other compilers.  It is used because compilation is a complicated procedure which involves running several programs and passing temporary files between them, forwarding the users switches to those programs selectively, and deleting the temporary files at the end.  CC recognizes how to compile each input file by suffixes in the file names. Once it knows which kind of compilation to perform, the procedure for compilation is specified by a string called a "spec".  Specs are strings containing lines, each of which (if not blank) is made up of a program name, and arguments separated by spaces. The program name must be exact and start from root, since no path is searched and it is unreliable to depend on the current working directory. Redirection of input or output is not supported; the subprograms must accept filenames saying what files to read and write.  In addition, the specs can contain %-sequences to substitute variable text or for conditional text.  Here is a table of all defined %-sequences. Note that spaces are not generated automatically around the results of expanding these sequences; therefore, you can concatenate them together or with constant text in a single argument.   %%	substitute one % into the program name or argument.  %i     substitute the name of the input file being processed.  %b     substitute the basename of the input file being processed. 	This is the substring up to (and not including) the last period.  %g     substitute the temporary-file-name-base.  This is a string chosen 	once per compilation.  Different temporary file names are made by 	concatenation of constant strings on the end, as in `%g.s'. 	%g also has the same effect of %d.  %d	marks the argument containing or following the %d as a 	temporary file name, so that that file will be deleted if CC exits 	successfully.  Unlike %g, this contributes no text to the argument.  %w	marks the argument containing or following the %w as the 	"output file" of this compilation.  This puts the argument 	into the sequence of arguments that %o will substitute later.  %W{...} 	like %{...} but mark last argument supplied within 	as a file to be deleted on failure.  %o	substitutes the names of all the output files, with spaces 	automatically placed around them.  You should write spaces 	around the %o as well or the results are undefined. 	%o is for use in the specs for running the linker. 	Input files whose names have no recognized suffix are not compiled 	at all, but they are included among the output files, so they will 	be linked.  %p	substitutes the standard macro predefinitions for the 	current target machine.  Use this when running cpp.  %P	like %p, but puts `__' before and after the name of each macro. 	This is for ANSI C.  %s     current argument is the name of a library or startup file of some sort.         Search for that file in a standard list of directories 	and substitute the full pathname found.  %eSTR  Print STR as an error message.  STR is terminated by a newline.         Use this when inconsistent options are detected.  %a     process ASM_SPEC as a spec.         This allows config.h to specify part of the spec for running as.  %l     process LINK_SPEC as a spec.  %L     process LIB_SPEC as a spec.  %S     process STARTFILE_SPEC as a spec.  A capital S is actually used here.  %E     process ENDFILE_SPEC as a spec.  A capital E is actually used here.  %c	process SIGNED_CHAR_SPEC as a spec.  %C     process CPP_SPEC as a spec.  A capital C is actually used here.  %1	process CC1_SPEC as a spec.  %{S}   substitutes the -S switch, if that switch was given to CC. 	If that switch was not specified, this substitutes nothing. 	Here S is a metasyntactic variable.  %{S*}  substitutes all the switches specified to CC whose names start 	with -S.  This is used for -o, -D, -I, etc; switches that take 	arguments.  CC considers `-o foo' as being one switch whose 	name starts with `o'.  %{o*} would substitute this text, 	including the space; thus, two arguments would be generated.  %{S:X} substitutes X, but only if the -S switch was given to CC.  %{!S:X} substitutes X, but only if the -S switch was NOT given to CC.  %{|S:X} like %{S:X}, but if no S switch, substitute `-'.  %{|!S:X} like %{!S:X}, but if there is an S switch, substitute `-'.  The conditional text X in a %{S:X} or %{!S:X} construct may contain other nested % constructs or spaces, or even newlines. They are processed as usual, as described above.  The character | is used to indicate that a command should be piped to the following command, but only if -pipe is specified.  Note that it is built into CC which switches take arguments and which do not.  You might think it would be useful to generalize this to allow each compiler's spec to say which switches take arguments.  But this cannot be done in a consistent fashion.  CC cannot even decide which input files have been specified without knowing which switches take arguments, and it must know which input files to compile in order to tell which compilers to run.  CC also knows implicitly that arguments starting in `-l' are to be treated as compiler output files, and passed to the linker in their proper position among the other output files.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"gvarargs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|R_OK
end_ifndef

begin_define
define|#
directive|define
name|R_OK
value|4
end_define

begin_define
define|#
directive|define
name|W_OK
value|2
end_define

begin_define
define|#
directive|define
name|X_OK
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|vfork
value|fork
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_function_decl
specifier|extern
name|int
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* If a stage of compilation returns an exit status>= 1,    compilation of that file ceases.  */
end_comment

begin_define
define|#
directive|define
name|MIN_FATAL_STATUS
value|1
end_define

begin_comment
comment|/* This is the obstack which we use to allocate many strings.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|obstack
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|handle_braces
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|save_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|concat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|do_spec
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|do_spec_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|find_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|find_exec_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|validate_switches
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|validate_all_switches
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fancy_abort
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* config.h can define ASM_SPEC to provide extra args to the assembler    or extra switch-translations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_SPEC
end_ifndef

begin_define
define|#
directive|define
name|ASM_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define CPP_SPEC to provide extra args to the C preprocessor    or extra switch-translations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CPP_SPEC
end_ifndef

begin_define
define|#
directive|define
name|CPP_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define CC1_SPEC to provide extra args to cc1    or extra switch-translations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CC1_SPEC
end_ifndef

begin_define
define|#
directive|define
name|CC1_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define LINK_SPEC to provide extra args to the linker    or extra switch-translations.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LINK_SPEC
end_ifndef

begin_define
define|#
directive|define
name|LINK_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define LIB_SPEC to override the default libraries.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LIB_SPEC
end_ifndef

begin_define
define|#
directive|define
name|LIB_SPEC
value|"%{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define ENDFILE_SPEC to override the default crtn files.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ENDFILE_SPEC
end_ifndef

begin_define
define|#
directive|define
name|ENDFILE_SPEC
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* config.h can define STARTFILE_SPEC to override the default crt0 files.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STARTFILE_SPEC
end_ifndef

begin_define
define|#
directive|define
name|STARTFILE_SPEC
define|\
value|"%{pg:gcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This spec is used for telling cpp whether char is signed or not.  */
end_comment

begin_define
define|#
directive|define
name|SIGNED_CHAR_SPEC
define|\
value|(DEFAULT_SIGNED_CHAR ? "%{funsigned-char:-D__CHAR_UNSIGNED__}"	\    : "%{!fsigned-char:-D__CHAR_UNSIGNED__}")
end_define

begin_comment
comment|/* This defines which switch letters take arguments.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SWITCH_TAKES_ARG
end_ifndef

begin_define
define|#
directive|define
name|SWITCH_TAKES_ARG
parameter_list|(
name|CHAR
parameter_list|)
define|\
value|((CHAR) == 'D' || (CHAR) == 'U' || (CHAR) == 'o' \    || (CHAR) == 'e' || (CHAR) == 'T' || (CHAR) == 'u' \    || (CHAR) == 'I' || (CHAR) == 'Y' || (CHAR) == 'm' \    || (CHAR) == 'L' || (CHAR) == 'i' || (CHAR) == 'A')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This defines which multi-letter switches take arguments.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WORD_SWITCH_TAKES_ARG
end_ifndef

begin_define
define|#
directive|define
name|WORD_SWITCH_TAKES_ARG
parameter_list|(
name|STR
parameter_list|)
value|(!strcmp (STR, "Tdata"))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This structure says how to run one compiler, and when to do so.  */
end_comment

begin_struct
struct|struct
name|compiler
block|{
name|char
modifier|*
name|suffix
decl_stmt|;
comment|/* Use this compiler for input files 				   whose names end in this suffix.  */
name|char
modifier|*
name|spec
decl_stmt|;
comment|/* To use this compiler, pass this spec 				   to do_spec.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Here are the specs for compiling files with various known suffixes.    A file that does not end in any of these suffixes will be passed    unchanged to the loader and nothing else will be done to it.  */
end_comment

begin_decl_stmt
name|struct
name|compiler
name|compilers
index|[]
init|=
block|{
block|{
literal|".c"
block|,
literal|"cpp %{nostdinc} %{C} %{v} %{D*} %{U*} %{I*} %{M*} %{i*} %{trigraphs} -undef \         -D__GNUC__ %{ansi:-trigraphs -$ -D__STRICT_ANSI__} %{!ansi:%p} %P\         %c %{O:-D__OPTIMIZE__} %{traditional} %{pedantic} %{P}\ 	%{Wcomment*} %{Wtrigraphs} %{Wall} %{w} %C\         %i %{!M*:%{!E:%{!pipe:%g.cpp}}}%{E:%W{o*}}%{M*:%W{o*}} |\n\     %{!M*:%{!E:cc1 %{!pipe:%g.cpp} %1 \ 		   %{!Q:-quiet} -dumpbase %i %{Y*} %{d*} %{m*} %{f*} %{a}\ 		   %{g} %{O} %{W*} %{w} %{pedantic} %{ansi} %{traditional}\ 		   %{v:-version} %{gg:-symout %g.sym} %{pg:-p} %{p}\ 		   %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\ 		   %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\n\               %{!S:as %{R} %{j} %{J} %{h} %{d2} %a %{gg:-G %g.sym}\ 		      %{c:%W{o*}%{!o*:-o %w%b.o}}%{!c:-o %d%w%b.o}\                       %{!pipe:%g.s}\n }}}"
block|}
block|,
block|{
literal|".cc"
block|,
literal|"cpp -+ %{nostdinc} %{C} %{v} %{D*} %{U*} %{I*} %{M*} %{i*} \         -undef -D__GNUC__ -D__GNUG__ %p %P\         %c %{O:-D__OPTIMIZE__} %{traditional} %{pedantic} %{P}\ 	%{Wcomment*} %{Wtrigraphs} %{Wall} %{w} %C\         %i %{!M*:%{!E:%{!pipe:%g.cpp}}}%{E:%W{o*}}%{M*:%W{o*}} |\n\     %{!M*:%{!E:cc1plus %{!pipe:%g.cpp} %1\ 		   %{!Q:-quiet} -dumpbase %i %{Y*} %{d*} %{m*} %{f*} %{a}\ 		   %{g} %{O} %{W*} %{w} %{pedantic} %{traditional}\ 		   %{v:-version} %{gg:-symout %g.sym} %{pg:-p} %{p}\ 		   %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\ 		   %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\n\               %{!S:as %{R} %{j} %{J} %{h} %{d2} %a %{gg:-G %g.sym}\ 		      %{c:%W{o*}%{!o*:-o %w%b.o}}%{!c:-o %d%w%b.o}\                       %{!pipe:%g.s}\n }}}"
block|}
block|,
block|{
literal|".i"
block|,
literal|"cc1 %i %1 %{!Q:-quiet} %{Y*} %{d*} %{m*} %{f*} %{a}\ 	%{g} %{O} %{W*} %{w} %{pedantic} %{ansi} %{traditional}\ 	%{v:-version} %{gg:-symout %g.sym} %{pg:-p} %{p}\ 	%{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\n\     %{!S:as %{R} %{j} %{J} %{h} %{d2} %a %{gg:-G %g.sym}\             %{c:%W{o*}%{!o*:-o %w%b.o}}%{!c:-o %d%w%b.o} %{!pipe:%g.s}\n }"
block|}
block|,
block|{
literal|".s"
block|,
literal|"%{!S:as %{R} %{j} %{J} %{h} %{d2} %a \             %{c:%W{o*}%{!o*:-o %w%b.o}}%{!c:-o %d%w%b.o} %i\n }"
block|}
block|,
block|{
literal|".S"
block|,
literal|"cpp %{nostdinc} %{C} %{v} %{D*} %{U*} %{I*} %{M*} %{trigraphs} \         -undef -D__GNUC__ -$ %p %P\         %c %{O:-D__OPTIMIZE__} %{traditional} %{pedantic} %{P}\ 	%{Wcomment*} %{Wtrigraphs} %{Wall} %{w} %C\         %i %{!M*:%{!E:%{!pipe:%g.s}}}%{E:%W{o*}}%{M*:%W{o*}} |\n\     %{!M*:%{!E:%{!S:as %{R} %{j} %{J} %{h} %{d2} %a \                     %{c:%W{o*}%{!o*:-o %w%b.o}}%{!c:-o %d%w%b.o}\ 		    %{!pipe:%g.s}\n }}}"
block|}
block|,
comment|/* Mark end of table */
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Here is the spec for running the linker, after compiling all files.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|link_spec
init|=
literal|"%{!c:%{!M*:%{!E:%{!S:ld %{o*} %l\  %{A} %{d} %{e*} %{N} %{n} %{r} %{s} %{S} %{T*} %{t} %{u*} %{X} %{x} %{z}\  %{y*} %{!A:%{!nostdlib:%S}} \  %{L*} %o %{!nostdlib:%L -lgnulib %{!A:%E}}\n }}}}"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Accumulate a command (program name and args), and run it.  */
end_comment

begin_comment
comment|/* Vector of pointers to arguments in the current line of specifications.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements allocated in argbuf.  */
end_comment

begin_decl_stmt
name|int
name|argbuf_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in argbuf currently in use (containing args).  */
end_comment

begin_decl_stmt
name|int
name|argbuf_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of commands executed so far.  */
end_comment

begin_decl_stmt
name|int
name|execution_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating whether we should print the command and arguments */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|vflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name with which this program was invoked.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|programname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* User-specified -B prefix to attach to command names,    or 0 if none specified.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|user_exec_prefix
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Environment-specified prefix to attach to command names,    or 0 if none specified.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|env_exec_prefix
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Suffix to attach to directories searched for commands.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|machine_suffix
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default prefixes to attach to command names.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STANDARD_EXEC_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|STANDARD_EXEC_PREFIX
value|"/usr/libexec/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined STANDARD_EXEC_PREFIX */
end_comment

begin_decl_stmt
name|char
modifier|*
name|standard_exec_prefix
init|=
name|STANDARD_EXEC_PREFIX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|standard_exec_prefix_1
init|=
literal|"/usr/libexec/gcc-"
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|STANDARD_STARTFILE_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|STANDARD_STARTFILE_PREFIX
value|"/usr/lib/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined STANDARD_STARTFILE_PREFIX */
end_comment

begin_decl_stmt
name|char
modifier|*
name|standard_startfile_prefix
init|=
name|STANDARD_STARTFILE_PREFIX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|standard_startfile_prefix_1
init|=
literal|"/usr/local/lib/"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|standard_startfile_prefix_2
init|=
literal|"/usr/lib/gcc-"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Clear out the vector of arguments (after a command is executed).  */
end_comment

begin_function
name|void
name|clear_args
parameter_list|()
block|{
name|argbuf_index
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add one argument to the vector at the end.    This is done when a space is seen or at the end of the line.    If DELETE_ALWAYS is nonzero, the arg is a filename     and the file should be deleted eventually.    If DELETE_FAILURE is nonzero, the arg is a filename     and the file should be deleted if this compilation fails.  */
end_comment

begin_function
name|void
name|store_arg
parameter_list|(
name|arg
parameter_list|,
name|delete_always
parameter_list|,
name|delete_failure
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|delete_always
decl_stmt|,
name|delete_failure
decl_stmt|;
block|{
if|if
condition|(
name|argbuf_index
operator|+
literal|1
operator|==
name|argbuf_length
condition|)
block|{
name|argbuf
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|argbuf
argument_list|,
operator|(
name|argbuf_length
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|argbuf
index|[
name|argbuf_index
operator|++
index|]
operator|=
name|arg
expr_stmt|;
name|argbuf
index|[
name|argbuf_index
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|delete_always
operator|||
name|delete_failure
condition|)
name|record_temp_file
argument_list|(
name|arg
argument_list|,
name|delete_always
argument_list|,
name|delete_failure
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record the names of temporary files we tell compilers to write,    and delete them at the end of the run.  */
end_comment

begin_comment
comment|/* This is the common prefix we use to make temp file names.    It is chosen once for each run of this program.    It is substituted into a spec by %g.    Thus, all temp file names contain this prefix.    In practice, all temp file names start with this prefix.     This prefix comes from the envvar TMPDIR if it is defined;    otherwise, in /tmp.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|temp_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of the prefix.  */
end_comment

begin_decl_stmt
name|int
name|temp_filename_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the list of temporary files to delete.  */
end_comment

begin_struct
struct|struct
name|temp_file
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|temp_file
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Queue of files to delete on success or failure of compilation.  */
end_comment

begin_decl_stmt
name|struct
name|temp_file
modifier|*
name|always_delete_queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Queue of files to delete on failure of compilation.  */
end_comment

begin_decl_stmt
name|struct
name|temp_file
modifier|*
name|failure_delete_queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record FILENAME as a file to be deleted automatically.    ALWAYS_DELETE nonzero means delete it if all compilation succeeds;    otherwise delete it in any case.    FAIL_DELETE nonzero means delete it if a compilation step fails;    otherwise delete it in any case.  */
end_comment

begin_function
name|void
name|record_temp_file
parameter_list|(
name|filename
parameter_list|,
name|always_delete
parameter_list|,
name|fail_delete
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|always_delete
decl_stmt|;
name|int
name|fail_delete
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|always_delete
condition|)
block|{
specifier|register
name|struct
name|temp_file
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|always_delete_queue
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|temp
operator|->
name|name
argument_list|)
condition|)
goto|goto
name|already1
goto|;
name|temp
operator|=
operator|(
expr|struct
name|temp_file
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|temp_file
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|always_delete_queue
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|always_delete_queue
operator|=
name|temp
expr_stmt|;
name|already1
label|:
empty_stmt|;
block|}
if|if
condition|(
name|fail_delete
condition|)
block|{
specifier|register
name|struct
name|temp_file
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|failure_delete_queue
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|temp
operator|->
name|name
argument_list|)
condition|)
goto|goto
name|already2
goto|;
name|temp
operator|=
operator|(
expr|struct
name|temp_file
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|temp_file
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|failure_delete_queue
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|failure_delete_queue
operator|=
name|temp
expr_stmt|;
name|already2
label|:
empty_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete all the temporary files whose names we previously recorded.  */
end_comment

begin_function
name|void
name|delete_temp_files
parameter_list|()
block|{
specifier|register
name|struct
name|temp_file
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|always_delete_queue
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"Delete %s? (y or n) "
argument_list|,
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|i
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'\n'
condition|)
while|while
condition|(
name|getchar
argument_list|()
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|'y'
operator|||
name|i
operator|==
literal|'Y'
condition|)
endif|#
directive|endif
comment|/* DEBUG */
block|{
if|if
condition|(
name|unlink
argument_list|(
name|temp
operator|->
name|name
argument_list|)
operator|<
literal|0
condition|)
if|if
condition|(
name|vflag
condition|)
name|perror_with_name
argument_list|(
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|always_delete_queue
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete all the files to be deleted on error.  */
end_comment

begin_function
name|void
name|delete_failure_queue
parameter_list|()
block|{
specifier|register
name|struct
name|temp_file
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|failure_delete_queue
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"Delete %s? (y or n) "
argument_list|,
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|i
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'\n'
condition|)
while|while
condition|(
name|getchar
argument_list|()
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|'y'
operator|||
name|i
operator|==
literal|'Y'
condition|)
endif|#
directive|endif
comment|/* DEBUG */
block|{
if|if
condition|(
name|unlink
argument_list|(
name|temp
operator|->
name|name
argument_list|)
operator|<
literal|0
condition|)
if|if
condition|(
name|vflag
condition|)
name|perror_with_name
argument_list|(
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|clear_failure_queue
parameter_list|()
block|{
name|failure_delete_queue
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute a string to use as the base of all temporary file names.    It is substituted for %g.  */
end_comment

begin_function
name|void
name|choose_temp_base
parameter_list|()
block|{
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|char
modifier|*
name|base
init|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|base
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|base
operator|=
literal|"/tmp/"
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|temp_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
sizeof|sizeof
argument_list|(
literal|"/ccXXXXXX"
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp_filename
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|temp_filename
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|temp_filename
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|temp_filename
operator|+
name|len
argument_list|,
literal|"ccXXXXXX"
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
name|temp_filename_length
operator|=
name|strlen
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Search for an execute file through our search path.    Return 0 if not found, otherwise return its name, allocated with malloc.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_exec_file
parameter_list|(
name|prog
parameter_list|)
name|char
modifier|*
name|prog
decl_stmt|;
block|{
name|int
name|win
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|size
decl_stmt|;
name|size
operator|=
name|strlen
argument_list|(
name|standard_exec_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|user_exec_prefix
operator|!=
literal|0
operator|&&
name|strlen
argument_list|(
name|user_exec_prefix
argument_list|)
operator|>
name|size
condition|)
name|size
operator|=
name|strlen
argument_list|(
name|user_exec_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_exec_prefix
operator|!=
literal|0
operator|&&
name|strlen
argument_list|(
name|env_exec_prefix
argument_list|)
operator|>
name|size
condition|)
name|size
operator|=
name|strlen
argument_list|(
name|env_exec_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|standard_exec_prefix_1
argument_list|)
operator|>
name|size
condition|)
name|size
operator|=
name|strlen
argument_list|(
name|standard_exec_prefix_1
argument_list|)
expr_stmt|;
name|size
operator|+=
name|strlen
argument_list|(
name|prog
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|machine_suffix
condition|)
name|size
operator|+=
name|strlen
argument_list|(
name|machine_suffix
argument_list|)
operator|+
literal|1
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* Determine the filename to execute.  */
if|if
condition|(
name|user_exec_prefix
condition|)
block|{
if|if
condition|(
name|machine_suffix
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|user_exec_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|user_exec_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|win
operator|&&
name|env_exec_prefix
condition|)
block|{
if|if
condition|(
name|machine_suffix
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|env_exec_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|env_exec_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
if|if
condition|(
name|machine_suffix
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|standard_exec_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|standard_exec_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
if|if
condition|(
name|machine_suffix
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|standard_exec_prefix_1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|standard_exec_prefix_1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|win
condition|)
return|return
name|temp
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* stdin file number.  */
end_comment

begin_define
define|#
directive|define
name|STDIN_FILE_NO
value|0
end_define

begin_comment
comment|/* stdout file number.  */
end_comment

begin_define
define|#
directive|define
name|STDOUT_FILE_NO
value|1
end_define

begin_comment
comment|/* value of `pipe': port index for reading.  */
end_comment

begin_define
define|#
directive|define
name|READ_PORT
value|0
end_define

begin_comment
comment|/* value of `pipe': port index for writing.  */
end_comment

begin_define
define|#
directive|define
name|WRITE_PORT
value|1
end_define

begin_comment
comment|/* Pipe waiting from last process, to be used as input for the next one.    Value is STDIN_FILE_NO if no pipe is waiting    (i.e. the next command is the first of a group).  */
end_comment

begin_decl_stmt
name|int
name|last_pipe_input
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fork one piped subcommand.  FUNC is the system call to use    (either execv or execvp).  ARGV is the arg vector to use.    NOT_LAST is nonzero if this is not the last subcommand    (i.e. its output should be piped to the next one.)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pexecute
argument_list|(
name|func
argument_list|,
name|program
argument_list|,
name|argv
argument_list|,
name|not_last
argument_list|)
name|char
modifier|*
name|program
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|not_last
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pid
decl_stmt|;
name|int
name|pdes
index|[
literal|2
index|]
decl_stmt|;
name|int
name|input_desc
init|=
name|last_pipe_input
decl_stmt|;
name|int
name|output_desc
init|=
name|STDOUT_FILE_NO
decl_stmt|;
comment|/* If this isn't the last process, make a pipe for its output,      and record it as waiting to be the input to the next process.  */
if|if
condition|(
name|not_last
condition|)
block|{
if|if
condition|(
name|pipe
argument_list|(
name|pdes
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
literal|"pipe"
argument_list|)
expr_stmt|;
name|output_desc
operator|=
name|pdes
index|[
name|WRITE_PORT
index|]
expr_stmt|;
name|last_pipe_input
operator|=
name|pdes
index|[
name|READ_PORT
index|]
expr_stmt|;
block|}
else|else
name|last_pipe_input
operator|=
name|STDIN_FILE_NO
expr_stmt|;
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|pid
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|pfatal_with_name
argument_list|(
literal|"vfork"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* child */
comment|/* Move the input and output pipes into place, if nec.  */
if|if
condition|(
name|input_desc
operator|!=
name|STDIN_FILE_NO
condition|)
block|{
name|close
argument_list|(
name|STDIN_FILE_NO
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|input_desc
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|input_desc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output_desc
operator|!=
name|STDOUT_FILE_NO
condition|)
block|{
name|close
argument_list|(
name|STDOUT_FILE_NO
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|output_desc
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|output_desc
argument_list|)
expr_stmt|;
block|}
comment|/* Close the parent's descs that aren't wanted here.  */
if|if
condition|(
name|last_pipe_input
operator|!=
name|STDIN_FILE_NO
condition|)
name|close
argument_list|(
name|last_pipe_input
argument_list|)
expr_stmt|;
comment|/* Exec the program.  */
call|(
modifier|*
name|func
call|)
argument_list|(
name|program
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|perror_exec
argument_list|(
name|program
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
comment|/* In the parent, after forking. 	 Close the descriptors that we made for this child.  */
if|if
condition|(
name|input_desc
operator|!=
name|STDIN_FILE_NO
condition|)
name|close
argument_list|(
name|input_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_desc
operator|!=
name|STDOUT_FILE_NO
condition|)
name|close
argument_list|(
name|output_desc
argument_list|)
expr_stmt|;
comment|/* Return child's process number.  */
return|return
name|pid
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Execute the command specified by the arguments on the current line of spec.    When using pipes, this includes several piped-together commands    with `|' between them.     Return 0 if successful, -1 if failed.  */
end_comment

begin_function
name|int
name|execute
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|n_commands
decl_stmt|;
comment|/* # of command.  */
name|char
modifier|*
name|string
decl_stmt|;
struct|struct
name|command
block|{
name|char
modifier|*
name|prog
decl_stmt|;
comment|/* program name.  */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* vector of args.  */
name|int
name|pid
decl_stmt|;
comment|/* pid of process for this command.  */
block|}
struct|;
name|struct
name|command
modifier|*
name|commands
decl_stmt|;
comment|/* each command buffer with above info.  */
comment|/* Count # of piped commands.  */
for|for
control|(
name|n_commands
operator|=
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argbuf_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argbuf
index|[
name|i
index|]
argument_list|,
literal|"|"
argument_list|)
operator|==
literal|0
condition|)
name|n_commands
operator|++
expr_stmt|;
comment|/* Get storage for each command.  */
name|commands
operator|=
operator|(
expr|struct
name|command
operator|*
operator|)
name|alloca
argument_list|(
name|n_commands
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|command
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Split argbuf into its separate piped processes,      and record info about each one.      Also search for the programs that are to be run.  */
name|commands
index|[
literal|0
index|]
operator|.
name|prog
operator|=
name|argbuf
index|[
literal|0
index|]
expr_stmt|;
comment|/* first command.  */
name|commands
index|[
literal|0
index|]
operator|.
name|argv
operator|=
operator|&
name|argbuf
index|[
literal|0
index|]
expr_stmt|;
name|string
operator|=
name|find_exec_file
argument_list|(
name|commands
index|[
literal|0
index|]
operator|.
name|prog
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
condition|)
name|commands
index|[
literal|0
index|]
operator|.
name|argv
index|[
literal|0
index|]
operator|=
name|string
expr_stmt|;
for|for
control|(
name|n_commands
operator|=
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argbuf_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argbuf
index|[
name|i
index|]
argument_list|,
literal|"|"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* each command.  */
name|argbuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* termination of command args.  */
name|commands
index|[
name|n_commands
index|]
operator|.
name|prog
operator|=
name|argbuf
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|commands
index|[
name|n_commands
index|]
operator|.
name|argv
operator|=
operator|&
name|argbuf
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|string
operator|=
name|find_exec_file
argument_list|(
name|commands
index|[
name|n_commands
index|]
operator|.
name|prog
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
condition|)
name|commands
index|[
name|n_commands
index|]
operator|.
name|argv
index|[
literal|0
index|]
operator|=
name|string
expr_stmt|;
name|n_commands
operator|++
expr_stmt|;
block|}
name|argbuf
index|[
name|argbuf_index
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If -v, print what we are about to do, and maybe query.  */
if|if
condition|(
name|vflag
condition|)
block|{
comment|/* Print each piped command as a separate line.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_commands
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
modifier|*
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|commands
index|[
name|i
index|]
operator|.
name|argv
init|;
operator|*
name|j
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
operator|*
name|j
argument_list|)
expr_stmt|;
comment|/* Print a pipe symbol after all but the last command.  */
if|if
condition|(
name|i
operator|+
literal|1
operator|!=
name|n_commands
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" |"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nGo ahead? (y or n) "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|j
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|j
operator|!=
literal|'\n'
condition|)
while|while
condition|(
name|getchar
argument_list|()
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|j
operator|!=
literal|'y'
operator|&&
name|j
operator|!=
literal|'Y'
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
comment|/* Run each piped subprocess.  */
name|last_pipe_input
operator|=
name|STDIN_FILE_NO
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_commands
condition|;
name|i
operator|++
control|)
block|{
specifier|extern
name|int
name|execv
argument_list|()
decl_stmt|,
name|execvp
argument_list|()
decl_stmt|;
name|char
modifier|*
name|string
init|=
name|commands
index|[
name|i
index|]
operator|.
name|argv
index|[
literal|0
index|]
decl_stmt|;
name|commands
index|[
name|i
index|]
operator|.
name|pid
operator|=
name|pexecute
argument_list|(
operator|(
name|string
operator|!=
name|commands
index|[
name|i
index|]
operator|.
name|prog
condition|?
name|execv
else|:
name|execvp
operator|)
argument_list|,
name|string
argument_list|,
name|commands
index|[
name|i
index|]
operator|.
name|argv
argument_list|,
name|i
operator|+
literal|1
operator|<
name|n_commands
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|!=
name|commands
index|[
name|i
index|]
operator|.
name|prog
condition|)
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
name|execution_count
operator|++
expr_stmt|;
comment|/* Wait for all the subprocesses to finish.      We don't care what order they finish in;      we know that N_COMMANDS waits will get them all.  */
block|{
name|int
name|ret_code
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_commands
condition|;
name|i
operator|++
control|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|char
modifier|*
name|prog
decl_stmt|;
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_commands
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|commands
index|[
name|j
index|]
operator|.
name|pid
operator|==
name|pid
condition|)
name|prog
operator|=
name|commands
index|[
name|j
index|]
operator|.
name|prog
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
literal|0x7F
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"Program %s got fatal signal %d."
argument_list|,
name|prog
argument_list|,
operator|(
name|status
operator|&
literal|0x7F
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|status
operator|&
literal|0xFF00
operator|)
operator|>>
literal|8
operator|)
operator|>=
name|MIN_FATAL_STATUS
condition|)
name|ret_code
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
name|ret_code
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all the switches given to us    and make a vector describing them.    The elements of the vector a strings, one per switch given.    If a switch uses the following argument, then the `part1' field    is the switch itself and the `part2' field is the following argument.    The `valid' field is nonzero if any spec has looked at this switch;    if it remains zero at the end of the run, it must be meaningless.  */
end_comment

begin_struct
struct|struct
name|switchstr
block|{
name|char
modifier|*
name|part1
decl_stmt|;
name|char
modifier|*
name|part2
decl_stmt|;
name|int
name|valid
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|switchstr
modifier|*
name|switches
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_switches
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Also a vector of input files specified.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|infiles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_infiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* And a vector of corresponding output files is made up later.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|outfiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create the vector `switches' and its contents.    Store its length in `n_switches'.  */
end_comment

begin_function
name|void
name|process_command
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
specifier|register
name|int
name|i
decl_stmt|;
name|n_switches
operator|=
literal|0
expr_stmt|;
name|n_infiles
operator|=
literal|0
expr_stmt|;
name|env_exec_prefix
operator|=
name|getenv
argument_list|(
literal|"GCC_EXEC_PREFIX"
argument_list|)
expr_stmt|;
comment|/* Scan argv twice.  Here, the first time, just count how many switches      there will be in their vector, and how many input files in theirs.      Here we also parse the switches that cc itself uses (e.g. -v).  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
literal|'l'
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|c
init|=
operator|*
name|p
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|machine_suffix
operator|=
name|p
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|user_exec_prefix
operator|=
name|p
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Print our subcommands and print versions.  */
name|vflag
operator|++
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
break|break;
default|default:
name|n_switches
operator|++
expr_stmt|;
if|if
condition|(
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|i
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
block|}
block|}
else|else
name|n_infiles
operator|++
expr_stmt|;
block|}
comment|/* Then create the space for the vectors and scan again.  */
name|switches
operator|=
operator|(
operator|(
expr|struct
name|switchstr
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n_switches
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|switchstr
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|infiles
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n_infiles
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|n_switches
operator|=
literal|0
expr_stmt|;
name|n_infiles
operator|=
literal|0
expr_stmt|;
comment|/* This, time, copy the text of each switch and store a pointer      to the copy in the vector of switches.      Store all the infiles in their vector.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
literal|'l'
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|c
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'B'
operator|||
name|c
operator|==
literal|'b'
condition|)
continue|continue;
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|SWITCH_TAKES_ARG
argument_list|(
name|c
argument_list|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|||
name|WORD_SWITCH_TAKES_ARG
argument_list|(
name|p
argument_list|)
condition|)
name|switches
index|[
name|n_switches
index|]
operator|.
name|part2
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'o'
condition|)
block|{
comment|/* On some systems, ld cannot handle -o without space. 	       So split the -o and its argument.  */
name|switches
index|[
name|n_switches
index|]
operator|.
name|part2
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|switches
index|[
name|n_switches
index|]
operator|.
name|part2
argument_list|,
operator|&
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|switches
index|[
name|n_switches
index|]
operator|.
name|part2
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|n_switches
index|]
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
name|n_switches
operator|++
expr_stmt|;
block|}
else|else
name|infiles
index|[
name|n_infiles
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
name|switches
index|[
name|n_switches
index|]
operator|.
name|part1
operator|=
literal|0
expr_stmt|;
name|infiles
index|[
name|n_infiles
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process a spec string, accumulating and running commands.  */
end_comment

begin_comment
comment|/* These variables describe the input file name.    input_file_number is the index on outfiles of this file,    so that the output file name can be stored for later use by %o.    input_basename is the start of the part of the input file    sans all directory names, and basename_length is the number    of characters starting there excluding the suffix .c or whatever.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|input_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|input_file_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|input_filename_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|basename_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|input_basename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are variables used within do_spec and do_spec_1.  */
end_comment

begin_comment
comment|/* Nonzero if an arg has been started and not yet terminated    (with space, tab or newline).  */
end_comment

begin_decl_stmt
name|int
name|arg_going
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means %d or %g has been seen; the next arg to be terminated    is a temporary file name.  */
end_comment

begin_decl_stmt
name|int
name|delete_this_arg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means %w has been seen; the next arg to be terminated    is the output file name of this compilation.  */
end_comment

begin_decl_stmt
name|int
name|this_is_output_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means %s has been seen; the next arg to be terminated    is the name of a library file and we should try the standard    search dirs for it.  */
end_comment

begin_decl_stmt
name|int
name|this_is_library_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Process the spec SPEC and run the commands specified therein.    Returns 0 if the spec is successfully processed; -1 if failed.  */
end_comment

begin_function
name|int
name|do_spec
parameter_list|(
name|spec
parameter_list|)
name|char
modifier|*
name|spec
decl_stmt|;
block|{
name|int
name|value
decl_stmt|;
name|clear_args
argument_list|()
expr_stmt|;
name|arg_going
operator|=
literal|0
expr_stmt|;
name|delete_this_arg
operator|=
literal|0
expr_stmt|;
name|this_is_output_file
operator|=
literal|0
expr_stmt|;
name|this_is_library_file
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|do_spec_1
argument_list|(
name|spec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Force out any unfinished command.      If -pipe, this forces out the last command if it ended in `|'.  */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argbuf_index
operator|>
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|argbuf
index|[
name|argbuf_index
operator|-
literal|1
index|]
argument_list|,
literal|"|"
argument_list|)
condition|)
name|argbuf_index
operator|--
expr_stmt|;
if|if
condition|(
name|argbuf_index
operator|>
literal|0
condition|)
name|value
operator|=
name|execute
argument_list|()
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Process the sub-spec SPEC as a portion of a larger spec.    This is like processing a whole spec except that we do    not initialize at the beginning and we do not supply a    newline by default at the end.    INSWITCH nonzero means don't process %-sequences in SPEC;    in this case, % is treated as an ordinary character.    This is used while substituting switches.    INSWITCH nonzero also causes SPC not to terminate an argument.     Value is zero unless a line was finished    and the command on that line reported an error.  */
end_comment

begin_function
name|int
name|do_spec_1
parameter_list|(
name|spec
parameter_list|,
name|inswitch
parameter_list|)
name|char
modifier|*
name|spec
decl_stmt|;
name|int
name|inswitch
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|spec
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
comment|/* If substituting a switch, treat all chars like letters.        Otherwise, NL, SPC, TAB and % are special.  */
switch|switch
condition|(
name|inswitch
condition|?
literal|'a'
else|:
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* End of line: finish any pending argument, 	   then run the pending command if one has been started.  */
if|if
condition|(
name|arg_going
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string
operator|=
name|obstack_finish
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_library_file
condition|)
name|string
operator|=
name|find_file
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|store_arg
argument_list|(
name|string
argument_list|,
name|delete_this_arg
argument_list|,
name|this_is_output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_output_file
condition|)
name|outfiles
index|[
name|input_file_number
index|]
operator|=
name|string
expr_stmt|;
block|}
name|arg_going
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argbuf_index
operator|>
literal|0
operator|&&
operator|!
name|strcmp
argument_list|(
name|argbuf
index|[
name|argbuf_index
operator|-
literal|1
index|]
argument_list|,
literal|"|"
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
literal|"pipe"
argument_list|)
condition|)
break|break;
comment|/* A `|' before the newline means use a pipe here, 	       but only if -pipe was specified. 	       Otherwise, execute now and don't pass the `|' as an arg.  */
if|if
condition|(
name|i
operator|<
name|n_switches
condition|)
block|{
name|switches
index|[
name|i
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
name|argbuf_index
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|argbuf_index
operator|>
literal|0
condition|)
block|{
name|int
name|value
init|=
name|execute
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
condition|)
return|return
name|value
return|;
block|}
comment|/* Reinitialize for a new command, and for a new argument.  */
name|clear_args
argument_list|()
expr_stmt|;
name|arg_going
operator|=
literal|0
expr_stmt|;
name|delete_this_arg
operator|=
literal|0
expr_stmt|;
name|this_is_output_file
operator|=
literal|0
expr_stmt|;
name|this_is_library_file
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
comment|/* End any pending argument.  */
if|if
condition|(
name|arg_going
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string
operator|=
name|obstack_finish
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_library_file
condition|)
name|string
operator|=
name|find_file
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|store_arg
argument_list|(
name|string
argument_list|,
name|delete_this_arg
argument_list|,
name|this_is_output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_output_file
condition|)
name|outfiles
index|[
name|input_file_number
index|]
operator|=
name|string
expr_stmt|;
block|}
comment|/* Use pipe */
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
case|case
literal|' '
case|:
comment|/* Space or tab ends an argument if one is pending.  */
if|if
condition|(
name|arg_going
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string
operator|=
name|obstack_finish
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_library_file
condition|)
name|string
operator|=
name|find_file
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|store_arg
argument_list|(
name|string
argument_list|,
name|delete_this_arg
argument_list|,
name|this_is_output_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_output_file
condition|)
name|outfiles
index|[
name|input_file_number
index|]
operator|=
name|string
expr_stmt|;
block|}
comment|/* Reinitialize for a new argument.  */
name|arg_going
operator|=
literal|0
expr_stmt|;
name|delete_this_arg
operator|=
literal|0
expr_stmt|;
name|this_is_output_file
operator|=
literal|0
expr_stmt|;
name|this_is_library_file
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|0
case|:
name|fatal
argument_list|(
literal|"Invalid specification!  Bug in cc."
argument_list|)
expr_stmt|;
case|case
literal|'b'
case|:
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|input_basename
argument_list|,
name|basename_length
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|delete_this_arg
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* {...:%efoo} means report an error with `foo' as error message 	       and don't execute any more commands for this file.  */
block|{
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|q
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|q
argument_list|,
name|p
operator|-
name|q
argument_list|)
expr_stmt|;
name|buf
index|[
name|p
operator|-
name|q
index|]
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
literal|'g'
case|:
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|temp_filename
argument_list|,
name|temp_filename_length
argument_list|)
expr_stmt|;
name|delete_this_arg
operator|=
literal|1
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|obstack_grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|input_filename
argument_list|,
name|input_filename_length
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
block|{
specifier|register
name|int
name|f
decl_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|n_infiles
condition|;
name|f
operator|++
control|)
name|store_arg
argument_list|(
name|outfiles
index|[
name|f
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
name|this_is_library_file
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
block|{
name|int
name|index
init|=
name|argbuf_index
decl_stmt|;
comment|/* Handle the {...} following the %W.  */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'{'
condition|)
name|abort
argument_list|()
expr_stmt|;
name|p
operator|=
name|handle_braces
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If any args were output, mark the last one for deletion 		 on failure.  */
if|if
condition|(
name|argbuf_index
operator|!=
name|index
condition|)
name|record_temp_file
argument_list|(
name|argbuf
index|[
name|argbuf_index
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'w'
case|:
name|this_is_output_file
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|p
operator|=
name|handle_braces
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|'%'
case|:
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
break|break;
comment|/*** The rest just process a certain constant string as a spec.  */
case|case
literal|'1'
case|:
name|do_spec_1
argument_list|(
name|CC1_SPEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|do_spec_1
argument_list|(
name|ASM_SPEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|do_spec_1
argument_list|(
name|SIGNED_CHAR_SPEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|do_spec_1
argument_list|(
name|CPP_SPEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|do_spec_1
argument_list|(
name|LINK_SPEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|do_spec_1
argument_list|(
name|LIB_SPEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|do_spec_1
argument_list|(
name|CPP_PREDEFINES
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
block|{
name|char
modifier|*
name|x
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|CPP_PREDEFINES
argument_list|)
operator|*
literal|2
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|x
decl_stmt|;
name|char
modifier|*
name|y
init|=
name|CPP_PREDEFINES
decl_stmt|;
comment|/* Copy all of CPP_PREDEFINES into BUF, 		 but put __ after every -D and at the end of each arg,  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|y
argument_list|,
literal|"-D"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
operator|*
name|x
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'D'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
name|y
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|y
operator|==
literal|' '
operator|||
operator|*
name|y
operator|==
literal|0
condition|)
block|{
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|x
operator|++
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
operator|*
name|y
operator|==
literal|0
condition|)
break|break;
else|else
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|x
operator|++
operator|=
operator|*
name|y
operator|++
expr_stmt|;
block|}
operator|*
name|x
operator|=
literal|0
expr_stmt|;
name|do_spec_1
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
name|do_spec_1
argument_list|(
name|STARTFILE_SPEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|do_spec_1
argument_list|(
name|ENDFILE_SPEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Ordinary character: put it into the current argument.  */
name|obstack_1grow
argument_list|(
operator|&
name|obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|arg_going
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* End of string */
block|}
end_function

begin_comment
comment|/* Return 0 if we call do_spec_1 and that returns -1.  */
end_comment

begin_function
name|char
modifier|*
name|handle_braces
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|filter
decl_stmt|;
name|int
name|pipe
init|=
literal|0
decl_stmt|;
name|int
name|negate
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'|'
condition|)
comment|/* A `|' after the open-brace means,        if the test fails, output a single minus sign rather than nothing.        This is used in %{|!pipe:...}.  */
name|pipe
operator|=
literal|1
operator|,
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
comment|/* A `!' after the open-brace negates the condition:        succeed if the specified switch is not present.  */
name|negate
operator|=
literal|1
operator|,
operator|++
name|p
expr_stmt|;
name|filter
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|'}'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'}'
condition|)
block|{
specifier|register
name|int
name|count
init|=
literal|1
decl_stmt|;
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'{'
condition|)
name|count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|'}'
condition|)
name|count
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
block|}
else|else
name|q
operator|=
name|p
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'}'
condition|)
block|{
comment|/* Substitute all matching switches as separate args.  */
specifier|register
name|int
name|i
decl_stmt|;
operator|--
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|filter
argument_list|,
name|p
operator|-
name|filter
argument_list|)
condition|)
name|give_switch
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Test for presence of the specified switch.  */
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|present
init|=
literal|0
decl_stmt|;
comment|/* If name specified ends in *, as in {x*:...}, 	 check for presence of any switch name starting with x.  */
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|filter
argument_list|,
name|p
operator|-
name|filter
operator|-
literal|1
argument_list|)
condition|)
block|{
name|switches
index|[
name|i
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
name|present
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Otherwise, check for presence of exact name specified.  */
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|filter
argument_list|,
name|p
operator|-
name|filter
argument_list|)
operator|&&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
name|p
operator|-
name|filter
index|]
operator|==
literal|0
condition|)
block|{
name|switches
index|[
name|i
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
name|present
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If it is as desired (present for %{s...}, absent for %{-s...}) 	 then substitute either the switch or the specified 	 conditional text.  */
if|if
condition|(
name|present
operator|!=
name|negate
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'}'
condition|)
block|{
name|give_switch
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|do_spec_1
argument_list|(
name|save_string
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|q
operator|-
name|p
operator|-
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|pipe
condition|)
block|{
comment|/* Here if a %{|...} conditional fails: output a minus sign, 	     which means "standard output" or "standard input".  */
name|do_spec_1
argument_list|(
literal|"-"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|q
return|;
block|}
end_function

begin_comment
comment|/* Pass a switch to the current accumulating command    in the same form that we received it.    SWITCHNUM identifies the switch; it is an index into    the vector of switches gcc received, which is `switches'.    This cannot fail since it never finishes a command line.  */
end_comment

begin_macro
name|give_switch
argument_list|(
argument|switchnum
argument_list|)
end_macro

begin_decl_stmt
name|int
name|switchnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|do_spec_1
argument_list|(
literal|"-"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
name|switches
index|[
name|switchnum
index|]
operator|.
name|part1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|switches
index|[
name|switchnum
index|]
operator|.
name|part2
operator|!=
literal|0
condition|)
block|{
name|do_spec_1
argument_list|(
name|switches
index|[
name|switchnum
index|]
operator|.
name|part2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_spec_1
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|switches
index|[
name|switchnum
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Search for a file named NAME trying various prefixes including the    user's -B prefix and some standard ones.    Return the absolute pathname found.  If nothing is found, return NAME.  */
end_comment

begin_function
name|char
modifier|*
name|find_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|win
init|=
literal|0
decl_stmt|;
comment|/* Compute maximum size of NAME plus any prefix we will try.  */
name|size
operator|=
name|strlen
argument_list|(
name|standard_exec_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|user_exec_prefix
operator|!=
literal|0
operator|&&
name|strlen
argument_list|(
name|user_exec_prefix
argument_list|)
operator|>
name|size
condition|)
name|size
operator|=
name|strlen
argument_list|(
name|user_exec_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_exec_prefix
operator|!=
literal|0
operator|&&
name|strlen
argument_list|(
name|env_exec_prefix
argument_list|)
operator|>
name|size
condition|)
name|size
operator|=
name|strlen
argument_list|(
name|env_exec_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|standard_exec_prefix
argument_list|)
operator|>
name|size
condition|)
name|size
operator|=
name|strlen
argument_list|(
name|standard_exec_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|standard_exec_prefix_1
argument_list|)
operator|>
name|size
condition|)
name|size
operator|=
name|strlen
argument_list|(
name|standard_exec_prefix_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|standard_startfile_prefix
argument_list|)
operator|>
name|size
condition|)
name|size
operator|=
name|strlen
argument_list|(
name|standard_startfile_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|standard_startfile_prefix_1
argument_list|)
operator|>
name|size
condition|)
name|size
operator|=
name|strlen
argument_list|(
name|standard_startfile_prefix_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|standard_startfile_prefix_2
argument_list|)
operator|>
name|size
condition|)
name|size
operator|=
name|strlen
argument_list|(
name|standard_startfile_prefix_2
argument_list|)
expr_stmt|;
if|if
condition|(
name|machine_suffix
condition|)
name|size
operator|+=
name|strlen
argument_list|(
name|machine_suffix
argument_list|)
operator|+
literal|1
expr_stmt|;
name|size
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|user_exec_prefix
condition|)
block|{
if|if
condition|(
name|machine_suffix
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|user_exec_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|user_exec_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|win
operator|&&
name|env_exec_prefix
condition|)
block|{
if|if
condition|(
name|machine_suffix
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|env_exec_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|env_exec_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
if|if
condition|(
name|machine_suffix
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|standard_exec_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|standard_exec_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
if|if
condition|(
name|machine_suffix
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|standard_exec_prefix_1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|standard_exec_prefix_1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
if|if
condition|(
name|machine_suffix
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|standard_startfile_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|standard_startfile_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
if|if
condition|(
name|machine_suffix
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|standard_startfile_prefix_1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|standard_startfile_prefix_1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
if|if
condition|(
name|machine_suffix
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|standard_startfile_prefix_2
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|standard_startfile_prefix_2
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
if|if
condition|(
name|machine_suffix
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
literal|"./"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|machine_suffix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|win
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
literal|"./"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|win
condition|)
return|return
name|save_string
argument_list|(
name|temp
argument_list|,
name|strlen
argument_list|(
name|temp
argument_list|)
argument_list|)
return|;
return|return
name|name
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* On fatal signals, delete all the temporary files.  */
end_comment

begin_function
name|void
name|fatal_error
parameter_list|(
name|signum
parameter_list|)
name|int
name|signum
decl_stmt|;
block|{
name|signal
argument_list|(
name|signum
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|delete_failure_queue
argument_list|()
expr_stmt|;
name|delete_temp_files
argument_list|()
expr_stmt|;
comment|/* Get the same signal again, this time not handled,      so its normal effect occurs.  */
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|signum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|value
decl_stmt|;
name|int
name|error_count
init|=
literal|0
decl_stmt|;
name|int
name|linker_was_run
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|explicit_link_files
decl_stmt|;
name|programname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|fatal_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|fatal_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|fatal_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|fatal_error
argument_list|)
expr_stmt|;
name|argbuf_length
operator|=
literal|10
expr_stmt|;
name|argbuf
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argbuf_length
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|obstack
argument_list|)
expr_stmt|;
name|choose_temp_base
argument_list|()
expr_stmt|;
comment|/* Make a table of what switches there are (switches, n_switches).      Make a table of specified input files (infiles, n_infiles).  */
name|process_command
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
block|{
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gcc version %s\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_infiles
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_infiles
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"No input files specified."
argument_list|)
expr_stmt|;
comment|/* Make a place to record the compiler output file names      that correspond to the input files.  */
name|outfiles
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_infiles
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|outfiles
argument_list|,
name|n_infiles
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record which files were specified explicitly as link input.  */
name|explicit_link_files
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_infiles
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|explicit_link_files
argument_list|,
name|n_infiles
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_infiles
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|compiler
modifier|*
name|cp
decl_stmt|;
name|int
name|this_file_error
init|=
literal|0
decl_stmt|;
comment|/* Tell do_spec what to substitute for %i.  */
name|input_filename
operator|=
name|infiles
index|[
name|i
index|]
expr_stmt|;
name|input_filename_length
operator|=
name|strlen
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|input_file_number
operator|=
name|i
expr_stmt|;
comment|/* Use the same thing in %o, unless cp->spec says otherwise.  */
name|outfiles
index|[
name|i
index|]
operator|=
name|input_filename
expr_stmt|;
comment|/* Figure out which compiler from the file's suffix.  */
for|for
control|(
name|cp
operator|=
name|compilers
init|;
name|cp
operator|->
name|spec
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|cp
operator|->
name|suffix
argument_list|)
operator|<
name|input_filename_length
operator|&&
operator|!
name|strcmp
argument_list|(
name|cp
operator|->
name|suffix
argument_list|,
name|infiles
index|[
name|i
index|]
operator|+
name|input_filename_length
operator|-
name|strlen
argument_list|(
name|cp
operator|->
name|suffix
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Ok, we found an applicable compiler.  Run its spec.  */
comment|/* First say how much of input_filename to substitute for %b  */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|input_basename
operator|=
name|input_filename
expr_stmt|;
for|for
control|(
name|p
operator|=
name|input_filename
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|input_basename
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|basename_length
operator|=
operator|(
name|input_filename_length
operator|-
name|strlen
argument_list|(
name|cp
operator|->
name|suffix
argument_list|)
operator|-
operator|(
name|input_basename
operator|-
name|input_filename
operator|)
operator|)
expr_stmt|;
name|value
operator|=
name|do_spec
argument_list|(
name|cp
operator|->
name|spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|this_file_error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* If this file's name does not contain a recognized suffix, 	 record it as explicit linker input.  */
if|if
condition|(
operator|!
name|cp
operator|->
name|spec
condition|)
name|explicit_link_files
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Clear the delete-on-failure queue, deleting the files in it 	 if this compilation failed.  */
if|if
condition|(
name|this_file_error
condition|)
block|{
name|delete_failure_queue
argument_list|()
expr_stmt|;
name|error_count
operator|++
expr_stmt|;
block|}
comment|/* If this compilation succeeded, don't delete those files later.  */
name|clear_failure_queue
argument_list|()
expr_stmt|;
block|}
comment|/* Run ld to link all the compiler output files.  */
if|if
condition|(
name|error_count
operator|==
literal|0
condition|)
block|{
name|int
name|tmp
init|=
name|execution_count
decl_stmt|;
name|value
operator|=
name|do_spec
argument_list|(
name|link_spec
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|error_count
operator|=
literal|1
expr_stmt|;
name|linker_was_run
operator|=
operator|(
name|tmp
operator|!=
name|execution_count
operator|)
expr_stmt|;
block|}
comment|/* If options said don't run linker,      complain about input files to be given to the linker.  */
if|if
condition|(
operator|!
name|linker_was_run
operator|&&
name|error_count
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_infiles
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|explicit_link_files
index|[
name|i
index|]
condition|)
name|error
argument_list|(
literal|"%s: linker input file unused since linking not done"
argument_list|,
name|outfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Set the `valid' bits for switches that match anything in any spec.  */
name|validate_all_switches
argument_list|()
expr_stmt|;
comment|/* Warn about any switches that no pass was interested in.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|switches
index|[
name|i
index|]
operator|.
name|valid
condition|)
name|error
argument_list|(
literal|"unrecognized option `-%s'"
argument_list|,
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|)
expr_stmt|;
comment|/* Delete some or all of the temporary files we made.  */
if|if
condition|(
name|error_count
condition|)
name|delete_failure_queue
argument_list|()
expr_stmt|;
name|delete_temp_files
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|error_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|xmalloc
argument_list|(
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|value
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"Virtual memory full."
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_block

begin_macro
name|xrealloc
argument_list|(
argument|ptr
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ptr
decl_stmt|,
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|value
init|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"Virtual memory full."
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_block

begin_comment
comment|/* Return a newly-allocated string whose contents concatenate those of s1, s2, s3.  */
end_comment

begin_function
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len1
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|,
name|len2
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|,
name|len3
init|=
name|strlen
argument_list|(
name|s3
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len1
operator|+
name|len2
operator|+
name|len3
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
operator|+
name|len2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
operator|*
operator|(
name|result
operator|+
name|len1
operator|+
name|len2
operator|+
name|len3
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|save_string
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|s
argument_list|,
name|result
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_macro
name|pfatal_with_name
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|,
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|s
operator|=
name|concat
argument_list|(
literal|"%s: "
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
literal|"cannot open %s"
expr_stmt|;
name|fatal
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|perror_with_name
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|,
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|s
operator|=
name|concat
argument_list|(
literal|"%s: "
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
literal|"cannot open %s"
expr_stmt|;
name|error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|perror_exec
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|,
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|s
operator|=
name|concat
argument_list|(
literal|"installation problem, cannot exec %s: "
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
literal|"installation problem, cannot exec %s"
expr_stmt|;
name|error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VPRINTF
end_ifdef

begin_comment
comment|/* Output an error message and exit */
end_comment

begin_function
name|int
name|fatal
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|delete_temp_files
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|error
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|programname
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not HAVE_VPRINTF */
end_comment

begin_macro
name|fatal
argument_list|(
argument|msg
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|,
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|error
argument_list|(
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|delete_temp_files
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|msg
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|,
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|programname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_VPRINTF */
end_comment

begin_escape
end_escape

begin_function
name|void
name|validate_all_switches
parameter_list|()
block|{
name|struct
name|compiler
modifier|*
name|comp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
for|for
control|(
name|comp
operator|=
name|compilers
init|;
name|comp
operator|->
name|spec
condition|;
name|comp
operator|++
control|)
block|{
name|p
operator|=
name|comp
operator|->
name|spec
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|link_spec
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Now notice switches mentioned in the machine-specific specs.  */
ifdef|#
directive|ifdef
name|ASM_SPEC
name|p
operator|=
name|ASM_SPEC
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CPP_SPEC
name|p
operator|=
name|CPP_SPEC
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGNED_CHAR_SPEC
name|p
operator|=
name|SIGNED_CHAR_SPEC
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CC1_SPEC
name|p
operator|=
name|CC1_SPEC
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LINK_SPEC
name|p
operator|=
name|LINK_SPEC
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LIB_SPEC
name|p
operator|=
name|LIB_SPEC
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STARTFILE_SPEC
name|p
operator|=
name|STARTFILE_SPEC
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
if|if
condition|(
name|c
operator|==
literal|'%'
operator|&&
operator|*
name|p
operator|==
literal|'{'
condition|)
comment|/* We have a switch spec.  */
name|validate_switches
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Look at the switch-name that comes after START    and mark as valid all supplied switches that match it.  */
end_comment

begin_function
name|void
name|validate_switches
parameter_list|(
name|start
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|start
decl_stmt|;
name|char
modifier|*
name|filter
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'|'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
operator|++
name|p
expr_stmt|;
name|filter
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|'}'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
comment|/* Mark all matching switches as valid.  */
operator|--
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|filter
argument_list|,
name|p
operator|-
name|filter
argument_list|)
condition|)
name|switches
index|[
name|i
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Mark an exact matching switch as valid.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_switches
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|switches
index|[
name|i
index|]
operator|.
name|part1
argument_list|,
name|filter
argument_list|,
name|p
operator|-
name|filter
argument_list|)
operator|&&
name|switches
index|[
name|i
index|]
operator|.
name|part1
index|[
name|p
operator|-
name|filter
index|]
operator|==
literal|0
condition|)
name|switches
index|[
name|i
index|]
operator|.
name|valid
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

