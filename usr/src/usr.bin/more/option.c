begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Mark Nudleman  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Mark Nudleman.  *   * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)option.c	5.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Process command line options.  * Each option is a single letter which controls a program variable.  * The options have defaults which may be changed via  * the command line option, or toggled via the "-" command.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_define
define|#
directive|define
name|toupper
parameter_list|(
name|c
parameter_list|)
value|((c)-'a'+'A')
end_define

begin_define
define|#
directive|define
name|END_OPTION_STRING
value|('$')
end_define

begin_comment
comment|/*  * Types of options.  */
end_comment

begin_define
define|#
directive|define
name|BOOL
value|01
end_define

begin_comment
comment|/* Boolean option: 0 or 1 */
end_comment

begin_define
define|#
directive|define
name|TRIPLE
value|02
end_define

begin_comment
comment|/* Triple-valued option: 0, 1 or 2 */
end_comment

begin_define
define|#
directive|define
name|NUMBER
value|04
end_define

begin_comment
comment|/* Numeric option */
end_comment

begin_define
define|#
directive|define
name|REPAINT
value|040
end_define

begin_comment
comment|/* Repaint screen after toggling option */
end_comment

begin_define
define|#
directive|define
name|NO_TOGGLE
value|0100
end_define

begin_comment
comment|/* Option cannot be toggled with "-" cmd */
end_comment

begin_comment
comment|/*  * Variables controlled by command line options.  */
end_comment

begin_decl_stmt
name|public
name|int
name|clean_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Can we assume the data is "clean"?  				   (That is, free of nulls, etc) */
end_comment

begin_decl_stmt
name|public
name|int
name|quiet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should we suppress the audible bell? */
end_comment

begin_decl_stmt
name|public
name|int
name|how_search
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where should forward searches start? */
end_comment

begin_decl_stmt
name|public
name|int
name|top_scroll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Repaint screen from top? 				   (alternative is scroll from bottom) */
end_comment

begin_decl_stmt
name|public
name|int
name|pr_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type of prompt (short, medium, long) */
end_comment

begin_decl_stmt
name|public
name|int
name|bs_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to process backspaces */
end_comment

begin_decl_stmt
name|public
name|int
name|know_dumb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't complain about dumb terminals */
end_comment

begin_decl_stmt
name|public
name|int
name|quit_at_eof
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Quit after hitting end of file twice */
end_comment

begin_decl_stmt
name|public
name|int
name|squeeze
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Squeeze multiple blank lines into one */
end_comment

begin_decl_stmt
name|public
name|int
name|tabstop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tab settings */
end_comment

begin_decl_stmt
name|public
name|int
name|back_scroll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Repaint screen on backwards movement */
end_comment

begin_decl_stmt
name|public
name|int
name|twiddle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Display "~" for lines after EOF */
end_comment

begin_decl_stmt
name|public
name|int
name|caseless
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do "caseless" searches */
end_comment

begin_decl_stmt
name|public
name|int
name|linenums
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use line numbers */
end_comment

begin_decl_stmt
name|public
name|int
name|cbufs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current number of buffers */
end_comment

begin_decl_stmt
name|public
name|int
name|autobuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|int
name|plusoption
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|prproto
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|eqproto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nbufs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ispipe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|first_cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|every_first_cmd
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|LOGFILE
end_if

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|namelogfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|force_logfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|logfile
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TAGS
end_if

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tagfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tagpattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|int
name|tagoption
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|char
modifier|*
name|opt_P
parameter_list|()
function_decl|;
end_function_decl

begin_struct
specifier|static
struct|struct
name|option
block|{
name|char
name|oletter
decl_stmt|;
comment|/* The controlling letter (a-z) */
name|char
name|otype
decl_stmt|;
comment|/* Type of the option */
name|int
name|odefault
decl_stmt|;
comment|/* Default value */
name|int
modifier|*
name|ovar
decl_stmt|;
comment|/* Pointer to the associated variable */
name|char
modifier|*
name|odesc
index|[
literal|3
index|]
decl_stmt|;
comment|/* Description of each value */
block|}
name|option
index|[]
init|=
block|{
block|{
literal|'a'
block|,
name|TRIPLE
block|,
literal|0
block|,
operator|&
name|how_search
block|,
block|{
literal|"Forward search starts at second REAL line displayed"
block|,
literal|"Forward search starts at bottom of screen"
block|,
literal|"Forward search starts at second SCREEN line displayed"
block|}
block|}
block|,
block|{
literal|'b'
block|,
name|NUMBER
block|,
literal|10
block|,
operator|&
name|cbufs
block|,
block|{
literal|"%d buffers"
block|,
name|NULL
block|,
name|NULL
block|}
block|}
block|,
block|{
literal|'B'
block|,
name|BOOL
block|,
literal|1
block|,
operator|&
name|autobuf
block|,
block|{
literal|"Don't automatically allocate buffers"
block|,
literal|"Automatically allocate buffers when needed"
block|,
name|NULL
block|}
block|}
block|,
block|{
literal|'c'
block|,
name|TRIPLE
block|,
literal|0
block|,
operator|&
name|top_scroll
block|,
block|{
literal|"Repaint by scrolling from bottom of screen"
block|,
literal|"Repaint by clearing each line"
block|,
literal|"Repaint by painting from top of screen"
block|}
block|}
block|,
block|{
literal|'d'
block|,
name|BOOL
operator||
name|NO_TOGGLE
block|,
literal|0
block|,
operator|&
name|know_dumb
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
block|,
block|{
literal|'e'
block|,
name|TRIPLE
block|,
literal|0
block|,
operator|&
name|quit_at_eof
block|,
block|{
literal|"Don't quit at end-of-file"
block|,
literal|"Quit at end-of-file"
block|,
literal|"Quit immediately at end-of-file"
block|}
block|}
block|,
block|{
literal|'h'
block|,
name|NUMBER
block|,
operator|-
literal|1
block|,
operator|&
name|back_scroll
block|,
block|{
literal|"Backwards scroll limit is %d lines"
block|,
name|NULL
block|,
name|NULL
block|}
block|}
block|,
block|{
literal|'i'
block|,
name|BOOL
block|,
literal|0
block|,
operator|&
name|caseless
block|,
block|{
literal|"Case is significant in searches"
block|,
literal|"Ignore case in searches"
block|,
name|NULL
block|}
block|}
block|,
block|{
literal|'m'
block|,
name|TRIPLE
block|,
literal|0
block|,
operator|&
name|pr_type
block|,
block|{
literal|"Short prompt"
block|,
literal|"Medium prompt"
block|,
literal|"Long prompt"
block|}
block|}
block|,
block|{
literal|'n'
block|,
name|BOOL
block|,
literal|1
block|,
operator|&
name|linenums
block|,
block|{
literal|"Don't use line numbers"
block|,
literal|"Use line numbers"
block|,
name|NULL
block|}
block|}
block|,
block|{
literal|'q'
block|,
name|TRIPLE
block|,
literal|0
block|,
operator|&
name|quiet
block|,
block|{
literal|"Ring the bell for errors AND at eof/bof"
block|,
literal|"Ring the bell for errors but not at eof/bof"
block|,
literal|"Never ring the bell"
block|}
block|}
block|,
block|{
literal|'s'
block|,
name|BOOL
operator||
name|REPAINT
block|,
literal|0
block|,
operator|&
name|squeeze
block|,
block|{
literal|"Don't squeeze multiple blank lines"
block|,
literal|"Squeeze multiple blank lines"
block|,
name|NULL
block|}
block|}
block|,
block|{
literal|'u'
block|,
name|TRIPLE
operator||
name|REPAINT
block|,
literal|0
block|,
operator|&
name|bs_mode
block|,
block|{
literal|"Underlined text displayed in underline mode"
block|,
literal|"Backspaces cause overstrike"
block|,
literal|"Backspaces print as ^H"
block|}
block|}
block|,
block|{
literal|'w'
block|,
name|BOOL
operator||
name|REPAINT
block|,
literal|1
block|,
operator|&
name|twiddle
block|,
block|{
literal|"Display nothing for lines after end-of-file"
block|,
literal|"Display ~ for lines after end-of-file"
block|,
name|NULL
block|}
block|}
block|,
block|{
literal|'x'
block|,
name|NUMBER
operator||
name|REPAINT
block|,
literal|8
block|,
operator|&
name|tabstop
block|,
block|{
literal|"Tab stops every %d spaces"
block|,
name|NULL
block|,
name|NULL
block|}
block|}
block|,
block|{
literal|'z'
block|,
name|NUMBER
operator||
name|REPAINT
block|,
operator|-
literal|1
block|,
operator|&
name|sc_window
block|,
block|{
literal|"Scroll window size is %d lines"
block|,
name|NULL
block|,
name|NULL
block|}
block|}
block|,
block|{
literal|'\0'
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Initialize each option to its default value.  */
end_comment

begin_function
name|public
name|void
name|init_option
parameter_list|()
block|{
specifier|register
name|struct
name|option
modifier|*
name|o
decl_stmt|;
name|first_cmd
operator|=
name|every_first_cmd
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|o
operator|=
name|option
init|;
name|o
operator|->
name|oletter
operator|!=
literal|'\0'
condition|;
name|o
operator|++
control|)
block|{
comment|/* 		 * Set each variable to its default. 		 */
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
name|o
operator|->
name|odefault
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Toggle command line flags from within the program.  * Used by the "-" and "_" commands.  * If do_toggle is zero, just report the current setting, without changing it.  */
end_comment

begin_function
name|public
name|void
name|toggle_option
parameter_list|(
name|s
parameter_list|,
name|do_toggle
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|do_toggle
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|option
modifier|*
name|o
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|dorepaint
decl_stmt|;
name|char
name|message
index|[
literal|100
index|]
decl_stmt|;
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'P'
case|:
comment|/* 		 * Special case for -P. 		 */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
name|prproto
index|[
name|pr_type
index|]
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|opt_P
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
if|#
directive|if
name|TAGS
case|case
literal|'t'
case|:
comment|/* 		 * Special case for -t. 		 */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"no tag"
argument_list|)
expr_stmt|;
return|return;
block|}
name|findtag
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|tagfile
operator|!=
name|NULL
condition|)
block|{
name|edit
argument_list|(
name|tagfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tagsearch
argument_list|()
expr_stmt|;
block|}
return|return;
endif|#
directive|endif
if|#
directive|if
name|LOGFILE
case|case
literal|'L'
case|:
comment|/* 		 * Special case for -l and -L. 		 */
name|force_logfile
operator|=
literal|1
expr_stmt|;
goto|goto
name|case_l
goto|;
case|case
literal|'l'
case|:
name|force_logfile
operator|=
literal|0
expr_stmt|;
name|case_l
label|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|logfile
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"no log file"
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"log file \"%s\""
argument_list|,
name|namelogfile
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|ispipe
condition|)
block|{
name|error
argument_list|(
literal|"input is not a pipe"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|logfile
operator|>=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"log file is already in use"
argument_list|)
expr_stmt|;
return|return;
block|}
name|namelogfile
operator|=
name|save
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|use_logfile
argument_list|()
expr_stmt|;
name|sync_logfile
argument_list|()
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
name|msg
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|o
operator|=
name|option
init|;
name|o
operator|->
name|oletter
operator|!=
literal|'\0'
condition|;
name|o
operator|++
control|)
block|{
if|if
condition|(
name|o
operator|->
name|otype
operator|&
name|NO_TOGGLE
condition|)
continue|continue;
name|dorepaint
operator|=
operator|(
name|o
operator|->
name|otype
operator|&
name|REPAINT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|otype
operator|&
name|BOOL
operator|)
operator|&&
operator|(
name|o
operator|->
name|oletter
operator|==
name|c
operator|)
condition|)
block|{
comment|/* 			 * Boolean option:  			 * just toggle it. 			 */
if|if
condition|(
name|do_toggle
condition|)
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
operator|!
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|o
operator|->
name|otype
operator|&
name|TRIPLE
operator|)
operator|&&
operator|(
name|o
operator|->
name|oletter
operator|==
name|c
operator|)
condition|)
block|{
comment|/* 			 * Triple-valued option with lower case letter: 			 * make it 1 unless already 1, then make it 0. 			 */
if|if
condition|(
name|do_toggle
condition|)
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
operator|(
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|==
literal|1
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|o
operator|->
name|otype
operator|&
name|TRIPLE
operator|)
operator|&&
operator|(
name|toupper
argument_list|(
name|o
operator|->
name|oletter
argument_list|)
operator|==
name|c
operator|)
condition|)
block|{
comment|/* 			 * Triple-valued option with upper case letter: 			 * make it 2 unless already 2, then make it 0. 			 */
if|if
condition|(
name|do_toggle
condition|)
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
operator|(
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|==
literal|2
operator|)
condition|?
literal|0
else|:
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|o
operator|->
name|otype
operator|&
name|NUMBER
operator|)
operator|&&
operator|(
name|o
operator|->
name|oletter
operator|==
name|c
operator|)
condition|)
block|{
name|n
operator|=
name|getnum
argument_list|(
operator|&
name|s
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
comment|/* 				 * No number; just a query. 				 * No need to repaint screen. 				 */
name|dorepaint
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Number follows the option letter. 				 * Set the variable to that number. 				 */
if|if
condition|(
name|do_toggle
condition|)
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
name|n
expr_stmt|;
block|}
comment|/* 			 * Special case for -b. 			 * Call ch_init to set new number of buffers. 			 */
if|if
condition|(
name|o
operator|->
name|ovar
operator|==
operator|&
name|cbufs
condition|)
name|ch_init
argument_list|(
name|cbufs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|message
argument_list|,
name|o
operator|->
name|odesc
index|[
literal|0
index|]
argument_list|,
operator|(
name|o
operator|->
name|ovar
operator|==
operator|&
name|back_scroll
operator|)
condition|?
name|get_back_scroll
argument_list|()
else|:
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
argument_list|)
expr_stmt|;
name|msg
operator|=
name|message
expr_stmt|;
block|}
else|else
continue|continue;
comment|/* 		 * Print a message describing the new setting. 		 */
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
name|msg
operator|=
name|o
operator|->
name|odesc
index|[
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
index|]
expr_stmt|;
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_toggle
operator|&&
name|dorepaint
condition|)
name|repaint
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|control_char
argument_list|(
name|c
argument_list|)
condition|)
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"-^%c"
argument_list|,
name|carat_char
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"-%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|message
argument_list|,
literal|": no such flag."
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine if an option is a single character option (BOOL or TRIPLE),  * or if it a multi-character option (NUMBER).  */
end_comment

begin_function
name|public
name|int
name|single_char_option
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|struct
name|option
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'P'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
name|TAGS
if|if
condition|(
name|c
operator|==
literal|'t'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
name|LOGFILE
if|if
condition|(
name|c
operator|==
literal|'l'
operator|||
name|c
operator|==
literal|'L'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
for|for
control|(
name|o
operator|=
name|option
init|;
name|o
operator|->
name|oletter
operator|!=
literal|'\0'
condition|;
name|o
operator|++
control|)
if|if
condition|(
name|o
operator|->
name|oletter
operator|==
name|c
condition|)
return|return
operator|(
name|o
operator|->
name|otype
operator|&
operator|(
name|BOOL
operator||
name|TRIPLE
operator|)
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scan to end of string or to an END_OPTION_STRING character.  * In the latter case, replace the char with a null char.  * Return a pointer to the remainder of the string, if any.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|optstring
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|message
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"string is required after -%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
name|END_OPTION_STRING
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|p
operator|+
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * Scan an argument (either from command line or from LESS environment   * variable) and process it.  */
end_comment

begin_function
name|public
name|void
name|scan_option
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|struct
name|option
modifier|*
name|o
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|set_default
decl_stmt|;
name|char
name|message
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return;
name|set_default
operator|=
literal|0
expr_stmt|;
name|next
label|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return;
switch|switch
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
name|END_OPTION_STRING
case|:
goto|goto
name|next
goto|;
case|case
literal|'-'
case|:
if|if
condition|(
name|set_default
operator|=
operator|(
operator|*
name|s
operator|==
literal|'+'
operator|)
condition|)
name|s
operator|++
expr_stmt|;
goto|goto
name|next
goto|;
case|case
literal|'+'
case|:
name|plusoption
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
name|every_first_cmd
operator|=
name|save
argument_list|(
operator|++
name|s
argument_list|)
expr_stmt|;
name|first_cmd
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|optstring
argument_list|(
name|s
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
if|#
directive|if
name|LOGFILE
case|case
literal|'L'
case|:
name|force_logfile
operator|=
literal|1
expr_stmt|;
comment|/* FALLTHRU */
case|case
literal|'l'
case|:
name|namelogfile
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|optstring
argument_list|(
name|s
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
endif|#
directive|endif
if|#
directive|if
name|TAGS
case|case
literal|'t'
case|:
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|tagoption
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|optstring
argument_list|(
name|s
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|findtag
argument_list|(
name|p
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
endif|#
directive|endif
case|case
literal|'P'
case|:
name|s
operator|=
name|opt_P
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* 		 * Handle special "more" compatibility form "-number" 		 * (instead of -znumber) to set the scrolling window size. 		 */
name|s
operator|--
expr_stmt|;
name|c
operator|=
literal|'z'
expr_stmt|;
break|break;
block|}
for|for
control|(
name|o
operator|=
name|option
init|;
name|o
operator|->
name|oletter
operator|!=
literal|'\0'
condition|;
name|o
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|o
operator|->
name|otype
operator|&
name|BOOL
operator|)
operator|&&
operator|(
name|o
operator|->
name|oletter
operator|==
name|c
operator|)
condition|)
block|{
if|if
condition|(
name|set_default
condition|)
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
name|o
operator|->
name|odefault
expr_stmt|;
else|else
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
operator|!
name|o
operator|->
name|odefault
expr_stmt|;
goto|goto
name|next
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|o
operator|->
name|otype
operator|&
name|TRIPLE
operator|)
operator|&&
operator|(
name|o
operator|->
name|oletter
operator|==
name|c
operator|)
condition|)
block|{
if|if
condition|(
name|set_default
condition|)
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
name|o
operator|->
name|odefault
expr_stmt|;
else|else
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
operator|(
name|o
operator|->
name|odefault
operator|==
literal|1
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
goto|goto
name|next
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|o
operator|->
name|otype
operator|&
name|TRIPLE
operator|)
operator|&&
operator|(
name|toupper
argument_list|(
name|o
operator|->
name|oletter
argument_list|)
operator|==
name|c
operator|)
condition|)
block|{
if|if
condition|(
name|set_default
condition|)
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
name|o
operator|->
name|odefault
expr_stmt|;
else|else
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
operator|(
name|o
operator|->
name|odefault
operator|==
literal|2
operator|)
condition|?
literal|0
else|:
literal|2
expr_stmt|;
goto|goto
name|next
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|o
operator|->
name|otype
operator|&
name|NUMBER
operator|)
operator|&&
operator|(
name|o
operator|->
name|oletter
operator|==
name|c
operator|)
condition|)
block|{
operator|*
operator|(
name|o
operator|->
name|ovar
operator|)
operator|=
name|getnum
argument_list|(
operator|&
name|s
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
block|}
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"\"-%c\": invalid flag"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Special case for -P.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|opt_P
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|es
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|proto
decl_stmt|;
name|es
operator|=
name|optstring
argument_list|(
name|s
argument_list|,
literal|'P'
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out which prototype string should be changed. 	 */
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'m'
case|:
name|proto
operator|=
operator|&
name|prproto
index|[
name|PR_MEDIUM
index|]
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|proto
operator|=
operator|&
name|prproto
index|[
name|PR_LONG
index|]
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|proto
operator|=
operator|&
name|eqproto
expr_stmt|;
name|s
operator|++
expr_stmt|;
break|break;
default|default:
name|proto
operator|=
operator|&
name|prproto
index|[
name|pr_type
index|]
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
operator|*
name|proto
argument_list|)
expr_stmt|;
operator|*
name|proto
operator|=
name|save
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|es
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Translate a string into a number.  * Like atoi(), but takes a pointer to a char *, and updates  * the char * to point after the translated number.  */
end_comment

begin_function
name|public
name|int
name|getnum
parameter_list|(
name|sp
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
modifier|*
name|sp
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|char
name|message
index|[
literal|80
index|]
decl_stmt|;
name|s
operator|=
operator|*
name|sp
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|<
literal|'0'
operator|||
operator|*
name|s
operator|>
literal|'9'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"number is required after -%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<=
literal|'9'
condition|)
name|n
operator|=
literal|10
operator|*
name|n
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
operator|*
name|sp
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

end_unit

