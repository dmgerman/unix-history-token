begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Mark Nudleman  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Mark Nudleman and the University of California, Berkeley.  The  * name of Mark Nudleman or the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)prompt.c	5.4 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Prompting and other messages.  * There are three flavors of prompts, SHORT, MEDIUM and LONG,  * selected by the -m/-M options.  * There is also the "equals message", printed by the = command.  * A prompt is a message composed of various pieces, such as the   * name of the file being viewed, the percentage into the file, etc.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|"position.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|pr_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ispipe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|hit_eof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|new_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|so_width
decl_stmt|,
name|se_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|current_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ac
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|curr_ac
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|linenums
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Prototypes for the three flavors of prompts.  * These strings are expanded by pr_expand().  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|s_proto
index|[]
init|=
literal|"?n?f%f .?m(file %i of %m) ..?e(END) ?x- Next\\: %x..%t"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|m_proto
index|[]
init|=
literal|"?n?f%f .?m(file %i of %m) ..?e(END) ?x- Next\\: %x.:?pB%pB\\%:byte %bB?s/%s...%t"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|M_proto
index|[]
init|=
literal|"?f%f .?n?m(file %i of %m) ..?ltline %lt :byte %bB?s/%s ..?e(END) ?x- Next\\: %x.:?pB%pB\\%..%t"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|e_proto
index|[]
init|=
literal|"?f%f .?m(file %i of %m) .?ltline %lt .byte %bB?s/%s. ?e(END) :?pB%pB\\%..%t"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|prproto
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|eqproto
init|=
name|e_proto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|message
index|[
literal|250
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize the prompt prototype strings.  */
end_comment

begin_function
name|public
name|void
name|init_prompt
parameter_list|()
block|{
name|prproto
index|[
literal|0
index|]
operator|=
name|save
argument_list|(
name|s_proto
argument_list|)
expr_stmt|;
name|prproto
index|[
literal|1
index|]
operator|=
name|save
argument_list|(
name|m_proto
argument_list|)
expr_stmt|;
name|prproto
index|[
literal|2
index|]
operator|=
name|save
argument_list|(
name|M_proto
argument_list|)
expr_stmt|;
name|eqproto
operator|=
name|save
argument_list|(
name|e_proto
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the message pointer to the end of the message string.  */
end_comment

begin_function
specifier|static
name|void
name|setmp
parameter_list|()
block|{
while|while
condition|(
operator|*
name|mp
operator|!=
literal|'\0'
condition|)
name|mp
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append a POSITION (as a decimal integer) to the end of the message.  */
end_comment

begin_function
specifier|static
name|void
name|ap_pos
parameter_list|(
name|pos
parameter_list|)
name|POSITION
name|pos
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|mp
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|pos
argument_list|)
expr_stmt|;
name|setmp
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append an integer to the end of the message.  */
end_comment

begin_function
specifier|static
name|void
name|ap_int
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|mp
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|setmp
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Append a question mark to the end of the message.  */
end_comment

begin_function
specifier|static
name|void
name|ap_quest
parameter_list|()
block|{
operator|*
name|mp
operator|++
operator|=
literal|'?'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the "current" byte offset in the file.  */
end_comment

begin_function
specifier|static
name|POSITION
name|curr_byte
parameter_list|(
name|where
parameter_list|)
name|int
name|where
decl_stmt|;
block|{
name|POSITION
name|pos
decl_stmt|;
name|pos
operator|=
name|position
argument_list|(
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
name|pos
operator|=
name|ch_length
argument_list|()
expr_stmt|;
return|return
operator|(
name|pos
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the value of a prototype conditional.  * A prototype string may include conditionals which consist of a   * question mark followed by a single letter.  * Here we decode that letter and return the appropriate boolean value.  */
end_comment

begin_function
specifier|static
name|int
name|cond
parameter_list|(
name|c
parameter_list|,
name|where
parameter_list|)
name|char
name|c
decl_stmt|;
name|int
name|where
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* Anything in the message yet? */
return|return
operator|(
name|mp
operator|>
name|message
operator|)
return|;
case|case
literal|'b'
case|:
comment|/* Current byte offset known? */
return|return
operator|(
name|curr_byte
argument_list|(
name|where
argument_list|)
operator|!=
name|NULL_POSITION
operator|)
return|;
case|case
literal|'e'
case|:
comment|/* At end of file? */
return|return
operator|(
name|hit_eof
operator|)
return|;
case|case
literal|'f'
case|:
comment|/* Filename known? */
return|return
operator|(
operator|!
name|ispipe
operator|)
return|;
case|case
literal|'l'
case|:
comment|/* Line number known? */
return|return
operator|(
name|linenums
operator|)
return|;
case|case
literal|'m'
case|:
comment|/* More than one file? */
return|return
operator|(
name|ac
operator|>
literal|1
operator|)
return|;
case|case
literal|'n'
case|:
comment|/* First prompt in a new file? */
return|return
operator|(
name|new_file
operator|)
return|;
case|case
literal|'p'
case|:
comment|/* Percent into file known? */
return|return
operator|(
name|curr_byte
argument_list|(
name|where
argument_list|)
operator|!=
name|NULL_POSITION
operator|&&
name|ch_length
argument_list|()
operator|>
literal|0
operator|)
return|;
case|case
literal|'s'
case|:
comment|/* Size of file known? */
return|return
operator|(
name|ch_length
argument_list|()
operator|!=
name|NULL_POSITION
operator|)
return|;
case|case
literal|'x'
case|:
comment|/* Is there a "next" file? */
return|return
operator|(
name|curr_ac
operator|+
literal|1
operator|<
name|ac
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decode a "percent" prototype character.  * A prototype string may include various "percent" escapes;  * that is, a percent sign followed by a single letter.  * Here we decode that letter and take the appropriate action,  * usually by appending something to the message being built.  */
end_comment

begin_function
specifier|static
name|void
name|protochar
parameter_list|(
name|c
parameter_list|,
name|where
parameter_list|)
name|int
name|c
decl_stmt|;
name|int
name|where
decl_stmt|;
block|{
name|POSITION
name|pos
decl_stmt|;
name|POSITION
name|len
decl_stmt|;
name|int
name|n
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* Current byte offset */
name|pos
operator|=
name|curr_byte
argument_list|(
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|NULL_POSITION
condition|)
name|ap_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
else|else
name|ap_quest
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* File name */
name|strtcpy
argument_list|(
name|mp
argument_list|,
name|current_file
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|&
name|message
index|[
sizeof|sizeof
argument_list|(
name|message
argument_list|)
index|]
operator|-
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|setmp
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Index into list of files */
name|ap_int
argument_list|(
name|curr_ac
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* Current line number */
name|n
operator|=
name|currline
argument_list|(
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
name|ap_int
argument_list|(
name|n
argument_list|)
expr_stmt|;
else|else
name|ap_quest
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Number of files */
name|ap_int
argument_list|(
name|ac
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Percent into file */
name|pos
operator|=
name|curr_byte
argument_list|(
name|where
argument_list|)
expr_stmt|;
name|len
operator|=
name|ch_length
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|NULL_POSITION
operator|&&
name|len
operator|>
literal|0
condition|)
name|ap_int
argument_list|(
call|(
name|int
call|)
argument_list|(
literal|100
operator|*
name|pos
operator|/
name|len
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ap_quest
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Size of file */
name|len
operator|=
name|ch_length
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|NULL_POSITION
condition|)
name|ap_pos
argument_list|(
name|len
argument_list|)
expr_stmt|;
else|else
name|ap_quest
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Truncate trailing spaces in the message */
while|while
condition|(
name|mp
operator|>
name|message
operator|&&
name|mp
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|mp
operator|--
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* Name of next file */
if|if
condition|(
name|curr_ac
operator|+
literal|1
operator|<
name|ac
condition|)
block|{
name|strtcpy
argument_list|(
name|mp
argument_list|,
name|av
index|[
name|curr_ac
operator|+
literal|1
index|]
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|&
name|message
index|[
sizeof|sizeof
argument_list|(
name|message
argument_list|)
index|]
operator|-
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|setmp
argument_list|()
expr_stmt|;
block|}
else|else
name|ap_quest
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Skip a false conditional.  * When a false condition is found (either a false IF or the ELSE part   * of a true IF), this routine scans the prototype string to decide  * where to resume parsing the string.  * We must keep track of nested IFs and skip them properly.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|skipcond
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|iflevel
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'?'
case|:
comment|/* 		 * Start of a nested IF. 		 */
name|iflevel
operator|++
expr_stmt|;
break|break;
case|case
literal|':'
case|:
comment|/* 		 * Else. 		 * If this matches the IF we came in here with, 		 * then we're done. 		 */
if|if
condition|(
name|iflevel
operator|==
literal|1
condition|)
return|return
operator|(
name|p
operator|)
return|;
break|break;
case|case
literal|'.'
case|:
comment|/* 		 * Endif. 		 * If this matches the IF we came in here with, 		 * then we're done. 		 */
if|if
condition|(
operator|--
name|iflevel
operator|==
literal|0
condition|)
return|return
operator|(
name|p
operator|)
return|;
break|break;
case|case
literal|'\\'
case|:
comment|/* 		 * Backslash escapes the next character. 		 */
operator|++
name|p
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
comment|/* 		 * Whoops.  Hit end of string. 		 * This is a malformed conditional, but just treat it 		 * as if all active conditionals ends here. 		 */
return|return
operator|(
name|p
operator|-
literal|1
operator|)
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|wherechar
parameter_list|(
name|p
parameter_list|,
name|wp
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|int
modifier|*
name|wp
decl_stmt|;
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'b'
case|:
case|case
literal|'l'
case|:
case|case
literal|'p'
case|:
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'t'
case|:
operator|*
name|wp
operator|=
name|TOP
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
operator|*
name|wp
operator|=
name|MIDDLE
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|wp
operator|=
name|BOTTOM
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
operator|*
name|wp
operator|=
name|BOTTOM_PLUS_ONE
expr_stmt|;
break|break;
default|default:
operator|*
name|wp
operator|=
name|TOP
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Construct a message based on a prototype string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|pr_expand
parameter_list|(
name|proto
parameter_list|,
name|maxwidth
parameter_list|)
name|char
modifier|*
name|proto
decl_stmt|;
name|int
name|maxwidth
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|where
decl_stmt|;
name|mp
operator|=
name|message
expr_stmt|;
if|if
condition|(
operator|*
name|proto
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|""
operator|)
return|;
for|for
control|(
name|p
operator|=
name|proto
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
default|default:
comment|/* Just put the character in the message */
operator|*
name|mp
operator|++
operator|=
operator|*
name|p
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Backslash escapes the next character */
name|p
operator|++
expr_stmt|;
operator|*
name|mp
operator|++
operator|=
operator|*
name|p
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* Conditional (IF) */
if|if
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|p
operator|)
operator|==
literal|'\0'
condition|)
operator|--
name|p
expr_stmt|;
else|else
block|{
name|p
operator|=
name|wherechar
argument_list|(
name|p
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
argument_list|(
name|c
argument_list|,
name|where
argument_list|)
condition|)
name|p
operator|=
name|skipcond
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|':'
case|:
comment|/* ELSE */
name|p
operator|=
name|skipcond
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
comment|/* ENDIF */
break|break;
case|case
literal|'%'
case|:
comment|/* Percent escape */
if|if
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|p
operator|)
operator|==
literal|'\0'
condition|)
operator|--
name|p
expr_stmt|;
else|else
block|{
name|p
operator|=
name|wherechar
argument_list|(
name|p
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|protochar
argument_list|(
name|c
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|new_file
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|message
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|mp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|maxwidth
operator|>
literal|0
operator|&&
name|mp
operator|>=
name|message
operator|+
name|maxwidth
condition|)
block|{
comment|/* 		 * Message is too long. 		 * Return just the final portion of it. 		 */
return|return
operator|(
name|mp
operator|-
name|maxwidth
operator|)
return|;
block|}
return|return
operator|(
name|message
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a message suitable for printing by the "=" command.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|eq_message
parameter_list|()
block|{
return|return
operator|(
name|pr_expand
argument_list|(
name|eqproto
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a prompt.  * This depends on the prompt type (SHORT, MEDIUM, LONG), etc.  * If we can't come up with an appropriate prompt, return NULL  * and the caller will prompt with a colon.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|pr_string
parameter_list|()
block|{
return|return
operator|(
name|pr_expand
argument_list|(
name|prproto
index|[
name|pr_type
index|]
argument_list|,
name|sc_width
operator|-
name|so_width
operator|-
name|se_width
operator|-
literal|2
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

