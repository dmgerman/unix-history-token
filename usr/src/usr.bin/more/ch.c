begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Mark Nudleman  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Mark Nudleman.  *   * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ch.c	5.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Low level character input from the input file.  * We use these special purpose routines which optimize moving  * both forward and backward from the current read pointer.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_decl_stmt
name|public
name|int
name|file
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File descriptor of the input file */
end_comment

begin_comment
comment|/*  * Pool of buffers holding the most recently used blocks of the input file.  */
end_comment

begin_define
define|#
directive|define
name|BUFSIZ
value|1024
end_define

begin_struct
struct|struct
name|buf
block|{
name|struct
name|buf
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|long
name|block
decl_stmt|;
name|int
name|datasize
decl_stmt|;
name|char
name|data
index|[
name|BUFSIZ
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|public
name|int
name|nbufs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The buffer pool is kept as a doubly-linked circular list,  * in order from most- to least-recently used.  * The circular list is anchored by buf_anchor.  */
end_comment

begin_define
define|#
directive|define
name|END_OF_CHAIN
value|((struct buf *)&buf_anchor)
end_define

begin_define
define|#
directive|define
name|buf_head
value|buf_anchor.next
end_define

begin_define
define|#
directive|define
name|buf_tail
value|buf_anchor.prev
end_define

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|buf
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
block|}
name|buf_anchor
init|=
block|{
name|END_OF_CHAIN
block|,
name|END_OF_CHAIN
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|int
name|clean_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ispipe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|autobuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cbufs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sigs
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|LOGFILE
end_if

begin_decl_stmt
specifier|extern
name|int
name|logfile
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Current position in file.  * Stored as a block number and an offset into the block.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|ch_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ch_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Length of file, needed if input is a pipe.  */
end_comment

begin_decl_stmt
specifier|static
name|POSITION
name|ch_fsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Number of bytes read, if input is standard input (a pipe).  */
end_comment

begin_decl_stmt
specifier|static
name|POSITION
name|last_piped_pos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Get the character pointed to by the read pointer.  * ch_get() is a macro which is more efficient to call  * than fch_get (the function), in the usual case   * that the block desired is at the head of the chain.  */
end_comment

begin_define
define|#
directive|define
name|ch_get
parameter_list|()
value|((buf_head->block == ch_block&& \ 		     ch_offset< buf_head->datasize) ? \ 			buf_head->data[ch_offset] : fch_get())
end_define

begin_function
specifier|static
name|int
name|fch_get
parameter_list|()
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
comment|/* 	 * Look for a buffer holding the desired block. 	 */
for|for
control|(
name|bp
operator|=
name|buf_head
init|;
name|bp
operator|!=
name|END_OF_CHAIN
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
if|if
condition|(
name|bp
operator|->
name|block
operator|==
name|ch_block
condition|)
block|{
if|if
condition|(
name|ch_offset
operator|>=
name|bp
operator|->
name|datasize
condition|)
comment|/* 				 * Need more data in this buffer. 				 */
goto|goto
name|read_more
goto|;
comment|/* 			 * On a pipe, we don't sort the buffers LRU 			 * because this can cause gaps in the buffers. 			 * For example, suppose we've got 12 1K buffers, 			 * and a 15K input stream.  If we read the first 12K 			 * sequentially, then jump to line 1, then jump to 			 * the end, the buffers have blocks 0,4,5,6,..,14. 			 * If we then jump to line 1 again and try to 			 * read sequentially, we're out of luck when we 			 * get to block 1 (we'd get the "pipe error" below). 			 * To avoid this, we only sort buffers on a pipe 			 * when we actually READ the data, not when we 			 * find it already buffered. 			 */
if|if
condition|(
name|ispipe
condition|)
return|return
operator|(
name|bp
operator|->
name|data
index|[
name|ch_offset
index|]
operator|)
return|;
goto|goto
name|found
goto|;
block|}
comment|/* 	 * Block is not in a buffer.   	 * Take the least recently used buffer  	 * and read the desired block into it. 	 * If the LRU buffer has data in it,  	 * and autobuf is true, and input is a pipe,  	 * then try to allocate a new buffer first. 	 */
if|if
condition|(
name|autobuf
operator|&&
name|ispipe
operator|&&
name|buf_tail
operator|->
name|block
operator|!=
call|(
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
operator|(
name|void
operator|)
name|ch_addbuf
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf_tail
expr_stmt|;
name|bp
operator|->
name|block
operator|=
name|ch_block
expr_stmt|;
name|bp
operator|->
name|datasize
operator|=
literal|0
expr_stmt|;
name|read_more
label|:
name|pos
operator|=
operator|(
name|ch_block
operator|*
name|BUFSIZ
operator|)
operator|+
name|bp
operator|->
name|datasize
expr_stmt|;
if|if
condition|(
name|ispipe
condition|)
block|{
comment|/* 		 * The data requested should be immediately after 		 * the last data read from the pipe. 		 */
if|if
condition|(
name|pos
operator|!=
name|last_piped_pos
condition|)
block|{
name|error
argument_list|(
literal|"pipe error"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|lseek
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Read the block. 	 * If we read less than a full block, we just return the 	 * partial block and pick up the rest next time. 	 */
name|n
operator|=
name|iread
argument_list|(
name|file
argument_list|,
operator|&
name|bp
operator|->
name|data
index|[
name|bp
operator|->
name|datasize
index|]
argument_list|,
name|BUFSIZ
operator|-
name|bp
operator|->
name|datasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|READ_INTR
condition|)
return|return
operator|(
name|EOI
operator|)
return|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"read error"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ispipe
condition|)
name|last_piped_pos
operator|+=
name|n
expr_stmt|;
if|#
directive|if
name|LOGFILE
comment|/* 	 * If we have a log file, write the new data to it. 	 */
if|if
condition|(
name|logfile
operator|>=
literal|0
operator|&&
name|n
operator|>
literal|0
condition|)
name|write
argument_list|(
name|logfile
argument_list|,
operator|&
name|bp
operator|->
name|data
index|[
name|bp
operator|->
name|datasize
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|->
name|datasize
operator|+=
name|n
expr_stmt|;
comment|/* 	 * Set an EOI marker in the buffered data itself. 	 * Then ensure the data is "clean": there are no  	 * extra EOI chars in the data and that the "meta" 	 * bit (the 0200 bit) is reset in each char. 	 */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|ch_fsize
operator|=
name|pos
expr_stmt|;
name|bp
operator|->
name|data
index|[
name|bp
operator|->
name|datasize
operator|++
index|]
operator|=
name|EOI
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|clean_data
condition|)
block|{
name|p
operator|=
operator|&
name|bp
operator|->
name|data
index|[
name|bp
operator|->
name|datasize
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
operator|*
operator|--
name|p
operator|&=
literal|0177
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|EOI
condition|)
operator|*
name|p
operator|=
literal|'@'
expr_stmt|;
block|}
block|}
name|found
label|:
if|if
condition|(
name|buf_head
operator|!=
name|bp
condition|)
block|{
comment|/* 		 * Move the buffer to the head of the buffer chain. 		 * This orders the buffer chain, most- to least-recently used. 		 */
name|bp
operator|->
name|next
operator|->
name|prev
operator|=
name|bp
operator|->
name|prev
expr_stmt|;
name|bp
operator|->
name|prev
operator|->
name|next
operator|=
name|bp
operator|->
name|next
expr_stmt|;
name|bp
operator|->
name|next
operator|=
name|buf_head
expr_stmt|;
name|bp
operator|->
name|prev
operator|=
name|END_OF_CHAIN
expr_stmt|;
name|buf_head
operator|->
name|prev
operator|=
name|bp
expr_stmt|;
name|buf_head
operator|=
name|bp
expr_stmt|;
block|}
if|if
condition|(
name|ch_offset
operator|>=
name|bp
operator|->
name|datasize
condition|)
comment|/* 		 * After all that, we still don't have enough data. 		 * Go back and try again. 		 */
goto|goto
name|read_more
goto|;
return|return
operator|(
name|bp
operator|->
name|data
index|[
name|ch_offset
index|]
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|LOGFILE
end_if

begin_comment
comment|/*  * Close the logfile.  * If we haven't read all of standard input into it, do that now.  */
end_comment

begin_function
name|public
name|void
name|end_logfile
parameter_list|()
block|{
specifier|static
name|int
name|tried
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|logfile
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|tried
operator|&&
name|ch_fsize
operator|==
name|NULL_POSITION
condition|)
block|{
name|tried
operator|=
literal|1
expr_stmt|;
name|ierror
argument_list|(
literal|"finishing logfile"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ch_forw_get
argument_list|()
operator|!=
name|EOI
condition|)
if|if
condition|(
name|sigs
condition|)
break|break;
block|}
name|close
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
name|logfile
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start a log file AFTER less has already been running.  * Invoked from the - command; see toggle_option().  * Write all the existing buffered data to the log file.  */
end_comment

begin_function
name|public
name|void
name|sync_logfile
parameter_list|()
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|long
name|block
decl_stmt|;
name|long
name|last_block
decl_stmt|;
name|last_block
operator|=
operator|(
name|last_piped_pos
operator|+
name|BUFSIZ
operator|-
literal|1
operator|)
operator|/
name|BUFSIZ
expr_stmt|;
for|for
control|(
name|block
operator|=
literal|0
init|;
name|block
operator|<=
name|last_block
condition|;
name|block
operator|++
control|)
for|for
control|(
name|bp
operator|=
name|buf_head
init|;
name|bp
operator|!=
name|END_OF_CHAIN
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
if|if
condition|(
name|bp
operator|->
name|block
operator|==
name|block
condition|)
block|{
name|n
operator|=
name|bp
operator|->
name|datasize
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|data
index|[
name|n
operator|-
literal|1
index|]
operator|==
name|EOI
condition|)
name|n
operator|--
expr_stmt|;
name|write
argument_list|(
name|logfile
argument_list|,
name|bp
operator|->
name|data
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Determine if a specific block is currently in one of the buffers.  */
end_comment

begin_function
specifier|static
name|int
name|buffered
parameter_list|(
name|block
parameter_list|)
name|long
name|block
decl_stmt|;
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|buf_head
init|;
name|bp
operator|!=
name|END_OF_CHAIN
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
if|if
condition|(
name|bp
operator|->
name|block
operator|==
name|block
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Seek to a specified position in the file.  * Return 0 if successful, non-zero if can't seek there.  */
end_comment

begin_function
name|public
name|int
name|ch_seek
parameter_list|(
name|pos
parameter_list|)
specifier|register
name|POSITION
name|pos
decl_stmt|;
block|{
name|long
name|new_block
decl_stmt|;
name|new_block
operator|=
name|pos
operator|/
name|BUFSIZ
expr_stmt|;
if|if
condition|(
operator|!
name|ispipe
operator|||
name|pos
operator|==
name|last_piped_pos
operator|||
name|buffered
argument_list|(
name|new_block
argument_list|)
condition|)
block|{
comment|/* 		 * Set read pointer. 		 */
name|ch_block
operator|=
name|new_block
expr_stmt|;
name|ch_offset
operator|=
name|pos
operator|%
name|BUFSIZ
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Seek to the end of the file.  */
end_comment

begin_function
name|public
name|int
name|ch_end_seek
parameter_list|()
block|{
if|if
condition|(
operator|!
name|ispipe
condition|)
return|return
operator|(
name|ch_seek
argument_list|(
name|ch_length
argument_list|()
argument_list|)
operator|)
return|;
comment|/* 	 * Do it the slow way: read till end of data. 	 */
while|while
condition|(
name|ch_forw_get
argument_list|()
operator|!=
name|EOI
condition|)
if|if
condition|(
name|sigs
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Seek to the beginning of the file, or as close to it as we can get.  * We may not be able to seek there if input is a pipe and the  * beginning of the pipe is no longer buffered.  */
end_comment

begin_function
name|public
name|int
name|ch_beg_seek
parameter_list|()
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|firstbp
decl_stmt|;
comment|/* 	 * Try a plain ch_seek first. 	 */
if|if
condition|(
name|ch_seek
argument_list|(
operator|(
name|POSITION
operator|)
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Can't get to position 0. 	 * Look thru the buffers for the one closest to position 0. 	 */
name|firstbp
operator|=
name|bp
operator|=
name|buf_head
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|END_OF_CHAIN
condition|)
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
operator|(
name|bp
operator|=
name|bp
operator|->
name|next
operator|)
operator|!=
name|END_OF_CHAIN
condition|)
if|if
condition|(
name|bp
operator|->
name|block
operator|<
name|firstbp
operator|->
name|block
condition|)
name|firstbp
operator|=
name|bp
expr_stmt|;
name|ch_block
operator|=
name|firstbp
operator|->
name|block
expr_stmt|;
name|ch_offset
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the length of the file, if known.  */
end_comment

begin_function
name|public
name|POSITION
name|ch_length
parameter_list|()
block|{
if|if
condition|(
name|ispipe
condition|)
return|return
operator|(
name|ch_fsize
operator|)
return|;
return|return
operator|(
call|(
name|POSITION
call|)
argument_list|(
name|lseek
argument_list|(
name|file
argument_list|,
operator|(
name|offset_t
operator|)
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the current position in the file.  */
end_comment

begin_function
name|public
name|POSITION
name|ch_tell
parameter_list|()
block|{
return|return
operator|(
name|ch_block
operator|*
name|BUFSIZ
operator|+
name|ch_offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the current char and post-increment the read pointer.  */
end_comment

begin_function
name|public
name|int
name|ch_forw_get
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|ch_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOI
operator|&&
operator|++
name|ch_offset
operator|>=
name|BUFSIZ
condition|)
block|{
name|ch_offset
operator|=
literal|0
expr_stmt|;
name|ch_block
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pre-decrement the read pointer and get the new current char.  */
end_comment

begin_function
name|public
name|int
name|ch_back_get
parameter_list|()
block|{
if|if
condition|(
operator|--
name|ch_offset
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ch_block
operator|<=
literal|0
operator|||
operator|(
name|ispipe
operator|&&
operator|!
name|buffered
argument_list|(
name|ch_block
operator|-
literal|1
argument_list|)
operator|)
condition|)
block|{
name|ch_offset
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EOI
operator|)
return|;
block|}
name|ch_offset
operator|=
name|BUFSIZ
operator|-
literal|1
expr_stmt|;
name|ch_block
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|ch_get
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate buffers.  * Caller wants us to have a total of at least want_nbufs buffers.  * keep==1 means keep the data in the current buffers;  * otherwise discard the old data.  */
end_comment

begin_function
name|public
name|void
name|ch_init
parameter_list|(
name|want_nbufs
parameter_list|,
name|keep
parameter_list|)
name|int
name|want_nbufs
decl_stmt|;
name|int
name|keep
decl_stmt|;
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|char
name|message
index|[
literal|80
index|]
decl_stmt|;
name|cbufs
operator|=
name|nbufs
expr_stmt|;
if|if
condition|(
name|nbufs
operator|<
name|want_nbufs
operator|&&
name|ch_addbuf
argument_list|(
name|want_nbufs
operator|-
name|nbufs
argument_list|)
condition|)
block|{
comment|/* 		 * Cannot allocate enough buffers. 		 * If we don't have ANY, then quit. 		 * Otherwise, just report the error and return. 		 */
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"cannot allocate %d buffers"
argument_list|,
name|want_nbufs
operator|-
name|nbufs
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbufs
operator|==
literal|0
condition|)
name|quit
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|keep
condition|)
return|return;
comment|/* 	 * We don't want to keep the old data, 	 * so initialize all the buffers now. 	 */
for|for
control|(
name|bp
operator|=
name|buf_head
init|;
name|bp
operator|!=
name|END_OF_CHAIN
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
name|bp
operator|->
name|block
operator|=
call|(
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|last_piped_pos
operator|=
operator|(
name|POSITION
operator|)
literal|0
expr_stmt|;
name|ch_fsize
operator|=
name|NULL_POSITION
expr_stmt|;
operator|(
name|void
operator|)
name|ch_seek
argument_list|(
operator|(
name|POSITION
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate some new buffers.  * The buffers are added to the tail of the buffer chain.  */
end_comment

begin_function
specifier|static
name|int
name|ch_addbuf
parameter_list|(
name|nnew
parameter_list|)
name|int
name|nnew
decl_stmt|;
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|newbufs
decl_stmt|;
comment|/* 	 * We don't have enough buffers.   	 * Allocate some new ones. 	 */
name|newbufs
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|calloc
argument_list|(
name|nnew
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbufs
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Initialize the new buffers and link them together. 	 * Link them all onto the tail of the buffer list. 	 */
name|nbufs
operator|+=
name|nnew
expr_stmt|;
name|cbufs
operator|=
name|nbufs
expr_stmt|;
for|for
control|(
name|bp
operator|=
operator|&
name|newbufs
index|[
literal|0
index|]
init|;
name|bp
operator|<
operator|&
name|newbufs
index|[
name|nnew
index|]
condition|;
name|bp
operator|++
control|)
block|{
name|bp
operator|->
name|next
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
name|bp
operator|->
name|prev
operator|=
name|bp
operator|-
literal|1
expr_stmt|;
name|bp
operator|->
name|block
operator|=
call|(
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|newbufs
index|[
name|nnew
operator|-
literal|1
index|]
operator|.
name|next
operator|=
name|END_OF_CHAIN
expr_stmt|;
name|newbufs
index|[
literal|0
index|]
operator|.
name|prev
operator|=
name|buf_tail
expr_stmt|;
name|buf_tail
operator|->
name|next
operator|=
operator|&
name|newbufs
index|[
literal|0
index|]
expr_stmt|;
name|buf_tail
operator|=
operator|&
name|newbufs
index|[
name|nnew
operator|-
literal|1
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

