begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Mark Nudleman  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ch.c	5.9 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Low level character input from the input file.  * We use these special purpose routines which optimize moving  * both forward and backward from the current read pointer.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<less.h>
end_include

begin_decl_stmt
name|int
name|file
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File descriptor of the input file */
end_comment

begin_comment
comment|/*  * Pool of buffers holding the most recently used blocks of the input file.  */
end_comment

begin_struct
struct|struct
name|buf
block|{
name|struct
name|buf
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|long
name|block
decl_stmt|;
name|int
name|datasize
decl_stmt|;
name|char
name|data
index|[
name|BUFSIZ
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|nbufs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The buffer pool is kept as a doubly-linked circular list, in order from  * most- to least-recently used.  The circular list is anchored by buf_anchor.  */
end_comment

begin_define
define|#
directive|define
name|END_OF_CHAIN
value|((struct buf *)&buf_anchor)
end_define

begin_define
define|#
directive|define
name|buf_head
value|buf_anchor.next
end_define

begin_define
define|#
directive|define
name|buf_tail
value|buf_anchor.prev
end_define

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|buf
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
block|}
name|buf_anchor
init|=
block|{
name|END_OF_CHAIN
block|,
name|END_OF_CHAIN
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|int
name|ispipe
decl_stmt|,
name|cbufs
decl_stmt|,
name|sigs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Current position in file.  * Stored as a block number and an offset into the block.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|ch_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ch_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of file, needed if input is a pipe. */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|ch_fsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes read, if input is standard input (a pipe). */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|last_piped_pos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Get the character pointed to by the read pointer.  ch_get() is a macro  * which is more efficient to call than fch_get (the function), in the usual  * case that the block desired is at the head of the chain.  */
end_comment

begin_define
define|#
directive|define
name|ch_get
parameter_list|()
define|\
value|((buf_head->block == ch_block&& \ 	    ch_offset< buf_head->datasize) ? \ 	    buf_head->data[ch_offset] : fch_get())
end_define

begin_expr_stmt
specifier|static
name|fch_get
argument_list|()
block|{
specifier|extern
name|int
name|bs_mode
block|;
specifier|register
expr|struct
name|buf
operator|*
name|bp
block|;
specifier|register
name|int
name|n
block|,
name|ch
block|;
specifier|register
name|char
operator|*
name|p
block|,
operator|*
name|t
block|;
name|off_t
name|pos
block|,
name|lseek
argument_list|()
block|;
comment|/* look for a buffer holding the desired block. */
for|for
control|(
name|bp
operator|=
name|buf_head
init|;
name|bp
operator|!=
name|END_OF_CHAIN
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
if|if
condition|(
name|bp
operator|->
name|block
operator|==
name|ch_block
condition|)
block|{
if|if
condition|(
name|ch_offset
operator|>=
name|bp
operator|->
name|datasize
condition|)
comment|/* 				 * Need more data in this buffer. 				 */
goto|goto
name|read_more
goto|;
comment|/* 			 * On a pipe, we don't sort the buffers LRU 			 * because this can cause gaps in the buffers. 			 * For example, suppose we've got 12 1K buffers, 			 * and a 15K input stream.  If we read the first 12K 			 * sequentially, then jump to line 1, then jump to 			 * the end, the buffers have blocks 0,4,5,6,..,14. 			 * If we then jump to line 1 again and try to 			 * read sequentially, we're out of luck when we 			 * get to block 1 (we'd get the "pipe error" below). 			 * To avoid this, we only sort buffers on a pipe 			 * when we actually READ the data, not when we 			 * find it already buffered. 			 */
if|if
condition|(
name|ispipe
condition|)
return|return
operator|(
name|bp
operator|->
name|data
index|[
name|ch_offset
index|]
operator|)
return|;
goto|goto
name|found
goto|;
block|}
end_expr_stmt

begin_comment
comment|/* 	 * Block is not in a buffer.  Take the least recently used buffer 	 * and read the desired block into it.  If the LRU buffer has data 	 * in it, and input is a pipe, then try to allocate a new buffer first. 	 */
end_comment

begin_if
if|if
condition|(
name|ispipe
operator|&&
name|buf_tail
operator|->
name|block
operator|!=
call|(
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
operator|(
name|void
operator|)
name|ch_addbuf
argument_list|(
literal|1
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|bp
operator|=
name|buf_tail
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bp
operator|->
name|block
operator|=
name|ch_block
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bp
operator|->
name|datasize
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_label
name|read_more
label|:
end_label

begin_expr_stmt
name|pos
operator|=
operator|(
name|ch_block
operator|*
name|BUFSIZ
operator|)
operator|+
name|bp
operator|->
name|datasize
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ispipe
condition|)
block|{
comment|/* 		 * The data requested should be immediately after 		 * the last data read from the pipe. 		 */
if|if
condition|(
name|pos
operator|!=
name|last_piped_pos
condition|)
block|{
name|error
argument_list|(
literal|"pipe error"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
block|}
else|else
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* 	 * Read the block. 	 * If we read less than a full block, we just return the 	 * partial block and pick up the rest next time. 	 */
end_comment

begin_expr_stmt
name|n
operator|=
name|iread
argument_list|(
name|file
argument_list|,
operator|&
name|bp
operator|->
name|data
index|[
name|bp
operator|->
name|datasize
index|]
argument_list|,
name|BUFSIZ
operator|-
name|bp
operator|->
name|datasize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|n
operator|==
name|READ_INTR
condition|)
return|return
operator|(
name|EOI
operator|)
return|;
end_if

begin_if
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"read error"
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|ispipe
condition|)
name|last_piped_pos
operator|+=
name|n
expr_stmt|;
end_if

begin_expr_stmt
name|p
operator|=
operator|&
name|bp
operator|->
name|data
index|[
name|bp
operator|->
name|datasize
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bp
operator|->
name|datasize
operator|+=
name|n
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Set an EOI marker in the buffered data itself.  Then ensure the 	 * data is "clean": there are no extra EOI chars in the data and 	 * that the "meta" bit (the 0200 bit) is reset in each char; 	 * also translate \r\n sequences to \n if -u flag not set. 	 */
end_comment

begin_if
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|ch_fsize
operator|=
name|pos
expr_stmt|;
name|bp
operator|->
name|data
index|[
name|bp
operator|->
name|datasize
operator|++
index|]
operator|=
name|EOI
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|bs_mode
condition|)
block|{
for|for
control|(
name|p
operator|=
operator|&
name|bp
operator|->
name|data
index|[
name|bp
operator|->
name|datasize
index|]
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
control|)
block|{
operator|*
operator|--
name|p
operator|&=
literal|0177
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|EOI
condition|)
operator|*
name|p
operator|=
literal|0200
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|t
operator|=
name|p
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
operator|++
name|p
control|)
block|{
name|ch
operator|=
operator|*
name|p
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\r'
operator|&&
name|n
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|&
literal|0177
operator|)
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|p
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
else|else
operator|*
name|t
operator|++
operator|=
operator|(
name|ch
operator|==
name|EOI
operator|)
condition|?
literal|0200
else|:
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|t
condition|)
block|{
name|bp
operator|->
name|datasize
operator|-=
name|p
operator|-
name|t
expr_stmt|;
if|if
condition|(
name|ispipe
condition|)
name|last_piped_pos
operator|-=
name|p
operator|-
name|t
expr_stmt|;
block|}
block|}
end_if

begin_label
name|found
label|:
end_label

begin_if
if|if
condition|(
name|buf_head
operator|!=
name|bp
condition|)
block|{
comment|/* 		 * Move the buffer to the head of the buffer chain. 		 * This orders the buffer chain, most- to least-recently used. 		 */
name|bp
operator|->
name|next
operator|->
name|prev
operator|=
name|bp
operator|->
name|prev
expr_stmt|;
name|bp
operator|->
name|prev
operator|->
name|next
operator|=
name|bp
operator|->
name|next
expr_stmt|;
name|bp
operator|->
name|next
operator|=
name|buf_head
expr_stmt|;
name|bp
operator|->
name|prev
operator|=
name|END_OF_CHAIN
expr_stmt|;
name|buf_head
operator|->
name|prev
operator|=
name|bp
expr_stmt|;
name|buf_head
operator|=
name|bp
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|ch_offset
operator|>=
name|bp
operator|->
name|datasize
condition|)
comment|/* 		 * After all that, we still don't have enough data. 		 * Go back and try again. 		 */
goto|goto
name|read_more
goto|;
end_if

begin_return
return|return
operator|(
name|bp
operator|->
name|data
index|[
name|ch_offset
index|]
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * Determine if a specific block is currently in one of the buffers.  */
end_comment

begin_macro
unit|static
name|buffered
argument_list|(
argument|block
argument_list|)
end_macro

begin_decl_stmt
name|long
name|block
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|buf_head
init|;
name|bp
operator|!=
name|END_OF_CHAIN
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
if|if
condition|(
name|bp
operator|->
name|block
operator|==
name|block
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Seek to a specified position in the file.  * Return 0 if successful, non-zero if can't seek there.  */
end_comment

begin_expr_stmt
name|ch_seek
argument_list|(
name|pos
argument_list|)
specifier|register
name|off_t
name|pos
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|long
name|new_block
decl_stmt|;
name|new_block
operator|=
name|pos
operator|/
name|BUFSIZ
expr_stmt|;
if|if
condition|(
operator|!
name|ispipe
operator|||
name|pos
operator|==
name|last_piped_pos
operator|||
name|buffered
argument_list|(
name|new_block
argument_list|)
condition|)
block|{
comment|/* 		 * Set read pointer. 		 */
name|ch_block
operator|=
name|new_block
expr_stmt|;
name|ch_offset
operator|=
name|pos
operator|%
name|BUFSIZ
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Seek to the end of the file.  */
end_comment

begin_macro
name|ch_end_seek
argument_list|()
end_macro

begin_block
block|{
name|off_t
name|ch_length
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|ispipe
condition|)
return|return
operator|(
name|ch_seek
argument_list|(
name|ch_length
argument_list|()
argument_list|)
operator|)
return|;
comment|/* 	 * Do it the slow way: read till end of data. 	 */
while|while
condition|(
name|ch_forw_get
argument_list|()
operator|!=
name|EOI
condition|)
if|if
condition|(
name|sigs
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Seek to the beginning of the file, or as close to it as we can get.  * We may not be able to seek there if input is a pipe and the  * beginning of the pipe is no longer buffered.  */
end_comment

begin_macro
name|ch_beg_seek
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|firstbp
decl_stmt|;
comment|/* 	 * Try a plain ch_seek first. 	 */
if|if
condition|(
name|ch_seek
argument_list|(
operator|(
name|off_t
operator|)
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Can't get to position 0. 	 * Look thru the buffers for the one closest to position 0. 	 */
name|firstbp
operator|=
name|bp
operator|=
name|buf_head
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|END_OF_CHAIN
condition|)
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
operator|(
name|bp
operator|=
name|bp
operator|->
name|next
operator|)
operator|!=
name|END_OF_CHAIN
condition|)
if|if
condition|(
name|bp
operator|->
name|block
operator|<
name|firstbp
operator|->
name|block
condition|)
name|firstbp
operator|=
name|bp
expr_stmt|;
name|ch_block
operator|=
name|firstbp
operator|->
name|block
expr_stmt|;
name|ch_offset
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Return the length of the file, if known.  */
end_comment

begin_function
name|off_t
name|ch_length
parameter_list|()
block|{
name|off_t
name|lseek
parameter_list|()
function_decl|;
if|if
condition|(
name|ispipe
condition|)
return|return
operator|(
name|ch_fsize
operator|)
return|;
return|return
operator|(
call|(
name|off_t
call|)
argument_list|(
name|lseek
argument_list|(
name|file
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|L_XTND
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the current position in the file.  */
end_comment

begin_function
name|off_t
name|ch_tell
parameter_list|()
block|{
return|return
operator|(
name|ch_block
operator|*
name|BUFSIZ
operator|+
name|ch_offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the current char and post-increment the read pointer.  */
end_comment

begin_macro
name|ch_forw_get
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|ch_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOI
operator|&&
operator|++
name|ch_offset
operator|>=
name|BUFSIZ
condition|)
block|{
name|ch_offset
operator|=
literal|0
expr_stmt|;
operator|++
name|ch_block
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Pre-decrement the read pointer and get the new current char.  */
end_comment

begin_macro
name|ch_back_get
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|--
name|ch_offset
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ch_block
operator|<=
literal|0
operator|||
operator|(
name|ispipe
operator|&&
operator|!
name|buffered
argument_list|(
name|ch_block
operator|-
literal|1
argument_list|)
operator|)
condition|)
block|{
name|ch_offset
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EOI
operator|)
return|;
block|}
name|ch_offset
operator|=
name|BUFSIZ
operator|-
literal|1
expr_stmt|;
name|ch_block
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|ch_get
argument_list|()
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Allocate buffers.  * Caller wants us to have a total of at least want_nbufs buffers.  * keep==1 means keep the data in the current buffers;  * otherwise discard the old data.  */
end_comment

begin_macro
name|ch_init
argument_list|(
argument|want_nbufs
argument_list|,
argument|keep
argument_list|)
end_macro

begin_decl_stmt
name|int
name|want_nbufs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|keep
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|char
name|message
index|[
literal|80
index|]
decl_stmt|;
name|cbufs
operator|=
name|nbufs
expr_stmt|;
if|if
condition|(
name|nbufs
operator|<
name|want_nbufs
operator|&&
name|ch_addbuf
argument_list|(
name|want_nbufs
operator|-
name|nbufs
argument_list|)
condition|)
block|{
comment|/* 		 * Cannot allocate enough buffers. 		 * If we don't have ANY, then quit. 		 * Otherwise, just report the error and return. 		 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"cannot allocate %d buffers"
argument_list|,
name|want_nbufs
operator|-
name|nbufs
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbufs
operator|==
literal|0
condition|)
name|quit
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|keep
condition|)
return|return;
comment|/* 	 * We don't want to keep the old data, 	 * so initialize all the buffers now. 	 */
for|for
control|(
name|bp
operator|=
name|buf_head
init|;
name|bp
operator|!=
name|END_OF_CHAIN
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
name|bp
operator|->
name|block
operator|=
call|(
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|last_piped_pos
operator|=
operator|(
name|off_t
operator|)
literal|0
expr_stmt|;
name|ch_fsize
operator|=
name|NULL_POSITION
expr_stmt|;
operator|(
name|void
operator|)
name|ch_seek
argument_list|(
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Allocate some new buffers.  * The buffers are added to the tail of the buffer chain.  */
end_comment

begin_expr_stmt
specifier|static
name|ch_addbuf
argument_list|(
argument|nnew
argument_list|)
name|int
name|nnew
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|newbufs
decl_stmt|;
name|char
modifier|*
name|calloc
parameter_list|()
function_decl|;
comment|/* 	 * We don't have enough buffers.   	 * Allocate some new ones. 	 */
name|newbufs
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|u_int
operator|)
name|nnew
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbufs
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Initialize the new buffers and link them together. 	 * Link them all onto the tail of the buffer list. 	 */
name|nbufs
operator|+=
name|nnew
expr_stmt|;
name|cbufs
operator|=
name|nbufs
expr_stmt|;
for|for
control|(
name|bp
operator|=
operator|&
name|newbufs
index|[
literal|0
index|]
init|;
name|bp
operator|<
operator|&
name|newbufs
index|[
name|nnew
index|]
condition|;
name|bp
operator|++
control|)
block|{
name|bp
operator|->
name|next
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
name|bp
operator|->
name|prev
operator|=
name|bp
operator|-
literal|1
expr_stmt|;
name|bp
operator|->
name|block
operator|=
call|(
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|newbufs
index|[
name|nnew
operator|-
literal|1
index|]
operator|.
name|next
operator|=
name|END_OF_CHAIN
expr_stmt|;
name|newbufs
index|[
literal|0
index|]
operator|.
name|prev
operator|=
name|buf_tail
expr_stmt|;
name|buf_tail
operator|->
name|next
operator|=
operator|&
name|newbufs
index|[
literal|0
index|]
expr_stmt|;
name|buf_tail
operator|=
operator|&
name|newbufs
index|[
name|nnew
operator|-
literal|1
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

