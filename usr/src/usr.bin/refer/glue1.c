begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)glue1.c	4.4 (Berkeley) 9/28/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|unopen
parameter_list|(
name|fil
parameter_list|)
value|{if (fil!=NULL) {fclose(fil); fil=NULL;}}
end_define

begin_decl_stmt
specifier|extern
name|char
name|refdir
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lmaster
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|reached
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|hfreq
decl_stmt|,
name|hfrflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|colevel
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
modifier|*
name|master
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|iflong
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|fgnames
index|[]
decl_stmt|,
modifier|*
modifier|*
name|fgnamp
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|iopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|todir
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|prfreqs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|typeindex
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|usedir
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|full
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sinput
decl_stmt|,
modifier|*
name|soutput
decl_stmt|,
modifier|*
name|tagout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|indexdate
init|=
literal|0
decl_stmt|,
name|gdate
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|soutlen
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|taglen
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_macro
name|huntmain
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* read query from stdin, expect name of indexes in argv[1] */
specifier|static
name|FILE
modifier|*
name|fa
decl_stmt|,
modifier|*
name|fb
decl_stmt|,
modifier|*
name|fc
decl_stmt|;
name|char
name|indexname
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|qitem
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|rprog
init|=
literal|0
decl_stmt|;
name|char
name|grepquery
index|[
literal|200
index|]
decl_stmt|;
specifier|static
name|char
name|oldname
index|[
literal|30
index|]
decl_stmt|;
specifier|static
name|int
name|nhash
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|maxhash
init|=
literal|0
decl_stmt|;
name|int
name|falseflg
init|=
literal|0
decl_stmt|,
name|nitem
decl_stmt|,
name|nfound
decl_stmt|,
name|frtbl
decl_stmt|;
specifier|static
name|long
modifier|*
name|hpt
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"in glue1 argc %d argv %o %o\n"
argument_list|,
name|argc
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|savedir
argument_list|()
expr_stmt|;
while|while
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"argv.1 is %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* all output, incl. false drops */
name|falseflg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|rprog
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* put out full text */
name|full
operator|=
name|setfrom
argument_list|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* put out tags */
name|tags
operator|=
name|setfrom
argument_list|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* input in argument string */
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|sinput
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/*text output to string */
case|case
literal|'o'
case|:
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|soutput
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|argv
index|[
literal|2
index|]
operator|<
literal|16000
condition|)
block|{
name|soutlen
operator|=
operator|(
name|int
operator|)
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
comment|/*tag output to string */
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|tagout
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|argv
index|[
literal|2
index|]
operator|<
literal|16000
condition|)
block|{
name|taglen
operator|=
operator|(
name|int
operator|)
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
comment|/* specify length of lists */
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|lmaster
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"lmaster now %d\n"
argument_list|,
name|lmaster
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'C'
case|:
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|colevel
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|indexname
argument_list|,
name|todir
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"in huntmain indexname %s typeindex %d\n"
argument_list|,
name|indexname
argument_list|,
name|typeindex
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|typeindex
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|oldname
argument_list|,
name|indexname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|oldname
argument_list|,
name|indexname
argument_list|)
expr_stmt|;
name|unopen
argument_list|(
name|fa
argument_list|)
expr_stmt|;
name|unopen
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|unopen
argument_list|(
name|fc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckexist
argument_list|(
name|indexname
argument_list|,
literal|".ib"
argument_list|)
condition|)
block|{
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"found old index\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fa
operator|=
name|iopen
argument_list|(
name|indexname
argument_list|,
literal|".ia"
argument_list|)
expr_stmt|;
name|fb
operator|=
name|iopen
argument_list|(
name|indexname
argument_list|,
literal|".ib"
argument_list|)
expr_stmt|;
name|fc
operator|=
name|iopen
argument_list|(
name|indexname
argument_list|,
literal|".ic"
argument_list|)
expr_stmt|;
name|typeindex
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"opened f's as %o %o %o\n"
argument_list|,
name|fa
argument_list|,
name|fb
argument_list|,
name|fc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|indexdate
operator|=
name|gdate
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|nhash
argument_list|,
sizeof|sizeof
argument_list|(
name|nhash
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fa
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|iflong
argument_list|,
sizeof|sizeof
argument_list|(
name|iflong
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fa
argument_list|)
expr_stmt|;
if|if
condition|(
name|nhash
operator|>
name|maxhash
condition|)
block|{
if|if
condition|(
name|hpt
condition|)
name|free
argument_list|(
name|hpt
argument_list|,
name|maxhash
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hpt
argument_list|)
argument_list|)
expr_stmt|;
name|hpt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hfreq
condition|)
name|free
argument_list|(
name|hfreq
argument_list|,
name|maxhash
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hfreq
argument_list|)
argument_list|)
expr_stmt|;
name|hfreq
operator|=
literal|0
expr_stmt|;
name|maxhash
operator|=
name|nhash
expr_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Freed if needed maxhash %d\n"
argument_list|,
name|maxhash
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|hpt
operator|==
literal|0
condition|)
name|hpt
operator|=
operator|(
name|long
operator|*
operator|)
name|zalloc
argument_list|(
name|nhash
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hpt
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hpt now %o\n"
argument_list|,
name|hpt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hpt
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|"No space for hash list (%d)"
argument_list|,
name|nhash
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|hpt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hpt
argument_list|)
argument_list|,
name|nhash
argument_list|,
name|fa
argument_list|)
expr_stmt|;
if|if
condition|(
name|hfreq
operator|==
literal|0
condition|)
name|hfreq
operator|=
operator|(
name|int
operator|*
operator|)
name|zalloc
argument_list|(
name|nhash
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hfreq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hfreq
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|"No space for hash frequencies (%d)"
argument_list|,
name|nhash
argument_list|)
expr_stmt|;
name|frtbl
operator|=
name|fread
argument_list|(
name|hfreq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hfreq
argument_list|)
argument_list|,
name|nhash
argument_list|,
name|fa
argument_list|)
expr_stmt|;
name|hfrflg
operator|=
operator|(
name|frtbl
operator|==
name|nhash
operator|)
expr_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Read pointer files\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|master
operator|==
literal|0
condition|)
name|master
operator|=
operator|(
name|unsigned
operator|*
operator|)
name|zalloc
argument_list|(
name|lmaster
argument_list|,
name|iflong
condition|?
sizeof|sizeof
argument_list|(
name|long
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|master
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|"no space for answer list"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|makefgrep
argument_list|(
name|indexname
argument_list|)
condition|)
name|typeindex
operator|=
literal|2
expr_stmt|;
else|else
block|{
name|err
argument_list|(
literal|"No files %s\n"
argument_list|,
name|indexname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"typeindex now %d\n"
argument_list|,
name|typeindex
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tagout
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|typeindex
operator|==
literal|2
condition|)
block|{
name|grepcall
argument_list|(
name|sinput
argument_list|,
name|tagout
argument_list|,
name|indexname
argument_list|)
expr_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" back from grepcall\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|restodir
argument_list|()
expr_stmt|;
return|return;
block|}
name|nitem
operator|=
name|getq
argument_list|(
name|qitem
argument_list|)
expr_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"approaching doquery fb %o\n"
argument_list|,
name|fb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nfound
operator|=
name|doquery
argument_list|(
name|hpt
argument_list|,
name|nhash
argument_list|,
name|fb
argument_list|,
name|nitem
argument_list|,
name|qitem
argument_list|,
name|master
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"return from doquery with nfound %d\n"
argument_list|,
name|nfound
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|falseflg
operator|==
literal|0
condition|)
name|nfound
operator|=
name|baddrop
argument_list|(
name|master
argument_list|,
name|nfound
argument_list|,
name|fc
argument_list|,
name|nitem
argument_list|,
name|qitem
argument_list|,
name|rprog
argument_list|,
name|full
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"after baddrop with nfound %d\n"
argument_list|,
name|nfound
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tagout is /%s/, sout /%s/\n"
argument_list|,
name|tagout
argument_list|,
name|soutput
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tags
condition|)
name|result
argument_list|(
name|master
argument_list|,
name|nfound
operator|>
name|tags
condition|?
name|tags
else|:
name|nfound
argument_list|,
name|fc
argument_list|)
expr_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done with huntmain\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tagout is /%s/\n"
argument_list|,
name|tagout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"string out is /%s/\n"
argument_list|,
name|soutput
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fgnamp
operator|>
name|fgnames
condition|)
block|{
name|char
modifier|*
modifier|*
name|fgp
decl_stmt|;
name|int
name|k
decl_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"were %d bad files\n"
argument_list|,
name|fgnamp
operator|-
name|fgnames
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|grepquery
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nitem
condition|;
name|k
operator|++
control|)
block|{
name|strcat
argument_list|(
name|grepquery
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|grepquery
argument_list|,
name|qitem
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|fgp
operator|=
name|fgnames
init|;
name|fgp
operator|<
name|fgnamp
condition|;
name|fgp
operator|++
control|)
block|{
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Now on %s query /%s/\n"
argument_list|,
operator|*
name|fgp
argument_list|,
name|grepquery
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|makefgrep
argument_list|(
operator|*
name|fgp
argument_list|)
expr_stmt|;
name|grepcall
argument_list|(
name|grepquery
argument_list|,
name|tagout
argument_list|,
operator|*
name|fgp
argument_list|)
expr_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tagout now /%s/\n"
argument_list|,
name|tagout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|restodir
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|todir
parameter_list|(
name|t
parameter_list|)
name|char
modifier|*
name|t
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|usedir
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|s
operator|>=
name|t
operator|&&
operator|*
name|s
operator|!=
literal|'/'
condition|)
name|s
operator|--
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|t
condition|)
return|return
operator|(
name|t
operator|)
return|;
operator|*
name|s
operator|++
operator|=
literal|0
expr_stmt|;
name|t
operator|=
operator|(
operator|*
name|t
condition|?
name|t
else|:
literal|"/"
operator|)
expr_stmt|;
name|chdir
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|usedir
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_macro
name|setfrom
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'y'
case|:
case|case
literal|'\0'
case|:
default|default:
return|return
operator|(
literal|1000
operator|)
return|;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
return|return
operator|(
name|c
operator|-
literal|'0'
operator|)
return|;
case|case
literal|'n'
case|:
case|case
literal|'0'
case|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

end_unit

