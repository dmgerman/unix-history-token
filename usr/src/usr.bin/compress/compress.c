begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)compress.c	5.8 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*   * Compress - data compression program   */
end_comment

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a>b) ? b : a)
end_define

begin_comment
comment|/*  * machine variants which require cc -Dmachine:  pdp11, z8000, pcxt  */
end_comment

begin_comment
comment|/*  * Set USERMEM to the maximum amount of physical user memory available  * in bytes.  USERMEM is used to determine the maximum BITS that can be used  * for compression.  *  * SACREDMEM is the amount of physical memory saved for others; compress  * will hog the rest.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SACREDMEM
end_ifndef

begin_define
define|#
directive|define
name|SACREDMEM
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USERMEM
end_ifndef

begin_define
define|#
directive|define
name|USERMEM
value|450000
end_define

begin_comment
comment|/* default user memory */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|interdata
end_ifdef

begin_comment
comment|/* (Perkin-Elmer) */
end_comment

begin_define
define|#
directive|define
name|SIGNED_COMPARE_SLOW
end_define

begin_comment
comment|/* signed compare is slower than unsigned */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|pdp11
end_ifdef

begin_define
define|#
directive|define
name|BITS
value|12
end_define

begin_comment
comment|/* max bits/code for 16-bit machine */
end_comment

begin_define
define|#
directive|define
name|NO_UCHAR
end_define

begin_comment
comment|/* also if "unsigned char" functions as signed char */
end_comment

begin_undef
undef|#
directive|undef
name|USERMEM
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* pdp11 */
end_comment

begin_comment
comment|/* don't forget to compile with -i */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|z8000
end_ifdef

begin_define
define|#
directive|define
name|BITS
value|12
end_define

begin_undef
undef|#
directive|undef
name|vax
end_undef

begin_comment
comment|/* weird preprocessor */
end_comment

begin_undef
undef|#
directive|undef
name|USERMEM
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* z8000 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|pcxt
end_ifdef

begin_define
define|#
directive|define
name|BITS
value|12
end_define

begin_undef
undef|#
directive|undef
name|USERMEM
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* pcxt */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USERMEM
end_ifdef

begin_if
if|#
directive|if
name|USERMEM
operator|>=
operator|(
literal|433484
operator|+
name|SACREDMEM
operator|)
end_if

begin_define
define|#
directive|define
name|PBITS
value|16
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|USERMEM
operator|>=
operator|(
literal|229600
operator|+
name|SACREDMEM
operator|)
end_if

begin_define
define|#
directive|define
name|PBITS
value|15
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|USERMEM
operator|>=
operator|(
literal|127536
operator|+
name|SACREDMEM
operator|)
end_if

begin_define
define|#
directive|define
name|PBITS
value|14
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|USERMEM
operator|>=
operator|(
literal|73464
operator|+
name|SACREDMEM
operator|)
end_if

begin_define
define|#
directive|define
name|PBITS
value|13
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PBITS
value|12
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|USERMEM
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USERMEM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PBITS
end_ifdef

begin_comment
comment|/* Preferred BITS for this memory size */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BITS
end_ifndef

begin_define
define|#
directive|define
name|BITS
value|PBITS
end_define

begin_endif
endif|#
directive|endif
endif|BITS
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PBITS */
end_comment

begin_if
if|#
directive|if
name|BITS
operator|==
literal|16
end_if

begin_define
define|#
directive|define
name|HSIZE
value|69001
end_define

begin_comment
comment|/* 95% occupancy */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|BITS
operator|==
literal|15
end_if

begin_define
define|#
directive|define
name|HSIZE
value|35023
end_define

begin_comment
comment|/* 94% occupancy */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|BITS
operator|==
literal|14
end_if

begin_define
define|#
directive|define
name|HSIZE
value|18013
end_define

begin_comment
comment|/* 91% occupancy */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|BITS
operator|==
literal|13
end_if

begin_define
define|#
directive|define
name|HSIZE
value|9001
end_define

begin_comment
comment|/* 91% occupancy */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|BITS
operator|<=
literal|12
end_if

begin_define
define|#
directive|define
name|HSIZE
value|5003
end_define

begin_comment
comment|/* 80% occupancy */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|M_XENIX
end_ifdef

begin_comment
comment|/* Stupid compiler can't handle arrays with */
end_comment

begin_if
if|#
directive|if
name|BITS
operator|==
literal|16
end_if

begin_comment
comment|/* more than 65535 bytes - so we fake it */
end_comment

begin_define
define|#
directive|define
name|XENIX_16
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|BITS
operator|>
literal|13
end_if

begin_comment
comment|/* Code only handles BITS = 12, 13, or 16 */
end_comment

begin_define
define|#
directive|define
name|BITS
value|13
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * a code_int must be able to hold 2**BITS values of type int, and also -1  */
end_comment

begin_if
if|#
directive|if
name|BITS
operator|>
literal|15
end_if

begin_typedef
typedef|typedef
name|long
name|int
name|code_int
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|int
name|code_int
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SIGNED_COMPARE_SLOW
end_ifdef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|int
name|count_int
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|short
name|int
name|count_short
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|long
name|int
name|count_int
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_UCHAR
end_ifdef

begin_typedef
typedef|typedef
name|char
name|char_type
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|unsigned
name|char
name|char_type
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UCHAR */
end_comment

begin_decl_stmt
name|char_type
name|magic_header
index|[]
init|=
block|{
literal|"\037\235"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1F 9D */
end_comment

begin_comment
comment|/* Defines for third byte of header */
end_comment

begin_define
define|#
directive|define
name|BIT_MASK
value|0x1f
end_define

begin_define
define|#
directive|define
name|BLOCK_MASK
value|0x80
end_define

begin_comment
comment|/* Masks 0x40 and 0x20 are free.  I think 0x20 should mean that there is    a fourth header byte (for expansion). */
end_comment

begin_define
define|#
directive|define
name|INIT_BITS
value|9
end_define

begin_comment
comment|/* initial number of bits/code */
end_comment

begin_comment
comment|/*  * compress.c - File compression ala IEEE Computer, June 1984.  *  * Authors:	Spencer W. Thomas	(decvax!harpo!utah-cs!utah-gr!thomas)  *		Jim McKie		(decvax!mcvax!jim)  *		Steve Davies		(decvax!vax135!petsd!peora!srd)  *		Ken Turkowski		(decvax!decwrl!turtlevax!ken)  *		James A. Woods		(decvax!ihnp4!ames!jaw)  *		Joe Orost		(decvax!vax135!petsd!joe)  *  * $Header: compress.c,v 4.0 85/07/30 12:50:00 joe Release $  * $Log:	compress.c,v $  * Revision 4.0  85/07/30  12:50:00  joe  * Removed ferror() calls in output routine on every output except first.  * Prepared for release to the world.  *   * Revision 3.6  85/07/04  01:22:21  joe  * Remove much wasted storage by overlaying hash table with the tables  * used by decompress: tab_suffix[1<<BITS], stack[8000].  Updated USERMEM  * computations.  Fixed dump_tab() DEBUG routine.  *  * Revision 3.5  85/06/30  20:47:21  jaw  * Change hash function to use exclusive-or.  Rip out hash cache.  These  * speedups render the megamemory version defunct, for now.  Make decoder  * stack global.  Parts of the RCS trunks 2.7, 2.6, and 2.1 no longer apply.  *  * Revision 3.4  85/06/27  12:00:00  ken  * Get rid of all floating-point calculations by doing all compression ratio  * calculations in fixed point.  *  * Revision 3.3  85/06/24  21:53:24  joe  * Incorporate portability suggestion for M_XENIX.  Got rid of text on #else  * and #endif lines.  Cleaned up #ifdefs for vax and interdata.  *  * Revision 3.2  85/06/06  21:53:24  jaw  * Incorporate portability suggestions for Z8000, IBM PC/XT from mailing list.  * Default to "quiet" output (no compression statistics).  *  * Revision 3.1  85/05/12  18:56:13  jaw  * Integrate decompress() stack speedups (from early pointer mods by McKie).  * Repair multi-file USERMEM gaffe.  Unify 'force' flags to mimic semantics  * of SVR2 'pack'.  Streamline block-compress table clear logic.  Increase   * output byte count by magic number size.  *   * Revision 3.0   84/11/27  11:50:00  petsd!joe  * Set HSIZE depending on BITS.  Set BITS depending on USERMEM.  Unrolled  * loops in clear routines.  Added "-C" flag for 2.0 compatibility.  Used  * unsigned compares on Perkin-Elmer.  Fixed foreground check.  *  * Revision 2.7   84/11/16  19:35:39  ames!jaw  * Cache common hash codes based on input statistics; this improves  * performance for low-density raster images.  Pass on #ifdef bundle  * from Turkowski.  *  * Revision 2.6   84/11/05  19:18:21  ames!jaw  * Vary size of hash tables to reduce time for small files.  * Tune PDP-11 hash function.  *  * Revision 2.5   84/10/30  20:15:14  ames!jaw  * Junk chaining; replace with the simpler (and, on the VAX, faster)  * double hashing, discussed within.  Make block compression standard.  *  * Revision 2.4   84/10/16  11:11:11  ames!jaw  * Introduce adaptive reset for block compression, to boost the rate  * another several percent.  (See mailing list notes.)  *  * Revision 2.3   84/09/22  22:00:00  petsd!joe  * Implemented "-B" block compress.  Implemented REVERSE sorting of tab_next.  * Bug fix for last bits.  Changed fwrite to putchar loop everywhere.  *  * Revision 2.2   84/09/18  14:12:21  ames!jaw  * Fold in news changes, small machine typedef from thomas,  * #ifdef interdata from joe.  *  * Revision 2.1   84/09/10  12:34:56  ames!jaw  * Configured fast table lookup for 32-bit machines.  * This cuts user time in half for b<= FBITS, and is useful for news batching  * from VAX to PDP sites.  Also sped up decompress() [fwrite->putc] and  * added signal catcher [plus beef in writeerr()] to delete effluvia.  *  * Revision 2.0   84/08/28  22:00:00  petsd!joe  * Add check for foreground before prompting user.  Insert maxbits into  * compressed file.  Force file being uncompressed to end with ".Z".  * Added "-c" flag and "zcat".  Prepared for release.  *  * Revision 1.10  84/08/24  18:28:00  turtlevax!ken  * Will only compress regular files (no directories), added a magic number  * header (plus an undocumented -n flag to handle old files without headers),  * added -f flag to force overwriting of possibly existing destination file,  * otherwise the user is prompted for a response.  Will tack on a .Z to a  * filename if it doesn't have one when decompressing.  Will only replace  * file if it was compressed.  *  * Revision 1.9  84/08/16  17:28:00  turtlevax!ken  * Removed scanargs(), getopt(), added .Z extension and unlimited number of  * filenames to compress.  Flags may be clustered (-Ddvb12) or separated  * (-D -d -v -b 12), or combination thereof.  Modes and other status is  * copied with copystat().  -O bug for 4.2 seems to have disappeared with  * 1.8.  *  * Revision 1.8  84/08/09  23:15:00  joe  * Made it compatible with vax version, installed jim's fixes/enhancements  *  * Revision 1.6  84/08/01  22:08:00  joe  * Sped up algorithm significantly by sorting the compress chain.  *  * Revision 1.5  84/07/13  13:11:00  srd  * Added C version of vax asm routines.  Changed structure to arrays to  * save much memory.  Do unsigned compares where possible (faster on  * Perkin-Elmer)  *  * Revision 1.4  84/07/05  03:11:11  thomas  * Clean up the code a little and lint it.  (Lint complains about all  * the regs used in the asm, but I'm not going to "fix" this.)  *  * Revision 1.3  84/07/05  02:06:54  thomas  * Minor fixes.  *  * Revision 1.2  84/07/05  00:27:27  thomas  * Add variable bit length output.  *  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcs_ident
index|[]
init|=
literal|"$Header: compress.c,v 4.0 85/07/30 12:50:00 joe Release $"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_define
define|#
directive|define
name|ARGVAL
parameter_list|()
value|(*++(*argv) || (--argc&& *++argv))
end_define

begin_decl_stmt
name|int
name|n_bits
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bits/code */
end_comment

begin_decl_stmt
name|int
name|maxbits
init|=
name|BITS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user settable max # bits/code */
end_comment

begin_decl_stmt
name|code_int
name|maxcode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum code, given n_bits */
end_comment

begin_decl_stmt
name|code_int
name|maxmaxcode
init|=
literal|1
operator|<<
name|BITS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* should NEVER generate this code */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMPATIBLE
end_ifdef

begin_comment
comment|/* But wrong! */
end_comment

begin_define
define|#
directive|define
name|MAXCODE
parameter_list|(
name|n_bits
parameter_list|)
value|(1<< (n_bits) - 1)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAXCODE
parameter_list|(
name|n_bits
parameter_list|)
value|((1<< (n_bits)) - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPATIBLE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XENIX_16
end_ifdef

begin_decl_stmt
name|count_int
name|htab0
index|[
literal|8192
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|count_int
name|htab1
index|[
literal|8192
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|count_int
name|htab2
index|[
literal|8192
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|count_int
name|htab3
index|[
literal|8192
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|count_int
name|htab4
index|[
literal|8192
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|count_int
name|htab5
index|[
literal|8192
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|count_int
name|htab6
index|[
literal|8192
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|count_int
name|htab7
index|[
literal|8192
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|count_int
name|htab8
index|[
name|HSIZE
operator|-
literal|65536
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|count_int
modifier|*
name|htab
index|[
literal|9
index|]
init|=
block|{
name|htab0
block|,
name|htab1
block|,
name|htab2
block|,
name|htab3
block|,
name|htab4
block|,
name|htab5
block|,
name|htab6
block|,
name|htab7
block|,
name|htab8
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|htabof
parameter_list|(
name|i
parameter_list|)
value|(htab[(i)>> 13][(i)& 0x1fff])
end_define

begin_decl_stmt
name|unsigned
name|short
name|code0tab
index|[
literal|16384
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|code1tab
index|[
literal|16384
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|code2tab
index|[
literal|16384
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|code3tab
index|[
literal|16384
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|code4tab
index|[
literal|16384
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
modifier|*
name|codetab
index|[
literal|5
index|]
init|=
block|{
name|code0tab
block|,
name|code1tab
block|,
name|code2tab
block|,
name|code3tab
block|,
name|code4tab
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|codetabof
parameter_list|(
name|i
parameter_list|)
value|(codetab[(i)>> 14][(i)& 0x3fff])
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Normal machine */
end_comment

begin_decl_stmt
name|count_int
name|htab
index|[
name|HSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|codetab
index|[
name|HSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|htabof
parameter_list|(
name|i
parameter_list|)
value|htab[i]
end_define

begin_define
define|#
directive|define
name|codetabof
parameter_list|(
name|i
parameter_list|)
value|codetab[i]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XENIX_16 */
end_comment

begin_decl_stmt
name|code_int
name|hsize
init|=
name|HSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for dynamic table sizing */
end_comment

begin_decl_stmt
name|count_int
name|fsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * To save much memory, we overlay the table used by compress() with those  * used by decompress().  The tab_prefix table is the same size and type  * as the codetab.  The tab_suffix table needs 2**BITS characters.  We  * get this from the beginning of htab.  The output stack uses the rest  * of htab, and contains characters.  There is plenty of room for any  * possible stack (stack used to be 8000 characters).  */
end_comment

begin_define
define|#
directive|define
name|tab_prefixof
parameter_list|(
name|i
parameter_list|)
value|codetabof(i)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|XENIX_16
end_ifdef

begin_define
define|#
directive|define
name|tab_suffixof
parameter_list|(
name|i
parameter_list|)
value|((char_type *)htab[(i)>>15])[(i)& 0x7fff]
end_define

begin_define
define|#
directive|define
name|de_stack
value|((char_type *)(htab2))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Normal machine */
end_comment

begin_define
define|#
directive|define
name|tab_suffixof
parameter_list|(
name|i
parameter_list|)
value|((char_type *)(htab))[i]
end_define

begin_define
define|#
directive|define
name|de_stack
value|((char_type *)&tab_suffixof(1<<BITS))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XENIX_16 */
end_comment

begin_decl_stmt
name|code_int
name|free_ent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first unused entry */
end_comment

begin_decl_stmt
name|int
name|exit_stat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|code_int
name|getcode
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|Usage
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: compress [-dDVfc] [-b maxbits] [file ...]\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: compress [-fvc] [-b maxbits] [file ...]\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_expr_stmt
unit|int
name|nomagic
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Use a 3-byte magic number header, unless old file */
end_comment

begin_decl_stmt
name|int
name|zcat_flg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Write output on stdout, suppress messages */
end_comment

begin_decl_stmt
name|int
name|precious
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't unlink output file on interrupt */
end_comment

begin_decl_stmt
name|int
name|quiet
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't tell me about compression */
end_comment

begin_comment
comment|/*  * block compression parameters -- after all codes are used up,  * and compression rate changes, start over.  */
end_comment

begin_decl_stmt
name|int
name|block_compress
init|=
name|BLOCK_MASK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|clear_flg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|int
name|ratio
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CHECK_GAP
value|10000
end_define

begin_comment
comment|/* ratio check interval */
end_comment

begin_decl_stmt
name|count_int
name|checkpoint
init|=
name|CHECK_GAP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * the next two codes should not be changed lightly, as they must not  * lie within the contiguous general code space.  */
end_comment

begin_define
define|#
directive|define
name|FIRST
value|257
end_define

begin_comment
comment|/* first free entry */
end_comment

begin_define
define|#
directive|define
name|CLEAR
value|256
end_define

begin_comment
comment|/* table clear output code */
end_comment

begin_decl_stmt
name|int
name|force
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ofname
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|bgnd_flag
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|do_decomp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************************************************************  * TAG( main )  *  * Algorithm from "A Technique for High Performance Data Compression",  * Terry A. Welch, IEEE Computer Vol 17, No 6 (June 1984), pp 8-19.  *  * Usage: compress [-dfvc] [-b bits] [file ...]  * Inputs:  *	-d:	    If given, decompression is done instead.  *  *      -c:         Write output on stdout, don't remove original.  *  *      -b:         Parameter limits the max number of bits/code.  *  *	-f:	    Forces output file to be generated, even if one already  *		    exists, and even if no space is saved by compressing.  *		    If -f is not used, the user will be prompted if stdin is  *		    a tty, otherwise, the output file will not be overwritten.  *  *      -v:	    Write compression statistics  *  * 	file ...:   Files to be compressed.  If none specified, stdin  *		    is used.  * Outputs:  *	file.Z:	    Compressed form of file with same mode, owner, and utimes  * 	or stdout   (if stdin used as input)  *  * Assumptions:  *	When filenames are given, replaces with the compressed version  *	(.Z suffix) only if the file decreases in size.  * Algorithm:  * 	Modified Lempel-Ziv method (LZW).  Basically finds common  * substrings and replaces them with a variable size code.  This is  * deterministic, and can be done on the fly.  Thus, the decompression  * procedure needs no input table, but tracks the way the table was built.  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
specifier|register
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|overwrite
init|=
literal|0
decl_stmt|;
comment|/* Do not overwrite unless given -f flag */
name|char
name|tempname
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|filelist
decl_stmt|,
modifier|*
modifier|*
name|fileptr
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|,
modifier|*
name|malloc
argument_list|()
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
extern|extern onintr(
block|)
operator|,
function|oops
parameter_list|()
function|;
end_function

begin_if
if|if
condition|(
operator|(
name|bgnd_flag
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|oops
argument_list|)
expr_stmt|;
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|COMPATIBLE
end_ifdef

begin_expr_stmt
name|nomagic
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Original didn't have a magic number */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPATIBLE */
end_comment

begin_expr_stmt
name|filelist
operator|=
name|fileptr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|malloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|filelist
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"uncompress"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|do_decomp
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"zcat"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|do_decomp
operator|=
literal|1
expr_stmt|;
name|zcat_flg
operator|=
literal|1
expr_stmt|;
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_2
end_ifdef

begin_comment
comment|/* 4.2BSD dependent - take it out if not */
end_comment

begin_expr_stmt
name|setlinebuf
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD4_2 */
end_comment

begin_comment
comment|/* Argument Processing      * All flags are optional.      * -D => debug      * -V => print Version; debug verbose      * -d => do_decomp      * -v => unquiet      * -f => force overwrite of output file      * -n => no header: useful to uncompress old files      * -b maxbits => maxbits.  If -b is specified, then maxbits MUST be      *	    given also.      * -c => cat all output to stdout      * -C => generate output compatible with compress 2.0.      * if a string is left, must be an input filename.      */
end_comment

begin_for
for|for
control|(
name|argc
operator|--
operator|,
name|argv
operator|++
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
comment|/* A flag argument */
while|while
condition|(
operator|*
operator|++
operator|(
operator|*
name|argv
operator|)
condition|)
block|{
comment|/* Process all flags in this arg */
switch|switch
condition|(
operator|*
operator|*
name|argv
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'D'
case|:
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
name|version
argument_list|()
expr_stmt|;
break|break;
else|#
directive|else
case|case
literal|'V'
case|:
name|version
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* DEBUG */
case|case
literal|'v'
case|:
name|quiet
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|do_decomp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|overwrite
operator|=
literal|1
expr_stmt|;
name|force
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|nomagic
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|block_compress
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
operator|!
name|ARGVAL
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Missing maxbits\n"
argument_list|)
expr_stmt|;
name|Usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|maxbits
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
goto|goto
name|nextarg
goto|;
case|case
literal|'c'
case|:
name|zcat_flg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown flag: '%c'; "
argument_list|,
operator|*
operator|*
name|argv
argument_list|)
expr_stmt|;
name|Usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Input file name */
operator|*
name|fileptr
operator|++
operator|=
operator|*
name|argv
expr_stmt|;
comment|/* Build input file list */
operator|*
name|fileptr
operator|=
name|NULL
expr_stmt|;
comment|/* process nextarg; */
block|}
name|nextarg
label|:
continue|continue;
block|}
end_for

begin_if
if|if
condition|(
name|maxbits
operator|<
name|INIT_BITS
condition|)
name|maxbits
operator|=
name|INIT_BITS
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|maxbits
operator|>
name|BITS
condition|)
name|maxbits
operator|=
name|BITS
expr_stmt|;
end_if

begin_expr_stmt
name|maxmaxcode
operator|=
literal|1
operator|<<
name|maxbits
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|*
name|filelist
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|fileptr
operator|=
name|filelist
init|;
operator|*
name|fileptr
condition|;
name|fileptr
operator|++
control|)
block|{
name|exit_stat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|do_decomp
operator|!=
literal|0
condition|)
block|{
comment|/* DECOMPRESSION */
comment|/* Check for .Z suffix */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|fileptr
operator|+
name|strlen
argument_list|(
operator|*
name|fileptr
argument_list|)
operator|-
literal|2
argument_list|,
literal|".Z"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* No .Z: tack one on */
name|strcpy
argument_list|(
name|tempname
argument_list|,
operator|*
name|fileptr
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tempname
argument_list|,
literal|".Z"
argument_list|)
expr_stmt|;
operator|*
name|fileptr
operator|=
name|tempname
expr_stmt|;
block|}
comment|/* Open input file */
if|if
condition|(
operator|(
name|freopen
argument_list|(
operator|*
name|fileptr
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
operator|*
name|fileptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Check the magic number */
if|if
condition|(
name|nomagic
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|getchar
argument_list|()
operator|!=
operator|(
name|magic_header
index|[
literal|0
index|]
operator|&
literal|0xFF
operator|)
operator|)
operator|||
operator|(
name|getchar
argument_list|()
operator|!=
operator|(
name|magic_header
index|[
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: not in compressed format\n"
argument_list|,
operator|*
name|fileptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|maxbits
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* set -b from file */
name|block_compress
operator|=
name|maxbits
operator|&
name|BLOCK_MASK
expr_stmt|;
name|maxbits
operator|&=
name|BIT_MASK
expr_stmt|;
name|maxmaxcode
operator|=
literal|1
operator|<<
name|maxbits
expr_stmt|;
if|if
condition|(
name|maxbits
operator|>
name|BITS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: compressed with %d bits, can only handle %d bits\n"
argument_list|,
operator|*
name|fileptr
argument_list|,
name|maxbits
argument_list|,
name|BITS
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Generate output filename */
name|strcpy
argument_list|(
name|ofname
argument_list|,
operator|*
name|fileptr
argument_list|)
expr_stmt|;
name|ofname
index|[
name|strlen
argument_list|(
operator|*
name|fileptr
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Strip off .Z */
block|}
else|else
block|{
comment|/* COMPRESSION */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|fileptr
operator|+
name|strlen
argument_list|(
operator|*
name|fileptr
argument_list|)
operator|-
literal|2
argument_list|,
literal|".Z"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: already has .Z suffix -- no change\n"
argument_list|,
operator|*
name|fileptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Open input file */
if|if
condition|(
operator|(
name|freopen
argument_list|(
operator|*
name|fileptr
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
operator|*
name|fileptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|stat
argument_list|(
operator|*
name|fileptr
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
name|fsize
operator|=
operator|(
name|long
operator|)
name|statbuf
operator|.
name|st_size
expr_stmt|;
comment|/* 		 * tune hash table size for small files -- ad hoc, 		 * but the sizes match earlier #defines, which 		 * serve as upper bounds on the number of output codes.  		 */
name|hsize
operator|=
name|HSIZE
expr_stmt|;
if|if
condition|(
name|fsize
operator|<
operator|(
literal|1
operator|<<
literal|12
operator|)
condition|)
name|hsize
operator|=
name|min
argument_list|(
literal|5003
argument_list|,
name|HSIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fsize
operator|<
operator|(
literal|1
operator|<<
literal|13
operator|)
condition|)
name|hsize
operator|=
name|min
argument_list|(
literal|9001
argument_list|,
name|HSIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fsize
operator|<
operator|(
literal|1
operator|<<
literal|14
operator|)
condition|)
name|hsize
operator|=
name|min
argument_list|(
literal|18013
argument_list|,
name|HSIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fsize
operator|<
operator|(
literal|1
operator|<<
literal|15
operator|)
condition|)
name|hsize
operator|=
name|min
argument_list|(
literal|35023
argument_list|,
name|HSIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fsize
operator|<
literal|47000
condition|)
name|hsize
operator|=
name|min
argument_list|(
literal|50021
argument_list|,
name|HSIZE
argument_list|)
expr_stmt|;
comment|/* Generate output filename */
name|strcpy
argument_list|(
name|ofname
argument_list|,
operator|*
name|fileptr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|BSD4_2
comment|/* Short filenames */
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|ofname
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cp
operator|++
expr_stmt|;
else|else
name|cp
operator|=
name|ofname
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|>
literal|12
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: filename too long to tack on .Z\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* BSD4_2		Long filenames allowed */
name|strcat
argument_list|(
name|ofname
argument_list|,
literal|".Z"
argument_list|)
expr_stmt|;
block|}
comment|/* Check for overwrite of existing file */
if|if
condition|(
name|overwrite
operator|==
literal|0
operator|&&
name|zcat_flg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|ofname
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|response
index|[
literal|2
index|]
decl_stmt|;
name|response
index|[
literal|0
index|]
operator|=
literal|'n'
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s already exists;"
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
if|if
condition|(
name|foreground
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" do you wish to overwrite %s (y or n)? "
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|read
argument_list|(
literal|2
argument_list|,
name|response
argument_list|,
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|response
index|[
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
literal|2
argument_list|,
name|response
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Ack! */
name|perror
argument_list|(
literal|"stderr"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|response
index|[
literal|0
index|]
operator|!=
literal|'y'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tnot overwritten\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
if|if
condition|(
name|zcat_flg
operator|==
literal|0
condition|)
block|{
comment|/* Open output file */
if|if
condition|(
name|freopen
argument_list|(
name|ofname
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|precious
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
operator|*
name|fileptr
argument_list|)
expr_stmt|;
block|}
comment|/* Actually do the compression/decompression */
if|if
condition|(
name|do_decomp
operator|==
literal|0
condition|)
name|compress
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
else|else
name|decompress
argument_list|()
expr_stmt|;
else|#
directive|else
elseif|else
if|if
condition|(
name|debug
operator|==
literal|0
condition|)
name|decompress
argument_list|()
expr_stmt|;
else|else
name|printcodes
argument_list|()
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|dump_tab
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|zcat_flg
operator|==
literal|0
condition|)
block|{
name|copystat
argument_list|(
operator|*
name|fileptr
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
comment|/* Copy stats */
name|precious
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|exit_stat
operator|==
literal|1
operator|)
operator|||
operator|(
operator|!
name|quiet
operator|)
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Standard input */
if|if
condition|(
name|do_decomp
operator|==
literal|0
condition|)
block|{
name|compress
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|verbose
condition|)
name|dump_tab
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|!
name|quiet
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check the magic number */
if|if
condition|(
name|nomagic
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|getchar
argument_list|()
operator|!=
operator|(
name|magic_header
index|[
literal|0
index|]
operator|&
literal|0xFF
operator|)
operator|)
operator|||
operator|(
name|getchar
argument_list|()
operator|!=
operator|(
name|magic_header
index|[
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"stdin: not in compressed format\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|maxbits
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* set -b from file */
name|block_compress
operator|=
name|maxbits
operator|&
name|BLOCK_MASK
expr_stmt|;
name|maxbits
operator|&=
name|BIT_MASK
expr_stmt|;
name|maxmaxcode
operator|=
literal|1
operator|<<
name|maxbits
expr_stmt|;
name|fsize
operator|=
literal|100000
expr_stmt|;
comment|/* assume stdin large for USERMEM */
if|if
condition|(
name|maxbits
operator|>
name|BITS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"stdin: compressed with %d bits, can only handle %d bits\n"
argument_list|,
name|maxbits
argument_list|,
name|BITS
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|DEBUG
name|decompress
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|debug
operator|==
literal|0
condition|)
name|decompress
argument_list|()
expr_stmt|;
else|else
name|printcodes
argument_list|()
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|dump_tab
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
block|}
end_if

begin_expr_stmt
name|exit
argument_list|(
name|exit_stat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
unit|}  static
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|int
name|in_count
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of input */
end_comment

begin_decl_stmt
name|long
name|int
name|bytes_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of compressed output */
end_comment

begin_decl_stmt
name|long
name|int
name|out_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of codes output (for debugging) */
end_comment

begin_comment
comment|/*  * compress stdin to stdout  *  * Algorithm:  use open addressing double hashing (no chaining) on the   * prefix code / next character combination.  We do a variant of Knuth's  * algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime  * secondary probe.  Here, the modular division first probe is gives way  * to a faster exclusive-or manipulation.  Also do block compression with  * an adaptive reset, whereby the code table is cleared when the compression  * ratio decreases, but after the table fills.  The variable-length output  * codes are re-sized at this point, and a special CLEAR code is generated  * for the decompressor.  Late addition:  construct the table according to  * file size for noticeable speed improvement on small files.  Please direct  * questions about this implementation to ames!jaw.  */
end_comment

begin_macro
name|compress
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|long
name|fcode
decl_stmt|;
specifier|register
name|code_int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|code_int
name|ent
decl_stmt|;
ifdef|#
directive|ifdef
name|XENIX_16
specifier|register
name|code_int
name|disp
decl_stmt|;
else|#
directive|else
comment|/* Normal machine */
specifier|register
name|int
name|disp
decl_stmt|;
endif|#
directive|endif
specifier|register
name|code_int
name|hsize_reg
decl_stmt|;
specifier|register
name|int
name|hshift
decl_stmt|;
ifndef|#
directive|ifndef
name|COMPATIBLE
if|if
condition|(
name|nomagic
operator|==
literal|0
condition|)
block|{
name|putchar
argument_list|(
name|magic_header
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|magic_header
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
call|(
name|char
call|)
argument_list|(
name|maxbits
operator||
name|block_compress
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|writeerr
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* COMPATIBLE */
name|offset
operator|=
literal|0
expr_stmt|;
name|bytes_out
operator|=
literal|3
expr_stmt|;
comment|/* includes 3-byte header mojo */
name|out_count
operator|=
literal|0
expr_stmt|;
name|clear_flg
operator|=
literal|0
expr_stmt|;
name|ratio
operator|=
literal|0
expr_stmt|;
name|in_count
operator|=
literal|1
expr_stmt|;
name|checkpoint
operator|=
name|CHECK_GAP
expr_stmt|;
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
operator|=
name|INIT_BITS
argument_list|)
expr_stmt|;
name|free_ent
operator|=
operator|(
operator|(
name|block_compress
operator|)
condition|?
name|FIRST
else|:
literal|256
operator|)
expr_stmt|;
name|ent
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|hshift
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fcode
operator|=
operator|(
name|long
operator|)
name|hsize
init|;
name|fcode
operator|<
literal|65536L
condition|;
name|fcode
operator|*=
literal|2L
control|)
name|hshift
operator|++
expr_stmt|;
name|hshift
operator|=
literal|8
operator|-
name|hshift
expr_stmt|;
comment|/* set hash code range bound */
name|hsize_reg
operator|=
name|hsize
expr_stmt|;
name|cl_hash
argument_list|(
operator|(
name|count_int
operator|)
name|hsize_reg
argument_list|)
expr_stmt|;
comment|/* clear hash table */
ifdef|#
directive|ifdef
name|SIGNED_COMPARE_SLOW
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
operator|(
name|unsigned
operator|)
name|EOF
condition|)
block|{
else|#
directive|else
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
block|{
endif|#
directive|endif
name|in_count
operator|++
expr_stmt|;
name|fcode
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|c
operator|<<
name|maxbits
operator|)
operator|+
name|ent
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
operator|(
name|c
operator|<<
name|hshift
operator|)
operator|^
name|ent
operator|)
expr_stmt|;
comment|/* xor hashing */
if|if
condition|(
name|htabof
argument_list|(
name|i
argument_list|)
operator|==
name|fcode
condition|)
block|{
name|ent
operator|=
name|codetabof
argument_list|(
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|long
operator|)
name|htabof
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
comment|/* empty slot */
goto|goto
name|nomatch
goto|;
name|disp
operator|=
name|hsize_reg
operator|-
name|i
expr_stmt|;
comment|/* secondary hash (after G. Knott) */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|disp
operator|=
literal|1
expr_stmt|;
name|probe
label|:
if|if
condition|(
operator|(
name|i
operator|-=
name|disp
operator|)
operator|<
literal|0
condition|)
name|i
operator|+=
name|hsize_reg
expr_stmt|;
if|if
condition|(
name|htabof
argument_list|(
name|i
argument_list|)
operator|==
name|fcode
condition|)
block|{
name|ent
operator|=
name|codetabof
argument_list|(
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|htabof
argument_list|(
name|i
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|probe
goto|;
name|nomatch
label|:
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
name|out_count
operator|++
expr_stmt|;
name|ent
operator|=
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGNED_COMPARE_SLOW
if|if
condition|(
operator|(
name|unsigned
operator|)
name|free_ent
operator|<
operator|(
name|unsigned
operator|)
name|maxmaxcode
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|free_ent
operator|<
name|maxmaxcode
condition|)
block|{
endif|#
directive|endif
name|codetabof
argument_list|(
name|i
argument_list|)
operator|=
name|free_ent
operator|++
expr_stmt|;
comment|/* code -> hashtable */
name|htabof
argument_list|(
name|i
argument_list|)
operator|=
name|fcode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|count_int
operator|)
name|in_count
operator|>=
name|checkpoint
operator|&&
name|block_compress
condition|)
name|cl_block
argument_list|()
expr_stmt|;
block|}
comment|/*      * Put out the final code.      */
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
name|out_count
operator|++
expr_stmt|;
name|output
argument_list|(
operator|(
name|code_int
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Print out stats on stderr      */
if|if
condition|(
name|zcat_flg
operator|==
literal|0
operator|&&
operator|!
name|quiet
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld chars in, %ld codes (%ld bytes) out, compression factor: "
argument_list|,
name|in_count
argument_list|,
name|out_count
argument_list|,
name|bytes_out
argument_list|)
expr_stmt|;
name|prratio
argument_list|(
name|stderr
argument_list|,
name|in_count
argument_list|,
name|bytes_out
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tCompression as in compact: "
argument_list|)
expr_stmt|;
name|prratio
argument_list|(
name|stderr
argument_list|,
name|in_count
operator|-
name|bytes_out
argument_list|,
name|in_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tLargest code (of last block) was %d (%d bits)\n"
argument_list|,
name|free_ent
operator|-
literal|1
argument_list|,
name|n_bits
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !DEBUG */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Compression: "
argument_list|)
expr_stmt|;
name|prratio
argument_list|(
name|stderr
argument_list|,
name|in_count
operator|-
name|bytes_out
argument_list|,
name|in_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
if|if
condition|(
name|bytes_out
operator|>
name|in_count
condition|)
comment|/* exit(2) if no savings */
name|exit_stat
operator|=
literal|2
expr_stmt|;
return|return;
block|}
comment|/*****************************************************************  * TAG( output )  *  * Output the given code.  * Inputs:  * 	code:	A n_bits-bit integer.  If == -1, then EOF.  This assumes  *		that n_bits =< (long)wordsize - 1.  * Outputs:  * 	Outputs code to the file.  * Assumptions:  *	Chars are 8 bits long.  * Algorithm:  * 	Maintain a BITS character long buffer (so that 8 codes will  * fit in it exactly).  Use the VAX insv instruction to insert each  * code in turn.  When the buffer fills up empty it and start over.  */
specifier|static
name|char
name|buf
index|[
name|BITS
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|vax
name|char_type
name|lmask
index|[
literal|9
index|]
init|=
block|{
literal|0xff
block|,
literal|0xfe
block|,
literal|0xfc
block|,
literal|0xf8
block|,
literal|0xf0
block|,
literal|0xe0
block|,
literal|0xc0
block|,
literal|0x80
block|,
literal|0x00
block|}
decl_stmt|;
name|char_type
name|rmask
index|[
literal|9
index|]
init|=
block|{
literal|0x00
block|,
literal|0x01
block|,
literal|0x03
block|,
literal|0x07
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x3f
block|,
literal|0x7f
block|,
literal|0xff
block|}
decl_stmt|;
endif|#
directive|endif
comment|/* vax */
name|output
argument_list|(
argument|code
argument_list|)
name|code_int
name|code
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
specifier|static
name|int
name|col
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*      * On the VAX, it is important to have the register declarations      * in exactly the order given, or the asm will break.      */
specifier|register
name|int
name|r_off
init|=
name|offset
decl_stmt|,
name|bits
init|=
name|n_bits
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%5d%c"
argument_list|,
name|code
argument_list|,
operator|(
name|col
operator|+=
literal|6
operator|)
operator|>=
literal|74
condition|?
operator|(
name|col
operator|=
literal|0
operator|,
literal|'\n'
operator|)
else|:
literal|' '
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|vax
comment|/* VAX DEPENDENT!! Implementation on other machines is below. 	 * 	 * Translation: Insert BITS bits from the argument starting at 	 * offset bits from the beginning of buf. 	 */
literal|0
expr_stmt|;
comment|/* Work around for pcc -O bug with asm and if stmt */
asm|asm( "insv	4(ap),r11,r10,(r9)" );
else|#
directive|else
comment|/* not a vax */
comment|/*   * byte/bit numbering on the VAX is simulated by the following code  */
comment|/* 	 * Get to the first byte. 	 */
name|bp
operator|+=
operator|(
name|r_off
operator|>>
literal|3
operator|)
expr_stmt|;
name|r_off
operator|&=
literal|7
expr_stmt|;
comment|/* 	 * Since code is always>= 8 bits, only need to mask the first 	 * hunk on the left. 	 */
operator|*
name|bp
operator|=
operator|(
operator|*
name|bp
operator|&
name|rmask
index|[
name|r_off
index|]
operator|)
operator||
operator|(
name|code
operator|<<
name|r_off
operator|)
operator|&
name|lmask
index|[
name|r_off
index|]
expr_stmt|;
name|bp
operator|++
expr_stmt|;
name|bits
operator|-=
operator|(
literal|8
operator|-
name|r_off
operator|)
expr_stmt|;
name|code
operator|>>=
literal|8
operator|-
name|r_off
expr_stmt|;
comment|/* Get any 8 bit parts in the middle (<=1 for up to 16 bits). */
if|if
condition|(
name|bits
operator|>=
literal|8
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
name|code
expr_stmt|;
name|code
operator|>>=
literal|8
expr_stmt|;
name|bits
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* Last bits. */
if|if
condition|(
name|bits
condition|)
operator|*
name|bp
operator|=
name|code
expr_stmt|;
endif|#
directive|endif
comment|/* vax */
name|offset
operator|+=
name|n_bits
expr_stmt|;
if|if
condition|(
name|offset
operator|==
operator|(
name|n_bits
operator|<<
literal|3
operator|)
condition|)
block|{
name|bp
operator|=
name|buf
expr_stmt|;
name|bits
operator|=
name|n_bits
expr_stmt|;
name|bytes_out
operator|+=
name|bits
expr_stmt|;
do|do
name|putchar
argument_list|(
operator|*
name|bp
operator|++
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|bits
condition|)
do|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If the next entry is going to be too big for the code size, 	 * then increase it, if possible. 	 */
if|if
condition|(
name|free_ent
operator|>
name|maxcode
operator|||
operator|(
name|clear_flg
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* 	     * Write the whole buffer, because the input side won't 	     * discover the size increase until after it has read it. 	     */
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|n_bits
argument_list|,
name|stdout
argument_list|)
operator|!=
name|n_bits
condition|)
name|writeerr
argument_list|()
expr_stmt|;
name|bytes_out
operator|+=
name|n_bits
expr_stmt|;
block|}
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|clear_flg
condition|)
block|{
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
operator|=
name|INIT_BITS
argument_list|)
expr_stmt|;
name|clear_flg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|n_bits
operator|++
expr_stmt|;
if|if
condition|(
name|n_bits
operator|==
name|maxbits
condition|)
name|maxcode
operator|=
name|maxmaxcode
expr_stmt|;
else|else
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChange to %d bits\n"
argument_list|,
name|n_bits
argument_list|)
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
block|}
block|}
else|else
block|{
comment|/* 	 * At EOF, write the rest of the buffer. 	 */
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
operator|(
name|offset
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|bytes_out
operator|+=
operator|(
name|offset
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|writeerr
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*  * Decompress stdin to stdout.  This routine adapts to the codes in the  * file building the "string" table on-the-fly; requiring no table to  * be stored in the compressed file.  The tables used herein are shared  * with those of the compress() routine.  See the definitions above.  */
name|decompress
argument_list|()
block|{
specifier|register
name|char_type
modifier|*
name|stackp
decl_stmt|;
specifier|register
name|int
name|finchar
decl_stmt|;
specifier|register
name|code_int
name|code
decl_stmt|,
name|oldcode
decl_stmt|,
name|incode
decl_stmt|;
comment|/*      * As above, initialize the first 256 entries in the table.      */
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
operator|=
name|INIT_BITS
argument_list|)
expr_stmt|;
for|for
control|(
name|code
operator|=
literal|255
init|;
name|code
operator|>=
literal|0
condition|;
name|code
operator|--
control|)
block|{
name|tab_prefixof
argument_list|(
name|code
argument_list|)
operator|=
literal|0
expr_stmt|;
name|tab_suffixof
argument_list|(
name|code
argument_list|)
operator|=
operator|(
name|char_type
operator|)
name|code
expr_stmt|;
block|}
name|free_ent
operator|=
operator|(
operator|(
name|block_compress
operator|)
condition|?
name|FIRST
else|:
literal|256
operator|)
expr_stmt|;
name|finchar
operator|=
name|oldcode
operator|=
name|getcode
argument_list|()
expr_stmt|;
if|if
condition|(
name|oldcode
operator|==
operator|-
literal|1
condition|)
comment|/* EOF already? */
return|return;
comment|/* Get out of here */
name|putchar
argument_list|(
operator|(
name|char
operator|)
name|finchar
argument_list|)
expr_stmt|;
comment|/* first code must be 8 bits = char */
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
comment|/* Crash if can't write */
name|writeerr
argument_list|()
expr_stmt|;
name|stackp
operator|=
name|de_stack
expr_stmt|;
while|while
condition|(
operator|(
name|code
operator|=
name|getcode
argument_list|()
operator|)
operator|>
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|==
name|CLEAR
operator|)
operator|&&
name|block_compress
condition|)
block|{
for|for
control|(
name|code
operator|=
literal|255
init|;
name|code
operator|>=
literal|0
condition|;
name|code
operator|--
control|)
name|tab_prefixof
argument_list|(
name|code
argument_list|)
operator|=
literal|0
expr_stmt|;
name|clear_flg
operator|=
literal|1
expr_stmt|;
name|free_ent
operator|=
name|FIRST
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|getcode
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
comment|/* O, untimely death! */
break|break;
block|}
name|incode
operator|=
name|code
expr_stmt|;
comment|/* 	 * Special case for KwKwK string. 	 */
if|if
condition|(
name|code
operator|>=
name|free_ent
condition|)
block|{
operator|*
name|stackp
operator|++
operator|=
name|finchar
expr_stmt|;
name|code
operator|=
name|oldcode
expr_stmt|;
block|}
comment|/* 	 * Generate output characters in reverse order 	 */
ifdef|#
directive|ifdef
name|SIGNED_COMPARE_SLOW
while|while
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|code
operator|)
operator|>=
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|256
operator|)
condition|)
block|{
else|#
directive|else
while|while
condition|(
name|code
operator|>=
literal|256
condition|)
block|{
endif|#
directive|endif
operator|*
name|stackp
operator|++
operator|=
name|tab_suffixof
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|code
operator|=
name|tab_prefixof
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
operator|*
name|stackp
operator|++
operator|=
name|finchar
operator|=
name|tab_suffixof
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* 	 * And put them out in forward order 	 */
do|do
name|putchar
argument_list|(
operator|*
operator|--
name|stackp
argument_list|)
expr_stmt|;
do|while
condition|(
name|stackp
operator|>
name|de_stack
condition|)
do|;
comment|/* 	 * Generate the new entry. 	 */
if|if
condition|(
operator|(
name|code
operator|=
name|free_ent
operator|)
operator|<
name|maxmaxcode
condition|)
block|{
name|tab_prefixof
argument_list|(
name|code
argument_list|)
operator|=
operator|(
name|unsigned
name|short
operator|)
name|oldcode
expr_stmt|;
name|tab_suffixof
argument_list|(
name|code
argument_list|)
operator|=
name|finchar
expr_stmt|;
name|free_ent
operator|=
name|code
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 	 * Remember previous code. 	 */
name|oldcode
operator|=
name|incode
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|writeerr
argument_list|()
expr_stmt|;
block|}
comment|/*****************************************************************  * TAG( getcode )  *  * Read one code from the standard input.  If EOF, return -1.  * Inputs:  * 	stdin  * Outputs:  * 	code or -1 is returned.  */
name|code_int
name|getcode
parameter_list|()
block|{
comment|/*      * On the VAX, it is important to have the register declarations      * in exactly the order given, or the asm will break.      */
specifier|register
name|code_int
name|code
decl_stmt|;
specifier|static
name|int
name|offset
init|=
literal|0
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|;
specifier|static
name|char_type
name|buf
index|[
name|BITS
index|]
decl_stmt|;
specifier|register
name|int
name|r_off
decl_stmt|,
name|bits
decl_stmt|;
specifier|register
name|char_type
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|clear_flg
operator|>
literal|0
operator|||
name|offset
operator|>=
name|size
operator|||
name|free_ent
operator|>
name|maxcode
condition|)
block|{
comment|/* 	 * If the next entry will be too big for the current code 	 * size, then we must increase the size.  This implies reading 	 * a new buffer full, too. 	 */
if|if
condition|(
name|free_ent
operator|>
name|maxcode
condition|)
block|{
name|n_bits
operator|++
expr_stmt|;
if|if
condition|(
name|n_bits
operator|==
name|maxbits
condition|)
name|maxcode
operator|=
name|maxmaxcode
expr_stmt|;
comment|/* won't get any bigger now */
else|else
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clear_flg
operator|>
literal|0
condition|)
block|{
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
operator|=
name|INIT_BITS
argument_list|)
expr_stmt|;
name|clear_flg
operator|=
literal|0
expr_stmt|;
block|}
name|size
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|n_bits
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* end of file */
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Round size down to integral number of codes */
name|size
operator|=
operator|(
name|size
operator|<<
literal|3
operator|)
operator|-
operator|(
name|n_bits
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|r_off
operator|=
name|offset
expr_stmt|;
name|bits
operator|=
name|n_bits
expr_stmt|;
ifdef|#
directive|ifdef
name|vax
asm|asm( "extzv   r10,r9,(r8),r11" );
else|#
directive|else
comment|/* not a vax */
comment|/* 	 * Get to the first byte. 	 */
name|bp
operator|+=
operator|(
name|r_off
operator|>>
literal|3
operator|)
expr_stmt|;
name|r_off
operator|&=
literal|7
expr_stmt|;
comment|/* Get first part (low order bits) */
ifdef|#
directive|ifdef
name|NO_UCHAR
name|code
operator|=
operator|(
operator|(
operator|*
name|bp
operator|++
operator|>>
name|r_off
operator|)
operator|&
name|rmask
index|[
literal|8
operator|-
name|r_off
index|]
operator|)
operator|&
literal|0xff
expr_stmt|;
else|#
directive|else
name|code
operator|=
operator|(
operator|*
name|bp
operator|++
operator|>>
name|r_off
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* NO_UCHAR */
name|bits
operator|-=
operator|(
literal|8
operator|-
name|r_off
operator|)
expr_stmt|;
name|r_off
operator|=
literal|8
operator|-
name|r_off
expr_stmt|;
comment|/* now, offset into code word */
comment|/* Get any 8 bit parts in the middle (<=1 for up to 16 bits). */
if|if
condition|(
name|bits
operator|>=
literal|8
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_UCHAR
name|code
operator||=
operator|(
operator|*
name|bp
operator|++
operator|&
literal|0xff
operator|)
operator|<<
name|r_off
expr_stmt|;
else|#
directive|else
name|code
operator||=
operator|*
name|bp
operator|++
operator|<<
name|r_off
expr_stmt|;
endif|#
directive|endif
comment|/* NO_UCHAR */
name|r_off
operator|+=
literal|8
expr_stmt|;
name|bits
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* high order bits. */
name|code
operator||=
operator|(
operator|*
name|bp
operator|&
name|rmask
index|[
name|bits
index|]
operator|)
operator|<<
name|r_off
expr_stmt|;
endif|#
directive|endif
comment|/* vax */
name|offset
operator|+=
name|n_bits
expr_stmt|;
return|return
name|code
return|;
block|}
name|char
modifier|*
name|rindex
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|)
comment|/* For those who don't have it in libc.a */
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
name|c
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|NULL
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
name|c
condition|)
name|p
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printcodes
argument_list|()
block|{
comment|/*      * Just print out codes from input file.  For debugging.      */
name|code_int
name|code
decl_stmt|;
name|int
name|col
init|=
literal|0
decl_stmt|,
name|bits
decl_stmt|;
name|bits
operator|=
name|n_bits
operator|=
name|INIT_BITS
expr_stmt|;
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
expr_stmt|;
name|free_ent
operator|=
operator|(
operator|(
name|block_compress
operator|)
condition|?
name|FIRST
else|:
literal|256
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|code
operator|=
name|getcode
argument_list|()
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|==
name|CLEAR
operator|)
operator|&&
name|block_compress
condition|)
block|{
name|free_ent
operator|=
name|FIRST
operator|-
literal|1
expr_stmt|;
name|clear_flg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|free_ent
operator|<
name|maxmaxcode
condition|)
name|free_ent
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|!=
name|n_bits
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChange to %d bits\n"
argument_list|,
name|n_bits
argument_list|)
expr_stmt|;
name|bits
operator|=
name|n_bits
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%5d%c"
argument_list|,
name|code
argument_list|,
operator|(
name|col
operator|+=
literal|6
operator|)
operator|>=
literal|74
condition|?
operator|(
name|col
operator|=
literal|0
operator|,
literal|'\n'
operator|)
else|:
literal|' '
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|code_int
name|sorttab
index|[
literal|1
operator|<<
name|BITS
index|]
decl_stmt|;
comment|/* sorted pointers into htab */
name|dump_tab
argument_list|()
comment|/* dump string table */
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|first
decl_stmt|;
specifier|register
name|ent
expr_stmt|;
define|#
directive|define
name|STACK_SIZE
value|15000
name|int
name|stack_top
init|=
name|STACK_SIZE
decl_stmt|;
specifier|register
name|c
expr_stmt|;
if|if
condition|(
name|do_decomp
operator|==
literal|0
condition|)
block|{
comment|/* compressing */
specifier|register
name|int
name|flag
init|=
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hsize
condition|;
name|i
operator|++
control|)
block|{
comment|/* build sort pointers */
if|if
condition|(
operator|(
name|long
operator|)
name|htabof
argument_list|(
name|i
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|sorttab
index|[
name|codetabof
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
name|first
operator|=
name|block_compress
condition|?
name|FIRST
else|:
literal|256
expr_stmt|;
for|for
control|(
name|i
operator|=
name|first
init|;
name|i
operator|<
name|free_ent
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%5d: \""
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'\n'
expr_stmt|;
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'"'
expr_stmt|;
name|stack_top
operator|=
name|in_stack
argument_list|(
operator|(
name|htabof
argument_list|(
name|sorttab
index|[
name|i
index|]
argument_list|)
operator|>>
name|maxbits
operator|)
operator|&
literal|0xff
argument_list|,
name|stack_top
argument_list|)
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|htabof
argument_list|(
name|sorttab
index|[
name|i
index|]
argument_list|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|maxbits
operator|)
operator|-
literal|1
operator|)
init|;
name|ent
operator|>
literal|256
condition|;
name|ent
operator|=
name|htabof
argument_list|(
name|sorttab
index|[
name|ent
index|]
argument_list|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|maxbits
operator|)
operator|-
literal|1
operator|)
control|)
block|{
name|stack_top
operator|=
name|in_stack
argument_list|(
name|htabof
argument_list|(
name|sorttab
index|[
name|ent
index|]
argument_list|)
operator|>>
name|maxbits
argument_list|,
name|stack_top
argument_list|)
expr_stmt|;
block|}
name|stack_top
operator|=
name|in_stack
argument_list|(
name|ent
argument_list|,
name|stack_top
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|de_stack
index|[
name|stack_top
index|]
argument_list|,
literal|1
argument_list|,
name|STACK_SIZE
operator|-
name|stack_top
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|stack_top
operator|=
name|STACK_SIZE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|debug
condition|)
block|{
comment|/* decompressing */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|free_ent
condition|;
name|i
operator|++
control|)
block|{
name|ent
operator|=
name|i
expr_stmt|;
name|c
operator|=
name|tab_suffixof
argument_list|(
name|ent
argument_list|)
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%5d: %5d/'%c'  \""
argument_list|,
name|ent
argument_list|,
name|tab_prefixof
argument_list|(
name|ent
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%5d: %5d/\\%03o \""
argument_list|,
name|ent
argument_list|,
name|tab_prefixof
argument_list|(
name|ent
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'\n'
expr_stmt|;
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'"'
expr_stmt|;
for|for
control|(
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
operator|(
name|ent
operator|>=
name|FIRST
condition|?
name|tab_prefixof
argument_list|(
name|ent
argument_list|)
else|:
name|NULL
operator|)
control|)
block|{
name|stack_top
operator|=
name|in_stack
argument_list|(
name|tab_suffixof
argument_list|(
name|ent
argument_list|)
argument_list|,
name|stack_top
argument_list|)
expr_stmt|;
block|}
name|fwrite
argument_list|(
operator|&
name|de_stack
index|[
name|stack_top
index|]
argument_list|,
literal|1
argument_list|,
name|STACK_SIZE
operator|-
name|stack_top
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|stack_top
operator|=
name|STACK_SIZE
expr_stmt|;
block|}
block|}
block|}
name|int
name|in_stack
parameter_list|(
name|c
parameter_list|,
name|stack_top
parameter_list|)
function|register c
operator|,
function|stack_top;
block|{
if|if
condition|(
operator|(
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
name|isprint
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'\\'
operator|)
operator|||
name|c
operator|==
literal|' '
condition|)
block|{
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'n'
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'t'
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'f'
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'r'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'\\'
expr_stmt|;
break|break;
default|default:
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'0'
operator|+
name|c
operator|%
literal|8
expr_stmt|;
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'0'
operator|+
operator|(
name|c
operator|/
literal|8
operator|)
operator|%
literal|8
expr_stmt|;
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'0'
operator|+
name|c
operator|/
literal|64
expr_stmt|;
break|break;
block|}
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'\\'
expr_stmt|;
block|}
return|return
name|stack_top
return|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
name|writeerr
argument_list|()
block|{
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|copystat
argument_list|(
argument|ifname
argument_list|,
argument|ofname
argument_list|)
name|char
modifier|*
name|ifname
decl_stmt|,
modifier|*
name|ofname
decl_stmt|;
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|time_t
name|timep
index|[
literal|2
index|]
decl_stmt|;
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|ifname
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
block|{
comment|/* Get stat on input file */
name|perror
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
comment|/*0170000*/
operator|)
operator|!=
name|S_IFREG
comment|/*0100000*/
condition|)
block|{
if|if
condition|(
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -- not a regular file: unchanged"
argument_list|)
expr_stmt|;
name|exit_stat
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|statbuf
operator|.
name|st_nlink
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -- has %d other links: unchanged"
argument_list|,
name|statbuf
operator|.
name|st_nlink
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit_stat
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exit_stat
operator|==
literal|2
operator|&&
operator|(
operator|!
name|force
operator|)
condition|)
block|{
comment|/* No compression: remove file.Z */
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -- file unchanged"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ***** Successful Compression ***** */
name|exit_stat
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
name|statbuf
operator|.
name|st_mode
operator|&
literal|07777
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|ofname
argument_list|,
name|mode
argument_list|)
condition|)
comment|/* Copy modes */
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|chown
argument_list|(
name|ofname
argument_list|,
name|statbuf
operator|.
name|st_uid
argument_list|,
name|statbuf
operator|.
name|st_gid
argument_list|)
expr_stmt|;
comment|/* Copy ownership */
name|timep
index|[
literal|0
index|]
operator|=
name|statbuf
operator|.
name|st_atime
expr_stmt|;
name|timep
index|[
literal|1
index|]
operator|=
name|statbuf
operator|.
name|st_mtime
expr_stmt|;
name|utime
argument_list|(
name|ofname
argument_list|,
name|timep
argument_list|)
expr_stmt|;
comment|/* Update last accessed and modified times */
if|if
condition|(
name|unlink
argument_list|(
name|ifname
argument_list|)
condition|)
comment|/* Remove input file */
name|perror
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -- replaced with %s"
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
return|return;
comment|/* Successful return */
block|}
comment|/* Unsuccessful return -- one of the tests failed */
if|if
condition|(
name|unlink
argument_list|(
name|ofname
argument_list|)
condition|)
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
block|}
comment|/*  * This routine returns 1 if we are running in the foreground and stderr  * is a tty.  */
name|foreground
argument_list|()
block|{
if|if
condition|(
name|bgnd_flag
condition|)
block|{
comment|/* background? */
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* foreground */
if|if
condition|(
name|isatty
argument_list|(
literal|2
argument_list|)
condition|)
block|{
comment|/* and stderr is a tty */
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
name|onintr
argument_list|( )
block|{
if|if
condition|(
operator|!
name|precious
condition|)
name|unlink
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|oops
argument_list|( )
comment|/* wild pointer -- assume bad input */
block|{
if|if
condition|(
name|do_decomp
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"uncompress: corrupt input\n"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cl_block
argument_list|()
comment|/* table clear for block compress */
block|{
specifier|register
name|long
name|int
name|rat
decl_stmt|;
name|checkpoint
operator|=
name|in_count
operator|+
name|CHECK_GAP
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"count: %ld, ratio: "
argument_list|,
name|in_count
argument_list|)
expr_stmt|;
name|prratio
argument_list|(
name|stderr
argument_list|,
name|in_count
argument_list|,
name|bytes_out
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|in_count
operator|>
literal|0x007fffff
condition|)
block|{
comment|/* shift will overflow */
name|rat
operator|=
name|bytes_out
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|rat
operator|==
literal|0
condition|)
block|{
comment|/* Don't divide by zero */
name|rat
operator|=
literal|0x7fffffff
expr_stmt|;
block|}
else|else
block|{
name|rat
operator|=
name|in_count
operator|/
name|rat
expr_stmt|;
block|}
block|}
else|else
block|{
name|rat
operator|=
operator|(
name|in_count
operator|<<
literal|8
operator|)
operator|/
name|bytes_out
expr_stmt|;
comment|/* 8 fractional bits */
block|}
if|if
condition|(
name|rat
operator|>
name|ratio
condition|)
block|{
name|ratio
operator|=
name|rat
expr_stmt|;
block|}
else|else
block|{
name|ratio
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|verbose
condition|)
name|dump_tab
argument_list|()
expr_stmt|;
comment|/* dump string table */
endif|#
directive|endif
name|cl_hash
argument_list|(
operator|(
name|count_int
operator|)
name|hsize
argument_list|)
expr_stmt|;
name|free_ent
operator|=
name|FIRST
expr_stmt|;
name|clear_flg
operator|=
literal|1
expr_stmt|;
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|CLEAR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"clear\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
block|}
name|cl_hash
argument_list|(
name|hsize
argument_list|)
comment|/* reset code table */
specifier|register
name|count_int
name|hsize
expr_stmt|;
block|{
ifndef|#
directive|ifndef
name|XENIX_16
comment|/* Normal machine */
specifier|register
name|count_int
modifier|*
name|htab_p
init|=
name|htab
operator|+
name|hsize
decl_stmt|;
else|#
directive|else
specifier|register
name|j
expr_stmt|;
specifier|register
name|long
name|k
init|=
name|hsize
decl_stmt|;
specifier|register
name|count_int
modifier|*
name|htab_p
decl_stmt|;
endif|#
directive|endif
specifier|register
name|long
name|i
decl_stmt|;
specifier|register
name|long
name|m1
init|=
operator|-
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|XENIX_16
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|8
operator|&&
name|k
operator|>=
literal|0
condition|;
name|j
operator|++
operator|,
name|k
operator|-=
literal|8192
control|)
block|{
name|i
operator|=
literal|8192
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|8192
condition|)
block|{
name|i
operator|=
name|k
expr_stmt|;
block|}
name|htab_p
operator|=
operator|&
operator|(
name|htab
index|[
name|j
index|]
index|[
name|i
index|]
operator|)
expr_stmt|;
name|i
operator|-=
literal|16
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
else|#
directive|else
name|i
operator|=
name|hsize
operator|-
literal|16
expr_stmt|;
endif|#
directive|endif
do|do
block|{
comment|/* might use Sys V memset(3) here */
operator|*
operator|(
name|htab_p
operator|-
literal|16
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|15
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|14
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|13
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|12
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|11
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|10
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|9
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|8
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|7
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|6
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|5
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|4
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|3
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|2
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|1
operator|)
operator|=
name|m1
expr_stmt|;
name|htab_p
operator|-=
literal|16
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|i
operator|-=
literal|16
operator|)
operator|>=
literal|0
condition|)
do|;
ifdef|#
directive|ifdef
name|XENIX_16
block|}
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|+=
literal|16
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
operator|--
name|htab_p
operator|=
name|m1
expr_stmt|;
block|}
name|prratio
argument_list|(
argument|stream
argument_list|,
argument|num
argument_list|,
argument|den
argument_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|long
name|int
name|num
decl_stmt|,
name|den
decl_stmt|;
block|{
specifier|register
name|int
name|q
decl_stmt|;
comment|/* Doesn't need to be long */
if|if
condition|(
name|num
operator|>
literal|214748L
condition|)
block|{
comment|/* 2147483647/10000 */
name|q
operator|=
name|num
operator|/
operator|(
name|den
operator|/
literal|10000L
operator|)
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
literal|10000L
operator|*
name|num
operator|/
name|den
expr_stmt|;
comment|/* Long calculations, though */
block|}
if|if
condition|(
name|q
operator|<
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|'-'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|q
operator|=
operator|-
name|q
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%d.%02d%%"
argument_list|,
name|q
operator|/
literal|100
argument_list|,
name|q
operator|%
literal|100
argument_list|)
expr_stmt|;
block|}
name|version
argument_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s, Berkeley 5.8 %G%\n"
argument_list|,
name|rcs_ident
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Options: "
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|vax
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vax, "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_UCHAR
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"NO_UCHAR, "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGNED_COMPARE_SLOW
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SIGNED_COMPARE_SLOW, "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XENIX_16
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"XENIX_16, "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COMPATIBLE
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"COMPATIBLE, "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG, "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSD4_2
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"BSD4_2, "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"BITS = %d\n"
argument_list|,
name|BITS
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

