begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1985, 1986 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * James A. Woods, derived from original work by Spencer Thomas  * and Joseph Orost.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1985, 1986 The Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)compress.c	5.19 (Berkeley) 3/18/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * compress.c - File compression ala IEEE Computer, June 1984.  *  * Authors:	Spencer W. Thomas	(decvax!utah-cs!thomas)  *		Jim McKie		(decvax!mcvax!jim)  *		Steve Davies		(decvax!vax135!petsd!peora!srd)  *		Ken Turkowski		(decvax!decwrl!turtlevax!ken)  *		James A. Woods		(decvax!ihnp4!ames!jaw)  *		Joe Orost		(decvax!vax135!petsd!joe)  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/*  * Set USERMEM to the maximum amount of physical user memory available  * in bytes.  USERMEM is used to determine the maximum BITS that can be used  * for compression.  *  * SACREDMEM is the amount of physical memory saved for others; compress  * will hog the rest.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SACREDMEM
end_ifndef

begin_define
define|#
directive|define
name|SACREDMEM
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USERMEM
end_ifndef

begin_define
define|#
directive|define
name|USERMEM
value|450000
end_define

begin_comment
comment|/* default user memory */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|pdp11
end_ifdef

begin_define
define|#
directive|define
name|BITS
value|12
end_define

begin_comment
comment|/* max bits/code for 16-bit machine */
end_comment

begin_define
define|#
directive|define
name|NO_UCHAR
end_define

begin_comment
comment|/* also if "unsigned char" functions as signed char */
end_comment

begin_undef
undef|#
directive|undef
name|USERMEM
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* pdp11 */
end_comment

begin_comment
comment|/* don't forget to compile with -i */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USERMEM
end_ifdef

begin_if
if|#
directive|if
name|USERMEM
operator|>=
operator|(
literal|433484
operator|+
name|SACREDMEM
operator|)
end_if

begin_define
define|#
directive|define
name|PBITS
value|16
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|USERMEM
operator|>=
operator|(
literal|229600
operator|+
name|SACREDMEM
operator|)
end_if

begin_define
define|#
directive|define
name|PBITS
value|15
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|USERMEM
operator|>=
operator|(
literal|127536
operator|+
name|SACREDMEM
operator|)
end_if

begin_define
define|#
directive|define
name|PBITS
value|14
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|USERMEM
operator|>=
operator|(
literal|73464
operator|+
name|SACREDMEM
operator|)
end_if

begin_define
define|#
directive|define
name|PBITS
value|13
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PBITS
value|12
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|USERMEM
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USERMEM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PBITS
end_ifdef

begin_comment
comment|/* Preferred BITS for this memory size */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BITS
end_ifndef

begin_define
define|#
directive|define
name|BITS
value|PBITS
end_define

begin_endif
endif|#
directive|endif
endif|BITS
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PBITS */
end_comment

begin_if
if|#
directive|if
name|BITS
operator|==
literal|16
end_if

begin_define
define|#
directive|define
name|HSIZE
value|69001
end_define

begin_comment
comment|/* 95% occupancy */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|BITS
operator|==
literal|15
end_if

begin_define
define|#
directive|define
name|HSIZE
value|35023
end_define

begin_comment
comment|/* 94% occupancy */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|BITS
operator|==
literal|14
end_if

begin_define
define|#
directive|define
name|HSIZE
value|18013
end_define

begin_comment
comment|/* 91% occupancy */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|BITS
operator|==
literal|13
end_if

begin_define
define|#
directive|define
name|HSIZE
value|9001
end_define

begin_comment
comment|/* 91% occupancy */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|BITS
operator|<=
literal|12
end_if

begin_define
define|#
directive|define
name|HSIZE
value|5003
end_define

begin_comment
comment|/* 80% occupancy */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * a code_int must be able to hold 2**BITS values of type int, and also -1  */
end_comment

begin_if
if|#
directive|if
name|BITS
operator|>
literal|15
end_if

begin_typedef
typedef|typedef
name|long
name|int
name|code_int
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|int
name|code_int
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SIGNED_COMPARE_SLOW
end_ifdef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|int
name|count_int
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|short
name|int
name|count_short
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|long
name|int
name|count_int
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_UCHAR
end_ifdef

begin_typedef
typedef|typedef
name|char
name|char_type
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|unsigned
name|char
name|char_type
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UCHAR */
end_comment

begin_decl_stmt
name|char_type
name|magic_header
index|[]
init|=
block|{
literal|"\037\235"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1F 9D */
end_comment

begin_comment
comment|/* Defines for third byte of header */
end_comment

begin_define
define|#
directive|define
name|BIT_MASK
value|0x1f
end_define

begin_define
define|#
directive|define
name|BLOCK_MASK
value|0x80
end_define

begin_comment
comment|/* Masks 0x40 and 0x20 are free.  I think 0x20 should mean that there is    a fourth header byte (for expansion). */
end_comment

begin_define
define|#
directive|define
name|INIT_BITS
value|9
end_define

begin_comment
comment|/* initial number of bits/code */
end_comment

begin_decl_stmt
name|int
name|n_bits
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bits/code */
end_comment

begin_decl_stmt
name|int
name|maxbits
init|=
name|BITS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user settable max # bits/code */
end_comment

begin_decl_stmt
name|code_int
name|maxcode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum code, given n_bits */
end_comment

begin_decl_stmt
name|code_int
name|maxmaxcode
init|=
literal|1
operator|<<
name|BITS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* should NEVER generate this code */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMPATIBLE
end_ifdef

begin_comment
comment|/* But wrong! */
end_comment

begin_define
define|#
directive|define
name|MAXCODE
parameter_list|(
name|n_bits
parameter_list|)
value|(1<< (n_bits) - 1)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAXCODE
parameter_list|(
name|n_bits
parameter_list|)
value|((1<< (n_bits)) - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPATIBLE */
end_comment

begin_decl_stmt
name|count_int
name|htab
index|[
name|HSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|codetab
index|[
name|HSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|htabof
parameter_list|(
name|i
parameter_list|)
value|htab[i]
end_define

begin_define
define|#
directive|define
name|codetabof
parameter_list|(
name|i
parameter_list|)
value|codetab[i]
end_define

begin_decl_stmt
name|code_int
name|hsize
init|=
name|HSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for dynamic table sizing */
end_comment

begin_decl_stmt
name|count_int
name|fsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * To save much memory, we overlay the table used by compress() with those  * used by decompress().  The tab_prefix table is the same size and type  * as the codetab.  The tab_suffix table needs 2**BITS characters.  We  * get this from the beginning of htab.  The output stack uses the rest  * of htab, and contains characters.  There is plenty of room for any  * possible stack (stack used to be 8000 characters).  */
end_comment

begin_define
define|#
directive|define
name|tab_prefixof
parameter_list|(
name|i
parameter_list|)
value|codetabof(i)
end_define

begin_define
define|#
directive|define
name|tab_suffixof
parameter_list|(
name|i
parameter_list|)
value|((char_type *)(htab))[i]
end_define

begin_define
define|#
directive|define
name|de_stack
value|((char_type *)&tab_suffixof(1<<BITS))
end_define

begin_decl_stmt
name|code_int
name|free_ent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first unused entry */
end_comment

begin_decl_stmt
name|int
name|exit_stat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* per-file status */
end_comment

begin_decl_stmt
name|int
name|perm_stat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* permanent status */
end_comment

begin_function_decl
name|code_int
name|getcode
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|nomagic
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use a 3-byte magic number header, unless old file */
end_comment

begin_decl_stmt
name|int
name|zcat_flg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Write output on stdout, suppress messages */
end_comment

begin_decl_stmt
name|int
name|precious
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't unlink output file on interrupt */
end_comment

begin_decl_stmt
name|int
name|quiet
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't tell me about compression */
end_comment

begin_comment
comment|/*  * block compression parameters -- after all codes are used up,  * and compression rate changes, start over.  */
end_comment

begin_decl_stmt
name|int
name|block_compress
init|=
name|BLOCK_MASK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|clear_flg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|int
name|ratio
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CHECK_GAP
value|10000
end_define

begin_comment
comment|/* ratio check interval */
end_comment

begin_decl_stmt
name|count_int
name|checkpoint
init|=
name|CHECK_GAP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * the next two codes should not be changed lightly, as they must not  * lie within the contiguous general code space.  */
end_comment

begin_define
define|#
directive|define
name|FIRST
value|257
end_define

begin_comment
comment|/* first free entry */
end_comment

begin_define
define|#
directive|define
name|CLEAR
value|256
end_define

begin_comment
comment|/* table clear output code */
end_comment

begin_decl_stmt
name|int
name|force
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ofname
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|debug
decl_stmt|,
name|verbose
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|sig_t
name|oldint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bgnd_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_decomp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-  * Algorithm from "A Technique for High Performance Data Compression",  * Terry A. Welch, IEEE Computer Vol 17, No 6 (June 1984), pp 8-19.  *  * Usage: compress [-dfvc] [-b bits] [file ...]  * Inputs:  *	-d:	    If given, decompression is done instead.  *  *      -c:         Write output on stdout, don't remove original.  *  *      -b:         Parameter limits the max number of bits/code.  *  *	-f:	    Forces output file to be generated, even if one already  *		    exists, and even if no space is saved by compressing.  *		    If -f is not used, the user will be prompted if stdin is  *		    a tty, otherwise, the output file will not be overwritten.  *  *      -v:	    Write compression statistics  *  * 	file ...:   Files to be compressed.  If none specified, stdin  *		    is used.  * Outputs:  *	file.Z:	    Compressed form of file with same mode, owner, and utimes  * 	or stdout   (if stdin used as input)  *  * Assumptions:  *	When filenames are given, replaces with the compressed version  *	(.Z suffix) only if the file decreases in size.  * Algorithm:  * 	Modified Lempel-Ziv method (LZW).  Basically finds common  * substrings and replaces them with a variable size code.  This is  * deterministic, and can be done on the fly.  Thus, the decompression  * procedure needs no input table, but tracks the way the table was built.  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|overwrite
decl_stmt|;
name|char
modifier|*
modifier|*
name|filelist
decl_stmt|,
modifier|*
modifier|*
name|fileptr
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
name|tempname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|void
name|onintr
argument_list|()
decl_stmt|,
name|oops
argument_list|()
decl_stmt|;
comment|/* This bg check only works for sh. */
if|if
condition|(
operator|(
name|oldint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|)
operator|!=
name|SIG_IGN
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|oops
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
name|bgnd_flag
operator|=
name|oldint
operator|!=
name|SIG_DFL
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPATIBLE
name|nomagic
operator|=
literal|1
expr_stmt|;
comment|/* Original didn't have a magic number */
endif|#
directive|endif
if|if
condition|(
name|cp
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
else|else
name|cp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"uncompress"
argument_list|)
operator|==
literal|0
condition|)
name|do_decomp
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"zcat"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|do_decomp
operator|=
literal|1
expr_stmt|;
name|zcat_flg
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * -b maxbits => maxbits. 	 * -C => generate output compatible with compress 2.0. 	 * -c => cat all output to stdout 	 * -D => debug 	 * -d => do_decomp 	 * -f => force overwrite of output file 	 * -n => no header: useful to uncompress old files 	 * -V => print Version; debug verbose 	 * -v => unquiet 	 */
name|overwrite
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"b:CcDdfnVv"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
else|#
directive|else
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"b:Ccdfnv"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
endif|#
directive|endif
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'b'
case|:
name|maxbits
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|block_compress
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|zcat_flg
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'D'
case|:
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'d'
case|:
name|do_decomp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|overwrite
operator|=
literal|1
expr_stmt|;
name|force
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|nomagic
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'V'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'v'
case|:
name|quiet
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|maxbits
operator|<
name|INIT_BITS
condition|)
name|maxbits
operator|=
name|INIT_BITS
expr_stmt|;
if|if
condition|(
name|maxbits
operator|>
name|BITS
condition|)
name|maxbits
operator|=
name|BITS
expr_stmt|;
name|maxmaxcode
operator|=
literal|1
operator|<<
name|maxbits
expr_stmt|;
comment|/* Build useless input file list. */
name|filelist
operator|=
name|fileptr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|malloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|argv
condition|)
operator|*
name|fileptr
operator|++
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
operator|*
name|fileptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|filelist
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|fileptr
operator|=
name|filelist
init|;
operator|*
name|fileptr
condition|;
name|fileptr
operator|++
control|)
block|{
name|exit_stat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|do_decomp
condition|)
block|{
comment|/* DECOMPRESSION */
comment|/* Check for .Z suffix */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|fileptr
operator|+
name|strlen
argument_list|(
operator|*
name|fileptr
argument_list|)
operator|-
literal|2
argument_list|,
literal|".Z"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* No .Z: tack one on */
name|strcpy
argument_list|(
name|tempname
argument_list|,
operator|*
name|fileptr
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tempname
argument_list|,
literal|".Z"
argument_list|)
expr_stmt|;
operator|*
name|fileptr
operator|=
name|tempname
expr_stmt|;
block|}
comment|/* Open input file */
if|if
condition|(
operator|(
name|freopen
argument_list|(
operator|*
name|fileptr
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
operator|*
name|fileptr
argument_list|)
expr_stmt|;
name|perm_stat
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Check the magic number */
if|if
condition|(
name|nomagic
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|getchar
argument_list|()
operator|!=
operator|(
name|magic_header
index|[
literal|0
index|]
operator|&
literal|0xFF
operator|)
operator|)
operator|||
operator|(
name|getchar
argument_list|()
operator|!=
operator|(
name|magic_header
index|[
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: not in compressed format\n"
argument_list|,
operator|*
name|fileptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|maxbits
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* set -b from file */
name|block_compress
operator|=
name|maxbits
operator|&
name|BLOCK_MASK
expr_stmt|;
name|maxbits
operator|&=
name|BIT_MASK
expr_stmt|;
name|maxmaxcode
operator|=
literal|1
operator|<<
name|maxbits
expr_stmt|;
if|if
condition|(
name|maxbits
operator|>
name|BITS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: compressed with %d bits, can only handle %d bits\n"
argument_list|,
operator|*
name|fileptr
argument_list|,
name|maxbits
argument_list|,
name|BITS
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Generate output filename */
name|strcpy
argument_list|(
name|ofname
argument_list|,
operator|*
name|fileptr
argument_list|)
expr_stmt|;
name|ofname
index|[
name|strlen
argument_list|(
operator|*
name|fileptr
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Strip off .Z */
block|}
else|else
block|{
comment|/* COMPRESSION */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|fileptr
operator|+
name|strlen
argument_list|(
operator|*
name|fileptr
argument_list|)
operator|-
literal|2
argument_list|,
literal|".Z"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: already has .Z suffix -- no change\n"
argument_list|,
operator|*
name|fileptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Open input file */
if|if
condition|(
operator|(
name|freopen
argument_list|(
operator|*
name|fileptr
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
operator|*
name|fileptr
argument_list|)
expr_stmt|;
name|perm_stat
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|stat
argument_list|(
operator|*
name|fileptr
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
name|fsize
operator|=
operator|(
name|long
operator|)
name|statbuf
operator|.
name|st_size
expr_stmt|;
comment|/* 		 * tune hash table size for small files -- ad hoc, 		 * but the sizes match earlier #defines, which 		 * serve as upper bounds on the number of output codes.  		 */
name|hsize
operator|=
name|HSIZE
expr_stmt|;
if|if
condition|(
name|fsize
operator|<
operator|(
literal|1
operator|<<
literal|12
operator|)
condition|)
name|hsize
operator|=
name|MIN
argument_list|(
literal|5003
argument_list|,
name|HSIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fsize
operator|<
operator|(
literal|1
operator|<<
literal|13
operator|)
condition|)
name|hsize
operator|=
name|MIN
argument_list|(
literal|9001
argument_list|,
name|HSIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fsize
operator|<
operator|(
literal|1
operator|<<
literal|14
operator|)
condition|)
name|hsize
operator|=
name|MIN
argument_list|(
literal|18013
argument_list|,
name|HSIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fsize
operator|<
operator|(
literal|1
operator|<<
literal|15
operator|)
condition|)
name|hsize
operator|=
name|MIN
argument_list|(
literal|35023
argument_list|,
name|HSIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fsize
operator|<
literal|47000
condition|)
name|hsize
operator|=
name|MIN
argument_list|(
literal|50021
argument_list|,
name|HSIZE
argument_list|)
expr_stmt|;
comment|/* Generate output filename */
name|strcpy
argument_list|(
name|ofname
argument_list|,
operator|*
name|fileptr
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ofname
argument_list|,
literal|".Z"
argument_list|)
expr_stmt|;
block|}
comment|/* Check for overwrite of existing file */
if|if
condition|(
name|overwrite
operator|==
literal|0
operator|&&
name|zcat_flg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|ofname
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|response
index|[
literal|2
index|]
decl_stmt|;
name|response
index|[
literal|0
index|]
operator|=
literal|'n'
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s already exists;"
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bgnd_flag
operator|==
literal|0
operator|&&
name|isatty
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" do you wish to overwrite %s (y or n)? "
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|read
argument_list|(
literal|2
argument_list|,
name|response
argument_list|,
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|response
index|[
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
literal|2
argument_list|,
name|response
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Ack! */
name|perror
argument_list|(
literal|"stderr"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|response
index|[
literal|0
index|]
operator|!=
literal|'y'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tnot overwritten\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
if|if
condition|(
name|zcat_flg
operator|==
literal|0
condition|)
block|{
comment|/* Open output file */
if|if
condition|(
name|freopen
argument_list|(
name|ofname
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|perm_stat
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|precious
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
operator|*
name|fileptr
argument_list|)
expr_stmt|;
block|}
comment|/* Actually do the compression/decompression */
if|if
condition|(
name|do_decomp
operator|==
literal|0
condition|)
name|compress
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
else|else
name|decompress
argument_list|()
expr_stmt|;
else|#
directive|else
elseif|else
if|if
condition|(
name|debug
operator|==
literal|0
condition|)
name|decompress
argument_list|()
expr_stmt|;
else|else
name|printcodes
argument_list|()
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|dump_tab
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|zcat_flg
operator|==
literal|0
condition|)
block|{
name|copystat
argument_list|(
operator|*
name|fileptr
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
comment|/* Copy stats */
name|precious
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|exit_stat
operator|==
literal|1
operator|)
operator|||
operator|(
operator|!
name|quiet
operator|)
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Standard input */
if|if
condition|(
name|do_decomp
operator|==
literal|0
condition|)
block|{
name|compress
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|verbose
condition|)
name|dump_tab
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|!
name|quiet
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check the magic number */
if|if
condition|(
name|nomagic
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|getchar
argument_list|()
operator|!=
operator|(
name|magic_header
index|[
literal|0
index|]
operator|&
literal|0xFF
operator|)
operator|)
operator|||
operator|(
name|getchar
argument_list|()
operator|!=
operator|(
name|magic_header
index|[
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"stdin: not in compressed format\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|maxbits
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* set -b from file */
name|block_compress
operator|=
name|maxbits
operator|&
name|BLOCK_MASK
expr_stmt|;
name|maxbits
operator|&=
name|BIT_MASK
expr_stmt|;
name|maxmaxcode
operator|=
literal|1
operator|<<
name|maxbits
expr_stmt|;
name|fsize
operator|=
literal|100000
expr_stmt|;
comment|/* assume stdin large for USERMEM */
if|if
condition|(
name|maxbits
operator|>
name|BITS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"stdin: compressed with %d bits, can only handle %d bits\n"
argument_list|,
name|maxbits
argument_list|,
name|BITS
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|DEBUG
name|decompress
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|debug
operator|==
literal|0
condition|)
name|decompress
argument_list|()
expr_stmt|;
else|else
name|printcodes
argument_list|()
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|dump_tab
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
block|}
name|exit
argument_list|(
name|perm_stat
condition|?
name|perm_stat
else|:
name|exit_stat
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|int
name|in_count
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of input */
end_comment

begin_decl_stmt
name|long
name|int
name|bytes_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of compressed output */
end_comment

begin_decl_stmt
name|long
name|int
name|out_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of codes output (for debugging) */
end_comment

begin_comment
comment|/*  * compress stdin to stdout  *  * Algorithm:  use open addressing double hashing (no chaining) on the   * prefix code / next character combination.  We do a variant of Knuth's  * algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime  * secondary probe.  Here, the modular division first probe is gives way  * to a faster exclusive-or manipulation.  Also do block compression with  * an adaptive reset, whereby the code table is cleared when the compression  * ratio decreases, but after the table fills.  The variable-length output  * codes are re-sized at this point, and a special CLEAR code is generated  * for the decompressor.  Late addition:  construct the table according to  * file size for noticeable speed improvement on small files.  Please direct  * questions about this implementation to ames!jaw.  */
end_comment

begin_macro
name|compress
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|long
name|fcode
decl_stmt|;
specifier|register
name|code_int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|code_int
name|ent
decl_stmt|;
specifier|register
name|int
name|disp
decl_stmt|;
specifier|register
name|code_int
name|hsize_reg
decl_stmt|;
specifier|register
name|int
name|hshift
decl_stmt|;
ifndef|#
directive|ifndef
name|COMPATIBLE
if|if
condition|(
name|nomagic
operator|==
literal|0
condition|)
block|{
name|putchar
argument_list|(
name|magic_header
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|magic_header
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
call|(
name|char
call|)
argument_list|(
name|maxbits
operator||
name|block_compress
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|writeerr
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* COMPATIBLE */
name|offset
operator|=
literal|0
expr_stmt|;
name|bytes_out
operator|=
literal|3
expr_stmt|;
comment|/* includes 3-byte header mojo */
name|out_count
operator|=
literal|0
expr_stmt|;
name|clear_flg
operator|=
literal|0
expr_stmt|;
name|ratio
operator|=
literal|0
expr_stmt|;
name|in_count
operator|=
literal|1
expr_stmt|;
name|checkpoint
operator|=
name|CHECK_GAP
expr_stmt|;
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
operator|=
name|INIT_BITS
argument_list|)
expr_stmt|;
name|free_ent
operator|=
operator|(
operator|(
name|block_compress
operator|)
condition|?
name|FIRST
else|:
literal|256
operator|)
expr_stmt|;
name|ent
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|hshift
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fcode
operator|=
operator|(
name|long
operator|)
name|hsize
init|;
name|fcode
operator|<
literal|65536L
condition|;
name|fcode
operator|*=
literal|2L
control|)
name|hshift
operator|++
expr_stmt|;
name|hshift
operator|=
literal|8
operator|-
name|hshift
expr_stmt|;
comment|/* set hash code range bound */
name|hsize_reg
operator|=
name|hsize
expr_stmt|;
name|cl_hash
argument_list|(
operator|(
name|count_int
operator|)
name|hsize_reg
argument_list|)
expr_stmt|;
comment|/* clear hash table */
ifdef|#
directive|ifdef
name|SIGNED_COMPARE_SLOW
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
operator|(
name|unsigned
operator|)
name|EOF
condition|)
block|{
else|#
directive|else
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
block|{
endif|#
directive|endif
name|in_count
operator|++
expr_stmt|;
name|fcode
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|c
operator|<<
name|maxbits
operator|)
operator|+
name|ent
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
operator|(
name|c
operator|<<
name|hshift
operator|)
operator|^
name|ent
operator|)
expr_stmt|;
comment|/* xor hashing */
if|if
condition|(
name|htabof
argument_list|(
name|i
argument_list|)
operator|==
name|fcode
condition|)
block|{
name|ent
operator|=
name|codetabof
argument_list|(
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|long
operator|)
name|htabof
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
comment|/* empty slot */
goto|goto
name|nomatch
goto|;
name|disp
operator|=
name|hsize_reg
operator|-
name|i
expr_stmt|;
comment|/* secondary hash (after G. Knott) */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|disp
operator|=
literal|1
expr_stmt|;
name|probe
label|:
if|if
condition|(
operator|(
name|i
operator|-=
name|disp
operator|)
operator|<
literal|0
condition|)
name|i
operator|+=
name|hsize_reg
expr_stmt|;
if|if
condition|(
name|htabof
argument_list|(
name|i
argument_list|)
operator|==
name|fcode
condition|)
block|{
name|ent
operator|=
name|codetabof
argument_list|(
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|htabof
argument_list|(
name|i
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|probe
goto|;
name|nomatch
label|:
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
name|out_count
operator|++
expr_stmt|;
name|ent
operator|=
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGNED_COMPARE_SLOW
if|if
condition|(
operator|(
name|unsigned
operator|)
name|free_ent
operator|<
operator|(
name|unsigned
operator|)
name|maxmaxcode
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|free_ent
operator|<
name|maxmaxcode
condition|)
block|{
endif|#
directive|endif
name|codetabof
argument_list|(
name|i
argument_list|)
operator|=
name|free_ent
operator|++
expr_stmt|;
comment|/* code -> hashtable */
name|htabof
argument_list|(
name|i
argument_list|)
operator|=
name|fcode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|count_int
operator|)
name|in_count
operator|>=
name|checkpoint
operator|&&
name|block_compress
condition|)
name|cl_block
argument_list|()
expr_stmt|;
block|}
comment|/*      * Put out the final code.      */
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
name|out_count
operator|++
expr_stmt|;
name|output
argument_list|(
operator|(
name|code_int
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Print out stats on stderr      */
if|if
condition|(
name|zcat_flg
operator|==
literal|0
operator|&&
operator|!
name|quiet
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld chars in, %ld codes (%ld bytes) out, compression factor: "
argument_list|,
name|in_count
argument_list|,
name|out_count
argument_list|,
name|bytes_out
argument_list|)
expr_stmt|;
name|prratio
argument_list|(
name|stderr
argument_list|,
name|in_count
argument_list|,
name|bytes_out
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tCompression as in compact: "
argument_list|)
expr_stmt|;
name|prratio
argument_list|(
name|stderr
argument_list|,
name|in_count
operator|-
name|bytes_out
argument_list|,
name|in_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tLargest code (of last block) was %d (%d bits)\n"
argument_list|,
name|free_ent
operator|-
literal|1
argument_list|,
name|n_bits
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !DEBUG */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Compression: "
argument_list|)
expr_stmt|;
name|prratio
argument_list|(
name|stderr
argument_list|,
name|in_count
operator|-
name|bytes_out
argument_list|,
name|in_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
if|if
condition|(
name|bytes_out
operator|>
name|in_count
condition|)
comment|/* exit(2) if no savings */
name|exit_stat
operator|=
literal|2
expr_stmt|;
return|return;
block|}
comment|/*-  * Output the given code.  * Inputs:  * 	code:	A n_bits-bit integer.  If == -1, then EOF.  This assumes  *		that n_bits =< (long)wordsize - 1.  * Outputs:  * 	Outputs code to the file.  * Assumptions:  *	Chars are 8 bits long.  * Algorithm:  * 	Maintain a BITS character long buffer (so that 8 codes will  * fit in it exactly).  Use the VAX insv instruction to insert each  * code in turn.  When the buffer fills up empty it and start over.  */
specifier|static
name|char
name|buf
index|[
name|BITS
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|vax
name|char_type
name|lmask
index|[
literal|9
index|]
init|=
block|{
literal|0xff
block|,
literal|0xfe
block|,
literal|0xfc
block|,
literal|0xf8
block|,
literal|0xf0
block|,
literal|0xe0
block|,
literal|0xc0
block|,
literal|0x80
block|,
literal|0x00
block|}
decl_stmt|;
name|char_type
name|rmask
index|[
literal|9
index|]
init|=
block|{
literal|0x00
block|,
literal|0x01
block|,
literal|0x03
block|,
literal|0x07
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x3f
block|,
literal|0x7f
block|,
literal|0xff
block|}
decl_stmt|;
endif|#
directive|endif
comment|/* vax */
name|output
argument_list|(
argument|code
argument_list|)
name|code_int
name|code
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
specifier|static
name|int
name|col
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/*      * On the VAX, it is important to have the register declarations      * in exactly the order given, or the asm will break.      */
specifier|register
name|int
name|r_off
init|=
name|offset
decl_stmt|,
name|bits
init|=
name|n_bits
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%5d%c"
argument_list|,
name|code
argument_list|,
operator|(
name|col
operator|+=
literal|6
operator|)
operator|>=
literal|74
condition|?
operator|(
name|col
operator|=
literal|0
operator|,
literal|'\n'
operator|)
else|:
literal|' '
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
comment|/* 	 * VAX and PCC DEPENDENT!! Implementation on other machines is 	 * below. 	 * 	 * Translation: Insert BITS bits from the argument starting at 	 * offset bits from the beginning of buf. 	 */
literal|0
expr_stmt|;
comment|/* Work around for pcc -O bug with asm and if stmt */
asm|asm( "insv	4(ap),r11,r10,(r9)" );
else|#
directive|else
comment|/*   * byte/bit numbering on the VAX is simulated by the following code  */
comment|/* 	 * Get to the first byte. 	 */
name|bp
operator|+=
operator|(
name|r_off
operator|>>
literal|3
operator|)
expr_stmt|;
name|r_off
operator|&=
literal|7
expr_stmt|;
comment|/* 	 * Since code is always>= 8 bits, only need to mask the first 	 * hunk on the left. 	 */
operator|*
name|bp
operator|=
operator|(
operator|*
name|bp
operator|&
name|rmask
index|[
name|r_off
index|]
operator|)
operator||
operator|(
name|code
operator|<<
name|r_off
operator|)
operator|&
name|lmask
index|[
name|r_off
index|]
expr_stmt|;
name|bp
operator|++
expr_stmt|;
name|bits
operator|-=
operator|(
literal|8
operator|-
name|r_off
operator|)
expr_stmt|;
name|code
operator|>>=
literal|8
operator|-
name|r_off
expr_stmt|;
comment|/* Get any 8 bit parts in the middle (<=1 for up to 16 bits). */
if|if
condition|(
name|bits
operator|>=
literal|8
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
name|code
expr_stmt|;
name|code
operator|>>=
literal|8
expr_stmt|;
name|bits
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* Last bits. */
if|if
condition|(
name|bits
condition|)
operator|*
name|bp
operator|=
name|code
expr_stmt|;
endif|#
directive|endif
comment|/* vax */
name|offset
operator|+=
name|n_bits
expr_stmt|;
if|if
condition|(
name|offset
operator|==
operator|(
name|n_bits
operator|<<
literal|3
operator|)
condition|)
block|{
name|bp
operator|=
name|buf
expr_stmt|;
name|bits
operator|=
name|n_bits
expr_stmt|;
name|bytes_out
operator|+=
name|bits
expr_stmt|;
do|do
block|{
name|putchar
argument_list|(
operator|*
name|bp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|writeerr
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|bits
condition|)
do|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If the next entry is going to be too big for the code size, 	 * then increase it, if possible. 	 */
if|if
condition|(
name|free_ent
operator|>
name|maxcode
operator|||
operator|(
name|clear_flg
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* 	     * Write the whole buffer, because the input side won't 	     * discover the size increase until after it has read it. 	     */
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|n_bits
argument_list|,
name|stdout
argument_list|)
operator|!=
name|n_bits
condition|)
name|writeerr
argument_list|()
expr_stmt|;
name|bytes_out
operator|+=
name|n_bits
expr_stmt|;
block|}
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|clear_flg
condition|)
block|{
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
operator|=
name|INIT_BITS
argument_list|)
expr_stmt|;
name|clear_flg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|n_bits
operator|++
expr_stmt|;
if|if
condition|(
name|n_bits
operator|==
name|maxbits
condition|)
name|maxcode
operator|=
name|maxmaxcode
expr_stmt|;
else|else
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChange to %d bits\n"
argument_list|,
name|n_bits
argument_list|)
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
block|}
block|}
else|else
block|{
comment|/* 	 * At EOF, write the rest of the buffer. 	 */
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
name|offset
operator|=
operator|(
name|offset
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|offset
argument_list|,
name|stdout
argument_list|)
operator|!=
name|offset
condition|)
name|writeerr
argument_list|()
expr_stmt|;
name|bytes_out
operator|+=
name|offset
expr_stmt|;
block|}
name|offset
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|writeerr
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/*  * Decompress stdin to stdout.  This routine adapts to the codes in the  * file building the "string" table on-the-fly; requiring no table to  * be stored in the compressed file.  The tables used herein are shared  * with those of the compress() routine.  See the definitions above.  */
name|decompress
argument_list|()
block|{
specifier|register
name|char_type
modifier|*
name|stackp
decl_stmt|;
specifier|register
name|int
name|finchar
decl_stmt|;
specifier|register
name|code_int
name|code
decl_stmt|,
name|oldcode
decl_stmt|,
name|incode
decl_stmt|;
name|int
name|n
decl_stmt|,
name|nwritten
decl_stmt|,
name|offset
decl_stmt|;
comment|/* Variables for buffered write */
name|char
name|buff
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* Buffer for buffered write */
comment|/*      * As above, initialize the first 256 entries in the table.      */
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
operator|=
name|INIT_BITS
argument_list|)
expr_stmt|;
for|for
control|(
name|code
operator|=
literal|255
init|;
name|code
operator|>=
literal|0
condition|;
name|code
operator|--
control|)
block|{
name|tab_prefixof
argument_list|(
name|code
argument_list|)
operator|=
literal|0
expr_stmt|;
name|tab_suffixof
argument_list|(
name|code
argument_list|)
operator|=
operator|(
name|char_type
operator|)
name|code
expr_stmt|;
block|}
name|free_ent
operator|=
operator|(
operator|(
name|block_compress
operator|)
condition|?
name|FIRST
else|:
literal|256
operator|)
expr_stmt|;
name|finchar
operator|=
name|oldcode
operator|=
name|getcode
argument_list|()
expr_stmt|;
if|if
condition|(
name|oldcode
operator|==
operator|-
literal|1
condition|)
comment|/* EOF already? */
return|return;
comment|/* Get out of here */
comment|/* first code must be 8 bits = char */
name|n
operator|=
literal|0
expr_stmt|;
name|buff
index|[
name|n
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|finchar
expr_stmt|;
name|stackp
operator|=
name|de_stack
expr_stmt|;
while|while
condition|(
operator|(
name|code
operator|=
name|getcode
argument_list|()
operator|)
operator|>
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|==
name|CLEAR
operator|)
operator|&&
name|block_compress
condition|)
block|{
for|for
control|(
name|code
operator|=
literal|255
init|;
name|code
operator|>=
literal|0
condition|;
name|code
operator|--
control|)
name|tab_prefixof
argument_list|(
name|code
argument_list|)
operator|=
literal|0
expr_stmt|;
name|clear_flg
operator|=
literal|1
expr_stmt|;
name|free_ent
operator|=
name|FIRST
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|getcode
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
comment|/* O, untimely death! */
break|break;
block|}
name|incode
operator|=
name|code
expr_stmt|;
comment|/* 	 * Special case for KwKwK string. 	 */
if|if
condition|(
name|code
operator|>=
name|free_ent
condition|)
block|{
operator|*
name|stackp
operator|++
operator|=
name|finchar
expr_stmt|;
name|code
operator|=
name|oldcode
expr_stmt|;
block|}
comment|/* 	 * Generate output characters in reverse order 	 */
ifdef|#
directive|ifdef
name|SIGNED_COMPARE_SLOW
while|while
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|code
operator|)
operator|>=
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|256
operator|)
condition|)
block|{
else|#
directive|else
while|while
condition|(
name|code
operator|>=
literal|256
condition|)
block|{
endif|#
directive|endif
operator|*
name|stackp
operator|++
operator|=
name|tab_suffixof
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|code
operator|=
name|tab_prefixof
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
operator|*
name|stackp
operator|++
operator|=
name|finchar
operator|=
name|tab_suffixof
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* 	 * And put them out in forward order 	 */
do|do
block|{
comment|/* 	     * About 60% of the time is spent in the putchar() call 	     * that appeared here.  It was originally 	     *		putchar ( *--stackp ); 	     * If we buffer the writes ourselves, we can go faster (about 	     * 30%). 	     * 	     * At this point, the next line is the next *big* time 	     * sink in the code.  It takes up about 10% of the time. 	     */
name|buff
index|[
name|n
operator|++
index|]
operator|=
operator|*
operator|--
name|stackp
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|BUFSIZ
condition|)
block|{
name|offset
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|nwritten
operator|=
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
operator|&
name|buff
index|[
name|offset
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwritten
operator|<
literal|0
condition|)
name|writeerr
argument_list|()
expr_stmt|;
name|offset
operator|+=
name|nwritten
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|n
operator|-=
name|nwritten
operator|)
operator|>
literal|0
condition|)
do|;
block|}
block|}
do|while
condition|(
name|stackp
operator|>
name|de_stack
condition|)
do|;
comment|/* 	 * Generate the new entry. 	 */
if|if
condition|(
operator|(
name|code
operator|=
name|free_ent
operator|)
operator|<
name|maxmaxcode
condition|)
block|{
name|tab_prefixof
argument_list|(
name|code
argument_list|)
operator|=
operator|(
name|unsigned
name|short
operator|)
name|oldcode
expr_stmt|;
name|tab_suffixof
argument_list|(
name|code
argument_list|)
operator|=
name|finchar
expr_stmt|;
name|free_ent
operator|=
name|code
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 	 * Remember previous code. 	 */
name|oldcode
operator|=
name|incode
expr_stmt|;
block|}
comment|/*      * Flush the stuff remaining in our buffer...      */
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|nwritten
operator|=
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
operator|&
name|buff
index|[
name|offset
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwritten
operator|<
literal|0
condition|)
name|writeerr
argument_list|()
expr_stmt|;
name|offset
operator|+=
name|nwritten
expr_stmt|;
name|n
operator|-=
name|nwritten
expr_stmt|;
block|}
block|}
comment|/*-  * Read one code from the standard input.  If EOF, return -1.  * Inputs:  * 	stdin  * Outputs:  * 	code or -1 is returned.  */
name|code_int
name|getcode
parameter_list|()
block|{
comment|/*      * On the VAX, it is important to have the register declarations      * in exactly the order given, or the asm will break.      */
specifier|register
name|code_int
name|code
decl_stmt|;
specifier|static
name|int
name|offset
init|=
literal|0
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|;
specifier|static
name|char_type
name|buf
index|[
name|BITS
index|]
decl_stmt|;
specifier|register
name|int
name|r_off
decl_stmt|,
name|bits
decl_stmt|;
specifier|register
name|char_type
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|clear_flg
operator|>
literal|0
operator|||
name|offset
operator|>=
name|size
operator|||
name|free_ent
operator|>
name|maxcode
condition|)
block|{
comment|/* 	 * If the next entry will be too big for the current code 	 * size, then we must increase the size.  This implies reading 	 * a new buffer full, too. 	 */
if|if
condition|(
name|free_ent
operator|>
name|maxcode
condition|)
block|{
name|n_bits
operator|++
expr_stmt|;
if|if
condition|(
name|n_bits
operator|==
name|maxbits
condition|)
name|maxcode
operator|=
name|maxmaxcode
expr_stmt|;
comment|/* won't get any bigger now */
else|else
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clear_flg
operator|>
literal|0
condition|)
block|{
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
operator|=
name|INIT_BITS
argument_list|)
expr_stmt|;
name|clear_flg
operator|=
literal|0
expr_stmt|;
block|}
name|size
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|n_bits
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* end of file */
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Round size down to integral number of codes */
name|size
operator|=
operator|(
name|size
operator|<<
literal|3
operator|)
operator|-
operator|(
name|n_bits
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|r_off
operator|=
name|offset
expr_stmt|;
name|bits
operator|=
name|n_bits
expr_stmt|;
ifdef|#
directive|ifdef
name|vax
asm|asm( "extzv   r10,r9,(r8),r11" );
else|#
directive|else
comment|/* not a vax */
comment|/* 	 * Get to the first byte. 	 */
name|bp
operator|+=
operator|(
name|r_off
operator|>>
literal|3
operator|)
expr_stmt|;
name|r_off
operator|&=
literal|7
expr_stmt|;
comment|/* Get first part (low order bits) */
ifdef|#
directive|ifdef
name|NO_UCHAR
name|code
operator|=
operator|(
operator|(
operator|*
name|bp
operator|++
operator|>>
name|r_off
operator|)
operator|&
name|rmask
index|[
literal|8
operator|-
name|r_off
index|]
operator|)
operator|&
literal|0xff
expr_stmt|;
else|#
directive|else
name|code
operator|=
operator|(
operator|*
name|bp
operator|++
operator|>>
name|r_off
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* NO_UCHAR */
name|bits
operator|-=
operator|(
literal|8
operator|-
name|r_off
operator|)
expr_stmt|;
name|r_off
operator|=
literal|8
operator|-
name|r_off
expr_stmt|;
comment|/* now, offset into code word */
comment|/* Get any 8 bit parts in the middle (<=1 for up to 16 bits). */
if|if
condition|(
name|bits
operator|>=
literal|8
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_UCHAR
name|code
operator||=
operator|(
operator|*
name|bp
operator|++
operator|&
literal|0xff
operator|)
operator|<<
name|r_off
expr_stmt|;
else|#
directive|else
name|code
operator||=
operator|*
name|bp
operator|++
operator|<<
name|r_off
expr_stmt|;
endif|#
directive|endif
comment|/* NO_UCHAR */
name|r_off
operator|+=
literal|8
expr_stmt|;
name|bits
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* high order bits. */
name|code
operator||=
operator|(
operator|*
name|bp
operator|&
name|rmask
index|[
name|bits
index|]
operator|)
operator|<<
name|r_off
expr_stmt|;
endif|#
directive|endif
comment|/* vax */
name|offset
operator|+=
name|n_bits
expr_stmt|;
return|return
name|code
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printcodes
argument_list|()
block|{
comment|/*      * Just print out codes from input file.  For debugging.      */
name|code_int
name|code
decl_stmt|;
name|int
name|col
init|=
literal|0
decl_stmt|,
name|bits
decl_stmt|;
name|bits
operator|=
name|n_bits
operator|=
name|INIT_BITS
expr_stmt|;
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
expr_stmt|;
name|free_ent
operator|=
operator|(
operator|(
name|block_compress
operator|)
condition|?
name|FIRST
else|:
literal|256
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|code
operator|=
name|getcode
argument_list|()
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|==
name|CLEAR
operator|)
operator|&&
name|block_compress
condition|)
block|{
name|free_ent
operator|=
name|FIRST
operator|-
literal|1
expr_stmt|;
name|clear_flg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|free_ent
operator|<
name|maxmaxcode
condition|)
name|free_ent
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|!=
name|n_bits
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChange to %d bits\n"
argument_list|,
name|n_bits
argument_list|)
expr_stmt|;
name|bits
operator|=
name|n_bits
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%5d%c"
argument_list|,
name|code
argument_list|,
operator|(
name|col
operator|+=
literal|6
operator|)
operator|>=
literal|74
condition|?
operator|(
name|col
operator|=
literal|0
operator|,
literal|'\n'
operator|)
else|:
literal|' '
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|code_int
name|sorttab
index|[
literal|1
operator|<<
name|BITS
index|]
decl_stmt|;
comment|/* sorted pointers into htab */
name|dump_tab
argument_list|()
comment|/* dump string table */
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|first
decl_stmt|;
specifier|register
name|ent
expr_stmt|;
define|#
directive|define
name|STACK_SIZE
value|15000
name|int
name|stack_top
init|=
name|STACK_SIZE
decl_stmt|;
specifier|register
name|c
expr_stmt|;
if|if
condition|(
name|do_decomp
operator|==
literal|0
condition|)
block|{
comment|/* compressing */
specifier|register
name|int
name|flag
init|=
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hsize
condition|;
name|i
operator|++
control|)
block|{
comment|/* build sort pointers */
if|if
condition|(
operator|(
name|long
operator|)
name|htabof
argument_list|(
name|i
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|sorttab
index|[
name|codetabof
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
name|first
operator|=
name|block_compress
condition|?
name|FIRST
else|:
literal|256
expr_stmt|;
for|for
control|(
name|i
operator|=
name|first
init|;
name|i
operator|<
name|free_ent
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%5d: \""
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'\n'
expr_stmt|;
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'"'
expr_stmt|;
name|stack_top
operator|=
name|in_stack
argument_list|(
operator|(
name|htabof
argument_list|(
name|sorttab
index|[
name|i
index|]
argument_list|)
operator|>>
name|maxbits
operator|)
operator|&
literal|0xff
argument_list|,
name|stack_top
argument_list|)
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|htabof
argument_list|(
name|sorttab
index|[
name|i
index|]
argument_list|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|maxbits
operator|)
operator|-
literal|1
operator|)
init|;
name|ent
operator|>
literal|256
condition|;
name|ent
operator|=
name|htabof
argument_list|(
name|sorttab
index|[
name|ent
index|]
argument_list|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|maxbits
operator|)
operator|-
literal|1
operator|)
control|)
block|{
name|stack_top
operator|=
name|in_stack
argument_list|(
name|htabof
argument_list|(
name|sorttab
index|[
name|ent
index|]
argument_list|)
operator|>>
name|maxbits
argument_list|,
name|stack_top
argument_list|)
expr_stmt|;
block|}
name|stack_top
operator|=
name|in_stack
argument_list|(
name|ent
argument_list|,
name|stack_top
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|de_stack
index|[
name|stack_top
index|]
argument_list|,
literal|1
argument_list|,
name|STACK_SIZE
operator|-
name|stack_top
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|stack_top
operator|=
name|STACK_SIZE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|debug
condition|)
block|{
comment|/* decompressing */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|free_ent
condition|;
name|i
operator|++
control|)
block|{
name|ent
operator|=
name|i
expr_stmt|;
name|c
operator|=
name|tab_suffixof
argument_list|(
name|ent
argument_list|)
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%5d: %5d/'%c'  \""
argument_list|,
name|ent
argument_list|,
name|tab_prefixof
argument_list|(
name|ent
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%5d: %5d/\\%03o \""
argument_list|,
name|ent
argument_list|,
name|tab_prefixof
argument_list|(
name|ent
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'\n'
expr_stmt|;
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'"'
expr_stmt|;
for|for
control|(
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
operator|(
name|ent
operator|>=
name|FIRST
condition|?
name|tab_prefixof
argument_list|(
name|ent
argument_list|)
else|:
name|NULL
operator|)
control|)
block|{
name|stack_top
operator|=
name|in_stack
argument_list|(
name|tab_suffixof
argument_list|(
name|ent
argument_list|)
argument_list|,
name|stack_top
argument_list|)
expr_stmt|;
block|}
name|fwrite
argument_list|(
operator|&
name|de_stack
index|[
name|stack_top
index|]
argument_list|,
literal|1
argument_list|,
name|STACK_SIZE
operator|-
name|stack_top
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|stack_top
operator|=
name|STACK_SIZE
expr_stmt|;
block|}
block|}
block|}
name|int
name|in_stack
parameter_list|(
name|c
parameter_list|,
name|stack_top
parameter_list|)
function|register c
operator|,
function|stack_top;
block|{
if|if
condition|(
operator|(
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
name|isprint
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'\\'
operator|)
operator|||
name|c
operator|==
literal|' '
condition|)
block|{
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'n'
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'t'
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'f'
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'r'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'\\'
expr_stmt|;
break|break;
default|default:
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'0'
operator|+
name|c
operator|%
literal|8
expr_stmt|;
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'0'
operator|+
operator|(
name|c
operator|/
literal|8
operator|)
operator|%
literal|8
expr_stmt|;
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'0'
operator|+
name|c
operator|/
literal|64
expr_stmt|;
break|break;
block|}
name|de_stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'\\'
expr_stmt|;
block|}
return|return
name|stack_top
return|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
name|writeerr
argument_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"compress: %s: %s\n"
argument_list|,
name|ofname
index|[
literal|0
index|]
condition|?
name|ofname
else|:
literal|"stdout"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|copystat
argument_list|(
argument|ifname
argument_list|,
argument|ofname
argument_list|)
name|char
modifier|*
name|ifname
decl_stmt|,
modifier|*
name|ofname
decl_stmt|;
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|utimbuf
name|tp
decl_stmt|;
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|ifname
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
block|{
comment|/* Get stat on input file */
name|perror
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
comment|/*0170000*/
operator|)
operator|!=
name|S_IFREG
comment|/*0100000*/
condition|)
block|{
if|if
condition|(
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -- not a regular file: unchanged"
argument_list|)
expr_stmt|;
name|exit_stat
operator|=
literal|1
expr_stmt|;
name|perm_stat
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|statbuf
operator|.
name|st_nlink
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -- has %d other links: unchanged"
argument_list|,
name|statbuf
operator|.
name|st_nlink
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit_stat
operator|=
literal|1
expr_stmt|;
name|perm_stat
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exit_stat
operator|==
literal|2
operator|&&
operator|(
operator|!
name|force
operator|)
condition|)
block|{
comment|/* No compression: remove file.Z */
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -- file unchanged"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ***** Successful Compression ***** */
name|exit_stat
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
name|statbuf
operator|.
name|st_mode
operator|&
literal|07777
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|ofname
argument_list|,
name|mode
argument_list|)
condition|)
comment|/* Copy modes */
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|chown
argument_list|(
name|ofname
argument_list|,
name|statbuf
operator|.
name|st_uid
argument_list|,
name|statbuf
operator|.
name|st_gid
argument_list|)
expr_stmt|;
comment|/* Copy ownership */
name|tp
operator|.
name|actime
operator|=
name|statbuf
operator|.
name|st_atime
expr_stmt|;
name|tp
operator|.
name|modtime
operator|=
name|statbuf
operator|.
name|st_mtime
expr_stmt|;
name|utime
argument_list|(
name|ofname
argument_list|,
operator|&
name|tp
argument_list|)
expr_stmt|;
comment|/* Update last accessed and modified times */
if|if
condition|(
name|unlink
argument_list|(
name|ifname
argument_list|)
condition|)
comment|/* Remove input file */
name|perror
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -- replaced with %s"
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
return|return;
comment|/* Successful return */
block|}
comment|/* Unsuccessful return -- one of the tests failed */
if|if
condition|(
name|unlink
argument_list|(
name|ofname
argument_list|)
condition|)
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
block|}
name|void
name|onintr
parameter_list|( )
block|{
if|if
condition|(
operator|!
name|precious
condition|)
name|unlink
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|void
name|oops
parameter_list|( )
comment|/* wild pointer -- assume bad input */
block|{
if|if
condition|(
name|do_decomp
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"uncompress: corrupt input\n"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cl_block
argument_list|()
comment|/* table clear for block compress */
block|{
specifier|register
name|long
name|int
name|rat
decl_stmt|;
name|checkpoint
operator|=
name|in_count
operator|+
name|CHECK_GAP
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"count: %ld, ratio: "
argument_list|,
name|in_count
argument_list|)
expr_stmt|;
name|prratio
argument_list|(
name|stderr
argument_list|,
name|in_count
argument_list|,
name|bytes_out
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|in_count
operator|>
literal|0x007fffff
condition|)
block|{
comment|/* shift will overflow */
name|rat
operator|=
name|bytes_out
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|rat
operator|==
literal|0
condition|)
block|{
comment|/* Don't divide by zero */
name|rat
operator|=
literal|0x7fffffff
expr_stmt|;
block|}
else|else
block|{
name|rat
operator|=
name|in_count
operator|/
name|rat
expr_stmt|;
block|}
block|}
else|else
block|{
name|rat
operator|=
operator|(
name|in_count
operator|<<
literal|8
operator|)
operator|/
name|bytes_out
expr_stmt|;
comment|/* 8 fractional bits */
block|}
if|if
condition|(
name|rat
operator|>
name|ratio
condition|)
block|{
name|ratio
operator|=
name|rat
expr_stmt|;
block|}
else|else
block|{
name|ratio
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|verbose
condition|)
name|dump_tab
argument_list|()
expr_stmt|;
comment|/* dump string table */
endif|#
directive|endif
name|cl_hash
argument_list|(
operator|(
name|count_int
operator|)
name|hsize
argument_list|)
expr_stmt|;
name|free_ent
operator|=
name|FIRST
expr_stmt|;
name|clear_flg
operator|=
literal|1
expr_stmt|;
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|CLEAR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"clear\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
block|}
name|cl_hash
argument_list|(
name|hsize
argument_list|)
comment|/* reset code table */
specifier|register
name|count_int
name|hsize
expr_stmt|;
block|{
specifier|register
name|count_int
modifier|*
name|htab_p
init|=
name|htab
operator|+
name|hsize
decl_stmt|;
specifier|register
name|long
name|i
decl_stmt|;
specifier|register
name|long
name|m1
init|=
operator|-
literal|1
decl_stmt|;
name|i
operator|=
name|hsize
operator|-
literal|16
expr_stmt|;
do|do
block|{
comment|/* might use Sys V memset(3) here */
operator|*
operator|(
name|htab_p
operator|-
literal|16
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|15
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|14
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|13
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|12
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|11
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|10
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|9
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|8
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|7
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|6
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|5
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|4
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|3
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|2
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|1
operator|)
operator|=
name|m1
expr_stmt|;
name|htab_p
operator|-=
literal|16
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|i
operator|-=
literal|16
operator|)
operator|>=
literal|0
condition|)
do|;
for|for
control|(
name|i
operator|+=
literal|16
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
operator|--
name|htab_p
operator|=
name|m1
expr_stmt|;
block|}
name|prratio
argument_list|(
argument|stream
argument_list|,
argument|num
argument_list|,
argument|den
argument_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|long
name|int
name|num
decl_stmt|,
name|den
decl_stmt|;
block|{
specifier|register
name|int
name|q
decl_stmt|;
comment|/* Doesn't need to be long */
if|if
condition|(
name|num
operator|>
literal|214748L
condition|)
block|{
comment|/* 2147483647/10000 */
name|q
operator|=
name|num
operator|/
operator|(
name|den
operator|/
literal|10000L
operator|)
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
literal|10000L
operator|*
name|num
operator|/
name|den
expr_stmt|;
comment|/* Long calculations, though */
block|}
if|if
condition|(
name|q
operator|<
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|'-'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|q
operator|=
operator|-
name|q
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%d.%02d%%"
argument_list|,
name|q
operator|/
literal|100
argument_list|,
name|q
operator|%
literal|100
argument_list|)
expr_stmt|;
block|}
name|usage
argument_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
ifdef|#
directive|ifdef
name|DEBUG
literal|"compress [-CDVcdfnv] [-b maxbits] [file ...]\n"
argument_list|)
expr_stmt|;
else|#
directive|else
literal|"compress [-Ccdfnv] [-b maxbits] [file ...]\n"
block|)
empty_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

