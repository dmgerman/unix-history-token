begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)compress.c	5.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a>b) ? b : a)
end_define

begin_comment
comment|/*  * machine variants which require cc -Dmachine:  pdp11, z8000, pcxt  */
end_comment

begin_comment
comment|/* Set USERMEM to the maximum amount of physical user memory available  * in bytes.  USERMEM is used to determine the maximum BITS that can be used  * for compression.  If USERMEM is big enough, use fast compression algorithm.  *  * SACREDMEM is the amount of physical memory saved for others; compress  * will hog the rest.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SACREDMEM
end_ifndef

begin_define
define|#
directive|define
name|SACREDMEM
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USERMEM
end_ifndef

begin_define
define|#
directive|define
name|USERMEM
value|750000
end_define

begin_comment
comment|/* default user memory */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|pdp11
end_ifdef

begin_define
define|#
directive|define
name|BITS
value|12
end_define

begin_comment
comment|/* max bits/code for 16-bit machine */
end_comment

begin_define
define|#
directive|define
name|NO_UCHAR
end_define

begin_comment
comment|/* also if "unsigned char" functions as signed char */
end_comment

begin_define
define|#
directive|define
name|SHORT_INT
end_define

begin_comment
comment|/* ints are short */
end_comment

begin_undef
undef|#
directive|undef
name|USERMEM
end_undef

begin_endif
endif|#
directive|endif
endif|pdp11
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|z8000
end_ifdef

begin_define
define|#
directive|define
name|BITS
value|12
end_define

begin_define
define|#
directive|define
name|SHORT_INT
end_define

begin_undef
undef|#
directive|undef
name|vax
end_undef

begin_comment
comment|/* weird preprocessor */
end_comment

begin_undef
undef|#
directive|undef
name|USERMEM
end_undef

begin_endif
endif|#
directive|endif
endif|z8000
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|pcxt
end_ifdef

begin_define
define|#
directive|define
name|BITS
value|12
end_define

begin_define
define|#
directive|define
name|SHORT_INT
end_define

begin_define
define|#
directive|define
name|SMALL_STACK
end_define

begin_comment
comment|/* at least for Latice C, sez Lauren */
end_comment

begin_undef
undef|#
directive|undef
name|USERMEM
end_undef

begin_endif
endif|#
directive|endif
endif|pcxt
end_endif

begin_comment
comment|/*   * Define FBITS for machines with several MB of physical memory, to use  * table lookup for (b<= FBITS).  If FBITS is made too large, performance  * will decrease due to increased swapping/paging.  Since the program minus  * the fast lookup table is about a half Meg, we can allocate the rest of  * available physical memory to the fast lookup table.  *   * If FBITS is set to 12, a 2 MB array is allocated, but only 1 MB is  * addressed for parity-free input (i.e. text).  *  * FBITS=10 yields 1/2 meg lookup table + 4K code memory  * FBITS=11 yields 1 meg lookup table + 8K code memory  * FBITS=12 yields 2 meg lookup table + 16K code memory  * FBITS=13 yields 4 meg lookup table + 32K code memory  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USERMEM
end_ifdef

begin_if
if|#
directive|if
name|USERMEM
operator|>=
operator|(
literal|2621440
operator|+
name|SACREDMEM
operator|)
end_if

begin_if
if|#
directive|if
name|USERMEM
operator|>=
operator|(
literal|4718592
operator|+
name|SACREDMEM
operator|)
end_if

begin_define
define|#
directive|define
name|FBITS
value|13
end_define

begin_define
define|#
directive|define
name|PBITS
value|16
end_define

begin_else
else|#
directive|else
else|2.5M<= USERMEM< 4.5M
end_else

begin_define
define|#
directive|define
name|FBITS
value|12
end_define

begin_define
define|#
directive|define
name|PBITS
value|16
end_define

begin_endif
endif|#
directive|endif
endif|USERMEM<=> 4.5M
end_endif

begin_else
else|#
directive|else
else|USERMEM< 2.5M
end_else

begin_if
if|#
directive|if
name|USERMEM
operator|>=
operator|(
literal|1572864
operator|+
name|SACREDMEM
operator|)
end_if

begin_define
define|#
directive|define
name|FBITS
value|11
end_define

begin_define
define|#
directive|define
name|PBITS
value|16
end_define

begin_else
else|#
directive|else
else|USERMEM< 1.5M
end_else

begin_if
if|#
directive|if
name|USERMEM
operator|>=
operator|(
literal|1048576
operator|+
name|SACREDMEM
operator|)
end_if

begin_define
define|#
directive|define
name|FBITS
value|10
end_define

begin_define
define|#
directive|define
name|PBITS
value|16
end_define

begin_else
else|#
directive|else
else|USERMEM< 1M
end_else

begin_if
if|#
directive|if
name|USERMEM
operator|>=
operator|(
literal|631808
operator|+
name|SACREDMEM
operator|)
end_if

begin_define
define|#
directive|define
name|PBITS
value|16
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|USERMEM
operator|>=
operator|(
literal|329728
operator|+
name|SACREDMEM
operator|)
end_if

begin_define
define|#
directive|define
name|PBITS
value|15
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|USERMEM
operator|>=
operator|(
literal|178176
operator|+
name|SACREDMEM
operator|)
end_if

begin_define
define|#
directive|define
name|PBITS
value|14
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|USERMEM
operator|>=
operator|(
literal|99328
operator|+
name|SACREDMEM
operator|)
end_if

begin_define
define|#
directive|define
name|PBITS
value|13
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PBITS
value|12
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|USERMEM
end_undef

begin_endif
endif|#
directive|endif
endif|USERMEM<=> 1M
end_endif

begin_endif
endif|#
directive|endif
endif|USERMEM<=> 1.5M
end_endif

begin_endif
endif|#
directive|endif
endif|USERMEM<=> 2.5M
end_endif

begin_endif
endif|#
directive|endif
endif|USERMEM
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PBITS
end_ifdef

begin_comment
comment|/* Preferred BITS for this memory size */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BITS
end_ifndef

begin_define
define|#
directive|define
name|BITS
value|PBITS
end_define

begin_endif
endif|#
directive|endif
endif|BITS
end_endif

begin_endif
endif|#
directive|endif
endif|PBITS
end_endif

begin_if
if|#
directive|if
name|BITS
operator|==
literal|16
end_if

begin_define
define|#
directive|define
name|HSIZE
value|69001
end_define

begin_comment
comment|/* 95% occupancy */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|BITS
operator|==
literal|15
end_if

begin_define
define|#
directive|define
name|HSIZE
value|35023
end_define

begin_comment
comment|/* 94% occupancy */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|BITS
operator|==
literal|14
end_if

begin_define
define|#
directive|define
name|HSIZE
value|18013
end_define

begin_comment
comment|/* 91% occupancy */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|BITS
operator|==
literal|13
end_if

begin_define
define|#
directive|define
name|HSIZE
value|9001
end_define

begin_comment
comment|/* 91% occupancy */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|BITS
operator|<=
literal|12
end_if

begin_define
define|#
directive|define
name|HSIZE
value|5003
end_define

begin_comment
comment|/* 80% occupancy */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BITS< 9 will cause an error */
end_comment

begin_comment
comment|/*  * a code_int must be able to hold 2**BITS values of type int, and also -1  */
end_comment

begin_if
if|#
directive|if
name|BITS
operator|>
literal|15
end_if

begin_typedef
typedef|typedef
name|long
name|int
name|code_int
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|int
name|code_int
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|interdata
end_ifdef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|int
name|count_int
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|short
name|int
name|count_short
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|long
name|int
name|count_int
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_UCHAR
end_ifdef

begin_typedef
typedef|typedef
name|char
name|char_type
typedef|;
end_typedef

begin_else
else|#
directive|else
else|UCHAR
end_else

begin_typedef
typedef|typedef
name|unsigned
name|char
name|char_type
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
endif|UCHAR
end_endif

begin_decl_stmt
name|char_type
name|magic_header
index|[]
init|=
block|{
literal|"\037\235"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1F 9D */
end_comment

begin_comment
comment|/* Defines for third byte of header */
end_comment

begin_define
define|#
directive|define
name|BIT_MASK
value|0x1f
end_define

begin_define
define|#
directive|define
name|BLOCK_MASK
value|0x80
end_define

begin_comment
comment|/* Masks 0x40 and 0x20 are free.  I think 0x20 should mean that there is    a fourth header byte (for expansion). */
end_comment

begin_define
define|#
directive|define
name|INIT_BITS
value|9
end_define

begin_comment
comment|/* initial number of bits/code */
end_comment

begin_comment
comment|/*  * compress.c - File compression ala IEEE Computer, June 1984.  *  * Authors:	Spencer W. Thomas	(decvax!harpo!utah-cs!utah-gr!thomas)  *		Jim McKie		(decvax!mcvax!jim)  *		Steve Davies		(decvax!vax135!petsd!peora!srd)  *		Ken Turkowski		(decvax!decwrl!turtlevax!ken)  *		James A. Woods		(decvax!ihnp4!ames!jaw)  *		Joe Orost		(decvax!vax135!petsd!joe)  *  * $Header: compress.c,v 3.2 85/06/06 21:53:24 jaw Exp $  * $Log:	compress.c,v $  * Revision 3.2  85/06/06  21:53:24  jaw  * Incorporate portability suggestions for Z8000, IBM PC/XT from mailing list.  * Default to "quiet" output (no compression statistics).  *  * Revision 3.1  85/05/12  18:56:13  jaw  * Integrate decompress() stack speedups (from early pointer mods by McKie).  * Repair multi-file USERMEM gaffe.  Unify 'force' flags to mimic semantics  * of SVR2 'pack'.  Streamline block-compress table clear logic.  Increase   * output byte count by magic number size.  *   * Revision 3.0   84/11/27  11:50:00  petsd!joe  * Set HSIZE depending on BITS.  Set BITS depending on USERMEM.  Unrolled  * loops in clear routines.  Added "-C" flag for 2.0 compatibility.  Used  * unsigned compares on Perkin-Elmer.  Fixed foreground check.  *  * Revision 2.7   84/11/16  19:35:39  ames!jaw  * Cache common hash codes based on input statistics; this improves  * performance for low-density raster images.  Pass on #ifdef bundle  * from Turkowski.  *  * Revision 2.6   84/11/05  19:18:21  ames!jaw  * Vary size of hash tables to reduce time for small files.  * Tune PDP-11 hash function.  *  * Revision 2.5   84/10/30  20:15:14  ames!jaw  * Junk chaining; replace with the simpler (and, on the VAX, faster)  * double hashing, discussed within.  Make block compression standard.  *  * Revision 2.4   84/10/16  11:11:11  ames!jaw  * Introduce adaptive reset for block compression, to boost the rate  * another several percent.  (See mailing list notes.)  *  * Revision 2.3   84/09/22  22:00:00  petsd!joe  * Implemented "-B" block compress.  Implemented REVERSE sorting of tab_next.  * Bug fix for last bits.  Changed fwrite to putchar loop everywhere.  *  * Revision 2.2   84/09/18  14:12:21  ames!jaw  * Fold in news changes, small machine typedef from thomas,  * #ifdef interdata from joe.  *  * Revision 2.1   84/09/10  12:34:56  ames!jaw  * Configured fast table lookup for 32-bit machines.  * This cuts user time in half for b<= FBITS, and is useful for news batching  * from VAX to PDP sites.  Also sped up decompress() [fwrite->putc] and  * added signal catcher [plus beef in writeerr()] to delete effluvia.  *  * Revision 2.0   84/08/28  22:00:00  petsd!joe  * Add check for foreground before prompting user.  Insert maxbits into  * compressed file.  Force file being uncompressed to end with ".Z".  * Added "-c" flag and "zcat".  Prepared for release.  *  * Revision 1.10  84/08/24  18:28:00  turtlevax!ken  * Will only compress regular files (no directories), added a magic number  * header (plus an undocumented -n flag to handle old files without headers),  * added -f flag to force overwriting of possibly existing destination file,  * otherwise the user is prompted for a response.  Will tack on a .Z to a  * filename if it doesn't have one when decompressing.  Will only replace  * file if it was compressed.  *  * Revision 1.9  84/08/16  17:28:00  turtlevax!ken  * Removed scanargs(), getopt(), added .Z extension and unlimited number of  * filenames to compress.  Flags may be clustered (-Ddvb12) or separated  * (-D -d -v -b 12), or combination thereof.  Modes and other status is  * copied with copystat().  -O bug for 4.2 seems to have disappeared with  * 1.8.  *  * Revision 1.8  84/08/09  23:15:00  joe  * Made it compatible with vax version, installed jim's fixes/enhancements  *  * Revision 1.6  84/08/01  22:08:00  joe  * Sped up algorithm significantly by sorting the compress chain.  *  * Revision 1.5  84/07/13  13:11:00  srd  * Added C version of vax asm routines.  Changed structure to arrays to  * save much memory.  Do unsigned compares where possible (faster on  * Perkin-Elmer)  *  * Revision 1.4  84/07/05  03:11:11  thomas  * Clean up the code a little and lint it.  (Lint complains about all  * the regs used in the asm, but I'm not going to "fix" this.)  *  * Revision 1.3  84/07/05  02:06:54  thomas  * Minor fixes.  *  * Revision 1.2  84/07/05  00:27:27  thomas  * Add variable bit length output.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcs_ident
index|[]
init|=
literal|"$Header: compress.c,v 3.1 85/05/12 18:56:13 jaw Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|!lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_define
define|#
directive|define
name|ARGVAL
parameter_list|()
value|(*++(*argv) || (--argc&& *++argv))
end_define

begin_decl_stmt
name|int
name|n_bits
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bits/code */
end_comment

begin_decl_stmt
name|int
name|maxbits
init|=
name|BITS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user settable max # bits/code */
end_comment

begin_decl_stmt
name|code_int
name|maxcode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum code, given n_bits */
end_comment

begin_decl_stmt
name|code_int
name|maxmaxcode
init|=
literal|1
operator|<<
name|BITS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* should NEVER generate this code */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMPATIBLE
end_ifdef

begin_comment
comment|/* But wrong! */
end_comment

begin_define
define|#
directive|define
name|MAXCODE
parameter_list|(
name|n_bits
parameter_list|)
value|(1<< (n_bits) - 1)
end_define

begin_else
else|#
directive|else
else|COMPATIBLE
end_else

begin_define
define|#
directive|define
name|MAXCODE
parameter_list|(
name|n_bits
parameter_list|)
value|((1<< (n_bits)) - 1)
end_define

begin_endif
endif|#
directive|endif
endif|COMPATIBLE
end_endif

begin_comment
comment|/*  * One code could conceivably represent (1<<BITS) characters, but  * to get a code of length N requires an input string of at least  * N*(N-1)/2 characters.  With 5000 chars in the stack, an input  * file would have to contain a 25Mb string of a single character.  * This seems unlikely.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SHORT_INT
end_ifdef

begin_define
define|#
directive|define
name|MAXSTACK
value|5000
end_define

begin_comment
comment|/* size of output stack */
end_comment

begin_else
else|#
directive|else
else|!SHORT_INT
end_else

begin_define
define|#
directive|define
name|MAXSTACK
value|8000
end_define

begin_comment
comment|/* size of output stack */
end_comment

begin_endif
endif|#
directive|endif
endif|!SHORT_INT
end_endif

begin_decl_stmt
name|count_int
name|htab
index|[
name|HSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|codetab
index|[
name|HSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|code_int
name|hsize
init|=
name|HSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for dynamic table sizing */
end_comment

begin_decl_stmt
name|count_int
name|fsize
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|tab_prefix
value|codetab
end_define

begin_comment
comment|/* prefix code for this entry */
end_comment

begin_decl_stmt
name|char_type
name|tab_suffix
index|[
literal|1
operator|<<
name|BITS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last char in this entry */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USERMEM
end_ifdef

begin_decl_stmt
name|short
name|ftable
index|[
operator|(
literal|1
operator|<<
name|FBITS
operator|)
operator|*
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|count_int
name|fcodemem
index|[
literal|1
operator|<<
name|FBITS
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|USERMEM
end_endif

begin_decl_stmt
name|code_int
name|free_ent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first unused entry */
end_comment

begin_decl_stmt
name|int
name|exit_stat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|code_int
name|getcode
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|Usage
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: compress [-dDVfc] [-b maxbits] [file ...]\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
else|DEBUG
end_else

begin_expr_stmt
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: compress [-dfvc] [-b maxbits] [file ...]\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
unit|}
endif|#
directive|endif
endif|DEBUG
end_endif

begin_expr_stmt
unit|int
name|nomagic
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Use a 3-byte magic number header, unless old file */
end_comment

begin_decl_stmt
name|int
name|zcat_flg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Write output on stdout, suppress messages */
end_comment

begin_decl_stmt
name|int
name|quiet
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't tell me about compression */
end_comment

begin_comment
comment|/*  * block compression parameters -- after all codes are used up,  * and compression rate changes, start over.  */
end_comment

begin_decl_stmt
name|int
name|block_compress
init|=
name|BLOCK_MASK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|clear_flg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|ratio
init|=
literal|0.0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* compression ratio for last block */
end_comment

begin_define
define|#
directive|define
name|CHECK_GAP
value|10000
end_define

begin_comment
comment|/* ratio check interval */
end_comment

begin_decl_stmt
name|count_int
name|checkpoint
init|=
name|CHECK_GAP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * the next two codes should not be changed lightly, as they must not  * lie within the contiguous general code space.  */
end_comment

begin_define
define|#
directive|define
name|FIRST
value|257
end_define

begin_comment
comment|/* first free entry */
end_comment

begin_define
define|#
directive|define
name|CLEAR
value|256
end_define

begin_comment
comment|/* table clear output code */
end_comment

begin_decl_stmt
name|int
name|force
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ofname
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

begin_function_decl
name|int
function_decl|(
modifier|*
name|bgnd_flag
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|nfiles
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of files processed */
end_comment

begin_comment
comment|/*****************************************************************  * TAG( main )  *  * Algorithm from "A Technique for High Performance Data Compression",  * Terry A. Welch, IEEE Computer Vol 17, No 6 (June 1984), pp 8-19.  *  * Usage: compress [-dfvc] [-b bits] [file ...]  * Inputs:  *	-d:	    If given, decompression is done instead.  *  *      -c:         Write output on stdout, don't remove original.  *  *      -b:         Parameter limits the max number of bits/code.  *  *	-f:	    Forces output file to be generated, even if one already  *		    exists, and even if no space is saved by compressing.  *		    If -f is not used, the user will be prompted if stdin is  *		    a tty, otherwise, the output file will not be overwritten.  *  *      -v:	    Write compression statistics  *  * 	file ...:   Files to be compressed.  If none specified, stdin  *		    is used.  * Outputs:  *	file.Z:	    Compressed form of file with same mode, owner, and utimes  * 	or stdout   (if stdin used as input)  *  * Assumptions:  *	When filenames are given, replaces with the compressed version  *	(.Z suffix) only if the file decreases in size.  * Algorithm:  * 	Modified Lempel-Ziv method (LZW).  Basically finds common  * substrings and replaces them with a variable size code.  This is  * deterministic, and can be done on the fly.  Thus, the decompression  * procedure needs no input table, but tracks the way the table was built.  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
specifier|register
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|do_decomp
init|=
literal|0
decl_stmt|;
name|int
name|overwrite
init|=
literal|0
decl_stmt|;
comment|/* Do not overwrite unless given -f flag */
name|char
name|tempname
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|filelist
decl_stmt|,
modifier|*
modifier|*
name|fileptr
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|,
modifier|*
name|malloc
argument_list|()
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
extern|extern onintr(
block|)
function|;
end_function

begin_if
if|if
condition|(
operator|(
name|bgnd_flag
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|COMPATIBLE
end_ifdef

begin_expr_stmt
name|nomagic
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Original didn't have a magic number */
end_comment

begin_endif
endif|#
directive|endif
endif|COMPATIBLE
end_endif

begin_expr_stmt
name|filelist
operator|=
name|fileptr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|malloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|filelist
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"uncompress"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|do_decomp
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"zcat"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|do_decomp
operator|=
literal|1
expr_stmt|;
name|zcat_flg
operator|=
literal|1
expr_stmt|;
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_2
end_ifdef

begin_comment
comment|/* 4.2BSD dependent - take it out if not */
end_comment

begin_expr_stmt
name|setlinebuf
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
endif|BSD4_2
end_endif

begin_comment
comment|/* Argument Processing      * All flags are optional.      * -D => debug      * -V => debug verbose      * -d => do_decomp      * -v => unquiet      * -f => force overwrite of output file      * -n => no header: useful to uncompress old files      * -b maxbits => maxbits.  If -b is specified, then maxbits MUST be      *	    given also.      * -c => cat all output to stdout      * -C => generate output compatible with compress 2.0.      * if a string is left, must be an input filename.      */
end_comment

begin_for
for|for
control|(
name|argc
operator|--
operator|,
name|argv
operator|++
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
comment|/* A flag argument */
while|while
condition|(
operator|*
operator|++
operator|(
operator|*
name|argv
operator|)
condition|)
block|{
comment|/* Process all flags in this arg */
switch|switch
condition|(
operator|*
operator|*
name|argv
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'D'
case|:
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
endif|DEBUG
case|case
literal|'v'
case|:
name|quiet
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|do_decomp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|overwrite
operator|=
literal|1
expr_stmt|;
name|force
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|nomagic
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|block_compress
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
operator|!
name|ARGVAL
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Missing maxbits\n"
argument_list|)
expr_stmt|;
name|Usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|maxbits
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
goto|goto
name|nextarg
goto|;
case|case
literal|'c'
case|:
name|zcat_flg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown flag: '%c'; "
argument_list|,
operator|*
operator|*
name|argv
argument_list|)
expr_stmt|;
name|Usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Input file name */
operator|*
name|fileptr
operator|++
operator|=
operator|*
name|argv
expr_stmt|;
comment|/* Build input file list */
operator|*
name|fileptr
operator|=
name|NULL
expr_stmt|;
comment|/* goto nextarg; */
block|}
name|nextarg
label|:
continue|continue;
block|}
end_for

begin_if
if|if
condition|(
name|maxbits
operator|<
name|INIT_BITS
condition|)
name|maxbits
operator|=
name|INIT_BITS
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|maxbits
operator|>
name|BITS
condition|)
name|maxbits
operator|=
name|BITS
expr_stmt|;
end_if

begin_expr_stmt
name|maxmaxcode
operator|=
literal|1
operator|<<
name|maxbits
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|*
name|filelist
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|fileptr
operator|=
name|filelist
init|;
operator|*
name|fileptr
condition|;
name|fileptr
operator|++
control|)
block|{
name|exit_stat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|do_decomp
operator|!=
literal|0
condition|)
block|{
comment|/* DECOMPRESSION */
comment|/* Check for .Z suffix */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|fileptr
operator|+
name|strlen
argument_list|(
operator|*
name|fileptr
argument_list|)
operator|-
literal|2
argument_list|,
literal|".Z"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* No .Z: tack one on */
name|strcpy
argument_list|(
name|tempname
argument_list|,
operator|*
name|fileptr
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tempname
argument_list|,
literal|".Z"
argument_list|)
expr_stmt|;
operator|*
name|fileptr
operator|=
name|tempname
expr_stmt|;
block|}
comment|/* Open input file */
if|if
condition|(
operator|(
name|freopen
argument_list|(
operator|*
name|fileptr
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
operator|*
name|fileptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Check the magic number */
if|if
condition|(
name|nomagic
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|getchar
argument_list|()
operator|!=
operator|(
name|magic_header
index|[
literal|0
index|]
operator|&
literal|0xFF
operator|)
operator|)
operator|||
operator|(
name|getchar
argument_list|()
operator|!=
operator|(
name|magic_header
index|[
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: not in compressed format\n"
argument_list|,
operator|*
name|fileptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|maxbits
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* set -b from file */
name|block_compress
operator|=
name|maxbits
operator|&
name|BLOCK_MASK
expr_stmt|;
name|maxbits
operator|&=
name|BIT_MASK
expr_stmt|;
name|maxmaxcode
operator|=
literal|1
operator|<<
name|maxbits
expr_stmt|;
if|if
condition|(
name|maxbits
operator|>
name|BITS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: compressed with %d bits, can only handle %d bits\n"
argument_list|,
operator|*
name|fileptr
argument_list|,
name|maxbits
argument_list|,
name|BITS
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Generate output filename */
name|strcpy
argument_list|(
name|ofname
argument_list|,
operator|*
name|fileptr
argument_list|)
expr_stmt|;
name|ofname
index|[
name|strlen
argument_list|(
operator|*
name|fileptr
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Strip off .Z */
block|}
else|else
block|{
comment|/* COMPRESSION */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|fileptr
operator|+
name|strlen
argument_list|(
operator|*
name|fileptr
argument_list|)
operator|-
literal|2
argument_list|,
literal|".Z"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: already has .Z suffix -- no change\n"
argument_list|,
operator|*
name|fileptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Open input file */
if|if
condition|(
operator|(
name|freopen
argument_list|(
operator|*
name|fileptr
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
operator|*
name|fileptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|stat
argument_list|(
operator|*
name|fileptr
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
name|fsize
operator|=
operator|(
name|long
operator|)
name|statbuf
operator|.
name|st_size
expr_stmt|;
comment|/* 		 * tune hash table size for small files -- ad hoc 		 */
name|hsize
operator|=
name|HSIZE
expr_stmt|;
if|if
condition|(
name|fsize
operator|<
operator|(
literal|1
operator|<<
literal|12
operator|)
condition|)
name|hsize
operator|=
name|min
argument_list|(
literal|5003
argument_list|,
name|HSIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fsize
operator|<
operator|(
literal|1
operator|<<
literal|13
operator|)
condition|)
name|hsize
operator|=
name|min
argument_list|(
literal|9001
argument_list|,
name|HSIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fsize
operator|<
operator|(
literal|1
operator|<<
literal|14
operator|)
condition|)
name|hsize
operator|=
name|min
argument_list|(
literal|18013
argument_list|,
name|HSIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fsize
operator|<
operator|(
literal|1
operator|<<
literal|15
operator|)
condition|)
name|hsize
operator|=
name|min
argument_list|(
literal|35023
argument_list|,
name|HSIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fsize
operator|<
literal|47000
condition|)
name|hsize
operator|=
name|min
argument_list|(
literal|50021
argument_list|,
name|HSIZE
argument_list|)
expr_stmt|;
comment|/* Generate output filename */
name|strcpy
argument_list|(
name|ofname
argument_list|,
operator|*
name|fileptr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|BSD4_2
comment|/* Short filenames */
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|ofname
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cp
operator|++
expr_stmt|;
else|else
name|cp
operator|=
name|ofname
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|>
literal|12
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: filename too long to tack on .Z\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
endif|BSD4_2
comment|/* Long filenames allowed */
name|strcat
argument_list|(
name|ofname
argument_list|,
literal|".Z"
argument_list|)
expr_stmt|;
block|}
comment|/* Check for overwrite of existing file */
if|if
condition|(
name|overwrite
operator|==
literal|0
operator|&&
name|zcat_flg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|ofname
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|response
index|[
literal|2
index|]
decl_stmt|;
name|response
index|[
literal|0
index|]
operator|=
literal|'n'
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s already exists;"
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
if|if
condition|(
name|foreground
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" do you wish to overwrite %s (y or n)? "
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|read
argument_list|(
literal|2
argument_list|,
name|response
argument_list|,
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|response
index|[
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
literal|2
argument_list|,
name|response
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Ack! */
name|perror
argument_list|(
literal|"stderr"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|response
index|[
literal|0
index|]
operator|!=
literal|'y'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tnot overwritten\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
if|if
condition|(
name|zcat_flg
operator|==
literal|0
condition|)
block|{
comment|/* Open output file */
if|if
condition|(
name|freopen
argument_list|(
name|ofname
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
operator|*
name|fileptr
argument_list|)
expr_stmt|;
block|}
comment|/* Actually do the compression/decompression */
if|if
condition|(
name|do_decomp
operator|==
literal|0
condition|)
name|compress
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG
else|else
name|decompress
argument_list|()
expr_stmt|;
else|#
directive|else
else|DEBUG
elseif|else
if|if
condition|(
name|debug
operator|==
literal|0
condition|)
name|decompress
argument_list|()
expr_stmt|;
else|else
name|printcodes
argument_list|()
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|dump_tab
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|zcat_flg
operator|==
literal|0
condition|)
block|{
name|copystat
argument_list|(
operator|*
name|fileptr
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
comment|/* Copy stats */
if|if
condition|(
name|exit_stat
operator|||
operator|(
operator|!
name|quiet
operator|)
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Standard input */
if|if
condition|(
name|do_decomp
operator|==
literal|0
condition|)
block|{
name|compress
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check the magic number */
if|if
condition|(
name|nomagic
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|getchar
argument_list|()
operator|!=
operator|(
name|magic_header
index|[
literal|0
index|]
operator|&
literal|0xFF
operator|)
operator|)
operator|||
operator|(
name|getchar
argument_list|()
operator|!=
operator|(
name|magic_header
index|[
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"stdin: not in compressed format\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|maxbits
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* set -b from file */
name|block_compress
operator|=
name|maxbits
operator|&
name|BLOCK_MASK
expr_stmt|;
name|maxbits
operator|&=
name|BIT_MASK
expr_stmt|;
name|maxmaxcode
operator|=
literal|1
operator|<<
name|maxbits
expr_stmt|;
name|fsize
operator|=
literal|100000
expr_stmt|;
comment|/* assume stdin large for USERMEM */
if|if
condition|(
name|maxbits
operator|>
name|BITS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"stdin: compressed with %d bits, can only handle %d bits\n"
argument_list|,
name|maxbits
argument_list|,
name|BITS
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|DEBUG
name|decompress
argument_list|()
expr_stmt|;
else|#
directive|else
else|DEBUG
if|if
condition|(
name|debug
operator|==
literal|0
condition|)
name|decompress
argument_list|()
expr_stmt|;
else|else
name|printcodes
argument_list|()
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|dump_tab
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
block|}
end_if

begin_expr_stmt
name|exit
argument_list|(
name|exit_stat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
unit|}  static
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|int
name|in_count
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of input */
end_comment

begin_decl_stmt
name|long
name|int
name|bytes_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of compressed output */
end_comment

begin_decl_stmt
name|long
name|int
name|out_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of codes output (for debugging) */
end_comment

begin_define
define|#
directive|define
name|HOG_CHECK
value|((count_int) 2000)
end_define

begin_comment
comment|/* Number of chars to read b4 check */
end_comment

begin_define
define|#
directive|define
name|MAX_CACHE
value|((count_int) 1<<BITS)
end_define

begin_comment
comment|/* Next line is this constant too */
end_comment

begin_decl_stmt
name|unsigned
name|short
name|hashcache
index|[
literal|1
operator|<<
name|BITS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* common hash short circuit cache */
end_comment

begin_decl_stmt
name|count_int
name|cfreq
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* character counts */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|vax
end_ifndef

begin_decl_stmt
name|char
name|chog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* most common character from input */
end_comment

begin_define
define|#
directive|define
name|CHOG
value|' '
end_define

begin_comment
comment|/* Assume space is most frequent */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|chog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* char arith slow on VAX */
end_comment

begin_define
define|#
directive|define
name|CHOG
value|(int) ' '
end_define

begin_comment
comment|/* Assume space is most frequent */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|cstat_flg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* on after determining char hog */
end_comment

begin_comment
comment|/*  * compress stdin to stdout  *  * Algorithm:  on large machines, for maxbits<= FBITS, use fast direct table  * lookup on the prefix code / next character combination.  For smaller code  * size, use open addressing modular division double hashing (no chaining), ala  * Knuth vol. 3, sec. 6.4 Algorithm D, along with G. Knott's relatively-prime  * secondary probe.  Do block compression with an adaptive reset, whereby the  * code table is cleared when the compression ratio decreases, but after the  * table fills.  The variable-length output codes are re-sized at this point,  * and a special CLEAR code is generated for the decompressor.  For the  * megamemory version, the sparse array is cleared indirectly through a  * "shadow" output code history.  Late additions: for the hashing code,  * construct the table according to file size for noticeable speed improvement  * on small files.  Also detect and cache codes associated with the most  * common character to bypass hash calculation on these codes (a characteristic  * of highly-compressable raster images).  Please direct questions about this  * implementation to ames!jaw.  */
end_comment

begin_macro
name|compress
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|long
name|fcode
decl_stmt|;
specifier|register
name|code_int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|code_int
name|ent
decl_stmt|;
specifier|register
name|int
name|disp
decl_stmt|;
specifier|register
name|code_int
name|hsize_reg
decl_stmt|;
ifndef|#
directive|ifndef
name|COMPATIBLE
if|if
condition|(
name|nomagic
operator|==
literal|0
condition|)
block|{
name|putchar
argument_list|(
name|magic_header
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|magic_header
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
call|(
name|char
call|)
argument_list|(
name|maxbits
operator||
name|block_compress
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|COMPATIBLE
name|offset
operator|=
literal|0
expr_stmt|;
name|bytes_out
operator|=
literal|3
expr_stmt|;
comment|/* includes 3-byte header mojo */
name|out_count
operator|=
literal|0
expr_stmt|;
name|clear_flg
operator|=
literal|0
expr_stmt|;
name|ratio
operator|=
literal|0.0
expr_stmt|;
name|in_count
operator|=
literal|1
expr_stmt|;
name|checkpoint
operator|=
name|CHECK_GAP
expr_stmt|;
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
operator|=
name|INIT_BITS
argument_list|)
expr_stmt|;
name|free_ent
operator|=
operator|(
operator|(
name|block_compress
operator|)
condition|?
name|FIRST
else|:
literal|256
operator|)
expr_stmt|;
name|ent
operator|=
name|getchar
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USERMEM
if|if
condition|(
name|maxbits
operator|<=
name|FBITS
operator|&&
operator|(
name|fsize
operator|>=
literal|30000
operator|)
condition|)
block|{
comment|/* use hashing on small files */
if|if
condition|(
name|nfiles
operator|++
operator|>
literal|0
condition|)
comment|/* clear table between files */
name|cl_sparse
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
operator|(
name|unsigned
operator|)
name|EOF
condition|)
block|{
name|in_count
operator|++
expr_stmt|;
name|fcode
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|c
operator|<<
name|maxbits
operator|)
operator|+
name|ent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftable
index|[
name|fcode
index|]
operator|!=
literal|0
condition|)
comment|/* test for code in "string" table */
name|ent
operator|=
name|ftable
index|[
name|fcode
index|]
expr_stmt|;
else|else
block|{
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
name|out_count
operator|++
expr_stmt|;
name|ent
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|free_ent
operator|>=
name|maxmaxcode
condition|)
block|{
if|if
condition|(
operator|(
name|count_int
operator|)
name|in_count
operator|<
name|checkpoint
operator|||
operator|(
operator|!
name|block_compress
operator|)
condition|)
continue|continue;
else|else
block|{
name|cl_block
argument_list|()
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* put code in table */
name|ftable
index|[
name|fcode
index|]
operator|=
operator|(
name|short
operator|)
name|free_ent
operator|++
expr_stmt|;
name|fcodemem
index|[
name|i
operator|++
index|]
operator|=
name|fcode
expr_stmt|;
comment|/* memorize for block compression */
block|}
block|}
block|}
goto|goto
name|fin
goto|;
block|}
endif|#
directive|endif
endif|USERMEM
name|chog
operator|=
name|CHOG
expr_stmt|;
comment|/* assumed character for the hog */
name|cstat_flg
operator|=
literal|0
expr_stmt|;
name|hsize_reg
operator|=
name|hsize
expr_stmt|;
name|cl_hash
argument_list|(
operator|(
name|count_int
operator|)
name|hsize_reg
argument_list|)
expr_stmt|;
comment|/* clear hash tables */
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
operator|(
name|unsigned
operator|)
name|EOF
condition|)
block|{
name|in_count
operator|++
expr_stmt|;
if|if
condition|(
name|cstat_flg
operator|==
literal|0
condition|)
block|{
name|cfreq
index|[
name|c
index|]
operator|++
expr_stmt|;
comment|/* gather frequencies at start of input */
if|if
condition|(
operator|(
name|count_int
operator|)
name|in_count
operator|>
name|HOG_CHECK
condition|)
block|{
name|cstat_flg
operator|=
literal|1
expr_stmt|;
name|chog
operator|=
name|hogtally
argument_list|()
expr_stmt|;
comment|/* compute char hog */
if|if
condition|(
name|chog
operator|!=
name|CHOG
condition|)
comment|/* fixup for wrong assumption */
name|cl_cache
argument_list|(
operator|(
name|count_int
operator|)
name|free_ent
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
name|chog
condition|)
if|if
condition|(
operator|(
name|i
operator|=
name|hashcache
index|[
name|ent
index|]
operator|)
condition|)
block|{
comment|/* cache -> code */
name|ent
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
name|fcode
operator|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|c
operator|<<
name|maxbits
operator|)
operator|+
name|ent
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHORT_INT
name|i
operator|=
operator|(
operator|(
operator|(
name|c
operator|+
literal|12347
operator|)
operator|*
name|ent
operator|)
operator|&
literal|077777
operator|)
operator|%
name|HSIZE
expr_stmt|;
comment|/* avoid 'lrem' call */
else|#
directive|else
else|!SHORT_INT
name|i
operator|=
name|fcode
operator|%
name|hsize_reg
expr_stmt|;
comment|/* division hashing */
endif|#
directive|endif
endif|SHORT_INT
if|if
condition|(
name|htab
index|[
name|i
index|]
operator|==
name|fcode
condition|)
block|{
name|ent
operator|=
name|codetab
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|long
operator|)
name|htab
index|[
name|i
index|]
operator|<
literal|0
condition|)
comment|/* empty slot */
goto|goto
name|nomatch
goto|;
name|disp
operator|=
name|hsize_reg
operator|-
name|i
expr_stmt|;
comment|/* secondary hash (G. Knott) */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|disp
operator|=
literal|1
expr_stmt|;
name|probe
label|:
if|if
condition|(
operator|(
name|i
operator|-=
name|disp
operator|)
operator|<
literal|0
condition|)
name|i
operator|+=
name|hsize_reg
expr_stmt|;
if|if
condition|(
name|htab
index|[
name|i
index|]
operator|==
name|fcode
condition|)
block|{
name|ent
operator|=
name|codetab
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|htab
index|[
name|i
index|]
operator|>
literal|0
condition|)
goto|goto
name|probe
goto|;
name|nomatch
label|:
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
name|out_count
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|interdata
if|if
condition|(
operator|(
name|unsigned
operator|)
name|free_ent
operator|<
operator|(
name|unsigned
operator|)
name|maxmaxcode
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|free_ent
operator|<
name|maxmaxcode
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
name|chog
condition|)
comment|/* code -> cache */
name|hashcache
index|[
name|ent
index|]
operator|=
name|free_ent
expr_stmt|;
comment|/* code -> hashtable */
name|codetab
index|[
name|i
index|]
operator|=
name|free_ent
operator|++
expr_stmt|;
name|htab
index|[
name|i
index|]
operator|=
name|fcode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|count_int
operator|)
name|in_count
operator|>=
name|checkpoint
operator|&&
name|block_compress
condition|)
name|cl_block
argument_list|()
expr_stmt|;
name|ent
operator|=
name|c
expr_stmt|;
block|}
name|fin
label|:
comment|/*      * Put out the final code.      */
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|ent
argument_list|)
expr_stmt|;
name|out_count
operator|++
expr_stmt|;
name|output
argument_list|(
operator|(
name|code_int
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Print out stats on stderr      */
if|if
condition|(
name|zcat_flg
operator|==
literal|0
operator|&&
operator|!
name|quiet
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ld chars in, %ld codes (%ld bytes) out, compression factor %g\n"
argument_list|,
name|in_count
argument_list|,
name|out_count
argument_list|,
name|bytes_out
argument_list|,
operator|(
name|double
operator|)
name|in_count
operator|/
operator|(
name|double
operator|)
name|bytes_out
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tCompression as in compact: %5.2f%%\n"
argument_list|,
literal|100.0
operator|*
operator|(
name|in_count
operator|-
name|bytes_out
operator|)
operator|/
operator|(
name|double
operator|)
name|in_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tLargest code was %d (%d bits)\n"
argument_list|,
name|free_ent
operator|-
literal|1
argument_list|,
name|n_bits
argument_list|)
expr_stmt|;
else|#
directive|else
else|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Compression: %5.2f%%"
argument_list|,
literal|100.0
operator|*
operator|(
name|in_count
operator|-
name|bytes_out
operator|)
operator|/
operator|(
name|double
operator|)
name|in_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
if|if
condition|(
name|bytes_out
operator|>
name|in_count
condition|)
comment|/* exit(2) if no savings */
name|exit_stat
operator|=
literal|2
expr_stmt|;
return|return;
block|}
comment|/*****************************************************************  * TAG( output )  *  * Output the given code.  * Inputs:  * 	code:	A n_bits-bit integer.  If == -1, then EOF.  This assumes  *		that n_bits =< (long)wordsize - 1.  * Outputs:  * 	Outputs code to the file.  * Assumptions:  *	Chars are 8 bits long.  * Algorithm:  * 	Maintain a BITS character long buffer (so that 8 codes will  * fit in it exactly).  Use the VAX insv instruction to insert each  * code in turn.  When the buffer fills up empty it and start over.  */
specifier|static
name|char
name|buf
index|[
name|BITS
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|vax
name|char_type
name|lmask
index|[
literal|9
index|]
init|=
block|{
literal|0xff
block|,
literal|0xfe
block|,
literal|0xfc
block|,
literal|0xf8
block|,
literal|0xf0
block|,
literal|0xe0
block|,
literal|0xc0
block|,
literal|0x80
block|,
literal|0x00
block|}
decl_stmt|;
name|char_type
name|rmask
index|[
literal|9
index|]
init|=
block|{
literal|0x00
block|,
literal|0x01
block|,
literal|0x03
block|,
literal|0x07
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x3f
block|,
literal|0x7f
block|,
literal|0xff
block|}
decl_stmt|;
endif|#
directive|endif
endif|!vax
name|output
argument_list|(
argument|code
argument_list|)
name|code_int
name|code
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
specifier|static
name|int
name|col
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
endif|DEBUG
comment|/*      * On the VAX, it is important to have the register declarations      * in exactly the order given, or the asm will break.      */
specifier|register
name|int
name|r_off
init|=
name|offset
decl_stmt|,
name|bits
init|=
name|n_bits
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|code
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|vax
comment|/* VAX DEPENDENT!! Implementation on other machines may be difficult. 	 * 	 * Translation: Insert BITS bits from the argument starting at 	 * offset bits from the beginning of buf. 	 */
literal|0
expr_stmt|;
comment|/* C compiler bug ?? */
asm|asm( "insv	4(ap),r11,r10,(r9)" );
else|#
directive|else
else|not a vax
comment|/*   * byte/bit numbering on the VAX is simulated by the following code  */
comment|/* 	 * Get to the first byte. 	 */
name|bp
operator|+=
operator|(
name|r_off
operator|>>
literal|3
operator|)
expr_stmt|;
name|r_off
operator|&=
literal|7
expr_stmt|;
comment|/* 	 * Since code is always>= 8 bits, only need to mask the first 	 * hunk on the left. 	 */
operator|*
name|bp
operator|=
operator|(
operator|*
name|bp
operator|&
name|rmask
index|[
name|r_off
index|]
operator|)
operator||
operator|(
name|code
operator|<<
name|r_off
operator|)
operator|&
name|lmask
index|[
name|r_off
index|]
expr_stmt|;
name|bp
operator|++
expr_stmt|;
name|bits
operator|-=
operator|(
literal|8
operator|-
name|r_off
operator|)
expr_stmt|;
name|code
operator|>>=
literal|8
operator|-
name|r_off
expr_stmt|;
comment|/* Get any 8 bit parts in the middle (<=1 for up to 16 bits). */
if|if
condition|(
name|bits
operator|>=
literal|8
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
name|code
expr_stmt|;
name|code
operator|>>=
literal|8
expr_stmt|;
name|bits
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* Last bits. */
if|if
condition|(
name|bits
condition|)
operator|*
name|bp
operator|=
name|code
expr_stmt|;
endif|#
directive|endif
endif|vax
name|offset
operator|+=
name|n_bits
expr_stmt|;
if|if
condition|(
name|offset
operator|==
operator|(
name|n_bits
operator|<<
literal|3
operator|)
condition|)
block|{
name|bp
operator|=
name|buf
expr_stmt|;
name|bits
operator|=
name|n_bits
expr_stmt|;
name|bytes_out
operator|+=
name|bits
expr_stmt|;
do|do
name|putchar
argument_list|(
operator|*
name|bp
operator|++
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|bits
condition|)
do|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|writeerr
argument_list|()
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%5d%c"
argument_list|,
name|code
argument_list|,
operator|(
name|col
operator|+=
literal|6
operator|)
operator|>=
literal|74
condition|?
operator|(
name|col
operator|=
literal|0
operator|,
literal|'\n'
operator|)
else|:
literal|' '
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
comment|/* 	 * If the next entry is going to be too big for the code size, 	 * then increase it, if possible. 	 */
if|if
condition|(
name|free_ent
operator|>
name|maxcode
operator|||
operator|(
name|clear_flg
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* 	     * Write the whole buffer, because the input side won't 	     * discover the size increase until after it has read it. 	     */
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|n_bits
argument_list|,
name|stdout
argument_list|)
operator|!=
name|n_bits
condition|)
name|writeerr
argument_list|()
expr_stmt|;
name|bytes_out
operator|+=
name|n_bits
expr_stmt|;
block|}
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|clear_flg
condition|)
block|{
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
operator|=
name|INIT_BITS
argument_list|)
expr_stmt|;
name|clear_flg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|n_bits
operator|++
expr_stmt|;
if|if
condition|(
name|n_bits
operator|==
name|maxbits
condition|)
name|maxcode
operator|=
name|maxmaxcode
expr_stmt|;
else|else
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChange to %d bits\n"
argument_list|,
name|n_bits
argument_list|)
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
block|}
block|}
else|else
block|{
comment|/* 	 * At EOF, write the rest of the buffer. 	 */
if|if
condition|(
name|offset
operator|>
literal|0
condition|)
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
operator|(
name|offset
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|bytes_out
operator|+=
operator|(
name|offset
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|writeerr
argument_list|()
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SMALL_STACK
name|char_type
name|stack
index|[
name|MAXSTACK
index|]
decl_stmt|;
endif|#
directive|endif
name|decompress
argument_list|()
block|{
specifier|register
name|char_type
modifier|*
name|stackp
decl_stmt|;
specifier|register
name|int
name|finchar
decl_stmt|;
specifier|register
name|code_int
name|code
decl_stmt|,
name|oldcode
decl_stmt|,
name|incode
decl_stmt|;
ifndef|#
directive|ifndef
name|SMALL_STACK
name|char_type
name|stack
index|[
name|MAXSTACK
index|]
decl_stmt|;
endif|#
directive|endif
comment|/*      * As above, initialize the first 256 entries in the table.      */
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
operator|=
name|INIT_BITS
argument_list|)
expr_stmt|;
for|for
control|(
name|code
operator|=
literal|255
init|;
name|code
operator|>=
literal|0
condition|;
name|code
operator|--
control|)
block|{
name|tab_prefix
index|[
name|code
index|]
operator|=
literal|0
expr_stmt|;
name|tab_suffix
index|[
name|code
index|]
operator|=
operator|(
name|char_type
operator|)
name|code
expr_stmt|;
block|}
name|free_ent
operator|=
operator|(
operator|(
name|block_compress
operator|)
condition|?
name|FIRST
else|:
literal|256
operator|)
expr_stmt|;
name|finchar
operator|=
name|oldcode
operator|=
name|getcode
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
operator|(
name|char
operator|)
name|finchar
argument_list|)
expr_stmt|;
comment|/* first code must be 8 bits = char */
name|stackp
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|code
operator|=
name|getcode
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|==
name|CLEAR
operator|)
operator|&&
name|block_compress
condition|)
block|{
for|for
control|(
name|code
operator|=
literal|255
init|;
name|code
operator|>=
literal|0
condition|;
name|code
operator|--
control|)
name|tab_prefix
index|[
name|code
index|]
operator|=
literal|0
expr_stmt|;
name|clear_flg
operator|=
literal|1
expr_stmt|;
name|free_ent
operator|=
name|FIRST
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|getcode
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
comment|/* O, untimely death! */
break|break;
block|}
name|incode
operator|=
name|code
expr_stmt|;
comment|/* 	 * Special case for KwKwK string. 	 */
if|if
condition|(
name|code
operator|>=
name|free_ent
condition|)
block|{
operator|*
name|stackp
operator|++
operator|=
name|finchar
expr_stmt|;
name|code
operator|=
name|oldcode
expr_stmt|;
block|}
comment|/* 	 * Generate output characters in reverse order 	 */
ifdef|#
directive|ifdef
name|interdata
while|while
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|code
operator|)
operator|>=
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|256
operator|)
condition|)
block|{
else|#
directive|else
else|!interdata
while|while
condition|(
name|code
operator|>=
literal|256
condition|)
block|{
endif|#
directive|endif
endif|interdata
operator|*
name|stackp
operator|++
operator|=
name|tab_suffix
index|[
name|code
index|]
expr_stmt|;
name|code
operator|=
name|tab_prefix
index|[
name|code
index|]
expr_stmt|;
block|}
operator|*
name|stackp
operator|++
operator|=
name|finchar
operator|=
name|tab_suffix
index|[
name|code
index|]
expr_stmt|;
comment|/* 	 * And put them out in forward order 	 */
while|while
condition|(
operator|--
name|stackp
operator|>
operator|&
name|stack
index|[
literal|0
index|]
condition|)
name|putchar
argument_list|(
operator|*
name|stackp
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|stackp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|writeerr
argument_list|( )
expr_stmt|;
comment|/* 	 * Generate the new entry. 	 */
if|if
condition|(
operator|(
name|code
operator|=
name|free_ent
operator|)
operator|<
name|maxmaxcode
condition|)
block|{
name|tab_prefix
index|[
name|code
index|]
operator|=
operator|(
name|unsigned
name|short
operator|)
name|oldcode
expr_stmt|;
name|tab_suffix
index|[
name|code
index|]
operator|=
name|finchar
expr_stmt|;
name|free_ent
operator|=
name|code
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 	 * Remember previous code. 	 */
name|oldcode
operator|=
name|incode
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|writeerr
argument_list|()
expr_stmt|;
block|}
comment|/*****************************************************************  * TAG( getcode )  *  * Read one code from the standard input.  If EOF, return -1.  * Inputs:  * 	stdin  * Outputs:  * 	code or -1 is returned.  */
name|code_int
name|getcode
parameter_list|()
block|{
comment|/*      * On the VAX, it is important to have the register declarations      * in exactly the order given, or the asm will break.      */
specifier|register
name|code_int
name|code
decl_stmt|;
specifier|static
name|int
name|offset
init|=
literal|0
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|;
specifier|static
name|char_type
name|buf
index|[
name|BITS
index|]
decl_stmt|;
specifier|register
name|int
name|r_off
decl_stmt|,
name|bits
decl_stmt|;
specifier|register
name|char_type
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|clear_flg
operator|>
literal|0
operator|||
name|offset
operator|>=
name|size
operator|||
name|free_ent
operator|>
name|maxcode
condition|)
block|{
comment|/* 	 * If the next entry will be too big for the current code 	 * size, then we must increase the size.  This implies reading 	 * a new buffer full, too. 	 */
if|if
condition|(
name|free_ent
operator|>
name|maxcode
condition|)
block|{
name|n_bits
operator|++
expr_stmt|;
if|if
condition|(
name|n_bits
operator|==
name|maxbits
condition|)
name|maxcode
operator|=
name|maxmaxcode
expr_stmt|;
comment|/* won't get any bigger now */
else|else
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clear_flg
operator|>
literal|0
condition|)
block|{
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
operator|=
name|INIT_BITS
argument_list|)
expr_stmt|;
name|clear_flg
operator|=
literal|0
expr_stmt|;
block|}
name|size
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|n_bits
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* end of file */
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Round size down to integral number of codes */
name|size
operator|=
operator|(
name|size
operator|<<
literal|3
operator|)
operator|-
operator|(
name|n_bits
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|r_off
operator|=
name|offset
expr_stmt|;
name|bits
operator|=
name|n_bits
expr_stmt|;
ifdef|#
directive|ifdef
name|vax
asm|asm( "extzv   r10,r9,(r8),r11" );
else|#
directive|else
else|not a vax
comment|/* 	 * Get to the first byte. 	 */
name|bp
operator|+=
operator|(
name|r_off
operator|>>
literal|3
operator|)
expr_stmt|;
name|r_off
operator|&=
literal|7
expr_stmt|;
comment|/* Get first part (low order bits) */
ifdef|#
directive|ifdef
name|NO_UCHAR
name|code
operator|=
operator|(
operator|(
operator|*
name|bp
operator|++
operator|>>
name|r_off
operator|)
operator|&
name|rmask
index|[
literal|8
operator|-
name|r_off
index|]
operator|)
operator|&
literal|0xff
expr_stmt|;
else|#
directive|else
else|NO_UCHAR
name|code
operator|=
operator|(
operator|*
name|bp
operator|++
operator|>>
name|r_off
operator|)
expr_stmt|;
endif|#
directive|endif
endif|NO_UCHAR
name|bits
operator|-=
operator|(
literal|8
operator|-
name|r_off
operator|)
expr_stmt|;
name|r_off
operator|=
literal|8
operator|-
name|r_off
expr_stmt|;
comment|/* now, offset into code word */
comment|/* Get any 8 bit parts in the middle (<=1 for up to 16 bits). */
if|if
condition|(
name|bits
operator|>=
literal|8
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_UCHAR
name|code
operator||=
operator|(
operator|*
name|bp
operator|++
operator|&
literal|0xff
operator|)
operator|<<
name|r_off
expr_stmt|;
else|#
directive|else
else|NO_UCHAR
name|code
operator||=
operator|*
name|bp
operator|++
operator|<<
name|r_off
expr_stmt|;
endif|#
directive|endif
endif|NO_UCHAR
name|r_off
operator|+=
literal|8
expr_stmt|;
name|bits
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* high order bits. */
name|code
operator||=
operator|(
operator|*
name|bp
operator|&
name|rmask
index|[
name|bits
index|]
operator|)
operator|<<
name|r_off
expr_stmt|;
endif|#
directive|endif
endif|vax
name|offset
operator|+=
name|n_bits
expr_stmt|;
return|return
name|code
return|;
block|}
name|char
modifier|*
name|rindex
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|)
comment|/* For those who don't have it in libc.a */
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
name|c
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|NULL
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
name|c
condition|)
name|p
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printcodes
argument_list|()
block|{
comment|/*      * Just print out codes from input file.  For debugging.      */
name|code_int
name|code
decl_stmt|;
name|int
name|col
init|=
literal|0
decl_stmt|,
name|bits
decl_stmt|;
name|bits
operator|=
name|n_bits
operator|=
name|INIT_BITS
expr_stmt|;
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
expr_stmt|;
name|free_ent
operator|=
operator|(
operator|(
name|block_compress
operator|)
condition|?
name|FIRST
else|:
literal|256
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|code
operator|=
name|getcode
argument_list|()
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|==
name|CLEAR
operator|)
operator|&&
name|block_compress
condition|)
block|{
name|free_ent
operator|=
name|FIRST
operator|-
literal|1
expr_stmt|;
name|clear_flg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|free_ent
operator|<
name|maxmaxcode
condition|)
name|free_ent
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|!=
name|n_bits
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nChange to %d bits\n"
argument_list|,
name|n_bits
argument_list|)
expr_stmt|;
name|bits
operator|=
name|n_bits
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%5d%c"
argument_list|,
name|code
argument_list|,
operator|(
name|col
operator|+=
literal|6
operator|)
operator|>=
literal|74
condition|?
operator|(
name|col
operator|=
literal|0
operator|,
literal|'\n'
operator|)
else|:
literal|' '
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|dump_tab
argument_list|()
comment|/* dump string table */
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|ent
expr_stmt|;
name|char
name|stack
index|[
literal|4
operator|*
name|MAXSTACK
index|]
decl_stmt|;
comment|/* \nnn makes it 4 times bigger */
name|int
name|stack_top
init|=
literal|4
operator|*
name|MAXSTACK
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|free_ent
condition|;
name|i
operator|++
control|)
block|{
name|ent
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
name|tab_suffix
index|[
name|ent
index|]
argument_list|)
operator|&&
name|isprint
argument_list|(
name|tab_suffix
index|[
name|ent
index|]
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%5d: %5d/'%c'  \""
argument_list|,
name|ent
argument_list|,
name|tab_prefix
index|[
name|ent
index|]
argument_list|,
name|tab_suffix
index|[
name|ent
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%5d: %5d/\\%03o \""
argument_list|,
name|ent
argument_list|,
name|tab_prefix
index|[
name|ent
index|]
argument_list|,
name|tab_suffix
index|[
name|ent
index|]
argument_list|)
expr_stmt|;
name|stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'\n'
expr_stmt|;
name|stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'"'
expr_stmt|;
for|for
control|(
init|;
name|ent
operator|!=
name|NULL
condition|;
name|ent
operator|=
operator|(
name|ent
operator|>=
name|FIRST
condition|?
name|tab_prefix
index|[
name|ent
index|]
else|:
name|NULL
operator|)
control|)
block|{
if|if
condition|(
name|isascii
argument_list|(
name|tab_suffix
index|[
name|ent
index|]
argument_list|)
operator|&&
name|isprint
argument_list|(
name|tab_suffix
index|[
name|ent
index|]
argument_list|)
condition|)
name|stack
index|[
operator|--
name|stack_top
index|]
operator|=
name|tab_suffix
index|[
name|ent
index|]
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|tab_suffix
index|[
name|ent
index|]
condition|)
block|{
case|case
literal|'\n'
case|:
name|stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'n'
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'t'
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'f'
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'r'
expr_stmt|;
break|break;
default|default:
name|stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'0'
operator|+
name|tab_suffix
index|[
name|ent
index|]
operator|%
literal|8
expr_stmt|;
name|stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'0'
operator|+
operator|(
name|tab_suffix
index|[
name|ent
index|]
operator|/
literal|8
operator|)
operator|%
literal|8
expr_stmt|;
name|stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'0'
operator|+
name|tab_suffix
index|[
name|ent
index|]
operator|/
literal|64
expr_stmt|;
break|break;
block|}
name|stack
index|[
operator|--
name|stack_top
index|]
operator|=
literal|'\\'
expr_stmt|;
block|}
block|}
name|fwrite
argument_list|(
operator|&
name|stack
index|[
name|stack_top
index|]
argument_list|,
literal|1
argument_list|,
literal|4
operator|*
name|MAXSTACK
operator|-
name|stack_top
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|stack_top
operator|=
literal|4
operator|*
name|MAXSTACK
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|DEBUG
comment|/*****************************************************************  * TAG( writeerr )  *  * Exits with a message.  We only check for write errors often enough  * to avoid a lot of "file system full" messages, not on every write.  * ferror() check after fflush will catch any others (I trust).  *  */
name|writeerr
argument_list|()
block|{
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|copystat
argument_list|(
argument|ifname
argument_list|,
argument|ofname
argument_list|)
name|char
modifier|*
name|ifname
decl_stmt|,
modifier|*
name|ofname
decl_stmt|;
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|time_t
name|timep
index|[
literal|2
index|]
decl_stmt|;
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|ifname
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
block|{
comment|/* Get stat on input file */
name|perror
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
comment|/*0170000*/
operator|)
operator|!=
name|S_IFREG
comment|/*0100000*/
condition|)
block|{
if|if
condition|(
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -- not a regular file: unchanged"
argument_list|)
expr_stmt|;
name|exit_stat
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|statbuf
operator|.
name|st_nlink
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -- has %d other links: unchanged"
argument_list|,
name|statbuf
operator|.
name|st_nlink
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit_stat
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exit_stat
operator|==
literal|2
operator|&&
operator|(
operator|!
name|force
operator|)
operator|&&
operator|!
name|quiet
condition|)
block|{
comment|/* No compression: remove file.Z */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -- file unchanged"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ***** Successful Compression ***** */
name|exit_stat
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
name|statbuf
operator|.
name|st_mode
operator|&
literal|07777
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|ofname
argument_list|,
name|mode
argument_list|)
condition|)
comment|/* Copy modes */
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|chown
argument_list|(
name|ofname
argument_list|,
name|statbuf
operator|.
name|st_uid
argument_list|,
name|statbuf
operator|.
name|st_gid
argument_list|)
expr_stmt|;
comment|/* Copy ownership */
name|timep
index|[
literal|0
index|]
operator|=
name|statbuf
operator|.
name|st_atime
expr_stmt|;
name|timep
index|[
literal|1
index|]
operator|=
name|statbuf
operator|.
name|st_mtime
expr_stmt|;
name|utime
argument_list|(
name|ofname
argument_list|,
name|timep
argument_list|)
expr_stmt|;
comment|/* Update last accessed and modified times */
if|if
condition|(
name|unlink
argument_list|(
name|ifname
argument_list|)
condition|)
comment|/* Remove input file */
name|perror
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -- replaced with %s"
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
return|return;
comment|/* Successful return */
block|}
comment|/* Unsuccessful return -- one of the tests failed */
if|if
condition|(
name|unlink
argument_list|(
name|ofname
argument_list|)
condition|)
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
block|}
comment|/*  * This routine returns 1 if we are running in the foreground and stderr  * is a tty.  */
name|foreground
argument_list|()
block|{
if|if
condition|(
name|bgnd_flag
condition|)
block|{
comment|/* background? */
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* foreground */
if|if
condition|(
name|isatty
argument_list|(
literal|2
argument_list|)
condition|)
block|{
comment|/* and stderr is a tty */
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
name|onintr
argument_list|( )
block|{
name|unlink
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cl_block
argument_list|()
comment|/* table clear for block compress */
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"count: %ld ratio: %f\n"
argument_list|,
name|in_count
argument_list|,
operator|(
name|double
operator|)
name|in_count
operator|/
operator|(
name|double
operator|)
name|bytes_out
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|checkpoint
operator|=
name|in_count
operator|+
name|CHECK_GAP
expr_stmt|;
if|if
condition|(
operator|(
name|double
operator|)
name|in_count
operator|/
operator|(
name|double
operator|)
name|bytes_out
operator|>
name|ratio
condition|)
name|ratio
operator|=
operator|(
name|double
operator|)
name|in_count
operator|/
operator|(
name|double
operator|)
name|bytes_out
expr_stmt|;
else|else
block|{
name|ratio
operator|=
literal|0.0
expr_stmt|;
ifdef|#
directive|ifdef
name|USERMEM
if|if
condition|(
name|maxbits
operator|<=
name|FBITS
condition|)
comment|/* sparse array clear */
name|cl_sparse
argument_list|()
expr_stmt|;
else|else
endif|#
directive|endif
endif|USERMEM
comment|/* hash table clear */
block|{
name|cl_hash
argument_list|(
operator|(
name|count_int
operator|)
name|hsize
argument_list|)
expr_stmt|;
block|}
name|free_ent
operator|=
name|FIRST
expr_stmt|;
name|clear_flg
operator|=
literal|1
expr_stmt|;
name|output
argument_list|(
operator|(
name|code_int
operator|)
name|CLEAR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"clear\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
block|}
name|cl_cache
argument_list|(
name|n
argument_list|)
comment|/* clear hash cache */
specifier|register
name|count_int
name|n
expr_stmt|;
comment|/* clear at least this many entries */
block|{
specifier|register
name|count_int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|short
modifier|*
name|hash_p
decl_stmt|;
specifier|register
name|unsigned
name|short
name|zero
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nfiles
operator|++
operator|==
literal|0
condition|)
comment|/* no clear needed if first time */
return|return;
name|n
operator|=
operator|(
name|n
operator|+
literal|15
operator|)
operator|&
operator|(
operator|-
literal|16
operator|)
expr_stmt|;
name|hash_p
operator|=
name|hashcache
operator|+
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
literal|16
control|)
block|{
comment|/* can do BSD bzero(3) or Sys V memset(3) */
operator|*
operator|(
name|hash_p
operator|-
literal|16
operator|)
operator|=
name|zero
expr_stmt|;
operator|*
operator|(
name|hash_p
operator|-
literal|15
operator|)
operator|=
name|zero
expr_stmt|;
operator|*
operator|(
name|hash_p
operator|-
literal|14
operator|)
operator|=
name|zero
expr_stmt|;
operator|*
operator|(
name|hash_p
operator|-
literal|13
operator|)
operator|=
name|zero
expr_stmt|;
operator|*
operator|(
name|hash_p
operator|-
literal|12
operator|)
operator|=
name|zero
expr_stmt|;
operator|*
operator|(
name|hash_p
operator|-
literal|11
operator|)
operator|=
name|zero
expr_stmt|;
operator|*
operator|(
name|hash_p
operator|-
literal|10
operator|)
operator|=
name|zero
expr_stmt|;
operator|*
operator|(
name|hash_p
operator|-
literal|9
operator|)
operator|=
name|zero
expr_stmt|;
operator|*
operator|(
name|hash_p
operator|-
literal|8
operator|)
operator|=
name|zero
expr_stmt|;
operator|*
operator|(
name|hash_p
operator|-
literal|7
operator|)
operator|=
name|zero
expr_stmt|;
operator|*
operator|(
name|hash_p
operator|-
literal|6
operator|)
operator|=
name|zero
expr_stmt|;
operator|*
operator|(
name|hash_p
operator|-
literal|5
operator|)
operator|=
name|zero
expr_stmt|;
operator|*
operator|(
name|hash_p
operator|-
literal|4
operator|)
operator|=
name|zero
expr_stmt|;
operator|*
operator|(
name|hash_p
operator|-
literal|3
operator|)
operator|=
name|zero
expr_stmt|;
operator|*
operator|(
name|hash_p
operator|-
literal|2
operator|)
operator|=
name|zero
expr_stmt|;
operator|*
operator|(
name|hash_p
operator|-
literal|1
operator|)
operator|=
name|zero
expr_stmt|;
name|hash_p
operator|-=
literal|16
expr_stmt|;
block|}
block|}
name|hogtally
argument_list|()
comment|/* compute character code hog */
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|most
decl_stmt|;
for|for
control|(
name|i
operator|=
name|most
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cfreq
index|[
name|i
index|]
operator|>=
name|cfreq
index|[
name|most
index|]
condition|)
name|most
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|most
operator|)
return|;
block|}
name|cl_hash
argument_list|(
name|hsize
argument_list|)
comment|/* clear hash cache, re-init code table */
specifier|register
name|count_int
name|hsize
expr_stmt|;
block|{
specifier|register
name|count_int
modifier|*
name|htab_p
init|=
name|htab
operator|+
name|hsize
decl_stmt|;
specifier|register
name|count_int
name|i
decl_stmt|;
specifier|register
name|long
name|m1
init|=
operator|-
literal|1
decl_stmt|;
name|cl_cache
argument_list|(
name|min
argument_list|(
operator|(
name|count_int
operator|)
name|hsize
argument_list|,
name|MAX_CACHE
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|hsize
operator|-
literal|16
expr_stmt|;
do|do
block|{
operator|*
operator|(
name|htab_p
operator|-
literal|16
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|15
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|14
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|13
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|12
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|11
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|10
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|9
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|8
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|7
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|6
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|5
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|4
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|3
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|2
operator|)
operator|=
name|m1
expr_stmt|;
operator|*
operator|(
name|htab_p
operator|-
literal|1
operator|)
operator|=
name|m1
expr_stmt|;
name|htab_p
operator|-=
literal|16
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|i
operator|-=
literal|16
operator|)
operator|>=
literal|0
condition|)
do|;
for|for
control|(
name|i
operator|+=
literal|16
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
operator|--
name|htab_p
operator|=
name|m1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USERMEM
name|cl_sparse
argument_list|( )
comment|/* clear sparse table indirectly thru "shadow" array */
block|{
specifier|register
name|code_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
literal|1
operator|<<
name|maxbits
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|ftable
index|[
name|fcodemem
index|[
name|i
index|]
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|USERMEM
end_endif

end_unit

