begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.  * Copyright (c) 1988, 1989 by Adam de Boor  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1989 The Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)main.c	5.5 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*-  * main.c --  *	The main file for this entire program. Exit routines etc  *	reside here.  *  * Utility functions defined in this file:  *	Main_ParseArgLine   	Takes a line of arguments, breaks them and  *	    	  	    	treats them as if they were given when first  *	    	  	    	invoked. Used by the parse module to implement  *	    	  	    	the .MFLAGS target.  *  *	Error	  	    	Print a tagged error message. The global  *	    	  	    	MAKE variable must have been defined. This  *	    	  	    	takes a format string and two optional  *	    	  	    	arguments for it.  *  *	Fatal	  	    	Print an error message and exit. Also takes  *	    	  	    	a format string and two arguments.  *  *	Punt	  	    	Aborts all jobs and exits with a message. Also  *	    	  	    	takes a format string and two arguments.  *  *	Finish	  	    	Finish things up by printing the number of  *	    	  	    	errors which occured, as passed to it, and  *	    	  	    	exiting.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|DEFMAXLOCAL
end_ifndef

begin_define
define|#
directive|define
name|DEFMAXLOCAL
value|DEFMAXJOBS
end_define

begin_endif
endif|#
directive|endif
endif|DEFMAXLOCAL
end_endif

begin_define
define|#
directive|define
name|MAKEFLAGS
value|".MAKEFLAGS"
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|progName
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Our invocation name */
end_comment

begin_decl_stmt
name|Lst
name|create
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Targets to be made */
end_comment

begin_decl_stmt
name|time_t
name|now
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Time at start of make */
end_comment

begin_decl_stmt
name|GNode
modifier|*
name|DEFAULT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* .DEFAULT node */
end_comment

begin_decl_stmt
name|Boolean
name|allPrecious
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* .PRECIOUS given on line by itself */
end_comment

begin_decl_stmt
specifier|static
name|int
name|printGraph
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -p flag */
end_comment

begin_decl_stmt
specifier|static
name|Boolean
name|noBuiltins
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -r flag */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|makefiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of makefiles to read (in 					 * order) */
end_comment

begin_decl_stmt
name|int
name|maxJobs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -J argument */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxLocal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -L argument */
end_comment

begin_decl_stmt
name|Boolean
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -d flag */
end_comment

begin_decl_stmt
name|Boolean
name|amMake
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -M flag */
end_comment

begin_decl_stmt
name|Boolean
name|noWarnings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -W flag */
end_comment

begin_decl_stmt
name|Boolean
name|noExecute
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -n flag */
end_comment

begin_decl_stmt
name|Boolean
name|keepgoing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -k flag */
end_comment

begin_decl_stmt
name|Boolean
name|queryFlag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -q flag */
end_comment

begin_decl_stmt
name|Boolean
name|touchFlag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -t flag */
end_comment

begin_decl_stmt
name|Boolean
name|usePipes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* !-P flag */
end_comment

begin_decl_stmt
name|Boolean
name|backwards
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -B flag */
end_comment

begin_decl_stmt
name|Boolean
name|ignoreErrors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -i flag */
end_comment

begin_decl_stmt
name|Boolean
name|beSilent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -s flag */
end_comment

begin_decl_stmt
name|Boolean
name|sysVmake
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -v flag */
end_comment

begin_decl_stmt
name|Boolean
name|oldVars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -V flag */
end_comment

begin_decl_stmt
name|Boolean
name|checkEnvFirst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -e flag */
end_comment

begin_decl_stmt
specifier|static
name|Boolean
name|XFlag
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -X flag given */
end_comment

begin_decl_stmt
specifier|static
name|Boolean
name|xFlag
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -x flag given */
end_comment

begin_decl_stmt
name|Boolean
name|noExport
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set TRUE if shouldn't export */
end_comment

begin_decl_stmt
specifier|static
name|Boolean
name|jobsRunning
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if the jobs might be running */
end_comment

begin_function_decl
specifier|static
name|Boolean
name|ReadMakefile
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Initial value for optind when parsing args. Different getopts start it  * differently...  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|initOptInd
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CAN_EXPORT
end_ifdef

begin_define
define|#
directive|define
name|OPTSTR
value|"BCD:I:J:L:MPSVWXd:ef:iknp:qrstvxh"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|OPTSTR
value|"BCD:I:J:L:MPSVWd:ef:iknp:qrstvh"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|help
index|[]
init|=
block|{
literal|"-B	    	Be as backwards-compatible with make as possible without\n\ 		being make."
block|,
literal|"-C	    	Cancel any current indications of compatibility."
block|,
literal|"-D<var>	Define the variable<var> with value 1."
block|,
literal|"-I<dir>	Specify another directory in which to search for included\n\ 		makefiles."
block|,
literal|"-J<num>	Specify maximum overall concurrency."
block|,
literal|"-L<num>	Specify maximum local concurrency."
block|,
literal|"-M		Be Make as closely as possible."
block|,
literal|"-P		Don't use pipes to catch the output of jobs, use files."
block|,
literal|"-S	    	Turn off the -k flag (see below)."
block|,
ifndef|#
directive|ifndef
name|POSIX
literal|"-V		Use old-style variable substitution."
block|,
endif|#
directive|endif
literal|"-W		Don't print warning messages."
block|,
ifdef|#
directive|ifdef
name|CAN_EXPORT
literal|"-X		Turn off exporting of commands."
block|,
endif|#
directive|endif
literal|"-d<flags>  	Turn on debugging output."
block|,
literal|"-e		Give environment variables precedence over those in the\n\ 		makefile(s)."
block|,
literal|"-f<file>	Specify a(nother) makefile to read"
block|,
literal|"-i		Ignore errors from executed commands."
block|,
literal|"-k		On error, continue working on targets that do not depend on\n\ 		the one for which an error was detected."
block|,
literal|"-n	    	Don't execute commands, just print them."
block|,
literal|"-p<num>    	Tell when to print the input graph: 1 (before processing),\n\ 		2 (after processing), or 3 (both)."
block|,
literal|"-q	    	See if anything needs to be done. Exits 1 if so."
block|,
literal|"-r	    	Do not read the system makefile for pre-defined rules."
block|,
literal|"-s	    	Don't print commands as they are executed."
block|,
literal|"-t	    	Update targets by \"touching\" them (see touch(1))."
block|,
literal|"-v	    	Be compatible with System V make. Implies -B, -V."
block|,
ifdef|#
directive|ifdef
name|CAN_EXPORT
literal|"-x	    	Allow exportation of commands."
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-  *----------------------------------------------------------------------  * MainParseArgs --  *	Parse a given argument vector. Called from main() and from  *	Main_ParseArgLine() when the .MAKEFLAGS target is used.  *  *	XXX: Deal with command line overriding .MAKEFLAGS in makefile  *  * Results:  *	None  *  * Side Effects:  *	Various global and local flags will be set depending on the flags  *	given  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|MainParseArgs
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments in argv */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* The arguments themselves */
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
name|char
name|c
decl_stmt|;
name|optind
operator|=
name|initOptInd
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|OPTSTR
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'B'
case|:
name|backwards
operator|=
name|oldVars
operator|=
name|TRUE
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-B"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|oldVars
operator|=
name|backwards
operator|=
name|sysVmake
operator|=
name|amMake
operator|=
name|FALSE
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-C"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|Var_Set
argument_list|(
name|optarg
argument_list|,
literal|"1"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-D"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
name|optarg
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|Parse_AddIncludeDir
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-I"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
name|optarg
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|maxJobs
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-J"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
name|optarg
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|maxLocal
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-L"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
name|optarg
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|amMake
operator|=
name|TRUE
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-M"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|usePipes
operator|=
name|FALSE
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-P"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|keepgoing
operator|=
name|FALSE
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-S"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|oldVars
operator|=
name|TRUE
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-V"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|noWarnings
operator|=
name|TRUE
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-W"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|XFlag
operator|=
name|TRUE
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-X"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
block|{
name|char
modifier|*
name|modules
init|=
name|optarg
decl_stmt|;
while|while
condition|(
operator|*
name|modules
condition|)
block|{
switch|switch
condition|(
operator|*
name|modules
condition|)
block|{
case|case
literal|'s'
case|:
name|debug
operator||=
name|DEBUG_SUFF
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|debug
operator||=
name|DEBUG_MAKE
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|debug
operator||=
name|DEBUG_JOB
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|debug
operator||=
name|DEBUG_TARG
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debug
operator||=
name|DEBUG_DIR
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|debug
operator||=
name|DEBUG_VAR
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|debug
operator||=
name|DEBUG_COND
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|debug
operator||=
name|DEBUG_PARSE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|debug
operator||=
name|DEBUG_RMT
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|debug
operator||=
name|DEBUG_ARCH
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|debug
operator|=
operator|~
literal|0
expr_stmt|;
break|break;
block|}
name|modules
operator|++
expr_stmt|;
block|}
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-d"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
name|optarg
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'e'
case|:
name|checkEnvFirst
operator|=
name|TRUE
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-e"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|makefiles
argument_list|,
operator|(
name|ClientData
operator|)
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|ignoreErrors
operator|=
name|TRUE
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-i"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|keepgoing
operator|=
name|TRUE
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-k"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|noExecute
operator|=
name|TRUE
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-n"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|printGraph
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|queryFlag
operator|=
name|TRUE
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-q"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
comment|/* Kind of 							  * nonsensical, wot? 							  */
break|break;
case|case
literal|'r'
case|:
name|noBuiltins
operator|=
name|TRUE
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-r"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|beSilent
operator|=
name|TRUE
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-s"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|touchFlag
operator|=
name|TRUE
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-t"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|sysVmake
operator|=
name|oldVars
operator|=
name|backwards
operator|=
name|TRUE
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|"-v"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|help
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|help
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|help
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|c
operator|==
literal|'?'
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*      * Take care of encompassing compatibility levels...      */
if|if
condition|(
name|amMake
condition|)
block|{
name|backwards
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|backwards
condition|)
block|{
name|oldVars
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/*      * See if the rest of the arguments are variable assignments and perform      * them if so. Else take them to be targets and stuff them on the end      * of the "create" list.      */
for|for
control|(
name|i
operator|=
name|optind
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Parse_IsVar
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|Parse_DoVar
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|VAR_CMD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|Punt
argument_list|(
literal|"Bogus argument in MainParseArgs"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|create
argument_list|,
operator|(
name|ClientData
operator|)
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*-  *----------------------------------------------------------------------  * Main_ParseArgLine --  *  	Used by the parse module when a .MFLAGS or .MAKEFLAGS target  *	is encountered and by main() when reading the .MAKEFLAGS envariable.  *	Takes a line of arguments and breaks it into its  * 	component words and passes those words and the number of them to the  *	MainParseArgs function.  *	The line should have all its leading whitespace removed.  *  * Results:  *	None  *  * Side Effects:  *	Only those that come from the various arguments.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Main_ParseArgLine
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
comment|/* Line to fracture */
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* Manufactured argument vector */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments in argv */
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
operator|*
name|line
operator|==
literal|' '
condition|)
name|line
operator|++
expr_stmt|;
name|argv
operator|=
name|Str_BreakString
argument_list|(
name|line
argument_list|,
literal|" \t"
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
name|MainParseArgs
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|Str_FreeVec
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *----------------------------------------------------------------------  * main --  *	The main function, for obvious reasons. Initializes variables  *	and a few modules, then parses the arguments give it in the  *	environment and on the command line. Reads the system makefile  *	followed by either Makefile, makefile or the file given by the  *	-f argument. Sets the .MAKEFLAGS PMake variable based on all the  *	flags it has received by then uses either the Make or the Compat  *	module to create the initial list of targets.  *  * Results:  *	If -q was given, exits -1 if anything was out-of-date. Else it exits  *	0.  *  * Side Effects:  *	The program exits when done. Targets are created. etc. etc. etc.  *  *----------------------------------------------------------------------  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|Lst
name|targs
decl_stmt|;
comment|/* list of target nodes to create. Passed to 				 * Make_Init */
name|Boolean
name|outOfDate
decl_stmt|;
comment|/* FALSE if all targets up to date */
name|char
modifier|*
name|cp
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
name|create
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|makefiles
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|beSilent
operator|=
name|FALSE
expr_stmt|;
comment|/* Print commands as executed */
name|ignoreErrors
operator|=
name|FALSE
expr_stmt|;
comment|/* Pay attention to non-zero returns */
name|noExecute
operator|=
name|FALSE
expr_stmt|;
comment|/* Execute all commands */
name|keepgoing
operator|=
name|FALSE
expr_stmt|;
comment|/* Stop on error */
name|allPrecious
operator|=
name|FALSE
expr_stmt|;
comment|/* Remove targets when interrupted */
name|queryFlag
operator|=
name|FALSE
expr_stmt|;
comment|/* This is not just a check-run */
name|noBuiltins
operator|=
name|FALSE
expr_stmt|;
comment|/* Read the built-in rules */
name|touchFlag
operator|=
name|FALSE
expr_stmt|;
comment|/* Actually update targets */
name|usePipes
operator|=
name|TRUE
expr_stmt|;
comment|/* Catch child output in pipes */
name|debug
operator|=
literal|0
expr_stmt|;
comment|/* No debug verbosity, please. */
name|noWarnings
operator|=
name|FALSE
expr_stmt|;
comment|/* Print warning messages */
name|sysVmake
operator|=
name|FALSE
expr_stmt|;
comment|/* Don't be System V compatible */
name|jobsRunning
operator|=
name|FALSE
expr_stmt|;
name|maxJobs
operator|=
name|DEFMAXJOBS
expr_stmt|;
comment|/* Set the default maximum concurrency */
name|maxLocal
operator|=
name|DEFMAXLOCAL
expr_stmt|;
comment|/* Set the default local max concurrency */
comment|/*      * Deal with disagreement between different getopt's as to what      * the initial value of optind should be by simply saving the      * damn thing.      */
name|initOptInd
operator|=
name|optind
expr_stmt|;
comment|/*      * See what the user calls us. If s/he calls us (yuck) "make", then      * act like it. Otherwise act like our normal, cheerful self.      */
name|cp
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
name|progName
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"make"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|amMake
operator|=
name|TRUE
expr_stmt|;
comment|/* Be like make */
name|backwards
operator|=
name|TRUE
expr_stmt|;
comment|/* Do things the old-fashioned way */
name|oldVars
operator|=
name|TRUE
expr_stmt|;
comment|/* Same with variables */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"smake"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"vmake"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sysVmake
operator|=
name|oldVars
operator|=
name|backwards
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|amMake
operator|=
name|FALSE
expr_stmt|;
name|backwards
operator|=
name|FALSE
expr_stmt|;
comment|/* Do things MY way, not MAKE's */
ifdef|#
directive|ifdef
name|DEF_OLD_VARS
name|oldVars
operator|=
name|TRUE
expr_stmt|;
else|#
directive|else
name|oldVars
operator|=
name|FALSE
expr_stmt|;
comment|/* don't substitute for undefined variables */
endif|#
directive|endif
block|}
comment|/*      * Initialize the parsing, directory and variable modules to prepare      * for the reading of inclusion paths and variable settings on the      * command line       */
name|Dir_Init
argument_list|()
expr_stmt|;
comment|/* Initialize directory structures so -I flags 				 * can be processed correctly */
name|Parse_Init
argument_list|()
expr_stmt|;
comment|/* Need to initialize the paths of #include 				 * directories */
name|Var_Init
argument_list|()
expr_stmt|;
comment|/* As well as the lists of variables for 				 * parsing arguments */
comment|/*      * Initialize various variables.      *	.PMAKE gets how we were executed.      *	MAKE also gets this name, for compatibility      *	.MAKEFLAGS gets set to the empty string just in case.      *  MFLAGS also gets initialized empty, for compatibility.      */
name|Var_Set
argument_list|(
literal|".PMAKE"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
literal|"MAKE"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|MAKEFLAGS
argument_list|,
literal|""
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
literal|"MFLAGS"
argument_list|,
literal|""
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
comment|/*      * First snag any flags out of the PMAKE environment variable.      * (Note this is *not* MAKEFLAGS since /bin/make uses that and it's in      * a different format).      */
ifdef|#
directive|ifdef
name|POSIX
name|Main_ParseArgLine
argument_list|(
name|getenv
argument_list|(
literal|"MAKEFLAGS"
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|Main_ParseArgLine
argument_list|(
name|getenv
argument_list|(
literal|"PMAKE"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MainParseArgs
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/*      * Initialize archive, target and suffix modules in preparation for      * parsing the makefile(s)       */
name|Arch_Init
argument_list|()
expr_stmt|;
name|Targ_Init
argument_list|()
expr_stmt|;
name|Suff_Init
argument_list|()
expr_stmt|;
name|DEFAULT
operator|=
name|NILGNODE
expr_stmt|;
name|now
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Set up the .TARGETS variable to contain the list of targets to be      * created. If none specified, make the variable empty -- the parser      * will fill the thing in with the default or .MAIN target.      */
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|create
argument_list|)
condition|)
block|{
name|LstNode
name|ln
decl_stmt|;
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
name|create
argument_list|)
init|;
name|ln
operator|!=
name|NILLNODE
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
decl_stmt|;
name|Var_Append
argument_list|(
literal|".TARGETS"
argument_list|,
name|name
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Var_Set
argument_list|(
literal|".TARGETS"
argument_list|,
literal|""
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
block|}
comment|/*      * Read in the built-in rules first, followed by the specified makefile,      * if it was (makefile != (char *) NULL), or the default Makefile and      * makefile, in that order, if it wasn't.       */
if|if
condition|(
operator|!
name|noBuiltins
operator|&&
operator|!
name|ReadMakefile
argument_list|(
name|DEFSYSMK
argument_list|)
condition|)
block|{
name|Fatal
argument_list|(
literal|"Could not open system rules (%s)"
argument_list|,
name|DEFSYSMK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|makefiles
argument_list|)
condition|)
block|{
name|LstNode
name|ln
init|=
name|Lst_Find
argument_list|(
name|makefiles
argument_list|,
operator|(
name|ClientData
operator|)
name|NULL
argument_list|,
name|ReadMakefile
argument_list|)
decl_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NILLNODE
condition|)
block|{
name|Fatal
argument_list|(
literal|"Cannot open %s"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|POSIX
if|if
condition|(
operator|!
name|ReadMakefile
argument_list|(
literal|"makefile"
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ReadMakefile
argument_list|(
literal|"Makefile"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|ReadMakefile
argument_list|(
operator|(
name|amMake
operator|||
name|sysVmake
operator|)
condition|?
literal|"makefile"
else|:
literal|"Makefile"
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ReadMakefile
argument_list|(
operator|(
name|amMake
operator|||
name|sysVmake
operator|)
condition|?
literal|"Makefile"
else|:
literal|"makefile"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/*      * Figure "noExport" out based on the current mode. Since exporting each      * command in make mode is rather inefficient, we only export if the -x      * flag was given. In regular mode though, we only refuse to export if      * -X was given. In case the operative flag was given in the environment,      * however, the opposite one may be given on the command line and cancel      * the action.      */
if|if
condition|(
name|amMake
condition|)
block|{
name|noExport
operator|=
operator|!
name|xFlag
operator|||
name|XFlag
expr_stmt|;
block|}
else|else
block|{
name|noExport
operator|=
name|XFlag
operator|&&
operator|!
name|xFlag
expr_stmt|;
block|}
name|Var_Append
argument_list|(
literal|"MFLAGS"
argument_list|,
name|Var_Value
argument_list|(
name|MAKEFLAGS
argument_list|,
name|VAR_GLOBAL
argument_list|)
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
comment|/*      * Install all the flags into the PMAKE envariable.      */
ifdef|#
directive|ifdef
name|POSIX
name|setenv
argument_list|(
literal|"MAKEFLAGS"
argument_list|,
name|Var_Value
argument_list|(
name|MAKEFLAGS
argument_list|,
name|VAR_GLOBAL
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|setenv
argument_list|(
literal|"PMAKE"
argument_list|,
name|Var_Value
argument_list|(
name|MAKEFLAGS
argument_list|,
name|VAR_GLOBAL
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * For compatibility, look at the directories in the VPATH variable      * and add them to the search path, if the variable is defined. The      * variable's value is in the same format as the PATH envariable, i.e.      *<directory>:<directory>:<directory>...      */
if|if
condition|(
name|Var_Exists
argument_list|(
literal|"VPATH"
argument_list|,
name|VAR_CMD
argument_list|)
condition|)
block|{
name|char
modifier|*
name|vpath
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|savec
decl_stmt|;
specifier|static
name|char
name|VPATH
index|[]
init|=
literal|"${VPATH}"
decl_stmt|;
comment|/* GCC stores string constants in 					     * read-only memory, but Var_Subst 					     * will want to write this thing, 					     * so store it in an array */
name|vpath
operator|=
name|Var_Subst
argument_list|(
name|VPATH
argument_list|,
name|VAR_CMD
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|path
operator|=
name|vpath
expr_stmt|;
do|do
block|{
comment|/* 	     * Skip to end of directory 	     */
for|for
control|(
name|cp
operator|=
name|path
init|;
operator|*
name|cp
operator|!=
literal|':'
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
continue|continue;
block|}
comment|/* 	     * Save terminator character to figure out when to stop 	     */
name|savec
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	     * Add directory to search path 	     */
name|Dir_AddDir
argument_list|(
name|dirSearchPath
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
name|savec
expr_stmt|;
name|path
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|savec
operator|==
literal|':'
condition|)
do|;
name|free
argument_list|(
operator|(
name|Address
operator|)
name|vpath
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now that all search paths have been read for suffixes et al, it's      * time to add the default search path to their lists...      */
name|Suff_DoPaths
argument_list|()
expr_stmt|;
comment|/*      * Print the initial graph, if the user requested it      */
if|if
condition|(
name|printGraph
operator|&
literal|1
condition|)
block|{
name|Targ_PrintGraph
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Rmt_Init
argument_list|()
expr_stmt|;
comment|/*      * Have now read the entire graph and need to make a list of targets to      * create. If none was given on the command line, we consult the parsing      * module to find the main target(s) to create.      */
if|if
condition|(
name|Lst_IsEmpty
argument_list|(
name|create
argument_list|)
condition|)
block|{
name|targs
operator|=
name|Parse_MainName
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|targs
operator|=
name|Targ_FindList
argument_list|(
name|create
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|amMake
condition|)
block|{
comment|/* 	 * Initialize job module before traversing the graph, now that any 	 * .BEGIN and .END targets have been read. This is done only if the 	 * -q flag wasn't given (to prevent the .BEGIN from being executed 	 * should it exist). 	 */
if|if
condition|(
operator|!
name|queryFlag
condition|)
block|{
if|if
condition|(
name|maxLocal
operator|==
operator|-
literal|1
condition|)
block|{
name|maxLocal
operator|=
name|maxJobs
expr_stmt|;
block|}
name|Job_Init
argument_list|(
name|maxJobs
argument_list|,
name|maxLocal
argument_list|)
expr_stmt|;
name|jobsRunning
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 	 * Traverse the graph, checking on all the targets  	 */
name|outOfDate
operator|=
name|Make_Run
argument_list|(
name|targs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Compat_Init will take care of creating all the targets as well 	 * as initializing the module. 	 */
name|Compat_Run
argument_list|(
name|targs
argument_list|)
expr_stmt|;
block|}
comment|/*      * Print the graph now it's been processed if the user requested it      */
if|if
condition|(
name|printGraph
operator|&
literal|2
condition|)
block|{
name|Targ_PrintGraph
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queryFlag
operator|&&
name|outOfDate
condition|)
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ReadMakefile  --  *	Open and parse the given makefile.  *  * Results:  *	TRUE if ok. FALSE if couldn't open file.  *  * Side Effects:  *	lots  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|ReadMakefile
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* makefile to read */
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fname
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Parse_File
argument_list|(
literal|"(stdin)"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
literal|"MAKEFILE"
argument_list|,
literal|""
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
specifier|extern
name|Lst
name|parseIncPath
decl_stmt|,
name|sysIncPath
decl_stmt|;
name|stream
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* 	     * Look in -I directories... 	     */
name|char
modifier|*
name|name
init|=
name|Dir_FindFile
argument_list|(
name|fname
argument_list|,
name|parseIncPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Last-ditch: look in system include directories. 		 */
name|name
operator|=
name|Dir_FindFile
argument_list|(
name|fname
argument_list|,
name|sysIncPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
name|stream
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Better safe than sorry... */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|fname
operator|=
name|name
expr_stmt|;
block|}
comment|/* 	 * Set the MAKEFILE variable desired by System V fans -- the placement 	 * of the setting here means it gets set to the last makefile 	 * specified, as it is set by SysV make... 	 */
name|Var_Set
argument_list|(
literal|"MAKEFILE"
argument_list|,
name|fname
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|Parse_File
argument_list|(
name|fname
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Error --  *	Print an error message given its format and 0, 1, 2 or 3 arguments.  *  * Results:  *	None.  *  * Side Effects:  *	The message is printed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|void
name|Error
parameter_list|(
name|fmt
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Format string */
name|int
name|arg1
decl_stmt|,
comment|/* First optional argument */
name|arg2
decl_stmt|,
comment|/* Second optional argument */
name|arg3
decl_stmt|;
comment|/* Third optional argument */
block|{
specifier|static
name|char
name|estr
index|[
name|BSIZE
index|]
decl_stmt|;
comment|/* output string */
name|sprintf
argument_list|(
name|estr
argument_list|,
literal|"%s: "
argument_list|,
name|Var_Value
argument_list|(
literal|".PMAKE"
argument_list|,
name|VAR_GLOBAL
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|estr
index|[
name|strlen
argument_list|(
name|estr
argument_list|)
index|]
argument_list|,
name|fmt
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|estr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|estr
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Fatal --  *	Produce a Fatal error message. If jobs are running, waits for them  *	to finish.  *  * Results:  *	None  *  * Side Effects:  *	The program exits  *-----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* VARARGS1 */
end_comment

begin_function
name|void
name|Fatal
parameter_list|(
name|fmt
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* format string */
name|int
name|arg1
decl_stmt|;
comment|/* first optional argument */
name|int
name|arg2
decl_stmt|;
comment|/* second optional argument */
block|{
if|if
condition|(
name|jobsRunning
condition|)
block|{
name|Job_Wait
argument_list|()
expr_stmt|;
block|}
name|Error
argument_list|(
name|fmt
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|printGraph
operator|&
literal|2
condition|)
block|{
name|Targ_PrintGraph
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Not 1 so -q can distinguish error */
block|}
end_function

begin_comment
comment|/*  *-----------------------------------------------------------------------  * Punt --  *	Major exception once jobs are being created. Kills all jobs, prints  *	a message and exits.  *  * Results:  *	None   *  * Side Effects:  *	All children are killed indiscriminately and the program Lib_Exits  *-----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* VARARGS1 */
end_comment

begin_function
name|void
name|Punt
parameter_list|(
name|fmt
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* format string */
name|int
name|arg1
decl_stmt|;
comment|/* optional argument */
name|int
name|arg2
decl_stmt|;
comment|/* optional second argument */
block|{
name|Error
argument_list|(
name|fmt
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|DieHorribly
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * DieHorribly --  *	Exit without giving a message.  *  * Results:  *	None  *  * Side Effects:  *	A big one...  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|DieHorribly
parameter_list|()
block|{
if|if
condition|(
name|jobsRunning
condition|)
block|{
name|Job_AbortAll
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|printGraph
operator|&
literal|2
condition|)
block|{
name|Targ_PrintGraph
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Not 1, so -q can distinguish error */
block|}
end_function

begin_comment
comment|/*  *-----------------------------------------------------------------------  * Finish --  *	Called when aborting due to errors in child shell to signal  *	abnormal exit.   *  * Results:  *	None   *  * Side Effects:  *	The program exits  * -----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Finish
parameter_list|(
name|errors
parameter_list|)
name|int
name|errors
decl_stmt|;
comment|/* number of errors encountered in Make_Make */
block|{
name|Fatal
argument_list|(
literal|"%d error%s"
argument_list|,
name|errors
argument_list|,
name|errors
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|||
name|defined
argument_list|(
name|is68k
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PROF
argument_list|)
end_if

begin_macro
name|exit
argument_list|(
argument|status
argument_list|)
end_macro

begin_block
block|{
name|_cleanup
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* System V */
end_comment

end_unit

