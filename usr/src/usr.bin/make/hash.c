begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.  * Copyright (c) 1988, 1989 by Adam de Boor  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)hash.c	5.5 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* hash.c --  *  * 	This module contains routines to manipulate a hash table.  * 	See hash.h for a definition of the structure of the hash  * 	table.  Hash tables grow automatically as the amount of  * 	information increases.  */
end_comment

begin_include
include|#
directive|include
file|"sprite.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_comment
comment|/*  * Forward references to local procedures that are used before they're  * defined:  */
end_comment

begin_function_decl
specifier|static
name|void
name|RebuildTable
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*   * The following defines the ratio of # entries to # buckets  * at which we rebuild the table to make it larger.  */
end_comment

begin_define
define|#
directive|define
name|rebuildLimit
value|8
end_define

begin_comment
comment|/*  *---------------------------------------------------------  *   * Hash_InitTable --  *  *	This routine just sets up the hash table.  *  * Results:	  *	None.  *  * Side Effects:  *	Memory is allocated for the initial bucket area.  *  *---------------------------------------------------------  */
end_comment

begin_function
name|void
name|Hash_InitTable
parameter_list|(
name|t
parameter_list|,
name|numBuckets
parameter_list|)
specifier|register
name|Hash_Table
modifier|*
name|t
decl_stmt|;
comment|/* Structure to use to hold table. */
name|int
name|numBuckets
decl_stmt|;
comment|/* How many buckets to create for starters. 				 * This number is rounded up to a power of 				 * two.   If<= 0, a reasonable default is 				 * chosen. The table will grow in size later 				 * as needed. */
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|Hash_Entry
modifier|*
modifier|*
name|hp
decl_stmt|;
comment|/* 	 * Round up the size to a power of two.  	 */
if|if
condition|(
name|numBuckets
operator|<=
literal|0
condition|)
name|i
operator|=
literal|16
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|numBuckets
condition|;
name|i
operator|<<=
literal|1
control|)
comment|/* void */
empty_stmt|;
block|}
name|t
operator|->
name|numEntries
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|size
operator|=
name|i
expr_stmt|;
name|t
operator|->
name|mask
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|t
operator|->
name|bucketPtr
operator|=
name|hp
operator|=
operator|(
expr|struct
name|Hash_Entry
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hp
argument_list|)
operator|*
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
operator|*
name|hp
operator|++
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------  *  * Hash_DeleteTable --  *  *	This routine removes everything from a hash table  *	and frees up the memory space it occupied (except for  *	the space in the Hash_Table structure).  *  * Results:	  *	None.  *  * Side Effects:  *	Lots of memory is freed up.  *  *---------------------------------------------------------  */
end_comment

begin_function
name|void
name|Hash_DeleteTable
parameter_list|(
name|t
parameter_list|)
name|Hash_Table
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|struct
name|Hash_Entry
modifier|*
modifier|*
name|hp
decl_stmt|,
modifier|*
name|h
decl_stmt|,
modifier|*
name|nexth
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|hp
operator|=
name|t
operator|->
name|bucketPtr
operator|,
name|i
operator|=
name|t
operator|->
name|size
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
for|for
control|(
name|h
operator|=
operator|*
name|hp
operator|++
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|nexth
control|)
block|{
name|nexth
operator|=
name|h
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|h
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|bucketPtr
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the hash table to cause memory faults on any future access 	 * attempts until re-initialization.  	 */
name|t
operator|->
name|bucketPtr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------  *  * Hash_FindEntry --  *  * 	Searches a hash table for an entry corresponding to key.  *  * Results:  *	The return value is a pointer to the entry for key,  *	if key was present in the table.  If key was not  *	present, NULL is returned.  *  * Side Effects:  *	None.  *  *---------------------------------------------------------  */
end_comment

begin_function
name|Hash_Entry
modifier|*
name|Hash_FindEntry
parameter_list|(
name|t
parameter_list|,
name|key
parameter_list|)
name|Hash_Table
modifier|*
name|t
decl_stmt|;
comment|/* Hash table to search. */
name|char
modifier|*
name|key
decl_stmt|;
comment|/* A hash key. */
block|{
specifier|register
name|Hash_Entry
modifier|*
name|e
decl_stmt|;
specifier|register
name|unsigned
name|h
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|h
operator|=
literal|0
operator|,
name|p
operator|=
name|key
init|;
operator|*
name|p
condition|;
control|)
name|h
operator|=
operator|(
name|h
operator|<<
literal|5
operator|)
operator|-
name|h
operator|+
operator|*
name|p
operator|++
expr_stmt|;
name|p
operator|=
name|key
expr_stmt|;
for|for
control|(
name|e
operator|=
name|t
operator|->
name|bucketPtr
index|[
name|h
operator|&
name|t
operator|->
name|mask
index|]
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
if|if
condition|(
name|e
operator|->
name|namehash
operator|==
name|h
operator|&&
name|strcmp
argument_list|(
name|e
operator|->
name|name
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|e
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------  *  * Hash_CreateEntry --  *  *	Searches a hash table for an entry corresponding to  *	key.  If no entry is found, then one is created.  *  * Results:  *	The return value is a pointer to the entry.  If *newPtr  *	isn't NULL, then *newPtr is filled in with TRUE if a  *	new entry was created, and FALSE if an entry already existed  *	with the given key.  *  * Side Effects:  *	Memory may be allocated, and the hash buckets may be modified.  *---------------------------------------------------------  */
end_comment

begin_function
name|Hash_Entry
modifier|*
name|Hash_CreateEntry
parameter_list|(
name|t
parameter_list|,
name|key
parameter_list|,
name|newPtr
parameter_list|)
specifier|register
name|Hash_Table
modifier|*
name|t
decl_stmt|;
comment|/* Hash table to search. */
name|char
modifier|*
name|key
decl_stmt|;
comment|/* A hash key. */
name|Boolean
modifier|*
name|newPtr
decl_stmt|;
comment|/* Filled in with TRUE if new entry created, 				 * FALSE otherwise. */
block|{
specifier|register
name|Hash_Entry
modifier|*
name|e
decl_stmt|;
specifier|register
name|unsigned
name|h
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|keylen
decl_stmt|;
name|struct
name|Hash_Entry
modifier|*
modifier|*
name|hp
decl_stmt|;
comment|/* 	 * Hash the key.  As a side effect, save the length (strlen) of the 	 * key in case we need to create the entry. 	 */
for|for
control|(
name|h
operator|=
literal|0
operator|,
name|p
operator|=
name|key
init|;
operator|*
name|p
condition|;
control|)
name|h
operator|=
operator|(
name|h
operator|<<
literal|5
operator|)
operator|-
name|h
operator|+
operator|*
name|p
operator|++
expr_stmt|;
name|keylen
operator|=
name|p
operator|-
name|key
expr_stmt|;
name|p
operator|=
name|key
expr_stmt|;
for|for
control|(
name|e
operator|=
name|t
operator|->
name|bucketPtr
index|[
name|h
operator|&
name|t
operator|->
name|mask
index|]
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|namehash
operator|==
name|h
operator|&&
name|strcmp
argument_list|(
name|e
operator|->
name|name
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|newPtr
operator|!=
name|NULL
condition|)
operator|*
name|newPtr
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
block|}
comment|/* 	 * The desired entry isn't there.  Before allocating a new entry, 	 * expand the table if necessary (and this changes the resulting 	 * bucket chain).  	 */
if|if
condition|(
name|t
operator|->
name|numEntries
operator|>=
name|rebuildLimit
operator|*
name|t
operator|->
name|size
condition|)
name|RebuildTable
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|e
operator|=
operator|(
name|Hash_Entry
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
operator|+
name|keylen
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|&
name|t
operator|->
name|bucketPtr
index|[
name|h
operator|&
name|t
operator|->
name|mask
index|]
expr_stmt|;
name|e
operator|->
name|next
operator|=
operator|*
name|hp
expr_stmt|;
operator|*
name|hp
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|clientData
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|namehash
operator|=
name|h
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|e
operator|->
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|t
operator|->
name|numEntries
operator|++
expr_stmt|;
if|if
condition|(
name|newPtr
operator|!=
name|NULL
condition|)
operator|*
name|newPtr
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------  *  * Hash_DeleteEntry --  *  * 	Delete the given hash table entry and free memory associated with  *	it.  *  * Results:  *	None.  *  * Side Effects:  *	Hash chain that entry lives in is modified and memory is freed.  *  *---------------------------------------------------------  */
end_comment

begin_function
name|void
name|Hash_DeleteEntry
parameter_list|(
name|t
parameter_list|,
name|e
parameter_list|)
name|Hash_Table
modifier|*
name|t
decl_stmt|;
name|Hash_Entry
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|Hash_Entry
modifier|*
modifier|*
name|hp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|hp
operator|=
operator|&
name|t
operator|->
name|bucketPtr
index|[
name|e
operator|->
name|namehash
operator|&
name|t
operator|->
name|mask
index|]
init|;
operator|(
name|p
operator|=
operator|*
name|hp
operator|)
operator|!=
name|NULL
condition|;
name|hp
operator|=
operator|&
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|==
name|e
condition|)
block|{
operator|*
name|hp
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|t
operator|->
name|numEntries
operator|--
expr_stmt|;
return|return;
block|}
block|}
operator|(
name|void
operator|)
name|write
argument_list|(
literal|2
argument_list|,
literal|"bad call to Hash_DeleteEntry\n"
argument_list|,
literal|29
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------  *  * Hash_EnumFirst --  *	This procedure sets things up for a complete search  *	of all entries recorded in the hash table.  *  * Results:	  *	The return value is the address of the first entry in  *	the hash table, or NULL if the table is empty.  *  * Side Effects:  *	The information in searchPtr is initialized so that successive  *	calls to Hash_Next will return successive HashEntry's  *	from the table.  *  *---------------------------------------------------------  */
end_comment

begin_function
name|Hash_Entry
modifier|*
name|Hash_EnumFirst
parameter_list|(
name|t
parameter_list|,
name|searchPtr
parameter_list|)
name|Hash_Table
modifier|*
name|t
decl_stmt|;
comment|/* Table to be searched. */
specifier|register
name|Hash_Search
modifier|*
name|searchPtr
decl_stmt|;
comment|/* Area in which to keep state  					 * about search.*/
block|{
name|searchPtr
operator|->
name|tablePtr
operator|=
name|t
expr_stmt|;
name|searchPtr
operator|->
name|nextIndex
operator|=
literal|0
expr_stmt|;
name|searchPtr
operator|->
name|hashEntryPtr
operator|=
name|NULL
expr_stmt|;
return|return
name|Hash_EnumNext
argument_list|(
name|searchPtr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------  *  * Hash_EnumNext --  *    This procedure returns successive entries in the hash table.  *  * Results:  *    The return value is a pointer to the next HashEntry  *    in the table, or NULL when the end of the table is  *    reached.  *  * Side Effects:  *    The information in searchPtr is modified to advance to the  *    next entry.  *  *---------------------------------------------------------  */
end_comment

begin_function
name|Hash_Entry
modifier|*
name|Hash_EnumNext
parameter_list|(
name|searchPtr
parameter_list|)
specifier|register
name|Hash_Search
modifier|*
name|searchPtr
decl_stmt|;
comment|/* Area used to keep state about  					    search. */
block|{
specifier|register
name|Hash_Entry
modifier|*
name|e
decl_stmt|;
name|Hash_Table
modifier|*
name|t
init|=
name|searchPtr
operator|->
name|tablePtr
decl_stmt|;
comment|/* 	 * The hashEntryPtr field points to the most recently returned 	 * entry, or is nil if we are starting up.  If not nil, we have 	 * to start at the next one in the chain. 	 */
name|e
operator|=
name|searchPtr
operator|->
name|hashEntryPtr
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
name|e
operator|=
name|e
operator|->
name|next
expr_stmt|;
comment|/* 	 * If the chain ran out, or if we are starting up, we need to 	 * find the next nonempty chain. 	 */
while|while
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|searchPtr
operator|->
name|nextIndex
operator|>=
name|t
operator|->
name|size
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|e
operator|=
name|t
operator|->
name|bucketPtr
index|[
name|searchPtr
operator|->
name|nextIndex
operator|++
index|]
expr_stmt|;
block|}
name|searchPtr
operator|->
name|hashEntryPtr
operator|=
name|e
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *---------------------------------------------------------  *  * RebuildTable --  *	This local routine makes a new hash table that  *	is larger than the old one.  *  * Results:	  * 	None.  *  * Side Effects:  *	The entire hash table is moved, so any bucket numbers  *	from the old table are invalid.  *  *---------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|RebuildTable
parameter_list|(
name|t
parameter_list|)
specifier|register
name|Hash_Table
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|Hash_Entry
modifier|*
name|e
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
modifier|*
name|hp
decl_stmt|,
modifier|*
modifier|*
name|xp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|mask
decl_stmt|;
specifier|register
name|Hash_Entry
modifier|*
modifier|*
name|oldhp
decl_stmt|;
name|int
name|oldsize
decl_stmt|;
name|oldhp
operator|=
name|t
operator|->
name|bucketPtr
expr_stmt|;
name|oldsize
operator|=
name|i
operator|=
name|t
operator|->
name|size
expr_stmt|;
name|i
operator|<<=
literal|1
expr_stmt|;
name|t
operator|->
name|size
operator|=
name|i
expr_stmt|;
name|t
operator|->
name|mask
operator|=
name|mask
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|t
operator|->
name|bucketPtr
operator|=
name|hp
operator|=
operator|(
expr|struct
name|Hash_Entry
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hp
argument_list|)
operator|*
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
operator|*
name|hp
operator|++
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|hp
operator|=
name|oldhp
operator|,
name|i
operator|=
name|oldsize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
for|for
control|(
name|e
operator|=
operator|*
name|hp
operator|++
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|next
control|)
block|{
name|next
operator|=
name|e
operator|->
name|next
expr_stmt|;
name|xp
operator|=
operator|&
name|t
operator|->
name|bucketPtr
index|[
name|e
operator|->
name|namehash
operator|&
name|mask
index|]
expr_stmt|;
name|e
operator|->
name|next
operator|=
operator|*
name|xp
expr_stmt|;
operator|*
name|xp
operator|=
name|e
expr_stmt|;
block|}
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oldhp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

