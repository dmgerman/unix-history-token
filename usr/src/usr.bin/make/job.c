begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * job.c --  *	handle the creation etc. of our child processes.  *  * Copyright (c) 1988, 1989 by the Regents of the University of California  * Copyright (c) 1988, 1989 by Adam de Boor  * Copyright (c) 1989 by Berkeley Softworks  *  * Permission to use, copy, modify, and distribute this  * software and its documentation for any non-commercial purpose  * and without fee is hereby granted, provided that the above copyright  * notice appears in all copies.  The University of California,  * Berkeley Softworks and Adam de Boor make no representations about  * the suitability of this software for any purpose.  It is provided  * "as is" without express or implied warranty.  *  * Interface:  *	Job_Make  	    	Start the creation of the given target.  *  *	Job_CatchChildren   	Check for and handle the termination of any  *	    	  	    	children. This must be called reasonably  *	    	  	    	frequently to keep the whole make going at  *	    	  	    	a decent clip, since job table entries aren't  *	    	  	    	removed until their process is caught this way.  *	    	  	    	Its single argument is TRUE if the function  *	    	  	    	should block waiting for a child to terminate.  *  *	Job_CatchOutput	    	Print any output our children have produced.  *	    	  	    	Should also be called fairly frequently to  *	    	  	    	keep the user informed of what's going on.  *	    	  	    	If no output is waiting, it will block for  *	    	  	    	a time given by the SEL_* constants, below,  *	    	  	    	or until output is ready.  *  *	Job_Init  	    	Called to intialize this module. in addition,  *	    	  	    	any commands attached to the .BEGIN target  *	    	  	    	are executed before this function returns.  *	    	  	    	Hence, the makefile must have been parsed  *	    	  	    	before this function is called.  *  *	Job_Full  	    	Return TRUE if the job table is filled.  *  *	Job_Empty 	    	Return TRUE if the job table is completely  *	    	  	    	empty.  *  *	Job_ParseShell	    	Given the line following a .SHELL target, parse  *	    	  	    	the line as a shell specification. Returns  *	    	  	    	FAILURE if the spec was incorrect.  *  *	Job_End	  	    	Perform any final processing which needs doing.  *	    	  	    	This includes the execution of any commands  *	    	  	    	which have been/were attached to the .END  *	    	  	    	target. It should only be called when the  *	    	  	    	job table is empty.  *  *	Job_AbortAll	    	Abort all currently running jobs. It doesn't  *	    	  	    	handle output or do anything for the jobs,  *	    	  	    	just kills them. It should only be called in  *	    	  	    	an emergency, as it were.  *  *	Job_CheckCommands   	Verify that the commands for a target are  *	    	  	    	ok. Provide them if necessary and possible.  *  *	Job_Touch 	    	Update a target without really updating it.  *  *	Job_Wait  	    	Wait for all currently-running jobs to finish.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Id: job.c,v 1.97 89/11/14 13:43:51 adam Exp $ SPRITE (Berkeley)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"job.h"
end_include

begin_comment
comment|/*  * Some systems define the fd_set we use, but not the macros to deal with it  * (SunOS 3.5, e.g.)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FD_SET
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_FD_SET
end_ifdef

begin_comment
comment|/*  * Then there are the systems that don't even define fd_set...  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FD_SETSIZE
end_ifndef

begin_define
define|#
directive|define
name|FD_SETSIZE
value|256
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NBBY
end_ifndef

begin_define
define|#
directive|define
name|NBBY
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|long
name|fd_mask
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NFDBITS
value|(sizeof(fd_mask) * NBBY)
end_define

begin_comment
comment|/* bits per mask */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|howmany
end_ifndef

begin_define
define|#
directive|define
name|howmany
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((unsigned int)(((x)+((y)-1)))/(unsigned int)(y))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|fd_set
block|{
name|fd_mask
name|fds_bits
index|[
name|howmany
argument_list|(
name|FD_SETSIZE
argument_list|,
name|NFDBITS
argument_list|)
index|]
decl_stmt|;
block|}
name|fd_set
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEED_FD_SET */
end_comment

begin_define
define|#
directive|define
name|FD_SET
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|)
value|((p)->fds_bits[(n)/NFDBITS] |= (1<< ((n) % NFDBITS)))
end_define

begin_define
define|#
directive|define
name|FD_CLR
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|)
value|((p)->fds_bits[(n)/NFDBITS]&= ~(1<< ((n) % NFDBITS)))
end_define

begin_define
define|#
directive|define
name|FD_ISSET
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|)
value|((p)->fds_bits[(n)/NFDBITS]& (1<< ((n) % NFDBITS)))
end_define

begin_define
define|#
directive|define
name|FD_ZERO
parameter_list|(
name|p
parameter_list|)
value|bzero((char *)(p), sizeof(*(p)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FD_SET */
end_comment

begin_comment
comment|/*  * error handling variables   */
end_comment

begin_decl_stmt
name|int
name|errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of errors reported */
end_comment

begin_decl_stmt
name|int
name|aborting
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* why is the make aborting? */
end_comment

begin_define
define|#
directive|define
name|ABORT_ERROR
value|1
end_define

begin_comment
comment|/* Because of an error */
end_comment

begin_define
define|#
directive|define
name|ABORT_INTERRUPT
value|2
end_define

begin_comment
comment|/* Because it was interrupted */
end_comment

begin_define
define|#
directive|define
name|ABORT_WAIT
value|3
end_define

begin_comment
comment|/* Waiting for jobs to finish */
end_comment

begin_comment
comment|/*  * post-make command processing. The node postCommands is really just the  * .END target but we keep it around to avoid having to search for it  * all the time.  */
end_comment

begin_decl_stmt
specifier|static
name|GNode
modifier|*
name|postCommands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* node containing commands to execute when 				     * everything else is done */
end_comment

begin_decl_stmt
specifier|static
name|int
name|numCommands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of commands actually printed 				     * for a target. Should this number be 				     * 0, no shell will be executed. */
end_comment

begin_comment
comment|/*  * Return values from JobStart.  */
end_comment

begin_define
define|#
directive|define
name|JOB_RUNNING
value|0
end_define

begin_comment
comment|/* Job is running */
end_comment

begin_define
define|#
directive|define
name|JOB_ERROR
value|1
end_define

begin_comment
comment|/* Error in starting the job */
end_comment

begin_define
define|#
directive|define
name|JOB_FINISHED
value|2
end_define

begin_comment
comment|/* The job is already finished */
end_comment

begin_define
define|#
directive|define
name|JOB_STOPPED
value|3
end_define

begin_comment
comment|/* The job is stopped */
end_comment

begin_comment
comment|/*  * tfile is the name of a file into which all shell commands are put. It is  * used over by removing it before the child shell is executed. The XXXXX in  * the string are replaced by the pid of the make process in a 5-character  * field with leading zeroes.   */
end_comment

begin_decl_stmt
specifier|static
name|char
name|tfile
index|[]
init|=
name|TMPPAT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Descriptions for various shells.  */
end_comment

begin_decl_stmt
specifier|static
name|Shell
name|shells
index|[]
init|=
block|{
comment|/*      * CSH description. The csh can do echo control by playing      * with the setting of the 'echo' shell variable. Sadly,      * however, it is unable to do error control nicely.      */
block|{
literal|"csh"
block|,
name|TRUE
block|,
literal|"unset verbose"
block|,
literal|"set verbose"
block|,
literal|"unset verbose"
block|,
literal|10
block|,
name|FALSE
block|,
literal|"echo \"%s\"\n"
block|,
literal|"csh -c \"%s || exit 0\""
block|,
literal|"v"
block|,
literal|"e"
block|, }
block|,
comment|/*      * SH description. Echo control is also possible and, under      * sun UNIX anyway, one can even control error checking.      */
block|{
literal|"sh"
block|,
name|TRUE
block|,
literal|"set -"
block|,
literal|"set -v"
block|,
literal|"set -"
block|,
literal|5
block|,
if|#
directive|if
operator|(
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Sprite
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|SYSV
argument_list|)
name|TRUE
block|,
literal|"set -e"
block|,
literal|"set +e"
block|,
else|#
directive|else
name|FALSE
block|,
literal|"echo \"%s\"\n"
block|,
literal|"sh -c '%s || exit 0'\n"
block|,
endif|#
directive|endif
literal|"v"
block|,
literal|"e"
block|, }
block|,
comment|/*      * UNKNOWN.      */
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
name|FALSE
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|, }
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Shell
modifier|*
name|commandShell
init|=
operator|&
name|shells
index|[
name|DEFSHELL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* this is the shell to 						   * which we pass all 						   * commands in the Makefile. 						   * It is set by the 						   * Job_ParseShell function */
end_comment

begin_decl_stmt
name|char
modifier|*
name|shellPath
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|,
comment|/* full pathname of 						   * executable image */
modifier|*
name|shellName
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last component of shell */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxJobs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The most children we can run at once */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxLocal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The most local ones we can have */
end_comment

begin_decl_stmt
name|int
name|nJobs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of children currently running */
end_comment

begin_decl_stmt
name|int
name|nLocal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of local children */
end_comment

begin_decl_stmt
name|Lst
name|jobs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The structures that describe them */
end_comment

begin_decl_stmt
name|Boolean
name|jobFull
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag to tell when the job table is full. It 				 * is set TRUE when (1) the total number of 				 * running jobs equals the maximum allowed or 				 * (2) a job can only be run locally, but 				 * nLocal equals maxLocal */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RMT_WILL_WATCH
end_ifndef

begin_decl_stmt
specifier|static
name|fd_set
name|outputs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of descriptors of pipes connected to 				 * the output channels of children */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|GNode
modifier|*
name|lastNode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The node for which output was most recently 				 * produced. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|targFmt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Format string to use to head output from a 				 * job when it's not the most-recent job heard 				 * from */
end_comment

begin_define
define|#
directive|define
name|TARG_FMT
value|"--- %s ---\n"
end_define

begin_comment
comment|/* Default format */
end_comment

begin_comment
comment|/*  * When JobStart attempts to run a job remotely but can't, and isn't allowed  * to run the job locally, or when Job_CatchChildren detects a job that has  * been migrated home, the job is placed on the stoppedJobs queue to be run  * when the next job finishes.   */
end_comment

begin_decl_stmt
name|Lst
name|stoppedJobs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lst of Job structures describing 				 * jobs that were stopped due to concurrency 				 * limits or migration home */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_PGRP
argument_list|)
operator|&&
name|defined
argument_list|(
name|SYSV
argument_list|)
end_if

begin_define
define|#
directive|define
name|KILL
parameter_list|(
name|pid
parameter_list|,
name|sig
parameter_list|)
value|killpg(-(pid),(sig))
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_PGRP
argument_list|)
end_if

begin_define
define|#
directive|define
name|KILL
parameter_list|(
name|pid
parameter_list|,
name|sig
parameter_list|)
value|killpg((pid),(sig))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|KILL
parameter_list|(
name|pid
parameter_list|,
name|sig
parameter_list|)
value|kill((pid),(sig))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|JobRestart
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|JobStart
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|JobInterrupt
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobCondPassSig --  *	Pass a signal to a job if the job is remote or if USE_PGRP  *	is defined.  *  * Results:  *	=== 0  *  * Side Effects:  *	None, except the job may bite it.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|JobCondPassSig
parameter_list|(
name|job
parameter_list|,
name|signo
parameter_list|)
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* Job to biff */
name|int
name|signo
decl_stmt|;
comment|/* Signal to send it */
block|{
ifdef|#
directive|ifdef
name|RMT_WANTS_SIGNALS
if|if
condition|(
name|job
operator|->
name|flags
operator|&
name|JOB_REMOTE
condition|)
block|{
operator|(
name|void
operator|)
name|Rmt_Signal
argument_list|(
name|job
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/*      * Assume that sending the signal to job->pid will signal any remote      * job as well.      */
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|signo
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobPassSig --  *	Pass a signal on to all remote jobs and to all local jobs if  *	USE_PGRP is defined, then die ourselves.  *  * Results:  *	None.  *  * Side Effects:  *	We die by the same signal.  *	  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobPassSig
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
comment|/* The signal number we've received */
block|{
name|int
name|mask
decl_stmt|;
name|Lst_ForEach
argument_list|(
name|jobs
argument_list|,
name|JobCondPassSig
argument_list|,
operator|(
name|ClientData
operator|)
name|signo
argument_list|)
expr_stmt|;
comment|/*      * Deal with proper cleanup based on the signal received. We only run      * the .INTERRUPT target if the signal was in fact an interrupt. The other      * three termination signals are more of a "get out *now*" command.      */
if|if
condition|(
name|signo
operator|==
name|SIGINT
condition|)
block|{
name|JobInterrupt
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|signo
operator|==
name|SIGHUP
operator|)
operator|||
operator|(
name|signo
operator|==
name|SIGTERM
operator|)
operator|||
operator|(
name|signo
operator|==
name|SIGQUIT
operator|)
condition|)
block|{
name|JobInterrupt
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/*      * Leave gracefully if SIGQUIT, rather than core dumping.      */
if|if
condition|(
name|signo
operator|==
name|SIGQUIT
condition|)
block|{
name|Finish
argument_list|()
expr_stmt|;
block|}
comment|/*      * Send ourselves the signal now we've given the message to everyone else.      * Note we block everything else possible while we're getting the signal.      * This ensures that all our jobs get continued when we wake up before      * we take any other signal.      */
name|mask
operator|=
name|sigblock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
operator|~
literal|0
operator|&
operator|~
operator|(
literal|1
operator|<<
operator|(
name|signo
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|signo
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|jobs
argument_list|,
name|JobCondPassSig
argument_list|,
operator|(
name|ClientData
operator|)
name|SIGCONT
argument_list|)
expr_stmt|;
name|sigsetmask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|signo
argument_list|,
name|JobPassSig
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobCmpPid  --  *	Compare the pid of the job with the given pid and return 0 if they  *	are equal. This function is called from Job_CatchChildren via  *	Lst_Find to find the job descriptor of the finished job.  *  * Results:  *	0 if the pid's match  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|JobCmpPid
parameter_list|(
name|job
parameter_list|,
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
comment|/* process id desired */
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* job to examine */
block|{
return|return
operator|(
name|pid
operator|-
name|job
operator|->
name|pid
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobPrintCommand  --  *	Put out another command for the given job. If the command starts  *	with an @ or a - we process it specially. In the former case,  *	so long as the -s and -n flags weren't given to make, we stick  *	a shell-specific echoOff command in the script. In the latter,  *	we ignore errors for the entire job, unless the shell has error  *	control.  *	If the command is just "..." we take all future commands for this  *	job to be commands to be executed once the entire graph has been  *	made and return non-zero to signal that the end of the commands  *	was reached. These commands are later attached to the postCommands  *	node and executed by Job_End when all things are done.  *	This function is called from JobStart via Lst_ForEach.  *  * Results:  *	Always 0, unless the command was "..."  *  * Side Effects:  *	If the command begins with a '-' and the shell has no error control,  *	the JOB_IGNERR flag is set in the job descriptor.  *	If the command is "..." and we're not ignoring such things,  *	tailCmds is set to the successor node of the cmd.  *	numCommands is incremented if the command is actually printed.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|JobPrintCommand
parameter_list|(
name|cmd
parameter_list|,
name|job
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
comment|/* command string to print */
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* job for which to print it */
block|{
name|Boolean
name|noSpecials
decl_stmt|;
comment|/* true if we shouldn't worry about 				     * inserting special commands into 				     * the input stream. */
name|Boolean
name|shutUp
init|=
name|FALSE
decl_stmt|;
comment|/* true if we put a no echo command 				     * into the command file */
name|Boolean
name|errOff
init|=
name|FALSE
decl_stmt|;
comment|/* true if we turned error checking 				     * off before printing the command 				     * and need to turn it back on */
name|char
modifier|*
name|cmdTemplate
decl_stmt|;
comment|/* Template to use when printing the 				     * command */
name|char
modifier|*
name|cmdStart
decl_stmt|;
comment|/* Start of expanded command */
name|LstNode
name|cmdNode
decl_stmt|;
comment|/* Node for replacing the command */
name|noSpecials
operator|=
operator|(
name|noExecute
operator|&&
operator|!
operator|(
name|job
operator|->
name|node
operator|->
name|type
operator|&
name|OP_MAKE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"..."
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNDOTS
operator|)
operator|==
literal|0
condition|)
block|{
name|job
operator|->
name|tailCmds
operator|=
name|Lst_Succ
argument_list|(
name|Lst_Member
argument_list|(
name|job
operator|->
name|node
operator|->
name|commands
argument_list|,
operator|(
name|ClientData
operator|)
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
define|#
directive|define
name|DBPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|arg
parameter_list|)
value|if (DEBUG(JOB)) printf (fmt, arg); fprintf (job->cmdFILE, fmt, arg)
name|numCommands
operator|+=
literal|1
expr_stmt|;
comment|/*      * For debugging, we replace each command with the result of expanding      * the variables in the command.      */
name|cmdNode
operator|=
name|Lst_Member
argument_list|(
name|job
operator|->
name|node
operator|->
name|commands
argument_list|,
operator|(
name|ClientData
operator|)
name|cmd
argument_list|)
expr_stmt|;
name|cmdStart
operator|=
name|cmd
operator|=
name|Var_Subst
argument_list|(
name|cmd
argument_list|,
name|job
operator|->
name|node
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|Lst_Replace
argument_list|(
name|cmdNode
argument_list|,
operator|(
name|ClientData
operator|)
name|cmdStart
argument_list|)
expr_stmt|;
name|cmdTemplate
operator|=
literal|"%s\n"
expr_stmt|;
comment|/*      * Check for leading @' and -'s to control echoing and error checking.      */
while|while
condition|(
operator|*
name|cmd
operator|==
literal|'@'
operator|||
operator|*
name|cmd
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'@'
condition|)
block|{
name|shutUp
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|errOff
operator|=
name|TRUE
expr_stmt|;
block|}
name|cmd
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|shutUp
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
operator|!
name|noSpecials
operator|&&
name|commandShell
operator|->
name|hasEchoCtl
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shutUp
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errOff
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
operator|&&
operator|!
name|noSpecials
condition|)
block|{
if|if
condition|(
name|commandShell
operator|->
name|hasErrCtl
condition|)
block|{
comment|/* 		 * we don't want the error-control commands showing 		 * up either, so we turn off echoing while executing 		 * them. We could put another field in the shell 		 * structure to tell JobDoOutput to look for this 		 * string too, but why make it any more complex than 		 * it already is? 		 */
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
operator|!
name|shutUp
operator|&&
name|commandShell
operator|->
name|hasEchoCtl
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOff
argument_list|)
expr_stmt|;
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|ignErr
argument_list|)
expr_stmt|;
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|ignErr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|commandShell
operator|->
name|ignErr
operator|&&
operator|(
operator|*
name|commandShell
operator|->
name|ignErr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
comment|/* 		 * The shell has no error control, so we need to be 		 * weird to get it to ignore any errors from the command. 		 * If echoing is turned on, we turn it off and use the 		 * errCheck template to echo the command. Leave echoing 		 * off so the user doesn't see the weirdness we go through 		 * to ignore errors. Set cmdTemplate to use the weirdness 		 * instead of the simple "%s\n" template. 		 */
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
operator|!
name|shutUp
operator|&&
name|commandShell
operator|->
name|hasEchoCtl
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOff
argument_list|)
expr_stmt|;
name|DBPRINTF
argument_list|(
name|commandShell
operator|->
name|errCheck
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|shutUp
operator|=
name|TRUE
expr_stmt|;
block|}
name|cmdTemplate
operator|=
name|commandShell
operator|->
name|ignErr
expr_stmt|;
comment|/* 		 * The error ignoration (hee hee) is already taken care 		 * of by the ignErr template, so pretend error checking 		 * is still on. 		 */
name|errOff
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|errOff
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
name|errOff
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|DBPRINTF
argument_list|(
name|cmdTemplate
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|errOff
condition|)
block|{
comment|/* 	 * If echoing is already off, there's no point in issuing the 	 * echoOff command. Otherwise we issue it and pretend it was on 	 * for the whole command... 	 */
if|if
condition|(
operator|!
name|shutUp
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
name|commandShell
operator|->
name|hasEchoCtl
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOff
argument_list|)
expr_stmt|;
name|shutUp
operator|=
name|TRUE
expr_stmt|;
block|}
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|errCheck
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shutUp
condition|)
block|{
name|DBPRINTF
argument_list|(
literal|"%s\n"
argument_list|,
name|commandShell
operator|->
name|echoOn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobSaveCommand --  *	Save a command to be executed when everything else is done.  *	Callback function for JobFinish...  *  * Results:  *	Always returns 0  *  * Side Effects:  *	The command is tacked onto the end of postCommands's commands list.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|JobSaveCommand
parameter_list|(
name|cmd
parameter_list|,
name|gn
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
name|GNode
modifier|*
name|gn
decl_stmt|;
block|{
name|cmd
operator|=
name|Var_Subst
argument_list|(
name|cmd
argument_list|,
name|gn
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|postCommands
operator|->
name|commands
argument_list|,
operator|(
name|ClientData
operator|)
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobFinish  --  *	Do final processing for the given job including updating  *	parents and starting new jobs as available/necessary. Note  *	that we pay no attention to the JOB_IGNERR flag here.  *	This is because when we're called because of a noexecute flag  *	or something, jstat.w_status is 0 and when called from  *	Job_CatchChildren, the status is zeroed if it s/b ignored.  *  * Results:  *	None  *  * Side Effects:  *	Some nodes may be put on the toBeMade queue.  *	Final commands for the job are placed on postCommands.  *  *	If we got an error and are aborting (aborting == ABORT_ERROR) and  *	the job list is now empty, we are done for the day.  *	If we recognized an error (errors !=0), we set the aborting flag  *	to ABORT_ERROR so no more jobs will be started.  *-----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|JobFinish
parameter_list|(
name|job
parameter_list|,
name|status
parameter_list|)
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* job to finish */
name|union
name|wait
name|status
decl_stmt|;
comment|/* sub-why job went away */
block|{
name|Boolean
name|done
decl_stmt|;
if|if
condition|(
operator|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|status
operator|.
name|w_retcode
operator|!=
literal|0
operator|)
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
operator|)
operator|||
operator|!
name|backwards
operator|)
operator|)
operator|||
operator|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
operator|&&
operator|(
name|status
operator|.
name|w_termsig
operator|!=
name|SIGCONT
operator|)
operator|)
condition|)
block|{
comment|/* 	 * If it exited non-zero and either we're doing things our 	 * way or we're not ignoring errors, the job is finished. 	 * Similarly, if the shell died because of a signal (the 	 * conditional on SIGCONT is to handle the mapping of Sprite 	 * signal semantics whereby wait will return a signal 	 * termination with SIGCONT being the signal to indicate that the 	 * child has resumed), the job is also finished. In these 	 * cases, finish out the job's output before printing the exit 	 * status... 	 */
if|if
condition|(
name|usePipes
condition|)
block|{
ifdef|#
directive|ifdef
name|RMT_WILL_WATCH
name|Rmt_Ignore
argument_list|(
name|job
operator|->
name|inPipe
argument_list|)
expr_stmt|;
else|#
directive|else
name|FD_CLR
argument_list|(
name|job
operator|->
name|inPipe
argument_list|,
operator|&
name|outputs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RMT_WILL_WATCH */
if|if
condition|(
name|job
operator|->
name|outPipe
operator|!=
name|job
operator|->
name|inPipe
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|job
operator|->
name|outPipe
argument_list|)
expr_stmt|;
block|}
name|JobDoOutput
argument_list|(
name|job
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|job
operator|->
name|inPipe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|job
operator|->
name|outFd
argument_list|)
expr_stmt|;
name|JobDoOutput
argument_list|(
name|job
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|!=
name|NULL
operator|&&
name|job
operator|->
name|cmdFILE
operator|!=
name|stdout
condition|)
block|{
name|fclose
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
expr_stmt|;
block|}
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|backwards
operator|&&
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|&&
name|status
operator|.
name|w_retcode
operator|!=
literal|0
condition|)
block|{
comment|/* 	 * Deal with ignored errors in -B mode. We need to print a message 	 * telling of the ignored error as well as setting status.w_status 	 * to 0 so the next command gets run. To do this, we set done to be 	 * TRUE if in -B mode and the job exited non-zero. Note we don't 	 * want to close down any of the streams until we know we're at the 	 * end. 	 */
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * No need to close things down or anything. 	 */
name|done
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|done
operator|||
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
operator|||
operator|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
operator|&&
operator|(
name|status
operator|.
name|w_termsig
operator|==
name|SIGCONT
operator|)
operator|)
operator|||
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|FILE
modifier|*
name|out
decl_stmt|;
if|if
condition|(
name|backwards
operator|&&
operator|!
name|usePipes
operator|&&
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
condition|)
block|{
comment|/* 	     * If output is going to a file and this job is ignoring 	     * errors, arrange to have the exit status sent to the 	     * output file as well. 	     */
name|out
operator|=
name|fdopen
argument_list|(
name|job
operator|->
name|outFd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|=
name|stdout
expr_stmt|;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|status
operator|.
name|w_retcode
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|usePipes
operator|&&
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
name|targFmt
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"*** Error code %d%s\n"
argument_list|,
name|status
operator|.
name|w_retcode
argument_list|,
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
condition|?
literal|" (ignored)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
condition|)
block|{
name|status
operator|.
name|w_status
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
if|if
condition|(
name|usePipes
operator|&&
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
name|targFmt
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"*** Completed successfully\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|usePipes
operator|&&
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
name|targFmt
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_REMIGRATE
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"*** Stopped -- signal %d\n"
argument_list|,
name|status
operator|.
name|w_stopsig
argument_list|)
expr_stmt|;
block|}
name|job
operator|->
name|flags
operator||=
name|JOB_RESUME
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|stoppedJobs
argument_list|,
operator|(
name|ClientData
operator|)
name|job
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|status
operator|.
name|w_termsig
operator|==
name|SIGCONT
condition|)
block|{
comment|/* 	     * If the beastie has continued, shift the Job from the stopped 	     * list to the running one (or re-stop it if concurrency is 	     * exceeded) and go and get another child. 	     */
if|if
condition|(
name|job
operator|->
name|flags
operator|&
operator|(
name|JOB_RESUME
operator||
name|JOB_REMIGRATE
operator||
name|JOB_RESTART
operator|)
condition|)
block|{
if|if
condition|(
name|usePipes
operator|&&
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
name|targFmt
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"*** Continued\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_CONTINUING
operator|)
condition|)
block|{
name|JobRestart
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Lst_AtEnd
argument_list|(
name|jobs
argument_list|,
operator|(
name|ClientData
operator|)
name|job
argument_list|)
expr_stmt|;
name|nJobs
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_REMOTE
operator|)
condition|)
block|{
name|nLocal
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nJobs
operator|==
name|maxJobs
condition|)
block|{
name|jobFull
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Job queue is full.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fflush
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|usePipes
operator|&&
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
name|targFmt
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"*** Signal %d\n"
argument_list|,
name|status
operator|.
name|w_termsig
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now handle the -B-mode stuff. If the beast still isn't finished,      * try and restart the job on the next command. If JobStart says it's      * ok, it's ok. If there's an error, this puppy is done.      */
if|if
condition|(
name|backwards
operator|&&
operator|(
name|status
operator|.
name|w_status
operator|==
literal|0
operator|)
operator|&&
operator|!
name|Lst_IsAtEnd
argument_list|(
name|job
operator|->
name|node
operator|->
name|commands
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|JobStart
argument_list|(
name|job
operator|->
name|node
argument_list|,
name|job
operator|->
name|flags
operator|&
name|JOB_IGNDOTS
argument_list|,
name|job
argument_list|)
condition|)
block|{
case|case
name|JOB_RUNNING
case|:
name|done
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|JOB_ERROR
case|:
name|done
operator|=
name|TRUE
expr_stmt|;
name|status
operator|.
name|w_retcode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|JOB_FINISHED
case|:
comment|/* 		 * If we got back a JOB_FINISHED code, JobStart has already 		 * called Make_Update and freed the job descriptor. We set 		 * done to false here to avoid fake cycles and double frees. 		 * JobStart needs to do the update so we can proceed up the 		 * graph when given the -n flag.. 		 */
name|done
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|done
operator|&&
operator|(
name|aborting
operator|!=
name|ABORT_ERROR
operator|)
operator|&&
operator|(
name|aborting
operator|!=
name|ABORT_INTERRUPT
operator|)
operator|&&
operator|(
name|status
operator|.
name|w_status
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 	 * As long as we aren't aborting and the job didn't return a non-zero 	 * status that we shouldn't ignore, we call Make_Update to update 	 * the parents. In addition, any saved commands for the node are placed 	 * on the .END target. 	 */
if|if
condition|(
name|job
operator|->
name|tailCmds
operator|!=
name|NILLNODE
condition|)
block|{
name|Lst_ForEachFrom
argument_list|(
name|job
operator|->
name|node
operator|->
name|commands
argument_list|,
name|job
operator|->
name|tailCmds
argument_list|,
name|JobSaveCommand
argument_list|,
operator|(
name|ClientData
operator|)
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
name|job
operator|->
name|node
operator|->
name|made
operator|=
name|MADE
expr_stmt|;
name|Make_Update
argument_list|(
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|Address
operator|)
name|job
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|.
name|w_status
condition|)
block|{
name|errors
operator|+=
literal|1
expr_stmt|;
name|free
argument_list|(
operator|(
name|Address
operator|)
name|job
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|errors
operator|&&
operator|!
name|jobFull
operator|&&
operator|!
name|Lst_IsEmpty
argument_list|(
name|stoppedJobs
argument_list|)
condition|)
block|{
name|JobRestart
argument_list|(
operator|(
name|Job
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|stoppedJobs
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * Set aborting if any error.      */
if|if
condition|(
name|errors
operator|&&
operator|!
name|keepgoing
operator|&&
operator|(
name|aborting
operator|!=
name|ABORT_INTERRUPT
operator|)
condition|)
block|{
comment|/* 	 * If we found any errors in this batch of children and the -k flag 	 * wasn't given, we set the aborting flag so no more jobs get 	 * started. 	 */
name|aborting
operator|=
name|ABORT_ERROR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|aborting
operator|==
name|ABORT_ERROR
operator|)
operator|&&
name|Job_Empty
argument_list|()
condition|)
block|{
comment|/* 	 * If we are aborting and the job table is now empty, we finish. 	 */
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
name|Finish
argument_list|(
name|errors
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_Touch --  *	Touch the given target. Called by JobStart when the -t flag was  *	given  *  * Results:  *	None  *  * Side Effects:  *	The data modification of the file is changed. In addition, if the  *	file did not exist, it is created.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_Touch
parameter_list|(
name|gn
parameter_list|,
name|silent
parameter_list|)
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* the node of the file to touch */
name|Boolean
name|silent
decl_stmt|;
comment|/* TRUE if should not print messages */
block|{
name|int
name|streamID
decl_stmt|;
comment|/* ID of stream opened to do the touch */
name|struct
name|timeval
name|times
index|[
literal|2
index|]
decl_stmt|;
comment|/* Times for utimes() call */
name|struct
name|stat
name|attr
decl_stmt|;
comment|/* Attributes of the file */
if|if
condition|(
name|gn
operator|->
name|type
operator|&
operator|(
name|OP_JOIN
operator||
name|OP_USE
operator||
name|OP_EXEC
operator||
name|OP_DONTCARE
operator|)
condition|)
block|{
comment|/* 	 * .JOIN, .USE, .ZEROTIME and .DONTCARE targets are "virtual" targets 	 * and, as such, shouldn't really be created. 	 */
return|return;
block|}
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|printf
argument_list|(
literal|"touch %s\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noExecute
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_ARCHV
condition|)
block|{
name|Arch_Touch
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_LIB
condition|)
block|{
name|Arch_TouchLib
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|file
init|=
name|gn
operator|->
name|path
condition|?
name|gn
operator|->
name|path
else|:
name|gn
operator|->
name|name
decl_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|times
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|now
expr_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|times
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|utimes
argument_list|(
name|file
argument_list|,
name|times
argument_list|)
operator|<
literal|0
condition|)
block|{
name|streamID
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|streamID
operator|>=
literal|0
condition|)
block|{
name|char
name|c
decl_stmt|;
comment|/* 		 * Read and write a byte to the file to change the 		 * modification time, then close the file. 		 */
if|if
condition|(
name|read
argument_list|(
name|streamID
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
name|lseek
argument_list|(
name|streamID
argument_list|,
literal|0L
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|streamID
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|streamID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
name|printf
argument_list|(
literal|"*** couldn't touch %s: %s"
argument_list|,
name|file
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_CheckCommands --  *	Make sure the given node has all the commands it needs.   *  * Results:  *	TRUE if the commands list is/was ok.  *  * Side Effects:  *	The node will have commands from the .DEFAULT rule added to it  *	if it needs them.  *-----------------------------------------------------------------------  */
end_comment

begin_decl_stmt
name|Boolean
name|Job_CheckCommands
argument_list|(
name|gn
argument_list|,
name|abortProc
argument_list|)
name|GNode
modifier|*
name|gn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target whose commands need 				     * verifying */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|abortProc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Function to abort with message */
end_comment

begin_block
block|{
if|if
condition|(
name|OP_NOP
argument_list|(
name|gn
operator|->
name|type
argument_list|)
operator|&&
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|commands
argument_list|)
operator|&&
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_LIB
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 	 * No commands. Look for .DEFAULT rule from which we might infer 	 * commands  	 */
if|if
condition|(
operator|(
name|DEFAULT
operator|!=
name|NILGNODE
operator|)
operator|&&
operator|!
name|Lst_IsEmpty
argument_list|(
name|DEFAULT
operator|->
name|commands
argument_list|)
condition|)
block|{
comment|/* 	     * Make only looks for a .DEFAULT if the node was never the 	     * target of an operator, so that's what we do too. If 	     * a .DEFAULT was given, we substitute its commands for gn's 	     * commands and set the IMPSRC variable to be the target's name 	     * The DEFAULT node acts like a transformation rule, in that 	     * gn also inherits any attributes or sources attached to 	     * .DEFAULT itself. 	     */
name|Make_HandleUse
argument_list|(
name|DEFAULT
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|IMPSRC
argument_list|,
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|gn
argument_list|)
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Dir_MTime
argument_list|(
name|gn
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 	     * The node wasn't the target of an operator we have no .DEFAULT 	     * rule to go on and the target doesn't already exist. There's 	     * nothing more we can do for this branch. If the -k flag wasn't 	     * given, we stop in our tracks, otherwise we just don't update 	     * this node's parents so they never get examined.  	     */
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_DONTCARE
condition|)
block|{
name|printf
argument_list|(
literal|"Can't figure out how to make %s (ignored)\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keepgoing
condition|)
block|{
name|printf
argument_list|(
literal|"Can't figure out how to make %s (continuing)\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|else
block|{
call|(
modifier|*
name|abortProc
call|)
argument_list|(
literal|"Can't figure out how to make %s. Stop"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|RMT_WILL_WATCH
end_ifdef

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobLocalInput --  *	Handle a pipe becoming readable. Callback function for Rmt_Watch  *  * Results:  *	None  *  * Side Effects:  *	JobDoOutput is called.  *	  *-----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|JobLocalInput
parameter_list|(
name|stream
parameter_list|,
name|job
parameter_list|)
name|int
name|stream
decl_stmt|;
comment|/* Stream that's ready (ignored) */
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* Job to which the stream belongs */
block|{
name|JobDoOutput
argument_list|(
name|job
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RMT_WILL_WATCH */
end_comment

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobExec --  *	Execute the shell for the given job. Called from JobStart and  *	JobRestart.  *  * Results:  *	None.  *  * Side Effects:  *	A shell is executed, outputs is altered and the Job structure added  *	to the job table.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobExec
parameter_list|(
name|job
parameter_list|,
name|argv
parameter_list|)
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* Job to execute */
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|cpid
decl_stmt|;
comment|/* ID of new child */
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"Running %s %sly\n"
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|,
name|job
operator|->
name|flags
operator|&
name|JOB_REMOTE
condition|?
literal|"remote"
else|:
literal|"local"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tCommand: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|argv
index|[
name|i
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Some jobs produce no output and it's disconcerting to have      * no feedback of their running (since they produce no output, the      * banner with their name in it never appears). This is an attempt to      * provide that feedback, even if nothing follows it.      */
if|if
condition|(
operator|(
name|lastNode
operator|!=
name|job
operator|->
name|node
operator|)
operator|&&
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_FIRST
operator|)
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
condition|)
block|{
name|printf
argument_list|(
name|targFmt
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RMT_NO_EXEC
if|if
condition|(
name|job
operator|->
name|flags
operator|&
name|JOB_REMOTE
condition|)
block|{
goto|goto
name|jobExecFinish
goto|;
block|}
endif|#
directive|endif
comment|/* RMT_NO_EXEC */
if|if
condition|(
operator|(
name|cpid
operator|=
name|vfork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|Punt
argument_list|(
literal|"Cannot fork"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cpid
operator|==
literal|0
condition|)
block|{
comment|/* 	 * Must duplicate the input stream down to the child's input and 	 * reset it to the beginning (again). Since the stream was marked 	 * close-on-exec, we must clear that bit in the new input. 	 */
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fileno
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|usePipes
condition|)
block|{
comment|/* 	     * Set up the child's output to be routed through the pipe 	     * we've created for it. 	     */
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|job
operator|->
name|outPipe
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * We're capturing output in a file, so we duplicate the 	     * descriptor to the temporary file into the standard 	     * output. 	     */
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|job
operator|->
name|outFd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The output channels are marked close on exec. This bit was 	 * duplicated by the dup2 (on some systems), so we have to clear 	 * it before routing the shell's error output to the same place as 	 * its standard output. 	 */
name|fcntl
argument_list|(
literal|1
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_PGRP
comment|/* 	 * We want to switch the child into a different process family so 	 * we can kill it and all its descendants in one fell swoop, 	 * by killing its process family, but not commit suicide. 	 */
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|(
name|void
operator|)
name|setpgrp
argument_list|()
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|setpgrp
argument_list|(
literal|0
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|USE_PGRP
if|if
condition|(
name|job
operator|->
name|flags
operator|&
name|JOB_REMOTE
condition|)
block|{
name|Rmt_Exec
argument_list|(
name|shellPath
argument_list|,
name|argv
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|execv
argument_list|(
name|shellPath
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|write
argument_list|(
literal|2
argument_list|,
literal|"Could not execute shell\n"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"Could not execute shell"
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|job
operator|->
name|pid
operator|=
name|cpid
expr_stmt|;
if|if
condition|(
name|usePipes
operator|&&
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_FIRST
operator|)
condition|)
block|{
comment|/* 	     * The first time a job is run for a node, we set the current 	     * position in the buffer to the beginning and mark another 	     * stream to watch in the outputs mask 	     */
name|job
operator|->
name|curPos
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|RMT_WILL_WATCH
name|Rmt_Watch
argument_list|(
name|job
operator|->
name|inPipe
argument_list|,
name|JobLocalInput
argument_list|,
name|job
argument_list|)
expr_stmt|;
else|#
directive|else
name|FD_SET
argument_list|(
name|job
operator|->
name|inPipe
argument_list|,
operator|&
name|outputs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RMT_WILL_WATCH */
block|}
if|if
condition|(
name|job
operator|->
name|flags
operator|&
name|JOB_REMOTE
condition|)
block|{
name|job
operator|->
name|rmtID
operator|=
operator|(
name|char
operator|*
operator|)
name|Rmt_LastID
argument_list|(
name|job
operator|->
name|pid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nLocal
operator|+=
literal|1
expr_stmt|;
comment|/* 	     * XXX: Used to not happen if CUSTOMS. Why? 	     */
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|!=
name|stdout
condition|)
block|{
name|fclose
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
expr_stmt|;
name|job
operator|->
name|cmdFILE
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|jobExecFinish
label|:
comment|/*      * Now the job is actually running, add it to the table.      */
name|nJobs
operator|+=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|jobs
argument_list|,
operator|(
name|ClientData
operator|)
name|job
argument_list|)
expr_stmt|;
if|if
condition|(
name|nJobs
operator|==
name|maxJobs
condition|)
block|{
name|jobFull
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobMakeArgv --  *	Create the argv needed to execute the shell for a given job.  *	  *  * Results:  *  * Side Effects:  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobMakeArgv
parameter_list|(
name|job
parameter_list|,
name|argv
parameter_list|)
name|Job
modifier|*
name|job
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|argc
decl_stmt|;
specifier|static
name|char
name|args
index|[
literal|10
index|]
decl_stmt|;
comment|/* For merged arguments */
name|argv
index|[
literal|0
index|]
operator|=
name|shellName
expr_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|commandShell
operator|->
name|exit
operator|&&
operator|(
operator|*
name|commandShell
operator|->
name|exit
operator|!=
literal|'-'
operator|)
operator|)
operator|||
operator|(
name|commandShell
operator|->
name|echo
operator|&&
operator|(
operator|*
name|commandShell
operator|->
name|echo
operator|!=
literal|'-'
operator|)
operator|)
condition|)
block|{
comment|/* 	 * At least one of the flags doesn't have a minus before it, so 	 * merge them together. Have to do this because the *(&(@*#*&#$# 	 * Bourne shell thinks its second argument is a file to source. 	 * Grrrr. Note the ten-character limitation on the combined arguments. 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|args
argument_list|,
literal|"-%s%s"
argument_list|,
operator|(
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
condition|?
literal|""
else|:
operator|(
name|commandShell
operator|->
name|exit
condition|?
name|commandShell
operator|->
name|exit
else|:
literal|""
operator|)
operator|)
argument_list|,
operator|(
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
condition|?
literal|""
else|:
operator|(
name|commandShell
operator|->
name|echo
condition|?
name|commandShell
operator|->
name|echo
else|:
literal|""
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
block|{
name|argv
index|[
name|argc
index|]
operator|=
name|args
expr_stmt|;
name|argc
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_IGNERR
operator|)
operator|&&
name|commandShell
operator|->
name|exit
condition|)
block|{
name|argv
index|[
name|argc
index|]
operator|=
name|commandShell
operator|->
name|exit
expr_stmt|;
name|argc
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
operator|)
operator|&&
name|commandShell
operator|->
name|echo
condition|)
block|{
name|argv
index|[
name|argc
index|]
operator|=
name|commandShell
operator|->
name|echo
expr_stmt|;
name|argc
operator|++
expr_stmt|;
block|}
block|}
name|argv
index|[
name|argc
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobRestart --  *	Restart a job that stopped for some reason. If the job stopped  *	because it migrated home again, we tell the Rmt module to  *	find a new home for it and make it runnable if Rmt_ReExport  *	succeeded (if it didn't and the job may be run locally, we  *	simply resume it). If the job didn't run and can now, we run it.  *  * Results:  *	None.  *  * Side Effects:  *	jobFull will be set if the job couldn't be run.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobRestart
parameter_list|(
name|job
parameter_list|)
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* Job to restart */
block|{
if|if
condition|(
name|job
operator|->
name|flags
operator|&
name|JOB_REMIGRATE
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Remigrating %x\n"
argument_list|,
name|job
operator|->
name|pid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Rmt_ReExport
argument_list|(
name|job
operator|->
name|pid
argument_list|)
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Couldn't migrate..."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nLocal
operator|!=
name|maxLocal
condition|)
block|{
comment|/* 		 * Job cannot be remigrated, but there's room on the local 		 * machine, so resume the job and note that another 		 * local job has started. 		 */
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"resuming on local machine\n"
argument_list|)
expr_stmt|;
block|}
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
name|nLocal
operator|+=
literal|1
expr_stmt|;
name|job
operator|->
name|flags
operator|&=
operator|~
operator|(
name|JOB_REMIGRATE
operator||
name|JOB_RESUME
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Job cannot be restarted. Mark the table as full and 		 * place the job back on the list of stopped jobs. 		 */
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"holding\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Lst_AtFront
argument_list|(
name|stoppedJobs
argument_list|,
operator|(
name|ClientData
operator|)
name|job
argument_list|)
expr_stmt|;
name|jobFull
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Job queue is full.\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
else|else
block|{
comment|/* 	     * Clear out the remigrate and resume flags. If MIGRATE was set, 	     * leave that around for JobFinish to see so it doesn't print out 	     * that the job was continued. 	     */
name|job
operator|->
name|flags
operator|&=
operator|~
operator|(
name|JOB_REMIGRATE
operator||
name|JOB_RESUME
operator|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|jobs
argument_list|,
operator|(
name|ClientData
operator|)
name|job
argument_list|)
expr_stmt|;
name|nJobs
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|nJobs
operator|==
name|maxJobs
condition|)
block|{
name|jobFull
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Job queue is full.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|job
operator|->
name|flags
operator|&
name|JOB_RESTART
condition|)
block|{
comment|/* 	 * Set up the control arguments to the shell. This is based on the 	 * flags set earlier for this job. If the JOB_IGNERR flag is clear, 	 * the 'exit' flag of the commandShell is used to cause it to exit 	 * upon receiving an error. If the JOB_SILENT flag is clear, the 	 * 'echo' flag of the commandShell is used to get it to start echoing 	 * as soon as it starts processing commands.  	 */
name|char
modifier|*
name|argv
index|[
literal|4
index|]
decl_stmt|;
name|JobMakeArgv
argument_list|(
name|job
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Restarting %s..."
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|job
operator|->
name|node
operator|->
name|type
operator|&
name|OP_NOEXPORT
operator|)
operator|||
ifdef|#
directive|ifdef
name|RMT_NO_EXEC
operator|!
name|Rmt_Export
argument_list|(
name|shellPath
argument_list|,
name|argv
argument_list|,
name|job
argument_list|)
else|#
directive|else
operator|!
name|Rmt_Begin
argument_list|(
name|shellPath
argument_list|,
name|argv
argument_list|,
name|job
operator|->
name|node
argument_list|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
ifdef|#
directive|ifdef
name|sparc
comment|/* KLUDGE */
operator|(
name|job
operator|->
name|node
operator|->
name|type
operator|&
name|OP_M68020
operator|)
operator|||
endif|#
directive|endif
operator|(
operator|(
name|nLocal
operator|>=
name|maxLocal
operator|)
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SPECIAL
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Can't be exported and not allowed to run locally -- put it 		 * back on the hold queue and mark the table full 		 */
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"holding\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Lst_AtFront
argument_list|(
name|stoppedJobs
argument_list|,
operator|(
name|ClientData
operator|)
name|job
argument_list|)
expr_stmt|;
name|jobFull
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Job queue is full.\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
comment|/* 		 * Job may be run locally. 		 */
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"running locally\n"
argument_list|)
expr_stmt|;
block|}
name|job
operator|->
name|flags
operator|&=
operator|~
name|JOB_REMOTE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	     * Can be exported. Hooray! 	     */
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"exporting\n"
argument_list|)
expr_stmt|;
block|}
name|job
operator|->
name|flags
operator||=
name|JOB_REMOTE
expr_stmt|;
block|}
name|JobExec
argument_list|(
name|job
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * The job has stopped and needs to be restarted. Why it stopped, 	 * we don't know... 	 */
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Resuming %s..."
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_REMOTE
operator|)
operator|||
operator|(
name|nLocal
operator|<
name|maxLocal
operator|)
operator|||
operator|(
operator|(
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SPECIAL
operator|)
operator|||
operator|(
name|job
operator|->
name|node
operator|->
name|type
operator|&
name|OP_NOEXPORT
operator|)
operator|)
operator|&&
operator|(
name|maxLocal
operator|==
literal|0
operator|)
operator|)
operator|)
operator|&&
operator|(
name|nJobs
operator|!=
name|maxJobs
operator|)
condition|)
block|{
comment|/* 	     * If the job is remote, it's ok to resume it as long as the 	     * maximum concurrency won't be exceeded. If it's local and 	     * we haven't reached the local concurrency limit already (or the 	     * job must be run locally and maxLocal is 0), it's also ok to 	     * resume it. 	     */
name|Boolean
name|error
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
name|union
name|wait
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|RMT_WANTS_SIGNALS
if|if
condition|(
name|job
operator|->
name|flags
operator|&
name|JOB_REMOTE
condition|)
block|{
name|error
operator|=
operator|!
name|Rmt_Signal
argument_list|(
name|job
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* RMT_WANTS_SIGNALS */
name|error
operator|=
operator|(
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|SIGCONT
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* 		 * Make sure the user knows we've continued the beast and 		 * actually put the thing in the job table. 		 */
name|job
operator|->
name|flags
operator||=
name|JOB_CONTINUING
expr_stmt|;
name|status
operator|.
name|w_termsig
operator|=
name|SIGCONT
expr_stmt|;
name|JobFinish
argument_list|(
name|job
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|job
operator|->
name|flags
operator|&=
operator|~
operator|(
name|JOB_RESUME
operator||
name|JOB_CONTINUING
operator|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Error
argument_list|(
literal|"couldn't resume %s: %s"
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|status
operator|.
name|w_status
operator|=
literal|0
expr_stmt|;
name|status
operator|.
name|w_retcode
operator|=
literal|1
expr_stmt|;
name|JobFinish
argument_list|(
name|job
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	     * Job cannot be restarted. Mark the table as full and 	     * place the job back on the list of stopped jobs. 	     */
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"table full\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Lst_AtFront
argument_list|(
name|stoppedJobs
argument_list|,
operator|(
name|ClientData
operator|)
name|job
argument_list|)
expr_stmt|;
name|jobFull
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Job queue is full.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobStart  --  *	Start a target-creation process going for the target described  *	by the graph node gn.   *  * Results:  *	JOB_ERROR if there was an error in the commands, JOB_FINISHED  *	if there isn't actually anything left to do for the job and  *	JOB_RUNNING if the job has been started.  *  * Side Effects:  *	A new Job node is created and added to the list of running  *	jobs. PMake is forked and a child shell created.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|JobStart
parameter_list|(
name|gn
parameter_list|,
name|flags
parameter_list|,
name|previous
parameter_list|)
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* target to create */
name|short
name|flags
decl_stmt|;
comment|/* flags for the job to override normal ones. 			       * e.g. JOB_SPECIAL or JOB_IGNDOTS */
name|Job
modifier|*
name|previous
decl_stmt|;
comment|/* The previous Job structure for this node, 			       * if any. */
block|{
specifier|register
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* new job descriptor */
name|char
modifier|*
name|argv
index|[
literal|4
index|]
decl_stmt|;
comment|/* Argument vector to shell */
name|char
name|args
index|[
literal|5
index|]
decl_stmt|;
comment|/* arguments to shell */
specifier|static
name|int
name|jobno
init|=
literal|0
decl_stmt|;
comment|/* job number of catching output in a file */
name|Boolean
name|cmdsOK
decl_stmt|;
comment|/* true if the nodes commands were all right */
name|Boolean
name|local
decl_stmt|;
comment|/* Set true if the job was run locally */
name|Boolean
name|noExec
decl_stmt|;
comment|/* Set true if we decide not to run the job */
if|if
condition|(
name|previous
operator|!=
operator|(
name|Job
operator|*
operator|)
name|NULL
condition|)
block|{
name|previous
operator|->
name|flags
operator|&=
operator|~
operator|(
name|JOB_FIRST
operator||
name|JOB_IGNERR
operator||
name|JOB_SILENT
operator||
name|JOB_REMOTE
operator|)
expr_stmt|;
name|job
operator|=
name|previous
expr_stmt|;
block|}
else|else
block|{
name|job
operator|=
operator|(
name|Job
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Job
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|==
operator|(
name|Job
operator|*
operator|)
name|NULL
condition|)
block|{
name|Punt
argument_list|(
literal|"JobStart out of memory"
argument_list|)
expr_stmt|;
block|}
name|flags
operator||=
name|JOB_FIRST
expr_stmt|;
block|}
name|job
operator|->
name|node
operator|=
name|gn
expr_stmt|;
name|job
operator|->
name|tailCmds
operator|=
name|NILLNODE
expr_stmt|;
comment|/*      * Set the initial value of the flags for this job based on the global      * ones and the node's attributes... Any flags supplied by the caller      * are also added to the field.      */
name|job
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Targ_Ignore
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|job
operator|->
name|flags
operator||=
name|JOB_IGNERR
expr_stmt|;
block|}
if|if
condition|(
name|Targ_Silent
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|job
operator|->
name|flags
operator||=
name|JOB_SILENT
expr_stmt|;
block|}
name|job
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
comment|/*      * Check the commands now so any attributes from .DEFAULT have a chance      * to migrate to the node      */
if|if
condition|(
operator|!
name|backwards
operator|||
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_FIRST
operator|)
condition|)
block|{
name|cmdsOK
operator|=
name|Job_CheckCommands
argument_list|(
name|gn
argument_list|,
name|Error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmdsOK
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/*      * If the -n flag wasn't given, we open up OUR (not the child's)      * temporary file to stuff commands in it. The thing is rd/wr so we don't      * need to reopen it to feed it to the shell. If the -n flag *was* given,      * we just set the file to be stdout. Cute, huh?      */
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_MAKE
operator|)
operator|||
operator|(
operator|!
name|noExecute
operator|&&
operator|!
name|touchFlag
operator|)
condition|)
block|{
comment|/* 	 * We're serious here, but if the commands were bogus, we're 	 * also dead... 	 */
if|if
condition|(
operator|!
name|cmdsOK
condition|)
block|{
name|DieHorribly
argument_list|()
expr_stmt|;
block|}
name|job
operator|->
name|cmdFILE
operator|=
name|fopen
argument_list|(
name|tfile
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
name|Punt
argument_list|(
literal|"Could not open %s"
argument_list|,
name|tfile
argument_list|)
expr_stmt|;
block|}
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Send the commands to the command file, flush all its buffers then 	 * rewind and remove the thing. 	 */
name|noExec
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|backwards
condition|)
block|{
comment|/* 	     * Be compatible: If this is the first time for this node, 	     * verify its commands are ok and open the commands list for 	     * sequential access by later invocations of JobStart. 	     * Once that is done, we take the next command off the list 	     * and print it to the command file. If the command was an 	     * ellipsis, note that there's nothing more to execute. 	     */
if|if
condition|(
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_FIRST
operator|)
operator|&&
operator|(
name|Lst_Open
argument_list|(
name|gn
operator|->
name|commands
argument_list|)
operator|!=
name|SUCCESS
operator|)
condition|)
block|{
name|cmdsOK
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|LstNode
name|ln
init|=
name|Lst_Next
argument_list|(
name|gn
operator|->
name|commands
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ln
operator|==
name|NILLNODE
operator|)
operator|||
name|JobPrintCommand
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|job
argument_list|)
condition|)
block|{
name|noExec
operator|=
name|TRUE
expr_stmt|;
name|Lst_Close
argument_list|(
name|gn
operator|->
name|commands
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noExec
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_FIRST
operator|)
condition|)
block|{
comment|/* 		     * If we're not going to execute anything, the job 		     * is done and we need to close down the various 		     * file descriptors we've opened for output, then 		     * call JobDoOutput to catch the final characters or 		     * send the file to the screen... Note that the i/o streams 		     * are only open if this isn't the first job. 		     * Note also that this could not be done in 		     * Job_CatchChildren b/c it wasn't clear if there were 		     * more commands to execute or not... 		     */
if|if
condition|(
name|usePipes
condition|)
block|{
ifdef|#
directive|ifdef
name|RMT_WILL_WATCH
name|Rmt_Ignore
argument_list|(
name|job
operator|->
name|inPipe
argument_list|)
expr_stmt|;
else|#
directive|else
name|FD_CLR
argument_list|(
name|job
operator|->
name|inPipe
argument_list|,
operator|&
name|outputs
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|job
operator|->
name|outPipe
operator|!=
name|job
operator|->
name|inPipe
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|job
operator|->
name|outPipe
argument_list|)
expr_stmt|;
block|}
name|JobDoOutput
argument_list|(
name|job
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|job
operator|->
name|inPipe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|job
operator|->
name|outFd
argument_list|)
expr_stmt|;
name|JobDoOutput
argument_list|(
name|job
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* 	     * We can do all the commands at once. hooray for sanity 	     */
name|numCommands
operator|=
literal|0
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|commands
argument_list|,
name|JobPrintCommand
argument_list|,
operator|(
name|ClientData
operator|)
name|job
argument_list|)
expr_stmt|;
comment|/* 	     * If we didn't print out any commands to the shell script, 	     * there's not much point in executing the shell, is there? 	     */
if|if
condition|(
name|numCommands
operator|==
literal|0
condition|)
block|{
name|noExec
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|noExecute
condition|)
block|{
comment|/* 	 * Not executing anything -- just print all the commands to stdout 	 * in one fell swoop. This will still set up job->tailCmds correctly. 	 */
if|if
condition|(
name|lastNode
operator|!=
name|gn
condition|)
block|{
name|printf
argument_list|(
name|targFmt
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|gn
expr_stmt|;
block|}
name|job
operator|->
name|cmdFILE
operator|=
name|stdout
expr_stmt|;
comment|/* 	 * Only print the commands if they're ok, but don't die if they're 	 * not -- just let the user know they're bad and keep going. It 	 * doesn't do any harm in this case and may do some good. 	 */
if|if
condition|(
name|cmdsOK
condition|)
block|{
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|commands
argument_list|,
name|JobPrintCommand
argument_list|,
operator|(
name|ClientData
operator|)
name|job
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Don't execute the shell, thank you. 	 */
name|noExec
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Just touch the target and note that no shell should be executed. 	 * Set cmdFILE to stdout to make life easier. Check the commands, too, 	 * but don't die if they're no good -- it does no harm to keep working 	 * up the graph. 	 */
name|job
operator|->
name|cmdFILE
operator|=
name|stdout
expr_stmt|;
name|Job_Touch
argument_list|(
name|gn
argument_list|,
name|job
operator|->
name|flags
operator|&
name|JOB_SILENT
argument_list|)
expr_stmt|;
name|noExec
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/*      * If we're not supposed to execute a shell, don't.       */
if|if
condition|(
name|noExec
condition|)
block|{
comment|/* 	 * Unlink and close the command file if we opened one 	 */
if|if
condition|(
name|job
operator|->
name|cmdFILE
operator|!=
name|stdout
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We only want to work our way up the graph if we aren't here because 	 * the commands for the job were no good. 	 */
if|if
condition|(
name|cmdsOK
condition|)
block|{
if|if
condition|(
name|aborting
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|job
operator|->
name|tailCmds
operator|!=
name|NILLNODE
condition|)
block|{
name|Lst_ForEachFrom
argument_list|(
name|job
operator|->
name|node
operator|->
name|commands
argument_list|,
name|job
operator|->
name|tailCmds
argument_list|,
name|JobSaveCommand
argument_list|,
operator|(
name|ClientData
operator|)
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
name|Make_Update
argument_list|(
name|job
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|Address
operator|)
name|job
argument_list|)
expr_stmt|;
return|return
operator|(
name|JOB_FINISHED
operator|)
return|;
block|}
else|else
block|{
name|free
argument_list|(
operator|(
name|Address
operator|)
name|job
argument_list|)
expr_stmt|;
return|return
operator|(
name|JOB_ERROR
operator|)
return|;
block|}
block|}
else|else
block|{
name|fflush
argument_list|(
name|job
operator|->
name|cmdFILE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
block|}
comment|/*      * Set up the control arguments to the shell. This is based on the flags      * set earlier for this job.      */
name|JobMakeArgv
argument_list|(
name|job
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/*      * If we're using pipes to catch output, create the pipe by which we'll      * get the shell's output. If we're using files, print out that we're      * starting a job and then set up its temporary-file name. This is just      * tfile with two extra digits tacked on -- jobno.      */
if|if
condition|(
operator|!
name|backwards
operator|||
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_FIRST
operator|)
condition|)
block|{
if|if
condition|(
name|usePipes
condition|)
block|{
name|int
name|fd
index|[
literal|2
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|pipe
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|job
operator|->
name|inPipe
operator|=
name|fd
index|[
literal|0
index|]
expr_stmt|;
name|job
operator|->
name|outPipe
operator|=
name|fd
index|[
literal|1
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|job
operator|->
name|inPipe
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|job
operator|->
name|outPipe
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Remaking `%s'\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|job
operator|->
name|outFile
argument_list|,
literal|"%s%02d"
argument_list|,
name|tfile
argument_list|,
name|jobno
argument_list|)
expr_stmt|;
name|jobno
operator|=
operator|(
name|jobno
operator|+
literal|1
operator|)
operator|%
literal|100
expr_stmt|;
name|job
operator|->
name|outFd
operator|=
name|open
argument_list|(
name|job
operator|->
name|outFile
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_APPEND
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|job
operator|->
name|outFd
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_NOEXPORT
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|RMT_NO_EXEC
name|local
operator|=
operator|!
name|Rmt_Export
argument_list|(
name|shellPath
argument_list|,
name|argv
argument_list|,
name|job
argument_list|)
expr_stmt|;
else|#
directive|else
name|local
operator|=
operator|!
name|Rmt_Begin
argument_list|(
name|shellPath
argument_list|,
name|argv
argument_list|,
name|gn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RMT_NO_EXEC */
if|if
condition|(
operator|!
name|local
condition|)
block|{
name|job
operator|->
name|flags
operator||=
name|JOB_REMOTE
expr_stmt|;
block|}
block|}
else|else
block|{
name|local
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|local
operator|&&
operator|(
ifdef|#
directive|ifdef
name|sparc
comment|/* KLUDGE */
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_M68020
operator|)
operator|||
endif|#
directive|endif
operator|(
operator|(
name|nLocal
operator|>=
name|maxLocal
operator|)
operator|&&
operator|!
operator|(
name|job
operator|->
name|flags
operator|&
name|JOB_SPECIAL
operator|)
operator|&&
operator|(
operator|!
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_NOEXPORT
operator|)
operator|||
operator|(
name|maxLocal
operator|!=
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* 	 * The job can only be run locally, but we've hit the limit of 	 * local concurrency, so put the job on hold until some other job 	 * finishes. Note that the special jobs (.BEGIN, .INTERRUPT and .END) 	 * may be run locally even when the local limit has been reached 	 * (e.g. when maxLocal == 0), though they will be exported if at 	 * all possible. In addition, any target marked with .NOEXPORT will 	 * be run locally if maxLocal is 0. 	 */
name|jobFull
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Can only run job locally.\n"
argument_list|)
expr_stmt|;
block|}
name|job
operator|->
name|flags
operator||=
name|JOB_RESTART
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|stoppedJobs
argument_list|,
operator|(
name|ClientData
operator|)
name|job
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|nLocal
operator|>=
name|maxLocal
operator|)
operator|&&
name|local
condition|)
block|{
comment|/* 	     * If we're running this job locally as a special case (see above), 	     * at least say the table is full. 	     */
name|jobFull
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Local job queue is full.\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|JobExec
argument_list|(
name|job
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|JOB_RUNNING
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobDoOutput  --  *	This function is called at different times depending on  *	whether the user has specified that output is to be collected  *	via pipes or temporary files. In the former case, we are called  *	whenever there is something to read on the pipe. We collect more  *	output from the given job and store it in the job's outBuf. If  *	this makes up a line, we print it tagged by the job's identifier,  *	as necessary.  *	If output has been collected in a temporary file, we open the  *	file and read it line by line, transfering it to our own  *	output channel until the file is empty. At which point we  *	remove the temporary file.  *	In both cases, however, we keep our figurative eye out for the  *	'noPrint' line for the shell from which the output came. If  *	we recognize a line, we don't print it. If the command is not  *	alone on the line (the character after it is not \0 or \n), we  *	do print whatever follows it.  *  * Results:  *	None  *  * Side Effects:  *	curPos may be shifted as may the contents of outBuf.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|JobDoOutput
parameter_list|(
name|job
parameter_list|,
name|finish
parameter_list|)
specifier|register
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* the job whose output needs printing */
name|Boolean
name|finish
decl_stmt|;
comment|/* TRUE if this is the last time we'll be 				   * called for this job */
block|{
name|Boolean
name|gotNL
init|=
name|FALSE
decl_stmt|;
comment|/* true if got a newline */
specifier|register
name|int
name|nr
decl_stmt|;
comment|/* number of bytes read */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* auxiliary index into outBuf */
specifier|register
name|int
name|max
decl_stmt|;
comment|/* limit for i (end of current data) */
name|int
name|nRead
decl_stmt|;
comment|/* (Temporary) number of bytes read */
name|char
name|c
decl_stmt|;
comment|/* character after noPrint string */
name|FILE
modifier|*
name|oFILE
decl_stmt|;
comment|/* Stream pointer to shell's output file */
name|char
name|inLine
index|[
literal|132
index|]
decl_stmt|;
if|if
condition|(
name|usePipes
condition|)
block|{
comment|/* 	 * Read as many bytes as will fit in the buffer. 	 */
name|end_loop
label|:
name|nRead
operator|=
name|read
argument_list|(
name|job
operator|->
name|inPipe
argument_list|,
operator|&
name|job
operator|->
name|outBuf
index|[
name|job
operator|->
name|curPos
index|]
argument_list|,
name|JOB_BUFSIZE
operator|-
name|job
operator|->
name|curPos
argument_list|)
expr_stmt|;
if|if
condition|(
name|nRead
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"JobDoOutput(piperead)"
argument_list|)
expr_stmt|;
block|}
name|nr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|nr
operator|=
name|nRead
expr_stmt|;
block|}
comment|/* 	 * If we hit the end-of-file (the job is dead), we must flush its 	 * remaining output, so pretend we read a newline if there's any 	 * output remaining in the buffer. 	 * Also clear the 'finish' flag so we stop looping. 	 */
if|if
condition|(
operator|(
name|nr
operator|==
literal|0
operator|)
operator|&&
operator|(
name|job
operator|->
name|curPos
operator|!=
literal|0
operator|)
condition|)
block|{
name|job
operator|->
name|outBuf
index|[
name|job
operator|->
name|curPos
index|]
operator|=
literal|'\n'
expr_stmt|;
name|nr
operator|=
literal|1
expr_stmt|;
name|finish
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nr
operator|==
literal|0
condition|)
block|{
name|finish
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* 	 * Look for the last newline in the bytes we just got. If there is 	 * one, break out of the loop with 'i' as its index and gotNL set 	 * TRUE.  	 */
name|max
operator|=
name|job
operator|->
name|curPos
operator|+
name|nr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|job
operator|->
name|curPos
operator|+
name|nr
operator|-
literal|1
init|;
name|i
operator|>=
name|job
operator|->
name|curPos
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|job
operator|->
name|outBuf
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
name|gotNL
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|job
operator|->
name|outBuf
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * Why? 		 */
name|job
operator|->
name|outBuf
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|gotNL
condition|)
block|{
name|job
operator|->
name|curPos
operator|+=
name|nr
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|curPos
operator|==
name|JOB_BUFSIZE
condition|)
block|{
comment|/* 		 * If we've run out of buffer space, we have no choice 		 * but to print the stuff. sigh.  		 */
name|gotNL
operator|=
name|TRUE
expr_stmt|;
name|i
operator|=
name|job
operator|->
name|curPos
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gotNL
condition|)
block|{
comment|/* 	     * Need to send the output to the screen. Null terminate it 	     * first, overwriting the newline character if there was one. 	     * So long as the line isn't one we should filter (according 	     * to the shell description), we print the line, preceeded 	     * by a target banner if this target isn't the same as the 	     * one for which we last printed something. 	     * The rest of the data in the buffer are then shifted down 	     * to the start of the buffer and curPos is set accordingly.  	     */
name|job
operator|->
name|outBuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|job
operator|->
name|curPos
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ecp
decl_stmt|;
name|cp
operator|=
name|job
operator|->
name|outBuf
expr_stmt|;
if|if
condition|(
name|commandShell
operator|->
name|noPrint
condition|)
block|{
name|ecp
operator|=
name|Str_FindSubstring
argument_list|(
name|job
operator|->
name|outBuf
argument_list|,
name|commandShell
operator|->
name|noPrint
argument_list|)
expr_stmt|;
while|while
condition|(
name|ecp
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|cp
operator|!=
name|ecp
condition|)
block|{
operator|*
name|ecp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|printf
argument_list|(
name|targFmt
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
comment|/* 			     * The only way there wouldn't be a newline after 			     * this line is if it were the last in the buffer. 			     * however, since the non-printable comes after it, 			     * there must be a newline, so we don't print one. 			     */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|ecp
operator|+
name|commandShell
operator|->
name|noPLen
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
operator|&
name|job
operator|->
name|outBuf
index|[
name|i
index|]
condition|)
block|{
comment|/* 			     * Still more to print, look again after skipping 			     * the whitespace following the non-printable 			     * command.... 			     */
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
operator|||
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|ecp
operator|=
name|Str_FindSubstring
argument_list|(
name|cp
argument_list|,
name|commandShell
operator|->
name|noPrint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
comment|/* 		 * There's still more in that thar buffer. This time, though, 		 * we know there's no newline at the end, so we add one of 		 * our own free will. 		 */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|job
operator|->
name|node
operator|!=
name|lastNode
condition|)
block|{
name|printf
argument_list|(
name|targFmt
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
name|lastNode
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|max
operator|-
literal|1
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|job
operator|->
name|outBuf
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
comment|/* shift the remaining */
name|job
operator|->
name|outBuf
argument_list|,
comment|/* characters down */
name|max
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|job
operator|->
name|curPos
operator|=
name|max
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We have written everything out, so we just start over 		 * from the start of the buffer. No copying. No nothing. 		 */
name|job
operator|->
name|curPos
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|finish
condition|)
block|{
comment|/* 	     * If the finish flag is true, we must loop until we hit 	     * end-of-file on the pipe. This is guaranteed to happen eventually 	     * since the other end of the pipe is now closed (we closed it 	     * explicitly and the child has exited). When we do get an EOF, 	     * finish will be set FALSE and we'll fall through and out. 	     */
goto|goto
name|end_loop
goto|;
block|}
block|}
else|else
block|{
comment|/* 	 * We've been called to retrieve the output of the job from the 	 * temporary file where it's been squirreled away. This consists of 	 * opening the file, reading the output line by line, being sure not 	 * to print the noPrint line for the shell we used, then close and 	 * remove the temporary file. Very simple. 	 * 	 * Change to read in blocks and do FindSubString type things as for 	 * pipes? That would allow for "@echo -n..." 	 */
name|oFILE
operator|=
name|fopen
argument_list|(
name|job
operator|->
name|outFile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|oFILE
operator|!=
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Results of making %s:\n"
argument_list|,
name|job
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|inLine
argument_list|,
sizeof|sizeof
argument_list|(
name|inLine
argument_list|)
argument_list|,
name|oFILE
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ecp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|cp
operator|=
name|inLine
expr_stmt|;
name|endp
operator|=
name|inLine
operator|+
name|strlen
argument_list|(
name|inLine
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
operator|*
operator|--
name|endp
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|commandShell
operator|->
name|noPrint
condition|)
block|{
name|ecp
operator|=
name|Str_FindSubstring
argument_list|(
name|cp
argument_list|,
name|commandShell
operator|->
name|noPrint
argument_list|)
expr_stmt|;
while|while
condition|(
name|ecp
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|cp
operator|!=
name|ecp
condition|)
block|{
operator|*
name|ecp
operator|=
literal|'\0'
expr_stmt|;
comment|/* 			     * The only way there wouldn't be a newline after 			     * this line is if it were the last in the buffer. 			     * however, since the non-printable comes after it, 			     * there must be a newline, so we don't print one. 			     */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|ecp
operator|+
name|commandShell
operator|->
name|noPLen
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|endp
condition|)
block|{
comment|/* 			     * Still more to print, look again after skipping 			     * the whitespace following the non-printable 			     * command.... 			     */
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
operator|||
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|ecp
operator|=
name|Str_FindSubstring
argument_list|(
name|cp
argument_list|,
name|commandShell
operator|->
name|noPrint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
comment|/* 		 * There's still more in that thar buffer. This time, though, 		 * we know there's no newline at the end, so we add one of 		 * our own free will. 		 */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|oFILE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|job
operator|->
name|outFile
argument_list|)
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_CatchChildren --  *	Handle the exit of a child. Called from Make_Make.  *  * Results:  *	none.  *  * Side Effects:  *	The job descriptor is removed from the list of children.  *  * Notes:  *	We do waits, blocking or not, according to the wisdom of our  *	caller, until there are no more children to report. For each  *	job, call JobFinish to finish things off. This will take care of  *	putting jobs on the stoppedJobs queue.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_CatchChildren
parameter_list|(
name|block
parameter_list|)
name|Boolean
name|block
decl_stmt|;
comment|/* TRUE if should block on the wait. */
block|{
name|int
name|pid
decl_stmt|;
comment|/* pid of dead child */
specifier|register
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* job descriptor for dead child */
name|LstNode
name|jnode
decl_stmt|;
comment|/* list element for finding job */
name|union
name|wait
name|status
decl_stmt|;
comment|/* Exit/termination status */
comment|/*      * Don't even bother if we know there's no one around.      */
if|if
condition|(
name|nLocal
operator|==
literal|0
condition|)
block|{
return|return;
block|}
while|while
condition|(
operator|(
name|pid
operator|=
name|wait3
argument_list|(
operator|&
name|status
argument_list|,
operator|(
name|block
condition|?
literal|0
else|:
name|WNOHANG
operator|)
operator||
name|WUNTRACED
argument_list|,
operator|(
expr|struct
name|rusage
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|Sprite
name|printf
argument_list|(
literal|"Process %x exited or stopped.\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"Process %d exited or stopped.\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Sprite */
block|}
name|jnode
operator|=
name|Lst_Find
argument_list|(
name|jobs
argument_list|,
operator|(
name|ClientData
operator|)
name|pid
argument_list|,
name|JobCmpPid
argument_list|)
expr_stmt|;
if|if
condition|(
name|jnode
operator|==
name|NILLNODE
condition|)
block|{
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
operator|&&
operator|(
name|status
operator|.
name|w_termsig
operator|==
name|SIGCONT
operator|)
condition|)
block|{
name|jnode
operator|=
name|Lst_Find
argument_list|(
name|stoppedJobs
argument_list|,
operator|(
name|ClientData
operator|)
name|pid
argument_list|,
name|JobCmpPid
argument_list|)
expr_stmt|;
if|if
condition|(
name|jnode
operator|==
name|NILLNODE
condition|)
block|{
ifdef|#
directive|ifdef
name|Sprite
name|Error
argument_list|(
literal|"Resumed child (%x) not in table"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
else|#
directive|else
name|Error
argument_list|(
literal|"Resumed child (%d) not in table"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Sprite */
continue|continue;
block|}
name|job
operator|=
operator|(
name|Job
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|jnode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_Remove
argument_list|(
name|stoppedJobs
argument_list|,
name|jnode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|Sprite
name|Error
argument_list|(
literal|"Child (%x) not in table?"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
else|#
directive|else
name|Error
argument_list|(
literal|"Child (%d) not in table?"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Sprite */
continue|continue;
block|}
block|}
else|else
block|{
name|job
operator|=
operator|(
name|Job
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|jnode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_Remove
argument_list|(
name|jobs
argument_list|,
name|jnode
argument_list|)
expr_stmt|;
name|nJobs
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|jobFull
operator|&&
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Job queue is no longer full.\n"
argument_list|)
expr_stmt|;
block|}
name|jobFull
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|flags
operator|&
name|JOB_REMOTE
condition|)
block|{
name|Rmt_Done
argument_list|(
name|job
operator|->
name|rmtID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nLocal
operator|-=
literal|1
expr_stmt|;
block|}
block|}
name|JobFinish
argument_list|(
name|job
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_CatchOutput --  *	Catch the output from our children, if we're using  *	pipes do so. Otherwise just block time until we get a  *	signal (most likely a SIGCHLD) since there's no point in  *	just spinning when there's nothing to do and the reaping  *	of a child can wait for a while.   *  * Results:  *	None   *  * Side Effects:  *	Output is read from pipes if we're piping.  * -----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_CatchOutput
parameter_list|()
block|{
name|int
name|nfds
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|fd_set
name|readfds
decl_stmt|;
specifier|register
name|LstNode
name|ln
decl_stmt|;
specifier|register
name|Job
modifier|*
name|job
decl_stmt|;
name|int
name|pnJobs
decl_stmt|;
comment|/* Previous nJobs */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RMT_WILL_WATCH
name|pnJobs
operator|=
name|nJobs
expr_stmt|;
comment|/*      * It is possible for us to be called with nJobs equal to 0. This happens      * if all the jobs finish and a job that is stopped cannot be run      * locally (eg if maxLocal is 0) and cannot be exported. The job will      * be placed back on the stoppedJobs queue, Job_Empty() will return false,      * Make_Run will call us again when there's nothing for which to wait.      * nJobs never changes, so we loop forever. Hence the check. It could      * be argued that we should sleep for a bit so as not to swamp the      * exportation system with requests. Perhaps we should.      *      * NOTE: IT IS THE RESPONSIBILITY OF Rmt_Wait TO CALL Job_CatchChildren      * IN A TIMELY FASHION TO CATCH ANY LOCALLY RUNNING JOBS THAT EXIT.      * It may use the variable nLocal to determine if it needs to call      * Job_CatchChildren (if nLocal is 0, there's nothing for which to      * wait...)      */
while|while
condition|(
name|nJobs
operator|!=
literal|0
operator|&&
name|pnJobs
operator|==
name|nJobs
condition|)
block|{
name|Rmt_Wait
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|usePipes
condition|)
block|{
name|readfds
operator|=
name|outputs
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
name|SEL_SEC
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
name|SEL_USEC
expr_stmt|;
if|if
condition|(
operator|(
name|nfds
operator|=
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|readfds
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return;
block|}
else|else
block|{
if|if
condition|(
name|Lst_Open
argument_list|(
name|jobs
argument_list|)
operator|==
name|FAILURE
condition|)
block|{
name|Punt
argument_list|(
literal|"Cannot open job table"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|nfds
operator|&&
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|jobs
argument_list|)
operator|)
operator|!=
name|NILLNODE
condition|)
block|{
name|job
operator|=
operator|(
name|Job
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|job
operator|->
name|inPipe
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
block|{
name|JobDoOutput
argument_list|(
name|job
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|nfds
operator|-=
literal|1
expr_stmt|;
block|}
block|}
name|Lst_Close
argument_list|(
name|jobs
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* RMT_WILL_WATCH */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_Make --  *	Start the creation of a target. Basically a front-end for  *	JobStart used by the Make module.  *  * Results:  *	None.  *  * Side Effects:  *	Another job is started.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_Make
parameter_list|(
name|gn
parameter_list|)
name|GNode
modifier|*
name|gn
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|JobStart
argument_list|(
name|gn
argument_list|,
literal|0
argument_list|,
operator|(
name|Job
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_Init --  *	Initialize the process module  *  * Results:  *	none  *  * Side Effects:  *	lists and counters are initialized  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_Init
parameter_list|(
name|maxproc
parameter_list|,
name|maxlocal
parameter_list|)
name|int
name|maxproc
decl_stmt|;
comment|/* the greatest number of jobs which may be 			     * running at one time */
name|int
name|maxlocal
decl_stmt|;
comment|/* the greatest number of local jobs which may 			     * be running at once. */
block|{
name|GNode
modifier|*
name|begin
decl_stmt|;
comment|/* node for commands to do at the very start */
ifdef|#
directive|ifdef
name|Sprite
name|sprintf
argument_list|(
name|tfile
argument_list|,
literal|"/tmp/make%05x"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|tfile
argument_list|,
literal|"/tmp/make%05d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Sprite */
name|jobs
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|stoppedJobs
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|maxJobs
operator|=
name|maxproc
expr_stmt|;
name|maxLocal
operator|=
name|maxlocal
expr_stmt|;
name|nJobs
operator|=
literal|0
expr_stmt|;
name|nLocal
operator|=
literal|0
expr_stmt|;
name|jobFull
operator|=
name|FALSE
expr_stmt|;
name|aborting
operator|=
literal|0
expr_stmt|;
name|errors
operator|=
literal|0
expr_stmt|;
name|lastNode
operator|=
name|NILGNODE
expr_stmt|;
if|if
condition|(
name|maxJobs
operator|==
literal|1
condition|)
block|{
comment|/* 	 * If only one job can run at a time, there's no need for a banner, 	 * no is there? 	 */
name|targFmt
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|targFmt
operator|=
name|TARG_FMT
expr_stmt|;
block|}
if|if
condition|(
name|shellPath
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* 	 * The user didn't specify a shell to use, so we are using the 	 * default one... Both the absolute path and the last component 	 * must be set. The last component is taken from the 'name' field 	 * of the default shell description pointed-to by commandShell. 	 * All default shells are located in DEFSHELLDIR. 	 */
name|shellName
operator|=
name|commandShell
operator|->
name|name
expr_stmt|;
name|shellPath
operator|=
name|Str_Concat
argument_list|(
name|DEFSHELLDIR
argument_list|,
name|shellName
argument_list|,
name|STR_ADDSLASH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commandShell
operator|->
name|exit
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|commandShell
operator|->
name|exit
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|commandShell
operator|->
name|echo
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|commandShell
operator|->
name|echo
operator|=
literal|""
expr_stmt|;
block|}
comment|/*      * Catch the four signals that POSIX specifies if they aren't ignored.      * JobPassSig will take care of calling JobInterrupt if appropriate.      */
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|JobPassSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|JobPassSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|JobPassSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|JobPassSig
argument_list|)
expr_stmt|;
block|}
comment|/*      * There are additional signals that need to be caught and passed if      * either the export system wants to be told directly of signals or if      * we're giving each job its own process group (since then it won't get      * signals from the terminal driver as we own the terminal)      */
if|#
directive|if
name|defined
argument_list|(
name|RMT_WANTS_SIGNALS
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_PGRP
argument_list|)
if|if
condition|(
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|JobPassSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|JobPassSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|JobPassSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|JobPassSig
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|begin
operator|=
name|Targ_FindNode
argument_list|(
literal|".BEGIN"
argument_list|,
name|TARG_NOCREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|begin
operator|!=
name|NILGNODE
condition|)
block|{
name|JobStart
argument_list|(
name|begin
argument_list|,
name|JOB_SPECIAL
argument_list|,
operator|(
name|Job
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|nJobs
condition|)
block|{
name|Job_CatchOutput
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|RMT_WILL_WATCH
name|Job_CatchChildren
argument_list|(
operator|!
name|usePipes
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RMT_WILL_WATCH */
block|}
block|}
name|postCommands
operator|=
name|Targ_FindNode
argument_list|(
literal|".END"
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_Full --  *	See if the job table is full. It is considered full if it is OR  *	if we are in the process of aborting OR if we have  *	reached/exceeded our local quota. This prevents any more jobs  *	from starting up.  *  * Results:  *	TRUE if the job table is full, FALSE otherwise  * Side Effects:  *	None.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Job_Full
parameter_list|()
block|{
return|return
operator|(
name|aborting
operator|||
name|jobFull
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_Empty --  *	See if the job table is empty.  Because the local concurrency may  *	be set to 0, it is possible for the job table to become empty,  *	while the list of stoppedJobs remains non-empty. In such a case,  *	we want to restart as many jobs as we can.  *  * Results:  *	TRUE if it is. FALSE if it ain't.  *  * Side Effects:  *	None.  *  * -----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Job_Empty
parameter_list|()
block|{
if|if
condition|(
name|nJobs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|stoppedJobs
argument_list|)
operator|&&
operator|!
name|aborting
condition|)
block|{
comment|/* 	     * The job table is obviously not full if it has no jobs in 	     * it...Try and restart the stopped jobs. 	     */
name|jobFull
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|jobFull
operator|&&
operator|!
name|Lst_IsEmpty
argument_list|(
name|stoppedJobs
argument_list|)
condition|)
block|{
name|JobRestart
argument_list|(
operator|(
name|Job
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|stoppedJobs
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobMatchShell --  *	Find a matching shell in 'shells' given its final component.  *  * Results:  *	A pointer to the Shell structure.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Shell
modifier|*
name|JobMatchShell
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Final component of shell path */
block|{
specifier|register
name|Shell
modifier|*
name|sh
decl_stmt|;
comment|/* Pointer into shells table */
name|Shell
modifier|*
name|match
decl_stmt|;
comment|/* Longest-matching shell */
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|char
modifier|*
name|eoname
decl_stmt|;
name|eoname
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|match
operator|=
operator|(
name|Shell
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|sh
operator|=
name|shells
init|;
name|sh
operator|->
name|name
operator|!=
name|NULL
condition|;
name|sh
operator|++
control|)
block|{
for|for
control|(
name|cp1
operator|=
name|eoname
operator|-
name|strlen
argument_list|(
name|sh
operator|->
name|name
argument_list|)
operator|,
name|cp2
operator|=
name|sh
operator|->
name|name
init|;
operator|*
name|cp1
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp1
operator|==
operator|*
name|cp2
condition|;
name|cp1
operator|++
operator|,
name|cp2
operator|++
control|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp1
operator|!=
operator|*
name|cp2
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|match
operator|==
operator|(
name|Shell
operator|*
operator|)
name|NULL
operator|||
name|strlen
argument_list|(
name|match
operator|->
name|name
argument_list|)
operator|<
name|strlen
argument_list|(
name|sh
operator|->
name|name
argument_list|)
condition|)
block|{
name|match
operator|=
name|sh
expr_stmt|;
block|}
block|}
return|return
operator|(
name|match
operator|==
operator|(
name|Shell
operator|*
operator|)
name|NULL
condition|?
name|sh
else|:
name|match
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_ParseShell --  *	Parse a shell specification and set up commandShell, shellPath  *	and shellName appropriately.  *  * Results:  *	FAILURE if the specification was incorrect.  *  * Side Effects:  *	commandShell points to a Shell structure (either predefined or  *	created from the shell spec), shellPath is the full path of the  *	shell described by commandShell, while shellName is just the  *	final component of shellPath.  *  * Notes:  *	A shell specification consists of a .SHELL target, with dependency  *	operator, followed by a series of blank-separated words. Double  *	quotes can be used to use blanks in words. A backslash escapes  *	anything (most notably a double-quote and a space) and  *	provides the functionality it does in C. Each word consists of  *	keyword and value separated by an equal sign. There should be no  *	unnecessary spaces in the word. The keywords are as follows:  *	    name  	    Name of shell.  *	    path  	    Location of shell. Overrides "name" if given  *	    quiet 	    Command to turn off echoing.  *	    echo  	    Command to turn echoing on  *	    filter	    Result of turning off echoing that shouldn't be  *	    	  	    printed.  *	    echoFlag	    Flag to turn echoing on at the start  *	    errFlag	    Flag to turn error checking on at the start  *	    hasErrCtl	    True if shell has error checking control  *	    check 	    Command to turn on error checking if hasErrCtl  *	    	  	    is TRUE or template of command to echo a command  *	    	  	    for which error checking is off if hasErrCtl is  *	    	  	    FALSE.  *	    ignore	    Command to turn off error checking if hasErrCtl  *	    	  	    is TRUE or template of command to execute a  *	    	  	    command so as to ignore any errors it returns if  *	    	  	    hasErrCtl is FALSE.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|ReturnStatus
name|Job_ParseShell
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
comment|/* The shell spec */
block|{
name|char
modifier|*
modifier|*
name|words
decl_stmt|;
name|int
name|wordCount
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|register
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|Shell
name|newShell
decl_stmt|;
name|Boolean
name|fullSpec
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|line
argument_list|)
condition|)
block|{
name|line
operator|++
expr_stmt|;
block|}
name|words
operator|=
name|Str_BreakString
argument_list|(
name|line
argument_list|,
literal|" \t"
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|wordCount
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|Address
operator|)
operator|&
name|newShell
argument_list|,
sizeof|sizeof
argument_list|(
name|newShell
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Parse the specification by keyword      */
for|for
control|(
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|,
name|argc
operator|=
name|wordCount
operator|-
literal|1
operator|,
name|argv
operator|=
name|words
operator|+
literal|1
init|;
name|argc
operator|!=
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"path="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|path
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|5
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"name="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|name
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|5
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"quiet="
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|echoOff
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|6
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"echo="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|echoOn
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|5
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"filter="
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|noPrint
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|7
index|]
expr_stmt|;
name|newShell
operator|.
name|noPLen
operator|=
name|strlen
argument_list|(
name|newShell
operator|.
name|noPrint
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"echoFlag="
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|echo
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|9
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"errFlag="
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|exit
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|8
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"hasErrCtl="
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|c
init|=
name|argv
index|[
literal|0
index|]
index|[
literal|10
index|]
decl_stmt|;
name|newShell
operator|.
name|hasErrCtl
operator|=
operator|!
operator|(
operator|(
name|c
operator|!=
literal|'Y'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'y'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'T'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'t'
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"check="
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|errCheck
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|6
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"ignore="
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|newShell
operator|.
name|ignErr
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|7
index|]
expr_stmt|;
block|}
else|else
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Unknown keyword \"%s\""
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|Str_FreeVec
argument_list|(
name|wordCount
argument_list|,
name|words
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
name|fullSpec
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|path
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* 	 * If no path was given, the user wants one of the pre-defined shells, 	 * yes? So we find the one s/he wants with the help of JobMatchShell 	 * and set things up the right way. shellPath will be set up by 	 * Job_Init. 	 */
if|if
condition|(
name|newShell
operator|.
name|name
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Neither path nor name specified"
argument_list|)
expr_stmt|;
name|Str_FreeVec
argument_list|(
name|wordCount
argument_list|,
name|words
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
else|else
block|{
name|commandShell
operator|=
name|JobMatchShell
argument_list|(
name|newShell
operator|.
name|name
argument_list|)
expr_stmt|;
name|shellName
operator|=
name|newShell
operator|.
name|name
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * The user provided a path. If s/he gave nothing else (fullSpec is 	 * FALSE), try and find a matching shell in the ones we know of. 	 * Else we just take the specification at its word and copy it 	 * to a new location. In either case, we need to record the 	 * path the user gave for the shell. 	 */
name|shellPath
operator|=
name|path
expr_stmt|;
name|path
operator|=
name|rindex
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|path
operator|=
name|shellPath
expr_stmt|;
block|}
else|else
block|{
name|path
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|newShell
operator|.
name|name
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|shellName
operator|=
name|newShell
operator|.
name|name
expr_stmt|;
block|}
else|else
block|{
name|shellName
operator|=
name|path
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fullSpec
condition|)
block|{
name|commandShell
operator|=
name|JobMatchShell
argument_list|(
name|shellName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|commandShell
operator|=
operator|(
name|Shell
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Shell
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|commandShell
operator|=
name|newShell
expr_stmt|;
block|}
block|}
if|if
condition|(
name|commandShell
operator|->
name|echoOn
operator|&&
name|commandShell
operator|->
name|echoOff
condition|)
block|{
name|commandShell
operator|->
name|hasEchoCtl
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|commandShell
operator|->
name|hasErrCtl
condition|)
block|{
if|if
condition|(
name|commandShell
operator|->
name|errCheck
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|commandShell
operator|->
name|errCheck
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|commandShell
operator|->
name|ignErr
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|commandShell
operator|->
name|ignErr
operator|=
literal|"%s\n"
expr_stmt|;
block|}
block|}
comment|/*      * Do not free up the words themselves, since they might be in use by the      * shell specification...      */
name|free
argument_list|(
name|words
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * JobInterrupt --  *	Handle the receipt of an interrupt.  *  * Results:  *	None  *  * Side Effects:  *	All children are killed. Another job will be started if the  *	.INTERRUPT target was given.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|JobInterrupt
parameter_list|(
name|runINTERRUPT
parameter_list|)
name|int
name|runINTERRUPT
decl_stmt|;
comment|/* Non-zero if commands for the .INTERRUPT 				 * target should be executed */
block|{
name|LstNode
name|ln
decl_stmt|;
comment|/* element in job table */
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* job descriptor in that element */
name|GNode
modifier|*
name|interrupt
decl_stmt|;
comment|/* the node describing the .INTERRUPT target */
name|aborting
operator|=
name|ABORT_INTERRUPT
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_Open
argument_list|(
name|jobs
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|jobs
argument_list|)
operator|)
operator|!=
name|NILLNODE
condition|)
block|{
name|job
operator|=
operator|(
name|Job
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Targ_Precious
argument_list|(
name|job
operator|->
name|node
argument_list|)
condition|)
block|{
name|char
modifier|*
name|file
init|=
operator|(
name|job
operator|->
name|node
operator|->
name|path
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|?
name|job
operator|->
name|node
operator|->
name|name
else|:
name|job
operator|->
name|node
operator|->
name|path
operator|)
decl_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|file
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Error
argument_list|(
literal|"*** %s removed"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|RMT_WANTS_SIGNALS
if|if
condition|(
name|job
operator|->
name|flags
operator|&
name|JOB_REMOTE
condition|)
block|{
comment|/* 	     * If job is remote, let the Rmt module do the killing. 	     */
if|if
condition|(
operator|!
name|Rmt_Signal
argument_list|(
name|job
argument_list|,
name|SIGINT
argument_list|)
condition|)
block|{
comment|/* 		 * If couldn't kill the thing, finish it out now with an 		 * error code, since no exit report will come in likely. 		 */
name|union
name|wait
name|status
decl_stmt|;
name|status
operator|.
name|w_status
operator|=
literal|0
expr_stmt|;
name|status
operator|.
name|w_retcode
operator|=
literal|1
expr_stmt|;
name|JobFinish
argument_list|(
name|job
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|job
operator|->
name|pid
condition|)
block|{
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|job
operator|->
name|pid
condition|)
block|{
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RMT_WANTS_SIGNALS */
block|}
name|Lst_Close
argument_list|(
name|jobs
argument_list|)
expr_stmt|;
if|if
condition|(
name|runINTERRUPT
operator|&&
operator|!
name|touchFlag
condition|)
block|{
name|interrupt
operator|=
name|Targ_FindNode
argument_list|(
literal|".INTERRUPT"
argument_list|,
name|TARG_NOCREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|interrupt
operator|!=
name|NILGNODE
condition|)
block|{
name|ignoreErrors
operator|=
name|FALSE
expr_stmt|;
name|JobStart
argument_list|(
name|interrupt
argument_list|,
name|JOB_IGNDOTS
argument_list|,
operator|(
name|Job
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|nJobs
condition|)
block|{
name|Job_CatchOutput
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|RMT_WILL_WATCH
name|Job_CatchChildren
argument_list|(
operator|!
name|usePipes
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RMT_WILL_WATCH */
block|}
block|}
block|}
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *-----------------------------------------------------------------------  * Job_End --  *	Do final processing such as the running of the commands  *	attached to the .END target.   *  * Results:  *	Number of errors reported.  *  * Side Effects:  *	The process' temporary file (tfile) is removed if it still  *	existed.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Job_End
parameter_list|()
block|{
if|if
condition|(
name|postCommands
operator|!=
name|NILGNODE
operator|&&
operator|!
name|Lst_IsEmpty
argument_list|(
name|postCommands
operator|->
name|commands
argument_list|)
condition|)
block|{
if|if
condition|(
name|errors
condition|)
block|{
name|Error
argument_list|(
literal|"Errors reported so .END ignored"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|JobStart
argument_list|(
name|postCommands
argument_list|,
name|JOB_SPECIAL
operator||
name|JOB_IGNDOTS
argument_list|,
operator|(
name|Job
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|nJobs
condition|)
block|{
name|Job_CatchOutput
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|RMT_WILL_WATCH
name|Job_CatchChildren
argument_list|(
operator|!
name|usePipes
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RMT_WILL_WATCH */
block|}
block|}
block|}
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|errors
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_Wait --  *	Waits for all running jobs to finish and returns. Sets 'aborting'  *	to ABORT_WAIT to prevent other jobs from starting.  *  * Results:  *	None.  *  * Side Effects:  *	Currently running jobs finish.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_Wait
parameter_list|()
block|{
name|aborting
operator|=
name|ABORT_WAIT
expr_stmt|;
while|while
condition|(
name|nJobs
operator|!=
literal|0
condition|)
block|{
name|Job_CatchOutput
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|RMT_WILL_WATCH
name|Job_CatchChildren
argument_list|(
operator|!
name|usePipes
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RMT_WILL_WATCH */
block|}
name|aborting
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Job_AbortAll --  *	Abort all currently running jobs without handling output or anything.  *	This function is to be called only in the event of a major  *	error. Most definitely NOT to be called from JobInterrupt.  *  * Results:  *	None  *  * Side Effects:  *	All children are killed, not just the firstborn  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Job_AbortAll
parameter_list|()
block|{
name|LstNode
name|ln
decl_stmt|;
comment|/* element in job table */
name|Job
modifier|*
name|job
decl_stmt|;
comment|/* the job descriptor in that element */
name|int
name|foo
decl_stmt|;
name|aborting
operator|=
name|ABORT_ERROR
expr_stmt|;
if|if
condition|(
name|nJobs
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_Open
argument_list|(
name|jobs
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|jobs
argument_list|)
operator|)
operator|!=
name|NILLNODE
condition|)
block|{
name|job
operator|=
operator|(
name|Job
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
comment|/* 	     * kill the child process with increasingly drastic signals to make 	     * darn sure it's dead.  	     */
ifdef|#
directive|ifdef
name|RMT_WANTS_SIGNALS
if|if
condition|(
name|job
operator|->
name|flags
operator|&
name|JOB_REMOTE
condition|)
block|{
name|Rmt_Signal
argument_list|(
name|job
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|Rmt_Signal
argument_list|(
name|job
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|KILL
argument_list|(
name|job
operator|->
name|pid
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RMT_WANTS_SIGNALS */
block|}
block|}
comment|/*      * Catch as many children as want to report in at first, then give up      */
while|while
condition|(
name|wait3
argument_list|(
operator|&
name|foo
argument_list|,
name|WNOHANG
argument_list|,
operator|(
expr|struct
name|rusage
operator|*
operator|)
literal|0
argument_list|)
operator|>
literal|0
condition|)
block|{
empty_stmt|;
block|}
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

