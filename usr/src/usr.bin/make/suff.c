begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)suff.c	8.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*-  * suff.c --  *	Functions to maintain suffix lists and find implicit dependents  *	using suffix transformation rules  *  * Interface:  *	Suff_Init 	    	Initialize all things to do with suffixes.  *  *	Suff_DoPaths	    	This function is used to make life easier  *	    	  	    	when searching for a file according to its  *	    	  	    	suffix. It takes the global search path,  *	    	  	    	as defined using the .PATH: target, and appends  *	    	  	    	its directories to the path of each of the  *	    	  	    	defined suffixes, as specified using  *	    	  	    	.PATH<suffix>: targets. In addition, all  *	    	  	    	directories given for suffixes labeled as  *	    	  	    	include files or libraries, using the .INCLUDES  *	    	  	    	or .LIBS targets, are played with using  *	    	  	    	Dir_MakeFlags to create the .INCLUDES and  *	    	  	    	.LIBS global variables.  *  *	Suff_ClearSuffixes  	Clear out all the suffixes and defined  *	    	  	    	transformations.  *  *	Suff_IsTransform    	Return TRUE if the passed string is the lhs  *	    	  	    	of a transformation rule.  *  *	Suff_AddSuffix	    	Add the passed string as another known suffix.  *  *	Suff_GetPath	    	Return the search path for the given suffix.  *  *	Suff_AddInclude	    	Mark the given suffix as denoting an include  *	    	  	    	file.  *  *	Suff_AddLib	    	Mark the given suffix as denoting a library.  *  *	Suff_AddTransform   	Add another transformation to the suffix  *	    	  	    	graph. Returns  GNode suitable for framing, I  *	    	  	    	mean, tacking commands, attributes, etc. on.  *  *	Suff_SetNull	    	Define the suffix to consider the suffix of  *	    	  	    	any file that doesn't have a known one.  *  *	Suff_FindDeps	    	Find implicit sources for and the location of  *	    	  	    	a target based on its suffix. Returns the  *	    	  	    	bottom-most node added to the graph or NILGNODE  *	    	  	    	if the target had no implicit sources.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"bit.h"
end_include

begin_decl_stmt
specifier|static
name|Lst
name|sufflist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lst of suffixes */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|transforms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lst of transformation rules */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sNum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counter for assigning suffix numbers */
end_comment

begin_comment
comment|/*  * Structure describing an individual suffix.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_Suff
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The suffix itself */
name|int
name|nameLen
decl_stmt|;
comment|/* Length of the suffix */
name|short
name|flags
decl_stmt|;
comment|/* Type of suffix */
define|#
directive|define
name|SUFF_INCLUDE
value|0x01
comment|/* One which is #include'd */
define|#
directive|define
name|SUFF_LIBRARY
value|0x02
comment|/* One which contains a library */
define|#
directive|define
name|SUFF_NULL
value|0x04
comment|/* The empty suffix */
name|Lst
name|searchPath
decl_stmt|;
comment|/* The path along which files of this suffix 				 * may be found */
name|int
name|sNum
decl_stmt|;
comment|/* The suffix number */
name|Lst
name|parents
decl_stmt|;
comment|/* Suffixes we have a transformation to */
name|Lst
name|children
decl_stmt|;
comment|/* Suffixes we have a transformation from */
block|}
name|Suff
typedef|;
end_typedef

begin_comment
comment|/*  * Structure used in the search for implied sources.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_Src
block|{
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The file to look for */
name|char
modifier|*
name|pref
decl_stmt|;
comment|/* Prefix from which file was formed */
name|Suff
modifier|*
name|suff
decl_stmt|;
comment|/* The suffix on the file */
name|struct
name|_Src
modifier|*
name|parent
decl_stmt|;
comment|/* The Src for which this is a source */
name|GNode
modifier|*
name|node
decl_stmt|;
comment|/* The node describing the file */
name|int
name|children
decl_stmt|;
comment|/* Count of existing children (so we don't free 				 * this thing too early or never nuke it) */
block|}
name|Src
typedef|;
end_typedef

begin_comment
comment|/*  * A structure for passing more than one argument to the Lst-library-invoked  * function...  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|Lst
name|l
decl_stmt|;
name|Src
modifier|*
name|s
decl_stmt|;
block|}
name|LstSrc
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|Suff
modifier|*
name|suffNull
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The NULL suffix for this run */
end_comment

begin_decl_stmt
specifier|static
name|Suff
modifier|*
name|emptySuff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The empty suffix required for POSIX 				 * single-suffix transformation rules */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SuffStrIsPrefix
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SuffSuffIsSuffix
name|__P
argument_list|(
operator|(
name|Suff
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SuffSuffIsSuffixP
name|__P
argument_list|(
operator|(
name|Suff
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SuffSuffHasNameP
name|__P
argument_list|(
operator|(
name|Suff
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SuffSuffIsPrefix
name|__P
argument_list|(
operator|(
name|Suff
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SuffGNHasNameP
name|__P
argument_list|(
operator|(
name|GNode
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|SuffFree
name|__P
argument_list|(
operator|(
name|Suff
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|SuffInsert
name|__P
argument_list|(
operator|(
name|Lst
operator|,
name|Suff
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Boolean
name|SuffParseTransform
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|Suff
operator|*
operator|*
operator|,
name|Suff
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SuffRebuildGraph
name|__P
argument_list|(
operator|(
name|GNode
operator|*
operator|,
name|Suff
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SuffAddSrc
name|__P
argument_list|(
operator|(
name|Suff
operator|*
operator|,
name|LstSrc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|SuffAddLevel
name|__P
argument_list|(
operator|(
name|Lst
operator|,
name|Src
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|SuffFreeSrc
name|__P
argument_list|(
operator|(
name|Src
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Src
modifier|*
name|SuffFindThem
name|__P
argument_list|(
operator|(
name|Lst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Src
modifier|*
name|SuffFindCmds
name|__P
argument_list|(
operator|(
name|Src
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SuffExpandChildren
name|__P
argument_list|(
operator|(
name|GNode
operator|*
operator|,
name|GNode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Boolean
name|SuffApplyTransform
name|__P
argument_list|(
operator|(
name|GNode
operator|*
operator|,
name|GNode
operator|*
operator|,
name|Suff
operator|*
operator|,
name|Suff
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|SuffFindArchiveDeps
name|__P
argument_list|(
operator|(
name|GNode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|SuffFindNormalDeps
name|__P
argument_list|(
operator|(
name|GNode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SuffPrintName
name|__P
argument_list|(
operator|(
name|Suff
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SuffPrintSuff
name|__P
argument_list|(
operator|(
name|Suff
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SuffPrintTrans
name|__P
argument_list|(
operator|(
name|GNode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*************** Lst Predicates ****************/
end_comment

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffStrIsPrefix  --  *	See if pref is a prefix of str.  *  * Results:  *	NULL if it ain't, pointer to character in str after prefix if so  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|SuffStrIsPrefix
parameter_list|(
name|pref
parameter_list|,
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|pref
decl_stmt|;
comment|/* possible prefix */
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
comment|/* string to check */
block|{
while|while
condition|(
operator|*
name|str
operator|&&
operator|*
name|pref
operator|==
operator|*
name|str
condition|)
block|{
name|pref
operator|++
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|pref
condition|?
name|NULL
else|:
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffSuffIsSuffix  --  *	See if suff is a suffix of str. Str should point to THE END of the  *	string to check. (THE END == the null byte)  *  * Results:  *	NULL if it ain't, pointer to character in str before suffix if  *	it is.  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|SuffSuffIsSuffix
parameter_list|(
name|s
parameter_list|,
name|str
parameter_list|)
specifier|register
name|Suff
modifier|*
name|s
decl_stmt|;
comment|/* possible suffix */
name|char
modifier|*
name|str
decl_stmt|;
comment|/* string to examine */
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
comment|/* Pointer into suffix name */
specifier|register
name|char
modifier|*
name|p2
decl_stmt|;
comment|/* Pointer into string being examined */
name|p1
operator|=
name|s
operator|->
name|name
operator|+
name|s
operator|->
name|nameLen
expr_stmt|;
name|p2
operator|=
name|str
expr_stmt|;
while|while
condition|(
name|p1
operator|>=
name|s
operator|->
name|name
operator|&&
operator|*
name|p1
operator|==
operator|*
name|p2
condition|)
block|{
name|p1
operator|--
expr_stmt|;
name|p2
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|p1
operator|==
name|s
operator|->
name|name
operator|-
literal|1
condition|?
name|p2
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffSuffIsSuffixP --  *	Predicate form of SuffSuffIsSuffix. Passed as the callback function  *	to Lst_Find.  *  * Results:  *	0 if the suffix is the one desired, non-zero if not.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SuffSuffIsSuffixP
parameter_list|(
name|s
parameter_list|,
name|str
parameter_list|)
name|Suff
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
return|return
operator|(
operator|!
name|SuffSuffIsSuffix
argument_list|(
name|s
argument_list|,
name|str
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffSuffHasNameP --  *	Callback procedure for finding a suffix based on its name. Used by  *	Suff_GetPath.  *  * Results:  *	0 if the suffix is of the given name. non-zero otherwise.  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SuffSuffHasNameP
parameter_list|(
name|s
parameter_list|,
name|sname
parameter_list|)
name|Suff
modifier|*
name|s
decl_stmt|;
comment|/* Suffix to check */
name|char
modifier|*
name|sname
decl_stmt|;
comment|/* Desired name */
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|sname
argument_list|,
name|s
operator|->
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffSuffIsPrefix  --  *	See if the suffix described by s is a prefix of the string. Care  *	must be taken when using this to search for transformations and  *	what-not, since there could well be two suffixes, one of which  *	is a prefix of the other...  *  * Results:  *	0 if s is a prefix of str. non-zero otherwise  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SuffSuffIsPrefix
parameter_list|(
name|s
parameter_list|,
name|str
parameter_list|)
name|Suff
modifier|*
name|s
decl_stmt|;
comment|/* suffix to compare */
name|char
modifier|*
name|str
decl_stmt|;
comment|/* string to examine */
block|{
return|return
operator|(
name|SuffStrIsPrefix
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|str
argument_list|)
operator|==
name|NULL
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffGNHasNameP  --  *	See if the graph node has the desired name  *  * Results:  *	0 if it does. non-zero if it doesn't  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SuffGNHasNameP
parameter_list|(
name|gn
parameter_list|,
name|name
parameter_list|)
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* current node we're looking at */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name we're looking for */
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|gn
operator|->
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********** Maintenance Functions ************/
end_comment

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffFree  --  *	Free up all memory associated with the given suffix structure.  *  * Results:  *	none  *  * Side Effects:  *	the suffix entry is detroyed  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffFree
parameter_list|(
name|s
parameter_list|)
name|Suff
modifier|*
name|s
decl_stmt|;
block|{
name|Lst_Destroy
argument_list|(
name|s
operator|->
name|children
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|s
operator|->
name|parents
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|s
operator|->
name|searchPath
argument_list|,
name|Dir_Destroy
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|Address
operator|)
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|Address
operator|)
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffInsert  --  *	Insert the suffix into the list keeping the list ordered by suffix  *	numbers.  *  * Results:  *	None  *  * Side Effects:  *	Not really  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffInsert
parameter_list|(
name|l
parameter_list|,
name|s
parameter_list|)
name|Lst
name|l
decl_stmt|;
comment|/* the list where in s should be inserted */
name|Suff
modifier|*
name|s
decl_stmt|;
comment|/* the suffix to insert */
block|{
name|LstNode
name|ln
decl_stmt|;
comment|/* current element in l we're examining */
name|Suff
modifier|*
name|s2
init|=
name|NULL
decl_stmt|;
comment|/* the suffix descriptor in this element */
if|if
condition|(
name|Lst_Open
argument_list|(
name|l
argument_list|)
operator|==
name|FAILURE
condition|)
block|{
return|return;
block|}
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|l
argument_list|)
operator|)
operator|!=
name|NILLNODE
condition|)
block|{
name|s2
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
operator|->
name|sNum
operator|>=
name|s
operator|->
name|sNum
condition|)
block|{
break|break;
block|}
block|}
name|Lst_Close
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"inserting %s(%d)..."
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|s
operator|->
name|sNum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ln
operator|==
name|NILLNODE
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"at end of list\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|l
argument_list|,
operator|(
name|ClientData
operator|)
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s2
operator|->
name|sNum
operator|!=
name|s
operator|->
name|sNum
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"before %s(%d)\n"
argument_list|,
name|s2
operator|->
name|name
argument_list|,
name|s2
operator|->
name|sNum
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Lst_Insert
argument_list|(
name|l
argument_list|,
name|ln
argument_list|,
operator|(
name|ClientData
operator|)
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"already there\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_ClearSuffixes --  *	This is gross. Nuke the list of suffixes but keep all transformation  *	rules around. The transformation graph is destroyed in this process,  *	but we leave the list of rules so when a new graph is formed the rules  *	will remain.  *	This function is called from the parse module when a  *	.SUFFIXES:\n line is encountered.  *  * Results:  *	none  *  * Side Effects:  *	the sufflist and its graph nodes are destroyed  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_ClearSuffixes
parameter_list|()
block|{
name|Lst_Destroy
argument_list|(
name|sufflist
argument_list|,
name|SuffFree
argument_list|)
expr_stmt|;
name|sufflist
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|sNum
operator|=
literal|0
expr_stmt|;
name|suffNull
operator|=
name|emptySuff
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffParseTransform --  *	Parse a transformation string to find its two component suffixes.  *  * Results:  *	TRUE if the string is a valid transformation and FALSE otherwise.  *  * Side Effects:  *	The passed pointers are overwritten.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|SuffParseTransform
parameter_list|(
name|str
parameter_list|,
name|srcPtr
parameter_list|,
name|targPtr
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
comment|/* String being parsed */
name|Suff
modifier|*
modifier|*
name|srcPtr
decl_stmt|;
comment|/* Place to store source of trans. */
name|Suff
modifier|*
modifier|*
name|targPtr
decl_stmt|;
comment|/* Place to store target of trans. */
block|{
specifier|register
name|LstNode
name|srcLn
decl_stmt|;
comment|/* element in suffix list of trans source*/
specifier|register
name|Suff
modifier|*
name|src
decl_stmt|;
comment|/* Source of transformation */
specifier|register
name|LstNode
name|targLn
decl_stmt|;
comment|/* element in suffix list of trans target*/
specifier|register
name|char
modifier|*
name|str2
decl_stmt|;
comment|/* Extra pointer (maybe target suffix) */
name|LstNode
name|singleLn
decl_stmt|;
comment|/* element in suffix list of any suffix 				     * that exactly matches str */
name|Suff
modifier|*
name|single
init|=
name|NULL
decl_stmt|;
comment|/* Source of possible transformation to 				     * null suffix */
name|srcLn
operator|=
name|NILLNODE
expr_stmt|;
name|singleLn
operator|=
name|NILLNODE
expr_stmt|;
comment|/*      * Loop looking first for a suffix that matches the start of the      * string and then for one that exactly matches the rest of it. If      * we can find two that meet these criteria, we've successfully      * parsed the string.      */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|srcLn
operator|==
name|NILLNODE
condition|)
block|{
name|srcLn
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
operator|(
name|ClientData
operator|)
name|str
argument_list|,
name|SuffSuffIsPrefix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|srcLn
operator|=
name|Lst_FindFrom
argument_list|(
name|sufflist
argument_list|,
name|Lst_Succ
argument_list|(
name|srcLn
argument_list|)
argument_list|,
operator|(
name|ClientData
operator|)
name|str
argument_list|,
name|SuffSuffIsPrefix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|srcLn
operator|==
name|NILLNODE
condition|)
block|{
comment|/* 	     * Ran out of source suffixes -- no such rule 	     */
if|if
condition|(
name|singleLn
operator|!=
name|NILLNODE
condition|)
block|{
comment|/* 		 * Not so fast Mr. Smith! There was a suffix that encompassed 		 * the entire string, so we assume it was a transformation 		 * to the null suffix (thank you POSIX). We still prefer to 		 * find a double rule over a singleton, hence we leave this 		 * check until the end. 		 * 		 * XXX: Use emptySuff over suffNull? 		 */
operator|*
name|srcPtr
operator|=
name|single
expr_stmt|;
operator|*
name|targPtr
operator|=
name|suffNull
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|src
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|srcLn
argument_list|)
expr_stmt|;
name|str2
operator|=
name|str
operator|+
name|src
operator|->
name|nameLen
expr_stmt|;
if|if
condition|(
operator|*
name|str2
operator|==
literal|'\0'
condition|)
block|{
name|single
operator|=
name|src
expr_stmt|;
name|singleLn
operator|=
name|srcLn
expr_stmt|;
block|}
else|else
block|{
name|targLn
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
operator|(
name|ClientData
operator|)
name|str2
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|targLn
operator|!=
name|NILLNODE
condition|)
block|{
operator|*
name|srcPtr
operator|=
name|src
expr_stmt|;
operator|*
name|targPtr
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|targLn
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_IsTransform  --  *	Return TRUE if the given string is a transformation rule  *  *  * Results:  *	TRUE if the string is a concatenation of two known suffixes.  *	FALSE otherwise  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Suff_IsTransform
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
comment|/* string to check */
block|{
name|Suff
modifier|*
name|src
decl_stmt|,
modifier|*
name|targ
decl_stmt|;
return|return
operator|(
name|SuffParseTransform
argument_list|(
name|str
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|targ
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_AddTransform --  *	Add the transformation rule described by the line to the  *	list of rules and place the transformation itself in the graph  *  * Results:  *	The node created for the transformation in the transforms list  *  * Side Effects:  *	The node is placed on the end of the transforms Lst and links are  *	made between the two suffixes mentioned in the target name  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|GNode
modifier|*
name|Suff_AddTransform
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
comment|/* name of transformation to add */
block|{
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* GNode of transformation rule */
name|Suff
modifier|*
name|s
decl_stmt|,
comment|/* source suffix */
modifier|*
name|t
decl_stmt|;
comment|/* target suffix */
name|LstNode
name|ln
decl_stmt|;
comment|/* Node for existing transformation */
name|ln
operator|=
name|Lst_Find
argument_list|(
name|transforms
argument_list|,
operator|(
name|ClientData
operator|)
name|line
argument_list|,
name|SuffGNHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NILLNODE
condition|)
block|{
comment|/* 	 * Make a new graph node for the transformation. It will be filled in 	 * by the Parse module.  	 */
name|gn
operator|=
name|Targ_NewGN
argument_list|(
name|line
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|transforms
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * New specification for transformation rule. Just nuke the old list 	 * of commands so they can be filled in again... We don't actually 	 * free the commands themselves, because a given command can be 	 * attached to several different transformations. 	 */
name|gn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|gn
operator|->
name|commands
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
name|gn
operator|->
name|commands
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|gn
operator|->
name|children
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|gn
operator|->
name|type
operator|=
name|OP_TRANSFORM
expr_stmt|;
operator|(
name|void
operator|)
name|SuffParseTransform
argument_list|(
name|line
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
comment|/*      * link the two together in the proper relationship and order       */
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"defining transformation from `%s' to `%s'\n"
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|SuffInsert
argument_list|(
name|t
operator|->
name|children
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|SuffInsert
argument_list|(
name|s
operator|->
name|parents
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|gn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_EndTransform --  *	Handle the finish of a transformation definition, removing the  *	transformation from the graph if it has neither commands nor  *	sources. This is a callback procedure for the Parse module via  *	Lst_ForEach  *  * Results:  *	=== 0  *  * Side Effects:  *	If the node has no commands or children, the children and parents  *	lists of the affected suffices are altered.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Suff_EndTransform
parameter_list|(
name|gn
parameter_list|)
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* Node for transformation */
block|{
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_TRANSFORM
operator|)
operator|&&
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|commands
argument_list|)
operator|&&
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|children
argument_list|)
condition|)
block|{
name|Suff
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|LstNode
name|ln
decl_stmt|;
operator|(
name|void
operator|)
name|SuffParseTransform
argument_list|(
name|gn
operator|->
name|name
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"deleting transformation from %s to %s\n"
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Remove the source from the target's children list. We check for a 	 * nil return to handle a beanhead saying something like 	 *  .c.o .c.o: 	 * 	 * We'll be called twice when the next target is seen, but .c and .o 	 * are only linked once... 	 */
name|ln
operator|=
name|Lst_Member
argument_list|(
name|t
operator|->
name|children
argument_list|,
operator|(
name|ClientData
operator|)
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NILLNODE
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_Remove
argument_list|(
name|t
operator|->
name|children
argument_list|,
name|ln
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Remove the target from the source's parents list 	 */
name|ln
operator|=
name|Lst_Member
argument_list|(
name|s
operator|->
name|parents
argument_list|,
operator|(
name|ClientData
operator|)
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NILLNODE
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_Remove
argument_list|(
name|s
operator|->
name|parents
argument_list|,
name|ln
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_TRANSFORM
operator|)
operator|&&
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"transformation %s complete\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffRebuildGraph --  *	Called from Suff_AddSuffix via Lst_ForEach to search through the  *	list of existing transformation rules and rebuild the transformation  *	graph when it has been destroyed by Suff_ClearSuffixes. If the  *	given rule is a transformation involving this suffix and another,  *	existing suffix, the proper relationship is established between  *	the two.  *  * Results:  *	Always 0.  *  * Side Effects:  *	The appropriate links will be made between this suffix and  *	others if transformation rules exist for it.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SuffRebuildGraph
parameter_list|(
name|transform
parameter_list|,
name|s
parameter_list|)
name|GNode
modifier|*
name|transform
decl_stmt|;
comment|/* Transformation to test */
name|Suff
modifier|*
name|s
decl_stmt|;
comment|/* Suffix to rebuild */
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|LstNode
name|ln
decl_stmt|;
specifier|register
name|Suff
modifier|*
name|s2
decl_stmt|;
comment|/*      * First see if it is a transformation from this suffix.      */
name|cp
operator|=
name|SuffStrIsPrefix
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|transform
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
operator|(
name|ClientData
operator|)
name|cp
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NILLNODE
condition|)
block|{
comment|/* 	     * Found target. Link in and return, since it can't be anything 	     * else. 	     */
name|s2
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|SuffInsert
argument_list|(
name|s2
operator|->
name|children
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|SuffInsert
argument_list|(
name|s
operator|->
name|parents
argument_list|,
name|s2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/*      * Not from, maybe to?      */
name|cp
operator|=
name|SuffSuffIsSuffix
argument_list|(
name|s
argument_list|,
name|transform
operator|->
name|name
operator|+
name|strlen
argument_list|(
name|transform
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* 	 * Null-terminate the source suffix in order to find it. 	 */
name|cp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
operator|(
name|ClientData
operator|)
name|transform
operator|->
name|name
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
comment|/* 	 * Replace the start of the target suffix 	 */
name|cp
index|[
literal|1
index|]
operator|=
name|s
operator|->
name|name
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NILLNODE
condition|)
block|{
comment|/* 	     * Found it -- establish the proper relationship 	     */
name|s2
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|SuffInsert
argument_list|(
name|s
operator|->
name|children
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|SuffInsert
argument_list|(
name|s2
operator|->
name|parents
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_AddSuffix --  *	Add the suffix in string to the end of the list of known suffixes.  *	Should we restructure the suffix graph? Make doesn't...  *  * Results:  *	None  *  * Side Effects:  *	A GNode is created for the suffix and a Suff structure is created and  *	added to the suffixes list unless the suffix was already known.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_AddSuffix
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
comment|/* the name of the suffix to add */
block|{
name|Suff
modifier|*
name|s
decl_stmt|;
comment|/* new suffix descriptor */
name|LstNode
name|ln
decl_stmt|;
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
operator|(
name|ClientData
operator|)
name|str
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NILLNODE
condition|)
block|{
name|s
operator|=
operator|(
name|Suff
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Suff
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|s
operator|->
name|nameLen
operator|=
name|strlen
argument_list|(
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|s
operator|->
name|searchPath
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|->
name|children
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|->
name|parents
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|->
name|sNum
operator|=
name|sNum
operator|++
expr_stmt|;
name|s
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|sufflist
argument_list|,
operator|(
name|ClientData
operator|)
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Look for any existing transformations from or to this suffix. 	 * XXX: Only do this after a Suff_ClearSuffixes? 	 */
name|Lst_ForEach
argument_list|(
name|transforms
argument_list|,
name|SuffRebuildGraph
argument_list|,
operator|(
name|ClientData
operator|)
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_GetPath --  *	Return the search path for the given suffix, if it's defined.  *  * Results:  *	The searchPath for the desired suffix or NILLST if the suffix isn't  *	defined.  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Lst
name|Suff_GetPath
parameter_list|(
name|sname
parameter_list|)
name|char
modifier|*
name|sname
decl_stmt|;
block|{
name|LstNode
name|ln
decl_stmt|;
name|Suff
modifier|*
name|s
decl_stmt|;
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
operator|(
name|ClientData
operator|)
name|sname
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NILLNODE
condition|)
block|{
return|return
operator|(
name|NILLST
operator|)
return|;
block|}
else|else
block|{
name|s
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|->
name|searchPath
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_DoPaths --  *	Extend the search paths for all suffixes to include the default  *	search path.  *  * Results:  *	None.  *  * Side Effects:  *	The searchPath field of all the suffixes is extended by the  *	directories in dirSearchPath. If paths were specified for the  *	".h" suffix, the directories are stuffed into a global variable  *	called ".INCLUDES" with each directory preceeded by a -I. The same  *	is done for the ".a" suffix, except the variable is called  *	".LIBS" and the flag is -L.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_DoPaths
parameter_list|()
block|{
specifier|register
name|Suff
modifier|*
name|s
decl_stmt|;
specifier|register
name|LstNode
name|ln
decl_stmt|;
name|Lst
name|inIncludes
decl_stmt|;
comment|/* Cumulative .INCLUDES path */
name|Lst
name|inLibs
decl_stmt|;
comment|/* Cumulative .LIBS path */
if|if
condition|(
name|Lst_Open
argument_list|(
name|sufflist
argument_list|)
operator|==
name|FAILURE
condition|)
block|{
return|return;
block|}
name|inIncludes
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|inLibs
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|sufflist
argument_list|)
operator|)
operator|!=
name|NILLNODE
condition|)
block|{
name|s
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|s
operator|->
name|searchPath
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INCLUDES
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SUFF_INCLUDE
condition|)
block|{
name|Dir_Concat
argument_list|(
name|inIncludes
argument_list|,
name|s
operator|->
name|searchPath
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* INCLUDES */
ifdef|#
directive|ifdef
name|LIBRARIES
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SUFF_LIBRARY
condition|)
block|{
name|Dir_Concat
argument_list|(
name|inLibs
argument_list|,
name|s
operator|->
name|searchPath
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LIBRARIES */
name|Dir_Concat
argument_list|(
name|s
operator|->
name|searchPath
argument_list|,
name|dirSearchPath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Lst_Destroy
argument_list|(
name|s
operator|->
name|searchPath
argument_list|,
name|Dir_Destroy
argument_list|)
expr_stmt|;
name|s
operator|->
name|searchPath
operator|=
name|Lst_Duplicate
argument_list|(
name|dirSearchPath
argument_list|,
name|Dir_CopyDir
argument_list|)
expr_stmt|;
block|}
block|}
name|Var_Set
argument_list|(
literal|".INCLUDES"
argument_list|,
name|Dir_MakeFlags
argument_list|(
literal|"-I"
argument_list|,
name|inIncludes
argument_list|)
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
literal|".LIBS"
argument_list|,
name|Dir_MakeFlags
argument_list|(
literal|"-L"
argument_list|,
name|inLibs
argument_list|)
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|inIncludes
argument_list|,
name|Dir_Destroy
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|inLibs
argument_list|,
name|Dir_Destroy
argument_list|)
expr_stmt|;
name|Lst_Close
argument_list|(
name|sufflist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_AddInclude --  *	Add the given suffix as a type of file which gets included.  *	Called from the parse module when a .INCLUDES line is parsed.  *	The suffix must have already been defined.  *  * Results:  *	None.  *  * Side Effects:  *	The SUFF_INCLUDE bit is set in the suffix's flags field  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_AddInclude
parameter_list|(
name|sname
parameter_list|)
name|char
modifier|*
name|sname
decl_stmt|;
comment|/* Name of suffix to mark */
block|{
name|LstNode
name|ln
decl_stmt|;
name|Suff
modifier|*
name|s
decl_stmt|;
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
operator|(
name|ClientData
operator|)
name|sname
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NILLNODE
condition|)
block|{
name|s
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|s
operator|->
name|flags
operator||=
name|SUFF_INCLUDE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_AddLib --  *	Add the given suffix as a type of file which is a library.  *	Called from the parse module when parsing a .LIBS line. The  *	suffix must have been defined via .SUFFIXES before this is  *	called.  *  * Results:  *	None.  *  * Side Effects:  *	The SUFF_LIBRARY bit is set in the suffix's flags field  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_AddLib
parameter_list|(
name|sname
parameter_list|)
name|char
modifier|*
name|sname
decl_stmt|;
comment|/* Name of suffix to mark */
block|{
name|LstNode
name|ln
decl_stmt|;
name|Suff
modifier|*
name|s
decl_stmt|;
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
operator|(
name|ClientData
operator|)
name|sname
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NILLNODE
condition|)
block|{
name|s
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|s
operator|->
name|flags
operator||=
name|SUFF_LIBRARY
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/********** Implicit Source Search Functions *********/
end_comment

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffAddSrc  --  *	Add a suffix as a Src structure to the given list with its parent  *	being the given Src structure. If the suffix is the null suffix,  *	the prefix is used unaltered as the file name in the Src structure.  *  * Results:  *	always returns 0  *  * Side Effects:  *	A Src structure is created and tacked onto the end of the list  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SuffAddSrc
parameter_list|(
name|s
parameter_list|,
name|ls
parameter_list|)
name|Suff
modifier|*
name|s
decl_stmt|;
comment|/* suffix for which to create a Src structure */
name|LstSrc
modifier|*
name|ls
decl_stmt|;
comment|/* list and parent for the new Src */
block|{
name|Src
modifier|*
name|s2
decl_stmt|;
comment|/* new Src structure */
name|Src
modifier|*
name|targ
decl_stmt|;
comment|/* Target structure */
name|targ
operator|=
name|ls
operator|->
name|s
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SUFF_NULL
operator|)
operator|&&
operator|(
operator|*
name|s
operator|->
name|name
operator|!=
literal|'\0'
operator|)
condition|)
block|{
comment|/* 	 * If the suffix has been marked as the NULL suffix, also create a Src 	 * structure for a file with no suffix attached. Two birds, and all 	 * that... 	 */
name|s2
operator|=
operator|(
name|Src
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Src
argument_list|)
argument_list|)
expr_stmt|;
name|s2
operator|->
name|file
operator|=
name|strdup
argument_list|(
name|targ
operator|->
name|pref
argument_list|)
expr_stmt|;
name|s2
operator|->
name|pref
operator|=
name|targ
operator|->
name|pref
expr_stmt|;
name|s2
operator|->
name|parent
operator|=
name|targ
expr_stmt|;
name|s2
operator|->
name|node
operator|=
name|NILGNODE
expr_stmt|;
name|s2
operator|->
name|suff
operator|=
name|s
expr_stmt|;
name|s2
operator|->
name|children
operator|=
literal|0
expr_stmt|;
name|targ
operator|->
name|children
operator|+=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|ls
operator|->
name|l
argument_list|,
operator|(
name|ClientData
operator|)
name|s2
argument_list|)
expr_stmt|;
block|}
name|s2
operator|=
operator|(
name|Src
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Src
argument_list|)
argument_list|)
expr_stmt|;
name|s2
operator|->
name|file
operator|=
name|str_concat
argument_list|(
name|targ
operator|->
name|pref
argument_list|,
name|s
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s2
operator|->
name|pref
operator|=
name|targ
operator|->
name|pref
expr_stmt|;
name|s2
operator|->
name|parent
operator|=
name|targ
expr_stmt|;
name|s2
operator|->
name|node
operator|=
name|NILGNODE
expr_stmt|;
name|s2
operator|->
name|suff
operator|=
name|s
expr_stmt|;
name|s2
operator|->
name|children
operator|=
literal|0
expr_stmt|;
name|targ
operator|->
name|children
operator|+=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|ls
operator|->
name|l
argument_list|,
operator|(
name|ClientData
operator|)
name|s2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffAddLevel  --  *	Add all the children of targ as Src structures to the given list  *  * Results:  *	None  *  * Side Effects:  * 	Lots of structures are created and added to the list  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffAddLevel
parameter_list|(
name|l
parameter_list|,
name|targ
parameter_list|)
name|Lst
name|l
decl_stmt|;
comment|/* list to which to add the new level */
name|Src
modifier|*
name|targ
decl_stmt|;
comment|/* Src structure to use as the parent */
block|{
name|LstSrc
name|ls
decl_stmt|;
name|ls
operator|.
name|s
operator|=
name|targ
expr_stmt|;
name|ls
operator|.
name|l
operator|=
name|l
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|targ
operator|->
name|suff
operator|->
name|children
argument_list|,
name|SuffAddSrc
argument_list|,
operator|(
name|ClientData
operator|)
operator|&
name|ls
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *----------------------------------------------------------------------  * SuffFreeSrc --  *	Free all memory associated with a Src structure  *  * Results:  *	None  *  * Side Effects:  *	The memory is free'd.  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffFreeSrc
parameter_list|(
name|s
parameter_list|)
name|Src
modifier|*
name|s
decl_stmt|;
block|{
name|free
argument_list|(
operator|(
name|Address
operator|)
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|parent
condition|)
block|{
name|free
argument_list|(
operator|(
name|Address
operator|)
name|s
operator|->
name|pref
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|--
name|s
operator|->
name|parent
operator|->
name|children
operator|==
literal|0
operator|&&
name|s
operator|->
name|parent
operator|->
name|parent
condition|)
block|{
comment|/* 	 * Parent has no more children, now we're gone, and it's not 	 * at the top of the tree, so blow it away too. 	 */
name|SuffFreeSrc
argument_list|(
name|s
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|Address
operator|)
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffFindThem --  *	Find the first existing file/target in the list srcs  *  * Results:  *	The lowest structure in the chain of transformations  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Src
modifier|*
name|SuffFindThem
parameter_list|(
name|srcs
parameter_list|)
name|Lst
name|srcs
decl_stmt|;
comment|/* list of Src structures to search through */
block|{
name|Src
modifier|*
name|s
decl_stmt|;
comment|/* current Src */
name|Src
modifier|*
name|rs
decl_stmt|;
comment|/* returned Src */
name|rs
operator|=
operator|(
name|Src
operator|*
operator|)
name|NULL
expr_stmt|;
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|srcs
argument_list|)
condition|)
block|{
name|s
operator|=
operator|(
name|Src
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|srcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\ttrying %s..."
argument_list|,
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * A file is considered to exist if either a node exists in the 	 * graph for it or the file actually exists. 	 */
if|if
condition|(
operator|(
name|Targ_FindNode
argument_list|(
name|s
operator|->
name|file
argument_list|,
name|TARG_NOCREATE
argument_list|)
operator|!=
name|NILGNODE
operator|)
operator|||
operator|(
name|Dir_FindFile
argument_list|(
name|s
operator|->
name|file
argument_list|,
name|s
operator|->
name|suff
operator|->
name|searchPath
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"got it\n"
argument_list|)
expr_stmt|;
block|}
name|rs
operator|=
name|s
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"not there\n"
argument_list|)
expr_stmt|;
block|}
name|SuffAddLevel
argument_list|(
name|srcs
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffFindCmds --  *	See if any of the children of the target in the Src structure is  *	one from which the target can be transformed. If there is one,  *	a Src structure is put together for it and returned.  *  * Results:  *	The Src structure of the "winning" child, or NIL if no such beast.  *  * Side Effects:  *	A Src structure may be allocated.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Src
modifier|*
name|SuffFindCmds
parameter_list|(
name|targ
parameter_list|)
name|Src
modifier|*
name|targ
decl_stmt|;
comment|/* Src structure to play with */
block|{
name|LstNode
name|ln
decl_stmt|;
comment|/* General-purpose list node */
specifier|register
name|GNode
modifier|*
name|t
decl_stmt|,
comment|/* Target GNode */
modifier|*
name|s
decl_stmt|;
comment|/* Source GNode */
name|int
name|prefLen
decl_stmt|;
comment|/* The length of the defined prefix */
name|Suff
modifier|*
name|suff
decl_stmt|;
comment|/* Suffix on matching beastie */
name|Src
modifier|*
name|ret
decl_stmt|;
comment|/* Return value */
name|char
modifier|*
name|cp
decl_stmt|;
name|t
operator|=
name|targ
operator|->
name|node
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_Open
argument_list|(
name|t
operator|->
name|children
argument_list|)
expr_stmt|;
name|prefLen
operator|=
name|strlen
argument_list|(
name|targ
operator|->
name|pref
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|t
operator|->
name|children
argument_list|)
operator|)
operator|!=
name|NILLNODE
condition|)
block|{
name|s
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|cp
operator|=
name|s
operator|->
name|name
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|targ
operator|->
name|pref
argument_list|,
name|prefLen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 	     * The node matches the prefix ok, see if it has a known 	     * suffix. 	     */
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
operator|(
name|ClientData
operator|)
operator|&
name|cp
index|[
name|prefLen
index|]
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NILLNODE
condition|)
block|{
comment|/* 		 * It even has a known suffix, see if there's a transformation 		 * defined between the node's suffix and the target's suffix. 		 * 		 * XXX: Handle multi-stage transformations here, too. 		 */
name|suff
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lst_Member
argument_list|(
name|suff
operator|->
name|parents
argument_list|,
operator|(
name|ClientData
operator|)
name|targ
operator|->
name|suff
argument_list|)
operator|!=
name|NILLNODE
condition|)
block|{
comment|/* 		     * Hot Damn! Create a new Src structure to describe 		     * this transformation (making sure to duplicate the 		     * source node's name so Suff_FindDeps can free it 		     * again (ick)), and return the new structure. 		     */
name|ret
operator|=
operator|(
name|Src
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Src
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|file
operator|=
name|strdup
argument_list|(
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|->
name|pref
operator|=
name|targ
operator|->
name|pref
expr_stmt|;
name|ret
operator|->
name|suff
operator|=
name|suff
expr_stmt|;
name|ret
operator|->
name|parent
operator|=
name|targ
expr_stmt|;
name|ret
operator|->
name|node
operator|=
name|s
expr_stmt|;
name|ret
operator|->
name|children
operator|=
literal|0
expr_stmt|;
name|targ
operator|->
name|children
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\tusing existing source %s\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
block|}
block|}
name|Lst_Close
argument_list|(
name|t
operator|->
name|children
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|Src
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffExpandChildren --  *	Expand the names of any children of a given node that contain  *	variable invocations or file wildcards into actual targets.  *  * Results:  *	=== 0 (continue)  *  * Side Effects:  *	The expanded node is removed from the parent's list of children,  *	and the parent's unmade counter is decremented, but other nodes  * 	may be added.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SuffExpandChildren
parameter_list|(
name|cgn
parameter_list|,
name|pgn
parameter_list|)
name|GNode
modifier|*
name|cgn
decl_stmt|;
comment|/* Child to examine */
name|GNode
modifier|*
name|pgn
decl_stmt|;
comment|/* Parent node being processed */
block|{
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* New source 8) */
name|LstNode
name|prevLN
decl_stmt|;
comment|/* Node after which new source should be put */
name|LstNode
name|ln
decl_stmt|;
comment|/* List element for old source */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Expanded value */
comment|/*      * New nodes effectively take the place of the child, so place them      * after the child      */
name|prevLN
operator|=
name|Lst_Member
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
operator|(
name|ClientData
operator|)
name|cgn
argument_list|)
expr_stmt|;
comment|/*      * First do variable expansion -- this takes precedence over      * wildcard expansion. If the result contains wildcards, they'll be gotten      * to later since the resulting words are tacked on to the end of      * the children list.      */
if|if
condition|(
name|strchr
argument_list|(
name|cgn
operator|->
name|name
argument_list|,
literal|'$'
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Expanding \"%s\"..."
argument_list|,
name|cgn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|cgn
operator|->
name|name
argument_list|,
name|pgn
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|Lst
name|members
init|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|cgn
operator|->
name|type
operator|&
name|OP_ARCHV
condition|)
block|{
comment|/* 		 * Node was an archive(member) target, so we want to call 		 * on the Arch module to find the nodes for us, expanding 		 * variables in the parent's context. 		 */
name|char
modifier|*
name|sacrifice
init|=
name|cp
decl_stmt|;
operator|(
name|void
operator|)
name|Arch_ParseArchive
argument_list|(
operator|&
name|sacrifice
argument_list|,
name|members
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Break the result into a vector of strings whose nodes 		 * we can find, then add those nodes to the members list. 		 * Unfortunately, we can't use brk_string b/c it 		 * doesn't understand about variable specifications with 		 * spaces in them... 		 */
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|initcp
init|=
name|cp
decl_stmt|;
comment|/* For freeing... */
for|for
control|(
name|start
operator|=
name|cp
init|;
operator|*
name|start
operator|==
literal|' '
operator|||
operator|*
name|start
operator|==
literal|'\t'
condition|;
name|start
operator|++
control|)
continue|continue;
for|for
control|(
name|cp
operator|=
name|start
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
block|{
comment|/* 			 * White-space -- terminate element, find the node, 			 * add it, skip any further spaces. 			 */
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|start
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|members
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
comment|/* 			 * Adjust cp for increment at start of loop, but 			 * set start to first non-space. 			 */
name|start
operator|=
name|cp
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
comment|/* 			 * Start of a variable spec -- contact variable module 			 * to find the end so we can skip over it. 			 */
name|char
modifier|*
name|junk
decl_stmt|;
name|int
name|len
decl_stmt|;
name|Boolean
name|doFree
decl_stmt|;
name|junk
operator|=
name|Var_Parse
argument_list|(
name|cp
argument_list|,
name|pgn
argument_list|,
name|TRUE
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|doFree
argument_list|)
expr_stmt|;
if|if
condition|(
name|junk
operator|!=
name|var_Error
condition|)
block|{
name|cp
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|doFree
condition|)
block|{
name|free
argument_list|(
name|junk
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 			 * Escaped something -- skip over it 			 */
name|cp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cp
operator|!=
name|start
condition|)
block|{
comment|/* 		     * Stuff left over -- add it to the list too 		     */
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|start
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|members
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Point cp back at the beginning again so the variable value 		 * can be freed. 		 */
name|cp
operator|=
name|initcp
expr_stmt|;
block|}
comment|/* 	     * Add all elements of the members list to the parent node. 	     */
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|members
argument_list|)
condition|)
block|{
name|gn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|members
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s..."
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Lst_Member
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
operator|==
name|NILLNODE
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_Append
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
name|prevLN
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
name|prevLN
operator|=
name|Lst_Succ
argument_list|(
name|prevLN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|gn
operator|->
name|parents
argument_list|,
operator|(
name|ClientData
operator|)
name|pgn
argument_list|)
expr_stmt|;
name|pgn
operator|->
name|unmade
operator|++
expr_stmt|;
block|}
block|}
name|Lst_Destroy
argument_list|(
name|members
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
comment|/* 	     * Free the result 	     */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now the source is expanded, remove it from the list of children to 	 * keep it from being processed. 	 */
name|ln
operator|=
name|Lst_Member
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
operator|(
name|ClientData
operator|)
name|cgn
argument_list|)
expr_stmt|;
name|pgn
operator|->
name|unmade
operator|--
expr_stmt|;
name|Lst_Remove
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Dir_HasWildcards
argument_list|(
name|cgn
operator|->
name|name
argument_list|)
condition|)
block|{
name|Lst
name|exp
decl_stmt|;
comment|/* List of expansions */
name|Lst
name|path
decl_stmt|;
comment|/* Search path along which to expand */
comment|/* 	 * Find a path along which to expand the word. 	 * 	 * If the word has a known suffix, use that path. 	 * If it has no known suffix and we're allowed to use the null 	 *   suffix, use its path. 	 * Else use the default system search path. 	 */
name|cp
operator|=
name|cgn
operator|->
name|name
operator|+
name|strlen
argument_list|(
name|cgn
operator|->
name|name
argument_list|)
expr_stmt|;
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
operator|(
name|ClientData
operator|)
name|cp
argument_list|,
name|SuffSuffIsSuffixP
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Wildcard expanding \"%s\"..."
argument_list|,
name|cgn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ln
operator|!=
name|NILLNODE
condition|)
block|{
name|Suff
modifier|*
name|s
init|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
decl_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"suffix is \"%s\"..."
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|path
operator|=
name|s
operator|->
name|searchPath
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Use default search path 	     */
name|path
operator|=
name|dirSearchPath
expr_stmt|;
block|}
comment|/* 	 * Expand the word along the chosen path 	 */
name|exp
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|Dir_Expand
argument_list|(
name|cgn
operator|->
name|name
argument_list|,
name|path
argument_list|,
name|exp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|exp
argument_list|)
condition|)
block|{
comment|/* 	     * Fetch next expansion off the list and find its GNode 	     */
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s..."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|cp
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
comment|/* 	     * If gn isn't already a child of the parent, make it so and 	     * up the parent's count of unmade children. 	     */
if|if
condition|(
name|Lst_Member
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
operator|==
name|NILLNODE
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_Append
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
name|prevLN
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
name|prevLN
operator|=
name|Lst_Succ
argument_list|(
name|prevLN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|gn
operator|->
name|parents
argument_list|,
operator|(
name|ClientData
operator|)
name|pgn
argument_list|)
expr_stmt|;
name|pgn
operator|->
name|unmade
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Nuke what's left of the list 	 */
name|Lst_Destroy
argument_list|(
name|exp
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
comment|/* 	 * Now the source is expanded, remove it from the list of children to 	 * keep it from being processed. 	 */
name|ln
operator|=
name|Lst_Member
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
operator|(
name|ClientData
operator|)
name|cgn
argument_list|)
expr_stmt|;
name|pgn
operator|->
name|unmade
operator|--
expr_stmt|;
name|Lst_Remove
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffApplyTransform --  *	Apply a transformation rule, given the source and target nodes  *	and suffixes.  *  * Results:  *	TRUE if successful, FALSE if not.  *  * Side Effects:  *	The source and target are linked and the commands from the  *	transformation are added to the target node's commands list.  *	All attributes but OP_DEPMASK and OP_TRANSFORM are applied  *	to the target. The target also inherits all the sources for  *	the transformation rule.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|SuffApplyTransform
parameter_list|(
name|tGn
parameter_list|,
name|sGn
parameter_list|,
name|t
parameter_list|,
name|s
parameter_list|)
name|GNode
modifier|*
name|tGn
decl_stmt|;
comment|/* Target node */
name|GNode
modifier|*
name|sGn
decl_stmt|;
comment|/* Source node */
name|Suff
modifier|*
name|t
decl_stmt|;
comment|/* Target suffix */
name|Suff
modifier|*
name|s
decl_stmt|;
comment|/* Source suffix */
block|{
name|LstNode
name|ln
decl_stmt|;
comment|/* General node */
name|char
modifier|*
name|tname
decl_stmt|;
comment|/* Name of transformation rule */
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* Node for same */
if|if
condition|(
name|Lst_Member
argument_list|(
name|tGn
operator|->
name|children
argument_list|,
operator|(
name|ClientData
operator|)
name|sGn
argument_list|)
operator|==
name|NILLNODE
condition|)
block|{
comment|/* 	 * Not already linked, so form the proper links between the 	 * target and source. 	 */
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|tGn
operator|->
name|children
argument_list|,
operator|(
name|ClientData
operator|)
name|sGn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|sGn
operator|->
name|parents
argument_list|,
operator|(
name|ClientData
operator|)
name|tGn
argument_list|)
expr_stmt|;
name|tGn
operator|->
name|unmade
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sGn
operator|->
name|type
operator|&
name|OP_OPMASK
operator|)
operator|==
name|OP_DOUBLEDEP
condition|)
block|{
comment|/* 	 * When a :: node is used as the implied source of a node, we have 	 * to link all its cohorts in as sources as well. Only the initial 	 * sGn gets the target in its iParents list, however, as that 	 * will be sufficient to get the .IMPSRC variable set for tGn 	 */
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
name|sGn
operator|->
name|cohorts
argument_list|)
init|;
name|ln
operator|!=
name|NILLNODE
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|gn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lst_Member
argument_list|(
name|tGn
operator|->
name|children
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
operator|==
name|NILLNODE
condition|)
block|{
comment|/* 		 * Not already linked, so form the proper links between the 		 * target and source. 		 */
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|tGn
operator|->
name|children
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|gn
operator|->
name|parents
argument_list|,
operator|(
name|ClientData
operator|)
name|tGn
argument_list|)
expr_stmt|;
name|tGn
operator|->
name|unmade
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/*      * Locate the transformation rule itself      */
name|tname
operator|=
name|str_concat
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|t
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ln
operator|=
name|Lst_Find
argument_list|(
name|transforms
argument_list|,
operator|(
name|ClientData
operator|)
name|tname
argument_list|,
name|SuffGNHasNameP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NILLNODE
condition|)
block|{
comment|/* 	 * Not really such a transformation rule (can happen when we're 	 * called to link an OP_MEMBER and OP_ARCHV node), so return 	 * FALSE. 	 */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|gn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\tapplying %s -> %s to \"%s\"\n"
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|t
operator|->
name|name
argument_list|,
name|tGn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/*      * Record last child for expansion purposes      */
name|ln
operator|=
name|Lst_Last
argument_list|(
name|tGn
operator|->
name|children
argument_list|)
expr_stmt|;
comment|/*      * Pass the buck to Make_HandleUse to apply the rule      */
operator|(
name|void
operator|)
name|Make_HandleUse
argument_list|(
name|gn
argument_list|,
name|tGn
argument_list|)
expr_stmt|;
comment|/*      * Deal with wildcards and variables in any acquired sources      */
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NILLNODE
condition|)
block|{
name|Lst_ForEachFrom
argument_list|(
name|tGn
operator|->
name|children
argument_list|,
name|ln
argument_list|,
name|SuffExpandChildren
argument_list|,
operator|(
name|ClientData
operator|)
name|tGn
argument_list|)
expr_stmt|;
block|}
comment|/*      * Keep track of another parent to which this beast is transformed so      * the .IMPSRC variable can be set correctly for the parent.      */
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|sGn
operator|->
name|iParents
argument_list|,
operator|(
name|ClientData
operator|)
name|tGn
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffFindArchiveDeps --  *	Locate dependencies for an OP_ARCHV node.  *  * Results:  *	None  *  * Side Effects:  *	Same as Suff_FindDeps  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffFindArchiveDeps
parameter_list|(
name|gn
parameter_list|)
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* Node for which to locate dependencies */
block|{
name|char
modifier|*
name|eoarch
decl_stmt|;
comment|/* End of archive portion */
name|char
modifier|*
name|eoname
decl_stmt|;
comment|/* End of member portion */
name|GNode
modifier|*
name|mem
decl_stmt|;
comment|/* Node for member */
specifier|static
name|char
modifier|*
name|copy
index|[]
init|=
block|{
comment|/* Variables to be copied from the member node */
name|TARGET
block|,
comment|/* Must be first */
name|PREFIX
block|,
comment|/* Must be second */
block|}
decl_stmt|;
name|char
modifier|*
name|vals
index|[
sizeof|sizeof
argument_list|(
name|copy
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|copy
index|[
literal|0
index|]
argument_list|)
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Index into copy and vals */
name|Suff
modifier|*
name|ms
decl_stmt|;
comment|/* Suffix descriptor for member */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Start of member's name */
comment|/*      * The node is an archive(member) pair. so we must find a      * suffix for both of them.      */
name|eoarch
operator|=
name|strchr
argument_list|(
name|gn
operator|->
name|name
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|eoname
operator|=
name|strchr
argument_list|(
name|eoarch
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
operator|*
name|eoname
operator|=
literal|'\0'
expr_stmt|;
comment|/* Nuke parentheses during suffix search */
operator|*
name|eoarch
operator|=
literal|'\0'
expr_stmt|;
comment|/* So a suffix can be found */
name|name
operator|=
name|eoarch
operator|+
literal|1
expr_stmt|;
comment|/*      * To simplify things, call Suff_FindDeps recursively on the member now,      * so we can simply compare the member's .PREFIX and .TARGET variables      * to locate its suffix. This allows us to figure out the suffix to      * use for the archive without having to do a quadratic search over the      * suffix list, backtracking for each one...      */
name|mem
operator|=
name|Targ_FindNode
argument_list|(
name|name
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
name|Suff_FindDeps
argument_list|(
name|mem
argument_list|)
expr_stmt|;
comment|/*      * Create the link between the two nodes right off      */
if|if
condition|(
name|Lst_Member
argument_list|(
name|gn
operator|->
name|children
argument_list|,
operator|(
name|ClientData
operator|)
name|mem
argument_list|)
operator|==
name|NILLNODE
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|gn
operator|->
name|children
argument_list|,
operator|(
name|ClientData
operator|)
name|mem
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|mem
operator|->
name|parents
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
name|gn
operator|->
name|unmade
operator|+=
literal|1
expr_stmt|;
block|}
comment|/*      * Copy in the variables from the member node to this one.      */
for|for
control|(
name|i
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|copy
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|copy
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|vals
index|[
name|i
index|]
operator|=
name|Var_Value
argument_list|(
name|copy
index|[
name|i
index|]
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|copy
index|[
name|i
index|]
argument_list|,
name|vals
index|[
name|i
index|]
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
name|ms
operator|=
name|mem
operator|->
name|suffix
expr_stmt|;
if|if
condition|(
name|ms
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * Didn't know what it was -- use .NULL suffix if not in make mode 	 */
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"using null suffix\n"
argument_list|)
expr_stmt|;
block|}
name|ms
operator|=
name|suffNull
expr_stmt|;
block|}
comment|/*      * Set the other two local variables required for this target.      */
name|Var_Set
argument_list|(
name|MEMBER
argument_list|,
name|name
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|ARCHIVE
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ms
operator|!=
name|NULL
condition|)
block|{
comment|/* 	 * Member has a known suffix, so look for a transformation rule from 	 * it to a possible suffix of the archive. Rather than searching 	 * through the entire list, we just look at suffixes to which the 	 * member's suffix may be transformed... 	 */
name|LstNode
name|ln
decl_stmt|;
comment|/* 	 * Use first matching suffix... 	 */
name|ln
operator|=
name|Lst_Find
argument_list|(
name|ms
operator|->
name|parents
argument_list|,
name|eoarch
argument_list|,
name|SuffSuffIsSuffixP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NILLNODE
condition|)
block|{
comment|/* 	     * Got one -- apply it 	     */
if|if
condition|(
operator|!
name|SuffApplyTransform
argument_list|(
name|gn
argument_list|,
name|mem
argument_list|,
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|ms
argument_list|)
operator|&&
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\tNo transformation from %s -> %s\n"
argument_list|,
name|ms
operator|->
name|name
argument_list|,
operator|(
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*      * Replace the opening and closing parens now we've no need of the separate      * pieces.      */
operator|*
name|eoarch
operator|=
literal|'('
expr_stmt|;
operator|*
name|eoname
operator|=
literal|')'
expr_stmt|;
comment|/*      * Pretend gn appeared to the left of a dependency operator so      * the user needn't provide a transformation from the member to the      * archive.      */
if|if
condition|(
name|OP_NOP
argument_list|(
name|gn
operator|->
name|type
argument_list|)
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|OP_DEPENDS
expr_stmt|;
block|}
comment|/*      * Flag the member as such so we remember to look in the archive for      * its modification time.      */
name|mem
operator|->
name|type
operator||=
name|OP_MEMBER
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffFindNormalDeps --  *	Locate implicit dependencies for regular targets.  *  * Results:  *	None.  *  * Side Effects:  *	Same as Suff_FindDeps...  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffFindNormalDeps
parameter_list|(
name|gn
parameter_list|)
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* Node for which to find sources */
block|{
name|char
modifier|*
name|eoname
decl_stmt|;
comment|/* End of name */
name|char
modifier|*
name|sopref
decl_stmt|;
comment|/* Start of prefix */
name|LstNode
name|ln
decl_stmt|;
comment|/* Next suffix node to check */
name|Lst
name|srcs
decl_stmt|;
comment|/* List of sources at which to look */
name|Lst
name|targs
decl_stmt|;
comment|/* List of targets to which things can be 			     * transformed. They all have the same file, 			     * but different suff and pref fields */
name|Src
modifier|*
name|bottom
decl_stmt|;
comment|/* Start of found transformation path */
name|Src
modifier|*
name|src
decl_stmt|;
comment|/* General Src pointer */
name|char
modifier|*
name|pref
decl_stmt|;
comment|/* Prefix to use */
name|Src
modifier|*
name|targ
decl_stmt|;
comment|/* General Src target pointer */
name|eoname
operator|=
name|gn
operator|->
name|name
operator|+
name|strlen
argument_list|(
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|sopref
operator|=
name|gn
operator|->
name|name
expr_stmt|;
comment|/*      * Begin at the beginning...      */
name|ln
operator|=
name|Lst_First
argument_list|(
name|sufflist
argument_list|)
expr_stmt|;
name|srcs
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|targs
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/*      * We're caught in a catch-22 here. On the one hand, we want to use any      * transformation implied by the target's sources, but we can't examine      * the sources until we've expanded any variables/wildcards they may hold,      * and we can't do that until we've set up the target's local variables      * and we can't do that until we know what the proper suffix for the      * target is (in case there are two suffixes one of which is a suffix of      * the other) and we can't know that until we've found its implied      * source, which we may not want to use if there's an existing source      * that implies a different transformation.      *      * In an attempt to get around this, which may not work all the time,      * but should work most of the time, we look for implied sources first,      * checking transformations to all possible suffixes of the target,      * use what we find to set the target's local variables, expand the      * children, then look for any overriding transformations they imply.      * Should we find one, we discard the one we found before.      */
while|while
condition|(
name|ln
operator|!=
name|NILLNODE
condition|)
block|{
comment|/* 	 * Look for next possible suffix... 	 */
name|ln
operator|=
name|Lst_FindFrom
argument_list|(
name|sufflist
argument_list|,
name|ln
argument_list|,
name|eoname
argument_list|,
name|SuffSuffIsSuffixP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NILLNODE
condition|)
block|{
name|int
name|prefLen
decl_stmt|;
comment|/* Length of the prefix */
name|Src
modifier|*
name|targ
decl_stmt|;
comment|/* 	     * Allocate a Src structure to which things can be transformed 	     */
name|targ
operator|=
operator|(
name|Src
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Src
argument_list|)
argument_list|)
expr_stmt|;
name|targ
operator|->
name|file
operator|=
name|strdup
argument_list|(
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|targ
operator|->
name|suff
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|targ
operator|->
name|node
operator|=
name|gn
expr_stmt|;
name|targ
operator|->
name|parent
operator|=
operator|(
name|Src
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* 	     * Allocate room for the prefix, whose end is found by subtracting 	     * the length of the suffix from the end of the name. 	     */
name|prefLen
operator|=
operator|(
name|eoname
operator|-
name|targ
operator|->
name|suff
operator|->
name|nameLen
operator|)
operator|-
name|sopref
expr_stmt|;
name|targ
operator|->
name|pref
operator|=
name|emalloc
argument_list|(
name|prefLen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|targ
operator|->
name|pref
argument_list|,
name|sopref
argument_list|,
name|prefLen
argument_list|)
expr_stmt|;
name|targ
operator|->
name|pref
index|[
name|prefLen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	     * Add nodes from which the target can be made 	     */
name|SuffAddLevel
argument_list|(
name|srcs
argument_list|,
name|targ
argument_list|)
expr_stmt|;
comment|/* 	     * Record the target so we can nuke it 	     */
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|targs
argument_list|,
operator|(
name|ClientData
operator|)
name|targ
argument_list|)
expr_stmt|;
comment|/* 	     * Search from this suffix's successor... 	     */
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Handle target of unknown suffix...      */
if|if
condition|(
name|Lst_IsEmpty
argument_list|(
name|targs
argument_list|)
operator|&&
name|suffNull
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\tNo known suffix on %s. Using .NULL suffix\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|targ
operator|=
operator|(
name|Src
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Src
argument_list|)
argument_list|)
expr_stmt|;
name|targ
operator|->
name|file
operator|=
name|strdup
argument_list|(
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|targ
operator|->
name|suff
operator|=
name|suffNull
expr_stmt|;
name|targ
operator|->
name|node
operator|=
name|gn
expr_stmt|;
name|targ
operator|->
name|parent
operator|=
operator|(
name|Src
operator|*
operator|)
name|NULL
expr_stmt|;
name|targ
operator|->
name|pref
operator|=
name|strdup
argument_list|(
name|sopref
argument_list|)
expr_stmt|;
name|SuffAddLevel
argument_list|(
name|srcs
argument_list|,
name|targ
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|targs
argument_list|,
operator|(
name|ClientData
operator|)
name|targ
argument_list|)
expr_stmt|;
block|}
comment|/*      * Using the list of possible sources built up from the target suffix(es),      * try and find an existing file/target that matches.      */
name|bottom
operator|=
name|SuffFindThem
argument_list|(
name|srcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|bottom
operator|==
operator|(
name|Src
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* 	 * No known transformations -- use the first suffix found for setting 	 * the local variables. 	 */
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|targs
argument_list|)
condition|)
block|{
name|targ
operator|=
operator|(
name|Src
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|Lst_First
argument_list|(
name|targs
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|targ
operator|=
operator|(
name|Src
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * Work up the transformation path to find the suffix of the 	 * target to which the transformation was made. 	 */
for|for
control|(
name|targ
operator|=
name|bottom
init|;
name|targ
operator|->
name|parent
operator|!=
name|NULL
condition|;
name|targ
operator|=
name|targ
operator|->
name|parent
control|)
continue|continue;
block|}
comment|/*      * The .TARGET variable we always set to be the name at this point,      * since it's only set to the path if the thing is only a source and      * if it's only a source, it doesn't matter what we put here as far      * as expanding sources is concerned, since it has none...      */
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|pref
operator|=
operator|(
name|targ
operator|!=
name|NULL
operator|)
condition|?
name|targ
operator|->
name|pref
else|:
name|gn
operator|->
name|name
expr_stmt|;
name|Var_Set
argument_list|(
name|PREFIX
argument_list|,
name|pref
argument_list|,
name|gn
argument_list|)
expr_stmt|;
comment|/*      * Now we've got the important local variables set, expand any sources      * that still contain variables or wildcards in their names.      */
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|SuffExpandChildren
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\tNo valid suffix on %s\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|sfnd_abort
label|:
comment|/* 	 * Deal with finding the thing on the default search path if the 	 * node is only a source (not on the lhs of a dependency operator 	 * or [XXX] it has neither children or commands). 	 */
if|if
condition|(
name|OP_NOP
argument_list|(
name|gn
operator|->
name|type
argument_list|)
operator|||
operator|(
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|children
argument_list|)
operator|&&
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|commands
argument_list|)
operator|)
condition|)
block|{
name|gn
operator|->
name|path
operator|=
name|Dir_FindFile
argument_list|(
name|gn
operator|->
name|name
argument_list|,
operator|(
name|targ
operator|==
name|NULL
condition|?
name|dirSearchPath
else|:
name|targ
operator|->
name|suff
operator|->
name|searchPath
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|path
operator|!=
name|NULL
condition|)
block|{
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|gn
operator|->
name|path
argument_list|,
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|!=
name|NULL
condition|)
block|{
comment|/* 		     * Suffix known for the thing -- trim the suffix off 		     * the path to form the proper .PREFIX variable. 		     */
name|int
name|len
init|=
name|strlen
argument_list|(
name|gn
operator|->
name|path
argument_list|)
decl_stmt|;
name|char
name|savec
decl_stmt|;
name|gn
operator|->
name|suffix
operator|=
name|targ
operator|->
name|suff
expr_stmt|;
name|savec
operator|=
name|gn
operator|->
name|path
index|[
name|len
operator|-
name|targ
operator|->
name|suff
operator|->
name|nameLen
index|]
expr_stmt|;
name|gn
operator|->
name|path
index|[
name|len
operator|-
name|targ
operator|->
name|suff
operator|->
name|nameLen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|Var_Set
argument_list|(
name|PREFIX
argument_list|,
name|gn
operator|->
name|path
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|gn
operator|->
name|path
index|[
name|len
operator|-
name|targ
operator|->
name|suff
operator|->
name|nameLen
index|]
operator|=
name|savec
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     * The .PREFIX gets the full path if the target has 		     * no known suffix. 		     */
name|gn
operator|->
name|suffix
operator|=
name|NULL
expr_stmt|;
name|Var_Set
argument_list|(
name|PREFIX
argument_list|,
name|gn
operator|->
name|path
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 	     * Not appropriate to search for the thing -- set the 	     * path to be the name so Dir_MTime won't go grovelling for 	     * it. 	     */
name|gn
operator|->
name|suffix
operator|=
operator|(
name|targ
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|targ
operator|->
name|suff
expr_stmt|;
name|gn
operator|->
name|path
operator|=
name|gn
operator|->
name|name
expr_stmt|;
block|}
goto|goto
name|sfnd_return
goto|;
block|}
comment|/*      * If the suffix indicates that the target is a library, mark that in      * the node's type field.      */
if|if
condition|(
name|targ
operator|->
name|suff
operator|->
name|flags
operator|&
name|SUFF_LIBRARY
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|OP_LIB
expr_stmt|;
block|}
comment|/*      * Check for overriding transformation rule implied by sources      */
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|children
argument_list|)
condition|)
block|{
name|src
operator|=
name|SuffFindCmds
argument_list|(
name|targ
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|!=
operator|(
name|Src
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* 	     * Free up all the Src structures in the transformation path 	     * up to, but not including, the parent node. 	     */
while|while
condition|(
name|bottom
operator|&&
name|bottom
operator|->
name|parent
operator|!=
name|NULL
condition|)
block|{
name|Src
modifier|*
name|p
init|=
name|bottom
operator|->
name|parent
decl_stmt|;
name|SuffFreeSrc
argument_list|(
name|bottom
argument_list|)
expr_stmt|;
name|bottom
operator|=
name|p
expr_stmt|;
block|}
name|bottom
operator|=
name|src
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bottom
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * No idea from where it can come -- return now. 	 */
goto|goto
name|sfnd_abort
goto|;
block|}
comment|/*      * We now have a list of Src structures headed by 'bottom' and linked via      * their 'parent' pointers. What we do next is create links between      * source and target nodes (which may or may not have been created)      * and set the necessary local variables in each target. The      * commands for each target are set from the commands of the      * transformation rule used to get from the src suffix to the targ      * suffix. Note that this causes the commands list of the original      * node, gn, to be replaced by the commands of the final      * transformation rule. Also, the unmade field of gn is incremented.      * Etc.       */
if|if
condition|(
name|bottom
operator|->
name|node
operator|==
name|NILGNODE
condition|)
block|{
name|bottom
operator|->
name|node
operator|=
name|Targ_FindNode
argument_list|(
name|bottom
operator|->
name|file
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|src
operator|=
name|bottom
init|;
name|src
operator|->
name|parent
operator|!=
operator|(
name|Src
operator|*
operator|)
name|NULL
condition|;
name|src
operator|=
name|src
operator|->
name|parent
control|)
block|{
name|targ
operator|=
name|src
operator|->
name|parent
expr_stmt|;
name|src
operator|->
name|node
operator|->
name|suffix
operator|=
name|src
operator|->
name|suff
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|node
operator|==
name|NILGNODE
condition|)
block|{
name|targ
operator|->
name|node
operator|=
name|Targ_FindNode
argument_list|(
name|targ
operator|->
name|file
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
block|}
name|SuffApplyTransform
argument_list|(
name|targ
operator|->
name|node
argument_list|,
name|src
operator|->
name|node
argument_list|,
name|targ
operator|->
name|suff
argument_list|,
name|src
operator|->
name|suff
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|node
operator|!=
name|gn
condition|)
block|{
comment|/* 	     * Finish off the dependency-search process for any nodes 	     * between bottom and gn (no point in questing around the 	     * filesystem for their implicit source when it's already 	     * known). Note that the node can't have any sources that 	     * need expanding, since SuffFindThem will stop on an existing 	     * node, so all we need to do is set the standard and System V 	     * variables. 	     */
name|targ
operator|->
name|node
operator|->
name|type
operator||=
name|OP_DEPS_FOUND
expr_stmt|;
name|Var_Set
argument_list|(
name|PREFIX
argument_list|,
name|targ
operator|->
name|pref
argument_list|,
name|targ
operator|->
name|node
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|targ
operator|->
name|node
operator|->
name|name
argument_list|,
name|targ
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
block|}
name|gn
operator|->
name|suffix
operator|=
name|src
operator|->
name|suff
expr_stmt|;
comment|/*      * So Dir_MTime doesn't go questing for it...      */
name|gn
operator|->
name|path
operator|=
name|gn
operator|->
name|name
expr_stmt|;
comment|/*      * Nuke the transformation path and the Src structures left over in the      * two lists.      */
name|SuffFreeSrc
argument_list|(
name|bottom
argument_list|)
expr_stmt|;
name|sfnd_return
label|:
name|Lst_Destroy
argument_list|(
name|srcs
argument_list|,
name|SuffFreeSrc
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|targs
argument_list|,
name|SuffFreeSrc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_FindDeps  --  *	Find implicit sources for the target described by the graph node  *	gn  *  * Results:  *	Nothing.  *  * Side Effects:  *	Nodes are added to the graph below the passed-in node. The nodes  *	are marked to have their IMPSRC variable filled in. The  *	PREFIX variable is set for the given node and all its  *	implied children.  *  * Notes:  *	The path found by this target is the shortest path in the  *	transformation graph, which may pass through non-existent targets,  *	to an existing target. The search continues on all paths from the  *	root suffix until a file is found. I.e. if there's a path  *	.o -> .c -> .l -> .l,v from the root and the .l,v file exists but  *	the .c and .l files don't, the search will branch out in  *	all directions from .o and again from all the nodes on the  *	next level until the .l,v node is encountered.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_FindDeps
parameter_list|(
name|gn
parameter_list|)
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* node we're dealing with */
block|{
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_DEPS_FOUND
condition|)
block|{
comment|/* 	 * If dependencies already found, no need to do it again... 	 */
return|return;
block|}
else|else
block|{
name|gn
operator|->
name|type
operator||=
name|OP_DEPS_FOUND
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Suff_FindDeps (%s)\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_ARCHV
condition|)
block|{
name|SuffFindArchiveDeps
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_LIB
condition|)
block|{
comment|/* 	 * If the node is a library, it is the arch module's job to find it 	 * and set the TARGET variable accordingly. We merely provide the 	 * search path, assuming all libraries end in ".a" (if the suffix 	 * hasn't been defined, there's nothing we can do for it, so we just 	 * set the TARGET variable to the node's name in order to give it a 	 * value). 	 */
name|LstNode
name|ln
decl_stmt|;
name|Suff
modifier|*
name|s
decl_stmt|;
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
operator|(
name|ClientData
operator|)
name|LIBSUFF
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NILLNODE
condition|)
block|{
name|gn
operator|->
name|suffix
operator|=
name|s
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|Arch_FindLib
argument_list|(
name|gn
argument_list|,
name|s
operator|->
name|searchPath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gn
operator|->
name|suffix
operator|=
name|NULL
expr_stmt|;
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Because a library (-lfoo) target doesn't follow the standard 	 * filesystem conventions, we don't set the regular variables for 	 * the thing. .PREFIX is simply made empty... 	 */
name|Var_Set
argument_list|(
name|PREFIX
argument_list|,
literal|""
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SuffFindNormalDeps
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_SetNull --  *	Define which suffix is the null suffix.  *  * Results:  *	None.  *  * Side Effects:  *	'suffNull' is altered.  *  * Notes:  *	Need to handle the changing of the null suffix gracefully so the  *	old transformation rules don't just go away.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_SetNull
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of null suffix */
block|{
name|Suff
modifier|*
name|s
decl_stmt|;
name|LstNode
name|ln
decl_stmt|;
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
operator|(
name|ClientData
operator|)
name|name
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NILLNODE
condition|)
block|{
name|s
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|suffNull
operator|!=
operator|(
name|Suff
operator|*
operator|)
name|NULL
condition|)
block|{
name|suffNull
operator|->
name|flags
operator|&=
operator|~
name|SUFF_NULL
expr_stmt|;
block|}
name|s
operator|->
name|flags
operator||=
name|SUFF_NULL
expr_stmt|;
comment|/* 	 * XXX: Here's where the transformation mangling would take place 	 */
name|suffNull
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Desired null suffix %s not defined."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_Init --  *	Initialize suffixes module  *  * Results:  *	None  *  * Side Effects:  *	Many  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_Init
parameter_list|()
block|{
name|sufflist
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|transforms
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|sNum
operator|=
literal|0
expr_stmt|;
comment|/*      * Create null suffix for single-suffix rules (POSIX). The thing doesn't      * actually go on the suffix list or everyone will think that's its      * suffix.      */
name|emptySuff
operator|=
name|suffNull
operator|=
operator|(
name|Suff
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Suff
argument_list|)
argument_list|)
expr_stmt|;
name|suffNull
operator|->
name|name
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|suffNull
operator|->
name|nameLen
operator|=
literal|0
expr_stmt|;
name|suffNull
operator|->
name|searchPath
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|suffNull
operator|->
name|children
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|suffNull
operator|->
name|parents
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|suffNull
operator|->
name|sNum
operator|=
name|sNum
operator|++
expr_stmt|;
name|suffNull
operator|->
name|flags
operator|=
name|SUFF_NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************* DEBUGGING FUNCTIONS **********************/
end_comment

begin_function
specifier|static
name|int
name|SuffPrintName
parameter_list|(
name|s
parameter_list|)
name|Suff
modifier|*
name|s
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SuffPrintSuff
parameter_list|(
name|s
parameter_list|)
name|Suff
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|printf
argument_list|(
literal|"# `%s'"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|flags
operator|=
name|s
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|flags
condition|)
block|{
name|fputs
argument_list|(
literal|" ("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
name|flags
condition|)
block|{
name|flag
operator|=
literal|1
operator|<<
operator|(
name|ffs
argument_list|(
name|flags
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|flag
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|SUFF_NULL
case|:
name|printf
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUFF_INCLUDE
case|:
name|printf
argument_list|(
literal|"INCLUDE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUFF_LIBRARY
case|:
name|printf
argument_list|(
literal|"LIBRARY"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fputc
argument_list|(
name|flags
condition|?
literal|'|'
else|:
literal|')'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#\tTo: "
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|s
operator|->
name|parents
argument_list|,
name|SuffPrintName
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#\tFrom: "
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|s
operator|->
name|children
argument_list|,
name|SuffPrintName
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#\tSearch Path: "
argument_list|)
expr_stmt|;
name|Dir_PrintPath
argument_list|(
name|s
operator|->
name|searchPath
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SuffPrintTrans
parameter_list|(
name|t
parameter_list|)
name|GNode
modifier|*
name|t
decl_stmt|;
block|{
specifier|extern
name|int
name|Targ_PrintCmd
parameter_list|()
function_decl|;
name|printf
argument_list|(
literal|"%-16s: "
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
name|Targ_PrintType
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|t
operator|->
name|commands
argument_list|,
name|Targ_PrintCmd
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|Suff_PrintAll
parameter_list|()
block|{
name|printf
argument_list|(
literal|"#*** Suffixes:\n"
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|sufflist
argument_list|,
name|SuffPrintSuff
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#*** Transformations:\n"
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|transforms
argument_list|,
name|SuffPrintTrans
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

