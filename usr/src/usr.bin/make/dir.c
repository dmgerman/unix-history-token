begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)dir.c	8.1 (Berkeley) 6/6/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*-  * dir.c --  *	Directory searching using wildcards and/or normal names...  *	Used both for source wildcarding in the Makefile and for finding  *	implicit sources.  *  * The interface for this module is:  *	Dir_Init  	    Initialize the module.  *  *	Dir_HasWildcards    Returns TRUE if the name given it needs to  *	    	  	    be wildcard-expanded.  *  *	Dir_Expand	    Given a pattern and a path, return a Lst of names  *	    	  	    which match the pattern on the search path.  *  *	Dir_FindFile	    Searches for a file on a given search path.  *	    	  	    If it exists, the entire path is returned.  *	    	  	    Otherwise NULL is returned.  *  *	Dir_MTime 	    Return the modification time of a node. The file  *	    	  	    is searched for along the default search path.  *	    	  	    The path and mtime fields of the node are filled  *	    	  	    in.  *  *	Dir_AddDir	    Add a directory to a search path.  *  *	Dir_MakeFlags	    Given a search path and a command flag, create  *	    	  	    a string with each of the directories in the path  *	    	  	    preceded by the command flag and all of them  *	    	  	    separated by a space.  *  *	Dir_Destroy	    Destroy an element of a search path. Frees up all  *	    	  	    things that can be freed for the element as long  *	    	  	    as the element is no longer referenced by any other  *	    	  	    search path.  *	Dir_ClearPath	    Resets a search path to the empty list.  *  * For debugging:  *	Dir_PrintDirectories	Print stats about the directory cache.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_comment
comment|/*  *	A search path consists of a Lst of Path structures. A Path structure  *	has in it the name of the directory and a hash table of all the files  *	in the directory. This is used to cut down on the number of system  *	calls necessary to find implicit dependents and their like. Since  *	these searches are made before any actions are taken, we need not  *	worry about the directory changing due to creation commands. If this  *	hampers the style of some makefiles, they must be changed.  *  *	A list of all previously-read directories is kept in the  *	openDirectories Lst. This list is checked first before a directory  *	is opened.  *  *	The need for the caching of whole directories is brought about by  *	the multi-level transformation code in suff.c, which tends to search  *	for far more files than regular make does. In the initial  *	implementation, the amount of time spent performing "stat" calls was  *	truly astronomical. The problem with hashing at the start is,  *	of course, that pmake doesn't then detect changes to these directories  *	during the course of the make. Three possibilities suggest themselves:  *  *	    1) just use stat to test for a file's existence. As mentioned  *	       above, this is very inefficient due to the number of checks  *	       engendered by the multi-level transformation code.  *	    2) use readdir() and company to search the directories, keeping  *	       them open between checks. I have tried this and while it  *	       didn't slow down the process too much, it could severely  *	       affect the amount of parallelism available as each directory  *	       open would take another file descriptor out of play for  *	       handling I/O for another job. Given that it is only recently  *	       that UNIX OS's have taken to allowing more than 20 or 32  *	       file descriptors for a process, this doesn't seem acceptable  *	       to me.  *	    3) record the mtime of the directory in the Path structure and  *	       verify the directory hasn't changed since the contents were  *	       hashed. This will catch the creation or deletion of files,  *	       but not the updating of files. However, since it is the  *	       creation and deletion that is the problem, this could be  *	       a good thing to do. Unfortunately, if the directory (say ".")  *	       were fairly large and changed fairly frequently, the constant  *	       rehashing could seriously degrade performance. It might be  *	       good in such cases to keep track of the number of rehashes  *	       and if the number goes over a (small) limit, resort to using  *	       stat in its place.  *  *	An additional thing to consider is that pmake is used primarily  *	to create C programs and until recently pcc-based compilers refused  *	to allow you to specify where the resulting object file should be  *	placed. This forced all objects to be created in the current  *	directory. This isn't meant as a full excuse, just an explanation of  *	some of the reasons for the caching used here.  *  *	One more note: the location of a target's file is only performed  *	on the downward traversal of the graph and then only for terminal  *	nodes in the graph. This could be construed as wrong in some cases,  *	but prevents inadvertent modification of files when the "installed"  *	directory for a file is provided in the search path.  *  *	Another data structure maintained by this module is an mtime  *	cache used when the searching of cached directories fails to find  *	a file. In the past, Dir_FindFile would simply perform an access()  *	call in such a case to determine if the file could be found using  *	just the name given. When this hit, however, all that was gained  *	was the knowledge that the file existed. Given that an access() is  *	essentially a stat() without the copyout() call, and that the same  *	filesystem overhead would have to be incurred in Dir_MTime, it made  *	sense to replace the access() with a stat() and record the mtime  *	in a cache for when Dir_MTime was actually called.  */
end_comment

begin_decl_stmt
name|Lst
name|dirSearchPath
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* main search path */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|openDirectories
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the list of all open directories */
end_comment

begin_comment
comment|/*  * Variables for gathering statistics on the efficiency of the hashing  * mechanism.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hits
decl_stmt|,
comment|/* Found in directory cache */
name|misses
decl_stmt|,
comment|/* Sad, but not evil misses */
name|nearmisses
decl_stmt|,
comment|/* Found under search path */
name|bigmisses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sought by itself */
end_comment

begin_decl_stmt
specifier|static
name|Path
modifier|*
name|dot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* contents of current directory */
end_comment

begin_decl_stmt
specifier|static
name|Hash_Table
name|mtimes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Results of doing a last-resort stat in 			     * Dir_FindFile -- if we have to go to the 			     * system to find the file, we might as well 			     * have its mtime on record. XXX: If this is done 			     * way early, there's a chance other rules will 			     * have already updated the file, in which case 			     * we'll update it again. Generally, there won't 			     * be two rules to update a single file, so this 			     * should be ok, but... */
end_comment

begin_decl_stmt
specifier|static
name|int
name|DirFindName
name|__P
argument_list|(
operator|(
name|Path
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DirMatchFiles
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|Path
operator|*
operator|,
name|Lst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DirExpandCurly
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|Lst
operator|,
name|Lst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DirExpandInt
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|Lst
operator|,
name|Lst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DirPrintWord
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|DirPrintDir
name|__P
argument_list|(
operator|(
name|Path
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_Init --  *	initialize things for this module  *  * Results:  *	none  *  * Side Effects:  *	some directories may be opened.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Dir_Init
parameter_list|()
block|{
name|dirSearchPath
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|openDirectories
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|Hash_InitTable
argument_list|(
operator|&
name|mtimes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Since the Path structure is placed on both openDirectories and      * the path we give Dir_AddDir (which in this case is openDirectories),      * we need to remove "." from openDirectories and what better time to      * do it than when we have to fetch the thing anyway?      */
name|Dir_AddDir
argument_list|(
name|openDirectories
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|dot
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|openDirectories
argument_list|)
expr_stmt|;
comment|/*      * We always need to have dot around, so we increment its reference count      * to make sure it's not destroyed.      */
name|dot
operator|->
name|refCount
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * DirFindName --  *	See if the Path structure describes the same directory as the  *	given one by comparing their names. Called from Dir_AddDir via  *	Lst_Find when searching the list of open directories.  *  * Results:  *	0 if it is the same. Non-zero otherwise  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|DirFindName
parameter_list|(
name|p
parameter_list|,
name|dname
parameter_list|)
name|Path
modifier|*
name|p
decl_stmt|;
comment|/* Current name */
name|char
modifier|*
name|dname
decl_stmt|;
comment|/* Desired name */
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|dname
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_HasWildcards  --  *	see if the given name has any wildcard characters in it  *  * Results:  *	returns TRUE if the word should be expanded, FALSE otherwise  *  * Side Effects:  *	none  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Dir_HasWildcards
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name to check */
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|name
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'{'
case|:
case|case
literal|'['
case|:
case|case
literal|'?'
case|:
case|case
literal|'*'
case|:
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * DirMatchFiles --  * 	Given a pattern and a Path structure, see if any files  *	match the pattern and add their names to the 'expansions' list if  *	any do. This is incomplete -- it doesn't take care of patterns like  *	src / *src / *.c properly (just *.c on any of the directories), but it  *	will do for now.  *  * Results:  *	Always returns 0  *  * Side Effects:  *	File names are added to the expansions lst. The directory will be  *	fully hashed when this is done.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|DirMatchFiles
parameter_list|(
name|pattern
parameter_list|,
name|p
parameter_list|,
name|expansions
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
comment|/* Pattern to look for */
name|Path
modifier|*
name|p
decl_stmt|;
comment|/* Directory to search */
name|Lst
name|expansions
decl_stmt|;
comment|/* Place to store the results */
block|{
name|Hash_Search
name|search
decl_stmt|;
comment|/* Index into the directory's table */
name|Hash_Entry
modifier|*
name|entry
decl_stmt|;
comment|/* Current entry in the table */
name|Boolean
name|isDot
decl_stmt|;
comment|/* TRUE if the directory being searched is . */
name|isDot
operator|=
operator|(
operator|*
name|p
operator|->
name|name
operator|==
literal|'.'
operator|&&
name|p
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|Hash_EnumFirst
argument_list|(
operator|&
name|p
operator|->
name|files
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|entry
operator|!=
operator|(
name|Hash_Entry
operator|*
operator|)
name|NULL
condition|;
name|entry
operator|=
name|Hash_EnumNext
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
comment|/* 	 * See if the file matches the given pattern. Note we follow the UNIX 	 * convention that dot files will only be found if the pattern 	 * begins with a dot (note also that as a side effect of the hashing 	 * scheme, .* won't match . or .. since they aren't hashed). 	 */
if|if
condition|(
name|Str_Match
argument_list|(
name|entry
operator|->
name|name
argument_list|,
name|pattern
argument_list|)
operator|&&
operator|(
operator|(
name|entry
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|)
operator|||
operator|(
name|pattern
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|expansions
argument_list|,
operator|(
name|isDot
condition|?
name|strdup
argument_list|(
name|entry
operator|->
name|name
argument_list|)
else|:
name|str_concat
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|STR_ADDSLASH
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * DirExpandCurly --  *	Expand curly braces like the C shell. Does this recursively.  *	Note the special case: if after the piece of the curly brace is  *	done there are no wildcard characters in the result, the result is  *	placed on the list WITHOUT CHECKING FOR ITS EXISTENCE.  *  * Results:  *	None.  *  * Side Effects:  *	The given list is filled with the expansions...  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DirExpandCurly
parameter_list|(
name|word
parameter_list|,
name|brace
parameter_list|,
name|path
parameter_list|,
name|expansions
parameter_list|)
name|char
modifier|*
name|word
decl_stmt|;
comment|/* Entire word to expand */
name|char
modifier|*
name|brace
decl_stmt|;
comment|/* First curly brace in it */
name|Lst
name|path
decl_stmt|;
comment|/* Search path to use */
name|Lst
name|expansions
decl_stmt|;
comment|/* Place to store the expansions */
block|{
name|char
modifier|*
name|end
decl_stmt|;
comment|/* Character after the closing brace */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Current position in brace clause */
name|char
modifier|*
name|start
decl_stmt|;
comment|/* Start of current piece of brace clause */
name|int
name|bracelevel
decl_stmt|;
comment|/* Number of braces we've seen. If we see a 				 * right brace when this is 0, we've hit the 				 * end of the clause. */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* Current expansion */
name|int
name|otherLen
decl_stmt|;
comment|/* The length of the other pieces of the 				 * expansion (chars before and after the 				 * clause in 'word') */
name|char
modifier|*
name|cp2
decl_stmt|;
comment|/* Pointer for checking for wildcards in 				 * expansion before calling Dir_Expand */
name|start
operator|=
name|brace
operator|+
literal|1
expr_stmt|;
comment|/*      * Find the end of the brace clause first, being wary of nested brace      * clauses.      */
for|for
control|(
name|end
operator|=
name|start
operator|,
name|bracelevel
operator|=
literal|0
init|;
operator|*
name|end
operator|!=
literal|'\0'
condition|;
name|end
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|end
operator|==
literal|'{'
condition|)
block|{
name|bracelevel
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|end
operator|==
literal|'}'
operator|)
operator|&&
operator|(
name|bracelevel
operator|--
operator|==
literal|0
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|end
operator|==
literal|'\0'
condition|)
block|{
name|Error
argument_list|(
literal|"Unterminated {} clause \"%s\""
argument_list|,
name|start
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|end
operator|++
expr_stmt|;
block|}
name|otherLen
operator|=
name|brace
operator|-
name|word
operator|+
name|strlen
argument_list|(
name|end
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|start
init|;
name|cp
operator|<
name|end
condition|;
name|cp
operator|++
control|)
block|{
comment|/* 	 * Find the end of this piece of the clause. 	 */
name|bracelevel
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'{'
condition|)
block|{
name|bracelevel
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'}'
operator|)
operator|&&
operator|(
name|bracelevel
operator|--
operator|<=
literal|0
operator|)
condition|)
block|{
break|break;
block|}
name|cp
operator|++
expr_stmt|;
block|}
comment|/* 	 * Allocate room for the combination and install the three pieces. 	 */
name|file
operator|=
name|emalloc
argument_list|(
name|otherLen
operator|+
name|cp
operator|-
name|start
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|brace
operator|!=
name|word
condition|)
block|{
name|strncpy
argument_list|(
name|file
argument_list|,
name|word
argument_list|,
name|brace
operator|-
name|word
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|!=
name|start
condition|)
block|{
name|strncpy
argument_list|(
operator|&
name|file
index|[
name|brace
operator|-
name|word
index|]
argument_list|,
name|start
argument_list|,
name|cp
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
operator|&
name|file
index|[
operator|(
name|brace
operator|-
name|word
operator|)
operator|+
operator|(
name|cp
operator|-
name|start
operator|)
index|]
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|/* 	 * See if the result has any wildcards in it. If we find one, call 	 * Dir_Expand right away, telling it to place the result on our list 	 * of expansions. 	 */
for|for
control|(
name|cp2
operator|=
name|file
init|;
operator|*
name|cp2
operator|!=
literal|'\0'
condition|;
name|cp2
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|cp2
condition|)
block|{
case|case
literal|'*'
case|:
case|case
literal|'?'
case|:
case|case
literal|'{'
case|:
case|case
literal|'['
case|:
name|Dir_Expand
argument_list|(
name|file
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
block|}
if|if
condition|(
operator|*
name|cp2
operator|==
literal|'\0'
condition|)
block|{
comment|/* 	     * Hit the end w/o finding any wildcards, so stick the expansion 	     * on the end of the list. 	     */
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|expansions
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next
label|:
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * DirExpandInt --  *	Internal expand routine. Passes through the directories in the  *	path one by one, calling DirMatchFiles for each. NOTE: This still  *	doesn't handle patterns in directories...  *  * Results:  *	None.  *  * Side Effects:  *	Things are added to the expansions list.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DirExpandInt
parameter_list|(
name|word
parameter_list|,
name|path
parameter_list|,
name|expansions
parameter_list|)
name|char
modifier|*
name|word
decl_stmt|;
comment|/* Word to expand */
name|Lst
name|path
decl_stmt|;
comment|/* Path on which to look */
name|Lst
name|expansions
decl_stmt|;
comment|/* Place to store the result */
block|{
name|LstNode
name|ln
decl_stmt|;
comment|/* Current node */
name|Path
modifier|*
name|p
decl_stmt|;
comment|/* Directory in the node */
if|if
condition|(
name|Lst_Open
argument_list|(
name|path
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|path
argument_list|)
operator|)
operator|!=
name|NILLNODE
condition|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|DirMatchFiles
argument_list|(
name|word
argument_list|,
name|p
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
block|}
name|Lst_Close
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * DirPrintWord --  *	Print a word in the list of expansions. Callback for Dir_Expand  *	when DEBUG(DIR), via Lst_ForEach.  *  * Results:  *	=== 0  *  * Side Effects:  *	The passed word is printed, followed by a space.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|DirPrintWord
parameter_list|(
name|word
parameter_list|)
name|char
modifier|*
name|word
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|word
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_Expand  --  *	Expand the given word into a list of words by globbing it looking  *	in the directories on the given search path.  *  * Results:  *	A list of words consisting of the files which exist along the search  *	path matching the given pattern.  *  * Side Effects:  *	Directories may be opened. Who knows?  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Dir_Expand
parameter_list|(
name|word
parameter_list|,
name|path
parameter_list|,
name|expansions
parameter_list|)
name|char
modifier|*
name|word
decl_stmt|;
comment|/* the word to expand */
name|Lst
name|path
decl_stmt|;
comment|/* the list of directories in which to find 			 * the resulting files */
name|Lst
name|expansions
decl_stmt|;
comment|/* the list on which to place the results */
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"expanding \"%s\"..."
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|strchr
argument_list|(
name|word
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|DirExpandCurly
argument_list|(
name|word
argument_list|,
name|cp
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|strchr
argument_list|(
name|word
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
comment|/* 	     * The thing has a directory component -- find the first wildcard 	     * in the string. 	     */
for|for
control|(
name|cp
operator|=
name|word
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'?'
operator|||
operator|*
name|cp
operator|==
literal|'['
operator|||
operator|*
name|cp
operator|==
literal|'*'
operator|||
operator|*
name|cp
operator|==
literal|'{'
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'{'
condition|)
block|{
comment|/* 		 * This one will be fun. 		 */
name|DirExpandCurly
argument_list|(
name|word
argument_list|,
name|cp
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 		 * Back up to the start of the component 		 */
name|char
modifier|*
name|dirpath
decl_stmt|;
while|while
condition|(
name|cp
operator|>
name|word
operator|&&
operator|*
name|cp
operator|!=
literal|'/'
condition|)
block|{
name|cp
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|!=
name|word
condition|)
block|{
name|char
name|sc
decl_stmt|;
comment|/* 		     * If the glob isn't in the first component, try and find 		     * all the components up to the one with a wildcard. 		     */
name|sc
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dirpath
operator|=
name|Dir_FindFile
argument_list|(
name|word
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
name|sc
expr_stmt|;
comment|/* 		     * dirpath is null if can't find the leading component 		     * XXX: Dir_FindFile won't find internal components. 		     * i.e. if the path contains ../Etc/Object and we're 		     * looking for Etc, it won't be found. Ah well. 		     * Probably not important. 		     */
if|if
condition|(
name|dirpath
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|dp
init|=
operator|&
name|dirpath
index|[
name|strlen
argument_list|(
name|dirpath
argument_list|)
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|dp
operator|==
literal|'/'
condition|)
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
name|path
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|Dir_AddDir
argument_list|(
name|path
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|DirExpandInt
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|path
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		     * Start the search from the local directory 		     */
name|DirExpandInt
argument_list|(
name|word
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Return the file -- this should never happen. 		 */
name|DirExpandInt
argument_list|(
name|word
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	     * First the files in dot 	     */
name|DirMatchFiles
argument_list|(
name|word
argument_list|,
name|dot
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
comment|/* 	     * Then the files in every other directory on the path. 	     */
name|DirExpandInt
argument_list|(
name|word
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|Lst_ForEach
argument_list|(
name|expansions
argument_list|,
name|DirPrintWord
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_FindFile  --  *	Find the file with the given name along the given search path.  *  * Results:  *	The path to the file or NULL. This path is guaranteed to be in a  *	different part of memory than name and so may be safely free'd.  *  * Side Effects:  *	If the file is found in a directory which is not on the path  *	already (either 'name' is absolute or it is a relative path  *	[ dir1/.../dirn/file ] which exists below one of the directories  *	already on the search path), its directory is added to the end  *	of the path on the assumption that there will be more files in  *	that directory later on. Sometimes this is true. Sometimes not.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Dir_FindFile
parameter_list|(
name|name
parameter_list|,
name|path
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* the file to find */
name|Lst
name|path
decl_stmt|;
comment|/* the Lst of directories to search */
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
comment|/* pointer into p->name */
specifier|register
name|char
modifier|*
name|p2
decl_stmt|;
comment|/* pointer into name */
name|LstNode
name|ln
decl_stmt|;
comment|/* a list element */
specifier|register
name|char
modifier|*
name|file
decl_stmt|;
comment|/* the current filename to check */
specifier|register
name|Path
modifier|*
name|p
decl_stmt|;
comment|/* current path member */
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* index of first slash, if any */
name|Boolean
name|hasSlash
decl_stmt|;
comment|/* true if 'name' contains a / */
name|struct
name|stat
name|stb
decl_stmt|;
comment|/* Buffer for stat, if necessary */
name|Hash_Entry
modifier|*
name|entry
decl_stmt|;
comment|/* Entry for mtimes table */
comment|/*      * Find the final component of the name and note whether it has a      * slash in it (the name, I mean)      */
name|cp
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|hasSlash
operator|=
name|TRUE
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|hasSlash
operator|=
name|FALSE
expr_stmt|;
name|cp
operator|=
name|name
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Searching for %s..."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/*      * No matter what, we always look for the file in the current directory      * before anywhere else and we *do not* add the ./ to it if it exists.      * This is so there are no conflicts between what the user specifies      * (fish.c) and what pmake finds (./fish.c).      */
if|if
condition|(
operator|(
operator|!
name|hasSlash
operator|||
operator|(
name|cp
operator|-
name|name
operator|==
literal|2
operator|&&
operator|*
name|name
operator|==
literal|'.'
operator|)
operator|)
operator|&&
operator|(
name|Hash_FindEntry
argument_list|(
operator|&
name|dot
operator|->
name|files
argument_list|,
name|cp
argument_list|)
operator|!=
operator|(
name|Hash_Entry
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"in '.'\n"
argument_list|)
expr_stmt|;
block|}
name|hits
operator|+=
literal|1
expr_stmt|;
name|dot
operator|->
name|hits
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|Lst_Open
argument_list|(
name|path
argument_list|)
operator|==
name|FAILURE
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"couldn't open path, file not found\n"
argument_list|)
expr_stmt|;
block|}
name|misses
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
comment|/*      * We look through all the directories on the path seeking one which      * contains the final component of the given name and whose final      * component(s) match the name's initial component(s). If such a beast      * is found, we concatenate the directory name and the final component      * and return the resulting string. If we don't find any such thing,      * we go on to phase two...      */
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|path
argument_list|)
operator|)
operator|!=
name|NILLNODE
condition|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s..."
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Hash_FindEntry
argument_list|(
operator|&
name|p
operator|->
name|files
argument_list|,
name|cp
argument_list|)
operator|!=
operator|(
name|Hash_Entry
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"here..."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasSlash
condition|)
block|{
comment|/* 		 * If the name had a slash, its initial components and p's 		 * final components must match. This is false if a mismatch 		 * is encountered before all of the initial components 		 * have been checked (p2> name at the end of the loop), or 		 * we matched only part of one of the components of p 		 * along with all the rest of them (*p1 != '/'). 		 */
name|p1
operator|=
name|p
operator|->
name|name
operator|+
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
operator|-
literal|1
expr_stmt|;
name|p2
operator|=
name|cp
operator|-
literal|2
expr_stmt|;
while|while
condition|(
name|p2
operator|>=
name|name
operator|&&
operator|*
name|p1
operator|==
operator|*
name|p2
condition|)
block|{
name|p1
operator|-=
literal|1
expr_stmt|;
name|p2
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p2
operator|>=
name|name
operator|||
operator|(
name|p1
operator|>=
name|p
operator|->
name|name
operator|&&
operator|*
name|p1
operator|!=
literal|'/'
operator|)
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"component mismatch -- continuing..."
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
block|}
name|file
operator|=
name|str_concat
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|cp
argument_list|,
name|STR_ADDSLASH
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"returning %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|Lst_Close
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|p
operator|->
name|hits
operator|+=
literal|1
expr_stmt|;
name|hits
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|file
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|hasSlash
condition|)
block|{
comment|/* 	     * If the file has a leading path component and that component 	     * exactly matches the entire name of the current search 	     * directory, we assume the file doesn't exist and return NULL. 	     */
for|for
control|(
name|p1
operator|=
name|p
operator|->
name|name
operator|,
name|p2
operator|=
name|name
init|;
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|==
operator|*
name|p2
condition|;
name|p1
operator|++
operator|,
name|p2
operator|++
control|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|*
name|p1
operator|==
literal|'\0'
operator|&&
name|p2
operator|==
name|cp
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"must be here but isn't -- returing NULL\n"
argument_list|)
expr_stmt|;
block|}
name|Lst_Close
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
block|}
block|}
comment|/*      * We didn't find the file on any existing members of the directory.      * If the name doesn't contain a slash, that means it doesn't exist.      * If it *does* contain a slash, however, there is still hope: it      * could be in a subdirectory of one of the members of the search      * path. (eg. /usr/include and sys/types.h. The above search would      * fail to turn up types.h in /usr/include, but it *is* in      * /usr/include/sys/types.h) If we find such a beast, we assume there      * will be more (what else can we assume?) and add all but the last      * component of the resulting name onto the search path (at the      * end). This phase is only performed if the file is *not* absolute.      */
if|if
condition|(
operator|!
name|hasSlash
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"failed.\n"
argument_list|)
expr_stmt|;
block|}
name|misses
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|name
operator|!=
literal|'/'
condition|)
block|{
name|Boolean
name|checkedDot
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"failed. Trying subdirectories..."
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Lst_Open
argument_list|(
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|path
argument_list|)
operator|)
operator|!=
name|NILLNODE
condition|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|dot
condition|)
block|{
name|file
operator|=
name|str_concat
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|STR_ADDSLASH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Checking in dot -- DON'T put a leading ./ on the thing. 		 */
name|file
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|checkedDot
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"checking %s..."
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|stb
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"got it.\n"
argument_list|)
expr_stmt|;
block|}
name|Lst_Close
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|/* 		 * We've found another directory to search. We know there's 		 * a slash in 'file' because we put one there. We nuke it after 		 * finding it and call Dir_AddDir to add this new directory 		 * onto the existing search path. Once that's done, we restore 		 * the slash and triumphantly return the file name, knowing 		 * that should a file in this directory every be referenced 		 * again in such a manner, we will find it without having to do 		 * numerous numbers of access calls. Hurrah! 		 */
name|cp
operator|=
name|strrchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|Dir_AddDir
argument_list|(
name|path
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
comment|/* 		 * Save the modification time so if it's needed, we don't have 		 * to fetch it again. 		 */
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Caching %s for %s\n"
argument_list|,
name|Targ_FmtTime
argument_list|(
name|stb
operator|.
name|st_mtime
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|entry
operator|=
name|Hash_CreateEntry
argument_list|(
operator|&
name|mtimes
argument_list|,
operator|(
name|char
operator|*
operator|)
name|file
argument_list|,
operator|(
name|Boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Hash_SetValue
argument_list|(
name|entry
argument_list|,
name|stb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|nearmisses
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|file
operator|)
return|;
block|}
else|else
block|{
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"failed. "
argument_list|)
expr_stmt|;
block|}
name|Lst_Close
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkedDot
condition|)
block|{
comment|/* 	     * Already checked by the given name, since . was in the path, 	     * so no point in proceeding... 	     */
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Checked . already, returning NULL\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/*      * Didn't find it that way, either. Sigh. Phase 3. Add its directory      * onto the search path in any case, just in case, then look for the      * thing in the hash table. If we find it, grand. We return a new      * copy of the name. Otherwise we sadly return a NULL pointer. Sigh.      * Note that if the directory holding the file doesn't exist, this will      * do an extra search of the final directory on the path. Unless something      * weird happens, this search won't succeed and life will be groovy.      *      * Sigh. We cannot add the directory onto the search path because      * of this amusing case:      * $(INSTALLDIR)/$(FILE): $(FILE)      *      * $(FILE) exists in $(INSTALLDIR) but not in the current one.      * When searching for $(FILE), we will find it in $(INSTALLDIR)      * b/c we added it here. This is not good...      */
ifdef|#
directive|ifdef
name|notdef
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|Dir_AddDir
argument_list|(
name|path
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
name|bigmisses
operator|+=
literal|1
expr_stmt|;
name|ln
operator|=
name|Lst_Last
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NILLNODE
condition|)
block|{
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Hash_FindEntry
argument_list|(
operator|&
name|p
operator|->
name|files
argument_list|,
name|cp
argument_list|)
operator|!=
operator|(
name|Hash_Entry
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
else|#
directive|else
comment|/* !notdef */
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Looking for \"%s\"..."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|bigmisses
operator|+=
literal|1
expr_stmt|;
name|entry
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|mtimes
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
operator|(
name|Hash_Entry
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"got it (in mtime cache)\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|stb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|entry
operator|=
name|Hash_CreateEntry
argument_list|(
operator|&
name|mtimes
argument_list|,
name|name
argument_list|,
operator|(
name|Boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Caching %s for %s\n"
argument_list|,
name|Targ_FmtTime
argument_list|(
name|stb
operator|.
name|st_mtime
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|Hash_SetValue
argument_list|(
name|entry
argument_list|,
name|stb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
return|return
operator|(
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"failed. Returning NULL\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* notdef */
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_MTime  --  *	Find the modification time of the file described by gn along the  *	search path dirSearchPath.  *   * Results:  *	The modification time or 0 if it doesn't exist  *  * Side Effects:  *	The modification time is placed in the node's mtime slot.  *	If the node didn't have a path entry before, and Dir_FindFile  *	found one for it, the full name is placed in the path slot.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Dir_MTime
parameter_list|(
name|gn
parameter_list|)
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* the file whose modification time is 			       * desired */
block|{
name|char
modifier|*
name|fullName
decl_stmt|;
comment|/* the full pathname of name */
name|struct
name|stat
name|stb
decl_stmt|;
comment|/* buffer for finding the mod time */
name|Hash_Entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_ARCHV
condition|)
block|{
return|return
name|Arch_MTime
argument_list|(
name|gn
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|path
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|fullName
operator|=
name|Dir_FindFile
argument_list|(
name|gn
operator|->
name|name
argument_list|,
name|dirSearchPath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fullName
operator|=
name|gn
operator|->
name|path
expr_stmt|;
block|}
if|if
condition|(
name|fullName
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|fullName
operator|=
name|gn
operator|->
name|name
expr_stmt|;
block|}
name|entry
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|mtimes
argument_list|,
name|fullName
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
operator|(
name|Hash_Entry
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* 	 * Only do this once -- the second time folks are checking to 	 * see if the file was actually updated, so we need to actually go 	 * to the file system. 	 */
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Using cached time %s for %s\n"
argument_list|,
name|Targ_FmtTime
argument_list|(
operator|(
name|time_t
operator|)
name|Hash_GetValue
argument_list|(
name|entry
argument_list|)
argument_list|)
argument_list|,
name|fullName
argument_list|)
expr_stmt|;
block|}
name|stb
operator|.
name|st_mtime
operator|=
operator|(
name|time_t
operator|)
name|Hash_GetValue
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|Hash_DeleteEntry
argument_list|(
operator|&
name|mtimes
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|fullName
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_MEMBER
condition|)
block|{
return|return
name|Arch_MemMTime
argument_list|(
name|gn
argument_list|)
return|;
block|}
else|else
block|{
name|stb
operator|.
name|st_mtime
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fullName
operator|&&
name|gn
operator|->
name|path
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|gn
operator|->
name|path
operator|=
name|fullName
expr_stmt|;
block|}
name|gn
operator|->
name|mtime
operator|=
name|stb
operator|.
name|st_mtime
expr_stmt|;
return|return
operator|(
name|gn
operator|->
name|mtime
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_AddDir --  *	Add the given name to the end of the given path. The order of  *	the arguments is backwards so ParseDoDependency can do a  *	Lst_ForEach of its list of paths...  *  * Results:  *	none  *  * Side Effects:  *	A structure is added to the list and the directory is   *	read and hashed.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Dir_AddDir
parameter_list|(
name|path
parameter_list|,
name|name
parameter_list|)
name|Lst
name|path
decl_stmt|;
comment|/* the path to which the directory should be 			       * added */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* the name of the directory to add */
block|{
name|LstNode
name|ln
decl_stmt|;
comment|/* node in case Path structure is found */
specifier|register
name|Path
modifier|*
name|p
decl_stmt|;
comment|/* pointer to new Path structure */
name|DIR
modifier|*
name|d
decl_stmt|;
comment|/* for reading directory */
specifier|register
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
comment|/* entry in directory */
name|ln
operator|=
name|Lst_Find
argument_list|(
name|openDirectories
argument_list|,
operator|(
name|ClientData
operator|)
name|name
argument_list|,
name|DirFindName
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NILLNODE
condition|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lst_Member
argument_list|(
name|path
argument_list|,
operator|(
name|ClientData
operator|)
name|p
argument_list|)
operator|==
name|NILLNODE
condition|)
block|{
name|p
operator|->
name|refCount
operator|+=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|path
argument_list|,
operator|(
name|ClientData
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Caching %s..."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|d
operator|=
name|opendir
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
operator|(
name|DIR
operator|*
operator|)
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Path
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|hits
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
name|Hash_InitTable
argument_list|(
operator|&
name|p
operator|->
name|files
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	     * Skip the first two entries -- these will *always* be . and .. 	     */
operator|(
name|void
operator|)
name|readdir
argument_list|(
name|d
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|readdir
argument_list|(
name|d
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
operator|)
operator|!=
operator|(
expr|struct
name|direct
operator|*
operator|)
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|sun
comment|/* 		 * The sun directory library doesn't check for a 0 inode 		 * (0-inode slots just take up space), so we have to do 		 * it ourselves. 		 */
if|if
condition|(
name|dp
operator|->
name|d_fileno
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
endif|sun
operator|(
name|void
operator|)
name|Hash_CreateEntry
argument_list|(
operator|&
name|p
operator|->
name|files
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
operator|(
name|Boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|openDirectories
argument_list|,
operator|(
name|ClientData
operator|)
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|path
argument_list|,
operator|(
name|ClientData
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_CopyDir --  *	Callback function for duplicating a search path via Lst_Duplicate.  *	Ups the reference count for the directory.  *  * Results:  *	Returns the Path it was given.  *  * Side Effects:  *	The refCount of the path is incremented.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|ClientData
name|Dir_CopyDir
parameter_list|(
name|p
parameter_list|)
name|Path
modifier|*
name|p
decl_stmt|;
comment|/* Directory descriptor to copy */
block|{
name|p
operator|->
name|refCount
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
operator|(
name|ClientData
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_MakeFlags --  *	Make a string by taking all the directories in the given search  *	path and preceding them by the given flag. Used by the suffix  *	module to create variables for compilers based on suffix search  *	paths.  *  * Results:  *	The string mentioned above. Note that there is no space between  *	the given flag and each directory. The empty string is returned if  *	Things don't go well.  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Dir_MakeFlags
parameter_list|(
name|flag
parameter_list|,
name|path
parameter_list|)
name|char
modifier|*
name|flag
decl_stmt|;
comment|/* flag which should precede each directory */
name|Lst
name|path
decl_stmt|;
comment|/* list of directories */
block|{
name|char
modifier|*
name|str
decl_stmt|;
comment|/* the string which will be returned */
name|char
modifier|*
name|tstr
decl_stmt|;
comment|/* the current directory preceded by 'flag' */
name|LstNode
name|ln
decl_stmt|;
comment|/* the node of the current directory */
name|Path
modifier|*
name|p
decl_stmt|;
comment|/* the structure describing the current directory */
name|str
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lst_Open
argument_list|(
name|path
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|path
argument_list|)
operator|)
operator|!=
name|NILLNODE
condition|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|tstr
operator|=
name|str_concat
argument_list|(
name|flag
argument_list|,
name|p
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
operator|=
name|str_concat
argument_list|(
name|str
argument_list|,
name|tstr
argument_list|,
name|STR_ADDSPACE
operator||
name|STR_DOFREE
argument_list|)
expr_stmt|;
block|}
name|Lst_Close
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_Destroy --  *	Nuke a directory descriptor, if possible. Callback procedure  *	for the suffixes module when destroying a search path.  *  * Results:  *	None.  *  * Side Effects:  *	If no other path references this directory (refCount == 0),  *	the Path and all its data are freed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Dir_Destroy
parameter_list|(
name|p
parameter_list|)
name|Path
modifier|*
name|p
decl_stmt|;
comment|/* The directory descriptor to nuke */
block|{
name|p
operator|->
name|refCount
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|refCount
operator|==
literal|0
condition|)
block|{
name|LstNode
name|ln
decl_stmt|;
name|ln
operator|=
name|Lst_Member
argument_list|(
name|openDirectories
argument_list|,
operator|(
name|ClientData
operator|)
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_Remove
argument_list|(
name|openDirectories
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|Hash_DeleteTable
argument_list|(
operator|&
name|p
operator|->
name|files
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|Address
operator|)
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|Address
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_ClearPath --  *	Clear out all elements of the given search path. This is different  *	from destroying the list, notice.  *  * Results:  *	None.  *  * Side Effects:  *	The path is set to the empty list.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Dir_ClearPath
parameter_list|(
name|path
parameter_list|)
name|Lst
name|path
decl_stmt|;
comment|/* Path to clear */
block|{
name|Path
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|Dir_Destroy
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_Concat --  *	Concatenate two paths, adding the second to the end of the first.  *	Makes sure to avoid duplicates.  *  * Results:  *	None  *  * Side Effects:  *	Reference counts for added dirs are upped.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Dir_Concat
parameter_list|(
name|path1
parameter_list|,
name|path2
parameter_list|)
name|Lst
name|path1
decl_stmt|;
comment|/* Dest */
name|Lst
name|path2
decl_stmt|;
comment|/* Source */
block|{
name|LstNode
name|ln
decl_stmt|;
name|Path
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
name|path2
argument_list|)
init|;
name|ln
operator|!=
name|NILLNODE
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lst_Member
argument_list|(
name|path1
argument_list|,
operator|(
name|ClientData
operator|)
name|p
argument_list|)
operator|==
name|NILLNODE
condition|)
block|{
name|p
operator|->
name|refCount
operator|+=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|path1
argument_list|,
operator|(
name|ClientData
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/********** DEBUG INFO **********/
end_comment

begin_function
name|void
name|Dir_PrintDirectories
parameter_list|()
block|{
name|LstNode
name|ln
decl_stmt|;
name|Path
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"#*** Directory Cache:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"# Stats: %d hits %d misses %d near misses %d losers (%d%%)\n"
argument_list|,
name|hits
argument_list|,
name|misses
argument_list|,
name|nearmisses
argument_list|,
name|bigmisses
argument_list|,
operator|(
name|hits
operator|+
name|bigmisses
operator|+
name|nearmisses
condition|?
name|hits
operator|*
literal|100
operator|/
operator|(
name|hits
operator|+
name|bigmisses
operator|+
name|nearmisses
operator|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"# %-20s referenced\thits\n"
argument_list|,
literal|"directory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lst_Open
argument_list|(
name|openDirectories
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|openDirectories
argument_list|)
operator|)
operator|!=
name|NILLNODE
condition|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"# %-20s %10d\t%4d\n"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|refCount
argument_list|,
name|p
operator|->
name|hits
argument_list|)
expr_stmt|;
block|}
name|Lst_Close
argument_list|(
name|openDirectories
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|DirPrintDir
parameter_list|(
name|p
parameter_list|)
name|Path
modifier|*
name|p
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|Dir_PrintPath
parameter_list|(
name|path
parameter_list|)
name|Lst
name|path
decl_stmt|;
block|{
name|Lst_ForEach
argument_list|(
name|path
argument_list|,
name|DirPrintDir
argument_list|,
operator|(
name|ClientData
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

