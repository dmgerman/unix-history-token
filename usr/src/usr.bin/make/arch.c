begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)arch.c	8.3 (Berkeley) 4/28/95"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*-  * arch.c --  *	Functions to manipulate libraries, archives and their members.  *  *	Once again, cacheing/hashing comes into play in the manipulation  * of archives. The first time an archive is referenced, all of its members'  * headers are read and hashed and the archive closed again. All hashed  * archives are kept on a list which is searched each time an archive member  * is referenced.  *  * The interface to this module is:  *	Arch_ParseArchive   	Given an archive specification, return a list  *	    	  	    	of GNode's, one for each member in the spec.  *	    	  	    	FAILURE is returned if the specification is  *	    	  	    	invalid for some reason.  *  *	Arch_Touch	    	Alter the modification time of the archive  *	    	  	    	member described by the given node to be  *	    	  	    	the current time.  *  *	Arch_TouchLib	    	Update the modification time of the library  *	    	  	    	described by the given node. This is special  *	    	  	    	because it also updates the modification time  *	    	  	    	of the library's table of contents.  *  *	Arch_MTime	    	Find the modification time of a member of  *	    	  	    	an archive *in the archive*. The time is also  *	    	  	    	placed in the member's GNode. Returns the  *	    	  	    	modification time.  *  *	Arch_MemTime	    	Find the modification time of a member of  *	    	  	    	an archive. Called when the member doesn't  *	    	  	    	already exist. Looks in the archive for the  *	    	  	    	modification time. Returns the modification  *	    	  	    	time.  *  *	Arch_FindLib	    	Search for a library along a path. The  *	    	  	    	library name in the GNode should be in  *	    	  	    	-l<name> format.  *  *	Arch_LibOODate	    	Special function to decide if a library node  *	    	  	    	is out-of-date.  *  *	Arch_Init 	    	Initialize this module.  *  *	Arch_End 	    	Cleanup this module.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_include
include|#
directive|include
file|<ranlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_decl_stmt
specifier|static
name|Lst
name|archives
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lst of archives we've already examined */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Arch
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of archive */
name|Hash_Table
name|members
decl_stmt|;
comment|/* All the members of the archive described 			       * by<name, struct ar_hdr *> key/value pairs */
block|}
name|Arch
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|ArchFindArchive
name|__P
argument_list|(
operator|(
name|ClientData
operator|,
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ArchFree
name|__P
argument_list|(
operator|(
name|ClientData
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ar_hdr
modifier|*
name|ArchStatMember
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|Boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|ArchFindMember
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|ar_hdr
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ArchFree --  *	Free memory used by an archive  *  * Results:  *	None.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ArchFree
parameter_list|(
name|ap
parameter_list|)
name|ClientData
name|ap
decl_stmt|;
block|{
name|Arch
modifier|*
name|a
init|=
operator|(
name|Arch
operator|*
operator|)
name|ap
decl_stmt|;
name|Hash_Search
name|search
decl_stmt|;
name|Hash_Entry
modifier|*
name|entry
decl_stmt|;
comment|/* Free memory from hash entries */
for|for
control|(
name|entry
operator|=
name|Hash_EnumFirst
argument_list|(
operator|&
name|a
operator|->
name|members
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|entry
operator|!=
operator|(
name|Hash_Entry
operator|*
operator|)
name|NULL
condition|;
name|entry
operator|=
name|Hash_EnumNext
argument_list|(
operator|&
name|search
argument_list|)
control|)
name|free
argument_list|(
operator|(
name|Address
operator|)
name|Hash_GetValue
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
operator|->
name|name
argument_list|)
expr_stmt|;
name|Hash_DeleteTable
argument_list|(
operator|&
name|a
operator|->
name|members
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|Address
operator|)
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_ParseArchive --  *	Parse the archive specification in the given line and find/create  *	the nodes for the specified archive members, placing their nodes  *	on the given list.  *  * Results:  *	SUCCESS if it was a valid specification. The linePtr is updated  *	to point to the first non-space after the archive spec. The  *	nodes for the members are placed on the given list.  *  * Side Effects:  *	Some nodes may be created. The given list is extended.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|ReturnStatus
name|Arch_ParseArchive
parameter_list|(
name|linePtr
parameter_list|,
name|nodeLst
parameter_list|,
name|ctxt
parameter_list|)
name|char
modifier|*
modifier|*
name|linePtr
decl_stmt|;
comment|/* Pointer to start of specification */
name|Lst
name|nodeLst
decl_stmt|;
comment|/* Lst on which to place the nodes */
name|GNode
modifier|*
name|ctxt
decl_stmt|;
comment|/* Context in which to expand variables */
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Pointer into line */
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* New node */
name|char
modifier|*
name|libName
decl_stmt|;
comment|/* Library-part of specification */
name|char
modifier|*
name|memName
decl_stmt|;
comment|/* Member-part of specification */
name|char
name|nameBuf
index|[
name|MAKE_BSIZE
index|]
decl_stmt|;
comment|/* temporary place for node name */
name|char
name|saveChar
decl_stmt|;
comment|/* Ending delimiter of member-name */
name|Boolean
name|subLibName
decl_stmt|;
comment|/* TRUE if libName should have/had 				     * variable substitution performed on it */
name|libName
operator|=
operator|*
name|linePtr
expr_stmt|;
name|subLibName
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|libName
init|;
operator|*
name|cp
operator|!=
literal|'('
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
comment|/* 	     * Variable spec, so call the Var module to parse the puppy 	     * so we can safely advance beyond it... 	     */
name|int
name|length
decl_stmt|;
name|Boolean
name|freeIt
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|Var_Parse
argument_list|(
name|cp
argument_list|,
name|ctxt
argument_list|,
name|TRUE
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|var_Error
condition|)
block|{
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
else|else
block|{
name|subLibName
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|freeIt
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|length
operator|-
literal|1
expr_stmt|;
block|}
block|}
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|subLibName
condition|)
block|{
name|libName
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|libName
argument_list|,
name|ctxt
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 	 * First skip to the start of the member's name, mark that 	 * place and skip to the end of it (either white-space or 	 * a close paren). 	 */
name|Boolean
name|doSubst
init|=
name|FALSE
decl_stmt|;
comment|/* TRUE if need to substitute in memName */
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
literal|')'
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|memName
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
literal|')'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
comment|/* 		 * Variable spec, so call the Var module to parse the puppy 		 * so we can safely advance beyond it... 		 */
name|int
name|length
decl_stmt|;
name|Boolean
name|freeIt
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|Var_Parse
argument_list|(
name|cp
argument_list|,
name|ctxt
argument_list|,
name|TRUE
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|var_Error
condition|)
block|{
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
else|else
block|{
name|doSubst
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|freeIt
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|length
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * If the specification ends without a closing parenthesis, 	 * chances are there's something wrong (like a missing backslash), 	 * so it's better to return failure than allow such things to happen 	 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"No closing parenthesis in archive specification\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
comment|/* 	 * If we didn't move anywhere, we must be done 	 */
if|if
condition|(
name|cp
operator|==
name|memName
condition|)
block|{
break|break;
block|}
name|saveChar
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * XXX: This should be taken care of intelligently by 	 * SuffExpandChildren, both for the archive and the member portions. 	 */
comment|/* 	 * If member contains variables, try and substitute for them. 	 * This will slow down archive specs with dynamic sources, of course, 	 * since we'll be (non-)substituting them three times, but them's 	 * the breaks -- we need to do this since SuffExpandChildren calls 	 * us, otherwise we could assume the thing would be taken care of 	 * later. 	 */
if|if
condition|(
name|doSubst
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|sacrifice
decl_stmt|;
name|char
modifier|*
name|oldMemName
init|=
name|memName
decl_stmt|;
name|memName
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|memName
argument_list|,
name|ctxt
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	     * Now form an archive spec and recurse to deal with nested 	     * variables and multi-word variable values.... The results 	     * are just placed at the end of the nodeLst we're returning. 	     */
name|buf
operator|=
name|sacrifice
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|memName
argument_list|)
operator|+
name|strlen
argument_list|(
name|libName
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s(%s)"
argument_list|,
name|libName
argument_list|,
name|memName
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|memName
argument_list|,
literal|'$'
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|memName
argument_list|,
name|oldMemName
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Must contain dynamic sources, so we can't deal with it now. 		 * Just create an ARCHV node for the thing and let 		 * SuffExpandChildren handle it... 		 */
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|buf
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|==
name|NILGNODE
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
else|else
block|{
name|gn
operator|->
name|type
operator||=
name|OP_ARCHV
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|nodeLst
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Arch_ParseArchive
argument_list|(
operator|&
name|sacrifice
argument_list|,
name|nodeLst
argument_list|,
name|ctxt
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
comment|/* 		 * Error in nested call -- free buffer and return FAILURE 		 * ourselves. 		 */
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
comment|/* 	     * Free buffer and continue with our work. 	     */
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Dir_HasWildcards
argument_list|(
name|memName
argument_list|)
condition|)
block|{
name|Lst
name|members
init|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
decl_stmt|;
name|char
modifier|*
name|member
decl_stmt|;
name|Dir_Expand
argument_list|(
name|memName
argument_list|,
name|dirSearchPath
argument_list|,
name|members
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|members
argument_list|)
condition|)
block|{
name|member
operator|=
operator|(
name|char
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|members
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|nameBuf
argument_list|,
literal|"%s(%s)"
argument_list|,
name|libName
argument_list|,
name|member
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|nameBuf
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|==
name|NILGNODE
condition|)
block|{
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
else|else
block|{
comment|/* 		     * We've found the node, but have to make sure the rest of 		     * the world knows it's an archive member, without having 		     * to constantly check for parentheses, so we type the 		     * thing with the OP_ARCHV bit before we place it on the 		     * end of the provided list. 		     */
name|gn
operator|->
name|type
operator||=
name|OP_ARCHV
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|nodeLst
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
name|Lst_Destroy
argument_list|(
name|members
argument_list|,
name|NOFREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|nameBuf
argument_list|,
literal|"%s(%s)"
argument_list|,
name|libName
argument_list|,
name|memName
argument_list|)
expr_stmt|;
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|nameBuf
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|==
name|NILGNODE
condition|)
block|{
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * We've found the node, but have to make sure the rest of the 		 * world knows it's an archive member, without having to 		 * constantly check for parentheses, so we type the thing with 		 * the OP_ARCHV bit before we place it on the end of the 		 * provided list. 		 */
name|gn
operator|->
name|type
operator||=
name|OP_ARCHV
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|nodeLst
argument_list|,
operator|(
name|ClientData
operator|)
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|doSubst
condition|)
block|{
name|free
argument_list|(
name|memName
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
name|saveChar
expr_stmt|;
block|}
comment|/*      * If substituted libName, free it now, since we need it no longer.      */
if|if
condition|(
name|subLibName
condition|)
block|{
name|free
argument_list|(
name|libName
argument_list|)
expr_stmt|;
block|}
comment|/*      * We promised the pointer would be set up at the next non-space, so      * we must advance cp there before setting *linePtr... (note that on      * entrance to the loop, cp is guaranteed to point at a ')')      */
do|do
block|{
name|cp
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
do|;
operator|*
name|linePtr
operator|=
name|cp
expr_stmt|;
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ArchFindArchive --  *	See if the given archive is the one we are looking for. Called  *	From ArchStatMember and ArchFindMember via Lst_Find.  *  * Results:  *	0 if it is, non-zero if it isn't.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ArchFindArchive
parameter_list|(
name|ar
parameter_list|,
name|archName
parameter_list|)
name|ClientData
name|ar
decl_stmt|;
comment|/* Current list element */
name|ClientData
name|archName
decl_stmt|;
comment|/* Name we want */
block|{
return|return
operator|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|archName
argument_list|,
operator|(
operator|(
name|Arch
operator|*
operator|)
name|ar
operator|)
operator|->
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ArchStatMember --  *	Locate a member of an archive, given the path of the archive and  *	the path of the desired member.  *  * Results:  *	A pointer to the current struct ar_hdr structure for the member. Note  *	That no position is returned, so this is not useful for touching  *	archive members. This is mostly because we have no assurances that  *	The archive will remain constant after we read all the headers, so  *	there's not much point in remembering the position...  *  * Side Effects:  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|struct
name|ar_hdr
modifier|*
name|ArchStatMember
parameter_list|(
name|archive
parameter_list|,
name|member
parameter_list|,
name|hash
parameter_list|)
name|char
modifier|*
name|archive
decl_stmt|;
comment|/* Path to the archive */
name|char
modifier|*
name|member
decl_stmt|;
comment|/* Name of member. If it is a path, only the 			       * last component is used. */
name|Boolean
name|hash
decl_stmt|;
comment|/* TRUE if archive should be hashed if not     			       * already so. */
block|{
define|#
directive|define
name|AR_MAX_NAME_LEN
value|(sizeof(arh.ar_name)-1)
name|FILE
modifier|*
name|arch
decl_stmt|;
comment|/* Stream to archive */
name|int
name|size
decl_stmt|;
comment|/* Size of archive member */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Useful character pointer */
name|char
name|magic
index|[
name|SARMAG
index|]
decl_stmt|;
name|LstNode
name|ln
decl_stmt|;
comment|/* Lst member containing archive descriptor */
name|Arch
modifier|*
name|ar
decl_stmt|;
comment|/* Archive descriptor */
name|Hash_Entry
modifier|*
name|he
decl_stmt|;
comment|/* Entry containing member's description */
name|struct
name|ar_hdr
name|arh
decl_stmt|;
comment|/* archive-member header for reading archive */
name|char
name|memName
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Current member name while hashing. */
comment|/*      * Because of space constraints and similar things, files are archived      * using their final path components, not the entire thing, so we need      * to point 'member' to the final component, if there is one, to make      * the comparisons easier...      */
name|cp
operator|=
name|strrchr
argument_list|(
name|member
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|member
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
name|ln
operator|=
name|Lst_Find
argument_list|(
name|archives
argument_list|,
operator|(
name|ClientData
operator|)
name|archive
argument_list|,
name|ArchFindArchive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NILLNODE
condition|)
block|{
name|ar
operator|=
operator|(
name|Arch
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|he
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|ar
operator|->
name|members
argument_list|,
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|he
operator|!=
operator|(
name|Hash_Entry
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|Hash_GetValue
argument_list|(
name|he
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* Try truncated name */
name|char
name|copy
index|[
name|AR_MAX_NAME_LEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|member
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|AR_MAX_NAME_LEN
condition|)
block|{
name|len
operator|=
name|AR_MAX_NAME_LEN
expr_stmt|;
name|strncpy
argument_list|(
name|copy
argument_list|,
name|member
argument_list|,
name|AR_MAX_NAME_LEN
argument_list|)
expr_stmt|;
name|copy
index|[
name|AR_MAX_NAME_LEN
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|he
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|ar
operator|->
name|members
argument_list|,
name|copy
argument_list|)
condition|)
return|return
operator|(
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|Hash_GetValue
argument_list|(
name|he
argument_list|)
operator|)
return|;
return|return
operator|(
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|hash
condition|)
block|{
comment|/* 	 * Caller doesn't want the thing hashed, just use ArchFindMember 	 * to read the header for the member out and close down the stream 	 * again. Since the archive is not to be hashed, we assume there's 	 * no need to allocate extra room for the header we're returning, 	 * so just declare it static. 	 */
specifier|static
name|struct
name|ar_hdr
name|sarh
decl_stmt|;
name|arch
operator|=
name|ArchFindMember
argument_list|(
name|archive
argument_list|,
name|member
argument_list|,
operator|&
name|sarh
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|sarh
operator|)
return|;
block|}
block|}
comment|/*      * We don't have this archive on the list yet, so we want to find out      * everything that's in it and cache it so we can get at it quickly.      */
name|arch
operator|=
name|fopen
argument_list|(
name|archive
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
comment|/*      * We use the ARMAG string to make sure this is an archive we      * can handle...      */
if|if
condition|(
operator|(
name|fread
argument_list|(
name|magic
argument_list|,
name|SARMAG
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
literal|1
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|magic
argument_list|,
name|ARMAG
argument_list|,
name|SARMAG
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|ar
operator|=
operator|(
name|Arch
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Arch
argument_list|)
argument_list|)
expr_stmt|;
name|ar
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|archive
argument_list|)
expr_stmt|;
name|Hash_InitTable
argument_list|(
operator|&
name|ar
operator|->
name|members
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memName
index|[
name|AR_MAX_NAME_LEN
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|arh
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|arh
operator|.
name|ar_fmag
argument_list|,
name|ARFMAG
argument_list|,
sizeof|sizeof
argument_list|(
name|arh
operator|.
name|ar_fmag
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				  * The header is bogus, so the archive is bad 				  * and there's no way we can recover... 				  */
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
name|Hash_DeleteTable
argument_list|(
operator|&
name|ar
operator|->
name|members
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|Address
operator|)
name|ar
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|memName
argument_list|,
name|arh
operator|.
name|ar_name
argument_list|,
sizeof|sizeof
argument_list|(
name|arh
operator|.
name|ar_name
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
operator|&
name|memName
index|[
name|AR_MAX_NAME_LEN
index|]
init|;
operator|*
name|cp
operator|==
literal|' '
condition|;
name|cp
operator|--
control|)
block|{
continue|continue;
block|}
name|cp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|AR_EFMT1
comment|/* 	     * BSD 4.4 extended AR format: #1/<namelen>, with name as the 	     * first<namelen> bytes of the file 	     */
if|if
condition|(
name|strncmp
argument_list|(
name|memName
argument_list|,
name|AR_EFMT1
argument_list|,
sizeof|sizeof
argument_list|(
name|AR_EFMT1
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|isdigit
argument_list|(
name|memName
index|[
sizeof|sizeof
argument_list|(
name|AR_EFMT1
argument_list|)
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|elen
init|=
name|atoi
argument_list|(
operator|&
name|memName
index|[
sizeof|sizeof
argument_list|(
name|AR_EFMT1
argument_list|)
operator|-
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|elen
operator|>
name|MAXPATHLEN
condition|)
block|{
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
name|Hash_DeleteTable
argument_list|(
operator|&
name|ar
operator|->
name|members
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|Address
operator|)
name|ar
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|memName
argument_list|,
name|elen
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
name|Hash_DeleteTable
argument_list|(
operator|&
name|ar
operator|->
name|members
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|Address
operator|)
name|ar
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|memName
index|[
name|elen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fseek
argument_list|(
name|arch
argument_list|,
operator|-
name|elen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|ARCH
argument_list|)
operator|||
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ArchStat: Extended format entry for %s\n"
argument_list|,
name|memName
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|he
operator|=
name|Hash_CreateEntry
argument_list|(
operator|&
name|ar
operator|->
name|members
argument_list|,
name|memName
argument_list|,
operator|(
name|Boolean
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Hash_SetValue
argument_list|(
name|he
argument_list|,
operator|(
name|ClientData
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|Address
operator|)
name|Hash_GetValue
argument_list|(
name|he
argument_list|)
argument_list|,
operator|(
name|Address
operator|)
operator|&
name|arh
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We need to advance the stream's pointer to the start of the 	 * next header. Files are padded with newlines to an even-byte 	 * boundary, so we need to extract the size of the file from the 	 * 'size' field of the header and round it up during the seek. 	 */
name|arh
operator|.
name|ar_size
index|[
sizeof|sizeof
argument_list|(
name|arh
operator|.
name|ar_size
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|size
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|arh
operator|.
name|ar_size
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|arch
argument_list|,
operator|(
name|size
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|archives
argument_list|,
operator|(
name|ClientData
operator|)
name|ar
argument_list|)
expr_stmt|;
comment|/*      * Now that the archive has been read and cached, we can look into      * the hash table to find the desired member's header.      */
name|he
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|ar
operator|->
name|members
argument_list|,
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|he
operator|!=
operator|(
name|Hash_Entry
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|Hash_GetValue
argument_list|(
name|he
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ArchFindMember --  *	Locate a member of an archive, given the path of the archive and  *	the path of the desired member. If the archive is to be modified,  *	the mode should be "r+", if not, it should be "r".  *  * Results:  *	An FILE *, opened for reading and writing, positioned at the  *	start of the member's struct ar_hdr, or NULL if the member was  *	nonexistent. The current struct ar_hdr for member.  *  * Side Effects:  *	The passed struct ar_hdr structure is filled in.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|ArchFindMember
parameter_list|(
name|archive
parameter_list|,
name|member
parameter_list|,
name|arhPtr
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|archive
decl_stmt|;
comment|/* Path to the archive */
name|char
modifier|*
name|member
decl_stmt|;
comment|/* Name of member. If it is a path, only the 			       * last component is used. */
name|struct
name|ar_hdr
modifier|*
name|arhPtr
decl_stmt|;
comment|/* Pointer to header structure to be filled in */
name|char
modifier|*
name|mode
decl_stmt|;
comment|/* The mode for opening the stream */
block|{
name|FILE
modifier|*
name|arch
decl_stmt|;
comment|/* Stream to archive */
name|int
name|size
decl_stmt|;
comment|/* Size of archive member */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Useful character pointer */
name|char
name|magic
index|[
name|SARMAG
index|]
decl_stmt|;
name|int
name|len
decl_stmt|,
name|tlen
decl_stmt|;
name|arch
operator|=
name|fopen
argument_list|(
name|archive
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
operator|(
name|FILE
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
comment|/*      * We use the ARMAG string to make sure this is an archive we      * can handle...      */
if|if
condition|(
operator|(
name|fread
argument_list|(
name|magic
argument_list|,
name|SARMAG
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
literal|1
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|magic
argument_list|,
name|ARMAG
argument_list|,
name|SARMAG
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|FILE
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
comment|/*      * Because of space constraints and similar things, files are archived      * using their final path components, not the entire thing, so we need      * to point 'member' to the final component, if there is one, to make      * the comparisons easier...      */
name|cp
operator|=
name|strrchr
argument_list|(
name|member
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|member
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
name|len
operator|=
name|tlen
operator|=
name|strlen
argument_list|(
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|arhPtr
operator|->
name|ar_name
argument_list|)
condition|)
block|{
name|tlen
operator|=
sizeof|sizeof
argument_list|(
name|arhPtr
operator|->
name|ar_name
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arhPtr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|arhPtr
operator|->
name|ar_fmag
argument_list|,
name|ARFMAG
argument_list|,
sizeof|sizeof
argument_list|(
name|arhPtr
operator|->
name|ar_fmag
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 	      * The header is bogus, so the archive is bad 	      * and there's no way we can recover... 	      */
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|FILE
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|member
argument_list|,
name|arhPtr
operator|->
name|ar_name
argument_list|,
name|tlen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 	     * If the member's name doesn't take up the entire 'name' field, 	     * we have to be careful of matching prefixes. Names are space- 	     * padded to the right, so if the character in 'name' at the end 	     * of the matched string is anything but a space, this isn't the 	     * member we sought. 	     */
if|if
condition|(
name|tlen
operator|!=
sizeof|sizeof
argument_list|(
name|arhPtr
operator|->
name|ar_name
argument_list|)
operator|&&
name|arhPtr
operator|->
name|ar_name
index|[
name|tlen
index|]
operator|!=
literal|' '
condition|)
block|{
goto|goto
name|skip
goto|;
block|}
else|else
block|{
comment|/* 		 * To make life easier, we reposition the file at the start 		 * of the header we just read before we return the stream. 		 * In a more general situation, it might be better to leave 		 * the file at the actual member, rather than its header, but 		 * not here... 		 */
name|fseek
argument_list|(
name|arch
argument_list|,
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|arch
operator|)
return|;
block|}
block|}
elseif|else
ifdef|#
directive|ifdef
name|AR_EFMT1
comment|/* 		 * BSD 4.4 extended AR format: #1/<namelen>, with name as the 		 * first<namelen> bytes of the file 		 */
if|if
condition|(
name|strncmp
argument_list|(
name|arhPtr
operator|->
name|ar_name
argument_list|,
name|AR_EFMT1
argument_list|,
sizeof|sizeof
argument_list|(
name|AR_EFMT1
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|isdigit
argument_list|(
name|arhPtr
operator|->
name|ar_name
index|[
sizeof|sizeof
argument_list|(
name|AR_EFMT1
argument_list|)
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|elen
init|=
name|atoi
argument_list|(
operator|&
name|arhPtr
operator|->
name|ar_name
index|[
sizeof|sizeof
argument_list|(
name|AR_EFMT1
argument_list|)
operator|-
literal|1
index|]
argument_list|)
decl_stmt|;
name|char
name|ename
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|elen
operator|>
name|MAXPATHLEN
condition|)
block|{
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|ename
argument_list|,
name|elen
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ename
index|[
name|elen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|ARCH
argument_list|)
operator|||
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ArchFind: Extended format entry for %s\n"
argument_list|,
name|ename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|ename
argument_list|,
name|member
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Found as extended name */
name|fseek
argument_list|(
name|arch
argument_list|,
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|-
name|elen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|arch
operator|)
return|;
block|}
name|fseek
argument_list|(
name|arch
argument_list|,
operator|-
name|elen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
else|else
endif|#
directive|endif
block|{
name|skip
label|:
comment|/* 	     * This isn't the member we're after, so we need to advance the 	     * stream's pointer to the start of the next header. Files are 	     * padded with newlines to an even-byte boundary, so we need to 	     * extract the size of the file from the 'size' field of the 	     * header and round it up during the seek. 	     */
name|arhPtr
operator|->
name|ar_size
index|[
sizeof|sizeof
argument_list|(
name|arhPtr
operator|->
name|ar_size
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|size
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|arhPtr
operator|->
name|ar_size
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|arch
argument_list|,
operator|(
name|size
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * We've looked everywhere, but the member is not to be found. Close the      * archive and return NULL -- an error.      */
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|FILE
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_Touch --  *	Touch a member of an archive.  *  * Results:  *	The 'time' field of the member's header is updated.  *  * Side Effects:  *	The modification time of the entire archive is also changed.  *	For a library, this could necessitate the re-ranlib'ing of the  *	whole thing.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Arch_Touch
parameter_list|(
name|gn
parameter_list|)
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* Node of member to touch */
block|{
name|FILE
modifier|*
name|arch
decl_stmt|;
comment|/* Stream open to archive, positioned properly */
name|struct
name|ar_hdr
name|arh
decl_stmt|;
comment|/* Current header describing member */
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|arch
operator|=
name|ArchFindMember
argument_list|(
name|Var_Value
argument_list|(
name|ARCHIVE
argument_list|,
name|gn
argument_list|,
operator|&
name|p1
argument_list|)
argument_list|,
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|gn
argument_list|,
operator|&
name|p2
argument_list|)
argument_list|,
operator|&
name|arh
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
condition|)
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
condition|)
name|free
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|arh
operator|.
name|ar_date
argument_list|,
literal|"%-12ld"
argument_list|,
operator|(
name|long
operator|)
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|!=
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|arh
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_TouchLib --  *	Given a node which represents a library, touch the thing, making  *	sure that the table of contents also is touched.  *  * Results:  *	None.  *  * Side Effects:  *	Both the modification time of the library and of the RANLIBMAG  *	member are set to 'now'.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Arch_TouchLib
parameter_list|(
name|gn
parameter_list|)
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* The node of the library to touch */
block|{
name|FILE
modifier|*
name|arch
decl_stmt|;
comment|/* Stream open to archive */
name|struct
name|ar_hdr
name|arh
decl_stmt|;
comment|/* Header describing table of contents */
name|struct
name|timeval
name|times
index|[
literal|2
index|]
decl_stmt|;
comment|/* Times for utimes() call */
name|arch
operator|=
name|ArchFindMember
argument_list|(
name|gn
operator|->
name|path
argument_list|,
name|RANLIBMAG
argument_list|,
operator|&
name|arh
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|arh
operator|.
name|ar_date
argument_list|,
literal|"%-12ld"
argument_list|,
operator|(
name|long
operator|)
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|!=
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|arh
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|arch
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|arch
argument_list|)
expr_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|times
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|now
expr_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|times
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|utimes
argument_list|(
name|gn
operator|->
name|path
argument_list|,
name|times
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_MTime --  *	Return the modification time of a member of an archive.  *  * Results:  *	The modification time (seconds).  *  * Side Effects:  *	The mtime field of the given node is filled in with the value  *	returned by the function.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Arch_MTime
parameter_list|(
name|gn
parameter_list|)
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* Node describing archive member */
block|{
name|struct
name|ar_hdr
modifier|*
name|arhPtr
decl_stmt|;
comment|/* Header of desired member */
name|int
name|modTime
decl_stmt|;
comment|/* Modification time as an integer */
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|arhPtr
operator|=
name|ArchStatMember
argument_list|(
name|Var_Value
argument_list|(
name|ARCHIVE
argument_list|,
name|gn
argument_list|,
operator|&
name|p1
argument_list|)
argument_list|,
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|gn
argument_list|,
operator|&
name|p2
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
condition|)
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
condition|)
name|free
argument_list|(
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|arhPtr
operator|!=
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|NULL
condition|)
block|{
name|modTime
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|arhPtr
operator|->
name|ar_date
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|modTime
operator|=
literal|0
expr_stmt|;
block|}
name|gn
operator|->
name|mtime
operator|=
name|modTime
expr_stmt|;
return|return
operator|(
name|modTime
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_MemMTime --  *	Given a non-existent archive member's node, get its modification  *	time from its archived form, if it exists.  *  * Results:  *	The modification time.  *  * Side Effects:  *	The mtime field is filled in.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Arch_MemMTime
parameter_list|(
name|gn
parameter_list|)
name|GNode
modifier|*
name|gn
decl_stmt|;
block|{
name|LstNode
name|ln
decl_stmt|;
name|GNode
modifier|*
name|pgn
decl_stmt|;
name|char
modifier|*
name|nameStart
decl_stmt|,
modifier|*
name|nameEnd
decl_stmt|;
if|if
condition|(
name|Lst_Open
argument_list|(
name|gn
operator|->
name|parents
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|gn
operator|->
name|mtime
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|gn
operator|->
name|parents
argument_list|)
operator|)
operator|!=
name|NILLNODE
condition|)
block|{
name|pgn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|pgn
operator|->
name|type
operator|&
name|OP_ARCHV
condition|)
block|{
comment|/* 	     * If the parent is an archive specification and is being made 	     * and its member's name matches the name of the node we were 	     * given, record the modification time of the parent in the 	     * child. We keep searching its parents in case some other 	     * parent requires this child to exist... 	     */
name|nameStart
operator|=
name|strchr
argument_list|(
name|pgn
operator|->
name|name
argument_list|,
literal|'('
argument_list|)
operator|+
literal|1
expr_stmt|;
name|nameEnd
operator|=
name|strchr
argument_list|(
name|nameStart
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pgn
operator|->
name|make
operator|&&
name|strncmp
argument_list|(
name|nameStart
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|nameEnd
operator|-
name|nameStart
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gn
operator|->
name|mtime
operator|=
name|Arch_MTime
argument_list|(
name|pgn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pgn
operator|->
name|make
condition|)
block|{
comment|/* 	     * Something which isn't a library depends on the existence of 	     * this target, so it needs to exist. 	     */
name|gn
operator|->
name|mtime
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|Lst_Close
argument_list|(
name|gn
operator|->
name|parents
argument_list|)
expr_stmt|;
return|return
operator|(
name|gn
operator|->
name|mtime
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_FindLib --  *	Search for a library along the given search path.   *  * Results:  *	None.  *  * Side Effects:  *	The node's 'path' field is set to the found path (including the  *	actual file name, not -l...). If the system can handle the -L  *	flag when linking (or we cannot find the library), we assume that  *	the user has placed the .LIBRARIES variable in the final linking  *	command (or the linker will know where to find it) and set the  *	TARGET variable for this node to be the node's name. Otherwise,  *	we set the TARGET variable to be the full path of the library,  *	as returned by Dir_FindFile.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Arch_FindLib
parameter_list|(
name|gn
parameter_list|,
name|path
parameter_list|)
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* Node of library to find */
name|Lst
name|path
decl_stmt|;
comment|/* Search path */
block|{
name|char
modifier|*
name|libName
decl_stmt|;
comment|/* file name for archive */
name|libName
operator|=
operator|(
name|char
operator|*
operator|)
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|gn
operator|->
name|name
argument_list|)
operator|+
literal|6
operator|-
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|libName
argument_list|,
literal|"lib%s.a"
argument_list|,
operator|&
name|gn
operator|->
name|name
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gn
operator|->
name|path
operator|=
name|Dir_FindFile
argument_list|(
name|libName
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|libName
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LIBRARIES
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
argument_list|)
expr_stmt|;
else|#
directive|else
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|gn
operator|->
name|path
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|?
name|gn
operator|->
name|name
else|:
name|gn
operator|->
name|path
argument_list|,
name|gn
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LIBRARIES
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_LibOODate --  *	Decide if a node with the OP_LIB attribute is out-of-date. Called  *	from Make_OODate to make its life easier.  *  *	There are several ways for a library to be out-of-date that are  *	not available to ordinary files. In addition, there are ways  *	that are open to regular files that are not available to  *	libraries. A library that is only used as a source is never  *	considered out-of-date by itself. This does not preclude the  *	library's modification time from making its parent be out-of-date.  *	A library will be considered out-of-date for any of these reasons,  *	given that it is a target on a dependency line somewhere:  *	    Its modification time is less than that of one of its  *	    	  sources (gn->mtime< gn->cmtime).  *	    Its modification time is greater than the time at which the  *	    	  make began (i.e. it's been modified in the course  *	    	  of the make, probably by archiving).  *	    The modification time of one of its sources is greater than  *		  the one of its RANLIBMAG member (i.e. its table of contents  *	    	  is out-of-date). We don't compare of the archive time  *		  vs. TOC time because they can be too close. In my  *		  opinion we should not bother with the TOC at all since  *		  this is used by 'ar' rules that affect the data contents  *		  of the archive, not by ranlib rules, which affect the  *		  TOC.   *  * Results:  *	TRUE if the library is out-of-date. FALSE otherwise.  *  * Side Effects:  *	The library will be hashed if it hasn't been already.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Arch_LibOODate
parameter_list|(
name|gn
parameter_list|)
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* The library's graph node */
block|{
name|Boolean
name|oodate
decl_stmt|;
if|if
condition|(
name|OP_NOP
argument_list|(
name|gn
operator|->
name|type
argument_list|)
operator|&&
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|children
argument_list|)
condition|)
block|{
name|oodate
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|gn
operator|->
name|mtime
operator|>
name|now
operator|)
operator|||
operator|(
name|gn
operator|->
name|mtime
operator|<
name|gn
operator|->
name|cmtime
operator|)
condition|)
block|{
name|oodate
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ar_hdr
modifier|*
name|arhPtr
decl_stmt|;
comment|/* Header for __.SYMDEF */
name|int
name|modTimeTOC
decl_stmt|;
comment|/* The table-of-contents's mod time */
name|arhPtr
operator|=
name|ArchStatMember
argument_list|(
name|gn
operator|->
name|path
argument_list|,
name|RANLIBMAG
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|arhPtr
operator|!=
operator|(
expr|struct
name|ar_hdr
operator|*
operator|)
name|NULL
condition|)
block|{
name|modTimeTOC
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|arhPtr
operator|->
name|ar_date
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|ARCH
argument_list|)
operator|||
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s modified %s..."
argument_list|,
name|RANLIBMAG
argument_list|,
name|Targ_FmtTime
argument_list|(
name|modTimeTOC
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|oodate
operator|=
operator|(
name|gn
operator|->
name|cmtime
operator|>
name|modTimeTOC
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * A library w/o a table of contents is out-of-date 	     */
if|if
condition|(
name|DEBUG
argument_list|(
name|ARCH
argument_list|)
operator|||
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"No t.o.c...."
argument_list|)
expr_stmt|;
block|}
name|oodate
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|oodate
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_Init --  *	Initialize things for this module.  *  * Results:  *	None.  *  * Side Effects:  *	The 'archives' list is initialized.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Arch_Init
parameter_list|()
block|{
name|archives
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Arch_End --  *	Cleanup things for this module.  *  * Results:  *	None.  *  * Side Effects:  *	The 'archives' list is freed  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Arch_End
parameter_list|()
block|{
name|Lst_Destroy
argument_list|(
name|archives
argument_list|,
name|ArchFree
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

