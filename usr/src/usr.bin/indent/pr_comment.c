begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)pr_comment.c	5.4 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*-  *  *			  Copyright (C) 1976  *				by the  *			  Board of Trustees  *				of the  *			University of Illinois  *  *			 All rights reserved  *  *  * NAME:  *	pr_comment  *  * FUNCTION:  *	This routine takes care of scanning and printing comments.  *  * ALGORITHM:  *	1) Decide where the comment should be aligned, and if lines should  *	   be broken.  *	2) If lines should not be broken and filled, just copy up to end of  *	   comment.  *	3) If lines should be filled, then scan thru input_buffer copying  *	   characters to com_buf.  Remember where the last blank, tab, or  *	   newline was.  When line is filled, print up to last blank and   *	   continue copying.  *  * HISTORY:  *	November 1976	D A Willcox of CAC	Initial coding  *	12/6/76		D A Willcox of CAC	Modification to handle   *						UNIX-style comments  *  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * this routine processes comments.  It makes an attempt to keep comments  * from going over the max line length.  If a line is too long, it moves  * everything from the last blank to the next comment line.  Blanks and  * tabs from the beginning of the input line are removed   */
end_comment

begin_include
include|#
directive|include
file|"indent_globs.h"
end_include

begin_macro
name|pr_comment
argument_list|()
end_macro

begin_block
block|{
name|int
name|now_col
decl_stmt|;
comment|/* column we are in now */
name|int
name|adj_max_col
decl_stmt|;
comment|/* Adjusted max_col for when we decide to 				 * spill comments over the right margin */
name|int
name|col_1_com
decl_stmt|;
comment|/* this comment should not be touched */
name|char
modifier|*
name|last_bl
decl_stmt|;
comment|/* points to the last blank in the output 				 * buffer */
name|char
name|achar
decl_stmt|;
name|char
modifier|*
name|t_ptr
decl_stmt|;
comment|/* used for moving string */
name|int
name|unix_comment
decl_stmt|;
comment|/* tri-state variable used to decide if it 				 * is a unix-style comment. 0 means only 				 * blanks since /*, 1 means regular style 				 * comment, 2 means unix style comment */
name|int
name|break_delim
init|=
name|comment_delimiter_on_blankline
decl_stmt|;
name|int
name|l_just_saw_decl
init|=
name|ps
operator|.
name|just_saw_decl
decl_stmt|;
comment|/*      * int         ps.last_nl = 0;	/* true iff the last significant      * thing weve seen is a newline       */
name|int
name|one_liner
init|=
literal|1
decl_stmt|;
comment|/* true iff this comment is a one-liner */
name|adj_max_col
operator|=
name|max_col
expr_stmt|;
name|ps
operator|.
name|just_saw_decl
operator|=
literal|0
expr_stmt|;
name|last_bl
operator|=
literal|0
expr_stmt|;
comment|/* no blanks found so far */
name|ps
operator|.
name|box_com
operator|=
name|col_1_com
operator|=
name|false
expr_stmt|;
comment|/* at first, assume that we are 					 * not in a boxed comment or some 					 * other comment that should not 					 * be touched */
operator|++
name|ps
operator|.
name|out_coms
expr_stmt|;
comment|/* keep track of number of comments */
name|unix_comment
operator|=
literal|1
expr_stmt|;
comment|/* set flag to let us figure out if there 				 * is a unix-style comment ** DISABLED: 				 * use 0 to reenable this hack! */
comment|/* Figure where to align and how to treat the comment */
if|if
condition|(
name|ps
operator|.
name|col_1
operator|&&
operator|!
name|format_col1_comments
condition|)
block|{
comment|/* if comment starts in 						 * column 1 it should not 						 * be touched */
name|col_1_com
operator|=
name|ps
operator|.
name|box_com
operator|=
name|true
expr_stmt|;
name|ps
operator|.
name|com_col
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'-'
operator|||
operator|*
name|buf_ptr
operator|==
literal|'*'
condition|)
block|{
name|ps
operator|.
name|box_com
operator|=
name|true
expr_stmt|;
comment|/* a comment with a '-' or '*' immediately 				 * after the /* is assumed to be a boxed 				 * comment */
name|col_1_com
operator|=
name|true
expr_stmt|;
name|break_delim
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
comment|/* ps.bl_line&& */
operator|(
name|s_lab
operator|==
name|e_lab
operator|)
operator|&&
operator|(
name|s_code
operator|==
name|e_code
operator|)
condition|)
block|{
comment|/* klg: check only if this line is blank */
comment|/* 	     * If this (*and previous lines are*) blank, dont put comment 	     * way out at left  	     */
name|ps
operator|.
name|com_col
operator|=
operator|(
name|ps
operator|.
name|ind_level
operator|-
name|ps
operator|.
name|unindent_displace
operator|)
operator|*
name|ps
operator|.
name|ind_size
operator|+
literal|1
expr_stmt|;
name|adj_max_col
operator|=
name|block_comment_max_col
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|com_col
operator|<=
literal|1
condition|)
name|ps
operator|.
name|com_col
operator|=
literal|1
operator|+
operator|!
name|format_col1_comments
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|target_col
expr_stmt|;
name|break_delim
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s_code
operator|!=
name|e_code
condition|)
name|target_col
operator|=
name|count_spaces
argument_list|(
name|compute_code_target
argument_list|()
argument_list|,
name|s_code
argument_list|)
expr_stmt|;
else|else
block|{
name|target_col
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|s_lab
operator|!=
name|e_lab
condition|)
name|target_col
operator|=
name|count_spaces
argument_list|(
name|compute_label_target
argument_list|()
argument_list|,
name|s_lab
argument_list|)
expr_stmt|;
block|}
name|ps
operator|.
name|com_col
operator|=
name|ps
operator|.
name|decl_on_line
operator|||
name|ps
operator|.
name|ind_level
operator|==
literal|0
condition|?
name|ps
operator|.
name|decl_com_ind
else|:
name|ps
operator|.
name|com_ind
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|com_col
operator|<
name|target_col
condition|)
name|ps
operator|.
name|com_col
operator|=
operator|(
operator|(
name|target_col
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|com_col
operator|+
literal|24
operator|>
name|adj_max_col
condition|)
name|adj_max_col
operator|=
name|ps
operator|.
name|com_col
operator|+
literal|24
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ps
operator|.
name|box_com
condition|)
block|{
name|buf_ptr
index|[
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|n_comment_delta
operator|=
literal|1
operator|-
name|count_spaces
argument_list|(
literal|1
argument_list|,
name|in_buffer
argument_list|)
expr_stmt|;
name|ps
operator|.
name|comment_delta
operator|=
literal|0
expr_stmt|;
name|buf_ptr
index|[
operator|-
literal|2
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
block|{
name|ps
operator|.
name|n_comment_delta
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|comment_delta
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|buf_ptr
operator|==
literal|' '
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\t'
condition|)
name|buf_ptr
operator|++
expr_stmt|;
block|}
name|ps
operator|.
name|comment_delta
operator|=
literal|0
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* put '/*' into buffer */
operator|*
name|e_com
operator|++
operator|=
literal|'*'
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|!=
literal|' '
operator|&&
operator|!
name|ps
operator|.
name|box_com
condition|)
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_com
operator|=
literal|'\0'
expr_stmt|;
name|now_col
operator|=
name|count_spaces
argument_list|(
name|ps
operator|.
name|com_col
argument_list|,
name|s_com
argument_list|)
expr_stmt|;
comment|/* figure what column we 						 * would be in if we 						 * printed the comment now */
comment|/* Start to copy the comment */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* this loop will go until the comment is 				 * copied */
if|if
condition|(
operator|*
name|buf_ptr
operator|>
literal|040
operator|&&
operator|*
name|buf_ptr
operator|!=
literal|'*'
condition|)
name|ps
operator|.
name|last_nl
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|buf_ptr
condition|)
block|{
comment|/* this checks for various spcl cases */
case|case
literal|014
case|:
comment|/* check for a form feed */
if|if
condition|(
operator|!
name|ps
operator|.
name|box_com
condition|)
block|{
comment|/* in a text comment, break the 					 * line here */
name|ps
operator|.
name|use_ff
operator|=
name|true
expr_stmt|;
comment|/* fix so dump_line uses a form feed */
name|dump_line
argument_list|()
expr_stmt|;
name|last_bl
operator|=
literal|0
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|'*'
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|buf_ptr
operator|==
literal|' '
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\t'
condition|)
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|014
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
if|if
condition|(
name|had_eof
condition|)
block|{
comment|/* check for unexpected eof */
name|printf
argument_list|(
literal|"Unterminated comment\n"
argument_list|)
expr_stmt|;
operator|*
name|e_com
operator|=
literal|'\0'
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|one_liner
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|box_com
operator|||
name|ps
operator|.
name|last_nl
condition|)
block|{
comment|/* if this is a boxed 						 * comment, we dont ignore 						 * the newline */
if|if
condition|(
name|s_com
operator|==
name|e_com
condition|)
block|{
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|e_com
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|ps
operator|.
name|box_com
operator|&&
name|e_com
operator|-
name|s_com
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|break_delim
operator|==
literal|1
operator|&&
name|s_com
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|s_com
index|[
literal|1
index|]
operator|==
literal|'*'
operator|&&
name|s_com
index|[
literal|2
index|]
operator|==
literal|' '
condition|)
block|{
name|char
modifier|*
name|t
init|=
name|e_com
decl_stmt|;
name|break_delim
operator|=
literal|2
expr_stmt|;
name|e_com
operator|=
name|s_com
operator|+
literal|2
expr_stmt|;
operator|*
name|e_com
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blanklines_before_blockcomments
condition|)
name|prefix_blankline_requested
operator|=
literal|1
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|e_com
operator|=
name|t
expr_stmt|;
name|s_com
index|[
literal|0
index|]
operator|=
name|s_com
index|[
literal|1
index|]
operator|=
name|s_com
index|[
literal|2
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|dump_line
argument_list|()
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|dump_line
argument_list|()
expr_stmt|;
name|now_col
operator|=
name|ps
operator|.
name|com_col
expr_stmt|;
block|}
else|else
block|{
name|ps
operator|.
name|last_nl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|unix_comment
operator|!=
literal|1
condition|)
block|{
comment|/* we not are in 						 * unix_style comment */
if|if
condition|(
name|unix_comment
operator|==
literal|0
operator|&&
name|s_code
operator|==
name|e_code
condition|)
block|{
comment|/* 			 * if it is a UNIX-style comment, ignore the 			 * requirement that previous line be blank for 			 * unindention  			 */
name|ps
operator|.
name|com_col
operator|=
operator|(
name|ps
operator|.
name|ind_level
operator|-
name|ps
operator|.
name|unindent_displace
operator|)
operator|*
name|ps
operator|.
name|ind_size
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|com_col
operator|<=
literal|1
condition|)
name|ps
operator|.
name|com_col
operator|=
literal|2
expr_stmt|;
block|}
name|unix_comment
operator|=
literal|2
expr_stmt|;
comment|/* permanently remember that we 					 * are in this type of comment */
name|dump_line
argument_list|()
expr_stmt|;
operator|++
name|line_no
expr_stmt|;
name|now_col
operator|=
name|ps
operator|.
name|com_col
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* 		     * fix so that the star at the start of the line will 		     * line up  		     */
do|do
comment|/* flush leading white space */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
do|while
condition|(
operator|*
name|buf_ptr
operator|==
literal|' '
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\t'
condition|)
do|;
break|break;
block|}
if|if
condition|(
operator|*
operator|(
name|e_com
operator|-
literal|1
operator|)
operator|==
literal|' '
operator|||
operator|*
operator|(
name|e_com
operator|-
literal|1
operator|)
operator|==
literal|'\t'
condition|)
name|last_bl
operator|=
name|e_com
operator|-
literal|1
expr_stmt|;
comment|/* 		 * if there was a space at the end of the last line, 		 * remember where it was  		 */
else|else
block|{
comment|/* otherwise, insert one */
name|last_bl
operator|=
name|e_com
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
operator|++
name|now_col
expr_stmt|;
block|}
block|}
operator|++
name|line_no
expr_stmt|;
comment|/* keep track of input line number */
if|if
condition|(
operator|!
name|ps
operator|.
name|box_com
condition|)
block|{
name|int
name|nstar
init|=
literal|1
decl_stmt|;
do|do
block|{
comment|/* flush any blanks and/or tabs at start 				 * of next line */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'*'
operator|&&
operator|--
name|nstar
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'/'
condition|)
goto|goto
name|end_of_comment
goto|;
block|}
block|}
do|while
condition|(
operator|*
name|buf_ptr
operator|==
literal|' '
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\t'
condition|)
do|;
block|}
elseif|else
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
break|break;
comment|/* end of case for newline */
case|case
literal|'*'
case|:
comment|/* must check for possibility of being at 				 * end of comment */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
comment|/* get to next char after * */
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|unix_comment
operator|==
literal|0
condition|)
comment|/* set flag to show we are not in 					 * unix-style comment */
name|unix_comment
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'/'
condition|)
block|{
comment|/* it is the end!!! */
name|end_of_comment
label|:
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|e_com
operator|-
literal|1
operator|)
operator|!=
literal|' '
operator|&&
operator|!
name|ps
operator|.
name|box_com
condition|)
block|{
comment|/* insure blank before 								 * end */
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
operator|++
name|now_col
expr_stmt|;
block|}
if|if
condition|(
name|break_delim
operator|==
literal|1
operator|&&
operator|!
name|one_liner
operator|&&
name|s_com
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|s_com
index|[
literal|1
index|]
operator|==
literal|'*'
operator|&&
name|s_com
index|[
literal|2
index|]
operator|==
literal|' '
condition|)
block|{
name|char
modifier|*
name|t
init|=
name|e_com
decl_stmt|;
name|break_delim
operator|=
literal|2
expr_stmt|;
name|e_com
operator|=
name|s_com
operator|+
literal|2
expr_stmt|;
operator|*
name|e_com
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blanklines_before_blockcomments
condition|)
name|prefix_blankline_requested
operator|=
literal|1
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|e_com
operator|=
name|t
expr_stmt|;
name|s_com
index|[
literal|0
index|]
operator|=
name|s_com
index|[
literal|1
index|]
operator|=
name|s_com
index|[
literal|2
index|]
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|break_delim
operator|==
literal|2
operator|&&
name|e_com
operator|>
name|s_com
operator|+
literal|3
comment|/* now_col> adj_max_col - 2&& !ps.box_com */
condition|)
block|{
operator|*
name|e_com
operator|=
literal|'\0'
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|now_col
operator|=
name|ps
operator|.
name|com_col
expr_stmt|;
block|}
operator|*
name|e_com
operator|++
operator|=
literal|'*'
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|e_com
operator|=
literal|'\0'
expr_stmt|;
name|ps
operator|.
name|just_saw_decl
operator|=
name|l_just_saw_decl
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* handle isolated '*' */
operator|*
name|e_com
operator|++
operator|=
literal|'*'
expr_stmt|;
operator|++
name|now_col
expr_stmt|;
block|}
break|break;
default|default:
comment|/* we have a random char */
if|if
condition|(
name|unix_comment
operator|==
literal|0
operator|&&
operator|*
name|buf_ptr
operator|!=
literal|' '
operator|&&
operator|*
name|buf_ptr
operator|!=
literal|'\t'
condition|)
name|unix_comment
operator|=
literal|1
expr_stmt|;
comment|/* we are not in unix-style 					 * comment */
operator|*
name|e_com
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|e_com
operator|==
literal|'\t'
condition|)
comment|/* keep track of column */
name|now_col
operator|=
operator|(
operator|(
name|now_col
operator|-
literal|1
operator|)
operator|&
name|tabmask
operator|)
operator|+
name|tabsize
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|e_com
operator|==
literal|'\b'
condition|)
comment|/* this is a backspace */
operator|--
name|now_col
expr_stmt|;
else|else
operator|++
name|now_col
expr_stmt|;
if|if
condition|(
operator|*
name|e_com
operator|==
literal|' '
operator|||
operator|*
name|e_com
operator|==
literal|'\t'
condition|)
name|last_bl
operator|=
name|e_com
expr_stmt|;
comment|/* remember we saw a blank */
operator|++
name|e_com
expr_stmt|;
if|if
condition|(
name|now_col
operator|>
name|adj_max_col
operator|&&
operator|!
name|ps
operator|.
name|box_com
operator|&&
name|unix_comment
operator|==
literal|1
operator|&&
name|e_com
index|[
operator|-
literal|1
index|]
operator|>
literal|' '
condition|)
block|{
comment|/* the comment is too long, it must be broken up */
if|if
condition|(
name|break_delim
operator|==
literal|1
operator|&&
name|s_com
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|s_com
index|[
literal|1
index|]
operator|==
literal|'*'
operator|&&
name|s_com
index|[
literal|2
index|]
operator|==
literal|' '
condition|)
block|{
name|char
modifier|*
name|t
init|=
name|e_com
decl_stmt|;
name|break_delim
operator|=
literal|2
expr_stmt|;
name|e_com
operator|=
name|s_com
operator|+
literal|2
expr_stmt|;
operator|*
name|e_com
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blanklines_before_blockcomments
condition|)
name|prefix_blankline_requested
operator|=
literal|1
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|e_com
operator|=
name|t
expr_stmt|;
name|s_com
index|[
literal|0
index|]
operator|=
name|s_com
index|[
literal|1
index|]
operator|=
name|s_com
index|[
literal|2
index|]
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|last_bl
operator|==
literal|0
condition|)
block|{
comment|/* we have seen no blanks */
name|last_bl
operator|=
name|e_com
expr_stmt|;
comment|/* fake it */
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|e_com
operator|=
literal|'\0'
expr_stmt|;
comment|/* print what we have */
operator|*
name|last_bl
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|last_bl
operator|>
name|s_com
operator|&&
name|last_bl
index|[
operator|-
literal|1
index|]
operator|<
literal|040
condition|)
operator|*
operator|--
name|last_bl
operator|=
literal|0
expr_stmt|;
name|e_com
operator|=
name|last_bl
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* add blanks for continuation */
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
name|t_ptr
operator|=
name|last_bl
operator|+
literal|1
expr_stmt|;
name|last_bl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t_ptr
operator|>=
name|e_com
condition|)
block|{
while|while
condition|(
operator|*
name|t_ptr
operator|==
literal|' '
operator|||
operator|*
name|t_ptr
operator|==
literal|'\t'
condition|)
name|t_ptr
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|t_ptr
operator|!=
literal|'\0'
condition|)
block|{
comment|/* move unprinted part 							 * of comment down in 							 * buffer */
if|if
condition|(
operator|*
name|t_ptr
operator|==
literal|' '
operator|||
operator|*
name|t_ptr
operator|==
literal|'\t'
condition|)
name|last_bl
operator|=
name|e_com
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
operator|*
name|t_ptr
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|e_com
operator|=
literal|'\0'
expr_stmt|;
name|now_col
operator|=
name|count_spaces
argument_list|(
name|ps
operator|.
name|com_col
argument_list|,
name|s_com
argument_list|)
expr_stmt|;
comment|/* recompute current 								 * position */
block|}
break|break;
block|}
block|}
block|}
end_block

end_unit

