begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)indent.c	4.1	(Berkeley)	%G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  			  Copyright (C) 1976 				by the 			  Board of Trustees 				of the 			University of Illinois  			 All rights reserved   NAME: 	indent main program  FUNCTION: 	This is the main program of the indent program.  Indent will take a C 	program source and reformat it into a semi-reasonable form.  ALGORITHM: 	The routine lexi scans tokens and passes them back one at a time to the 	main routine.  The subroutine parse takes care of much of the work of 	figuring indentation level.    	1) Call lexi 	2) Enter a monster switch statement on the code returned by lexi.  If  	   the indentation level for the line yet to be printed should be  	   changed, set the variable ind_level.  If the indentation level for 	   the following line should be changed, set the variable i_l_follow.  PARAMETERS: 	None  RETURNS: 	Nothing  GLOBALS: 	be_save = 	break_comma 	bp_save = 	btype_2 = 	code_lines 	com_ind = 	com_lines 	dec_nest = 	decl_com_ind = 	decl_on_line = 	i_l_follow = 	in_decl = 	ind_level = 	ind_size = 	ind_stmt = 	last_u_d = 	leave_comma = 	line_no = 	ljust_decl = 	max_col = 	out_coms 	out_lines 	p_l_follow = 	paren_level = 	pcase = 	sc_end = 	unindent_displace = 	use_ff = 	verbose =  CALLS: 	atoi (lib) 	cmp 	creat (lib) 	dump_line 	eqin 	fill_buffer 	lexi 	open (lib) 	parse 	pr_comment 	printf (lib) 	seek (lib) 	time (lib)  CALLED BY: 	No one (main routine)  HISTORY: 	November 1976	D A Willcox of CAC	Initial coding 	12/9/76		D A Willcox of CAC	Fixed defaults for decl_com_ind 						to be 8 less than com_ind if  						left justifying declarations 	12/9/76		D A Willcox of CAC	Fixed processing of nested<c>?<s>:<s> constructs 	1/7/77		D A Willcox of CAC	Added check for overwrite of 						input file 						Added code to handle -br and -bl 						parameters
comment|*/
end_comment

begin_include
include|#
directive|include
file|"indent_globs.h"
include|;
end_include

begin_include
include|#
directive|include
file|"indent_codes.h"
include|;
end_include

begin_comment
comment|/* #define dolog 1	/* if this define is removed, then the code to 			   produce a log file will be removed */
end_comment

begin_struct
struct|struct
name|templ
block|{
comment|/* this is a template for the list of 			          command line args */
name|char
modifier|*
name|str
decl_stmt|;
comment|/* pointer to string which is a valid 			          command line arg */
name|int
name|code
decl_stmt|;
comment|/* code to be used in switch for processing 			          this arg */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|templ
name|options
index|[]
init|=
block|{
comment|/* warning - because of the way that this 			          table is scanned, if one entry is an 			          initial substring of another, then the 			          longer entry should occur first */
literal|"-cd"
block|,
literal|4
block|,
literal|"-c"
block|,
literal|2
block|,
literal|"-l"
block|,
literal|1
block|,
literal|"-i"
block|,
literal|3
block|,
literal|"-v"
block|,
literal|5
block|,
literal|"-nv"
block|,
literal|6
block|,
literal|"-dj"
block|,
literal|7
block|,
literal|"-d"
block|,
literal|13
block|,
comment|/* unindented comment placement */
literal|"-ndj"
block|,
literal|8
block|,
literal|"-bc"
block|,
literal|10
block|,
comment|/* break after command in decl */
literal|"-nbc"
block|,
literal|9
block|,
comment|/* don't break after comma */
literal|"-br"
block|,
literal|14
block|,
comment|/* put brace on right of stmt */
literal|"-bl"
block|,
literal|15
block|,
comment|/* put brace on left by itself */
literal|"-st"
block|,
literal|16
block|,
comment|/* use the standard input and output 				  files */
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|in_name
init|=
literal|"Standard Input"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* will always point to name of input file  			       */
end_comment

begin_decl_stmt
name|char
modifier|*
name|out_name
init|=
literal|"Standard Output"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* will always point to name of output file 			          */
end_comment

begin_decl_stmt
name|char
name|bakfile
index|[
literal|32
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|dec_ind
decl_stmt|;
comment|/* current indentation for declarations */
name|int
name|di_stack
index|[
literal|20
index|]
decl_stmt|;
comment|/* a stack of structure indentation levels  			       */
name|int
name|flushed_nl
decl_stmt|;
comment|/* used when buffering up comments to 			          remember that a newline was passed over  			       */
name|int
name|force_nl
decl_stmt|;
comment|/* when true, code must be broken */
name|int
name|hd_type
decl_stmt|;
comment|/* used to store type of stmt for if (...), 			          for (...), etc */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* local loop counter */
name|int
name|in_or_st
decl_stmt|;
comment|/* Will be true iff there has been a 			          declarator (e.g. int or char) and no 			          left paren since the last semicolon. 			          When true, a { is starting a structure 			          definition or an initialization list */
specifier|register
name|int
name|j
decl_stmt|;
comment|/* local loop counter */
name|int
name|scase
decl_stmt|;
comment|/* set to true when we see a case, so we 			          will know what to do with the following 			          colon */
name|int
name|sp_sw
decl_stmt|;
comment|/* when true, we are in the expressin of 			          if(...), while(...), etc. */
name|int
name|squest
decl_stmt|;
comment|/* when this is positive, we have seen a ? 			          without the matching : in a<c>?<s>:<s> 			          construct */
specifier|register
name|char
modifier|*
name|t_ptr
decl_stmt|;
comment|/* used for copying tokens */
name|int
name|type_code
decl_stmt|;
comment|/* the type of token, returned by lexi */
name|int
name|want_blank
decl_stmt|;
comment|/* set to true when the following token 			          should be prefixed by a blank. (Said 			          prefixing is ignored in some cases.) */
ifdef|#
directive|ifdef
name|dolog
comment|/* include declarations needed for log */
name|int
name|log_fid
decl_stmt|;
comment|/* fid of log file */
struct|struct
name|logtmpl
block|{
comment|/* structure of a log entry */
name|int
name|tvec
index|[
literal|2
index|]
decl_stmt|;
comment|/* time of execution */
name|char
name|inp
decl_stmt|;
comment|/* input fid */
name|char
name|outp
decl_stmt|;
comment|/* output fid */
name|int
name|nout
decl_stmt|;
comment|/* # output lines */
name|int
name|ncom
decl_stmt|;
comment|/* # comments */
name|int
name|wcom
decl_stmt|;
comment|/* # lines w/ comments */
name|int
name|wcode
decl_stmt|;
comment|/* # lines w/code */
name|char
name|mc
decl_stmt|;
comment|/* max line size */
name|char
name|ci
decl_stmt|;
comment|/* comment indentation */
name|char
name|inds
decl_stmt|;
comment|/* indent size */
name|char
name|dci
decl_stmt|;
comment|/* decl comment indentation */
name|char
name|verb
decl_stmt|;
comment|/* verbose */
name|char
name|ljus
decl_stmt|;
comment|/* left just */
name|char
name|lvcom
decl_stmt|;
comment|/* leave commas */
name|char
name|unin
decl_stmt|;
comment|/* unindented comment indentation */
name|char
name|uid
decl_stmt|;
comment|/* the user id */
name|char
name|bropt
decl_stmt|;
comment|/* btype_2 */
name|int
name|reserved
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
name|struct
name|logtmpl
name|logent
decl_stmt|;
endif|#
directive|endif
comment|/*-----------------------------------------------*\ |    INITIALIZATION \*-----------------------------------------------*/
name|combuf
index|[
literal|0
index|]
operator|=
name|codebuf
index|[
literal|0
index|]
operator|=
name|labbuf
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* set up code, label, and comment buffers */
name|combuf
index|[
literal|1
index|]
operator|=
name|codebuf
index|[
literal|1
index|]
operator|=
name|labbuf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s_lab
operator|=
name|e_lab
operator|=
name|labbuf
operator|+
literal|1
expr_stmt|;
name|s_code
operator|=
name|e_code
operator|=
name|codebuf
operator|+
literal|1
expr_stmt|;
name|s_com
operator|=
name|e_com
operator|=
name|combuf
operator|+
literal|1
expr_stmt|;
name|buf_ptr
operator|=
name|buf_end
operator|=
name|in_buffer
expr_stmt|;
name|line_no
operator|=
literal|1
expr_stmt|;
name|had_eof
operator|=
name|in_decl
operator|=
name|decl_on_line
operator|=
name|break_comma
operator|=
name|false
expr_stmt|;
name|sp_sw
operator|=
name|force_nl
operator|=
name|false
expr_stmt|;
name|in_or_st
operator|=
name|false
expr_stmt|;
name|bl_line
operator|=
name|true
expr_stmt|;
name|dec_ind
operator|=
literal|0
expr_stmt|;
name|di_stack
index|[
name|dec_nest
operator|=
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|want_blank
operator|=
name|in_stmt
operator|=
name|ind_stmt
operator|=
name|false
expr_stmt|;
name|scase
operator|=
name|pcase
operator|=
name|false
expr_stmt|;
name|squest
operator|=
literal|0
expr_stmt|;
name|sc_end
operator|=
literal|0
expr_stmt|;
name|bp_save
operator|=
literal|0
expr_stmt|;
name|be_save
operator|=
literal|0
expr_stmt|;
name|input
operator|=
operator|-
literal|1
expr_stmt|;
name|output
operator|=
operator|-
literal|1
expr_stmt|;
name|ljust_decl
operator|=
name|d_ljust
expr_stmt|;
comment|/*--------------------------------------------------*\ |   COMMAND LINE SCAN \*--------------------------------------------------*/
name|max_col
operator|=
name|d_max_col
expr_stmt|;
comment|/* set up some default values */
name|com_ind
operator|=
name|d_com_ind
expr_stmt|;
name|ind_size
operator|=
name|d_ind_size
expr_stmt|;
name|verbose
operator|=
name|d_verbose
expr_stmt|;
name|decl_com_ind
operator|=
literal|0
expr_stmt|;
comment|/* if this is not set to some positive 			          value by an arg, we will set this equal 			          to com_ind */
name|btype_2
operator|=
name|d_btype_2
expr_stmt|;
name|unindent_displace
operator|=
name|d_unindent
expr_stmt|;
name|leave_comma
operator|=
name|d_leave_comma
expr_stmt|;
name|set_profile
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
comment|/* look thru args (if any) for changes to defaults */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
comment|/* no flag on parameter */
if|if
condition|(
name|input
operator|<
literal|0
condition|)
block|{
comment|/* we must have the input file */
name|in_name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
comment|/* remember name of input 					   file */
name|input
operator|=
name|open
argument_list|(
name|in_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
operator|<
literal|0
condition|)
block|{
comment|/* check for open error */
name|printf
argument_list|(
literal|"Can't open %s\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|output
operator|<
literal|0
condition|)
block|{
comment|/* we have the output file */
name|out_name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
comment|/* remember name of output file */
if|if
condition|(
name|cmp
argument_list|(
name|in_name
argument_list|,
name|out_name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* attempt to 					   overwright the file */
name|printf
argument_list|(
literal|"Input and output files must be different\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
block|}
name|output
operator|=
name|creat
argument_list|(
name|out_name
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|<
literal|0
condition|)
block|{
comment|/* check for create error */
name|printf
argument_list|(
literal|"Can't create %s\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
block|}
continue|continue;
block|}
name|printf
argument_list|(
literal|"Unknown parameter: %s\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
block|}
else|else
name|set_option
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* end of for */
if|if
condition|(
name|input
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: indent file [ outfile ] [ options ]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|output
operator|<
literal|0
condition|)
block|{
name|out_name
operator|=
name|in_name
expr_stmt|;
name|bakcopy
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|com_ind
operator|<=
literal|1
condition|)
name|com_ind
operator|=
literal|2
expr_stmt|;
comment|/* don't put normal comments before column 			          2 */
if|if
condition|(
name|decl_com_ind
operator|<=
literal|0
condition|)
comment|/* if not specified by user, set this */
name|decl_com_ind
operator|=
name|ljust_decl
condition|?
operator|(
name|com_ind
operator|<=
literal|10
condition|?
literal|2
else|:
name|com_ind
operator|-
literal|8
operator|)
else|:
name|com_ind
expr_stmt|;
name|fill_buffer
argument_list|()
expr_stmt|;
comment|/* get first batch of stuff into input 			          buffer */
name|parse
argument_list|(
name|semicolon
argument_list|)
expr_stmt|;
comment|/*----------------------------------------------------- |   START OF MAIN LOOP \*----------------------------------------------------*/
while|while
condition|(
literal|1
condition|)
block|{
comment|/* this is the main loop.  it will go until 			          we reach eof */
name|type_code
operator|=
name|lexi
argument_list|()
expr_stmt|;
comment|/* lexi reads one token.  The actual 			          characters read are stored in "token". 			          lexi returns a code indicating the type 			          of token */
comment|/*       * The following code moves everything following an if (), while (),      * else, etc. up to the start of the following stmt to a buffer.  This      * allows proper handling of both kinds of brace placement.      */
name|flushed_nl
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|search_brace
condition|)
block|{
comment|/* if we scanned an if(), while(), etc., we 			          might need to copy stuff into a buffer  	*/
comment|/* we must loop, copying stuff into save_com, until we find the 	   start of the stmt which follows the if, or whatever */
switch|switch
condition|(
name|type_code
condition|)
block|{
case|case
name|newline
case|:
operator|++
name|line_no
expr_stmt|;
name|flushed_nl
operator|=
name|true
expr_stmt|;
case|case
name|form_feed
case|:
break|break;
comment|/* form feeds and newlines found here will 			          be ignored */
case|case
name|lbrace
case|:
comment|/* this is a brace that starts the compound 			          stmt */
if|if
condition|(
name|sc_end
operator|==
literal|0
condition|)
block|{
comment|/* ignore buffering if a comment wasn't stored up */
name|search_brace
operator|=
name|false
expr_stmt|;
goto|goto
name|check_type
goto|;
block|}
if|if
condition|(
name|btype_2
condition|)
block|{
name|save_com
index|[
literal|0
index|]
operator|=
literal|'{'
expr_stmt|;
comment|/* we either want to put the brace right after the if  		    */
goto|goto
name|sw_buffer
goto|;
comment|/* go to common code to get out of this loop */
block|}
default|default:
comment|/* it is the start of a normal statment */
if|if
condition|(
name|flushed_nl
condition|)
comment|/* if we flushed a newline, make sure it is 			          put back */
name|force_nl
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|sc_end
operator|==
literal|0
condition|)
block|{
comment|/* ignore buffering if comment wasn't saved up */
name|search_brace
operator|=
name|false
expr_stmt|;
goto|goto
name|check_type
goto|;
block|}
if|if
condition|(
name|force_nl
condition|)
block|{
comment|/* if we should insert a nl here, put it into the 		       buffer */
name|force_nl
operator|=
name|false
expr_stmt|;
operator|--
name|line_no
expr_stmt|;
comment|/* this will be re-increased when the nl is read from 		       the buffer */
operator|*
name|sc_end
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|sc_end
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
operator|!
name|flushed_nl
condition|)
comment|/* print error msg if the line was not 			          already broken */
name|printf
argument_list|(
literal|"%d: Line broken\n"
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
name|flushed_nl
operator|=
name|false
expr_stmt|;
block|}
for|for
control|(
name|t_ptr
operator|=
name|token
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
operator|*
name|sc_end
operator|++
operator|=
operator|*
name|t_ptr
expr_stmt|;
comment|/* copy token into temp buffer */
name|sw_buffer
label|:
name|search_brace
operator|=
name|false
expr_stmt|;
comment|/* stop looking for start of stmt */
name|bp_save
operator|=
name|buf_ptr
expr_stmt|;
comment|/* save current input buffer */
name|be_save
operator|=
name|buf_end
expr_stmt|;
name|buf_ptr
operator|=
name|save_com
expr_stmt|;
comment|/* fix so that subsequent calls to lexi will take tokens 		   out of save_com */
operator|*
name|sc_end
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* add trailing blank, just in case */
name|buf_end
operator|=
name|sc_end
expr_stmt|;
name|sc_end
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|comment
case|:
comment|/* we have a comment, so we must copy it 			          into the buffer */
if|if
condition|(
name|sc_end
operator|==
literal|0
condition|)
block|{
comment|/* if this is the first comment, we must set up the 		       buffer */
name|save_com
index|[
literal|0
index|]
operator|=
name|save_com
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|sc_end
operator|=
operator|&
operator|(
name|save_com
index|[
literal|2
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|sc_end
operator|++
operator|=
literal|'\n'
expr_stmt|;
comment|/* add newline between comments */
operator|*
name|sc_end
operator|++
operator|=
literal|' '
expr_stmt|;
operator|--
name|line_no
expr_stmt|;
block|}
operator|*
name|sc_end
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* copy in start of comment */
operator|*
name|sc_end
operator|++
operator|=
literal|'*'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* loop until we get to the end of the 			          comment */
operator|*
name|sc_end
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|sc_end
operator|++
operator|==
literal|'*'
operator|&&
operator|*
name|buf_ptr
operator|==
literal|'/'
condition|)
break|break;
comment|/* we are at end of comment */
if|if
condition|(
name|sc_end
operator|>=
operator|&
operator|(
name|save_com
index|[
name|sc_size
index|]
operator|)
condition|)
block|{
comment|/* check for temp buffer overflow */
name|printf
argument_list|(
literal|"%d: Internal buffer overflow.\n"
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Move big comment from right after if,\  while, or whatever.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
block|}
block|}
operator|*
name|sc_end
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* add ending slash */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
comment|/* get past / in buffer */
name|fill_buffer
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* end of switch */
if|if
condition|(
name|type_code
operator|!=
literal|0
condition|)
comment|/* we must make this check, just in case 			          there was an unexpected EOF */
name|type_code
operator|=
name|lexi
argument_list|()
expr_stmt|;
comment|/* read another token */
block|}
comment|/* end of while (serach_brace) */
name|check_type
label|:
if|if
condition|(
name|type_code
operator|==
literal|0
condition|)
block|{
comment|/* we got eof */
if|if
condition|(
name|s_lab
operator|!=
name|e_lab
operator|||
name|s_code
operator|!=
name|e_code
operator|||
name|s_com
operator|!=
name|e_com
condition|)
comment|/* must dump end of line */
name|dump_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|i_l_follow
operator|!=
literal|0
condition|)
comment|/* check for balanced braces */
name|printf
argument_list|(
literal|"%d too few }'s\n"
argument_list|,
name|i_l_follow
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|dolog
comment|/* only include this stuff if we want to 			          keep a log */
name|log_fid
operator|=
name|open
argument_list|(
literal|"/mnt/net/willcox/indent/indent_log"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* open the log file */
if|if
condition|(
name|log_fid
operator|>=
literal|0
condition|)
block|{
name|seek
argument_list|(
name|log_fid
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* point to end of log */
name|time
argument_list|(
name|logent
operator|.
name|tvec
argument_list|)
expr_stmt|;
comment|/* get current time */
name|logent
operator|.
name|inp
operator|=
name|input
expr_stmt|;
comment|/* set up the log entry */
name|logent
operator|.
name|outp
operator|=
name|output
expr_stmt|;
name|logent
operator|.
name|nout
operator|=
name|out_lines
expr_stmt|;
name|logent
operator|.
name|ncom
operator|=
name|out_coms
expr_stmt|;
name|logent
operator|.
name|wcom
operator|=
name|com_lines
expr_stmt|;
name|logent
operator|.
name|wcode
operator|=
name|code_lines
expr_stmt|;
name|logent
operator|.
name|mc
operator|=
name|max_col
expr_stmt|;
name|logent
operator|.
name|ci
operator|=
name|com_ind
expr_stmt|;
name|logent
operator|.
name|inds
operator|=
name|ind_size
expr_stmt|;
name|logent
operator|.
name|dci
operator|=
name|decl_com_ind
expr_stmt|;
name|logent
operator|.
name|verb
operator|=
name|verbose
expr_stmt|;
name|logent
operator|.
name|ljus
operator|=
name|ljust_decl
expr_stmt|;
name|logent
operator|.
name|lvcom
operator|=
name|leave_comma
expr_stmt|;
name|logent
operator|.
name|unin
operator|=
name|unindent_displace
expr_stmt|;
name|logent
operator|.
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|logent
operator|.
name|bropt
operator|=
name|btype_2
expr_stmt|;
name|write
argument_list|(
name|log_fid
argument_list|,
operator|&
name|logent
argument_list|,
sizeof|sizeof
name|logent
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"There were %d output lines and %d comments\n"
argument_list|,
name|out_lines
argument_list|,
name|out_coms
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(Lines with comments)/(Lines with code): %6.3f\n"
argument_list|,
operator|(
literal|1.0
operator|*
name|com_lines
operator|)
operator|/
name|code_lines
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type_code
operator|!=
name|comment
operator|)
operator|&&
operator|(
name|type_code
operator|!=
name|newline
operator|)
operator|&&
operator|(
name|type_code
operator|!=
name|preesc
operator|)
operator|&&
operator|(
name|type_code
operator|!=
name|form_feed
operator|)
condition|)
block|{
if|if
condition|(
name|force_nl
operator|&&
operator|(
name|type_code
operator|!=
name|semicolon
operator|)
operator|&&
operator|(
name|type_code
operator|!=
name|lbrace
operator|||
operator|!
name|btype_2
operator|)
condition|)
block|{
comment|/* we should force a broken line here */
if|if
condition|(
name|verbose
operator|&&
operator|!
name|flushed_nl
condition|)
name|printf
argument_list|(
literal|"%d: Line broken\n"
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
name|flushed_nl
operator|=
name|false
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|want_blank
operator|=
name|false
expr_stmt|;
comment|/* don't insert blank at line start */
name|force_nl
operator|=
name|false
expr_stmt|;
block|}
name|in_stmt
operator|=
name|true
expr_stmt|;
comment|/* turn on flag which causes an extra level 			          of indentation. this is turned off by a 			          ; or } */
if|if
condition|(
name|s_com
operator|!=
name|e_com
condition|)
block|{
comment|/* the turkey has embedded a comment in a line. fix it */
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|t_ptr
operator|=
name|s_com
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
operator|*
name|e_code
operator|++
operator|=
operator|*
name|t_ptr
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_code
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminate code sect */
name|want_blank
operator|=
name|false
expr_stmt|;
name|e_com
operator|=
name|s_com
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type_code
operator|!=
name|comment
condition|)
comment|/* preserve force_nl thru a comment */
name|force_nl
operator|=
name|false
expr_stmt|;
comment|/* cancel forced newline after newline, form feed, etc */
comment|/*----------------------------------------------------*\     |   do switch on type of token scanned     \*----------------------------------------------------*/
switch|switch
condition|(
name|type_code
condition|)
block|{
comment|/* now, decide what to do with the token */
case|case
name|form_feed
case|:
comment|/* found a form feed in line */
name|use_ff
operator|=
name|true
expr_stmt|;
comment|/* a form feed is treated much like a 			          newline */
name|dump_line
argument_list|()
expr_stmt|;
name|want_blank
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|newline
case|:
name|dump_line
argument_list|()
expr_stmt|;
operator|++
name|line_no
expr_stmt|;
comment|/* keep track of input line number */
name|want_blank
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|lparen
case|:
comment|/* got a ( or [ */
operator|++
name|p_l_follow
expr_stmt|;
comment|/* count parens to make Healy happy */
if|if
condition|(
name|want_blank
operator|&&
operator|*
name|token
operator|!=
literal|'['
condition|)
comment|/* don't put space in front of square 			          bracket */
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|in_decl
condition|)
while|while
condition|(
operator|(
name|e_code
operator|-
name|s_code
operator|)
operator|<
name|dec_ind
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
name|token
index|[
literal|0
index|]
expr_stmt|;
name|want_blank
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|in_or_st
operator|&&
operator|*
name|token
operator|==
literal|'('
condition|)
block|{
comment|/* this is a kluge to make sure that declarations will be 		   aaigned right if proc decl has an explicit type on it, 		   i.e. "int a(x) {..." */
name|parse
argument_list|(
name|semicolon
argument_list|)
expr_stmt|;
comment|/* I said this was a kluge... */
name|in_or_st
operator|=
name|false
expr_stmt|;
comment|/* turn off flag for structure decl or initialization */
block|}
break|break;
case|case
name|rparen
case|:
comment|/* got a ) or ] */
if|if
condition|(
operator|--
name|p_l_follow
operator|<
literal|0
condition|)
block|{
name|p_l_follow
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%d: Extra %c\n"
argument_list|,
name|line_no
argument_list|,
operator|*
name|token
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e_code
operator|==
name|s_code
condition|)
comment|/* if the paren starts the line */
name|paren_level
operator|=
name|p_l_follow
expr_stmt|;
comment|/*    then indent it */
operator|*
name|e_code
operator|++
operator|=
name|token
index|[
literal|0
index|]
expr_stmt|;
name|want_blank
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|sp_sw
operator|&&
operator|(
name|p_l_follow
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* check for end of if (...), or some such */
name|sp_sw
operator|=
name|false
expr_stmt|;
name|force_nl
operator|=
name|true
expr_stmt|;
comment|/* must force newline after if */
name|last_u_d
operator|=
name|true
expr_stmt|;
comment|/* inform lexi that a following operator is unary */
name|in_stmt
operator|=
name|false
expr_stmt|;
comment|/* don't use stmt continuation indentation */
name|parse
argument_list|(
name|hd_type
argument_list|)
expr_stmt|;
comment|/* let parser worry about if, or whatever */
block|}
name|search_brace
operator|=
name|btype_2
expr_stmt|;
comment|/* this should insure that constructs such as main(){... and 	       int[]{... have their braces put in the right place */
break|break;
case|case
name|unary_op
case|:
comment|/* this could be any unary operation */
if|if
condition|(
name|want_blank
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|in_decl
condition|)
block|{
comment|/* if this is a unary op in a */
comment|/* 			          declaration, we should indent this token 			          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|token
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
empty_stmt|;
comment|/* find length of token */
while|while
condition|(
operator|(
name|e_code
operator|-
name|s_code
operator|)
operator|<
operator|(
name|dec_ind
operator|-
name|i
operator|)
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* pad it */
block|}
for|for
control|(
name|t_ptr
operator|=
name|token
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
operator|*
name|e_code
operator|++
operator|=
operator|*
name|t_ptr
expr_stmt|;
comment|/* move the token to buffer */
name|want_blank
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|binary_op
case|:
comment|/* any binary operation */
name|do_binary
label|:
if|if
condition|(
name|want_blank
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|t_ptr
operator|=
name|token
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
operator|*
name|e_code
operator|++
operator|=
operator|*
name|t_ptr
expr_stmt|;
comment|/* move the operator */
name|want_blank
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|postop
case|:
comment|/* got a trailing ++ or -- */
operator|*
name|e_code
operator|++
operator|=
name|token
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
name|token
index|[
literal|1
index|]
expr_stmt|;
name|want_blank
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|question
case|:
comment|/* got a ? */
name|squest
operator|++
expr_stmt|;
comment|/* this will be used when a later colon 			          appears so we can distinguish the<c>?<n>:<n> construct */
if|if
condition|(
name|want_blank
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|'?'
expr_stmt|;
name|want_blank
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|casestmt
case|:
comment|/* got word 'case' or 'default' */
name|scase
operator|=
name|true
expr_stmt|;
comment|/* so we can process the later colon 			          properly */
if|if
condition|(
name|want_blank
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|t_ptr
operator|=
name|token
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
operator|*
name|e_code
operator|++
operator|=
operator|*
name|t_ptr
expr_stmt|;
name|want_blank
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|colon
case|:
comment|/* got a ':' */
if|if
condition|(
name|squest
operator|>
literal|0
condition|)
block|{
comment|/* it is part of the<c>?<n>:<n> construct */
operator|--
name|squest
expr_stmt|;
if|if
condition|(
name|want_blank
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|':'
expr_stmt|;
name|want_blank
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|in_stmt
operator|=
name|false
expr_stmt|;
comment|/* seeing a label does not imply we are in a stmt */
for|for
control|(
name|t_ptr
operator|=
name|s_code
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
operator|*
name|e_lab
operator|++
operator|=
operator|*
name|t_ptr
expr_stmt|;
comment|/* turn everything so far into a label */
name|e_code
operator|=
name|s_code
expr_stmt|;
operator|*
name|e_lab
operator|++
operator|=
literal|':'
expr_stmt|;
operator|*
name|e_lab
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_lab
operator|=
literal|'\0'
expr_stmt|;
name|force_nl
operator|=
name|pcase
operator|=
name|scase
expr_stmt|;
comment|/* pcase will be used by dump_line to decide how to indent the 	       label. force_nl will force a case n: to be on a line by 	       itself */
name|scase
operator|=
name|false
expr_stmt|;
name|want_blank
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|semicolon
case|:
comment|/* got a ';' */
name|in_or_st
operator|=
name|false
expr_stmt|;
comment|/* we are not in an initialization or structure declaration */
name|scase
operator|=
name|false
expr_stmt|;
comment|/* these will only need resetting in a 			          error */
name|squest
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|in_decl
operator|&&
name|s_code
operator|==
name|e_code
condition|)
comment|/* align this in a declaration */
while|while
condition|(
operator|(
name|e_code
operator|-
name|s_code
operator|)
operator|<
operator|(
name|dec_ind
operator|-
literal|1
operator|)
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
name|in_decl
operator|=
operator|(
name|dec_nest
operator|>
literal|0
operator|)
expr_stmt|;
comment|/* if we were in a first level structure declaration, we 	       aren't any more */
if|if
condition|(
operator|(
operator|!
name|sp_sw
operator|||
name|hd_type
operator|!=
name|forstmt
operator|)
operator|&&
name|p_l_follow
operator|>
literal|0
condition|)
block|{
comment|/* This should be true iff there were unbalanced parens in 		   the stmt.  It is a bit complicated, because the 		   semicolon might be in a for stmt */
name|printf
argument_list|(
literal|"%d: Unbalanced parens\n"
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
name|p_l_follow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp_sw
condition|)
block|{
comment|/* this is a check for a if, while, etc. with 		       unbalanced parens */
name|sp_sw
operator|=
name|false
expr_stmt|;
name|parse
argument_list|(
name|hd_type
argument_list|)
expr_stmt|;
comment|/* don't lose the if, or whatever */
block|}
block|}
operator|*
name|e_code
operator|++
operator|=
literal|';'
expr_stmt|;
name|want_blank
operator|=
name|true
expr_stmt|;
name|in_stmt
operator|=
operator|(
name|p_l_follow
operator|>
literal|0
operator|)
expr_stmt|;
comment|/* we are no longer in the middle of a stmt */
if|if
condition|(
operator|!
name|sp_sw
condition|)
block|{
comment|/* if not if for (;;) */
name|parse
argument_list|(
name|semicolon
argument_list|)
expr_stmt|;
comment|/* let parser know about end of stmt */
name|force_nl
operator|=
name|true
expr_stmt|;
comment|/* force newline after a end of stmt */
block|}
break|break;
case|case
name|lbrace
case|:
comment|/* got a { */
name|in_stmt
operator|=
name|false
expr_stmt|;
comment|/* don't indent the { */
name|force_nl
operator|=
name|true
expr_stmt|;
comment|/* force other stuff on same line as { onto new line */
if|if
condition|(
name|s_code
operator|!=
name|e_code
operator|&&
operator|!
name|btype_2
condition|)
block|{
comment|/* bracket is not alone on line */
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%d: Line broken\n"
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|want_blank
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|p_l_follow
operator|>
literal|0
condition|)
block|{
comment|/* check for preceeding unbalanced parens */
name|printf
argument_list|(
literal|"%d: Unbalanced parens\n"
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
name|p_l_follow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp_sw
condition|)
block|{
comment|/* check for unclosed if, for, etc. */
name|sp_sw
operator|=
name|false
expr_stmt|;
name|parse
argument_list|(
name|hd_type
argument_list|)
expr_stmt|;
name|ind_level
operator|=
name|i_l_follow
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s_code
operator|==
name|e_code
condition|)
name|ind_stmt
operator|=
name|false
expr_stmt|;
comment|/* don't put extra indentation on line with '{' */
if|if
condition|(
name|in_decl
operator|&&
name|in_or_st
condition|)
block|{
comment|/* this is either a structure declaration or an init */
name|di_stack
index|[
name|dec_nest
operator|++
index|]
operator|=
name|dec_ind
expr_stmt|;
name|dec_ind
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|decl_on_line
operator|=
name|false
expr_stmt|;
comment|/* we can't be in the middle of a declaration, so don't do 	       special indentation of comments */
name|parse
argument_list|(
name|lbrace
argument_list|)
expr_stmt|;
comment|/* let parser know about this */
if|if
condition|(
name|want_blank
condition|)
comment|/* put a blank before { if { is not at 			          start of line */
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
name|want_blank
operator|=
name|false
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|'{'
expr_stmt|;
break|break;
case|case
name|rbrace
case|:
comment|/* got a } */
if|if
condition|(
name|p_l_follow
condition|)
block|{
comment|/* check for unclosed if, for, else. */
name|printf
argument_list|(
literal|"%d: Unbalanced parens\n"
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
name|p_l_follow
operator|=
literal|0
expr_stmt|;
name|sp_sw
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|s_code
operator|!=
name|e_code
condition|)
block|{
comment|/* } must be first on line */
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%d: Line broken\n"
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
block|}
operator|*
name|e_code
operator|++
operator|=
literal|'}'
expr_stmt|;
name|want_blank
operator|=
name|true
expr_stmt|;
name|in_stmt
operator|=
name|ind_stmt
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|dec_nest
operator|>
literal|0
condition|)
block|{
comment|/* we are in multi-level structure declaration */
name|dec_ind
operator|=
name|di_stack
index|[
operator|--
name|dec_nest
index|]
expr_stmt|;
name|in_decl
operator|=
name|true
expr_stmt|;
block|}
name|parse
argument_list|(
name|rbrace
argument_list|)
expr_stmt|;
comment|/*   let parser know about this */
break|break;
case|case
name|swstmt
case|:
comment|/* got keyword "switch" */
name|sp_sw
operator|=
name|true
expr_stmt|;
name|hd_type
operator|=
name|swstmt
expr_stmt|;
comment|/* keep this for when we have seen the expression */
goto|goto
name|copy_id
goto|;
comment|/* go move the token into buffer */
case|case
name|sp_paren
case|:
comment|/* token is if, while, for */
name|sp_sw
operator|=
name|true
expr_stmt|;
comment|/* the interesting stuff is done after the 			          expression is scanned */
name|hd_type
operator|=
operator|(
operator|*
name|token
operator|==
literal|'i'
condition|?
name|ifstmt
else|:
operator|(
operator|*
name|token
operator|==
literal|'w'
condition|?
name|whilestmt
else|:
name|forstmt
operator|)
operator|)
expr_stmt|;
comment|/* remember the type of header for later use by parser */
goto|goto
name|copy_id
goto|;
comment|/* copy the token into line */
case|case
name|sp_nparen
case|:
comment|/* got else, do */
name|in_stmt
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|e_code
operator|!=
name|s_code
condition|)
block|{
comment|/* make sure this starts a line */
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%d: Line broken\n"
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|want_blank
operator|=
name|false
expr_stmt|;
block|}
name|force_nl
operator|=
name|true
expr_stmt|;
comment|/* also, following stuff must go onto new line */
name|parse
argument_list|(
operator|*
name|token
operator|==
literal|'e'
condition|?
name|elselit
else|:
name|dolit
argument_list|)
expr_stmt|;
comment|/* pass token on to parser */
goto|goto
name|copy_id
goto|;
comment|/* move the token into line */
case|case
name|decl
case|:
comment|/* we have a declaration type (int, 			          register, etc.) */
name|parse
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* let parser worry about indentation */
name|in_or_st
operator|=
name|true
expr_stmt|;
comment|/* this might be a structure or initialization declaration */
name|in_decl
operator|=
name|decl_on_line
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|token
index|[
name|i
operator|++
index|]
condition|;
control|)
empty_stmt|;
comment|/* get length of token */
if|if
condition|(
name|i
operator|<=
literal|3
condition|)
name|i
operator|=
literal|4
expr_stmt|;
name|dec_ind
operator|=
operator|(
operator|(
name|e_code
operator|-
name|s_code
operator|+
name|i
operator|)
operator|/
name|ind_size
operator|+
literal|1
operator|)
operator|*
name|ind_size
expr_stmt|;
comment|/* this will tell us how far to indent subsequent identifiers  	    */
goto|goto
name|copy_id
goto|;
case|case
name|ident
case|:
comment|/* got an identifier or constant */
if|if
condition|(
name|in_decl
condition|)
block|{
comment|/* if we are in a declaration, we must 			          indent identifier */
if|if
condition|(
name|want_blank
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
name|want_blank
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|(
name|e_code
operator|-
name|s_code
operator|)
operator|<
name|dec_ind
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp_sw
operator|&&
name|p_l_follow
operator|==
literal|0
condition|)
block|{
comment|/* check for if expr w/o parens */
comment|/* this will make 		       JRM's obsurd "for ever" statements work */
name|sp_sw
operator|=
name|false
expr_stmt|;
name|force_nl
operator|=
name|true
expr_stmt|;
name|last_u_d
operator|=
name|true
expr_stmt|;
name|in_stmt
operator|=
name|false
expr_stmt|;
name|parse
argument_list|(
name|hd_type
argument_list|)
expr_stmt|;
block|}
name|copy_id
label|:
if|if
condition|(
name|want_blank
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|t_ptr
operator|=
name|token
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
operator|*
name|e_code
operator|++
operator|=
operator|*
name|t_ptr
expr_stmt|;
name|want_blank
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|period
case|:
comment|/* treat a period kind of like a binary 			          operation */
operator|*
name|e_code
operator|++
operator|=
literal|'.'
expr_stmt|;
comment|/* move the period into line */
name|want_blank
operator|=
name|false
expr_stmt|;
comment|/* don't put a blank after a period */
break|break;
case|case
name|comma
case|:
name|want_blank
operator|=
operator|(
name|s_code
operator|!=
name|e_code
operator|)
expr_stmt|;
comment|/* only put blank after comma if comma does not start the line 	       */
if|if
condition|(
name|in_decl
condition|)
comment|/* align these in a declaration */
while|while
condition|(
operator|(
name|e_code
operator|-
name|s_code
operator|)
operator|<
operator|(
name|dec_ind
operator|-
literal|1
operator|)
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|break_comma
operator|&&
name|p_l_follow
operator|==
literal|0
operator|&&
operator|!
name|leave_comma
condition|)
name|force_nl
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|preesc
case|:
comment|/* got the character '#' */
if|if
condition|(
operator|(
name|s_com
operator|!=
name|e_com
operator|)
operator|||
operator|(
name|s_lab
operator|!=
name|e_lab
operator|)
operator|||
operator|(
name|s_code
operator|!=
name|e_code
operator|)
condition|)
block|{
comment|/* true iff the '#' was not at start of the line */
name|printf
argument_list|(
literal|"%d: What is this # doing here?\n"
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
goto|goto
name|do_binary
goto|;
comment|/* treat it as a binary operator */
block|}
operator|*
name|e_lab
operator|++
operator|=
literal|'#'
expr_stmt|;
comment|/* move whole line to 'label' buffer */
while|while
condition|(
operator|*
name|buf_ptr
operator|!=
literal|'\n'
condition|)
block|{
operator|*
name|e_lab
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|e_lab
operator|++
operator|==
literal|'/'
operator|&&
operator|*
name|buf_ptr
operator|==
literal|'*'
condition|)
block|{
comment|/* check for comment on preprocessor line */
name|e_lab
operator|-
operator|=
literal|2
expr_stmt|;
comment|/* skip back over slash */
while|while
condition|(
operator|*
name|e_lab
operator|==
literal|'\t'
operator|||
operator|*
name|e_lab
operator|==
literal|' '
condition|)
operator|--
name|e_lab
expr_stmt|;
comment|/* strip off trailing blanks and tabs */
operator|*
operator|(
operator|++
name|e_lab
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminate the line */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
comment|/* space past start of comment */
name|fill_buffer
argument_list|()
expr_stmt|;
name|col_1
operator|=
name|false
expr_stmt|;
comment|/* don't let pr_comment think that this comment starts 		       in column 1 */
name|decl_on_line
operator|=
name|true
expr_stmt|;
comment|/* treat this as a declaration for comment placement 		       purposes */
goto|goto
name|proc_comment
goto|;
comment|/* go process the comment */
block|}
block|}
operator|*
name|e_lab
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminate line */
name|pcase
operator|=
name|false
expr_stmt|;
break|break;
comment|/* subsequent processing of the newline 			          character will cause the line to be 			          printed */
case|case
name|comment
case|:
comment|/* we have gotten a /*  this is a biggie */
name|proc_comment
label|:
name|pr_comment
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* end of big switch stmt */
operator|*
name|e_code
operator|=
literal|'\0'
expr_stmt|;
comment|/* make sure code section is null 			          terminated */
block|}
comment|/* end of main while (1) loop */
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * copy input file to backup file  * if in_name is /blah/blah/blah/file, then backup file  * will be ".Bfile"  * then make the backup file the input and original  * input file the output  */
end_comment

begin_macro
name|bakcopy
argument_list|()
end_macro

begin_block
block|{
name|int
name|n
decl_stmt|,
name|bakchn
decl_stmt|;
name|char
name|buff
index|[
literal|512
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* construct file name .Bfile */
for|for
control|(
name|p
operator|=
name|in_name
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
empty_stmt|;
comment|/* skip to end of string */
while|while
condition|(
name|p
operator|>
name|in_name
operator|&&
operator|*
name|p
operator|!=
literal|'/'
condition|)
comment|/* find last '/' */
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|p
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|bakfile
argument_list|,
literal|".B%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* copy in_name to backup file */
name|bakchn
operator|=
name|creat
argument_list|(
name|bakfile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|bakchn
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"can't create backup file \"%s\"\n"
argument_list|,
name|bakfile
argument_list|)
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|n
operator|=
name|read
argument_list|(
name|input
argument_list|,
name|buff
argument_list|,
literal|512
argument_list|)
condition|)
name|write
argument_list|(
name|bakchn
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|bakchn
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|input
argument_list|)
expr_stmt|;
comment|/* re-open backup file as the input file */
name|input
operator|=
name|open
argument_list|(
name|bakfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"can't re-open backup file\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
block|}
comment|/* now the original input file will be the output */
name|output
operator|=
name|creat
argument_list|(
name|in_name
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"can't create %s\n"
argument_list|,
name|in_name
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|bakfile
argument_list|)
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|set_option
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|j
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|options
index|[
name|j
index|]
operator|.
name|str
operator|!=
literal|0
condition|;
operator|++
name|j
control|)
block|{
comment|/* look thru list of possible options */
if|if
condition|(
name|eqin
argument_list|(
name|options
index|[
name|j
index|]
operator|.
name|str
argument_list|,
name|arg
argument_list|)
condition|)
block|{
name|set_var
argument_list|(
name|j
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
comment|/* get out of for loop */
block|}
block|}
if|if
condition|(
name|options
index|[
name|j
index|]
operator|.
name|str
operator|==
literal|0
condition|)
block|{
comment|/* illegal arg given */
name|printf
argument_list|(
literal|"Unknown parameter: %s\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|set_var
argument_list|(
argument|j
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|options
index|[
name|j
index|]
operator|.
name|code
condition|)
block|{
case|case
literal|1
case|:
comment|/* have -lnnn */
name|max_col
operator|=
name|atoi
argument_list|(
operator|&
name|arg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* have -cnnn */
name|com_ind
operator|=
name|atoi
argument_list|(
operator|&
name|arg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* have -innn */
name|ind_size
operator|=
name|atoi
argument_list|(
operator|&
name|arg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* have -cdnnn */
name|decl_com_ind
operator|=
name|atoi
argument_list|(
operator|&
name|arg
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* have -v */
name|verbose
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* have -nv */
name|verbose
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* have -dj */
name|ljust_decl
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* have -ndj */
name|ljust_decl
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|9
case|:
comment|/* -nbc */
name|leave_comma
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|10
case|:
comment|/* -bc */
name|leave_comma
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|13
case|:
comment|/* -dnnn */
name|unindent_displace
operator|=
name|atoi
argument_list|(
operator|&
name|arg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
comment|/* -br */
name|btype_2
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|15
case|:
comment|/* -bl */
name|btype_2
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
name|input
operator|<
literal|0
condition|)
name|input
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|output
operator|<
literal|0
condition|)
name|output
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * GETPRO - get profile file  * profile file is max 127 characters  */
end_comment

begin_macro
name|getpro
argument_list|(
argument|name
argument_list|,
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|,
comment|/* profile file name, as in '.indent.pro'  			       */
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* will receive contents of .pro file */
end_comment

begin_block
block|{
specifier|register
name|chn
operator|,
name|n
expr_stmt|;
name|char
name|file
index|[
literal|32
index|]
decl_stmt|;
name|file
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|file
argument_list|,
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|file
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|chn
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|chn
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|n
operator|=
name|read
argument_list|(
name|chn
argument_list|,
name|buf
argument_list|,
literal|127
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|buf
index|[
name|n
operator|--
index|]
operator|=
literal|0
expr_stmt|;
comment|/* null terminate line */
if|if
condition|(
name|buf
index|[
name|n
index|]
operator|==
literal|'\n'
condition|)
name|buf
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|close
argument_list|(
name|chn
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * strip off arguments in a string:  * p is address of a character pointer  * nextchr returns pointer to front of first arg  * arg is null terminated.  * p is reset to after arg for subsequent calls  */
end_comment

begin_function
name|char
modifier|*
name|nxtarg
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|f
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|f
operator|=
name|b
operator|=
operator|*
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|f
operator|&&
operator|(
operator|*
name|f
operator|==
literal|' '
operator|||
operator|*
name|f
operator|==
literal|'\t'
operator|)
condition|)
name|f
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|b
operator|&&
operator|(
operator|*
name|b
operator|!=
literal|' '
operator|&&
operator|*
name|b
operator|!=
literal|'\t'
operator|)
condition|)
name|b
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|b
operator|!=
literal|0
condition|)
operator|*
name|b
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|=
name|b
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_macro
name|set_profile
argument_list|()
end_macro

begin_block
block|{
name|char
name|line
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|b
decl_stmt|;
specifier|register
name|char
modifier|*
name|f
decl_stmt|;
specifier|extern
name|char
modifier|*
name|nxtarg
parameter_list|()
function_decl|;
if|if
condition|(
name|getpro
argument_list|(
literal|".indent.pro"
argument_list|,
name|line
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|b
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"profile: %s\n"
argument_list|,
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|(
name|f
operator|=
name|nxtarg
argument_list|(
operator|&
name|b
argument_list|)
operator|)
condition|)
name|set_option
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

