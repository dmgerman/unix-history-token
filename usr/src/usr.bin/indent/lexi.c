begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)lexi.c	4.1	(Berkeley)	%G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  			  Copyright (C) 1976 				by the 			  Board of Trustees 				of the 			University of Illinois  			 All rights reserved   NAME: 	lexi  FUNCTION: 	This is the token scanner for indent  ALGORITHM: 	1) Strip off intervening blanks and/or tabs. 	2) If it is an alphanumeric token, move it to the token buffer "token". 	   Check if it is a special reserved word that indent will want to 	   know about. 	3) Non-alphanumeric tokens are handled with a big switch statement.  A 	   flag is kept to remember if the last token was a "unary delimiter", 	   which forces a following operator to be unary as opposed to binary.  PARAMETERS: 	None  RETURNS: 	An integer code indicating the type of token scanned.  GLOBALS: 	buf_ptr = 	had_eof 	last_u_d =	Set to true iff this token is a "unary delimiter"  CALLS: 	fill_buffer 	printf (lib)  CALLED BY: 	main  NOTES: 	Start of comment is passed back so that the comment can be scanned by 	pr_comment.  	Strings and character literals are returned just like identifiers.  HISTORY: 	initial coding 	November 1976	D A Willcox of CAC 	1/7/77		D A Willcox of CAC	Fix to provide proper handling 						of "int a -1;"  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Here we have the token scanner for indent.  It scans off one token and    puts it in the global variable "token".  It returns a code, indicating the    type of token scanned. */
end_comment

begin_include
include|#
directive|include
file|"indent_globs.h"
include|;
end_include

begin_include
include|#
directive|include
file|"indent_codes.h"
include|;
end_include

begin_define
define|#
directive|define
name|alphanum
value|1
end_define

begin_define
define|#
directive|define
name|opchar
value|3
end_define

begin_struct
struct|struct
name|templ
block|{
name|char
modifier|*
name|rwd
decl_stmt|;
name|int
name|rwcode
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|templ
name|specials
index|[]
init|=
block|{
literal|"switch"
block|,
literal|1
block|,
literal|"case"
block|,
literal|2
block|,
literal|"struct"
block|,
literal|3
block|,
literal|"default"
block|,
literal|2
block|,
literal|"int"
block|,
literal|4
block|,
literal|"char"
block|,
literal|4
block|,
literal|"float"
block|,
literal|4
block|,
literal|"double"
block|,
literal|4
block|,
literal|"long"
block|,
literal|4
block|,
literal|"short"
block|,
literal|4
block|,
literal|"typdef"
block|,
literal|4
block|,
literal|"unsigned"
block|,
literal|4
block|,
literal|"register"
block|,
literal|4
block|,
literal|"static"
block|,
literal|4
block|,
literal|"global"
block|,
literal|4
block|,
literal|"extern"
block|,
literal|4
block|,
literal|"if"
block|,
literal|5
block|,
literal|"while"
block|,
literal|5
block|,
literal|"for"
block|,
literal|5
block|,
literal|"else"
block|,
literal|6
block|,
literal|"do"
block|,
literal|6
block|,
literal|"sizeof"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|chartype
index|[
literal|128
index|]
init|=
block|{
comment|/* this is used to facilitate the decision of what type 		      (alphanumeric, operator) each character is */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|last_nl
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* this is true if the last thing scanned was a newline */
end_comment

begin_function
name|int
name|lexi
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|tok
decl_stmt|;
comment|/* local pointer to next char in token */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* local loop counter */
specifier|register
name|char
modifier|*
name|j
decl_stmt|;
comment|/* used for searching thru list of reserved words */
name|int
name|unary_delim
decl_stmt|;
comment|/* this is set to 1 if the current token forces a following operator to be     unary */
specifier|static
name|int
name|last_code
decl_stmt|;
comment|/* the last token type returned */
specifier|static
name|int
name|l_struct
decl_stmt|;
comment|/* set to 1 if the last token was 'struct' */
name|int
name|found_it
decl_stmt|;
name|int
name|code
decl_stmt|;
comment|/* internal code to be returned */
name|char
name|qchar
decl_stmt|;
comment|/* the delimiter character for a string */
name|tok
operator|=
name|token
expr_stmt|;
comment|/* point to start of place to save token */
name|unary_delim
operator|=
name|false
expr_stmt|;
name|col_1
operator|=
name|last_nl
expr_stmt|;
comment|/* tell world that this token started in column 			          1 iff the last thing scanned was nl */
name|last_nl
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|*
name|buf_ptr
operator|==
literal|' '
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\t'
condition|)
block|{
comment|/* get rid of blanks */
name|col_1
operator|=
name|false
expr_stmt|;
comment|/* leading blanks imply token is not in column 1 			          */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
comment|/*----------------------------------------------------------*\  |    Scan an alphanumeric token \*----------------------------------------------------------*/
if|if
condition|(
name|chartype
index|[
operator|*
name|buf_ptr
operator|&
literal|0177
index|]
operator|==
name|alphanum
condition|)
block|{
comment|/* we have a character or number */
while|while
condition|(
name|chartype
index|[
operator|*
name|buf_ptr
operator|&
literal|0177
index|]
operator|==
name|alphanum
condition|)
block|{
comment|/* copy it over */
operator|*
name|tok
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
operator|*
name|tok
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|l_struct
condition|)
block|{
comment|/* if last token was 'struct', then this token 			          should be treated as a declaration */
name|l_struct
operator|=
name|false
expr_stmt|;
name|last_code
operator|=
name|ident
expr_stmt|;
name|last_u_d
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|decl
operator|)
return|;
block|}
name|last_u_d
operator|=
name|false
expr_stmt|;
comment|/* operator after indentifier is binary */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|specials
index|[
name|i
index|]
operator|.
name|rwd
operator|!=
literal|0
condition|;
operator|++
name|i
control|)
block|{
comment|/* this loop will check if the token is a keyword.  if so, a following 	   operator is unary */
name|last_code
operator|=
name|ident
expr_stmt|;
comment|/* remember that this is the code we will return 			          */
name|j
operator|=
name|specials
index|[
name|i
index|]
operator|.
name|rwd
expr_stmt|;
comment|/* point at ith reserved word */
name|tok
operator|=
name|token
expr_stmt|;
comment|/* point at scanned toekn */
name|found_it
operator|=
name|true
expr_stmt|;
comment|/* set to false if not found */
do|do
block|{
if|if
condition|(
operator|*
name|tok
operator|++
operator|!=
operator|*
name|j
condition|)
block|{
name|found_it
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|*
name|j
operator|++
condition|)
do|;
if|if
condition|(
name|found_it
condition|)
block|{
comment|/* we have a keyword */
name|last_u_d
operator|=
name|true
expr_stmt|;
switch|switch
condition|(
name|specials
index|[
name|i
index|]
operator|.
name|rwcode
condition|)
block|{
case|case
literal|1
case|:
comment|/* it is a switch */
return|return
operator|(
name|swstmt
operator|)
return|;
case|case
literal|2
case|:
comment|/* a case or default */
return|return
operator|(
name|casestmt
operator|)
return|;
case|case
literal|3
case|:
comment|/* a "struct" */
name|l_struct
operator|=
name|true
expr_stmt|;
comment|/* Next time around, we will want to know that we have had 		       a 'struct' */
case|case
literal|4
case|:
comment|/* one of the declaration keywords */
if|if
condition|(
name|p_l_follow
condition|)
break|break;
comment|/* inside parens: cast */
name|last_code
operator|=
name|decl
expr_stmt|;
return|return
operator|(
name|decl
operator|)
return|;
case|case
literal|5
case|:
comment|/* if, while, for */
return|return
operator|(
name|sp_paren
operator|)
return|;
case|case
literal|6
case|:
comment|/* do, else */
return|return
operator|(
name|sp_nparen
operator|)
return|;
default|default:
comment|/* all others are treated like any other 			          identifier */
return|return
operator|(
name|ident
operator|)
return|;
block|}
comment|/* end of switch */
block|}
comment|/* end of if (found_it) */
block|}
if|if
condition|(
name|last_code
operator|==
name|decl
condition|)
comment|/* if this is a declared variable, then 			          following sign is unary */
name|last_u_d
operator|=
name|true
expr_stmt|;
comment|/* will make "int a -1" work */
name|last_code
operator|=
name|ident
expr_stmt|;
return|return
operator|(
name|ident
operator|)
return|;
comment|/* the ident is not in the list */
block|}
comment|/* end of procesing for alpanum character */
comment|/*----------------------------------------------------------*\  |   Scan a non-alphanumeric token \*----------------------------------------------------------*/
operator|*
name|tok
operator|++
operator|=
operator|*
name|buf_ptr
expr_stmt|;
comment|/* if it is only a one-character token, it is 			          moved here */
operator|*
name|tok
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|token
condition|)
block|{
case|case
literal|'\n'
case|:
name|unary_delim
operator|=
name|last_u_d
expr_stmt|;
name|last_nl
operator|=
name|true
expr_stmt|;
comment|/* remember that we just had a newline */
name|code
operator|=
operator|(
name|had_eof
condition|?
literal|0
else|:
name|newline
operator|)
expr_stmt|;
comment|/* if data has been exausted, the newline is a dummy, and we should 	   return code to stop */
break|break;
case|case
literal|'\''
case|:
comment|/* start of quoted character */
name|qchar
operator|=
literal|'\''
expr_stmt|;
comment|/* remember final delimiter */
goto|goto
name|copy_lit
goto|;
comment|/* and go to common literal code */
case|case
literal|'"'
case|:
comment|/* start of string */
name|qchar
operator|=
literal|'"'
expr_stmt|;
name|copy_lit
label|:
do|do
block|{
comment|/* copy the string */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* move one character or [/<char>]<char> */
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'\n'
condition|)
block|{
comment|/* check for unterminated literal */
name|printf
argument_list|(
literal|"%d: Unterminated literal\n"
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
goto|goto
name|stop_lit
goto|;
comment|/* Don't copy any more */
block|}
operator|*
name|tok
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|had_eof
operator|||
operator|(
operator|(
name|tok
operator|-
name|token
operator|)
operator|>
operator|(
name|bufsize
operator|-
literal|2
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Unterminated literal\n"
argument_list|)
expr_stmt|;
operator|++
name|tok
expr_stmt|;
goto|goto
name|stop_lit
goto|;
comment|/* get outof literal copying loop */
block|}
if|if
condition|(
operator|*
name|tok
operator|==
literal|'\\'
condition|)
block|{
comment|/* if escape, copy extra char */
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'\n'
condition|)
comment|/* check for escaped newline */
operator|++
name|line_no
expr_stmt|;
operator|*
operator|(
operator|++
name|tok
operator|)
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
operator|++
name|tok
expr_stmt|;
comment|/* we must increment this again because we 			          copied two chars */
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
else|else
break|break;
comment|/* we copied one character */
block|}
comment|/* end of while (1) */
block|}
do|while
condition|(
operator|*
name|tok
operator|++
operator|!=
name|qchar
condition|)
do|;
name|stop_lit
label|:
name|code
operator|=
name|ident
expr_stmt|;
break|break;
case|case
operator|(
literal|'('
operator|)
case|:
case|case
operator|(
literal|'['
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|lparen
expr_stmt|;
break|break;
case|case
operator|(
literal|')'
operator|)
case|:
case|case
operator|(
literal|']'
operator|)
case|:
name|code
operator|=
name|rparen
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|unary_delim
operator|=
name|last_u_d
expr_stmt|;
name|code
operator|=
name|preesc
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|question
expr_stmt|;
break|break;
case|case
operator|(
literal|':'
operator|)
case|:
name|code
operator|=
name|colon
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
break|break;
case|case
operator|(
literal|';'
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|semicolon
expr_stmt|;
break|break;
case|case
operator|(
literal|'{'
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|lbrace
expr_stmt|;
break|break;
case|case
operator|(
literal|'}'
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|rbrace
expr_stmt|;
break|break;
case|case
literal|014
case|:
comment|/* a form feed */
name|unary_delim
operator|=
name|last_u_d
expr_stmt|;
name|last_nl
operator|=
name|true
expr_stmt|;
comment|/* remember this so we can set 'col_1' right */
name|code
operator|=
name|form_feed
expr_stmt|;
break|break;
case|case
operator|(
literal|','
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|comma
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|unary_delim
operator|=
name|false
expr_stmt|;
name|code
operator|=
name|period
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
case|case
literal|'+'
case|:
comment|/* check for -, +, --, ++ */
name|code
operator|=
operator|(
name|last_u_d
condition|?
name|unary_op
else|:
name|binary_op
operator|)
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
name|token
index|[
literal|0
index|]
condition|)
block|{
comment|/* check for doubled character */
operator|*
name|tok
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
comment|/* buffer overflow will be checked at end of loop */
if|if
condition|(
name|last_code
operator|==
name|ident
operator|||
name|last_code
operator|==
name|rparen
condition|)
block|{
name|code
operator|=
operator|(
name|last_u_d
condition|?
name|unary_op
else|:
name|postop
operator|)
expr_stmt|;
comment|/* check for following ++ or -- */
name|unary_delim
operator|=
name|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'>'
operator|||
operator|*
name|buf_ptr
operator|==
literal|'='
condition|)
comment|/* check for operator -> or += */
operator|*
name|tok
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
comment|/* buffer overflow will be checked at end of switch */
break|break;
case|case
literal|'='
case|:
if|if
condition|(
name|chartype
index|[
operator|*
name|buf_ptr
index|]
operator|==
name|opchar
condition|)
block|{
comment|/* we have two char assignment */
operator|*
name|tok
operator|++
operator|=
operator|*
name|buf_ptr
expr_stmt|;
comment|/* move second character */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
name|code
operator|=
name|binary_op
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|token
index|[
literal|1
index|]
operator|!=
literal|'<'
operator|&&
name|token
index|[
literal|1
index|]
operator|!=
literal|'>'
condition|)
comment|/* check for possible 3 char operator */
break|break;
comment|/* can drop thru!!! */
case|case
literal|'>'
case|:
case|case
literal|'<'
case|:
case|case
literal|'!'
case|:
comment|/* ops like<,<<,<=, !=, etc */
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'>'
operator|||
operator|*
name|buf_ptr
operator|==
literal|'<'
operator|||
operator|*
name|buf_ptr
operator|==
literal|'='
condition|)
block|{
operator|*
name|tok
operator|++
operator|=
operator|*
name|buf_ptr
expr_stmt|;
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'='
condition|)
operator|*
name|tok
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
name|code
operator|=
operator|(
name|last_u_d
condition|?
name|unary_op
else|:
name|binary_op
operator|)
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|token
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
operator|*
name|buf_ptr
operator|==
literal|'*'
condition|)
block|{
comment|/* it is start of comment */
operator|*
name|tok
operator|++
operator|=
literal|'*'
expr_stmt|;
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
name|code
operator|=
name|comment
expr_stmt|;
name|unary_delim
operator|=
name|last_u_d
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|*
operator|(
name|tok
operator|-
literal|1
operator|)
operator|==
operator|*
name|buf_ptr
operator|||
operator|*
name|buf_ptr
operator|==
literal|'='
condition|)
block|{
comment|/* handle ||,&&, etc, and also things as in int *****i */
operator|*
name|tok
operator|++
operator|=
operator|*
name|buf_ptr
expr_stmt|;
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
name|code
operator|=
operator|(
name|last_u_d
condition|?
name|unary_op
else|:
name|binary_op
operator|)
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
block|}
comment|/* end of switch */
if|if
condition|(
name|code
operator|!=
name|newline
condition|)
block|{
name|l_struct
operator|=
name|false
expr_stmt|;
name|last_code
operator|=
name|code
expr_stmt|;
block|}
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
comment|/* check for input buffer empty */
name|fill_buffer
argument_list|()
expr_stmt|;
name|last_u_d
operator|=
name|unary_delim
expr_stmt|;
operator|*
name|tok
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminate the token */
return|return
operator|(
name|code
operator|)
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

end_unit

