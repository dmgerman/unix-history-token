begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"defs"
end_include

begin_comment
comment|/* basic simplifying procedure */
end_comment

begin_function
name|ptr
name|simple
parameter_list|(
name|t
parameter_list|,
name|e
parameter_list|)
name|int
name|t
decl_stmt|;
comment|/* take on the values LVAL, RVAL, and SUBVAL */
specifier|register
name|ptr
name|e
decl_stmt|;
comment|/* points to an expression */
block|{
name|int
name|tag
decl_stmt|,
name|subtype
decl_stmt|;
name|ptr
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|int
name|ltag
decl_stmt|;
name|int
name|lsubt
decl_stmt|;
name|ptr
name|p
decl_stmt|,
name|e1
decl_stmt|;
name|ptr
name|exio
argument_list|()
decl_stmt|,
name|exioop
argument_list|()
decl_stmt|,
name|dblop
argument_list|()
decl_stmt|,
name|setfield
argument_list|()
decl_stmt|,
name|gentemp
argument_list|()
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|;
name|top
label|:
if|if
condition|(
name|e
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tag
operator|=
name|e
operator|->
name|tag
expr_stmt|;
name|subtype
operator|=
name|e
operator|->
name|subtype
expr_stmt|;
if|if
condition|(
name|lp
operator|=
name|e
operator|->
name|leftp
condition|)
block|{
name|ltag
operator|=
name|lp
operator|->
name|tag
expr_stmt|;
name|lsubt
operator|=
name|lp
operator|->
name|subtype
expr_stmt|;
block|}
name|rp
operator|=
name|e
operator|->
name|rightp
expr_stmt|;
name|TEST
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"simple(%d; tag %d,%d)\n"
argument_list|,
name|t
argument_list|,
name|tag
argument_list|,
name|subtype
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|TNOTOP
case|:
switch|switch
condition|(
name|ltag
condition|)
block|{
case|case
name|TNOTOP
case|:
comment|/* not not = yes */
name|frexpblock
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|lp
operator|->
name|leftp
expr_stmt|;
name|frexpblock
argument_list|(
name|lp
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
case|case
name|TLOGOP
case|:
comment|/* de Morgan's Law */
name|lp
operator|->
name|subtype
operator|=
operator|(
name|OPOR
operator|+
name|OPAND
operator|)
operator|-
name|lp
operator|->
name|subtype
expr_stmt|;
name|lp
operator|->
name|leftp
operator|=
name|mknode
argument_list|(
name|TNOTOP
argument_list|,
name|OPNOT
argument_list|,
name|lp
operator|->
name|leftp
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|lp
operator|->
name|rightp
operator|=
name|mknode
argument_list|(
name|TNOTOP
argument_list|,
name|OPNOT
argument_list|,
name|lp
operator|->
name|rightp
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|frexpblock
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|lp
expr_stmt|;
goto|goto
name|top
goto|;
case|case
name|TRELOP
case|:
comment|/* reverse the condition */
name|lp
operator|->
name|subtype
operator|=
operator|(
name|OPEQ
operator|+
name|OPNE
operator|)
operator|-
name|lp
operator|->
name|subtype
expr_stmt|;
name|frexpblock
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|lp
expr_stmt|;
goto|goto
name|top
goto|;
case|case
name|TCALL
case|:
case|case
name|TASGNOP
case|:
name|e
operator|->
name|leftp
operator|=
name|simple
argument_list|(
name|RVAL
argument_list|,
name|lp
argument_list|)
expr_stmt|;
case|case
name|TNAME
case|:
case|case
name|TFTNBLOCK
case|:
name|lp
operator|=
name|simple
argument_list|(
name|RVAL
argument_list|,
name|lp
argument_list|)
expr_stmt|;
case|case
name|TTEMP
case|:
if|if
condition|(
name|t
operator|==
name|LVAL
condition|)
name|e
operator|=
name|simple
argument_list|(
name|LVAL
argument_list|,
name|mknode
argument_list|(
name|TASGNOP
argument_list|,
literal|0
argument_list|,
name|gentemp
argument_list|(
name|e
operator|->
name|leftp
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCONST
case|:
if|if
condition|(
name|equals
argument_list|(
name|lp
operator|->
name|leftp
argument_list|,
literal|".false."
argument_list|)
condition|)
name|e
operator|->
name|leftp
operator|=
name|copys
argument_list|(
literal|".true."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|equals
argument_list|(
name|lp
operator|->
name|leftp
argument_list|,
literal|".true."
argument_list|)
condition|)
name|e
operator|->
name|leftp
operator|=
name|copys
argument_list|(
literal|".false."
argument_list|)
expr_stmt|;
else|else
goto|goto
name|typerr
goto|;
name|e
operator|->
name|tag
operator|=
name|TCONST
expr_stmt|;
name|e
operator|->
name|subtype
operator|=
literal|0
expr_stmt|;
name|cfree
argument_list|(
name|lp
operator|->
name|leftp
argument_list|)
expr_stmt|;
name|frexpblock
argument_list|(
name|lp
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|typerr
goto|;
block|}
break|break;
case|case
name|TLOGOP
case|:
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|OPOR
case|:
case|case
name|OPAND
case|:
goto|goto
name|binop
goto|;
case|case
name|OP2OR
case|:
case|case
name|OP2AND
case|:
name|lp
operator|=
name|e
operator|->
name|leftp
operator|=
name|simple
argument_list|(
name|RVAL
argument_list|,
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|tag
operator|!=
name|TTEMP
condition|)
name|lp
operator|=
name|simple
argument_list|(
name|RVAL
argument_list|,
name|mknode
argument_list|(
name|TASGNOP
argument_list|,
literal|0
argument_list|,
name|gent
argument_list|(
name|TYLOG
argument_list|,
literal|0
argument_list|)
argument_list|,
name|lp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|simple
argument_list|(
name|LVAL
argument_list|,
name|mknode
argument_list|(
name|TASGNOP
argument_list|,
name|subtype
argument_list|,
name|lp
argument_list|,
name|rp
argument_list|)
argument_list|)
operator|)
return|;
default|default:
name|fatal
argument_list|(
literal|"impossible logical operator"
argument_list|)
expr_stmt|;
block|}
case|case
name|TNEGOP
case|:
name|lp
operator|=
name|e
operator|->
name|leftp
operator|=
name|simple
argument_list|(
name|RVAL
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|ltag
operator|=
name|lp
operator|->
name|tag
expr_stmt|;
name|lsubt
operator|=
name|lp
operator|->
name|subtype
expr_stmt|;
if|if
condition|(
name|ltag
operator|==
name|TNEGOP
condition|)
block|{
name|frexpblock
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|lp
operator|->
name|leftp
expr_stmt|;
name|frexpblock
argument_list|(
name|lp
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
else|else
goto|goto
name|lvcheck
goto|;
case|case
name|TAROP
case|:
case|case
name|TRELOP
case|:
name|binop
label|:
name|e
operator|->
name|leftp
operator|=
name|simple
argument_list|(
name|RVAL
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|lp
operator|=
name|e
operator|->
name|leftp
expr_stmt|;
name|ltag
operator|=
name|lp
operator|->
name|tag
expr_stmt|;
name|lsubt
operator|=
name|lp
operator|->
name|subtype
expr_stmt|;
name|e
operator|->
name|rightp
operator|=
name|simple
argument_list|(
name|RVAL
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|rp
operator|=
name|e
operator|->
name|rightp
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|TAROP
operator|&&
name|isicon
argument_list|(
name|rp
argument_list|,
operator|&
name|b
argument_list|)
condition|)
block|{
comment|/* simplify a*1, a/1 , a+0, a-0  */
if|if
condition|(
operator|(
operator|(
name|subtype
operator|==
name|OPSTAR
operator|||
name|subtype
operator|==
name|OPSLASH
operator|)
operator|&&
name|b
operator|==
literal|1
operator|)
operator|||
operator|(
operator|(
name|subtype
operator|==
name|OPPLUS
operator|||
name|subtype
operator|==
name|OPMINUS
operator|)
operator|&&
name|b
operator|==
literal|0
operator|)
condition|)
block|{
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|mvexpr
argument_list|(
name|lp
argument_list|,
name|e
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|isicon
argument_list|(
name|lp
argument_list|,
operator|&
name|a
argument_list|)
condition|)
comment|/* try folding const op const */
block|{
name|e1
operator|=
name|fold
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|!=
name|e
operator|||
name|e1
operator|->
name|tag
operator|!=
name|TAROP
condition|)
block|{
name|e
operator|=
name|e1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
block|}
if|if
condition|(
name|ltag
operator|==
name|TAROP
operator|&&
name|lp
operator|->
name|needpar
operator|==
literal|0
operator|&&
name|isicon
argument_list|(
name|lp
operator|->
name|rightp
argument_list|,
operator|&
name|a
argument_list|)
condition|)
block|{
comment|/* look for cases of (e op const ) op' const */
if|if
condition|(
operator|(
name|subtype
operator|==
name|OPPLUS
operator|||
name|subtype
operator|==
name|OPMINUS
operator|)
operator|&&
operator|(
name|lsubt
operator|==
name|OPPLUS
operator|||
name|lsubt
operator|==
name|OPMINUS
operator|)
condition|)
block|{
comment|/*  (e +- const) +- const */
name|c
operator|=
operator|(
name|subtype
operator|==
name|OPPLUS
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
operator|*
name|b
operator|+
operator|(
name|lsubt
operator|==
name|OPPLUS
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
operator|*
name|a
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
condition|)
name|subtype
operator|=
name|OPPLUS
expr_stmt|;
else|else
block|{
name|subtype
operator|=
name|OPMINUS
expr_stmt|;
name|c
operator|=
operator|-
name|c
expr_stmt|;
block|}
name|fixexpr
label|:
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|lp
operator|->
name|rightp
argument_list|)
expr_stmt|;
name|frexpblock
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|lp
expr_stmt|;
name|e
operator|->
name|subtype
operator|=
name|subtype
expr_stmt|;
name|e
operator|->
name|rightp
operator|=
name|mkint
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
elseif|else
if|if
condition|(
name|lsubt
operator|==
name|OPSTAR
operator|&&
operator|(
operator|(
name|subtype
operator|==
name|OPSTAR
operator|)
operator|||
operator|(
name|subtype
operator|==
name|OPSLASH
operator|&&
name|a
operator|%
name|b
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* (e * const ) (* or /) const */
name|c
operator|=
operator|(
name|subtype
operator|==
name|OPSTAR
condition|?
name|a
operator|*
name|b
else|:
name|a
operator|/
name|b
operator|)
expr_stmt|;
name|subtype
operator|=
name|OPSTAR
expr_stmt|;
goto|goto
name|fixexpr
goto|;
block|}
block|}
if|if
condition|(
name|ltag
operator|==
name|TAROP
operator|&&
operator|(
name|lsubt
operator|==
name|OPPLUS
operator|||
name|lsubt
operator|==
name|OPMINUS
operator|)
operator|&&
name|subtype
operator|==
name|OPSLASH
operator|&&
name|divides
argument_list|(
name|lp
argument_list|,
name|conval
argument_list|(
name|rp
argument_list|)
argument_list|)
condition|)
block|{
name|e
operator|->
name|leftp
operator|=
name|mknode
argument_list|(
name|TAROP
argument_list|,
name|OPSLASH
argument_list|,
name|lp
operator|->
name|leftp
argument_list|,
name|cpexpr
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|rightp
operator|=
name|mknode
argument_list|(
name|TAROP
argument_list|,
name|OPSLASH
argument_list|,
name|lp
operator|->
name|rightp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|e
operator|->
name|subtype
operator|=
name|lsubt
expr_stmt|;
goto|goto
name|top
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|tag
operator|==
name|TRELOP
operator|&&
name|isicon
argument_list|(
name|lp
argument_list|,
operator|&
name|a
argument_list|)
operator|&&
name|isicon
argument_list|(
name|rp
argument_list|,
operator|&
name|b
argument_list|)
condition|)
block|{
name|e1
operator|=
name|fold
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|!=
name|e
operator|||
name|e1
operator|->
name|tag
operator|!=
name|TRELOP
condition|)
block|{
name|e
operator|=
name|e1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
block|}
name|lvcheck
label|:
if|if
condition|(
name|t
operator|==
name|LVAL
condition|)
name|e
operator|=
name|simple
argument_list|(
name|LVAL
argument_list|,
name|mknode
argument_list|(
name|TASGNOP
argument_list|,
literal|0
argument_list|,
name|gentemp
argument_list|(
name|e
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
name|SUBVAL
condition|)
block|{
comment|/* test for legal Fortran c*v +-c  form */
if|if
condition|(
name|tag
operator|==
name|TAROP
operator|&&
operator|(
name|subtype
operator|==
name|OPPLUS
operator|||
name|subtype
operator|==
name|OPMINUS
operator|)
condition|)
if|if
condition|(
name|rp
operator|->
name|tag
operator|==
name|TCONST
operator|&&
name|rp
operator|->
name|vtype
operator|==
name|TYINT
condition|)
block|{
if|if
condition|(
operator|!
name|cvform
argument_list|(
name|lp
argument_list|)
condition|)
name|e
operator|->
name|leftp
operator|=
name|simple
argument_list|(
name|SUBVAL
argument_list|,
name|lp
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|makesub
goto|;
elseif|else
if|if
condition|(
operator|!
name|cvform
argument_list|(
name|e
argument_list|)
condition|)
goto|goto
name|makesub
goto|;
block|}
break|break;
case|case
name|TCALL
case|:
if|if
condition|(
name|lp
operator|->
name|tag
operator|!=
name|TFTNBLOCK
operator|&&
name|ioop
argument_list|(
name|lp
operator|->
name|sthead
operator|->
name|namep
argument_list|)
condition|)
block|{
name|e
operator|=
name|exioop
argument_list|(
name|e
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|exlab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|e
operator|->
name|rightp
operator|=
name|simple
argument_list|(
name|RVAL
argument_list|,
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|SUBVAL
condition|)
goto|goto
name|makesub
goto|;
if|if
condition|(
name|t
operator|==
name|LVAL
condition|)
name|e
operator|=
name|simple
argument_list|(
name|RVAL
argument_list|,
name|mknode
argument_list|(
name|TASGNOP
argument_list|,
literal|0
argument_list|,
name|gentemp
argument_list|(
name|e
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TNAME
case|:
if|if
condition|(
name|e
operator|->
name|voffset
condition|)
name|fixsubs
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|vsubs
condition|)
name|e
operator|->
name|vsubs
operator|=
name|simple
argument_list|(
name|SUBVAL
argument_list|,
name|e
operator|->
name|vsubs
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|SUBVAL
operator|&&
operator|!
name|vform
argument_list|(
name|e
argument_list|)
condition|)
goto|goto
name|makesub
goto|;
case|case
name|TTEMP
case|:
case|case
name|TFTNBLOCK
case|:
case|case
name|TCONST
case|:
if|if
condition|(
name|t
operator|==
name|SUBVAL
operator|&&
name|e
operator|->
name|vtype
operator|!=
name|TYINT
condition|)
goto|goto
name|makesub
goto|;
break|break;
case|case
name|TASGNOP
case|:
name|lp
operator|=
name|e
operator|->
name|leftp
operator|=
name|simple
argument_list|(
name|LVAL
argument_list|,
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|OP2OR
operator|||
name|subtype
operator|==
name|OP2AND
condition|)
name|e
operator|=
name|dblop
argument_list|(
name|e
argument_list|)
expr_stmt|;
else|else
block|{
name|rp
operator|=
name|e
operator|->
name|rightp
operator|=
name|simple
argument_list|(
name|RVAL
argument_list|,
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|vtype
operator|==
name|TYCHAR
condition|)
name|excall
argument_list|(
name|mkcall
argument_list|(
name|mkftnblock
argument_list|(
name|TYSUBR
argument_list|,
literal|"ef1asc"
argument_list|)
argument_list|,
name|arg4
argument_list|(
name|cpexpr
argument_list|(
name|lp
argument_list|)
argument_list|,
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|vtype
operator|==
name|TYSTRUCT
condition|)
block|{
if|if
condition|(
name|lp
operator|->
name|vtypep
operator|->
name|strsize
operator|!=
name|rp
operator|->
name|vtypep
operator|->
name|strsize
condition|)
name|fatal
argument_list|(
literal|"simple: attempt to assign incompatible structures"
argument_list|)
expr_stmt|;
name|e1
operator|=
name|mkchain
argument_list|(
name|cpexpr
argument_list|(
name|lp
argument_list|)
argument_list|,
name|mkchain
argument_list|(
name|rp
argument_list|,
name|mkchain
argument_list|(
name|mkint
argument_list|(
name|lp
operator|->
name|vtypep
operator|->
name|strsize
argument_list|)
argument_list|,
name|CHNULL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|excall
argument_list|(
name|mkcall
argument_list|(
name|mkftnblock
argument_list|(
name|TYSUBR
argument_list|,
literal|"ef1ass"
argument_list|)
argument_list|,
name|mknode
argument_list|(
name|TLIST
argument_list|,
literal|0
argument_list|,
name|e1
argument_list|,
name|PNULL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lp
operator|->
name|vtype
operator|==
name|TYFIELD
condition|)
name|lp
operator|=
name|setfield
argument_list|(
name|e
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|subtype
operator|!=
name|OPASGN
condition|)
comment|/* but is one of += etc */
block|{
name|rp
operator|=
name|e
operator|->
name|rightp
operator|=
name|simple
argument_list|(
name|RVAL
argument_list|,
name|mknode
argument_list|(
operator|(
name|subtype
operator|<=
name|OPPOWER
condition|?
name|TAROP
else|:
name|TLOGOP
operator|)
argument_list|,
name|subtype
argument_list|,
name|cpexpr
argument_list|(
name|e
operator|->
name|leftp
argument_list|)
argument_list|,
name|e
operator|->
name|rightp
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|subtype
operator|=
name|OPASGN
expr_stmt|;
block|}
name|exlab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|prexpr
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
name|frexpblock
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|lp
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|SUBVAL
condition|)
goto|goto
name|top
goto|;
block|}
break|break;
case|case
name|TLIST
case|:
for|for
control|(
name|p
operator|=
name|lp
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
name|p
operator|->
name|datap
operator|=
name|simple
argument_list|(
name|t
argument_list|,
name|p
operator|->
name|datap
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOSTAT
case|:
name|e
operator|=
name|exio
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|e
operator|)
return|;
name|typerr
label|:
name|exprerr
argument_list|(
literal|"type match error"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
name|makesub
label|:
if|if
condition|(
name|t
operator|==
name|SUBVAL
operator|&&
name|e
operator|->
name|vtype
operator|!=
name|TYINT
condition|)
name|warn1
argument_list|(
literal|"Line %d. Non-integer subscript"
argument_list|,
name|yylineno
argument_list|)
expr_stmt|;
return|return
operator|(
name|simple
argument_list|(
name|RVAL
argument_list|,
name|mknode
argument_list|(
name|TASGNOP
argument_list|,
literal|0
argument_list|,
name|gent
argument_list|(
name|TYINT
argument_list|,
name|PNULL
argument_list|)
argument_list|,
name|e
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|ptr
name|fold
parameter_list|(
name|e
parameter_list|)
specifier|register
name|ptr
name|e
decl_stmt|;
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|ptr
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|lp
operator|=
name|e
operator|->
name|leftp
expr_stmt|;
name|rp
operator|=
name|e
operator|->
name|rightp
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|tag
operator|!=
name|TCONST
operator|&&
name|lp
operator|->
name|tag
operator|!=
name|TNEGOP
condition|)
return|return
operator|(
name|e
operator|)
return|;
if|if
condition|(
name|rp
operator|->
name|tag
operator|!=
name|TCONST
operator|&&
name|rp
operator|->
name|tag
operator|!=
name|TNEGOP
condition|)
return|return
operator|(
name|e
operator|)
return|;
switch|switch
condition|(
name|e
operator|->
name|tag
condition|)
block|{
case|case
name|TAROP
case|:
if|if
condition|(
operator|!
name|isicon
argument_list|(
name|lp
argument_list|,
operator|&
name|a
argument_list|)
operator|||
operator|!
name|isicon
argument_list|(
name|rp
argument_list|,
operator|&
name|b
argument_list|)
condition|)
return|return
operator|(
name|e
operator|)
return|;
switch|switch
condition|(
name|e
operator|->
name|subtype
condition|)
block|{
case|case
name|OPPLUS
case|:
name|c
operator|=
name|a
operator|+
name|b
expr_stmt|;
break|break;
case|case
name|OPMINUS
case|:
name|c
operator|=
name|a
operator|-
name|b
expr_stmt|;
break|break;
case|case
name|OPSTAR
case|:
name|c
operator|=
name|a
operator|*
name|b
expr_stmt|;
break|break;
case|case
name|OPSLASH
case|:
if|if
condition|(
name|a
operator|%
name|b
operator|!=
literal|0
operator|&&
operator|(
name|a
operator|<
literal|0
operator|||
name|b
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|c
operator|=
name|a
operator|/
name|b
expr_stmt|;
break|break;
case|case
name|OPPOWER
case|:
return|return
operator|(
name|e
operator|)
return|;
default|default:
name|fatal
argument_list|(
literal|"fold: illegal binary operator"
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
return|return
operator|(
name|mkint
argument_list|(
name|c
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|mknode
argument_list|(
name|TNEGOP
argument_list|,
name|OPMINUS
argument_list|,
name|mkint
argument_list|(
operator|-
name|c
argument_list|)
argument_list|,
name|PNULL
argument_list|)
operator|)
return|;
case|case
name|TRELOP
case|:
if|if
condition|(
operator|!
name|isicon
argument_list|(
name|lp
argument_list|,
operator|&
name|a
argument_list|)
operator|||
operator|!
name|isicon
argument_list|(
name|rp
argument_list|,
operator|&
name|b
argument_list|)
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|frexpr
argument_list|(
name|e
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|subtype
condition|)
block|{
case|case
name|OPEQ
case|:
name|c
operator|=
name|a
operator|==
name|b
expr_stmt|;
break|break;
case|case
name|OPLT
case|:
name|c
operator|=
name|a
operator|<
name|b
expr_stmt|;
break|break;
case|case
name|OPGT
case|:
name|c
operator|=
name|a
operator|>
name|b
expr_stmt|;
break|break;
case|case
name|OPLE
case|:
name|c
operator|=
name|a
operator|<=
name|b
expr_stmt|;
break|break;
case|case
name|OPGE
case|:
name|c
operator|=
name|a
operator|>=
name|b
expr_stmt|;
break|break;
case|case
name|OPNE
case|:
name|c
operator|=
name|a
operator|!=
name|b
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"fold: invalid relational operator"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mkconst
argument_list|(
name|TYLOG
argument_list|,
operator|(
name|c
condition|?
literal|".true."
else|:
literal|".false."
operator|)
argument_list|)
operator|)
return|;
case|case
name|TLOGOP
case|:
if|if
condition|(
name|lp
operator|->
name|vtype
operator|!=
name|TYLOG
operator|||
name|rp
operator|->
name|vtype
operator|!=
name|TYLOG
condition|)
return|return
operator|(
name|e
operator|)
return|;
name|a
operator|=
name|equals
argument_list|(
name|lp
operator|->
name|leftp
argument_list|,
literal|".true."
argument_list|)
expr_stmt|;
name|b
operator|=
name|equals
argument_list|(
name|rp
operator|->
name|leftp
argument_list|,
literal|".true."
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|e
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|subtype
condition|)
block|{
case|case
name|OPAND
case|:
case|case
name|OP2AND
case|:
name|c
operator|=
name|a
operator|&
name|b
expr_stmt|;
break|break;
case|case
name|OPOR
case|:
case|case
name|OP2OR
case|:
name|c
operator|=
name|a
operator||
name|b
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"fold: invalid logical operator"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mkconst
argument_list|(
name|TYLOG
argument_list|,
operator|(
name|c
condition|?
literal|".true."
else|:
literal|".false"
operator|)
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|e
operator|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|TO
value|+ 100*
end_define

begin_function
name|ptr
name|coerce
parameter_list|(
name|t
parameter_list|,
name|e
parameter_list|)
comment|/* coerce expression  e  to type  t */
name|int
name|t
decl_stmt|;
specifier|register
name|ptr
name|e
decl_stmt|;
block|{
specifier|register
name|int
name|et
decl_stmt|;
name|int
name|econst
decl_stmt|;
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
name|ptr
name|conrep
argument_list|()
decl_stmt|,
name|xfixf
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|tag
operator|==
name|TNEGOP
condition|)
block|{
name|e
operator|->
name|leftp
operator|=
name|coerce
argument_list|(
name|t
argument_list|,
name|e
operator|->
name|leftp
argument_list|)
expr_stmt|;
goto|goto
name|settype
goto|;
block|}
name|et
operator|=
name|e
operator|->
name|vtype
expr_stmt|;
name|econst
operator|=
operator|(
name|e
operator|->
name|tag
operator|==
name|TCONST
operator|)
expr_stmt|;
name|TEST
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"coerce type %d to type %d\n"
argument_list|,
name|et
argument_list|,
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|et
condition|)
return|return
operator|(
name|e
operator|)
return|;
switch|switch
condition|(
name|et
name|TO
name|t
condition|)
block|{
case|case
name|TYCOMPLEX
name|TO
name|TYINT
case|:
case|case
name|TYLREAL
name|TO
name|TYINT
case|:
name|e
operator|=
name|coerce
argument_list|(
name|TYREAL
argument_list|,
name|e
argument_list|)
expr_stmt|;
case|case
name|TYREAL
name|TO
name|TYINT
case|:
if|if
condition|(
name|econst
condition|)
name|e
operator|=
name|xfixf
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|vtype
operator|!=
name|TYINT
condition|)
name|e
operator|=
name|mkcall
argument_list|(
name|builtin
argument_list|(
name|TYINT
argument_list|,
literal|"ifix"
argument_list|)
argument_list|,
name|arg1
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYINT
name|TO
name|TYREAL
case|:
if|if
condition|(
name|econst
condition|)
block|{
name|e
operator|->
name|leftp
operator|=
name|conrep
argument_list|(
name|e
operator|->
name|leftp
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
goto|goto
name|settype
goto|;
block|}
name|e
operator|=
name|mkcall
argument_list|(
name|builtin
argument_list|(
name|TYREAL
argument_list|,
literal|"float"
argument_list|)
argument_list|,
name|arg1
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYLREAL
name|TO
name|TYREAL
case|:
if|if
condition|(
name|econst
condition|)
block|{
for|for
control|(
name|s
operator|=
name|e
operator|->
name|leftp
init|;
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'d'
condition|;
operator|++
name|s
control|)
empty_stmt|;
operator|*
name|s
operator|=
literal|'e'
expr_stmt|;
goto|goto
name|settype
goto|;
block|}
name|e
operator|=
name|mkcall
argument_list|(
name|builtin
argument_list|(
name|TYREAL
argument_list|,
literal|"sngl"
argument_list|)
argument_list|,
name|arg1
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYCOMPLEX
name|TO
name|TYREAL
case|:
if|if
condition|(
name|econst
condition|)
block|{
name|s1
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|e
operator|->
name|leftp
operator|)
operator|+
literal|1
expr_stmt|;
name|s
operator|=
name|buff
expr_stmt|;
while|while
condition|(
operator|*
name|s1
operator|!=
literal|','
operator|&&
operator|*
name|s1
operator|!=
literal|'\0'
condition|)
operator|*
name|s1
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|cfree
argument_list|(
name|e
operator|->
name|leftp
argument_list|)
expr_stmt|;
name|e
operator|->
name|leftp
operator|=
name|copys
argument_list|(
name|buff
argument_list|)
expr_stmt|;
goto|goto
name|settype
goto|;
block|}
else|else
name|e
operator|=
name|mkcall
argument_list|(
name|mkftnblock
argument_list|(
name|TYREAL
argument_list|,
literal|"real"
argument_list|)
argument_list|,
name|arg1
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYINT
name|TO
name|TYLREAL
case|:
if|if
condition|(
name|econst
condition|)
block|{
name|e
operator|->
name|leftp
operator|=
name|conrep
argument_list|(
name|e
operator|->
name|leftp
argument_list|,
literal|"d0"
argument_list|)
expr_stmt|;
goto|goto
name|settype
goto|;
block|}
case|case
name|TYCOMPLEX
name|TO
name|TYLREAL
case|:
name|e
operator|=
name|coerce
argument_list|(
name|TYREAL
argument_list|,
name|e
argument_list|)
expr_stmt|;
case|case
name|TYREAL
name|TO
name|TYLREAL
case|:
if|if
condition|(
name|econst
condition|)
block|{
for|for
control|(
name|s
operator|=
name|e
operator|->
name|leftp
init|;
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'e'
condition|;
operator|++
name|s
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'e'
condition|)
operator|*
name|s
operator|=
literal|'d'
expr_stmt|;
else|else
name|e
operator|->
name|leftp
operator|=
name|conrep
argument_list|(
name|e
operator|->
name|leftp
argument_list|,
literal|"d0"
argument_list|)
expr_stmt|;
goto|goto
name|settype
goto|;
block|}
name|e
operator|=
name|mkcall
argument_list|(
name|builtin
argument_list|(
name|TYLREAL
argument_list|,
literal|"dble"
argument_list|)
argument_list|,
name|arg1
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYINT
name|TO
name|TYCOMPLEX
case|:
case|case
name|TYLREAL
name|TO
name|TYCOMPLEX
case|:
name|e
operator|=
name|coerce
argument_list|(
name|TYREAL
argument_list|,
name|e
argument_list|)
expr_stmt|;
case|case
name|TYREAL
name|TO
name|TYCOMPLEX
case|:
if|if
condition|(
name|e
operator|->
name|tag
operator|==
name|TCONST
condition|)
block|{
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"(%s,0.)"
argument_list|,
name|e
operator|->
name|leftp
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|e
operator|->
name|leftp
argument_list|)
expr_stmt|;
name|e
operator|->
name|leftp
operator|=
name|copys
argument_list|(
name|buff
argument_list|)
expr_stmt|;
goto|goto
name|settype
goto|;
block|}
else|else
name|e
operator|=
name|mkcall
argument_list|(
name|builtin
argument_list|(
name|TYCOMPLEX
argument_list|,
literal|"cmplx"
argument_list|)
argument_list|,
name|arg2
argument_list|(
name|e
argument_list|,
name|mkconst
argument_list|(
name|TYREAL
argument_list|,
literal|"0."
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|mismatch
goto|;
block|}
return|return
operator|(
name|e
operator|)
return|;
name|mismatch
label|:
name|exprerr
argument_list|(
literal|"impossible conversion"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
name|settype
label|:
name|e
operator|->
name|vtype
operator|=
name|t
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
end_function

begin_comment
comment|/* check whether expression is in form c, v, or v*c */
end_comment

begin_expr_stmt
name|cvform
argument_list|(
name|p
argument_list|)
specifier|register
name|ptr
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
return|return
operator|(
name|p
operator|->
name|vtype
operator|==
name|TYINT
operator|)
return|;
case|case
name|TNAME
case|:
return|return
operator|(
name|vform
argument_list|(
name|p
argument_list|)
operator|)
return|;
case|case
name|TAROP
case|:
if|if
condition|(
name|p
operator|->
name|subtype
operator|==
name|OPSTAR
operator|&&
name|p
operator|->
name|rightp
operator|->
name|tag
operator|==
name|TCONST
operator|&&
name|p
operator|->
name|rightp
operator|->
name|vtype
operator|==
name|TYINT
operator|&&
name|vform
argument_list|(
name|p
operator|->
name|leftp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/* is p a simple integer variable */
end_comment

begin_expr_stmt
name|vform
argument_list|(
name|p
argument_list|)
specifier|register
name|ptr
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|p
operator|->
name|tag
operator|==
name|TNAME
operator|&&
name|p
operator|->
name|vtype
operator|==
name|TYINT
operator|&&
name|p
operator|->
name|vdim
operator|==
literal|0
operator|&&
name|p
operator|->
name|voffset
operator|==
literal|0
operator|&&
name|p
operator|->
name|vsubs
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|ptr
name|dblop
parameter_list|(
name|p
parameter_list|)
name|ptr
name|p
decl_stmt|;
block|{
name|ptr
name|q
decl_stmt|;
name|bgnexec
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|subtype
operator|==
name|OP2OR
condition|)
name|q
operator|=
name|mknode
argument_list|(
name|TNOTOP
argument_list|,
name|OPNOT
argument_list|,
name|cpexpr
argument_list|(
name|p
operator|->
name|leftp
argument_list|)
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
else|else
name|q
operator|=
name|cpexpr
argument_list|(
name|p
operator|->
name|leftp
argument_list|)
expr_stmt|;
name|pushctl
argument_list|(
name|STIF
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|bgnexec
argument_list|()
expr_stmt|;
name|exasgn
argument_list|(
name|cpexpr
argument_list|(
name|p
operator|->
name|leftp
argument_list|)
argument_list|,
name|OPASGN
argument_list|,
name|p
operator|->
name|rightp
argument_list|)
expr_stmt|;
name|ifthen
argument_list|()
expr_stmt|;
name|popctl
argument_list|()
expr_stmt|;
name|addexec
argument_list|()
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|leftp
operator|)
return|;
block|}
end_function

begin_macro
name|divides
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|ptr
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|a
operator|->
name|vtype
operator|!=
name|TYINT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|a
operator|->
name|tag
condition|)
block|{
case|case
name|TNEGOP
case|:
return|return
operator|(
name|divides
argument_list|(
name|a
operator|->
name|leftp
argument_list|,
name|b
argument_list|)
operator|)
return|;
case|case
name|TCONST
case|:
return|return
operator|(
name|conval
argument_list|(
name|a
argument_list|)
operator|%
name|b
operator|==
literal|0
operator|)
return|;
case|case
name|TAROP
case|:
switch|switch
condition|(
name|a
operator|->
name|subtype
condition|)
block|{
case|case
name|OPPLUS
case|:
case|case
name|OPMINUS
case|:
return|return
operator|(
name|divides
argument_list|(
name|a
operator|->
name|leftp
argument_list|,
name|b
argument_list|)
operator|&&
name|divides
argument_list|(
name|a
operator|->
name|rightp
argument_list|,
name|b
argument_list|)
operator|)
return|;
case|case
name|OPSTAR
case|:
return|return
operator|(
name|divides
argument_list|(
name|a
operator|->
name|rightp
argument_list|,
name|b
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* truncate floating point constant to integer */
end_comment

begin_define
define|#
directive|define
name|MAXD
value|100
end_define

begin_function
name|ptr
name|xfixf
parameter_list|(
name|e
parameter_list|)
name|struct
name|exprblock
modifier|*
name|e
decl_stmt|;
block|{
name|char
name|digit
index|[
name|MAXD
operator|+
literal|1
index|]
decl_stmt|;
comment|/* buffer into which digits are placed */
name|char
modifier|*
name|first
decl_stmt|;
comment|/* points to first nonzero digit */
specifier|register
name|char
modifier|*
name|end
decl_stmt|;
comment|/* points at position past last digit */
specifier|register
name|char
modifier|*
name|dot
decl_stmt|;
comment|/* decimal point is immediately to left of this digit */
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|expon
decl_stmt|;
name|dot
operator|=
name|NULL
expr_stmt|;
name|end
operator|=
name|digit
expr_stmt|;
name|expon
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|e
operator|->
name|leftp
init|;
operator|*
name|s
condition|;
operator|++
name|s
control|)
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|end
operator|-
name|digit
operator|>
name|MAXD
condition|)
return|return
operator|(
name|e
operator|)
return|;
operator|*
name|end
operator|++
operator|=
operator|*
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
name|dot
operator|=
name|end
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'d'
operator|||
operator|*
name|s
operator|==
literal|'e'
condition|)
block|{
name|expon
operator|=
name|convci
argument_list|(
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|fatal1
argument_list|(
literal|"impossible character %d in floating constant"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|==
name|NULL
condition|)
name|dot
operator|=
name|end
expr_stmt|;
name|dot
operator|+=
name|expon
expr_stmt|;
if|if
condition|(
name|dot
operator|-
name|digit
operator|>
name|MAXD
condition|)
return|return
operator|(
name|e
operator|)
return|;
for|for
control|(
name|first
operator|=
name|digit
init|;
name|first
operator|<
name|end
operator|&&
operator|*
name|first
operator|==
literal|'0'
condition|;
operator|++
name|first
control|)
empty_stmt|;
if|if
condition|(
name|dot
operator|<=
name|first
condition|)
block|{
name|dot
operator|=
name|first
operator|+
literal|1
expr_stmt|;
operator|*
name|first
operator|=
literal|'0'
expr_stmt|;
block|}
else|else
while|while
condition|(
name|end
operator|<
name|dot
condition|)
operator|*
name|end
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|dot
operator|=
literal|'\0'
expr_stmt|;
name|cfree
argument_list|(
name|e
operator|->
name|leftp
argument_list|)
expr_stmt|;
name|e
operator|->
name|leftp
operator|=
name|copys
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|e
operator|->
name|vtype
operator|=
name|TYINT
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
end_function

end_unit

