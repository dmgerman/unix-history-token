begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"defs"
end_include

begin_define
define|#
directive|define
name|NHISTO
value|50
end_define

begin_decl_stmt
name|int
name|histo
index|[
name|NHISTO
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mem
index|[
name|MEMSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|nmemused
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|nmemavail
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|int
name|totalloc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|int
name|totfreed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nexpblocks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ptr
name|expblocks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nexcblocks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ptr
name|excblocks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ptr
name|chains
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ptr
name|alloc
argument_list|()
decl_stmt|,
name|calloc
argument_list|()
decl_stmt|,
name|malloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|ptr
name|intalloc
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|int
modifier|*
name|p
decl_stmt|;
comment|/*debug*/
if|if
condition|(
name|n
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|genblock
argument_list|)
condition|)
name|fatal1
argument_list|(
literal|"intalloc(%d)"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|n
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|memdump
condition|)
name|prmem
argument_list|()
expr_stmt|;
name|fatal1
argument_list|(
literal|"Line %d:  Cannot allocate memory"
argument_list|,
name|yylineno
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|ptr
name|calloc
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|int
name|m
decl_stmt|,
name|n
decl_stmt|;
block|{
return|return
operator|(
name|alloc
argument_list|(
name|m
operator|*
name|n
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ptr
name|malloc
parameter_list|(
name|m
parameter_list|)
name|int
name|m
decl_stmt|;
block|{
return|return
operator|(
name|alloc
argument_list|(
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Very stupid memory allocator.  Stores a count word before    each block; negative if idle, positive if busy.    Looks for a block big enough for current request, and splits it    if necessary.  Does not coalesce, always starts at bottom of memory.    Checks validity of all count words it encounters. */
end_comment

begin_function
name|ptr
name|alloc
parameter_list|(
name|k
parameter_list|)
specifier|register
name|int
name|k
decl_stmt|;
block|{
name|int
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|k
operator|=
operator|(
name|k
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<=
literal|0
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"alloc(%d words)\n"
argument_list|,
name|k
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|>=
name|NHISTO
condition|)
operator|++
name|histo
index|[
literal|0
index|]
expr_stmt|;
else|else
operator|++
name|histo
index|[
name|k
index|]
expr_stmt|;
name|totalloc
operator|+=
name|k
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|256
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"calloc(%d words)\n"
argument_list|,
name|k
argument_list|)
expr_stmt|;
comment|/* look for a large enough slot */
if|if
condition|(
name|nmemavail
operator|>
name|k
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmemused
condition|;
control|)
block|{
name|j
operator|=
name|mem
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|256
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Bad count word %d\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
goto|goto
name|die
goto|;
block|}
if|if
condition|(
name|j
operator|>=
literal|0
operator|||
operator|(
name|j
operator|=
operator|-
name|j
operator|)
operator|<
name|k
condition|)
name|i
operator|+=
operator|(
name|j
operator|+
literal|1
operator|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|j
operator|>
literal|256
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Bad count word %d\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
goto|goto
name|die
goto|;
block|}
name|mem
index|[
name|i
index|]
operator|=
name|k
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|k
condition|)
name|mem
index|[
name|i
operator|+
name|k
operator|+
literal|1
index|]
operator|=
operator|-
operator|(
name|j
operator|-
name|k
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
name|k
init|;
name|j
operator|>
name|i
condition|;
operator|--
name|j
control|)
name|mem
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|nmemavail
operator|-=
operator|(
name|k
operator|+
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|mem
operator|+
name|i
operator|+
literal|1
operator|)
return|;
block|}
block|}
comment|/* otherwise try to advance the fence */
name|mem
index|[
name|nmemused
index|]
operator|=
name|k
expr_stmt|;
name|p
operator|=
name|mem
operator|+
name|nmemused
operator|+
literal|1
expr_stmt|;
name|nmemused
operator|+=
operator|(
name|k
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|nmemused
operator|>=
name|MEMSIZE
condition|)
block|{
name|die
label|:
comment|/*debug*/
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Highwater mark %d words. "
argument_list|,
name|nmemused
argument_list|)
expr_stmt|;
comment|/*debug*/
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"%ld words left over\n"
argument_list|,
name|totalloc
operator|-
name|totfreed
argument_list|)
expr_stmt|;
comment|/*	prmem();	*/
name|fatal1
argument_list|(
literal|"Line %d:  out of memory"
argument_list|,
name|yylineno
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|cfree
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|ptr
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"cfree(0)"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|free
argument_list|(
name|p
argument_list|)
specifier|register
name|unsigned
name|int
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|<=
name|mem
operator|||
name|p
operator|>
name|mem
operator|+
name|nmemused
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"attempt to free an unallocated block,  "
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|>
literal|256
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"attempted to free a block of length %u\n"
argument_list|,
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|bad
label|:
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"location %o    "
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"mem=%o   lastused=%o\n"
argument_list|,
name|mem
argument_list|,
name|mem
operator|+
name|nmemused
argument_list|)
expr_stmt|;
comment|/*	if(p[-1]>256 || p[-1]<0)	*/
name|fatal
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|totfreed
operator|+=
name|p
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|nmemavail
operator|+=
name|p
index|[
operator|-
literal|1
index|]
operator|+
literal|1
expr_stmt|;
name|p
index|[
operator|-
literal|1
index|]
operator|=
operator|-
name|p
index|[
operator|-
literal|1
index|]
expr_stmt|;
empty_stmt|;
block|}
end_block

begin_macro
name|prhisto
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"allocation histogram:\n%4d big blocks\n"
argument_list|,
name|histo
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NHISTO
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|histo
index|[
name|i
index|]
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"%4d %2d-word blocks\n"
argument_list|,
name|histo
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|ptr
name|allexpblock
parameter_list|()
block|{
name|ptr
name|p
decl_stmt|;
if|if
condition|(
name|expblocks
condition|)
block|{
name|p
operator|=
name|expblocks
expr_stmt|;
name|expblocks
operator|=
name|expblocks
operator|->
name|leftp
expr_stmt|;
name|zeroout
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exprblock
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|nexpblocks
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
else|else
return|return
operator|(
name|ALLOC
argument_list|(
name|exprblock
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|frexpblock
argument_list|(
name|p
argument_list|)
specifier|register
name|ptr
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|exprblock
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
name|badtag
argument_list|(
literal|"frexpblock"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|nexpblocks
operator|<
name|EXPRPOOL
condition|)
block|{
name|p
operator|->
name|leftp
operator|=
name|expblocks
expr_stmt|;
name|p
operator|->
name|tag
operator|=
literal|0
expr_stmt|;
name|expblocks
operator|=
name|p
expr_stmt|;
operator|++
name|nexpblocks
expr_stmt|;
block|}
else|else
name|cfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|ptr
name|allexcblock
parameter_list|()
block|{
name|ptr
name|p
decl_stmt|;
if|if
condition|(
name|excblocks
condition|)
block|{
name|p
operator|=
name|excblocks
expr_stmt|;
name|excblocks
operator|=
name|excblocks
operator|->
name|leftp
expr_stmt|;
name|zeroout
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|execblock
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|nexcblocks
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
else|else
return|return
operator|(
name|ALLOC
argument_list|(
name|execblock
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|frexcblock
argument_list|(
name|p
argument_list|)
specifier|register
name|ptr
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|execblock
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
name|fatal1
argument_list|(
literal|"invalid frexcblock block of size %d"
argument_list|,
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nexcblocks
operator|<
name|EXECPOOL
condition|)
block|{
name|p
operator|->
name|leftp
operator|=
name|excblocks
expr_stmt|;
name|p
operator|->
name|tag
operator|=
literal|0
expr_stmt|;
name|excblocks
operator|=
name|p
expr_stmt|;
operator|++
name|nexcblocks
expr_stmt|;
block|}
else|else
name|cfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|zeroout
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
specifier|register
name|int
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|pn
decl_stmt|;
name|pn
operator|=
name|p
operator|+
operator|(
name|n
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|pn
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|frchain
argument_list|(
name|p0
argument_list|)
specifier|register
name|chainp
operator|*
name|p0
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|ptr
name|p
decl_stmt|;
if|if
condition|(
name|p0
operator|==
literal|0
operator|||
operator|*
name|p0
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|p
operator|=
operator|*
name|p0
init|;
name|p
operator|->
name|nextp
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
name|p
operator|->
name|datap
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|datap
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|nextp
operator|=
name|chains
expr_stmt|;
name|chains
operator|=
operator|*
name|p0
expr_stmt|;
operator|*
name|p0
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|chainp
name|mkchain
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
name|ptr
name|p
decl_stmt|,
name|q
decl_stmt|;
block|{
specifier|register
name|chainp
name|r
decl_stmt|;
if|if
condition|(
name|chains
condition|)
block|{
name|r
operator|=
name|chains
expr_stmt|;
name|chains
operator|=
name|chains
operator|->
name|nextp
expr_stmt|;
block|}
else|else
name|r
operator|=
name|ALLOC
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|r
operator|->
name|datap
operator|=
name|p
expr_stmt|;
name|r
operator|->
name|nextp
operator|=
name|q
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_macro
name|prmem
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Memory dump:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmemused
condition|;
control|)
block|{
name|j
operator|=
name|mem
index|[
name|i
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Loc %6o = Word %5d   "
argument_list|,
name|mem
operator|+
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Idle block length %4d   "
argument_list|,
name|j
operator|=
operator|-
name|j
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"Busy block length %4d   "
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"tag %3d"
argument_list|,
name|mem
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|tag
operator|==
name|TNAME
operator|&&
name|mem
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|sthead
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"   varname %s"
argument_list|,
name|mem
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|sthead
operator|->
name|namep
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|==
literal|2
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"  chain %o %o"
argument_list|,
name|mem
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|mem
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mem
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|tag
operator|>
name|TIOSTAT
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|sn
decl_stmt|;
name|s
operator|=
operator|&
name|mem
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|sn
operator|=
name|s
operator|+
literal|12
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"  \""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
name|s
operator|<
name|sn
condition|)
name|putc
argument_list|(
operator|*
name|s
operator|++
argument_list|,
name|diagfile
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|i
operator|+=
name|j
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_block

end_unit

