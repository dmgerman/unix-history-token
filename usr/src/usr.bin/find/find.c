begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)find.c	4.13 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_define
define|#
directive|define
name|A_DAY
value|86400L
end_define

begin_comment
comment|/* a day full of seconds */
end_comment

begin_define
define|#
directive|define
name|EQ
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(strcmp(x, y)==0)
end_define

begin_decl_stmt
name|int
name|Randlast
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Pathname
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXNODES
value|100
end_define

begin_struct
struct|struct
name|anode
block|{
name|int
function_decl|(
modifier|*
name|F
function_decl|)
parameter_list|()
function_decl|;
name|struct
name|anode
modifier|*
name|L
decl_stmt|,
modifier|*
name|R
decl_stmt|;
block|}
name|Node
index|[
name|MAXNODES
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|Nn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of nodes */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Fname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|Now
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Argc
decl_stmt|,
name|Ai
decl_stmt|,
name|Pi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|Argv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cpio stuff */
end_comment

begin_decl_stmt
name|int
name|Cpio
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|Buf
decl_stmt|,
modifier|*
name|Dbuf
decl_stmt|,
modifier|*
name|Wp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Bufsize
init|=
literal|5120
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Wct
init|=
literal|2560
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|Newer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Xdev
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if SHOULD cross devices (file systems) */
end_comment

begin_decl_stmt
name|struct
name|stat
name|Devstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stats of each argument path's file system */
end_comment

begin_decl_stmt
name|struct
name|stat
name|Statb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|anode
modifier|*
name|exp
argument_list|()
decl_stmt|,
modifier|*
name|e1
argument_list|()
decl_stmt|,
modifier|*
name|e2
argument_list|()
decl_stmt|,
modifier|*
name|e3
argument_list|()
decl_stmt|,
modifier|*
name|mk
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|nxtarg
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|Home
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|Blocks
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * SEE ALSO:	updatedb, bigram.c, code.c  *		Usenix ;login:, February/March, 1983, p. 8.  *  * REVISIONS: 	James A. Woods, Informatics General Corporation,  *		NASA Ames Research Center, 6/81.  *  *		The second form searches a pre-computed filelist  *		(constructed nightly by /usr/lib/crontab) which is  *		compressed by updatedb (v.i.z.)  The effect of  *			find<name>  *		is similar to  *			find / +0 -name "*<name>*" -print  *		but much faster.  *  *		8/82 faster yet + incorporation of bigram coding -- jaw  *  *		1/83 incorporate glob-style matching -- jaw  */
end_comment

begin_define
define|#
directive|define
name|AMES
value|1
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|struct
name|anode
modifier|*
name|exlist
decl_stmt|;
name|int
name|paths
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|sp
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SUID_PWD
name|FILE
modifier|*
name|pwd
decl_stmt|,
modifier|*
name|popen
argument_list|()
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AMES
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: find name, or find path-list predicate-list\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|fastfind
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|time
argument_list|(
operator|&
name|Now
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUID_PWD
name|pwd
operator|=
name|popen
argument_list|(
literal|"pwd"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|Home
argument_list|,
sizeof|sizeof
name|Home
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
name|Home
index|[
name|strlen
argument_list|(
name|Home
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|getwd
argument_list|(
name|Home
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: Can't get current working directory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|Argc
operator|=
name|argc
expr_stmt|;
name|Argv
operator|=
name|argv
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|usage
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: find path-list predicate-list\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Ai
operator|=
name|paths
operator|=
literal|1
init|;
name|Ai
operator|<
operator|(
name|argc
operator|-
literal|1
operator|)
condition|;
operator|++
name|Ai
operator|,
operator|++
name|paths
control|)
if|if
condition|(
operator|*
name|Argv
index|[
name|Ai
index|]
operator|==
literal|'-'
operator|||
name|EQ
argument_list|(
name|Argv
index|[
name|Ai
index|]
argument_list|,
literal|"("
argument_list|)
operator|||
name|EQ
argument_list|(
name|Argv
index|[
name|Ai
index|]
argument_list|,
literal|"!"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|paths
operator|==
literal|1
condition|)
comment|/* no path-list */
goto|goto
name|usage
goto|;
if|if
condition|(
operator|!
operator|(
name|exlist
operator|=
name|exp
argument_list|()
operator|)
condition|)
block|{
comment|/* parse and compile the arguments */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: parsing error\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Ai
operator|<
name|argc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: missing conjunction\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Pi
operator|=
literal|1
init|;
name|Pi
operator|<
name|paths
condition|;
operator|++
name|Pi
control|)
block|{
name|sp
operator|=
literal|0
expr_stmt|;
name|chdir
argument_list|(
name|Home
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|Pathname
argument_list|,
name|Argv
index|[
name|Pi
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|rindex
argument_list|(
name|Pathname
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
name|sp
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
operator|*
name|Pathname
condition|?
name|Pathname
else|:
literal|"/"
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: bad starting directory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
block|}
name|Fname
operator|=
name|sp
condition|?
name|sp
else|:
name|Pathname
expr_stmt|;
if|if
condition|(
operator|!
name|Xdev
condition|)
name|stat
argument_list|(
name|Pathname
argument_list|,
operator|&
name|Devstat
argument_list|)
expr_stmt|;
name|descend
argument_list|(
name|Pathname
argument_list|,
name|Fname
argument_list|,
name|exlist
argument_list|)
expr_stmt|;
comment|/* to find files that match  */
block|}
if|if
condition|(
name|Cpio
condition|)
block|{
name|strcpy
argument_list|(
name|Pathname
argument_list|,
literal|"TRAILER!!!"
argument_list|)
expr_stmt|;
name|Statb
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|cpio
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%D blocks\n"
argument_list|,
name|Blocks
operator|*
literal|10
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* compile time functions:  priority is  exp()<e1()<e2()<e3()  */
end_comment

begin_function
name|struct
name|anode
modifier|*
name|exp
parameter_list|()
block|{
comment|/* parse ALTERNATION (-o)  */
name|int
name|or
parameter_list|()
function_decl|;
specifier|register
name|struct
name|anode
modifier|*
name|p1
decl_stmt|;
name|p1
operator|=
name|e1
argument_list|()
comment|/* get left operand */
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|nxtarg
argument_list|()
argument_list|,
literal|"-o"
argument_list|)
condition|)
block|{
name|Randlast
operator|--
expr_stmt|;
return|return
operator|(
name|mk
argument_list|(
name|or
argument_list|,
name|p1
argument_list|,
name|exp
argument_list|()
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|Ai
operator|<=
name|Argc
condition|)
operator|--
name|Ai
expr_stmt|;
return|return
operator|(
name|p1
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|anode
modifier|*
name|e1
parameter_list|()
block|{
comment|/* parse CONCATENATION (formerly -a) */
name|int
name|and
parameter_list|()
function_decl|;
specifier|register
name|struct
name|anode
modifier|*
name|p1
decl_stmt|;
specifier|register
name|char
modifier|*
name|a
decl_stmt|;
name|p1
operator|=
name|e2
argument_list|()
expr_stmt|;
name|a
operator|=
name|nxtarg
argument_list|()
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-a"
argument_list|)
condition|)
block|{
name|And
label|:
name|Randlast
operator|--
expr_stmt|;
return|return
operator|(
name|mk
argument_list|(
name|and
argument_list|,
name|p1
argument_list|,
name|e1
argument_list|()
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"("
argument_list|)
operator|||
name|EQ
argument_list|(
name|a
argument_list|,
literal|"!"
argument_list|)
operator|||
operator|(
operator|*
name|a
operator|==
literal|'-'
operator|&&
operator|!
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-o"
argument_list|)
operator|)
condition|)
block|{
operator|--
name|Ai
expr_stmt|;
goto|goto
name|And
goto|;
block|}
elseif|else
if|if
condition|(
name|Ai
operator|<=
name|Argc
condition|)
operator|--
name|Ai
expr_stmt|;
return|return
operator|(
name|p1
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|anode
modifier|*
name|e2
parameter_list|()
block|{
comment|/* parse NOT (!) */
name|int
name|not
parameter_list|()
function_decl|;
if|if
condition|(
name|Randlast
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: operand follows operand\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Randlast
operator|++
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|nxtarg
argument_list|()
argument_list|,
literal|"!"
argument_list|)
condition|)
return|return
operator|(
name|mk
argument_list|(
name|not
argument_list|,
name|e3
argument_list|()
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|Ai
operator|<=
name|Argc
condition|)
operator|--
name|Ai
expr_stmt|;
return|return
operator|(
name|e3
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|anode
modifier|*
name|e3
parameter_list|()
block|{
comment|/* parse parens and predicates */
name|int
name|exeq
argument_list|()
decl_stmt|,
name|ok
argument_list|()
decl_stmt|,
name|glob
argument_list|()
decl_stmt|,
name|mtime
argument_list|()
decl_stmt|,
name|atime
argument_list|()
decl_stmt|,
name|user
argument_list|()
decl_stmt|,
name|group
argument_list|()
decl_stmt|,
name|size
argument_list|()
decl_stmt|,
name|perm
argument_list|()
decl_stmt|,
name|links
argument_list|()
decl_stmt|,
name|print
argument_list|()
decl_stmt|,
name|type
argument_list|()
decl_stmt|,
name|ino
argument_list|()
decl_stmt|,
name|cpio
argument_list|()
decl_stmt|,
name|newer
argument_list|()
decl_stmt|,
name|nouser
argument_list|()
decl_stmt|,
name|nogroup
argument_list|()
decl_stmt|,
name|ls
argument_list|()
decl_stmt|,
name|dummy
argument_list|()
decl_stmt|;
name|struct
name|anode
modifier|*
name|p1
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
name|s
decl_stmt|;
name|a
operator|=
name|nxtarg
argument_list|()
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"("
argument_list|)
condition|)
block|{
name|Randlast
operator|--
expr_stmt|;
name|p1
operator|=
name|exp
argument_list|()
expr_stmt|;
name|a
operator|=
name|nxtarg
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|a
argument_list|,
literal|")"
argument_list|)
condition|)
goto|goto
name|err
goto|;
return|return
operator|(
name|p1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-print"
argument_list|)
condition|)
block|{
return|return
operator|(
name|mk
argument_list|(
name|print
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-nouser"
argument_list|)
condition|)
block|{
return|return
operator|(
name|mk
argument_list|(
name|nouser
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-nogroup"
argument_list|)
condition|)
block|{
return|return
operator|(
name|mk
argument_list|(
name|nogroup
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-ls"
argument_list|)
condition|)
block|{
return|return
operator|(
name|mk
argument_list|(
name|ls
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-xdev"
argument_list|)
condition|)
block|{
name|Xdev
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|mk
argument_list|(
name|dummy
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
name|b
operator|=
name|nxtarg
argument_list|()
expr_stmt|;
name|s
operator|=
operator|*
name|b
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|'+'
condition|)
name|b
operator|++
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-name"
argument_list|)
condition|)
return|return
operator|(
name|mk
argument_list|(
name|glob
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|b
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-mtime"
argument_list|)
condition|)
return|return
operator|(
name|mk
argument_list|(
name|mtime
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|atoi
argument_list|(
name|b
argument_list|)
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-atime"
argument_list|)
condition|)
return|return
operator|(
name|mk
argument_list|(
name|atime
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|atoi
argument_list|(
name|b
argument_list|)
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-user"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|getuid
argument_list|(
name|b
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|gmatch
argument_list|(
name|b
argument_list|,
literal|"[0-9]*"
argument_list|)
condition|)
return|return
name|mk
argument_list|(
name|user
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|atoi
argument_list|(
name|b
argument_list|)
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: cannot find -user name\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mk
argument_list|(
name|user
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|i
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-inum"
argument_list|)
condition|)
return|return
operator|(
name|mk
argument_list|(
name|ino
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|atoi
argument_list|(
name|b
argument_list|)
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-group"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|getgid
argument_list|(
name|b
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|gmatch
argument_list|(
name|b
argument_list|,
literal|"[0-9]*"
argument_list|)
condition|)
return|return
name|mk
argument_list|(
name|group
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|atoi
argument_list|(
name|b
argument_list|)
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: cannot find -group name\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mk
argument_list|(
name|group
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|i
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-size"
argument_list|)
condition|)
return|return
operator|(
name|mk
argument_list|(
name|size
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|atoi
argument_list|(
name|b
argument_list|)
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-links"
argument_list|)
condition|)
return|return
operator|(
name|mk
argument_list|(
name|links
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|atoi
argument_list|(
name|b
argument_list|)
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-perm"
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|b
condition|;
operator|++
name|b
control|)
block|{
if|if
condition|(
operator|*
name|b
operator|==
literal|'-'
condition|)
continue|continue;
name|i
operator|<<=
literal|3
expr_stmt|;
name|i
operator|=
name|i
operator|+
operator|(
operator|*
name|b
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|mk
argument_list|(
name|perm
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|i
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|s
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-type"
argument_list|)
condition|)
block|{
name|i
operator|=
name|s
operator|==
literal|'d'
condition|?
name|S_IFDIR
else|:
name|s
operator|==
literal|'b'
condition|?
name|S_IFBLK
else|:
name|s
operator|==
literal|'c'
condition|?
name|S_IFCHR
else|:
name|s
operator|==
literal|'f'
condition|?
name|S_IFREG
else|:
name|s
operator|==
literal|'l'
condition|?
name|S_IFLNK
else|:
name|s
operator|==
literal|'s'
condition|?
name|S_IFSOCK
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|mk
argument_list|(
name|type
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|i
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-exec"
argument_list|)
condition|)
block|{
name|i
operator|=
name|Ai
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|EQ
argument_list|(
name|nxtarg
argument_list|()
argument_list|,
literal|";"
argument_list|)
condition|)
empty_stmt|;
return|return
operator|(
name|mk
argument_list|(
name|exeq
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|i
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-ok"
argument_list|)
condition|)
block|{
name|i
operator|=
name|Ai
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|EQ
argument_list|(
name|nxtarg
argument_list|()
argument_list|,
literal|";"
argument_list|)
condition|)
empty_stmt|;
return|return
operator|(
name|mk
argument_list|(
name|ok
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
name|i
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-cpio"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|Cpio
operator|=
name|creat
argument_list|(
name|b
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: cannot create< %s>\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Buf
operator|=
operator|(
name|short
operator|*
operator|)
name|sbrk
argument_list|(
literal|512
argument_list|)
expr_stmt|;
name|Wp
operator|=
name|Dbuf
operator|=
operator|(
name|short
operator|*
operator|)
name|sbrk
argument_list|(
literal|5120
argument_list|)
expr_stmt|;
return|return
operator|(
name|mk
argument_list|(
name|cpio
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|a
argument_list|,
literal|"-newer"
argument_list|)
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|b
argument_list|,
operator|&
name|Statb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: cannot access< %s>\n"
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Newer
operator|=
name|Statb
operator|.
name|st_mtime
expr_stmt|;
return|return
name|mk
argument_list|(
name|newer
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|anode
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
name|err
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: bad option< %s>\n"
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|anode
modifier|*
name|mk
argument_list|(
name|f
argument_list|,
name|l
argument_list|,
name|r
argument_list|)
name|int
argument_list|(
operator|*
name|f
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|anode
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Nn
operator|>=
name|MAXNODES
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: Too many options\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Node
index|[
name|Nn
index|]
operator|.
name|F
operator|=
name|f
expr_stmt|;
name|Node
index|[
name|Nn
index|]
operator|.
name|L
operator|=
name|l
expr_stmt|;
name|Node
index|[
name|Nn
index|]
operator|.
name|R
operator|=
name|r
expr_stmt|;
return|return
operator|(
operator|&
operator|(
name|Node
index|[
name|Nn
operator|++
index|]
operator|)
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|nxtarg
parameter_list|()
block|{
comment|/* get next arg from command line */
specifier|static
name|strikes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strikes
operator|==
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: incomplete statement\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Ai
operator|>=
name|Argc
condition|)
block|{
name|strikes
operator|++
expr_stmt|;
name|Ai
operator|=
name|Argc
operator|+
literal|1
expr_stmt|;
return|return
operator|(
literal|""
operator|)
return|;
block|}
return|return
operator|(
name|Argv
index|[
name|Ai
operator|++
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* execution time functions */
end_comment

begin_expr_stmt
name|and
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|anode
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
operator|(
call|(
modifier|*
name|p
operator|->
name|L
operator|->
name|F
call|)
argument_list|(
name|p
operator|->
name|L
argument_list|)
operator|)
operator|&&
operator|(
call|(
modifier|*
name|p
operator|->
name|R
operator|->
name|F
call|)
argument_list|(
name|p
operator|->
name|R
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|or
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|anode
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
operator|(
call|(
modifier|*
name|p
operator|->
name|L
operator|->
name|F
call|)
argument_list|(
name|p
operator|->
name|L
argument_list|)
operator|)
operator|||
operator|(
call|(
modifier|*
name|p
operator|->
name|R
operator|->
name|F
call|)
argument_list|(
name|p
operator|->
name|R
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|not
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|anode
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
operator|!
operator|(
call|(
modifier|*
name|p
operator|->
name|L
operator|->
name|F
call|)
argument_list|(
name|p
operator|->
name|L
argument_list|)
operator|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|glob
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|;
name|char
operator|*
name|pat
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|gmatch
argument_list|(
name|Fname
argument_list|,
name|p
operator|->
name|pat
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|print
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|anode
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|puts
argument_list|(
name|Pathname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|mtime
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|t
block|,
name|s
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|scomp
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|Now
operator|-
name|Statb
operator|.
name|st_mtime
operator|)
operator|/
name|A_DAY
argument_list|)
argument_list|,
name|p
operator|->
name|t
argument_list|,
name|p
operator|->
name|s
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|atime
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|t
block|,
name|s
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|scomp
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|Now
operator|-
name|Statb
operator|.
name|st_atime
operator|)
operator|/
name|A_DAY
argument_list|)
argument_list|,
name|p
operator|->
name|t
argument_list|,
name|p
operator|->
name|s
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|user
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|u
block|,
name|s
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|scomp
argument_list|(
name|Statb
operator|.
name|st_uid
argument_list|,
name|p
operator|->
name|u
argument_list|,
name|p
operator|->
name|s
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|nouser
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|anode
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|getname
parameter_list|()
function_decl|;
return|return
operator|(
name|getname
argument_list|(
name|Statb
operator|.
name|st_uid
argument_list|)
operator|==
name|NULL
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|ino
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|u
block|,
name|s
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|scomp
argument_list|(
operator|(
name|int
operator|)
name|Statb
operator|.
name|st_ino
argument_list|,
name|p
operator|->
name|u
argument_list|,
name|p
operator|->
name|s
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|group
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|u
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|p
operator|->
name|u
operator|==
name|Statb
operator|.
name|st_gid
operator|)
return|;
block|}
end_block

begin_macro
name|nogroup
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|anode
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|getgroup
parameter_list|()
function_decl|;
return|return
operator|(
name|getgroup
argument_list|(
name|Statb
operator|.
name|st_gid
argument_list|)
operator|==
name|NULL
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|links
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|link
block|,
name|s
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|scomp
argument_list|(
name|Statb
operator|.
name|st_nlink
argument_list|,
name|p
operator|->
name|link
argument_list|,
name|p
operator|->
name|s
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|size
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|sz
block|,
name|s
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|scomp
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|Statb
operator|.
name|st_size
operator|+
literal|511
operator|)
operator|>>
literal|9
argument_list|)
argument_list|,
name|p
operator|->
name|sz
argument_list|,
name|p
operator|->
name|s
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|perm
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|per
block|,
name|s
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|i
operator|=
operator|(
name|p
operator|->
name|s
operator|==
literal|'-'
operator|)
condition|?
name|p
operator|->
name|per
else|:
literal|07777
expr_stmt|;
comment|/* '-' means only arg bits */
return|return
operator|(
operator|(
name|Statb
operator|.
name|st_mode
operator|&
name|i
operator|&
literal|07777
operator|)
operator|==
name|p
operator|->
name|per
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|type
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|per
block|,
name|s
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
operator|(
name|Statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|p
operator|->
name|per
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|exeq
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
block|{
name|int
name|f
block|,
name|com
block|; }
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* to flush possible `-print' */
return|return
operator|(
name|doex
argument_list|(
name|p
operator|->
name|com
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|ok
argument_list|(
argument|p
argument_list|)
end_macro

begin_struct
struct|struct
block|{
name|int
name|f
decl_stmt|,
name|com
decl_stmt|;
block|}
modifier|*
name|p
struct|;
end_struct

begin_block
block|{
name|char
name|c
decl_stmt|;
name|int
name|yes
decl_stmt|;
name|yes
operator|=
literal|0
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* to flush possible `-print' */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"< %s ... %s> ?   "
argument_list|,
name|Argv
index|[
name|p
operator|->
name|com
index|]
argument_list|,
name|Pathname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'y'
condition|)
name|yes
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yes
condition|)
return|return
operator|(
name|doex
argument_list|(
name|p
operator|->
name|com
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|MKSHORT
parameter_list|(
name|v
parameter_list|,
name|lv
parameter_list|)
value|{U.l=1L;if(U.c[0]) U.l=lv, v[0]=U.s[1], v[1]=U.s[0]; else U.l=lv, v[0]=U.s[0], v[1]=U.s[1];}
end_define

begin_union
union|union
block|{
name|long
name|l
decl_stmt|;
name|short
name|s
index|[
literal|2
index|]
decl_stmt|;
name|char
name|c
index|[
literal|4
index|]
decl_stmt|;
block|}
name|U
union|;
end_union

begin_function
name|long
name|mklong
parameter_list|(
name|v
parameter_list|)
name|short
name|v
index|[]
decl_stmt|;
block|{
name|U
operator|.
name|l
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|U
operator|.
name|c
index|[
literal|0
index|]
comment|/* VAX */
condition|)
name|U
operator|.
name|s
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|1
index|]
operator|,
name|U
operator|.
name|s
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
else|else
name|U
operator|.
name|s
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
operator|,
name|U
operator|.
name|s
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|1
index|]
expr_stmt|;
return|return
name|U
operator|.
name|l
return|;
block|}
end_function

begin_macro
name|cpio
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|anode
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|MAGIC
value|070707
struct|struct
name|header
block|{
name|short
name|h_magic
decl_stmt|,
name|h_dev
decl_stmt|,
name|h_ino
decl_stmt|,
name|h_mode
decl_stmt|,
name|h_uid
decl_stmt|,
name|h_gid
decl_stmt|,
name|h_nlink
decl_stmt|,
name|h_rdev
decl_stmt|;
name|short
name|h_mtime
index|[
literal|2
index|]
decl_stmt|;
name|short
name|h_namesize
decl_stmt|;
name|short
name|h_filesize
index|[
literal|2
index|]
decl_stmt|;
name|char
name|h_name
index|[
literal|256
index|]
decl_stmt|;
block|}
name|hdr
struct|;
specifier|register
name|ifile
operator|,
name|ct
expr_stmt|;
specifier|static
name|long
name|fsz
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|hdr
operator|.
name|h_magic
operator|=
name|MAGIC
expr_stmt|;
name|strcpy
argument_list|(
name|hdr
operator|.
name|h_name
argument_list|,
operator|!
name|strncmp
argument_list|(
name|Pathname
argument_list|,
literal|"./"
argument_list|,
literal|2
argument_list|)
condition|?
name|Pathname
operator|+
literal|2
else|:
name|Pathname
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|h_namesize
operator|=
name|strlen
argument_list|(
name|hdr
operator|.
name|h_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|hdr
operator|.
name|h_uid
operator|=
name|Statb
operator|.
name|st_uid
expr_stmt|;
name|hdr
operator|.
name|h_gid
operator|=
name|Statb
operator|.
name|st_gid
expr_stmt|;
name|hdr
operator|.
name|h_dev
operator|=
name|Statb
operator|.
name|st_dev
expr_stmt|;
name|hdr
operator|.
name|h_ino
operator|=
name|Statb
operator|.
name|st_ino
expr_stmt|;
name|hdr
operator|.
name|h_mode
operator|=
name|Statb
operator|.
name|st_mode
expr_stmt|;
name|MKSHORT
argument_list|(
name|hdr
operator|.
name|h_mtime
argument_list|,
name|Statb
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|h_nlink
operator|=
name|Statb
operator|.
name|st_nlink
expr_stmt|;
name|fsz
operator|=
name|hdr
operator|.
name|h_mode
operator|&
name|S_IFREG
condition|?
name|Statb
operator|.
name|st_size
else|:
literal|0L
expr_stmt|;
name|MKSHORT
argument_list|(
name|hdr
operator|.
name|h_filesize
argument_list|,
name|fsz
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|h_rdev
operator|=
name|Statb
operator|.
name|st_rdev
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|hdr
operator|.
name|h_name
argument_list|,
literal|"TRAILER!!!"
argument_list|)
condition|)
block|{
name|bwrite
argument_list|(
operator|(
name|short
operator|*
operator|)
operator|&
name|hdr
argument_list|,
operator|(
sizeof|sizeof
name|hdr
operator|-
literal|256
operator|)
operator|+
name|hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
operator|++
name|i
control|)
name|bwrite
argument_list|(
name|Buf
argument_list|,
literal|512
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|mklong
argument_list|(
name|hdr
operator|.
name|h_filesize
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|ifile
operator|=
name|open
argument_list|(
name|Fname
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|cerror
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: cannot copy< %s>\n"
argument_list|,
name|hdr
operator|.
name|h_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|bwrite
argument_list|(
operator|(
name|short
operator|*
operator|)
operator|&
name|hdr
argument_list|,
operator|(
sizeof|sizeof
name|hdr
operator|-
literal|256
operator|)
operator|+
name|hdr
operator|.
name|h_namesize
argument_list|)
expr_stmt|;
for|for
control|(
name|fsz
operator|=
name|mklong
argument_list|(
name|hdr
operator|.
name|h_filesize
argument_list|)
init|;
name|fsz
operator|>
literal|0
condition|;
name|fsz
operator|-=
literal|512
control|)
block|{
name|ct
operator|=
name|fsz
operator|>
literal|512
condition|?
literal|512
else|:
name|fsz
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|ifile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Buf
argument_list|,
name|ct
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|cerror
goto|;
name|bwrite
argument_list|(
name|Buf
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|newer
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|anode
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|Statb
operator|.
name|st_mtime
operator|>
name|Newer
return|;
block|}
end_block

begin_macro
name|ls
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|anode
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|list
argument_list|(
name|Pathname
argument_list|,
operator|&
name|Statb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|dummy
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|anode
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* dummy */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* support functions */
end_comment

begin_expr_stmt
name|scomp
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|s
argument_list|)
comment|/* funny signed compare */
specifier|register
name|a
operator|,
name|b
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|s
operator|==
literal|'+'
condition|)
return|return
operator|(
name|a
operator|>
name|b
operator|)
return|;
if|if
condition|(
name|s
operator|==
literal|'-'
condition|)
return|return
operator|(
name|a
operator|<
operator|(
name|b
operator|*
operator|-
literal|1
operator|)
operator|)
return|;
return|return
operator|(
name|a
operator|==
name|b
operator|)
return|;
block|}
end_block

begin_macro
name|doex
argument_list|(
argument|com
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|np
expr_stmt|;
specifier|register
name|char
modifier|*
name|na
decl_stmt|;
specifier|static
name|char
modifier|*
name|nargv
index|[
literal|50
index|]
decl_stmt|;
specifier|static
name|ccode
expr_stmt|;
specifier|register
name|int
name|w
decl_stmt|,
name|pid
decl_stmt|,
name|omask
decl_stmt|;
name|ccode
operator|=
name|np
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|na
operator|=
name|Argv
index|[
name|com
operator|++
index|]
condition|)
block|{
if|if
condition|(
name|np
operator|>=
sizeof|sizeof
name|nargv
operator|/
sizeof|sizeof
expr|*
name|nargv
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|na
argument_list|,
literal|";"
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|na
argument_list|,
literal|"{}"
argument_list|)
operator|==
literal|0
condition|)
name|nargv
index|[
name|np
operator|++
index|]
operator|=
name|Pathname
expr_stmt|;
else|else
name|nargv
index|[
name|np
operator|++
index|]
operator|=
name|na
expr_stmt|;
block|}
name|nargv
index|[
name|np
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|np
operator|==
literal|0
condition|)
return|return
operator|(
literal|9
operator|)
return|;
switch|switch
condition|(
name|pid
operator|=
name|vfork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|perror
argument_list|(
literal|"find: Can't fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|chdir
argument_list|(
name|Home
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|nargv
index|[
literal|0
index|]
argument_list|,
name|nargv
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"find: Can't execute "
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|nargv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * Kill ourselves; our exit status will be a suicide 		 * note indicating we couldn't do the "exec". 		 */
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGUSR1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGQUIT
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|w
operator|=
name|wait
argument_list|(
operator|&
name|ccode
argument_list|)
operator|)
operator|!=
name|pid
operator|&&
name|w
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccode
operator|&
literal|0177
operator|)
operator|==
name|SIGUSR1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ccode
operator|!=
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|getunum
argument_list|(
argument|f
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|,
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* find user/group name and return number */
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|char
name|str
index|[
literal|20
index|]
decl_stmt|;
name|FILE
modifier|*
name|pin
decl_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|pin
operator|=
name|fopen
argument_list|(
name|f
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
comment|/* prime with a CR */
do|do
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|sp
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|sp
operator|++
operator|=
name|getc
argument_list|(
name|pin
argument_list|)
operator|)
operator|!=
literal|':'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|RET
goto|;
operator|*
operator|--
name|sp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|str
argument_list|,
name|s
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|pin
argument_list|)
operator|)
operator|!=
literal|':'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|RET
goto|;
name|sp
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|sp
operator|=
name|getc
argument_list|(
name|pin
argument_list|)
operator|)
operator|!=
literal|':'
condition|)
name|sp
operator|++
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
name|atoi
argument_list|(
name|str
argument_list|)
expr_stmt|;
goto|goto
name|RET
goto|;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|pin
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
do|;
name|RET
label|:
name|fclose
argument_list|(
name|pin
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|descend
argument_list|(
argument|name
argument_list|,
argument|fname
argument_list|,
argument|exlist
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|anode
modifier|*
name|exlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DIR
modifier|*
name|dir
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|c1
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|endofname
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|fname
argument_list|,
operator|&
name|Statb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: bad status< %s>\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
call|(
modifier|*
name|exlist
operator|->
name|F
call|)
argument_list|(
name|exlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
operator|||
operator|!
name|Xdev
operator|&&
name|Devstat
operator|.
name|st_dev
operator|!=
name|Statb
operator|.
name|st_dev
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|c1
operator|=
name|name
init|;
operator|*
name|c1
condition|;
operator|++
name|c1
control|)
empty_stmt|;
if|if
condition|(
operator|*
operator|(
name|c1
operator|-
literal|1
operator|)
operator|==
literal|'/'
condition|)
operator|--
name|c1
expr_stmt|;
name|endofname
operator|=
name|c1
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|fname
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|dir
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: cannot open< %s>\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
for|for
control|(
name|dp
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
continue|continue;
name|c1
operator|=
name|endofname
expr_stmt|;
operator|*
name|c1
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|c1
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|Fname
operator|=
name|endofname
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|descend
argument_list|(
name|name
argument_list|,
name|Fname
argument_list|,
name|exlist
argument_list|)
condition|)
block|{
operator|*
name|endofname
operator|=
literal|'\0'
expr_stmt|;
name|chdir
argument_list|(
name|Home
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|Pathname
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: bad directory tree\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|rv
operator|=
literal|1
expr_stmt|;
name|ret
label|:
if|if
condition|(
name|dir
condition|)
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
literal|".."
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|endofname
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: bad directory<%s>\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|gmatch
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
comment|/* string match as in glob */
specifier|register
name|char
operator|*
name|s
operator|,
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
operator|*
name|p
operator|!=
literal|'.'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
name|amatch
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
return|;
block|}
end_block

begin_expr_stmt
name|amatch
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|cc
expr_stmt|;
name|int
name|scc
decl_stmt|,
name|k
decl_stmt|;
name|int
name|c
decl_stmt|,
name|lc
decl_stmt|;
name|scc
operator|=
operator|*
name|s
expr_stmt|;
name|lc
operator|=
literal|077777
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
condition|)
block|{
case|case
literal|'['
case|:
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cc
operator|=
operator|*
operator|++
name|p
condition|)
block|{
switch|switch
condition|(
name|cc
condition|)
block|{
case|case
literal|']'
case|:
if|if
condition|(
name|k
condition|)
return|return
operator|(
name|amatch
argument_list|(
operator|++
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'-'
case|:
name|k
operator||=
name|lc
operator|<=
name|scc
operator|&&
name|scc
operator|<=
operator|(
name|cc
operator|=
name|p
index|[
literal|1
index|]
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|scc
operator|==
operator|(
name|lc
operator|=
name|cc
operator|)
condition|)
name|k
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'?'
case|:
name|caseq
label|:
if|if
condition|(
name|scc
condition|)
return|return
operator|(
name|amatch
argument_list|(
operator|++
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'*'
case|:
return|return
operator|(
name|umatch
argument_list|(
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
case|case
literal|0
case|:
return|return
operator|(
operator|!
name|scc
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|scc
condition|)
goto|goto
name|caseq
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|umatch
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
name|amatch
argument_list|(
name|s
operator|++
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|bwrite
argument_list|(
name|rp
argument_list|,
name|c
argument_list|)
specifier|register
name|short
operator|*
name|rp
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|short
modifier|*
name|wp
init|=
name|Wp
decl_stmt|;
name|c
operator|=
operator|(
name|c
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|--
condition|)
block|{
if|if
condition|(
operator|!
name|Wct
condition|)
block|{
name|again
label|:
if|if
condition|(
name|write
argument_list|(
name|Cpio
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Dbuf
argument_list|,
name|Bufsize
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Cpio
operator|=
name|chgreel
argument_list|(
literal|1
argument_list|,
name|Cpio
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|Wct
operator|=
name|Bufsize
operator|>>
literal|1
expr_stmt|;
name|wp
operator|=
name|Dbuf
expr_stmt|;
operator|++
name|Blocks
expr_stmt|;
block|}
operator|*
name|wp
operator|++
operator|=
operator|*
name|rp
operator|++
expr_stmt|;
operator|--
name|Wct
expr_stmt|;
block|}
name|Wp
operator|=
name|wp
expr_stmt|;
block|}
end_block

begin_macro
name|chgreel
argument_list|(
argument|x
argument_list|,
argument|fl
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|f
expr_stmt|;
name|char
name|str
index|[
literal|22
index|]
decl_stmt|;
name|FILE
modifier|*
name|devtty
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
extern|extern errno;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: errno: %d, "
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: can't %s\n"
argument_list|,
name|x
condition|?
literal|"write output"
else|:
literal|"read input"
argument_list|)
expr_stmt|;
name|fstat
argument_list|(
name|fl
argument_list|,
operator|&
name|statb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFCHR
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|again
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"If you want to go on, type device/file name %s\n"
argument_list|,
literal|"when ready"
argument_list|)
expr_stmt|;
name|devtty
operator|=
name|fopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|str
argument_list|,
literal|20
argument_list|,
name|devtty
argument_list|)
expr_stmt|;
name|str
index|[
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|str
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|str
argument_list|,
name|x
condition|?
literal|1
else|:
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"That didn't work"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|devtty
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return
name|f
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|AMES
end_ifdef

begin_comment
comment|/*  * 'fastfind' scans a file list for the full pathname of a file  * given only a piece of the name.  The list has been processed with  * with "front-compression" and bigram coding.  Front compression reduces  * space by a factor of 4-5, bigram coding by a further 20-25%.  * The codes are:  *  *	0-28	likeliest differential counts + offset to make nonnegative   *	30	escape code for out-of-range count to follow in next word  *	128-255 bigram codes, (128 most common, as determined by 'updatedb')  *	32-127  single character (printable) ascii residue  *  * A novel two-tiered string search technique is employed:   *  * First, a metacharacter-free subpattern and partial pathname is  * matched BACKWARDS to avoid full expansion of the pathname list.  * The time savings is 40-50% over forward matching, which cannot efficiently  * handle overlapped search patterns and compressed path residue.  *  * Then, the actual shell glob-style regular expression (if in this form)  * is matched against the candidate pathnames using the slower routines  * provided in the standard 'find'.  */
end_comment

begin_define
define|#
directive|define
name|FCODES
value|"/usr/lib/find/find.codes"
end_define

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_define
define|#
directive|define
name|OFFSET
value|14
end_define

begin_define
define|#
directive|define
name|ESCCODE
value|30
end_define

begin_macro
name|fastfind
argument_list|(
argument|pathpart
argument_list|)
end_macro

begin_decl_stmt
name|char
name|pathpart
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|patprep
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|,
name|globflag
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|fopen
argument_list|()
decl_stmt|;
name|char
modifier|*
name|patend
decl_stmt|,
modifier|*
name|cutoff
decl_stmt|;
name|char
name|path
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|bigram1
index|[
literal|128
index|]
decl_stmt|,
name|bigram2
index|[
literal|128
index|]
decl_stmt|;
name|int
name|found
init|=
name|NO
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|FCODES
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: can't open %s\n"
argument_list|,
name|FCODES
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
name|bigram1
index|[
name|i
index|]
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|,
name|bigram2
index|[
name|i
index|]
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|pathpart
argument_list|,
literal|'*'
argument_list|)
operator|||
name|index
argument_list|(
name|pathpart
argument_list|,
literal|'?'
argument_list|)
operator|||
name|index
argument_list|(
name|pathpart
argument_list|,
literal|'['
argument_list|)
condition|)
name|globflag
operator|=
name|YES
expr_stmt|;
name|patend
operator|=
name|patprep
argument_list|(
name|pathpart
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|count
operator|+=
operator|(
operator|(
name|c
operator|==
name|ESCCODE
operator|)
condition|?
name|getw
argument_list|(
name|fp
argument_list|)
else|:
name|c
operator|)
operator|-
name|OFFSET
expr_stmt|;
for|for
control|(
name|p
operator|=
name|path
operator|+
name|count
init|;
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|>
name|ESCCODE
condition|;
control|)
comment|/* overlay old path */
if|if
condition|(
name|c
operator|<
literal|0200
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
else|else
comment|/* bigrams are parity-marked */
operator|*
name|p
operator|++
operator|=
name|bigram1
index|[
name|c
operator|&
literal|0177
index|]
operator|,
operator|*
name|p
operator|++
operator|=
name|bigram2
index|[
name|c
operator|&
literal|0177
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
operator|*
name|p
operator|--
operator|=
name|NULL
expr_stmt|;
name|cutoff
operator|=
operator|(
name|found
condition|?
name|path
else|:
name|path
operator|+
name|count
operator|)
expr_stmt|;
for|for
control|(
name|found
operator|=
name|NO
operator|,
name|s
operator|=
name|p
init|;
name|s
operator|>=
name|cutoff
condition|;
name|s
operator|--
control|)
if|if
condition|(
operator|*
name|s
operator|==
operator|*
name|patend
condition|)
block|{
comment|/* fast first char check */
for|for
control|(
name|p
operator|=
name|patend
operator|-
literal|1
operator|,
name|q
operator|=
name|s
operator|-
literal|1
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|--
operator|,
name|q
operator|--
control|)
if|if
condition|(
operator|*
name|q
operator|!=
operator|*
name|p
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* success on fast match */
name|found
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|globflag
operator|==
name|NO
operator|||
name|amatch
argument_list|(
name|path
argument_list|,
name|pathpart
argument_list|)
condition|)
name|puts
argument_list|(
name|path
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*     extract last glob-free subpattern in name for fast pre-match;     prepend '\0' for backwards match; return end of new pattern */
end_comment

begin_decl_stmt
specifier|static
name|char
name|globfree
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|patprep
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|endmark
decl_stmt|;
specifier|register
name|char
modifier|*
name|subp
init|=
name|globfree
decl_stmt|;
operator|*
name|subp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* 	   skip trailing metacharacters (and [] ranges) 	*/
for|for
control|(
init|;
name|p
operator|>=
name|name
condition|;
name|p
operator|--
control|)
if|if
condition|(
name|index
argument_list|(
literal|"*?"
argument_list|,
operator|*
name|p
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|p
operator|<
name|name
condition|)
name|p
operator|=
name|name
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|']'
condition|)
for|for
control|(
name|p
operator|--
init|;
name|p
operator|>=
name|name
condition|;
name|p
operator|--
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'['
condition|)
block|{
name|p
operator|--
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|<
name|name
condition|)
name|p
operator|=
name|name
expr_stmt|;
comment|/* 	   if pattern has only metacharacters, 	   check every path (force '/' search) 	*/
if|if
condition|(
operator|(
name|p
operator|==
name|name
operator|)
operator|&&
name|index
argument_list|(
literal|"?*[]"
argument_list|,
operator|*
name|p
argument_list|)
operator|!=
literal|0
condition|)
operator|*
name|subp
operator|++
operator|=
literal|'/'
expr_stmt|;
else|else
block|{
for|for
control|(
name|endmark
operator|=
name|p
init|;
name|p
operator|>=
name|name
condition|;
name|p
operator|--
control|)
if|if
condition|(
name|index
argument_list|(
literal|"]*?"
argument_list|,
operator|*
name|p
argument_list|)
operator|!=
literal|0
condition|)
break|break;
for|for
control|(
operator|++
name|p
init|;
operator|(
name|p
operator|<=
name|endmark
operator|)
operator|&&
name|subp
operator|<
operator|(
name|globfree
operator|+
sizeof|sizeof
argument_list|(
name|globfree
argument_list|)
operator|)
condition|;
control|)
operator|*
name|subp
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|subp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
operator|--
name|subp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* rest should be done with nameserver or database */
end_comment

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_decl_stmt
name|struct
name|utmp
name|utmp
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NMAX
value|(sizeof (utmp.ut_name))
end_define

begin_define
define|#
directive|define
name|SCPYN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|strncpy(a, b, NMAX)
end_define

begin_define
define|#
directive|define
name|NUID
value|64
end_define

begin_define
define|#
directive|define
name|NGID
value|300
end_define

begin_struct
struct|struct
name|ncache
block|{
name|int
name|uid
decl_stmt|;
name|char
name|name
index|[
name|NMAX
operator|+
literal|1
index|]
decl_stmt|;
block|}
name|nc
index|[
name|NUID
index|]
struct|;
end_struct

begin_decl_stmt
name|char
name|outrangename
index|[
name|NMAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|outrangeuid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|groups
index|[
name|NGID
index|]
index|[
name|NMAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|outrangegroup
index|[
name|NMAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|outrangegid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This function assumes that the password file is hashed  * (or some such) to allow fast access based on a name key.  * If this isn't true, duplicate the code for getgroup().  */
end_comment

begin_function
name|char
modifier|*
name|getname
parameter_list|(
name|uid
parameter_list|)
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|passwd
modifier|*
name|getpwent
parameter_list|()
function_decl|;
specifier|register
name|int
name|cp
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_PW_STAYOPEN
specifier|extern
name|int
name|_pw_stayopen
decl_stmt|;
name|_pw_stayopen
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|(
operator|(
name|NUID
operator|)
operator|&
operator|(
operator|(
name|NUID
operator|)
operator|-
literal|1
operator|)
operator|!=
literal|0
operator|)
name|cp
operator|=
name|uid
operator|%
operator|(
name|NUID
operator|)
expr_stmt|;
else|#
directive|else
name|cp
operator|=
name|uid
operator|&
operator|(
operator|(
name|NUID
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|uid
operator|>=
literal|0
operator|&&
name|nc
index|[
name|cp
index|]
operator|.
name|uid
operator|==
name|uid
operator|&&
name|nc
index|[
name|cp
index|]
operator|.
name|name
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|nc
index|[
name|cp
index|]
operator|.
name|name
operator|)
return|;
name|pw
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pw
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nc
index|[
name|cp
index|]
operator|.
name|uid
operator|=
name|uid
expr_stmt|;
name|SCPYN
argument_list|(
name|nc
index|[
name|cp
index|]
operator|.
name|name
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|nc
index|[
name|cp
index|]
operator|.
name|name
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|getgroup
parameter_list|(
name|gid
parameter_list|)
block|{
specifier|register
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
specifier|static
name|init
expr_stmt|;
name|struct
name|group
modifier|*
name|getgrent
parameter_list|()
function_decl|;
if|if
condition|(
name|gid
operator|>=
literal|0
operator|&&
name|gid
operator|<
name|NGID
operator|&&
name|groups
index|[
name|gid
index|]
index|[
literal|0
index|]
condition|)
return|return
operator|(
operator|&
name|groups
index|[
name|gid
index|]
index|[
literal|0
index|]
operator|)
return|;
if|if
condition|(
name|gid
operator|>=
literal|0
operator|&&
name|gid
operator|==
name|outrangegid
condition|)
return|return
operator|(
name|outrangegroup
operator|)
return|;
name|rescan
label|:
if|if
condition|(
name|init
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|gid
operator|<
name|NGID
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|setgrent
argument_list|()
expr_stmt|;
while|while
condition|(
name|gr
operator|=
name|getgrent
argument_list|()
condition|)
block|{
if|if
condition|(
name|gr
operator|->
name|gr_gid
operator|!=
name|gid
condition|)
continue|continue;
name|outrangegid
operator|=
name|gr
operator|->
name|gr_gid
expr_stmt|;
name|SCPYN
argument_list|(
name|outrangegroup
argument_list|,
name|gr
operator|->
name|gr_name
argument_list|)
expr_stmt|;
name|endgrent
argument_list|()
expr_stmt|;
return|return
operator|(
name|outrangegroup
operator|)
return|;
block|}
name|endgrent
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|init
operator|==
literal|0
condition|)
name|setgrent
argument_list|()
operator|,
name|init
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|gr
operator|=
name|getgrent
argument_list|()
condition|)
block|{
if|if
condition|(
name|gr
operator|->
name|gr_gid
operator|<
literal|0
operator|||
name|gr
operator|->
name|gr_gid
operator|>=
name|NGID
condition|)
block|{
if|if
condition|(
name|gr
operator|->
name|gr_gid
operator|==
name|gid
condition|)
block|{
name|outrangegid
operator|=
name|gr
operator|->
name|gr_gid
expr_stmt|;
name|SCPYN
argument_list|(
name|outrangegroup
argument_list|,
name|gr
operator|->
name|gr_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|outrangegroup
operator|)
return|;
block|}
continue|continue;
block|}
if|if
condition|(
name|groups
index|[
name|gr
operator|->
name|gr_gid
index|]
index|[
literal|0
index|]
condition|)
continue|continue;
name|SCPYN
argument_list|(
name|groups
index|[
name|gr
operator|->
name|gr_gid
index|]
argument_list|,
name|gr
operator|->
name|gr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|->
name|gr_gid
operator|==
name|gid
condition|)
return|return
operator|(
operator|&
name|groups
index|[
name|gid
index|]
index|[
literal|0
index|]
operator|)
return|;
block|}
name|init
operator|=
literal|2
expr_stmt|;
goto|goto
name|rescan
goto|;
block|}
end_function

begin_function
name|int
name|getuid
parameter_list|(
name|username
parameter_list|)
name|char
modifier|*
name|username
decl_stmt|;
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
ifndef|#
directive|ifndef
name|NO_PW_STAYOPEN
specifier|extern
name|int
name|_pw_stayopen
decl_stmt|;
name|_pw_stayopen
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|pw
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|!=
name|NULL
condition|)
return|return
operator|(
name|pw
operator|->
name|pw_uid
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|getgid
parameter_list|(
name|groupname
parameter_list|)
name|char
modifier|*
name|groupname
decl_stmt|;
block|{
specifier|register
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
name|struct
name|group
modifier|*
name|getgrnam
parameter_list|()
function_decl|;
name|gr
operator|=
name|getgrnam
argument_list|(
name|groupname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|gr
operator|->
name|gr_gid
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|permoffset
parameter_list|(
name|who
parameter_list|)
value|((who) * 3)
end_define

begin_define
define|#
directive|define
name|permission
parameter_list|(
name|who
parameter_list|,
name|type
parameter_list|)
value|((type)>> permoffset(who))
end_define

begin_define
define|#
directive|define
name|kbytes
parameter_list|(
name|bytes
parameter_list|)
value|(((bytes) + 1023) / 1024)
end_define

begin_macro
name|list
argument_list|(
argument|file
argument_list|,
argument|stp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|stat
modifier|*
name|stp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|pmode
index|[
literal|32
index|]
decl_stmt|,
name|uname
index|[
literal|32
index|]
decl_stmt|,
name|gname
index|[
literal|32
index|]
decl_stmt|,
name|fsize
index|[
literal|32
index|]
decl_stmt|,
name|ftime
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|getname
argument_list|()
decl_stmt|,
modifier|*
name|getgroup
argument_list|()
decl_stmt|,
modifier|*
name|ctime
argument_list|()
decl_stmt|;
specifier|static
name|long
name|special
index|[]
init|=
block|{
name|S_ISUID
block|,
literal|'s'
block|,
name|S_ISGID
block|,
literal|'s'
block|,
name|S_ISVTX
block|,
literal|'t'
block|}
decl_stmt|;
specifier|static
name|time_t
name|sixmonthsago
init|=
operator|-
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|S_IFLNK
name|char
name|flink
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
endif|#
directive|endif
specifier|register
name|int
name|who
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|time_t
name|now
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
operator|||
name|stp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|sixmonthsago
operator|==
operator|-
literal|1
condition|)
name|sixmonthsago
operator|=
name|now
operator|-
literal|6L
operator|*
literal|30L
operator|*
literal|24L
operator|*
literal|60L
operator|*
literal|60L
expr_stmt|;
switch|switch
condition|(
name|stp
operator|->
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
ifdef|#
directive|ifdef
name|S_IFDIR
case|case
name|S_IFDIR
case|:
comment|/* directory */
name|pmode
index|[
literal|0
index|]
operator|=
literal|'d'
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFCHR
case|case
name|S_IFCHR
case|:
comment|/* character special */
name|pmode
index|[
literal|0
index|]
operator|=
literal|'c'
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFBLK
case|case
name|S_IFBLK
case|:
comment|/* block special */
name|pmode
index|[
literal|0
index|]
operator|=
literal|'b'
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFLNK
case|case
name|S_IFLNK
case|:
comment|/* symbolic link */
name|pmode
index|[
literal|0
index|]
operator|=
literal|'l'
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFSOCK
case|case
name|S_IFSOCK
case|:
comment|/* socket */
name|pmode
index|[
literal|0
index|]
operator|=
literal|'s'
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFREG
case|case
name|S_IFREG
case|:
comment|/* regular */
endif|#
directive|endif
default|default:
name|pmode
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
break|break;
block|}
for|for
control|(
name|who
operator|=
literal|0
init|;
name|who
operator|<
literal|3
condition|;
name|who
operator|++
control|)
block|{
if|if
condition|(
name|stp
operator|->
name|st_mode
operator|&
name|permission
argument_list|(
name|who
argument_list|,
name|S_IREAD
argument_list|)
condition|)
name|pmode
index|[
name|permoffset
argument_list|(
name|who
argument_list|)
operator|+
literal|1
index|]
operator|=
literal|'r'
expr_stmt|;
else|else
name|pmode
index|[
name|permoffset
argument_list|(
name|who
argument_list|)
operator|+
literal|1
index|]
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|stp
operator|->
name|st_mode
operator|&
name|permission
argument_list|(
name|who
argument_list|,
name|S_IWRITE
argument_list|)
condition|)
name|pmode
index|[
name|permoffset
argument_list|(
name|who
argument_list|)
operator|+
literal|2
index|]
operator|=
literal|'w'
expr_stmt|;
else|else
name|pmode
index|[
name|permoffset
argument_list|(
name|who
argument_list|)
operator|+
literal|2
index|]
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|stp
operator|->
name|st_mode
operator|&
name|special
index|[
name|who
operator|*
literal|2
index|]
condition|)
name|pmode
index|[
name|permoffset
argument_list|(
name|who
argument_list|)
operator|+
literal|3
index|]
operator|=
name|special
index|[
name|who
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|stp
operator|->
name|st_mode
operator|&
name|permission
argument_list|(
name|who
argument_list|,
name|S_IEXEC
argument_list|)
condition|)
name|pmode
index|[
name|permoffset
argument_list|(
name|who
argument_list|)
operator|+
literal|3
index|]
operator|=
literal|'x'
expr_stmt|;
else|else
name|pmode
index|[
name|permoffset
argument_list|(
name|who
argument_list|)
operator|+
literal|3
index|]
operator|=
literal|'-'
expr_stmt|;
block|}
name|pmode
index|[
name|permoffset
argument_list|(
name|who
argument_list|)
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|getname
argument_list|(
name|stp
operator|->
name|st_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|uname
argument_list|,
literal|"%-9.9s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|uname
argument_list|,
literal|"%-9d"
argument_list|,
name|stp
operator|->
name|st_uid
argument_list|)
expr_stmt|;
name|cp
operator|=
name|getgroup
argument_list|(
name|stp
operator|->
name|st_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|gname
argument_list|,
literal|"%-9.9s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|gname
argument_list|,
literal|"%-9d"
argument_list|,
name|stp
operator|->
name|st_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmode
index|[
literal|0
index|]
operator|==
literal|'b'
operator|||
name|pmode
index|[
literal|0
index|]
operator|==
literal|'c'
condition|)
name|sprintf
argument_list|(
name|fsize
argument_list|,
literal|"%3d,%4d"
argument_list|,
name|major
argument_list|(
name|stp
operator|->
name|st_rdev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|stp
operator|->
name|st_rdev
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|fsize
argument_list|,
literal|"%8ld"
argument_list|,
name|stp
operator|->
name|st_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|S_IFLNK
if|if
condition|(
name|pmode
index|[
literal|0
index|]
operator|==
literal|'l'
condition|)
block|{
name|who
operator|=
name|readlink
argument_list|(
name|file
argument_list|,
name|flink
argument_list|,
sizeof|sizeof
name|flink
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|who
operator|>=
literal|0
condition|)
name|flink
index|[
name|who
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|cp
operator|=
name|ctime
argument_list|(
operator|&
name|stp
operator|->
name|st_mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|stp
operator|->
name|st_mtime
operator|<
name|sixmonthsago
operator|||
name|stp
operator|->
name|st_mtime
operator|>
name|now
condition|)
name|sprintf
argument_list|(
name|ftime
argument_list|,
literal|"%-7.7s %-4.4s"
argument_list|,
name|cp
operator|+
literal|4
argument_list|,
name|cp
operator|+
literal|20
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|ftime
argument_list|,
literal|"%-12.12s"
argument_list|,
name|cp
operator|+
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%5lu %4ld %s %2d %s%s%s %s %s%s%s\n"
argument_list|,
name|stp
operator|->
name|st_ino
argument_list|,
comment|/* inode #	*/
ifdef|#
directive|ifdef
name|S_IFSOCK
operator|(
name|long
operator|)
name|kbytes
argument_list|(
name|dbtob
argument_list|(
name|stp
operator|->
name|st_blocks
argument_list|)
argument_list|)
argument_list|,
comment|/* kbytes       */
else|#
directive|else
operator|(
name|long
operator|)
name|kbytes
argument_list|(
name|stp
operator|->
name|st_size
argument_list|)
argument_list|,
comment|/* kbytes       */
endif|#
directive|endif
name|pmode
argument_list|,
comment|/* protection	*/
name|stp
operator|->
name|st_nlink
argument_list|,
comment|/* # of links	*/
name|uname
argument_list|,
comment|/* owner	*/
name|gname
argument_list|,
comment|/* group	*/
name|fsize
argument_list|,
comment|/* # of bytes	*/
name|ftime
argument_list|,
comment|/* modify time	*/
name|file
argument_list|,
comment|/* name		*/
ifdef|#
directive|ifdef
name|S_IFLNK
operator|(
name|pmode
index|[
literal|0
index|]
operator|==
literal|'l'
operator|)
condition|?
literal|" -> "
else|:
literal|""
argument_list|,
operator|(
name|pmode
index|[
literal|0
index|]
operator|==
literal|'l'
operator|)
condition|?
name|flink
else|:
literal|""
comment|/* symlink	*/
else|#
directive|else
literal|""
argument_list|,
literal|""
endif|#
directive|endif
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

