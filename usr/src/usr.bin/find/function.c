begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Cimarron D. Taylor of the University of California, Berkeley.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)function.c	5.3 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<fts.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<tzfile.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"find.h"
end_include

begin_define
define|#
directive|define
name|FIND_EQUAL
value|0
end_define

begin_define
define|#
directive|define
name|FIND_LESSTHAN
value|1
end_define

begin_define
define|#
directive|define
name|FIND_GREATER
value|2
end_define

begin_define
define|#
directive|define
name|FIND_FALSE
value|0
end_define

begin_define
define|#
directive|define
name|FIND_TRUE
value|1
end_define

begin_define
define|#
directive|define
name|COMPARE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|{ \ 	switch(plan->flags) { \ 	case FIND_EQUAL: \ 		return(a == b); \ 	case FIND_LESSTHAN: \ 		return(a< b); \ 	case FIND_GREATER: \ 		return(a> b); \ 	} \ 	return(FIND_FALSE); \ }
end_define

begin_define
define|#
directive|define
name|NEW
parameter_list|(
name|t
parameter_list|,
name|f
parameter_list|)
value|{ \ 	new = (PLAN *)emalloc(sizeof(PLAN)); \ 	new->type = t; \ 	new->eval = f; \ 	new->flags = 0; \ 	new->next = NULL; \ }
end_define

begin_comment
comment|/*  * find_parsenum --  *	Parse a string of the form [+-]# and return the value.  */
end_comment

begin_function
name|long
name|find_parsenum
parameter_list|(
name|plan
parameter_list|,
name|option
parameter_list|,
name|str
parameter_list|,
name|endch
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|char
modifier|*
name|option
decl_stmt|,
decl|*
name|str
decl_stmt|,
modifier|*
name|endch
decl_stmt|;
end_function

begin_block
block|{
name|long
name|value
decl_stmt|;
name|char
modifier|*
name|endchar
decl_stmt|;
comment|/* pointer to character ending conversion */
comment|/* determine comparison from leading + or - */
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'+'
case|:
operator|++
name|str
expr_stmt|;
name|plan
operator|->
name|flags
operator|=
name|FIND_GREATER
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
operator|++
name|str
expr_stmt|;
name|plan
operator|->
name|flags
operator|=
name|FIND_LESSTHAN
expr_stmt|;
break|break;
default|default:
name|plan
operator|->
name|flags
operator|=
name|FIND_EQUAL
expr_stmt|;
break|break;
block|}
comment|/* 	 * convert the string with strtol().  Note, if strtol() returns zero 	 * and endchar points to the beginning of the string we know we have 	 * a syntax error. 	 */
name|value
operator|=
name|strtol
argument_list|(
name|str
argument_list|,
operator|&
name|endchar
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
operator|&&
name|endchar
operator|==
name|str
operator|||
name|endchar
index|[
literal|0
index|]
operator|&&
operator|(
operator|!
name|endch
operator|||
name|endchar
index|[
literal|0
index|]
operator|!=
operator|*
name|endch
operator|)
condition|)
name|bad_arg
argument_list|(
name|option
argument_list|,
literal|"illegal numeric value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|endch
condition|)
operator|*
name|endch
operator|=
name|endchar
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * -atime n functions --  *  *	True if the difference between the file access time and the  *	current time is n 24 hour periods.  *  */
end_comment

begin_macro
name|f_atime
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|time_t
name|now
decl_stmt|;
name|COMPARE
argument_list|(
operator|(
name|now
operator|-
name|entry
operator|->
name|statb
operator|.
name|st_atime
operator|+
name|SECSPERDAY
operator|-
literal|1
operator|)
operator|/
name|SECSPERDAY
argument_list|,
name|plan
operator|->
name|t_data
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_atime
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|NEW
argument_list|(
name|T_ATIME
argument_list|,
name|f_atime
argument_list|)
expr_stmt|;
name|new
operator|->
name|t_data
operator|=
name|find_parsenum
argument_list|(
name|new
argument_list|,
literal|"-atime"
argument_list|,
name|arg
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -ctime n functions --  *  *	True if the difference between the last change of file  *	status information and the current time is n 24 hour periods.  */
end_comment

begin_macro
name|f_ctime
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|time_t
name|now
decl_stmt|;
name|COMPARE
argument_list|(
operator|(
name|now
operator|-
name|entry
operator|->
name|statb
operator|.
name|st_ctime
operator|+
name|SECSPERDAY
operator|-
literal|1
operator|)
operator|/
name|SECSPERDAY
argument_list|,
name|plan
operator|->
name|t_data
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_ctime
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|NEW
argument_list|(
name|T_CTIME
argument_list|,
name|f_ctime
argument_list|)
expr_stmt|;
name|new
operator|->
name|t_data
operator|=
name|find_parsenum
argument_list|(
name|new
argument_list|,
literal|"-ctime"
argument_list|,
name|arg
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -depth functions --  *  *	Always true, causes descent of the directory hierarchy to be done  *	so that all entries in a directory are acted on before the directory  *	itself.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|f_always_true
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|FIND_TRUE
operator|)
return|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_depth
parameter_list|()
block|{
specifier|extern
name|int
name|depth
decl_stmt|;
name|PLAN
modifier|*
name|new
decl_stmt|;
name|depth
operator|=
literal|1
expr_stmt|;
name|NEW
argument_list|(
name|T_DEPTH
argument_list|,
name|f_always_true
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * [-exec | -ok] utility [arg ... ] ; functions --  *  *	True if the executed utility returns a zero value as exit status.  *	The end of the primary expression is delimited by a semicolon.  If  *	"{}" occurs anywhere, it gets replaced by the current pathname.  *	The current directory for the execution of utility is the same as  *	the current directory when the find utility was started.  *  *	The primary -ok is different in that it requests affirmation of the  *	user before executing the utility.  */
end_comment

begin_expr_stmt
name|f_exec
argument_list|(
name|plan
argument_list|,
name|entry
argument_list|)
specifier|register
name|PLAN
operator|*
name|plan
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
name|char
modifier|*
name|find_subst
parameter_list|()
function_decl|;
name|union
name|wait
name|pstat
decl_stmt|;
name|pid_t
name|pid
decl_stmt|,
name|waitpid
argument_list|()
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|plan
operator|->
name|e_argv
index|[
name|cnt
index|]
condition|;
operator|++
name|cnt
control|)
if|if
condition|(
name|plan
operator|->
name|e_len
index|[
name|cnt
index|]
condition|)
name|find_subst
argument_list|(
name|plan
operator|->
name|e_orig
index|[
name|cnt
index|]
argument_list|,
operator|&
name|plan
operator|->
name|e_argv
index|[
name|cnt
index|]
argument_list|,
name|entry
operator|->
name|path
argument_list|,
name|plan
operator|->
name|e_len
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|plan
operator|->
name|flags
operator|&&
operator|!
name|find_queryuser
argument_list|(
name|plan
operator|->
name|e_argv
argument_list|)
condition|)
return|return
operator|(
name|FIND_FALSE
operator|)
return|;
switch|switch
condition|(
name|pid
operator|=
name|vfork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: fork: %s.\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|0
case|:
name|execvp
argument_list|(
name|plan
operator|->
name|e_argv
index|[
literal|0
index|]
argument_list|,
name|plan
operator|->
name|e_argv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: %s: %s.\n"
argument_list|,
name|plan
operator|->
name|e_argv
index|[
literal|0
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|pid
operator|=
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|pstat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|pid
operator|==
operator|-
literal|1
operator|||
name|pstat
operator|.
name|w_status
condition|?
name|FIND_FALSE
else|:
name|FIND_TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * c_exec --  *	build three parallel arrays, one with pointers to the strings passed  *	on the command line, one with (possibly duplicated) pointers to the  *	argv array, and one with integer values that are lengths of the  *	strings, but also flags meaning that the string has to be massaged.  */
end_comment

begin_function
name|PLAN
modifier|*
name|c_exec
parameter_list|(
name|argvp
parameter_list|,
name|isok
parameter_list|)
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
name|int
name|isok
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
comment|/* node returned */
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|ftsoptions
operator||=
name|FTS_NOCHDIR
expr_stmt|;
name|output_specified
operator|=
literal|1
expr_stmt|;
name|NEW
argument_list|(
name|T_EXEC
argument_list|,
name|f_exec
argument_list|)
expr_stmt|;
name|new
operator|->
name|flags
operator|=
name|isok
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|argv
operator|=
operator|*
name|argvp
init|;
condition|;
operator|++
name|ap
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|ap
condition|)
name|bad_arg
argument_list|(
name|isok
condition|?
literal|"-ok"
else|:
literal|"-exec"
argument_list|,
literal|"no terminating \";\""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|ap
operator|==
literal|';'
condition|)
break|break;
block|}
name|cnt
operator|=
name|ap
operator|-
operator|*
name|argvp
operator|+
literal|1
expr_stmt|;
name|new
operator|->
name|e_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
operator|(
name|u_int
operator|)
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|e_orig
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
operator|(
name|u_int
operator|)
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|e_len
operator|=
operator|(
name|int
operator|*
operator|)
name|emalloc
argument_list|(
operator|(
name|u_int
operator|)
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|argv
operator|=
operator|*
name|argvp
operator|,
name|cnt
operator|=
literal|0
init|;
name|argv
operator|<
name|ap
condition|;
operator|++
name|argv
operator|,
operator|++
name|cnt
control|)
block|{
name|new
operator|->
name|e_orig
index|[
name|cnt
index|]
operator|=
operator|*
name|argv
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|argv
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'{'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
name|new
operator|->
name|e_argv
index|[
name|cnt
index|]
operator|=
name|emalloc
argument_list|(
operator|(
name|u_int
operator|)
literal|1024
argument_list|)
expr_stmt|;
name|new
operator|->
name|e_len
index|[
name|cnt
index|]
operator|=
literal|1024
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|*
name|p
condition|)
block|{
name|new
operator|->
name|e_argv
index|[
name|cnt
index|]
operator|=
operator|*
name|argv
expr_stmt|;
name|new
operator|->
name|e_len
index|[
name|cnt
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|new
operator|->
name|e_argv
index|[
name|cnt
index|]
operator|=
name|new
operator|->
name|e_orig
index|[
name|cnt
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|argvp
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -follow functions --  *  *	Always true, causes symbolic links to be followed on a global  *	basis.  */
end_comment

begin_function
name|PLAN
modifier|*
name|c_follow
parameter_list|()
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_PHYSICAL
expr_stmt|;
name|ftsoptions
operator||=
name|FTS_LOGICAL
expr_stmt|;
name|NEW
argument_list|(
name|T_FOLLOW
argument_list|,
name|f_always_true
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -fstype functions --  *  *	True if the file is of a certain type.  */
end_comment

begin_macro
name|f_fstype
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|dev_t
name|curdev
decl_stmt|;
name|struct
name|statfs
name|sb
decl_stmt|;
specifier|static
name|short
name|curtype
decl_stmt|;
comment|/* only check when we cross mount point */
if|if
condition|(
name|curdev
operator|!=
name|entry
operator|->
name|statb
operator|.
name|st_dev
condition|)
block|{
if|if
condition|(
name|statfs
argument_list|(
name|entry
operator|->
name|name
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: %s: %s.\n"
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|curtype
operator|=
name|sb
operator|.
name|f_type
expr_stmt|;
block|}
return|return
operator|(
name|plan
operator|->
name|flags
operator|==
name|curtype
operator|)
return|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_fstype
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|PLAN
modifier|*
name|new
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|NEW
argument_list|(
name|T_FSTYPE
argument_list|,
name|f_fstype
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|arg
condition|)
block|{
case|case
literal|'m'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"mfs"
argument_list|)
condition|)
block|{
name|new
operator|->
name|flags
operator|=
name|MOUNT_MFS
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"nfs"
argument_list|)
condition|)
block|{
name|new
operator|->
name|flags
operator|=
name|MOUNT_NFS
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"pc"
argument_list|)
condition|)
block|{
name|new
operator|->
name|flags
operator|=
name|MOUNT_PC
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ufs"
argument_list|)
condition|)
block|{
name|new
operator|->
name|flags
operator|=
name|MOUNT_UFS
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
break|break;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: unknown file type %s.\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * -group gname functions --  *  *	True if the file belongs to the group gname.  If gname is numeric and  *	an equivalent of the getgrnam() function does not return a valid group  *	name, gname is taken as a group ID.  */
end_comment

begin_macro
name|f_group
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|entry
operator|->
name|statb
operator|.
name|st_gid
operator|==
name|plan
operator|->
name|g_data
condition|?
name|FIND_TRUE
else|:
name|FIND_FALSE
operator|)
return|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_group
parameter_list|(
name|gname
parameter_list|)
name|char
modifier|*
name|gname
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|struct
name|group
modifier|*
name|g
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|g
operator|=
name|getgrnam
argument_list|(
name|gname
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
block|{
name|gid
operator|=
name|atoi
argument_list|(
name|gname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gid
operator|==
literal|0
operator|&&
name|gname
index|[
literal|0
index|]
operator|!=
literal|'0'
condition|)
name|bad_arg
argument_list|(
literal|"-group"
argument_list|,
literal|"no such group"
argument_list|)
expr_stmt|;
block|}
else|else
name|gid
operator|=
name|g
operator|->
name|gr_gid
expr_stmt|;
name|NEW
argument_list|(
name|T_GROUP
argument_list|,
name|f_group
argument_list|)
expr_stmt|;
name|new
operator|->
name|g_data
operator|=
name|gid
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -inum n functions --  *  *	True if the file has inode # n.  */
end_comment

begin_macro
name|f_inum
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|COMPARE
argument_list|(
name|entry
operator|->
name|statb
operator|.
name|st_ino
argument_list|,
name|plan
operator|->
name|i_data
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_inum
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|NEW
argument_list|(
name|T_INUM
argument_list|,
name|f_inum
argument_list|)
expr_stmt|;
name|new
operator|->
name|i_data
operator|=
name|find_parsenum
argument_list|(
name|new
argument_list|,
literal|"-inum"
argument_list|,
name|arg
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -links n functions --  *  *	True if the file has n links.  */
end_comment

begin_macro
name|f_links
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|COMPARE
argument_list|(
name|entry
operator|->
name|statb
operator|.
name|st_nlink
argument_list|,
name|plan
operator|->
name|l_data
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_links
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|NEW
argument_list|(
name|T_LINKS
argument_list|,
name|f_links
argument_list|)
expr_stmt|;
name|new
operator|->
name|l_data
operator|=
name|find_parsenum
argument_list|(
name|new
argument_list|,
literal|"-links"
argument_list|,
name|arg
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -ls functions --  *  *	Always true - prints the current entry to stdout in "ls" format.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|f_ls
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printlong
argument_list|(
name|entry
operator|->
name|path
argument_list|,
name|entry
operator|->
name|accpath
argument_list|,
operator|&
name|entry
operator|->
name|statb
argument_list|)
expr_stmt|;
return|return
operator|(
name|FIND_TRUE
operator|)
return|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_ls
parameter_list|()
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|output_specified
operator|=
literal|1
expr_stmt|;
name|NEW
argument_list|(
name|T_LS
argument_list|,
name|f_ls
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -name functions --  *  *	True if the basename of the filename being examined  *	matches pattern using Pattern Matching Notation S3.14  */
end_comment

begin_macro
name|f_name
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|fnmatch
argument_list|(
name|plan
operator|->
name|c_data
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|FNM_QUOTE
argument_list|)
condition|?
name|FIND_TRUE
else|:
name|FIND_FALSE
operator|)
return|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_name
parameter_list|(
name|pattern
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|NEW
argument_list|(
name|T_NAME
argument_list|,
name|f_name
argument_list|)
expr_stmt|;
name|new
operator|->
name|c_data
operator|=
name|pattern
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -newer file functions --  *  *	True if the current file has been modified more recently  *	then the modification time of the file named by the pathname  *	file.  */
end_comment

begin_macro
name|f_newer
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|entry
operator|->
name|statb
operator|.
name|st_mtime
operator|>
name|plan
operator|->
name|t_data
condition|?
name|FIND_TRUE
else|:
name|FIND_FALSE
operator|)
return|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_newer
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: %s: %s.\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|NEW
argument_list|(
name|T_NEWER
argument_list|,
name|f_newer
argument_list|)
expr_stmt|;
name|new
operator|->
name|t_data
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -nogroup functions --  *  *	True if file belongs to a user ID for which the equivalent  *	of the getgrnam() 9.2.1 [POSIX.1] function returns NULL.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|f_nogroup
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|group_from_gid
argument_list|(
name|entry
operator|->
name|statb
operator|.
name|st_gid
argument_list|,
literal|1
argument_list|)
condition|?
name|FIND_FALSE
else|:
name|FIND_TRUE
operator|)
return|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_nogroup
parameter_list|()
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|NEW
argument_list|(
name|T_NOGROUP
argument_list|,
name|f_nogroup
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -nouser functions --  *  *	True if file belongs to a user ID for which the equivalent  *	of the getpwuid() 9.2.2 [POSIX.1] function returns NULL.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|f_nouser
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|user_from_uid
argument_list|(
name|entry
operator|->
name|statb
operator|.
name|st_uid
argument_list|,
literal|1
argument_list|)
condition|?
name|FIND_FALSE
else|:
name|FIND_TRUE
operator|)
return|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_nouser
parameter_list|()
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|NEW
argument_list|(
name|T_NOUSER
argument_list|,
name|f_nouser
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -perm functions --  *  *	The mode argument is used to represent file mode bits.  If it starts  *	with a leading digit, it's treated as an octal mode, otherwise as a  *	symbolic mode.  */
end_comment

begin_macro
name|f_perm
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|mode_t
name|mode
decl_stmt|;
name|mode
operator|=
name|entry
operator|->
name|statb
operator|.
name|st_mode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator||
name|S_ISTXT
operator||
name|S_IRWXU
operator||
name|S_IRWXG
operator||
name|S_IRWXO
operator|)
expr_stmt|;
if|if
condition|(
name|plan
operator|->
name|flags
condition|)
return|return
operator|(
operator|(
name|plan
operator|->
name|m_data
operator||
name|mode
operator|)
operator|==
name|mode
operator|)
return|;
else|else
return|return
operator|(
name|mode
operator|==
name|plan
operator|->
name|m_data
operator|)
return|;
comment|/* NOTREACHED */
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_perm
parameter_list|(
name|perm
parameter_list|)
name|char
modifier|*
name|perm
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|NEW
argument_list|(
name|T_PERM
argument_list|,
name|f_perm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|perm
operator|==
literal|'-'
condition|)
block|{
name|new
operator|->
name|flags
operator|=
literal|1
expr_stmt|;
operator|++
name|perm
expr_stmt|;
block|}
if|if
condition|(
name|setmode
argument_list|(
name|perm
argument_list|)
condition|)
name|bad_arg
argument_list|(
literal|"-perm"
argument_list|,
literal|"illegal mode string"
argument_list|)
expr_stmt|;
name|new
operator|->
name|m_data
operator|=
name|getmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -print functions --  *  *	Always true, causes the current pathame to be written to  *	standard output.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|f_print
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|entry
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|FIND_TRUE
operator|)
return|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_print
parameter_list|()
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|output_specified
operator|=
literal|1
expr_stmt|;
name|NEW
argument_list|(
name|T_PRINT
argument_list|,
name|f_print
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -prune functions --  *  *	Prune a portion of the hierarchy.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|f_prune
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|FTS
modifier|*
name|tree
decl_stmt|;
if|if
condition|(
name|ftsset
argument_list|(
name|tree
argument_list|,
name|entry
argument_list|,
name|FTS_SKIP
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find: %s: %s.\n"
argument_list|,
name|entry
operator|->
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FIND_TRUE
operator|)
return|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_prune
parameter_list|()
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|NEW
argument_list|(
name|T_PRUNE
argument_list|,
name|f_prune
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -size n[c] functions --  *  *	True if the file size in bytes, divided by an implementation defined  *	value and rounded up to the next integer, is n.  If n is followed by  *	a c, the size is in bytes.  */
end_comment

begin_define
define|#
directive|define
name|FIND_SIZE
value|512
end_define

begin_decl_stmt
specifier|static
name|int
name|divsize
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_macro
name|f_size
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|off_t
name|size
decl_stmt|;
name|size
operator|=
name|divsize
condition|?
operator|(
name|entry
operator|->
name|statb
operator|.
name|st_size
operator|+
name|FIND_SIZE
operator|-
literal|1
operator|)
operator|/
name|FIND_SIZE
else|:
name|entry
operator|->
name|statb
operator|.
name|st_size
expr_stmt|;
name|COMPARE
argument_list|(
name|size
argument_list|,
name|plan
operator|->
name|o_data
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_size
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|char
name|endch
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|NEW
argument_list|(
name|T_SIZE
argument_list|,
name|f_size
argument_list|)
expr_stmt|;
name|new
operator|->
name|o_data
operator|=
name|find_parsenum
argument_list|(
name|new
argument_list|,
literal|"-size"
argument_list|,
name|arg
argument_list|,
operator|&
name|endch
argument_list|)
expr_stmt|;
if|if
condition|(
name|endch
operator|==
literal|'c'
condition|)
name|divsize
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -type c functions --  *  *	True if the type of the file is c, where c is b, c, d, p, or f for  *	block special file, character special file, directory, FIFO, or  *	regular file, respectively.  */
end_comment

begin_macro
name|f_type
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|entry
operator|->
name|statb
operator|.
name|st_mode
operator|&
name|plan
operator|->
name|m_data
condition|?
name|FIND_TRUE
else|:
name|FIND_FALSE
operator|)
return|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_type
parameter_list|(
name|typestring
parameter_list|)
name|char
modifier|*
name|typestring
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|mode_t
name|mask
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
switch|switch
condition|(
name|typestring
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'b'
case|:
name|mask
operator|=
name|S_IFBLK
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|mask
operator|=
name|S_IFCHR
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|mask
operator|=
name|S_IFDIR
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|mask
operator|=
name|S_IFREG
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|mask
operator|=
name|S_IFLNK
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|mask
operator|=
name|S_IFIFO
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|mask
operator|=
name|S_IFSOCK
expr_stmt|;
break|break;
default|default:
name|bad_arg
argument_list|(
literal|"-type"
argument_list|,
literal|"unknown type"
argument_list|)
expr_stmt|;
block|}
name|NEW
argument_list|(
name|T_TYPE
argument_list|,
name|f_type
argument_list|)
expr_stmt|;
name|new
operator|->
name|m_data
operator|=
name|mask
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -user uname functions --  *  *	True if the file belongs to the user uname.  If uname is numeric and  *	an equivalent of the getpwnam() S9.2.2 [POSIX.1] function does not  *	return a valid user name, uname is taken as a user ID.  */
end_comment

begin_macro
name|f_user
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|entry
operator|->
name|statb
operator|.
name|st_uid
operator|==
name|plan
operator|->
name|u_data
condition|?
name|FIND_TRUE
else|:
name|FIND_FALSE
operator|)
return|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_user
parameter_list|(
name|username
parameter_list|)
name|char
modifier|*
name|username
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|struct
name|passwd
modifier|*
name|p
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|p
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|uid
operator|=
name|atoi
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|==
literal|0
operator|&&
name|username
index|[
literal|0
index|]
operator|!=
literal|'0'
condition|)
name|bad_arg
argument_list|(
literal|"-user"
argument_list|,
literal|"no such user"
argument_list|)
expr_stmt|;
block|}
else|else
name|uid
operator|=
name|p
operator|->
name|pw_uid
expr_stmt|;
name|NEW
argument_list|(
name|T_USER
argument_list|,
name|f_user
argument_list|)
expr_stmt|;
name|new
operator|->
name|u_data
operator|=
name|uid
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -xdev functions --  *  *	Always true, causes find not to decend past directories that have a  *	different device ID (st_dev, see stat() S5.6.2 [POSIX.1])  *  *	Note: this checking is done in find_execute().  */
end_comment

begin_function
name|PLAN
modifier|*
name|c_xdev
parameter_list|()
block|{
specifier|extern
name|int
name|xdev
decl_stmt|;
name|PLAN
modifier|*
name|new
decl_stmt|;
name|xdev
operator|=
literal|1
expr_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|NEW
argument_list|(
name|T_XDEV
argument_list|,
name|f_always_true
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ( expression ) functions --  *  *	True if expression is true.  */
end_comment

begin_macro
name|f_expr
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|PLAN
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|state
decl_stmt|;
for|for
control|(
name|p
operator|=
name|plan
operator|->
name|p_data
index|[
literal|0
index|]
init|;
name|p
operator|&&
operator|(
name|state
operator|=
call|(
name|p
operator|->
name|eval
call|)
argument_list|(
name|p
argument_list|,
name|entry
argument_list|)
operator|)
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
return|return
operator|(
name|state
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * T_OPENPAREN and T_CLOSEPAREN nodes are temporary place markers.  They are  * eliminated during phase 2 of find_formplan() --- the '(' node is converted  * to a T_EXPR node containing the expression and the ')' node is discarded.  */
end_comment

begin_function
name|PLAN
modifier|*
name|c_openparen
parameter_list|()
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|NEW
argument_list|(
name|T_OPENPAREN
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_closeparen
parameter_list|()
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|NEW
argument_list|(
name|T_CLOSEPAREN
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -mtime n functions --  *  *	True if the difference between the file modification time and the  *	current time is n 24 hour periods.  */
end_comment

begin_macro
name|f_mtime
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|time_t
name|now
decl_stmt|;
name|COMPARE
argument_list|(
operator|(
name|now
operator|-
name|entry
operator|->
name|statb
operator|.
name|st_mtime
operator|+
name|SECSPERDAY
operator|-
literal|1
operator|)
operator|/
name|SECSPERDAY
argument_list|,
name|plan
operator|->
name|t_data
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_mtime
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|NEW
argument_list|(
name|T_MTIME
argument_list|,
name|f_mtime
argument_list|)
expr_stmt|;
name|new
operator|->
name|t_data
operator|=
name|find_parsenum
argument_list|(
name|new
argument_list|,
literal|"-mtime"
argument_list|,
name|arg
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ! expression functions --  *  *	Negation of a primary; the unary NOT operator.  */
end_comment

begin_macro
name|f_not
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|PLAN
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|state
decl_stmt|;
for|for
control|(
name|p
operator|=
name|plan
operator|->
name|p_data
index|[
literal|0
index|]
init|;
name|p
operator|&&
operator|(
name|state
operator|=
call|(
name|p
operator|->
name|eval
call|)
argument_list|(
name|p
argument_list|,
name|entry
argument_list|)
operator|)
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
return|return
operator|(
operator|!
name|state
operator|)
return|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_not
parameter_list|()
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|NEW
argument_list|(
name|T_NOT
argument_list|,
name|f_not
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * expression -o expression functions --  *  *	Alternation of primaries; the OR operator.  The second expression is  * not evaluated if the first expression is true.  */
end_comment

begin_macro
name|f_or
argument_list|(
argument|plan
argument_list|,
argument|entry
argument_list|)
end_macro

begin_decl_stmt
name|PLAN
modifier|*
name|plan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|PLAN
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|state
decl_stmt|;
for|for
control|(
name|p
operator|=
name|plan
operator|->
name|p_data
index|[
literal|0
index|]
init|;
name|p
operator|&&
operator|(
name|state
operator|=
call|(
name|p
operator|->
name|eval
call|)
argument_list|(
name|p
argument_list|,
name|entry
argument_list|)
operator|)
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
name|state
condition|)
return|return
operator|(
name|FIND_TRUE
operator|)
return|;
for|for
control|(
name|p
operator|=
name|plan
operator|->
name|p_data
index|[
literal|1
index|]
init|;
name|p
operator|&&
operator|(
name|state
operator|=
call|(
name|p
operator|->
name|eval
call|)
argument_list|(
name|p
argument_list|,
name|entry
argument_list|)
operator|)
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
return|return
operator|(
name|state
operator|)
return|;
block|}
end_block

begin_function
name|PLAN
modifier|*
name|c_or
parameter_list|()
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|NEW
argument_list|(
name|T_OR
argument_list|,
name|f_or
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

end_unit

