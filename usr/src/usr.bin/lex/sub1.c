begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)sub1.c	4.4 (Berkeley) 1/12/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ldefs.c"
end_include

begin_function
name|char
modifier|*
name|getl
parameter_list|(
name|p
parameter_list|)
comment|/* return next line of input, throw away trailing '\n' */
comment|/* returns 0 if eof is had immediately */
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|s
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|gch
argument_list|()
operator|)
operator|!=
literal|0
operator|)
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
operator|*
name|t
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|t
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
operator|&&
name|s
operator|==
name|t
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|prev
operator|=
literal|'\n'
expr_stmt|;
name|pres
operator|=
literal|'\n'
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_macro
name|space
argument_list|(
argument|ch
argument_list|)
end_macro

begin_block
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|digit
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
return|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|s
argument_list|,
argument|p
argument_list|,
argument|d
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|errorf
argument_list|,
literal|"\"%s\", line %d: (Error) "
argument_list|,
name|fptr
operator|>
literal|0
condition|?
name|sargv
index|[
name|fptr
index|]
else|:
literal|"<stdin>"
argument_list|,
name|yyline
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|errorf
argument_list|,
name|s
argument_list|,
name|p
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|errorf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&&
name|sect
operator|!=
name|ENDSECTION
condition|)
block|{
name|sect1dump
argument_list|()
expr_stmt|;
name|sect2dump
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|||
endif|#
directive|endif
name|report
operator|==
literal|1
condition|)
name|statistics
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* error return code */
block|}
end_block

begin_macro
name|warning
argument_list|(
argument|s
argument_list|,
argument|p
argument_list|,
argument|d
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|errorf
argument_list|,
literal|"\"%s\", line %d: (Warning) "
argument_list|,
name|fptr
operator|>
literal|0
condition|?
name|sargv
index|[
name|fptr
index|]
else|:
literal|"<stdin>"
argument_list|,
name|yyline
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|errorf
argument_list|,
name|s
argument_list|,
name|p
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|errorf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|errorf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|index
argument_list|(
argument|a
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|s
index|[
name|k
index|]
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|s
index|[
name|k
index|]
operator|==
name|a
condition|)
return|return
operator|(
name|k
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|alpha
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|ASCII
return|return
operator|(
literal|'a'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'z'
operator|||
literal|'A'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EBCDIC
return|return
operator|(
name|index
argument_list|(
name|c
argument_list|,
literal|"abcdefghijklmnopqrstuvxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
argument_list|)
operator|>=
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|printable
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|ASCII
return|return
operator|(
name|c
operator|>
literal|040
operator|&&
name|c
operator|<
literal|0177
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EBCDIC
return|return
operator|(
name|index
argument_list|(
name|c
argument_list|,
literal|"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.,;:><+*)('&%!-=\""
argument_list|)
operator|>=
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|lgate
argument_list|()
end_macro

begin_block
block|{
name|char
name|fname
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|lgatflg
condition|)
return|return;
name|lgatflg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fout
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"lex.yy.%c"
argument_list|,
name|ratfor
condition|?
literal|'r'
else|:
literal|'c'
argument_list|)
expr_stmt|;
name|fout
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fout
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Can't open %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ratfor
condition|)
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
name|phead1
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* scopy(ptr to str, ptr to str) - copy first arg str to second */
end_comment

begin_comment
comment|/* returns ptr to second arg */
end_comment

begin_macro
name|scopy
argument_list|(
argument|s
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|i
decl_stmt|;
name|i
operator|=
name|t
expr_stmt|;
while|while
condition|(
operator|*
name|i
operator|++
operator|=
operator|*
name|s
operator|++
condition|)
empty_stmt|;
return|return;
block|}
end_block

begin_macro
name|siconv
argument_list|(
argument|t
argument_list|)
end_macro

begin_comment
comment|/* convert string t, return integer value */
end_comment

begin_decl_stmt
name|char
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|sw
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|t
expr_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
literal|'0'
operator|<=
operator|*
name|s
operator|&&
operator|*
name|s
operator|<=
literal|'9'
operator|)
operator|||
operator|*
name|s
operator|==
literal|'-'
operator|)
operator|&&
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
name|sw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
comment|/* neg */
name|sw
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|'0'
operator|<=
operator|*
name|s
operator|&&
operator|*
name|s
operator|<=
literal|'9'
condition|)
name|i
operator|=
name|i
operator|*
literal|10
operator|+
operator|(
operator|*
operator|(
name|s
operator|++
operator|)
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
operator|(
name|sw
condition|?
operator|-
name|i
else|:
name|i
operator|)
return|;
block|}
end_block

begin_comment
comment|/* slength(ptr to str) - return integer length of string arg */
end_comment

begin_comment
comment|/* excludes '\0' terminator */
end_comment

begin_macro
name|slength
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|s
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|*
name|t
operator|++
condition|;
name|n
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_comment
comment|/* scomp(x,y) - return -1 if x< y, 		0 if x == y, 		return 1 if x> y, all lexicographically */
end_comment

begin_macro
name|scomp
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|a
operator|=
name|x
expr_stmt|;
name|d
operator|=
name|y
expr_stmt|;
while|while
condition|(
operator|*
name|a
operator|||
operator|*
name|d
condition|)
block|{
if|if
condition|(
operator|*
name|a
operator|>
operator|*
name|d
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* greater */
if|if
condition|(
operator|*
name|a
operator|<
operator|*
name|d
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* less */
name|a
operator|++
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* equal */
block|}
end_block

begin_macro
name|ctrans
argument_list|(
argument|ss
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|ss
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
operator|*
name|ss
operator|)
operator|!=
literal|'\\'
condition|)
return|return
operator|(
name|c
operator|)
return|;
switch|switch
condition|(
name|c
operator|=
operator|*
operator|++
operator|*
name|ss
condition|)
block|{
case|case
literal|'n'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|c
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|c
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|c
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|c
operator|=
literal|014
expr_stmt|;
break|break;
comment|/* form feed for ascii */
case|case
literal|'\\'
case|:
name|c
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|c
operator|-=
literal|'0'
expr_stmt|;
while|while
condition|(
operator|(
name|k
operator|=
operator|*
operator|(
operator|*
name|ss
operator|+
literal|1
operator|)
operator|)
operator|>=
literal|'0'
operator|&&
name|k
operator|<=
literal|'7'
condition|)
block|{
name|c
operator|=
name|c
operator|*
literal|8
operator|+
name|k
operator|-
literal|'0'
expr_stmt|;
operator|(
operator|*
name|ss
operator|)
operator|++
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_macro
name|cclinter
argument_list|(
argument|sw
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sw
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* sw = 1 ==> ccl */
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|m
decl_stmt|;
if|if
condition|(
operator|!
name|sw
condition|)
block|{
comment|/* is NCCL */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NCH
condition|;
name|i
operator|++
control|)
name|symbol
index|[
name|i
index|]
operator|^=
literal|1
expr_stmt|;
comment|/* reverse value */
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NCH
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|symbol
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|NCH
condition|)
return|return;
name|i
operator|=
name|cindex
index|[
name|i
index|]
expr_stmt|;
comment|/* see if ccl is already in our table */
name|j
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|NCH
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|symbol
index|[
name|j
index|]
operator|&&
name|cindex
index|[
name|j
index|]
operator|!=
name|i
operator|)
operator|||
operator|(
operator|!
name|symbol
index|[
name|j
index|]
operator|&&
name|cindex
index|[
name|j
index|]
operator|==
name|i
operator|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|j
operator|>=
name|NCH
condition|)
return|return;
comment|/* already in */
name|m
operator|=
literal|0
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NCH
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|symbol
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|cindex
index|[
name|i
index|]
condition|)
block|{
name|cindex
index|[
name|i
index|]
operator|=
name|ccount
expr_stmt|;
name|symbol
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|k
operator|=
literal|1
expr_stmt|;
block|}
comment|/* m == 1 implies last value of ccount has been used */
if|if
condition|(
name|m
condition|)
name|ccount
operator|++
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
return|return;
comment|/* is now in as ccount wholly */
comment|/* intersection must be computed */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NCH
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|symbol
index|[
name|i
index|]
condition|)
block|{
name|m
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|cindex
index|[
name|i
index|]
expr_stmt|;
comment|/* will be non-zero */
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|NCH
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|cindex
index|[
name|k
index|]
operator|==
name|j
condition|)
block|{
if|if
condition|(
name|symbol
index|[
name|k
index|]
condition|)
name|symbol
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|cindex
index|[
name|k
index|]
operator|=
name|ccount
expr_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|m
condition|)
name|ccount
operator|++
expr_stmt|;
block|}
block|}
return|return;
block|}
end_block

begin_macro
name|usescape
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|d
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'n'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|c
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|c
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|c
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|c
operator|=
literal|014
expr_stmt|;
break|break;
comment|/* form feed for ascii */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|c
operator|-=
literal|'0'
expr_stmt|;
while|while
condition|(
literal|'0'
operator|<=
operator|(
name|d
operator|=
name|gch
argument_list|()
operator|)
operator|&&
name|d
operator|<=
literal|'7'
condition|)
block|{
name|c
operator|=
name|c
operator|*
literal|8
operator|+
operator|(
name|d
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
literal|'0'
operator|<=
name|peek
operator|&&
name|peek
operator|<=
literal|'7'
operator|)
condition|)
break|break;
block|}
break|break;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_macro
name|lookup
argument_list|(
argument|s
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
if|if
condition|(
name|scomp
argument_list|(
name|s
argument_list|,
operator|*
name|t
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
name|i
operator|++
expr_stmt|;
name|t
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|cpyact
argument_list|()
end_macro

begin_block
block|{
comment|/* copy C action to the next ; or closing } */
specifier|register
name|int
name|brac
decl_stmt|,
name|c
decl_stmt|,
name|mth
decl_stmt|;
name|int
name|savline
decl_stmt|,
name|sw
decl_stmt|;
name|brac
operator|=
literal|0
expr_stmt|;
name|sw
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
operator|!
name|eof
condition|)
block|{
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
name|swt
label|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'|'
case|:
if|if
condition|(
name|brac
operator|==
literal|0
operator|&&
name|sw
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|peek
operator|==
literal|'|'
condition|)
name|gch
argument_list|()
expr_stmt|;
comment|/* eat up an extra '|' */
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
literal|';'
case|:
if|if
condition|(
name|brac
operator|==
literal|0
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|'{'
case|:
name|brac
operator|++
expr_stmt|;
name|savline
operator|=
name|yyline
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|brac
operator|--
expr_stmt|;
if|if
condition|(
name|brac
operator|==
literal|0
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|'/'
case|:
comment|/* look for comments */
name|putc
argument_list|(
name|c
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'*'
condition|)
goto|goto
name|swt
goto|;
comment|/* it really is a comment */
name|putc
argument_list|(
name|c
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|savline
operator|=
name|yyline
expr_stmt|;
while|while
condition|(
name|c
operator|=
name|gch
argument_list|()
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|gch
argument_list|()
operator|)
operator|==
literal|'/'
condition|)
goto|goto
name|loop
goto|;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
name|yyline
operator|=
name|savline
expr_stmt|;
name|error
argument_list|(
literal|"EOF inside comment"
argument_list|)
expr_stmt|;
case|case
literal|'\''
case|:
comment|/* character constant */
name|mth
operator|=
literal|'\''
expr_stmt|;
goto|goto
name|string
goto|;
case|case
literal|'"'
case|:
comment|/* character string */
name|mth
operator|=
literal|'"'
expr_stmt|;
name|string
label|:
name|putc
argument_list|(
name|c
argument_list|,
name|fout
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|=
name|gch
argument_list|()
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|mth
condition|)
goto|goto
name|loop
goto|;
name|putc
argument_list|(
name|c
argument_list|,
name|fout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|yyline
operator|--
expr_stmt|;
name|error
argument_list|(
literal|"Non-terminated string or character constant"
argument_list|)
expr_stmt|;
block|}
block|}
name|error
argument_list|(
literal|"EOF in string or character constant"
argument_list|)
expr_stmt|;
case|case
literal|'\0'
case|:
name|yyline
operator|=
name|savline
expr_stmt|;
name|error
argument_list|(
literal|"Action does not terminate"
argument_list|)
expr_stmt|;
default|default:
break|break;
comment|/* usual character */
block|}
name|loop
label|:
if|if
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|sw
operator|=
name|FALSE
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|"Premature EOF"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|gch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|static
name|int
name|hadeof
decl_stmt|;
if|if
condition|(
name|hadeof
condition|)
block|{
name|hadeof
operator|=
literal|0
expr_stmt|;
name|yyline
operator|=
literal|0
expr_stmt|;
block|}
name|prev
operator|=
name|pres
expr_stmt|;
name|c
operator|=
name|pres
operator|=
name|peek
expr_stmt|;
name|peek
operator|=
name|pushptr
operator|>
name|pushc
condition|?
operator|*
operator|--
name|pushptr
else|:
name|getc
argument_list|(
name|fin
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|==
name|EOF
operator|&&
name|sargc
operator|>
literal|1
condition|)
block|{
name|hadeof
operator|=
literal|1
expr_stmt|;
name|fclose
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|fin
operator|=
name|fopen
argument_list|(
name|sargv
index|[
operator|++
name|fptr
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|==
name|NULL
condition|)
block|{
name|yyline
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"Cannot open file %s"
argument_list|,
name|sargv
index|[
name|fptr
index|]
argument_list|)
expr_stmt|;
block|}
name|peek
operator|=
name|getc
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|sargc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|eof
operator|=
name|TRUE
expr_stmt|;
name|fclose
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|yyline
operator|++
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_macro
name|mn2
argument_list|(
argument|a
argument_list|,
argument|d
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|,
name|d
decl_stmt|,
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|name
index|[
name|tptr
index|]
operator|=
name|a
expr_stmt|;
name|left
index|[
name|tptr
index|]
operator|=
name|d
expr_stmt|;
name|right
index|[
name|tptr
index|]
operator|=
name|c
expr_stmt|;
name|parent
index|[
name|tptr
index|]
operator|=
literal|0
expr_stmt|;
name|nullstr
index|[
name|tptr
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|a
condition|)
block|{
case|case
name|RSTR
case|:
name|parent
index|[
name|d
index|]
operator|=
name|tptr
expr_stmt|;
break|break;
case|case
name|BAR
case|:
case|case
name|RNEWE
case|:
if|if
condition|(
name|nullstr
index|[
name|d
index|]
operator|||
name|nullstr
index|[
name|c
index|]
condition|)
name|nullstr
index|[
name|tptr
index|]
operator|=
name|TRUE
expr_stmt|;
name|parent
index|[
name|d
index|]
operator|=
name|parent
index|[
name|c
index|]
operator|=
name|tptr
expr_stmt|;
break|break;
case|case
name|RCAT
case|:
case|case
name|DIV
case|:
if|if
condition|(
name|nullstr
index|[
name|d
index|]
operator|&&
name|nullstr
index|[
name|c
index|]
condition|)
name|nullstr
index|[
name|tptr
index|]
operator|=
name|TRUE
expr_stmt|;
name|parent
index|[
name|d
index|]
operator|=
name|parent
index|[
name|c
index|]
operator|=
name|tptr
expr_stmt|;
break|break;
case|case
name|RSCON
case|:
name|parent
index|[
name|d
index|]
operator|=
name|tptr
expr_stmt|;
name|nullstr
index|[
name|tptr
index|]
operator|=
name|nullstr
index|[
name|d
index|]
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
default|default:
name|warning
argument_list|(
literal|"bad switch mn2 %d %d"
argument_list|,
name|a
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
if|if
condition|(
name|tptr
operator|>
name|treesize
condition|)
name|error
argument_list|(
literal|"Parse tree too big %s"
argument_list|,
operator|(
name|treesize
operator|==
name|TREESIZE
condition|?
literal|"\nTry using %e num"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|tptr
operator|++
operator|)
return|;
block|}
end_block

begin_macro
name|mn1
argument_list|(
argument|a
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|,
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|name
index|[
name|tptr
index|]
operator|=
name|a
expr_stmt|;
name|left
index|[
name|tptr
index|]
operator|=
name|d
expr_stmt|;
name|parent
index|[
name|tptr
index|]
operator|=
literal|0
expr_stmt|;
name|nullstr
index|[
name|tptr
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|a
condition|)
block|{
case|case
name|RCCL
case|:
case|case
name|RNCCL
case|:
if|if
condition|(
name|slength
argument_list|(
name|d
argument_list|)
operator|==
literal|0
condition|)
name|nullstr
index|[
name|tptr
index|]
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|STAR
case|:
case|case
name|QUEST
case|:
name|nullstr
index|[
name|tptr
index|]
operator|=
name|TRUE
expr_stmt|;
name|parent
index|[
name|d
index|]
operator|=
name|tptr
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
case|case
name|CARAT
case|:
name|nullstr
index|[
name|tptr
index|]
operator|=
name|nullstr
index|[
name|d
index|]
expr_stmt|;
name|parent
index|[
name|d
index|]
operator|=
name|tptr
expr_stmt|;
break|break;
case|case
name|S2FINAL
case|:
name|nullstr
index|[
name|tptr
index|]
operator|=
name|TRUE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
name|FINAL
case|:
case|case
name|S1FINAL
case|:
break|break;
default|default:
name|warning
argument_list|(
literal|"bad switch mn1 %d %d"
argument_list|,
name|a
argument_list|,
name|d
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
if|if
condition|(
name|tptr
operator|>
name|treesize
condition|)
name|error
argument_list|(
literal|"Parse tree too big %s"
argument_list|,
operator|(
name|treesize
operator|==
name|TREESIZE
condition|?
literal|"\nTry using %e num"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|tptr
operator|++
operator|)
return|;
block|}
end_block

begin_macro
name|mn0
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|name
index|[
name|tptr
index|]
operator|=
name|a
expr_stmt|;
name|parent
index|[
name|tptr
index|]
operator|=
literal|0
expr_stmt|;
name|nullstr
index|[
name|tptr
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|a
operator|>=
name|NCH
condition|)
switch|switch
condition|(
name|a
condition|)
block|{
case|case
name|RNULLS
case|:
name|nullstr
index|[
name|tptr
index|]
operator|=
name|TRUE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
default|default:
name|warning
argument_list|(
literal|"bad switch mn0 %d"
argument_list|,
name|a
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
if|if
condition|(
name|tptr
operator|>
name|treesize
condition|)
name|error
argument_list|(
literal|"Parse tree too big %s"
argument_list|,
operator|(
name|treesize
operator|==
name|TREESIZE
condition|?
literal|"\nTry using %e num"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|tptr
operator|++
operator|)
return|;
block|}
end_block

begin_macro
name|munput
argument_list|(
argument|t
argument_list|,
argument|p
argument_list|)
end_macro

begin_comment
comment|/* implementation dependent */
end_comment

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|'c'
condition|)
block|{
operator|*
name|pushptr
operator|++
operator|=
name|peek
expr_stmt|;
comment|/* watch out for this */
name|peek
operator|=
operator|(
name|int
operator|)
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
literal|'s'
condition|)
block|{
operator|*
name|pushptr
operator|++
operator|=
name|peek
expr_stmt|;
name|peek
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|i
operator|=
name|slength
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|1
condition|;
name|j
operator|--
control|)
operator|*
name|pushptr
operator|++
operator|=
name|p
index|[
name|j
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
else|else
name|error
argument_list|(
literal|"Unrecognized munput option %c"
argument_list|,
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pushptr
operator|>=
name|pushc
operator|+
name|TOKENSIZE
condition|)
name|error
argument_list|(
literal|"Too many characters pushed"
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|dupl
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* duplicate the subtree whose root is n, return ptr to it */
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|name
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|NCH
condition|)
return|return
operator|(
name|mn0
argument_list|(
name|i
argument_list|)
operator|)
return|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|RNULLS
case|:
return|return
operator|(
name|mn0
argument_list|(
name|i
argument_list|)
operator|)
return|;
case|case
name|RCCL
case|:
case|case
name|RNCCL
case|:
case|case
name|FINAL
case|:
case|case
name|S1FINAL
case|:
case|case
name|S2FINAL
case|:
return|return
operator|(
name|mn1
argument_list|(
name|i
argument_list|,
name|left
index|[
name|n
index|]
argument_list|)
operator|)
return|;
case|case
name|STAR
case|:
case|case
name|QUEST
case|:
case|case
name|PLUS
case|:
case|case
name|CARAT
case|:
return|return
operator|(
name|mn1
argument_list|(
name|i
argument_list|,
name|dupl
argument_list|(
name|left
index|[
name|n
index|]
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|RSTR
case|:
case|case
name|RSCON
case|:
return|return
operator|(
name|mn2
argument_list|(
name|i
argument_list|,
name|dupl
argument_list|(
name|left
index|[
name|n
index|]
argument_list|)
argument_list|,
name|right
index|[
name|n
index|]
argument_list|)
operator|)
return|;
case|case
name|BAR
case|:
case|case
name|RNEWE
case|:
case|case
name|RCAT
case|:
case|case
name|DIV
case|:
return|return
operator|(
name|mn2
argument_list|(
name|i
argument_list|,
name|dupl
argument_list|(
name|left
index|[
name|n
index|]
argument_list|)
argument_list|,
name|dupl
argument_list|(
name|right
index|[
name|n
index|]
argument_list|)
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
default|default:
name|warning
argument_list|(
literal|"bad switch dupl %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|allprint
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|014
case|:
name|printf
argument_list|(
literal|"\\f"
argument_list|)
expr_stmt|;
name|charc
operator|++
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|printf
argument_list|(
literal|"\\n"
argument_list|)
expr_stmt|;
name|charc
operator|++
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|printf
argument_list|(
literal|"\\t"
argument_list|)
expr_stmt|;
name|charc
operator|++
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|printf
argument_list|(
literal|"\\b"
argument_list|)
expr_stmt|;
name|charc
operator|++
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|printf
argument_list|(
literal|"\\\bb"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|printable
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\\%-3o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|charc
operator|+=
literal|3
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|charc
operator|++
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|strpt
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|charc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|allprint
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|charc
operator|>
name|LINESIZE
condition|)
block|{
name|charc
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_block

begin_macro
name|sect1dump
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"Sect 1:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
index|[
literal|0
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"str	trans\n"
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|def
index|[
operator|++
name|i
index|]
condition|)
name|printf
argument_list|(
literal|"%s\t%s\n"
argument_list|,
name|def
index|[
name|i
index|]
argument_list|,
name|subs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sname
index|[
literal|0
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"start names\n"
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|sname
index|[
operator|++
name|i
index|]
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|sname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chset
operator|==
name|TRUE
condition|)
block|{
name|printf
argument_list|(
literal|"char set changed\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NCH
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|ctable
index|[
name|i
index|]
condition|)
block|{
name|allprint
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|printable
argument_list|(
name|ctable
index|[
name|i
index|]
argument_list|)
condition|?
name|putchar
argument_list|(
name|ctable
index|[
name|i
index|]
argument_list|)
else|:
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|ctable
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_macro
name|sect2dump
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"Sect 2:\n"
argument_list|)
expr_stmt|;
name|treedump
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|treedump
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"treedump %d nodes:\n"
argument_list|,
name|tptr
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|tptr
condition|;
name|t
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%4d "
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|parent
index|[
name|t
index|]
condition|?
name|printf
argument_list|(
literal|"p=%4d"
argument_list|,
name|parent
index|[
name|t
index|]
argument_list|)
else|:
name|printf
argument_list|(
literal|"      "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
name|t
index|]
operator|<
name|NCH
condition|)
block|{
name|allprint
argument_list|(
name|name
index|[
name|t
index|]
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|name
index|[
name|t
index|]
condition|)
block|{
case|case
name|RSTR
case|:
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|left
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|allprint
argument_list|(
name|right
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCCL
case|:
name|printf
argument_list|(
literal|"ccl "
argument_list|)
expr_stmt|;
name|strpt
argument_list|(
name|left
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|RNCCL
case|:
name|printf
argument_list|(
literal|"nccl "
argument_list|)
expr_stmt|;
name|strpt
argument_list|(
name|left
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|printf
argument_list|(
literal|"/ %d %d"
argument_list|,
name|left
index|[
name|t
index|]
argument_list|,
name|right
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|BAR
case|:
name|printf
argument_list|(
literal|"| %d %d"
argument_list|,
name|left
index|[
name|t
index|]
argument_list|,
name|right
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCAT
case|:
name|printf
argument_list|(
literal|"cat %d %d"
argument_list|,
name|left
index|[
name|t
index|]
argument_list|,
name|right
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|printf
argument_list|(
literal|"+ %d"
argument_list|,
name|left
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|STAR
case|:
name|printf
argument_list|(
literal|"* %d"
argument_list|,
name|left
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CARAT
case|:
name|printf
argument_list|(
literal|"^ %d"
argument_list|,
name|left
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUEST
case|:
name|printf
argument_list|(
literal|"? %d"
argument_list|,
name|left
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|RNULLS
case|:
name|printf
argument_list|(
literal|"nullstring"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FINAL
case|:
name|printf
argument_list|(
literal|"final %d"
argument_list|,
name|left
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|S1FINAL
case|:
name|printf
argument_list|(
literal|"s1final %d"
argument_list|,
name|left
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|S2FINAL
case|:
name|printf
argument_list|(
literal|"s2final %d"
argument_list|,
name|left
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|RNEWE
case|:
name|printf
argument_list|(
literal|"new %d %d"
argument_list|,
name|left
index|[
name|t
index|]
argument_list|,
name|right
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSCON
case|:
name|p
operator|=
name|right
index|[
name|t
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"start %s"
argument_list|,
name|sname
index|[
operator|*
name|p
operator|++
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|printf
argument_list|(
literal|", %s"
argument_list|,
name|sname
index|[
operator|*
name|p
operator|++
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|left
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown %d %d %d"
argument_list|,
name|name
index|[
name|t
index|]
argument_list|,
name|left
index|[
name|t
index|]
argument_list|,
name|right
index|[
name|t
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nullstr
index|[
name|t
index|]
condition|)
name|printf
argument_list|(
literal|"\t(null poss.)"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

