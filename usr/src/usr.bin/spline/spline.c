begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)spline.c	4.5 (Berkeley) 12/2/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_define
define|#
directive|define
name|NP
value|1000
end_define

begin_define
define|#
directive|define
name|INF
value|HUGE
end_define

begin_struct
struct|struct
name|proj
block|{
name|int
name|lbf
decl_stmt|,
name|ubf
decl_stmt|;
name|float
name|a
decl_stmt|,
name|b
decl_stmt|,
name|lb
decl_stmt|,
name|ub
decl_stmt|,
name|quant
decl_stmt|,
name|mult
decl_stmt|,
name|val
index|[
name|NP
index|]
decl_stmt|;
block|}
name|x
struct|,
name|y
struct|;
end_struct

begin_decl_stmt
name|float
modifier|*
name|diag
decl_stmt|,
modifier|*
name|r
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|dx
init|=
literal|1.
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|ni
init|=
literal|100.
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|auta
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|periodic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|konst
init|=
literal|0.0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|zero
init|=
literal|0.
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Spline fit technique let x,y be vectors of abscissas and ordinates     h   be vector of differences hi=xi-xi-1     y"  be vector of 2nd derivs of approx function If the points are numbered 0,1,2,...,n+1 then y" satisfies (R W Hamming, Numerical Methods for Engineers and Scientists, 2nd Ed, p349ff) 	hiy"i-1+2(hi+hi+1)y"i+hi+1y"i+1 	 	= 6[(yi+1-yi)/hi+1-(yi-yi-1)/hi]   i=1,2,...,n  where y"0 = y"n+1 = 0 This is a symmetric tridiagonal system of the form  	| a1 h2               |  |y"1|      |b1| 	| h2 a2 h3            |  |y"2|      |b2| 	|    h3 a3 h4         |  |y"3|  =   |b3| 	|         .           |  | .|      | .| 	|            .        |  | .|      | .| It can be triangularized into 	| d1 h2               |  |y"1|      |r1| 	|    d2 h3            |  |y"2|      |r2| 	|       d3 h4         |  |y"3|  =   |r3| 	|          .          |  | .|      | .| 	|             .       |  | .|      | .| where 	d1 = a1  	r0 = 0  	di = ai - hi2/di-1	1<i<_n  	ri = bi - hiri-1/di-1i	1<_i<_n  the back solution is 	y"n = rn/dn  	y"i = (ri-hi+1y"i+1)/di	1<_i<n  superficially, di and ri don't have to be stored for they can be recalculated backward by the formulas  	di-1 = hi2/(ai-di)	1<i<_n  	ri-1 = (bi-ri)di-1/hi	1<i<_n  unhappily it turns out that the recursion forward for d is quite strongly geometrically convergent--and is wildly unstable going backward. There's similar trouble with r, so the intermediate results must be kept.  Note that n-1 in the program below plays the role of n+1 in the theory  Other boundary conditions_________________________  The boundary conditions are easily generalized to handle  	y0" = ky1", yn+1"   = kyn"  for some constant k.  The above analysis was for k = 0; k = 1 fits parabolas perfectly as well as stright lines; k = 1/2 has been recommended as somehow pleasant.  All that is necessary is to add h1 to a1 and hn+1 to an.   Periodic case_____________  To do this, add 1 more row and column thus  	| a1 h2            h1 |  |y1"|     |b1| 	| h2 a2 h3            |  |y2"|     |b2| 	|    h3 a4 h4         |  |y3"|     |b3| 	|                     |  | .|  =  | .| 	|             .       |  | .|     | .| 	| h1            h0 a0 |  | .|     | .|  where h0=_ hn+1  The same diagonalization procedure works, except for the effect of the 2 corner elements.  Let si be the part of the last element in the ith "diagonalized" row that arises from the extra top corner element.  		s1 = h1  		si = -si-1hi/di-1	2<_i<_n+1  After "diagonalizing", the lower corner element remains. Call ti the bottom element that appears in the ith colomn as the bottom element to its left is eliminated  		t1 = h1  		ti = -ti-1hi/di-1  Evidently ti = si. Elimination along the bottom row introduces further corrections to the bottom right element and to the last element of the right hand side. Call these corrections u and v.  	u1 = v1 = 0  	ui = ui-1-si-1*ti-1/di-1  	vi = vi-1-ri-1*ti-1/di-1	2<_i<_n+1  The back solution is now obtained as follows  	y"n+1 = (rn+1+vn+1)/(dn+1+sn+1+tn+1+un+1)  	y"i = (ri-hi+1*yi+1-si*yn+1)/di	1<_i<_n  Interpolation in the interval xi<_x<_xi+1 is by the formula  	y = yix+ + yi+1x- -(h2i+1/6)[y"i(x+-x+3)+y"i+1(x--x-3)] where 	x+ = xi+1-x  	x- = x-xi */
end_comment

begin_function
name|float
name|rhs
parameter_list|(
name|i
parameter_list|)
block|{
name|int
name|i_
decl_stmt|;
name|double
name|zz
decl_stmt|;
name|i_
operator|=
name|i
operator|==
name|n
operator|-
literal|1
condition|?
literal|0
else|:
name|i
expr_stmt|;
name|zz
operator|=
operator|(
name|y
operator|.
name|val
index|[
name|i
index|]
operator|-
name|y
operator|.
name|val
index|[
name|i
operator|-
literal|1
index|]
operator|)
operator|/
operator|(
name|x
operator|.
name|val
index|[
name|i
index|]
operator|-
name|x
operator|.
name|val
index|[
name|i
operator|-
literal|1
index|]
operator|)
expr_stmt|;
return|return
operator|(
literal|6
operator|*
operator|(
operator|(
name|y
operator|.
name|val
index|[
name|i_
operator|+
literal|1
index|]
operator|-
name|y
operator|.
name|val
index|[
name|i_
index|]
operator|)
operator|/
operator|(
name|x
operator|.
name|val
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|x
operator|.
name|val
index|[
name|i
index|]
operator|)
operator|-
name|zz
operator|)
operator|)
return|;
block|}
end_function

begin_macro
name|spline
argument_list|()
end_macro

begin_block
block|{
name|float
name|d
decl_stmt|,
name|s
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|,
name|hi
decl_stmt|,
name|hi1
decl_stmt|;
name|float
name|h
decl_stmt|;
name|float
name|D2yi
decl_stmt|,
name|D2yi1
decl_stmt|,
name|D2yn1
decl_stmt|,
name|x0
decl_stmt|,
name|x1
decl_stmt|,
name|yy
decl_stmt|,
name|a
decl_stmt|;
name|int
name|end
decl_stmt|;
name|float
name|corr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|m
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|3
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|periodic
condition|)
name|konst
operator|=
literal|0
expr_stmt|;
name|d
operator|=
literal|1
expr_stmt|;
name|r
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|periodic
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|++
name|i
operator|<
name|n
operator|-
operator|!
name|periodic
condition|;
control|)
block|{
comment|/* triangularize */
name|hi
operator|=
name|x
operator|.
name|val
index|[
name|i
index|]
operator|-
name|x
operator|.
name|val
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|hi1
operator|=
name|i
operator|==
name|n
operator|-
literal|1
condition|?
name|x
operator|.
name|val
index|[
literal|1
index|]
operator|-
name|x
operator|.
name|val
index|[
literal|0
index|]
else|:
name|x
operator|.
name|val
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|x
operator|.
name|val
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|hi1
operator|*
name|hi
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|u
operator|=
name|i
operator|==
literal|1
condition|?
name|zero
else|:
name|u
operator|-
name|s
operator|*
name|s
operator|/
name|d
expr_stmt|;
name|v
operator|=
name|i
operator|==
literal|1
condition|?
name|zero
else|:
name|v
operator|-
name|s
operator|*
name|r
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|d
expr_stmt|;
name|r
index|[
name|i
index|]
operator|=
name|rhs
argument_list|(
name|i
argument_list|)
operator|-
name|hi
operator|*
name|r
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|d
expr_stmt|;
name|s
operator|=
operator|-
name|hi
operator|*
name|s
operator|/
name|d
expr_stmt|;
name|a
operator|=
literal|2
operator|*
operator|(
name|hi
operator|+
name|hi1
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|a
operator|+=
name|konst
operator|*
name|hi
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|n
operator|-
literal|2
condition|)
name|a
operator|+=
name|konst
operator|*
name|hi1
expr_stmt|;
name|diag
index|[
name|i
index|]
operator|=
name|d
operator|=
name|i
operator|==
literal|1
condition|?
name|a
else|:
name|a
operator|-
name|hi
operator|*
name|hi
operator|/
name|d
expr_stmt|;
block|}
name|D2yi
operator|=
name|D2yn1
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|-
operator|!
name|periodic
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
comment|/* back substitute */
name|end
operator|=
name|i
operator|==
name|n
operator|-
literal|1
expr_stmt|;
name|hi1
operator|=
name|end
condition|?
name|x
operator|.
name|val
index|[
literal|1
index|]
operator|-
name|x
operator|.
name|val
index|[
literal|0
index|]
else|:
name|x
operator|.
name|val
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|x
operator|.
name|val
index|[
name|i
index|]
expr_stmt|;
name|D2yi1
operator|=
name|D2yi
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|hi
operator|=
name|x
operator|.
name|val
index|[
name|i
index|]
operator|-
name|x
operator|.
name|val
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|corr
operator|=
name|end
condition|?
literal|2
operator|*
name|s
operator|+
name|u
else|:
name|zero
expr_stmt|;
name|D2yi
operator|=
operator|(
name|end
operator|*
name|v
operator|+
name|r
index|[
name|i
index|]
operator|-
name|hi1
operator|*
name|D2yi1
operator|-
name|s
operator|*
name|D2yn1
operator|)
operator|/
operator|(
name|diag
index|[
name|i
index|]
operator|+
name|corr
operator|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
name|D2yn1
operator|=
name|D2yi
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
name|a
operator|=
literal|2
operator|*
operator|(
name|hi
operator|+
name|hi1
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|a
operator|+=
name|konst
operator|*
name|hi
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|n
operator|-
literal|2
condition|)
name|a
operator|+=
name|konst
operator|*
name|hi1
expr_stmt|;
name|d
operator|=
name|diag
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|s
operator|=
operator|-
name|s
operator|*
name|d
operator|/
name|hi
expr_stmt|;
block|}
block|}
else|else
name|D2yi
operator|=
name|D2yn1
expr_stmt|;
if|if
condition|(
operator|!
name|periodic
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|D2yi
operator|=
name|konst
operator|*
name|D2yi1
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|n
operator|-
literal|2
condition|)
name|D2yi1
operator|=
name|konst
operator|*
name|D2yi
expr_stmt|;
block|}
if|if
condition|(
name|end
condition|)
continue|continue;
name|m
operator|=
name|hi1
operator|>
literal|0
condition|?
name|ni
else|:
operator|-
name|ni
expr_stmt|;
name|m
operator|=
literal|1.001
operator|*
name|m
operator|*
name|hi1
operator|/
operator|(
name|x
operator|.
name|ub
operator|-
name|x
operator|.
name|lb
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|<=
literal|0
condition|)
name|m
operator|=
literal|1
expr_stmt|;
name|h
operator|=
name|hi1
operator|/
name|m
expr_stmt|;
for|for
control|(
name|j
operator|=
name|m
init|;
name|j
operator|>
literal|0
operator|||
name|i
operator|==
literal|0
operator|&&
name|j
operator|==
literal|0
condition|;
name|j
operator|--
control|)
block|{
comment|/* interpolate */
name|x0
operator|=
operator|(
name|m
operator|-
name|j
operator|)
operator|*
name|h
operator|/
name|hi1
expr_stmt|;
name|x1
operator|=
name|j
operator|*
name|h
operator|/
name|hi1
expr_stmt|;
name|yy
operator|=
name|D2yi
operator|*
operator|(
name|x0
operator|-
name|x0
operator|*
name|x0
operator|*
name|x0
operator|)
operator|+
name|D2yi1
operator|*
operator|(
name|x1
operator|-
name|x1
operator|*
name|x1
operator|*
name|x1
operator|)
expr_stmt|;
name|yy
operator|=
name|y
operator|.
name|val
index|[
name|i
index|]
operator|*
name|x0
operator|+
name|y
operator|.
name|val
index|[
name|i
operator|+
literal|1
index|]
operator|*
name|x1
operator|-
name|hi1
operator|*
name|hi1
operator|*
name|yy
operator|/
literal|6
expr_stmt|;
name|printf
argument_list|(
literal|"%f "
argument_list|,
name|x
operator|.
name|val
index|[
name|i
index|]
operator|+
name|j
operator|*
name|h
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%f\n"
argument_list|,
name|yy
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|readin
argument_list|()
end_macro

begin_block
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|NP
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|auta
condition|)
name|x
operator|.
name|val
index|[
name|n
index|]
operator|=
name|n
operator|*
name|dx
operator|+
name|x
operator|.
name|lb
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|getfloat
argument_list|(
operator|&
name|x
operator|.
name|val
index|[
name|n
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|getfloat
argument_list|(
operator|&
name|y
operator|.
name|val
index|[
name|n
index|]
argument_list|)
condition|)
break|break;
block|}
block|}
end_block

begin_macro
name|getfloat
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|float
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|int
name|i
decl_stmt|;
specifier|extern
name|double
name|atof
parameter_list|()
function_decl|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|buf
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
continue|continue;
block|}
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|30
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|buf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
condition|)
continue|continue;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'.'
case|:
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
continue|continue;
block|}
break|break;
block|}
name|buf
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
operator|*
name|p
operator|=
name|atof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|getlim
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proj
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|lbf
operator|&&
name|p
operator|->
name|lb
operator|>
operator|(
name|p
operator|->
name|val
index|[
name|i
index|]
operator|)
condition|)
name|p
operator|->
name|lb
operator|=
name|p
operator|->
name|val
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|ubf
operator|&&
name|p
operator|->
name|ub
operator|<
operator|(
name|p
operator|->
name|val
index|[
name|i
index|]
operator|)
condition|)
name|p
operator|->
name|ub
operator|=
name|p
operator|->
name|val
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|int
name|i
decl_stmt|;
name|x
operator|.
name|lbf
operator|=
name|x
operator|.
name|ubf
operator|=
name|y
operator|.
name|lbf
operator|=
name|y
operator|.
name|ubf
operator|=
literal|0
expr_stmt|;
name|x
operator|.
name|lb
operator|=
name|INF
expr_stmt|;
name|x
operator|.
name|ub
operator|=
operator|-
name|INF
expr_stmt|;
name|y
operator|.
name|lb
operator|=
name|INF
expr_stmt|;
name|y
operator|.
name|ub
operator|=
operator|-
name|INF
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
name|argv
operator|++
expr_stmt|;
name|again
label|:
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'-'
case|:
name|argv
index|[
literal|0
index|]
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
case|case
literal|'a'
case|:
name|auta
operator|=
literal|1
expr_stmt|;
name|numb
argument_list|(
operator|&
name|dx
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|numb
argument_list|(
operator|&
name|konst
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|numb
argument_list|(
operator|&
name|ni
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|periodic
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
operator|!
name|numb
argument_list|(
operator|&
name|x
operator|.
name|lb
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
condition|)
break|break;
name|x
operator|.
name|lbf
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|numb
argument_list|(
operator|&
name|x
operator|.
name|ub
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
condition|)
break|break;
name|x
operator|.
name|ubf
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad agrument\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|auta
operator|&&
operator|!
name|x
operator|.
name|lbf
condition|)
name|x
operator|.
name|lb
operator|=
literal|0
expr_stmt|;
name|readin
argument_list|()
expr_stmt|;
name|getlim
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
name|getlim
argument_list|(
operator|&
name|y
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dx
argument_list|)
expr_stmt|;
name|diag
operator|=
operator|(
name|float
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|i
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|float
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
operator|||
operator|!
name|spline
argument_list|()
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%f "
argument_list|,
name|x
operator|.
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%f\n"
argument_list|,
name|y
operator|.
name|val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|numb
argument_list|(
argument|np
argument_list|,
argument|argcp
argument_list|,
argument|argvp
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|argcp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
modifier|*
name|np
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|atof
parameter_list|()
function_decl|;
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|argcp
operator|<=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|c
operator|=
operator|(
operator|*
name|argvp
operator|)
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'.'
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|np
operator|=
name|atof
argument_list|(
operator|(
operator|*
name|argvp
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
operator|*
name|argcp
operator|)
operator|--
expr_stmt|;
operator|(
operator|*
name|argvp
operator|)
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

end_unit

