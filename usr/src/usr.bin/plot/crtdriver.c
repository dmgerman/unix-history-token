begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * %sccs.include.proprietary.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)crtdriver.c	4.3 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* This driver is used with crtplot.c. It is essentially the same driver as the one in /usr/src/cmd/plot. Unfortunately, the curses library has some of the same names as does as the functions that the driver calls.  These have been changed.  Also, one of the commands has been removed since they don't make sense for crt's. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_decl_stmt
name|float
name|deltx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|delty
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|std
init|=
literal|1
decl_stmt|;
name|FILE
modifier|*
name|fin
decl_stmt|;
while|while
condition|(
name|argc
operator|--
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|argv
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'l'
case|:
name|deltx
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|delty
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
else|else
block|{
name|std
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't open %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fplt
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|std
condition|)
name|fplt
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|fplt
argument_list|(
argument|fin
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fin
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
name|char
name|s
index|[
literal|256
index|]
decl_stmt|;
name|int
name|xi
decl_stmt|,
name|yi
decl_stmt|,
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|r
comment|/*,dx,n,i*/
decl_stmt|;
comment|/*int pat[256];*/
name|openpl
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fin
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'m'
case|:
name|xi
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|yi
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|plot_move
argument_list|(
name|xi
argument_list|,
name|yi
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|x0
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|y0
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|x1
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|y1
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|line
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|getstr
argument_list|(
name|s
argument_list|,
name|fin
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|plot_erase
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|xi
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|yi
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|point
argument_list|(
name|xi
argument_list|,
name|yi
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|xi
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|yi
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|cont
argument_list|(
name|xi
argument_list|,
name|yi
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|x0
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|y0
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|x1
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|y1
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|space
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|xi
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|yi
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|x0
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|y0
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|x1
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|y1
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|arc
argument_list|(
name|xi
argument_list|,
name|yi
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|xi
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|yi
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|r
operator|=
name|getsi
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|circle
argument_list|(
name|xi
argument_list|,
name|yi
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|getstr
argument_list|(
name|s
argument_list|,
name|fin
argument_list|)
expr_stmt|;
name|linemod
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown command %c (%o)\n"
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|closepl
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|getsi
argument_list|(
argument|fin
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fin
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* get an integer stored in 2 ascii bytes. */
name|short
name|a
decl_stmt|,
name|b
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|getc
argument_list|(
name|fin
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
operator|(
name|a
operator|=
name|getc
argument_list|(
name|fin
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
name|a
operator|=
name|a
operator|<<
literal|8
expr_stmt|;
return|return
operator|(
name|a
operator||
name|b
operator|)
return|;
block|}
end_block

begin_macro
name|getstr
argument_list|(
argument|s
argument_list|,
argument|fin
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fin
decl_stmt|;
end_decl_stmt

begin_block
block|{
for|for
control|(
init|;
operator|*
name|s
operator|=
name|getc
argument_list|(
name|fin
argument_list|)
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
break|break;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

end_unit

