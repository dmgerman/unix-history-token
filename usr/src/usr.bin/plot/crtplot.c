begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * %sccs.include.proprietary.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)crtplot.c	4.7 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* This plotting routine interprets plot commands and outputs them onto intelligent terminals (ie, terminals with clear screen and cursor addressability.  It uses the curses library.  It should be compiled as follows: 	cc crtdriver.c crtplot.c -lcurses -ltermcap -lm Note:  This requires as slightly modified driver from the standard driver because some function names conflicted with the curses library. (That's what you get when you have a flat name space!) */
end_comment

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/*  These map from plot routine coordinates to screen coordinates.  */
end_comment

begin_define
define|#
directive|define
name|scaleX
parameter_list|(
name|x
parameter_list|)
value|(int) ((x-lowX)*rangeX + 0.5)
end_define

begin_define
define|#
directive|define
name|scaleY
parameter_list|(
name|y
parameter_list|)
value|(int) (LINES-0.5 - ((y-lowY)*rangeY))
end_define

begin_define
define|#
directive|define
name|plot_movech
parameter_list|(
name|y
parameter_list|,
name|x
parameter_list|,
name|ch
parameter_list|)
value|{ plot_move(x, y); plot_addch(ch); }
end_define

begin_decl_stmt
specifier|static
name|double
name|lowX
decl_stmt|,
name|rangeX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* min and range of x */
end_comment

begin_decl_stmt
specifier|static
name|double
name|lowY
decl_stmt|,
name|rangeY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* min and range of y */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lastX
decl_stmt|,
name|lastY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last point plotted */
end_comment

begin_comment
comment|/* This routine just moves the cursor. */
end_comment

begin_macro
name|screen_move
argument_list|(
argument|y
argument_list|,
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* must check for automatic wrap at last col */
if|if
condition|(
operator|!
name|AM
operator|||
operator|(
name|y
operator|<
name|LINES
operator|-
literal|1
operator|)
operator|||
operator|(
name|x
operator|<
name|COLS
operator|-
literal|1
operator|)
condition|)
block|{
name|mvcur
argument_list|(
name|lastY
argument_list|,
name|lastX
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|lastY
operator|=
name|y
expr_stmt|;
name|lastX
operator|=
name|x
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* This routine assumes the cursor is positioned correctly. */
end_comment

begin_macro
name|plot_addch
argument_list|(
argument|ch
argument_list|)
end_macro

begin_decl_stmt
name|char
name|ch
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|_putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|lastX
operator|>=
name|COLS
condition|)
block|{
if|if
condition|(
name|AM
condition|)
block|{
name|lastX
operator|=
literal|0
expr_stmt|;
name|lastY
operator|++
expr_stmt|;
block|}
else|else
block|{
name|lastX
operator|=
name|COLS
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* See the curses manual for what is been done and why. */
end_comment

begin_macro
name|openpl
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|sp
decl_stmt|;
name|void
name|closepl
parameter_list|()
function_decl|;
name|gettmode
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
condition|)
name|setterm
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|closepl
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|closepl
parameter_list|()
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* Leave cursor at top of screen. */
name|mvcur
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|plot_move
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|screen_move
argument_list|(
name|scaleY
argument_list|(
name|y
argument_list|)
argument_list|,
name|scaleX
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|line
argument_list|(
argument|x0
argument_list|,
argument|y0
argument_list|,
argument|x1
argument_list|,
argument|y1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|plot_movech
argument_list|(
name|y0
argument_list|,
name|x0
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
name|dda_line
argument_list|(
literal|'*'
argument_list|,
name|scaleX
argument_list|(
name|x0
argument_list|)
argument_list|,
name|scaleY
argument_list|(
name|y0
argument_list|)
argument_list|,
name|scaleX
argument_list|(
name|x1
argument_list|)
argument_list|,
name|scaleY
argument_list|(
name|y1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|label
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|reg
name|i
decl_stmt|,
name|length
decl_stmt|;
if|if
condition|(
operator|(
name|length
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|)
operator|>
operator|(
name|COLS
operator|-
name|lastX
operator|)
condition|)
name|length
operator|=
name|COLS
operator|-
name|lastX
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
name|plot_addch
argument_list|(
name|str
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|cputchar
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|plot_erase
argument_list|()
end_macro

begin_block
block|{
comment|/* Some of these functions probably belong in openpl().  However, if the input is being typed in, putting them in openpl would not work since "noecho", etc would prevent (sort of) input.  Notice that the driver calls openpl before doing anything.  This is actually wrong, but it is what whoever originally wrote the driver decided to do.  (openpl() in libplot does nothing -- that is the main problem!) */
name|tputs
argument_list|(
name|TI
argument_list|,
literal|0
argument_list|,
name|cputchar
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|VS
argument_list|,
literal|0
argument_list|,
name|cputchar
argument_list|)
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|nonl
argument_list|()
expr_stmt|;
name|tputs
argument_list|(
name|CL
argument_list|,
name|LINES
argument_list|,
name|cputchar
argument_list|)
expr_stmt|;
name|mvcur
argument_list|(
literal|0
argument_list|,
name|COLS
operator|-
literal|1
argument_list|,
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lastX
operator|=
literal|0
expr_stmt|;
name|lastY
operator|=
name|LINES
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|point
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|plot_movech
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cont
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|dda_line
argument_list|(
literal|'*'
argument_list|,
name|lastX
operator|-
literal|1
argument_list|,
name|lastY
argument_list|,
name|scaleX
argument_list|(
name|x
argument_list|)
argument_list|,
name|scaleY
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|space
argument_list|(
argument|x0
argument_list|,
argument|y0
argument_list|,
argument|x1
argument_list|,
argument|y1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lowX
operator|=
operator|(
name|double
operator|)
name|x0
expr_stmt|;
name|lowY
operator|=
operator|(
name|double
operator|)
name|y0
expr_stmt|;
name|rangeX
operator|=
name|COLS
operator|/
call|(
name|double
call|)
argument_list|(
name|x1
operator|-
name|x0
argument_list|)
expr_stmt|;
name|rangeY
operator|=
name|LINES
operator|/
call|(
name|double
call|)
argument_list|(
name|y1
operator|-
name|y0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|linemod
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_comment
comment|/* See Neuman& Sproul for explanation and rationale. */
end_comment

begin_comment
comment|/* Does not plot first point -- assumed that it is already plotted */
end_comment

begin_macro
name|dda_line
argument_list|(
argument|ch
argument_list|,
argument|x0
argument_list|,
argument|y0
argument_list|,
argument|x1
argument_list|,
argument|y1
argument_list|)
end_macro

begin_decl_stmt
name|char
name|ch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* already transformed to screen coords */
end_comment

begin_block
block|{
name|int
name|length
decl_stmt|,
name|i
decl_stmt|;
name|double
name|deltaX
decl_stmt|,
name|deltaY
decl_stmt|;
name|double
name|x
decl_stmt|,
name|y
decl_stmt|;
name|length
operator|=
name|abs
argument_list|(
name|x1
operator|-
name|x0
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|y1
operator|-
name|y0
argument_list|)
operator|>
name|length
condition|)
name|length
operator|=
name|abs
argument_list|(
name|y1
operator|-
name|y0
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return;
name|deltaX
operator|=
call|(
name|double
call|)
argument_list|(
name|x1
operator|-
name|x0
argument_list|)
operator|/
operator|(
name|double
operator|)
name|length
expr_stmt|;
name|deltaY
operator|=
call|(
name|double
call|)
argument_list|(
name|y1
operator|-
name|y0
argument_list|)
operator|/
operator|(
name|double
operator|)
name|length
expr_stmt|;
name|x
operator|=
operator|(
name|double
operator|)
name|x0
operator|+
literal|0.5
expr_stmt|;
name|y
operator|=
operator|(
name|double
operator|)
name|y0
operator|+
literal|0.5
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
name|x
operator|+=
name|deltaX
expr_stmt|;
name|y
operator|+=
name|deltaY
expr_stmt|;
name|screen_move
argument_list|(
operator|(
name|int
operator|)
name|floor
argument_list|(
name|y
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|floor
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|plot_addch
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|circle
argument_list|(
argument|xc
argument_list|,
argument|yc
argument_list|,
argument|r
argument_list|)
end_macro

begin_decl_stmt
name|int
name|xc
decl_stmt|,
name|yc
decl_stmt|,
name|r
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|arc
argument_list|(
name|xc
argument_list|,
name|yc
argument_list|,
name|xc
operator|+
name|r
argument_list|,
name|yc
argument_list|,
name|xc
operator|-
name|r
argument_list|,
name|yc
argument_list|)
expr_stmt|;
name|arc
argument_list|(
name|xc
argument_list|,
name|yc
argument_list|,
name|xc
operator|-
name|r
argument_list|,
name|yc
argument_list|,
name|xc
operator|+
name|r
argument_list|,
name|yc
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* should include test for equality? */
end_comment

begin_define
define|#
directive|define
name|side
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(a*(x)+b*(y)+c> 0.0 ? 1 : -1)
end_define

begin_macro
name|arc
argument_list|(
argument|xc
argument_list|,
argument|yc
argument_list|,
argument|xbeg
argument_list|,
argument|ybeg
argument_list|,
argument|xend
argument_list|,
argument|yend
argument_list|)
end_macro

begin_decl_stmt
name|int
name|xc
decl_stmt|,
name|yc
decl_stmt|,
name|xbeg
decl_stmt|,
name|ybeg
decl_stmt|,
name|xend
decl_stmt|,
name|yend
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|r
decl_stmt|,
name|radius
decl_stmt|,
name|costheta
decl_stmt|,
name|sintheta
decl_stmt|;
name|double
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|tempX
decl_stmt|;
name|int
name|right_side
decl_stmt|;
name|xbeg
operator|-=
name|xc
expr_stmt|;
name|ybeg
operator|-=
name|yc
expr_stmt|;
name|xend
operator|-=
name|xc
expr_stmt|;
name|yend
operator|-=
name|yc
expr_stmt|;
comment|/* probably should check that arc is truely circular */
comment|/* Note: r is in screen coordinates. */
name|r
operator|=
name|sqrt
argument_list|(
name|rangeX
operator|*
name|rangeX
operator|*
name|xbeg
operator|*
name|xbeg
operator|+
name|rangeY
operator|*
name|rangeY
operator|*
name|ybeg
operator|*
name|ybeg
argument_list|)
expr_stmt|;
comment|/* 	This method is reasonably efficient, clean, and clever. 	The easy part is generating the next point on the arc.  This is 	done by rotating the points by the angle theta.  Theta is chosen 	so that no rotation will cause more than one pixel of a move. 	This corresponds to a triangle having 'x side' of r and 'y side' of 1. 	The rotation is done (way) below inside the loop. 	*/
if|if
condition|(
name|r
operator|<=
literal|1.0
condition|)
block|{
comment|/* radius is mapped to length< 1*/
name|point
argument_list|(
name|xc
argument_list|,
name|yc
argument_list|)
expr_stmt|;
return|return;
block|}
name|radius
operator|=
name|sqrt
argument_list|(
name|r
operator|*
name|r
operator|+
literal|1.0
argument_list|)
expr_stmt|;
name|sintheta
operator|=
literal|1.0
operator|/
name|radius
expr_stmt|;
name|costheta
operator|=
name|r
operator|/
name|radius
expr_stmt|;
comment|/* 	The hard part of drawing an arc is figuring out when to stop. 	This method works by drawing the line from the beginning point 	to the ending point.  This splits the plane in half, with the 	arc that we wish to draw on one side of the line.  If we evaluate 	side(x,y) = a*x + b*y + c, then all of the points on one side of the 	line will result in side being positive, and all the points on the 	other side of the line will result in side being negative.  	We want to draw the arc in a counter-clockwise direction, so we 	must find out what the sign of "side" is for a point which is to the  	"right" of a line drawn from "beg" to "end".  A point which must lie  	on the right is [xbeg + (yend-ybeg), ybeg - (xend-xbeg)].  (This 	point is perpendicular to the line at "beg").  	Thus, we compute "side" of the above point, and then compare the 	sign of side for each new point with the sign of the above point. 	When they are different, we terminate the loop. 	*/
name|a
operator|=
call|(
name|double
call|)
argument_list|(
name|yend
operator|-
name|ybeg
argument_list|)
expr_stmt|;
name|b
operator|=
call|(
name|double
call|)
argument_list|(
name|xend
operator|-
name|xbeg
argument_list|)
expr_stmt|;
name|c
operator|=
call|(
name|double
call|)
argument_list|(
name|yend
operator|*
name|xbeg
operator|-
name|xend
operator|*
name|ybeg
argument_list|)
expr_stmt|;
name|right_side
operator|=
name|side
argument_list|(
name|xbeg
operator|+
operator|(
name|yend
operator|-
name|ybeg
operator|)
argument_list|,
name|ybeg
operator|-
operator|(
name|xend
operator|-
name|xbeg
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|xbeg
expr_stmt|;
name|y
operator|=
name|ybeg
expr_stmt|;
name|plot_move
argument_list|(
name|xbeg
operator|+
name|xc
argument_list|,
name|ybeg
operator|+
name|yc
argument_list|)
expr_stmt|;
do|do
block|{
name|dda_line
argument_list|(
literal|'*'
argument_list|,
name|lastX
operator|-
literal|1
argument_list|,
name|lastY
argument_list|,
name|scaleX
argument_list|(
name|xc
operator|+
name|x
argument_list|)
argument_list|,
name|scaleY
argument_list|(
name|yc
operator|+
name|y
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		screen_move( scaleY(yc + y), scaleX(xc + x) ); 		plot_addch('*'); 		*/
name|tempX
operator|=
name|x
expr_stmt|;
name|x
operator|=
name|x
operator|*
name|costheta
operator|-
name|y
operator|*
name|sintheta
expr_stmt|;
name|y
operator|=
name|tempX
operator|*
name|sintheta
operator|+
name|y
operator|*
name|costheta
expr_stmt|;
block|}
do|while
condition|(
name|side
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|==
name|right_side
condition|)
do|;
block|}
end_block

end_unit

