begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************** rexp2.c copyright 1991, Michael D. Brennan  This is a source file for mawk, an implementation of the AWK programming language.  Mawk is distributed without warranty under the terms of the GNU General Public License, version 2, 1991. ********************************************/
end_comment

begin_comment
comment|/*$Log:	rexp2.c,v $  * Revision 3.7  92/01/21  17:33:15  brennan  * added some casts so that character classes work with signed chars  *   * Revision 3.6  91/10/29  10:54:03  brennan  * SIZE_T  *   * Revision 3.5  91/08/13  09:10:15  brennan  * VERSION .9994  *   * Revision 3.4  91/08/08  07:53:34  brennan  * work around for turboC realloc() bug  *   * Revision 3.4  91/08/07  07:10:47  brennan  * work around for TurboC realloc() bug  *   * Revision 3.3  91/08/04  15:45:57  brennan  * minor change for large model dos  *   * Revision 3.2  91/06/10  16:18:14  brennan  * changes for V7  *   * Revision 3.1  91/06/07  10:33:25  brennan  * VERSION 0.995  *   * Revision 1.8  91/06/05  09:01:33  brennan  * changes to RE_new_run_stack  *   * Revision 1.7  91/05/31  10:56:02  brennan  * stack_empty hack for DOS large model  *  */
end_comment

begin_comment
comment|/*  test a string against a machine   */
end_comment

begin_include
include|#
directive|include
file|"rexp.h"
end_include

begin_define
define|#
directive|define
name|STACKGROWTH
value|16
end_define

begin_comment
comment|/* statics */
end_comment

begin_decl_stmt
specifier|static
name|RT_STATE
modifier|*
name|PROTO
argument_list|(
name|slow_push
argument_list|,
operator|(
name|RT_STATE
operator|*
operator|,
name|STATE
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RT_STATE
modifier|*
name|RE_run_stack_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|RT_STATE
modifier|*
name|RE_run_stack_limit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Large model DOS segment arithemetic breaks the current stack.    This hack fixes it without rewriting the whole thing, 5/31/91 */
end_comment

begin_decl_stmt
name|RT_STATE
modifier|*
name|RE_run_stack_empty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for statistics and debug */
end_comment

begin_decl_stmt
specifier|static
name|RT_STATE
modifier|*
name|stack_max
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|RE_run_stack_init
parameter_list|()
block|{
if|if
condition|(
operator|!
name|RE_run_stack_base
condition|)
block|{
name|RE_run_stack_base
operator|=
operator|(
name|RT_STATE
operator|*
operator|)
name|RE_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RT_STATE
argument_list|)
operator|*
name|STACKGROWTH
argument_list|)
expr_stmt|;
name|RE_run_stack_limit
operator|=
name|RE_run_stack_base
operator|+
name|STACKGROWTH
expr_stmt|;
name|RE_run_stack_empty
operator|=
name|stack_max
operator|=
name|RE_run_stack_base
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* sometimes during REmatch(), this stack can grow pretty large.    In real life cases, the back tracking usually fails. Some    work is needed here to improve the algorithm.    I.e., figure out how not to stack useless paths. */
end_comment

begin_function
name|RT_STATE
modifier|*
name|RE_new_run_stack
parameter_list|()
block|{
name|int
name|newsize
init|=
operator|(
name|RE_run_stack_limit
operator|-
name|RE_run_stack_base
operator|)
operator|+
name|STACKGROWTH
decl_stmt|;
ifdef|#
directive|ifdef
name|LMDOS
comment|/* large model DOS */
comment|/* have to worry about overflow on multiplication (ugh) */
if|if
condition|(
name|newsize
operator|>=
literal|4096
condition|)
name|RE_run_stack_base
operator|=
operator|(
name|RT_STATE
operator|*
operator|)
literal|0
expr_stmt|;
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__TURBOC__
comment|/* turbo C's realloc() screws up when running out of mem  */
block|{
name|RT_STATE
modifier|*
name|temp
init|=
operator|(
name|RT_STATE
operator|*
operator|)
name|malloc
argument_list|(
name|SIZE_T
argument_list|(
name|newsize
operator|*
sizeof|sizeof
argument_list|(
name|RT_STATE
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
condition|)
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|temp
argument_list|,
name|RE_run_stack_base
argument_list|,
name|SIZE_T
argument_list|(
operator|(
name|newsize
operator|-
name|STACKGROWTH
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|RT_STATE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|RE_run_stack_base
argument_list|)
expr_stmt|;
name|RE_run_stack_base
operator|=
name|temp
expr_stmt|;
block|}
else|#
directive|else
comment|/* normal case */
name|RE_run_stack_base
operator|=
operator|(
name|RT_STATE
operator|*
operator|)
name|realloc
argument_list|(
name|RE_run_stack_base
argument_list|,
name|SIZE_T
argument_list|(
name|newsize
operator|*
sizeof|sizeof
argument_list|(
name|RT_STATE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|RE_run_stack_base
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"out of memory for RE run time stack\n"
argument_list|)
expr_stmt|;
comment|/* this is pretty unusual, I've only seen it happen on        weird input to REmatch() under 16bit DOS , the same        situation worked easily on 32bit machine.  */
name|exit
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|RE_run_stack_limit
operator|=
name|RE_run_stack_base
operator|+
name|newsize
expr_stmt|;
name|RE_run_stack_empty
operator|=
name|RE_run_stack_base
operator|-
literal|1
expr_stmt|;
return|return
name|stack_max
operator|=
name|RE_run_stack_base
operator|+
name|newsize
operator|-
name|STACKGROWTH
return|;
block|}
end_function

begin_function
specifier|static
name|RT_STATE
modifier|*
name|slow_push
parameter_list|(
name|sp
parameter_list|,
name|m
parameter_list|,
name|s
parameter_list|,
name|u
parameter_list|)
name|RT_STATE
modifier|*
name|sp
decl_stmt|;
name|STATE
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|u
decl_stmt|;
block|{
if|if
condition|(
name|sp
operator|>
name|stack_max
condition|)
if|if
condition|(
operator|(
name|stack_max
operator|=
name|sp
operator|)
operator|==
name|RE_run_stack_limit
condition|)
name|sp
operator|=
name|RE_new_run_stack
argument_list|()
expr_stmt|;
name|sp
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|sp
operator|->
name|s
operator|=
name|s
expr_stmt|;
name|sp
operator|->
name|u
operator|=
name|u
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|void
name|print_max_stack
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"stack_max = %d\n"
argument_list|,
name|stack_max
operator|-
name|RE_run_stack_base
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|push
parameter_list|(
name|mx
parameter_list|,
name|sx
parameter_list|,
name|ux
parameter_list|)
value|stackp = slow_push(++stackp, mx, sx, ux)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|push
parameter_list|(
name|mx
parameter_list|,
name|sx
parameter_list|,
name|ux
parameter_list|)
value|if (++stackp == RE_run_stack_limit)\                                 stackp = slow_push(stackp,mx,sx,ux) ;\                           else\                           { stackp->m=mx;stackp->s=sx;stackp->u=ux;}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CASE_UANY
parameter_list|(
name|x
parameter_list|)
value|case  x + U_OFF :  case  x + U_ON
end_define

begin_comment
comment|/* test if str ~ /machine/ */
end_comment

begin_function
name|int
name|REtest
parameter_list|(
name|str
parameter_list|,
name|machine
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|VOID
modifier|*
name|machine
decl_stmt|;
block|{
specifier|register
name|STATE
modifier|*
name|m
init|=
operator|(
name|STATE
operator|*
operator|)
name|machine
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|str
decl_stmt|;
specifier|register
name|RT_STATE
modifier|*
name|stackp
decl_stmt|;
name|int
name|u_flag
decl_stmt|;
name|char
modifier|*
name|str_end
decl_stmt|;
name|char
modifier|*
name|ts
decl_stmt|;
comment|/*convenient temps */
name|STATE
modifier|*
name|tm
decl_stmt|;
comment|/* handle the easy case quickly */
if|if
condition|(
operator|(
name|m
operator|+
literal|1
operator|)
operator|->
name|type
operator|==
name|M_ACCEPT
operator|&&
name|m
operator|->
name|type
operator|==
name|M_STR
condition|)
return|return
operator|(
name|int
operator|)
name|str_str
argument_list|(
name|s
argument_list|,
name|m
operator|->
name|data
operator|.
name|str
argument_list|,
name|m
operator|->
name|len
argument_list|)
return|;
else|else
block|{
name|u_flag
operator|=
name|U_ON
expr_stmt|;
name|str_end
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|stackp
operator|=
name|RE_run_stack_empty
expr_stmt|;
goto|goto
name|reswitch
goto|;
block|}
name|refill
label|:
if|if
condition|(
name|stackp
operator|==
name|RE_run_stack_empty
condition|)
return|return
literal|0
return|;
name|m
operator|=
name|stackp
operator|->
name|m
expr_stmt|;
name|s
operator|=
name|stackp
operator|->
name|s
expr_stmt|;
name|u_flag
operator|=
name|stackp
operator|--
operator|->
name|u
expr_stmt|;
name|reswitch
label|:
switch|switch
condition|(
name|m
operator|->
name|type
operator|+
name|u_flag
condition|)
block|{
case|case
name|M_STR
operator|+
name|U_OFF
operator|+
name|END_OFF
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
name|m
operator|->
name|data
operator|.
name|str
argument_list|,
name|SIZE_T
argument_list|(
name|m
operator|->
name|len
argument_list|)
argument_list|)
condition|)
goto|goto
name|refill
goto|;
name|s
operator|+=
name|m
operator|->
name|len
expr_stmt|;
name|m
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_STR
operator|+
name|U_OFF
operator|+
name|END_ON
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|m
operator|->
name|data
operator|.
name|str
argument_list|)
condition|)
goto|goto
name|refill
goto|;
name|s
operator|+=
name|m
operator|->
name|len
expr_stmt|;
name|m
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_STR
operator|+
name|U_ON
operator|+
name|END_OFF
case|:
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|str_str
argument_list|(
name|s
argument_list|,
name|m
operator|->
name|data
operator|.
name|str
argument_list|,
name|m
operator|->
name|len
argument_list|)
operator|)
condition|)
goto|goto
name|refill
goto|;
name|push
argument_list|(
name|m
argument_list|,
name|s
operator|+
literal|1
argument_list|,
name|U_ON
argument_list|)
expr_stmt|;
name|s
operator|+=
name|m
operator|->
name|len
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|u_flag
operator|=
name|U_OFF
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_STR
operator|+
name|U_ON
operator|+
name|END_ON
case|:
if|if
condition|(
operator|!
name|str_end
condition|)
name|str_end
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ts
operator|=
name|str_end
operator|-
name|m
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|ts
operator|<
name|s
operator|||
name|memcmp
argument_list|(
name|ts
argument_list|,
name|m
operator|->
name|data
operator|.
name|str
argument_list|,
name|SIZE_T
argument_list|(
name|m
operator|->
name|len
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
goto|goto
name|refill
goto|;
name|s
operator|=
name|str_end
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|u_flag
operator|=
name|U_OFF
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_CLASS
operator|+
name|U_OFF
operator|+
name|END_OFF
case|:
if|if
condition|(
operator|!
name|ison
argument_list|(
operator|*
name|m
operator|->
name|data
operator|.
name|bvp
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|)
condition|)
goto|goto
name|refill
goto|;
name|s
operator|++
expr_stmt|;
name|m
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_CLASS
operator|+
name|U_OFF
operator|+
name|END_ON
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|||
operator|!
name|ison
argument_list|(
operator|*
name|m
operator|->
name|data
operator|.
name|bvp
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|)
condition|)
goto|goto
name|refill
goto|;
name|s
operator|++
expr_stmt|;
name|m
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_CLASS
operator|+
name|U_ON
operator|+
name|END_OFF
case|:
while|while
condition|(
operator|!
name|ison
argument_list|(
operator|*
name|m
operator|->
name|data
operator|.
name|bvp
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|)
condition|)
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|0
condition|)
goto|goto
name|refill
goto|;
else|else
name|s
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|push
argument_list|(
name|m
argument_list|,
name|s
argument_list|,
name|U_ON
argument_list|)
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|u_flag
operator|=
name|U_OFF
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_CLASS
operator|+
name|U_ON
operator|+
name|END_ON
case|:
if|if
condition|(
operator|!
name|str_end
condition|)
name|str_end
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ison
argument_list|(
operator|*
name|m
operator|->
name|data
operator|.
name|bvp
argument_list|,
name|str_end
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
goto|goto
name|refill
goto|;
name|s
operator|=
name|str_end
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|u_flag
operator|=
name|U_OFF
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_ANY
operator|+
name|U_OFF
operator|+
name|END_OFF
case|:
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|0
condition|)
goto|goto
name|refill
goto|;
name|s
operator|++
expr_stmt|;
name|m
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_ANY
operator|+
name|U_OFF
operator|+
name|END_ON
case|:
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|s
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
goto|goto
name|refill
goto|;
name|s
operator|++
expr_stmt|;
name|m
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_ANY
operator|+
name|U_ON
operator|+
name|END_OFF
case|:
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|0
condition|)
goto|goto
name|refill
goto|;
name|s
operator|++
expr_stmt|;
name|push
argument_list|(
name|m
argument_list|,
name|s
argument_list|,
name|U_ON
argument_list|)
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|u_flag
operator|=
name|U_OFF
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_ANY
operator|+
name|U_ON
operator|+
name|END_ON
case|:
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|0
condition|)
goto|goto
name|refill
goto|;
if|if
condition|(
operator|!
name|str_end
condition|)
name|str_end
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|str_end
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|u_flag
operator|=
name|U_OFF
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_START
operator|+
name|U_OFF
operator|+
name|END_OFF
case|:
case|case
name|M_START
operator|+
name|U_ON
operator|+
name|END_OFF
case|:
if|if
condition|(
name|s
operator|!=
name|str
condition|)
goto|goto
name|refill
goto|;
name|m
operator|++
expr_stmt|;
name|u_flag
operator|=
name|U_OFF
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_START
operator|+
name|U_OFF
operator|+
name|END_ON
case|:
case|case
name|M_START
operator|+
name|U_ON
operator|+
name|END_ON
case|:
if|if
condition|(
name|s
operator|!=
name|str
operator|||
name|s
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
goto|goto
name|refill
goto|;
name|m
operator|++
expr_stmt|;
name|u_flag
operator|=
name|U_OFF
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_END
operator|+
name|U_OFF
case|:
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
goto|goto
name|refill
goto|;
name|m
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_END
operator|+
name|U_ON
case|:
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|u_flag
operator|=
name|U_OFF
expr_stmt|;
goto|goto
name|reswitch
goto|;
name|CASE_UANY
argument_list|(
name|M_U
argument_list|)
operator|:
name|u_flag
operator|=
name|U_ON
expr_stmt|;
name|m
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
name|CASE_UANY
argument_list|(
name|M_1J
argument_list|)
operator|:
name|m
operator|+=
name|m
operator|->
name|data
operator|.
name|jump
expr_stmt|;
goto|goto
name|reswitch
goto|;
name|CASE_UANY
argument_list|(
name|M_2JA
argument_list|)
operator|:
comment|/* take the non jump branch */
comment|/* don't stack an ACCEPT */
if|if
condition|(
operator|(
name|tm
operator|=
name|m
operator|+
name|m
operator|->
name|data
operator|.
name|jump
operator|)
operator|->
name|type
operator|==
name|M_ACCEPT
condition|)
return|return
literal|1
return|;
name|push
argument_list|(
name|tm
argument_list|,
name|s
argument_list|,
name|u_flag
argument_list|)
expr_stmt|;
name|m
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
name|CASE_UANY
argument_list|(
name|M_2JB
argument_list|)
operator|:
comment|/* take the jump branch */
comment|/* don't stack an ACCEPT */
if|if
condition|(
operator|(
name|tm
operator|=
name|m
operator|+
literal|1
operator|)
operator|->
name|type
operator|==
name|M_ACCEPT
condition|)
return|return
literal|1
return|;
name|push
argument_list|(
name|tm
argument_list|,
name|s
argument_list|,
name|u_flag
argument_list|)
expr_stmt|;
name|m
operator|+=
name|m
operator|->
name|data
operator|.
name|jump
expr_stmt|;
goto|goto
name|reswitch
goto|;
name|CASE_UANY
argument_list|(
name|M_ACCEPT
argument_list|)
operator|:
return|return
literal|1
return|;
default|default :
name|RE_panic
argument_list|(
literal|"unexpected case in REtest"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAWK
end_ifdef

begin_function
name|char
modifier|*
name|is_string_split
parameter_list|(
name|p
parameter_list|,
name|lenp
parameter_list|)
specifier|register
name|STATE
modifier|*
name|p
decl_stmt|;
name|unsigned
modifier|*
name|lenp
decl_stmt|;
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|.
name|type
operator|==
name|M_STR
operator|&&
name|p
index|[
literal|1
index|]
operator|.
name|type
operator|==
name|M_ACCEPT
condition|)
block|{
operator|*
name|lenp
operator|=
name|p
operator|->
name|len
expr_stmt|;
return|return
name|p
operator|->
name|data
operator|.
name|str
return|;
block|}
else|else
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* mawk provides its own str_str */
end_comment

begin_function
name|char
modifier|*
name|str_str
parameter_list|(
name|target
parameter_list|,
name|key
parameter_list|,
name|klen
parameter_list|)
specifier|register
name|char
modifier|*
name|target
decl_stmt|;
specifier|register
name|char
modifier|*
name|key
decl_stmt|;
name|unsigned
name|klen
decl_stmt|;
block|{
name|int
name|c
init|=
name|key
index|[
literal|0
index|]
decl_stmt|;
switch|switch
condition|(
name|klen
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
case|case
literal|1
case|:
return|return
name|strchr
argument_list|(
name|target
argument_list|,
name|c
argument_list|)
return|;
case|case
literal|2
case|:
while|while
condition|(
name|target
operator|=
name|strchr
argument_list|(
name|target
argument_list|,
name|c
argument_list|)
condition|)
if|if
condition|(
name|target
index|[
literal|1
index|]
operator|==
name|key
index|[
literal|1
index|]
condition|)
return|return
name|target
return|;
else|else
name|target
operator|++
expr_stmt|;
break|break ;
default|default :
name|klen
operator|--
expr_stmt|;
name|key
operator|++
expr_stmt|;
while|while
condition|(
name|target
operator|=
name|strchr
argument_list|(
name|target
argument_list|,
name|c
argument_list|)
condition|)
if|if
condition|(
name|memcmp
argument_list|(
name|target
operator|+
literal|1
argument_list|,
name|key
argument_list|,
name|SIZE_T
argument_list|(
name|klen
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|target
return|;
else|else
name|target
operator|++
expr_stmt|;
break|break ;
block|}
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAWK */
end_comment

end_unit

