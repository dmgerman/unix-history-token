begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************** rexp0.c copyright 1991, Michael D. Brennan  This is a source file for mawk, an implementation of the AWK programming language.  Mawk is distributed without warranty under the terms of the GNU General Public License, version 2, 1991. ********************************************/
end_comment

begin_comment
comment|/*$Log:	rexp0.c,v $  * Revision 3.6  92/01/21  17:32:51  brennan  * added some casts so that character classes work with signed chars  *   * Revision 3.5  91/10/29  10:53:57  brennan  * SIZE_T  *   * Revision 3.4  91/08/13  09:10:05  brennan  * VERSION .9994  *   * Revision 3.3  91/07/19  07:29:24  brennan  * backslash at end of regular expression now stands for backslash  *   * Revision 3.2  91/07/19  06:58:23  brennan  * removed small bozo in processing of escape characters  *   * Revision 3.1  91/06/07  10:33:20  brennan  * VERSION 0.995  *   * Revision 1.2  91/06/05  08:59:36  brennan  * changed RE_free to free  *   * Revision 1.1  91/06/03  07:10:15  brennan  * Initial revision  *  */
end_comment

begin_comment
comment|/*  lexical scanner  */
end_comment

begin_include
include|#
directive|include
file|"rexp.h"
end_include

begin_comment
comment|/* static functions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|PROTO
argument_list|(
name|do_str
argument_list|,
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|,
name|MACHINE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PROTO
argument_list|(
name|do_class
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|,
name|MACHINE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PROTO
argument_list|(
name|escape
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BV
modifier|*
name|PROTO
argument_list|(
name|store_bvp
argument_list|,
operator|(
name|BV
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PROTO
argument_list|(
name|ctohex
argument_list|,
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|EG
end_ifndef

begin_comment
comment|/* if EG make next array visible */
end_comment

begin_decl_stmt
specifier|static
endif|#
directive|endif
name|char
name|RE_char2token
index|[
literal|'|'
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|9
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|6
block|,
literal|7
block|,
literal|3
block|,
literal|4
block|,
literal|13
block|,
literal|13
block|,
literal|10
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|5
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|8
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|char2token
parameter_list|(
name|x
parameter_list|)
value|( (unsigned char)(x)> '|' ? T_CHAR : RE_char2token[x] )
end_define

begin_define
define|#
directive|define
name|NOT_STARTED
value|(-1)
end_define

begin_decl_stmt
specifier|static
name|int
name|prev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  ptr to reg exp string  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|re_len
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|RE_lex_init
parameter_list|(
name|re
parameter_list|)
name|char
modifier|*
name|re
decl_stmt|;
block|{
name|lp
operator|=
name|re
expr_stmt|;
name|re_len
operator|=
name|strlen
argument_list|(
name|re
argument_list|)
operator|+
literal|1
expr_stmt|;
name|prev
operator|=
name|NOT_STARTED
expr_stmt|;
name|RE_run_stack_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|RE_lex
parameter_list|(
name|mp
parameter_list|)
name|MACHINE
modifier|*
name|mp
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
switch|switch
condition|(
name|c
operator|=
name|char2token
argument_list|(
operator|*
name|lp
argument_list|)
condition|)
block|{
case|case
name|T_OR
case|:
case|case
name|T_PLUS
case|:
case|case
name|T_STAR
case|:
case|case
name|T_Q
case|:
case|case
name|T_RP
case|:
name|lp
operator|++
expr_stmt|;
return|return
name|prev
operator|=
name|c
return|;
case|case
name|T_SLASH
case|:
break|break ;
case|case
literal|0
case|:
return|return
literal|0
return|;
case|case
name|T_LP
case|:
switch|switch
condition|(
name|prev
condition|)
block|{
case|case
name|T_CHAR
case|:
case|case
name|T_STR
case|:
case|case
name|T_ANY
case|:
case|case
name|T_CLASS
case|:
case|case
name|T_START
case|:
case|case
name|T_RP
case|:
case|case
name|T_PLUS
case|:
case|case
name|T_STAR
case|:
case|case
name|T_Q
case|:
case|case
name|T_U
case|:
return|return
name|prev
operator|=
name|T_CAT
return|;
default|default  :
name|lp
operator|++
expr_stmt|;
return|return
name|prev
operator|=
name|T_LP
return|;
block|}
block|}
comment|/*  *lp  is  an operand, but implicit cat op is possible   */
switch|switch
condition|(
name|prev
condition|)
block|{
case|case
name|NOT_STARTED
case|:
case|case
name|T_OR
case|:
case|case
name|T_LP
case|:
case|case
name|T_CAT
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|T_ANY
case|:
block|{
specifier|static
name|plus_is_star_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|lp
operator|==
literal|'*'
condition|)
block|{
name|lp
operator|++
expr_stmt|;
operator|*
name|mp
operator|=
name|RE_u
argument_list|()
expr_stmt|;
return|return
name|prev
operator|=
name|T_U
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|lp
operator|==
literal|'+'
condition|)
if|if
condition|(
name|plus_is_star_flag
condition|)
block|{
name|lp
operator|++
expr_stmt|;
operator|*
name|mp
operator|=
name|RE_u
argument_list|()
expr_stmt|;
name|plus_is_star_flag
operator|=
literal|0
expr_stmt|;
return|return
name|prev
operator|=
name|T_U
return|;
block|}
else|else
block|{
name|plus_is_star_flag
operator|=
literal|1
expr_stmt|;
name|lp
operator|--
expr_stmt|;
operator|*
name|mp
operator|=
name|RE_any
argument_list|()
expr_stmt|;
return|return
name|prev
operator|=
name|T_ANY
return|;
block|}
else|else
block|{
operator|*
name|mp
operator|=
name|RE_any
argument_list|()
expr_stmt|;
name|prev
operator|=
name|T_ANY
expr_stmt|;
block|}
block|}
break|break ;
case|case
name|T_SLASH
case|:
name|lp
operator|++
expr_stmt|;
name|c
operator|=
name|escape
argument_list|(
operator|&
name|lp
argument_list|)
expr_stmt|;
name|prev
operator|=
name|do_str
argument_list|(
name|c
argument_list|,
operator|&
name|lp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break ;
case|case
name|T_CHAR
case|:
name|c
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
name|prev
operator|=
name|do_str
argument_list|(
name|c
argument_list|,
operator|&
name|lp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break ;
case|case
name|T_CLASS
case|:
name|prev
operator|=
name|do_class
argument_list|(
operator|&
name|lp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break ;
case|case
name|T_START
case|:
operator|*
name|mp
operator|=
name|RE_start
argument_list|()
expr_stmt|;
name|lp
operator|++
expr_stmt|;
name|prev
operator|=
name|T_START
expr_stmt|;
break|break ;
case|case
name|T_END
case|:
name|lp
operator|++
expr_stmt|;
operator|*
name|mp
operator|=
name|RE_end
argument_list|()
expr_stmt|;
return|return
name|prev
operator|=
name|T_END
return|;
default|default :
name|RE_panic
argument_list|(
literal|"bad switch in RE_lex"
argument_list|)
expr_stmt|;
block|}
break|break ;
default|default :
comment|/* don't advance the pointer, return T_CAT */
return|return
name|prev
operator|=
name|T_CAT
return|;
block|}
comment|/* check for end character */
if|if
condition|(
operator|*
name|lp
operator|==
literal|'$'
condition|)
block|{
name|mp
operator|->
name|start
operator|->
name|type
operator|+=
name|END_ON
expr_stmt|;
name|lp
operator|++
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_str
parameter_list|(
name|c
parameter_list|,
name|pp
parameter_list|,
name|mp
parameter_list|)
name|int
name|c
decl_stmt|;
comment|/* the first character */
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
comment|/* where to put the re_char pointer on exit */
name|MACHINE
modifier|*
name|mp
decl_stmt|;
comment|/* where to put the string machine */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
name|s
operator|=
name|str
operator|=
name|RE_malloc
argument_list|(
name|re_len
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|c
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|save
decl_stmt|;
switch|switch
condition|(
name|char2token
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
case|case
name|T_CHAR
case|:
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
break|break ;
case|case
name|T_SLASH
case|:
name|save
operator|=
operator|++
name|p
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|escape
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
name|p
operator|=
name|save
expr_stmt|;
break|break ;
default|default  :
goto|goto
name|out
goto|;
block|}
name|len
operator|++
expr_stmt|;
block|}
name|out
label|:
comment|/* if len> 1 and we failed on a ? + or * , need to back up */
if|if
condition|(
name|len
operator|>
literal|1
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'*'
operator|||
operator|*
name|p
operator|==
literal|'+'
operator|||
operator|*
name|p
operator|==
literal|'?'
operator|)
condition|)
block|{
name|len
operator|--
expr_stmt|;
name|p
operator|--
expr_stmt|;
name|s
operator|--
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|0
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
operator|*
name|mp
operator|=
name|RE_str
argument_list|(
operator|(
name|char
operator|*
operator|)
name|RE_realloc
argument_list|(
name|str
argument_list|,
name|len
operator|+
literal|1
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|T_STR
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------   BUILD A CHARACTER CLASS  *---------------------------*/
end_comment

begin_define
define|#
directive|define
name|on
parameter_list|(
name|b
parameter_list|,
name|x
parameter_list|)
value|( (b)[((unsigned char)(x))>>3] |= ( 1<< ((x)&7) ))
end_define

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|block_on
argument_list|,
operator|(
name|BV
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|block_on
parameter_list|(
name|b
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|BV
name|b
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|int
name|lo
init|=
operator|(
name|x
operator|&
literal|0xff
operator|)
operator|>>
literal|3
decl_stmt|;
name|int
name|hi
init|=
operator|(
name|y
operator|&
literal|0xff
operator|)
operator|>>
literal|3
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|bit
decl_stmt|;
if|if
condition|(
name|lo
operator|==
name|hi
condition|)
block|{
name|j
operator|=
name|x
operator|&
literal|7
expr_stmt|;
name|bit
operator|=
literal|1
operator|<<
name|j
expr_stmt|;
name|i
operator|=
operator|(
name|y
operator|&
literal|7
operator|)
operator|-
name|j
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|bit
operator|<<=
literal|1
control|)
name|b
index|[
name|lo
index|]
operator||=
name|bit
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|lo
operator|+
literal|1
init|;
name|i
operator|<=
name|hi
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|b
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
name|b
index|[
name|lo
index|]
operator||=
operator|(
literal|0xff
operator|<<
operator|(
name|x
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
name|b
index|[
name|hi
index|]
operator||=
operator|~
operator|(
literal|0xff
operator|<<
operator|(
operator|(
name|y
operator|&
literal|7
operator|)
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* build a BV for a character class.    *start points at the '['    on exit:   *start points at the character after ']'               mp points at a machine that recognizes the class */
end_comment

begin_function
specifier|static
name|int
name|do_class
parameter_list|(
name|start
parameter_list|,
name|mp
parameter_list|)
name|char
modifier|*
modifier|*
name|start
decl_stmt|;
name|MACHINE
modifier|*
name|mp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|BV
modifier|*
name|bvp
decl_stmt|;
name|int
name|prev
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|int
name|comp_flag
decl_stmt|;
name|p
operator|=
operator|(
operator|*
name|start
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|']'
operator|||
operator|*
name|p
operator|==
literal|'^'
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|']'
condition|)
name|RE_error_trap
argument_list|(
operator|-
name|E3
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
comment|/* find the back of the class */
block|{
if|if
condition|(
operator|!
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|']'
argument_list|)
operator|)
condition|)
comment|/* no closing bracket */
name|RE_error_trap
argument_list|(
operator|-
name|E3
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|-
literal|1
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|p
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cnt
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
comment|/* even number of \ */
break|break ;
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
block|}
comment|/*  q  now  pts at the back of the class   */
name|p
operator|=
operator|(
operator|*
name|start
operator|)
operator|+
literal|1
expr_stmt|;
operator|*
name|start
operator|=
name|q
operator|+
literal|1
expr_stmt|;
name|bvp
operator|=
operator|(
name|BV
operator|*
operator|)
name|RE_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BV
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|bvp
argument_list|,
literal|0
argument_list|,
name|SIZE_T
argument_list|(
sizeof|sizeof
argument_list|(
name|BV
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|comp_flag
operator|=
operator|*
name|p
operator|==
literal|'^'
condition|?
operator|(
name|p
operator|++
operator|,
literal|1
operator|)
else|:
literal|0
expr_stmt|;
name|prev
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* indicates  -  cannot be part of a range  */
while|while
condition|(
name|p
operator|<
name|q
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\\'
case|:
name|t
operator|=
operator|++
name|p
expr_stmt|;
name|prev
operator|=
name|escape
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|on
argument_list|(
operator|*
name|bvp
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|p
operator|=
name|t
expr_stmt|;
continue|continue ;
case|case
literal|'-'
case|:
if|if
condition|(
name|prev
operator|==
operator|-
literal|1
operator|||
name|p
operator|+
literal|1
operator|==
name|q
operator|||
name|prev
operator|>
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|p
operator|+
literal|1
operator|)
condition|)
block|{
name|prev
operator|=
literal|'-'
expr_stmt|;
name|on
argument_list|(
operator|*
name|bvp
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|++
expr_stmt|;
name|block_on
argument_list|(
operator|*
name|bvp
argument_list|,
name|prev
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|prev
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break ;
default|default :
name|prev
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
expr_stmt|;
name|on
argument_list|(
operator|*
name|bvp
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
break|break ;
block|}
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|comp_flag
condition|)
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|bvp
init|;
name|p
operator|<
operator|(
name|char
operator|*
operator|)
name|bvp
operator|+
sizeof|sizeof
argument_list|(
name|BV
argument_list|)
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
operator|~
operator|*
name|p
expr_stmt|;
comment|/* make sure zero is off */
operator|(
operator|*
name|bvp
operator|)
index|[
literal|0
index|]
operator|&=
literal|0xfe
expr_stmt|;
operator|*
name|mp
operator|=
name|RE_class
argument_list|(
name|store_bvp
argument_list|(
name|bvp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|T_CLASS
return|;
block|}
end_function

begin_comment
comment|/* storage for bit vectors so they can be reused ,    stored in an unsorted linear array     the array grows as needed */
end_comment

begin_define
define|#
directive|define
name|BV_GROWTH
value|6
end_define

begin_function
specifier|static
name|BV
modifier|*
name|store_bvp
parameter_list|(
name|bvp
parameter_list|)
name|BV
modifier|*
name|bvp
decl_stmt|;
block|{
specifier|static
name|BV
modifier|*
modifier|*
name|bv_base
decl_stmt|,
modifier|*
modifier|*
name|bv_limit
decl_stmt|;
specifier|static
name|BV
modifier|*
modifier|*
name|bv_next
decl_stmt|;
comment|/* next empty slot in the array */
specifier|register
name|BV
modifier|*
modifier|*
name|p
decl_stmt|;
name|unsigned
name|t
decl_stmt|;
if|if
condition|(
name|bv_next
operator|==
name|bv_limit
condition|)
comment|/* need to grow */
block|{
if|if
condition|(
operator|!
name|bv_base
condition|)
comment|/* first growth */
block|{
name|t
operator|=
literal|0
expr_stmt|;
name|bv_base
operator|=
operator|(
name|BV
operator|*
operator|*
operator|)
name|RE_malloc
argument_list|(
name|BV_GROWTH
operator|*
sizeof|sizeof
argument_list|(
name|BV
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|bv_next
operator|-
name|bv_base
expr_stmt|;
name|bv_base
operator|=
operator|(
name|BV
operator|*
operator|*
operator|)
name|RE_realloc
argument_list|(
name|bv_base
argument_list|,
operator|(
name|t
operator|+
name|BV_GROWTH
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|BV
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bv_next
operator|=
name|bv_base
operator|+
name|t
expr_stmt|;
name|bv_limit
operator|=
name|bv_next
operator|+
name|BV_GROWTH
expr_stmt|;
block|}
comment|/* put bvp in bv_next as a sentinal */
operator|*
name|bv_next
operator|=
name|bvp
expr_stmt|;
name|p
operator|=
name|bv_base
expr_stmt|;
while|while
condition|(
name|memcmp
argument_list|(
operator|*
name|p
argument_list|,
name|bvp
argument_list|,
name|SIZE_T
argument_list|(
sizeof|sizeof
argument_list|(
name|BV
argument_list|)
argument_list|)
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|bv_next
condition|)
comment|/* it is new */
name|bv_next
operator|++
expr_stmt|;
else|else
comment|/* we already have it */
name|free
argument_list|(
name|bvp
argument_list|)
expr_stmt|;
return|return
operator|*
name|p
return|;
block|}
end_function

begin_comment
comment|/* ----------   convert escape sequences  -------------*/
end_comment

begin_define
define|#
directive|define
name|isoctal
parameter_list|(
name|x
parameter_list|)
value|((x)>='0'&&(x)<='7')
end_define

begin_define
define|#
directive|define
name|NOT_HEX
value|16
end_define

begin_decl_stmt
specifier|static
name|char
name|hex_val
index|[
literal|'f'
operator|-
literal|'A'
operator|+
literal|1
index|]
init|=
block|{
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interpret 1 character as hex */
end_comment

begin_function
specifier|static
name|int
name|ctohex
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
name|int
name|t
decl_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
return|return
name|c
operator|-
literal|'0'
return|;
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'f'
operator|&&
operator|(
name|t
operator|=
name|hex_val
index|[
name|c
operator|-
literal|'A'
index|]
operator|)
condition|)
return|return
name|t
return|;
return|return
name|NOT_HEX
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ET_END
value|7
end_define

begin_struct
specifier|static
struct|struct
block|{
name|char
name|in
decl_stmt|,
name|out
decl_stmt|;
block|}
name|escape_test
index|[
name|ET_END
operator|+
literal|1
index|]
init|=
block|{
literal|'n'
block|,
literal|'\n'
block|,
literal|'t'
block|,
literal|'\t'
block|,
literal|'f'
block|,
literal|'\f'
block|,
literal|'b'
block|,
literal|'\b'
block|,
literal|'r'
block|,
literal|'\r'
block|,
literal|'a'
block|,
literal|'\07'
block|,
literal|'v'
block|,
literal|'\013'
block|,
literal|0
block|,
literal|0
block|}
struct|;
end_struct

begin_comment
comment|/*-----------------   return the char    and move the pointer forward   on entry *s -> at the character after the slash  *-------------------*/
end_comment

begin_function
specifier|static
name|int
name|escape
parameter_list|(
name|start_p
parameter_list|)
name|char
modifier|*
modifier|*
name|start_p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|*
name|start_p
decl_stmt|;
specifier|register
name|unsigned
name|x
decl_stmt|;
name|unsigned
name|xx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|escape_test
index|[
name|ET_END
index|]
operator|.
name|in
operator|=
operator|*
name|p
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|escape_test
index|[
name|i
index|]
operator|.
name|in
operator|!=
operator|*
name|p
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|ET_END
condition|)
comment|/* in table */
block|{
operator|*
name|start_p
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
name|escape_test
index|[
name|i
index|]
operator|.
name|out
return|;
block|}
if|if
condition|(
name|isoctal
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|x
operator|=
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isoctal
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|x
operator|=
operator|(
name|x
operator|<<
literal|3
operator|)
operator|+
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isoctal
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|x
operator|=
operator|(
name|x
operator|<<
literal|3
operator|)
operator|+
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
operator|*
name|start_p
operator|=
name|p
expr_stmt|;
return|return
name|x
operator|&
literal|0xff
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
literal|'\\'
return|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'x'
condition|)
comment|/* might be a hex digit */
block|{
if|if
condition|(
operator|(
name|x
operator|=
name|ctohex
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|==
name|NOT_HEX
condition|)
block|{
operator|*
name|start_p
operator|=
name|p
expr_stmt|;
return|return
literal|'x'
return|;
block|}
comment|/* look for another hex digit */
if|if
condition|(
operator|(
name|xx
operator|=
name|ctohex
argument_list|(
operator|*
operator|++
name|p
argument_list|)
operator|)
operator|!=
name|NOT_HEX
condition|)
block|{
name|x
operator|=
operator|(
name|x
operator|<<
literal|4
operator|)
operator|+
name|xx
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|start_p
operator|=
name|p
expr_stmt|;
return|return
name|x
return|;
block|}
comment|/* anything else \c -> c */
operator|*
name|start_p
operator|=
name|p
expr_stmt|;
return|return
name|p
index|[
operator|-
literal|1
index|]
return|;
block|}
end_function

end_unit

