begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************** rexp3.c copyright 1991, Michael D. Brennan  This is a source file for mawk, an implementation of the AWK programming language.  Mawk is distributed without warranty under the terms of the GNU General Public License, version 2, 1991. ********************************************/
end_comment

begin_comment
comment|/*$Log:	rexp3.c,v $  * Revision 3.5  92/01/21  17:33:20  brennan  * added some casts so that character classes work with signed chars  *   * Revision 3.4  91/10/29  10:54:09  brennan  * SIZE_T  *   * Revision 3.3  91/08/13  09:10:18  brennan  * VERSION .9994  *   * Revision 3.2  91/06/10  16:18:17  brennan  * changes for V7  *   * Revision 3.1  91/06/07  10:33:28  brennan  * VERSION 0.995  *   * Revision 1.4  91/05/31  10:56:32  brennan  * stack_empty hack for DOS large model  *  */
end_comment

begin_comment
comment|/*  match a string against a machine   */
end_comment

begin_include
include|#
directive|include
file|"rexp.h"
end_include

begin_decl_stmt
specifier|extern
name|RT_STATE
modifier|*
name|RE_run_stack_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|RT_STATE
modifier|*
name|RE_run_stack_limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|RT_STATE
modifier|*
name|RE_run_stack_empty
decl_stmt|;
end_decl_stmt

begin_function_decl
name|RT_STATE
modifier|*
name|RE_new_run_stack
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|push
parameter_list|(
name|mx
parameter_list|,
name|sx
parameter_list|,
name|ssx
parameter_list|,
name|ux
parameter_list|)
value|if (++stackp == RE_run_stack_limit)\                                 stackp = RE_new_run_stack() ;\                stackp->m=mx;stackp->s=sx;stackp->ss=ssx;stackp->u=ux;
end_define

begin_define
define|#
directive|define
name|CASE_UANY
parameter_list|(
name|x
parameter_list|)
value|case  x + U_OFF :  case  x + U_ON
end_define

begin_comment
comment|/* returns start of first longest match and the length by    reference.  If no match returns NULL and length zero */
end_comment

begin_function
name|char
modifier|*
name|REmatch
parameter_list|(
name|str
parameter_list|,
name|machine
parameter_list|,
name|lenp
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|VOID
modifier|*
name|machine
decl_stmt|;
name|unsigned
modifier|*
name|lenp
decl_stmt|;
block|{
specifier|register
name|STATE
modifier|*
name|m
init|=
operator|(
name|STATE
operator|*
operator|)
name|machine
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|str
decl_stmt|;
name|char
modifier|*
name|ss
decl_stmt|;
specifier|register
name|RT_STATE
modifier|*
name|stackp
decl_stmt|;
name|int
name|u_flag
decl_stmt|;
name|char
modifier|*
name|str_end
decl_stmt|,
modifier|*
name|ts
decl_stmt|;
comment|/* state of current best match stored here */
name|char
modifier|*
name|cb_ss
decl_stmt|;
comment|/* the start */
name|char
modifier|*
name|cb_e
decl_stmt|;
comment|/* the end , pts at first char not matched */
operator|*
name|lenp
operator|=
literal|0
expr_stmt|;
comment|/* check for the easy case */
if|if
condition|(
operator|(
name|m
operator|+
literal|1
operator|)
operator|->
name|type
operator|==
name|M_ACCEPT
operator|&&
name|m
operator|->
name|type
operator|==
name|M_STR
condition|)
block|{
if|if
condition|(
name|ts
operator|=
name|str_str
argument_list|(
name|s
argument_list|,
name|m
operator|->
name|data
operator|.
name|str
argument_list|,
name|m
operator|->
name|len
argument_list|)
condition|)
operator|*
name|lenp
operator|=
name|m
operator|->
name|len
expr_stmt|;
return|return
name|ts
return|;
block|}
name|u_flag
operator|=
name|U_ON
expr_stmt|;
name|cb_ss
operator|=
name|ss
operator|=
name|str_end
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|stackp
operator|=
name|RE_run_stack_empty
expr_stmt|;
goto|goto
name|reswitch
goto|;
name|refill
label|:
if|if
condition|(
name|stackp
operator|==
name|RE_run_stack_empty
condition|)
block|{
if|if
condition|(
name|cb_ss
condition|)
operator|*
name|lenp
operator|=
name|cb_e
operator|-
name|cb_ss
expr_stmt|;
return|return
name|cb_ss
return|;
block|}
name|ss
operator|=
name|stackp
operator|->
name|ss
expr_stmt|;
name|s
operator|=
name|stackp
operator|--
operator|->
name|s
expr_stmt|;
if|if
condition|(
name|cb_ss
condition|)
comment|/* does new state start too late ? */
if|if
condition|(
name|ss
condition|)
block|{
if|if
condition|(
name|cb_ss
operator|<
name|ss
condition|)
goto|goto
name|refill
goto|;
block|}
elseif|else
if|if
condition|(
name|cb_ss
operator|<
name|s
condition|)
goto|goto
name|refill
goto|;
name|m
operator|=
operator|(
name|stackp
operator|+
literal|1
operator|)
operator|->
name|m
expr_stmt|;
name|u_flag
operator|=
operator|(
name|stackp
operator|+
literal|1
operator|)
operator|->
name|u
expr_stmt|;
name|reswitch
label|:
switch|switch
condition|(
name|m
operator|->
name|type
operator|+
name|u_flag
condition|)
block|{
case|case
name|M_STR
operator|+
name|U_OFF
operator|+
name|END_OFF
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
name|m
operator|->
name|data
operator|.
name|str
argument_list|,
name|SIZE_T
argument_list|(
name|m
operator|->
name|len
argument_list|)
argument_list|)
condition|)
goto|goto
name|refill
goto|;
if|if
condition|(
operator|!
name|ss
condition|)
if|if
condition|(
name|cb_ss
operator|&&
name|s
operator|>
name|cb_ss
condition|)
goto|goto
name|refill
goto|;
else|else
name|ss
operator|=
name|s
expr_stmt|;
name|s
operator|+=
name|m
operator|->
name|len
expr_stmt|;
name|m
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_STR
operator|+
name|U_OFF
operator|+
name|END_ON
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|m
operator|->
name|data
operator|.
name|str
argument_list|)
condition|)
goto|goto
name|refill
goto|;
if|if
condition|(
operator|!
name|ss
condition|)
if|if
condition|(
name|cb_ss
operator|&&
name|s
operator|>
name|cb_ss
condition|)
goto|goto
name|refill
goto|;
else|else
name|ss
operator|=
name|s
expr_stmt|;
name|s
operator|+=
name|m
operator|->
name|len
expr_stmt|;
name|m
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_STR
operator|+
name|U_ON
operator|+
name|END_OFF
case|:
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|str_str
argument_list|(
name|s
argument_list|,
name|m
operator|->
name|data
operator|.
name|str
argument_list|,
name|m
operator|->
name|len
argument_list|)
operator|)
condition|)
goto|goto
name|refill
goto|;
name|push
argument_list|(
name|m
argument_list|,
name|s
operator|+
literal|1
argument_list|,
name|ss
argument_list|,
name|U_ON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ss
condition|)
if|if
condition|(
name|cb_ss
operator|&&
name|s
operator|>
name|cb_ss
condition|)
goto|goto
name|refill
goto|;
else|else
name|ss
operator|=
name|s
expr_stmt|;
name|s
operator|+=
name|m
operator|->
name|len
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|u_flag
operator|=
name|U_OFF
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_STR
operator|+
name|U_ON
operator|+
name|END_ON
case|:
if|if
condition|(
operator|!
name|str_end
condition|)
name|str_end
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ts
operator|=
name|str_end
operator|-
name|m
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|ts
operator|<
name|s
operator|||
name|memcmp
argument_list|(
name|ts
argument_list|,
name|m
operator|->
name|data
operator|.
name|str
argument_list|,
name|SIZE_T
argument_list|(
name|m
operator|->
name|len
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
goto|goto
name|refill
goto|;
if|if
condition|(
operator|!
name|ss
condition|)
if|if
condition|(
name|cb_ss
operator|&&
name|ts
operator|>
name|cb_ss
condition|)
goto|goto
name|refill
goto|;
else|else
name|ss
operator|=
name|ts
expr_stmt|;
name|s
operator|=
name|str_end
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|u_flag
operator|=
name|U_OFF
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_CLASS
operator|+
name|U_OFF
operator|+
name|END_OFF
case|:
if|if
condition|(
operator|!
name|ison
argument_list|(
operator|*
name|m
operator|->
name|data
operator|.
name|bvp
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|)
condition|)
goto|goto
name|refill
goto|;
if|if
condition|(
operator|!
name|ss
condition|)
if|if
condition|(
name|cb_ss
operator|&&
name|s
operator|>
name|cb_ss
condition|)
goto|goto
name|refill
goto|;
else|else
name|ss
operator|=
name|s
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|m
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_CLASS
operator|+
name|U_OFF
operator|+
name|END_ON
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|||
operator|!
name|ison
argument_list|(
operator|*
name|m
operator|->
name|data
operator|.
name|bvp
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|)
condition|)
goto|goto
name|refill
goto|;
if|if
condition|(
operator|!
name|ss
condition|)
if|if
condition|(
name|cb_ss
operator|&&
name|s
operator|>
name|cb_ss
condition|)
goto|goto
name|refill
goto|;
else|else
name|ss
operator|=
name|s
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|m
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_CLASS
operator|+
name|U_ON
operator|+
name|END_OFF
case|:
while|while
condition|(
operator|!
name|ison
argument_list|(
operator|*
name|m
operator|->
name|data
operator|.
name|bvp
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|)
condition|)
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|0
condition|)
goto|goto
name|refill
goto|;
else|else
name|s
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|push
argument_list|(
name|m
argument_list|,
name|s
argument_list|,
name|ss
argument_list|,
name|U_ON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ss
condition|)
if|if
condition|(
name|cb_ss
operator|&&
name|s
operator|-
literal|1
operator|>
name|cb_ss
condition|)
goto|goto
name|refill
goto|;
else|else
name|ss
operator|=
name|s
operator|-
literal|1
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|u_flag
operator|=
name|U_OFF
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_CLASS
operator|+
name|U_ON
operator|+
name|END_ON
case|:
if|if
condition|(
operator|!
name|str_end
condition|)
name|str_end
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ison
argument_list|(
operator|*
name|m
operator|->
name|data
operator|.
name|bvp
argument_list|,
name|str_end
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
goto|goto
name|refill
goto|;
if|if
condition|(
operator|!
name|ss
condition|)
if|if
condition|(
name|cb_ss
operator|&&
name|str_end
operator|-
literal|1
operator|>
name|cb_ss
condition|)
goto|goto
name|refill
goto|;
else|else
name|ss
operator|=
name|str_end
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|str_end
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|u_flag
operator|=
name|U_OFF
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_ANY
operator|+
name|U_OFF
operator|+
name|END_OFF
case|:
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|0
condition|)
goto|goto
name|refill
goto|;
if|if
condition|(
operator|!
name|ss
condition|)
if|if
condition|(
name|cb_ss
operator|&&
name|s
operator|>
name|cb_ss
condition|)
goto|goto
name|refill
goto|;
else|else
name|ss
operator|=
name|s
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|m
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_ANY
operator|+
name|U_OFF
operator|+
name|END_ON
case|:
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|s
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
goto|goto
name|refill
goto|;
if|if
condition|(
operator|!
name|ss
condition|)
if|if
condition|(
name|cb_ss
operator|&&
name|s
operator|>
name|cb_ss
condition|)
goto|goto
name|refill
goto|;
else|else
name|ss
operator|=
name|s
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|m
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_ANY
operator|+
name|U_ON
operator|+
name|END_OFF
case|:
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|0
condition|)
goto|goto
name|refill
goto|;
name|s
operator|++
expr_stmt|;
name|push
argument_list|(
name|m
argument_list|,
name|s
argument_list|,
name|ss
argument_list|,
name|U_ON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ss
condition|)
if|if
condition|(
name|cb_ss
operator|&&
name|s
operator|-
literal|1
operator|>
name|cb_ss
condition|)
goto|goto
name|refill
goto|;
else|else
name|ss
operator|=
name|s
operator|-
literal|1
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|u_flag
operator|=
name|U_OFF
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_ANY
operator|+
name|U_ON
operator|+
name|END_ON
case|:
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|0
condition|)
goto|goto
name|refill
goto|;
if|if
condition|(
operator|!
name|str_end
condition|)
name|str_end
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ss
condition|)
if|if
condition|(
name|cb_ss
operator|&&
name|str_end
operator|-
literal|1
operator|>
name|cb_ss
condition|)
goto|goto
name|refill
goto|;
else|else
name|ss
operator|=
name|str_end
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|str_end
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|u_flag
operator|=
name|U_OFF
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_START
operator|+
name|U_OFF
operator|+
name|END_OFF
case|:
case|case
name|M_START
operator|+
name|U_ON
operator|+
name|END_OFF
case|:
if|if
condition|(
name|s
operator|!=
name|str
condition|)
goto|goto
name|refill
goto|;
name|ss
operator|=
name|s
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|u_flag
operator|=
name|U_OFF
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_START
operator|+
name|U_OFF
operator|+
name|END_ON
case|:
case|case
name|M_START
operator|+
name|U_ON
operator|+
name|END_ON
case|:
if|if
condition|(
name|s
operator|!=
name|str
operator|||
name|s
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
goto|goto
name|refill
goto|;
name|ss
operator|=
name|s
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|u_flag
operator|=
name|U_OFF
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_END
operator|+
name|U_OFF
case|:
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
goto|goto
name|refill
goto|;
if|if
condition|(
operator|!
name|ss
condition|)
if|if
condition|(
name|cb_ss
operator|&&
name|s
operator|>
name|cb_ss
condition|)
goto|goto
name|refill
goto|;
else|else
name|ss
operator|=
name|s
expr_stmt|;
name|m
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_END
operator|+
name|U_ON
case|:
name|s
operator|=
name|str_end
condition|?
name|str_end
else|:
operator|(
name|str_end
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ss
condition|)
if|if
condition|(
name|cb_ss
operator|&&
name|s
operator|>
name|cb_ss
condition|)
goto|goto
name|refill
goto|;
else|else
name|ss
operator|=
name|s
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|u_flag
operator|=
name|U_OFF
expr_stmt|;
goto|goto
name|reswitch
goto|;
name|CASE_UANY
argument_list|(
name|M_U
argument_list|)
operator|:
if|if
condition|(
operator|!
name|ss
condition|)
if|if
condition|(
name|cb_ss
operator|&&
name|s
operator|>
name|cb_ss
condition|)
goto|goto
name|refill
goto|;
else|else
name|ss
operator|=
name|s
expr_stmt|;
name|u_flag
operator|=
name|U_ON
expr_stmt|;
name|m
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
name|CASE_UANY
argument_list|(
name|M_1J
argument_list|)
operator|:
name|m
operator|+=
name|m
operator|->
name|data
operator|.
name|jump
expr_stmt|;
goto|goto
name|reswitch
goto|;
name|CASE_UANY
argument_list|(
name|M_2JA
argument_list|)
operator|:
comment|/* take the non jump branch */
name|push
argument_list|(
name|m
operator|+
name|m
operator|->
name|data
operator|.
name|jump
argument_list|,
name|s
argument_list|,
name|ss
argument_list|,
name|u_flag
argument_list|)
expr_stmt|;
name|m
operator|++
expr_stmt|;
goto|goto
name|reswitch
goto|;
name|CASE_UANY
argument_list|(
name|M_2JB
argument_list|)
operator|:
comment|/* take the jump branch */
name|push
argument_list|(
name|m
operator|+
literal|1
argument_list|,
name|s
argument_list|,
name|ss
argument_list|,
name|u_flag
argument_list|)
expr_stmt|;
name|m
operator|+=
name|m
operator|->
name|data
operator|.
name|jump
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|M_ACCEPT
operator|+
name|U_OFF
case|:
if|if
condition|(
operator|!
name|ss
condition|)
name|ss
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|cb_ss
operator|||
name|ss
operator|<
name|cb_ss
operator|||
name|ss
operator|==
name|cb_ss
operator|&&
name|s
operator|>
name|cb_e
condition|)
block|{
comment|/* we have a new current best */
name|cb_ss
operator|=
name|ss
expr_stmt|;
name|cb_e
operator|=
name|s
expr_stmt|;
block|}
goto|goto
name|refill
goto|;
case|case
name|M_ACCEPT
operator|+
name|U_ON
case|:
if|if
condition|(
operator|!
name|ss
condition|)
name|ss
operator|=
name|s
expr_stmt|;
else|else
name|s
operator|=
name|str_end
condition|?
name|str_end
else|:
operator|(
name|str_end
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|cb_ss
operator|||
name|ss
operator|<
name|cb_ss
operator|||
name|ss
operator|==
name|cb_ss
operator|&&
name|s
operator|>
name|cb_e
condition|)
block|{
comment|/* we have a new current best */
name|cb_ss
operator|=
name|ss
expr_stmt|;
name|cb_e
operator|=
name|s
expr_stmt|;
block|}
goto|goto
name|refill
goto|;
default|default :
name|RE_panic
argument_list|(
literal|"unexpected case in REmatch"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

