begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************** da.c copyright 1991, Michael D. Brennan  This is a source file for mawk, an implementation of the AWK programming language.  Mawk is distributed without warranty under the terms of the GNU General Public License, version 2, 1991. ********************************************/
end_comment

begin_comment
comment|/* $Log:	da.c,v $  * Revision 5.1  91/12/05  07:55:45  brennan  * 1.1 pre-release  *  */
end_comment

begin_comment
comment|/*  da.c  */
end_comment

begin_comment
comment|/*  disassemble code */
end_comment

begin_comment
comment|/* This and new posix stuff won't fit in small model DOS  */
end_comment

begin_include
include|#
directive|include
file|"mawk.h"
end_include

begin_if
if|#
directive|if
operator|!
name|SM_DOS
end_if

begin_include
include|#
directive|include
file|"code.h"
end_include

begin_include
include|#
directive|include
file|"bi_funct.h"
end_include

begin_include
include|#
directive|include
file|"repl.h"
end_include

begin_include
include|#
directive|include
file|"field.h"
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|PROTO
argument_list|(
name|find_bi_name
argument_list|,
operator|(
name|PF_CP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|sc
block|{
name|char
name|op
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|simple_code
index|[]
init|=
block|{
name|_STOP
block|,
literal|"stop"
block|,
name|FE_PUSHA
block|,
literal|"fe_pusha"
block|,
name|FE_PUSHI
block|,
literal|"fe_pushi"
block|,
name|A_TEST
block|,
literal|"a_test"
block|,
name|A_DEL
block|,
literal|"a_del"
block|,
name|A_CAT
block|,
literal|"a_cat"
block|,
name|_POP
block|,
literal|"pop"
block|,
name|_ADD
block|,
literal|"add"
block|,
name|_SUB
block|,
literal|"sub"
block|,
name|_MUL
block|,
literal|"mul"
block|,
name|_DIV
block|,
literal|"div"
block|,
name|_MOD
block|,
literal|"mod"
block|,
name|_POW
block|,
literal|"pow"
block|,
name|_NOT
block|,
literal|"not"
block|,
name|_UMINUS
block|,
literal|"uminus"
block|,
name|_UPLUS
block|,
literal|"uplus"
block|,
name|_DUP
block|,
literal|"dup"
block|,
name|_TEST
block|,
literal|"test"
block|,
name|_CAT
block|,
literal|"cat"
block|,
name|_ASSIGN
block|,
literal|"assign"
block|,
name|_ADD_ASG
block|,
literal|"add_asg"
block|,
name|_SUB_ASG
block|,
literal|"sub_asg"
block|,
name|_MUL_ASG
block|,
literal|"mul_asg"
block|,
name|_DIV_ASG
block|,
literal|"div_asg"
block|,
name|_MOD_ASG
block|,
literal|"mod_asg"
block|,
name|_POW_ASG
block|,
literal|"pow_asg"
block|,
name|NF_PUSHI
block|,
literal|"nf_pushi"
block|,
name|F_ASSIGN
block|,
literal|"f_assign"
block|,
name|F_ADD_ASG
block|,
literal|"f_add_asg"
block|,
name|F_SUB_ASG
block|,
literal|"f_sub_asg"
block|,
name|F_MUL_ASG
block|,
literal|"f_mul_asg"
block|,
name|F_DIV_ASG
block|,
literal|"f_div_asg"
block|,
name|F_MOD_ASG
block|,
literal|"f_mod_asg"
block|,
name|F_POW_ASG
block|,
literal|"f_pow_asg"
block|,
name|_POST_INC
block|,
literal|"post_inc"
block|,
name|_POST_DEC
block|,
literal|"post_dec"
block|,
name|_PRE_INC
block|,
literal|"pre_inc"
block|,
name|_PRE_INC
block|,
literal|"pre_dec"
block|,
name|F_POST_INC
block|,
literal|"f_post_inc"
block|,
name|F_POST_DEC
block|,
literal|"f_post_dec"
block|,
name|F_PRE_INC
block|,
literal|"f_pre_inc"
block|,
name|F_PRE_INC
block|,
literal|"f_pre_dec"
block|,
name|_EQ
block|,
literal|"eq"
block|,
name|_NEQ
block|,
literal|"neq"
block|,
name|_LT
block|,
literal|"lt"
block|,
name|_LTE
block|,
literal|"lte"
block|,
name|_GT
block|,
literal|"gt"
block|,
name|_GTE
block|,
literal|"gte"
block|,
name|_MATCH2
block|,
literal|"match2"
block|,
name|_EXIT
block|,
literal|"exit"
block|,
name|_EXIT0
block|,
literal|"exit0"
block|,
name|_NEXT
block|,
literal|"next"
block|,
name|_RET
block|,
literal|"ret"
block|,
name|_RET0
block|,
literal|"ret0"
block|,
name|_OMAIN
block|,
literal|"omain"
block|,
name|_JMAIN
block|,
literal|"jmain"
block|,
name|OL_GL
block|,
literal|"ol_gl"
block|,
name|OL_GL_NR
block|,
literal|"ol_gl_nr"
block|,
name|_HALT
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|}
struct|;
end_struct

begin_function
name|void
name|da
parameter_list|(
name|start
parameter_list|,
name|fp
parameter_list|)
name|INST
modifier|*
name|start
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|CELL
modifier|*
name|cp
decl_stmt|;
specifier|register
name|INST
modifier|*
name|p
init|=
name|start
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
while|while
condition|(
name|p
operator|->
name|op
operator|!=
name|_HALT
condition|)
block|{
comment|/* print the relative code address (label) */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%03d "
argument_list|,
name|p
operator|-
name|start
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
operator|++
operator|->
name|op
condition|)
block|{
case|case
name|_PUSHC
case|:
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
name|p
operator|++
operator|->
name|ptr
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|type
condition|)
block|{
case|case
name|C_RE
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"pushc\t0x%lx\t/%s/\n"
argument_list|,
operator|(
name|long
operator|)
name|cp
operator|->
name|ptr
argument_list|,
name|re_uncompile
argument_list|(
name|cp
operator|->
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
break|break ;
case|case
name|C_SPACE
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"pushc\tspace split\n"
argument_list|)
expr_stmt|;
break|break ;
case|case
name|C_SNULL
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"pushc\tnull split\n"
argument_list|)
expr_stmt|;
break|break ;
case|case
name|C_REPL
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"pushc\trepl\t%s\n"
argument_list|,
name|repl_uncompile
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
break|break ;
case|case
name|C_REPLV
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"pushc\treplv\t%s\n"
argument_list|,
name|repl_uncompile
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
break|break ;
default|default :
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"pushc\tWEIRD\n"
argument_list|)
expr_stmt|;
empty_stmt|;
break|break ;
block|}
break|break ;
case|case
name|_PUSHD
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"pushd\t%.6g\n"
argument_list|,
operator|*
operator|(
name|double
operator|*
operator|)
name|p
operator|++
operator|->
name|ptr
argument_list|)
expr_stmt|;
break|break ;
case|case
name|_PUSHS
case|:
block|{
name|STRING
modifier|*
name|sval
init|=
operator|(
name|STRING
operator|*
operator|)
name|p
operator|++
operator|->
name|ptr
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"pushs\t\"%s\"\n"
argument_list|,
name|sval
operator|->
name|str
argument_list|)
expr_stmt|;
break|break ;
block|}
case|case
name|_MATCH0
case|:
case|case
name|_MATCH1
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"match%d\t0x%lx\t/%s/\n"
argument_list|,
name|p
index|[
operator|-
literal|1
index|]
operator|.
name|op
operator|==
name|_MATCH1
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|ptr
argument_list|,
name|re_uncompile
argument_list|(
name|p
operator|->
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break ;
case|case
name|_PUSHA
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"pusha\t%s\n"
argument_list|,
name|reverse_find
argument_list|(
name|ST_VAR
argument_list|,
operator|&
name|p
operator|++
operator|->
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
break|break ;
case|case
name|_PUSHI
case|:
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
name|p
operator|++
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|field
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"pushi\t$0\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|==
operator|&
name|fs_shadow
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"pushi\t@fs_shadow\n"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
if|#
directive|if
name|LM_DOS
name|SAMESEG
argument_list|(
name|cp
argument_list|,
name|field
argument_list|)
operator|&&
endif|#
directive|endif
name|cp
operator|>
name|NF
operator|&&
name|cp
operator|<=
name|LAST_PFIELD
condition|)
name|name
operator|=
name|reverse_find
argument_list|(
name|ST_FIELD
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|reverse_find
argument_list|(
name|ST_VAR
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"pushi\t%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
break|break ;
case|case
name|L_PUSHA
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"l_pusha\t%d\n"
argument_list|,
name|p
operator|++
operator|->
name|op
argument_list|)
expr_stmt|;
break|break ;
case|case
name|L_PUSHI
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"l_pushi\t%d\n"
argument_list|,
name|p
operator|++
operator|->
name|op
argument_list|)
expr_stmt|;
break|break ;
case|case
name|LAE_PUSHI
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"lae_pushi\t%d\n"
argument_list|,
name|p
operator|++
operator|->
name|op
argument_list|)
expr_stmt|;
break|break ;
case|case
name|LAE_PUSHA
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"lae_pusha\t%d\n"
argument_list|,
name|p
operator|++
operator|->
name|op
argument_list|)
expr_stmt|;
break|break ;
case|case
name|LA_PUSHA
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"la_pusha\t%d\n"
argument_list|,
name|p
operator|++
operator|->
name|op
argument_list|)
expr_stmt|;
break|break ;
case|case
name|F_PUSHA
case|:
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
name|p
operator|++
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
if|#
directive|if
name|LM_DOS
name|SAMESEG
argument_list|(
name|cp
argument_list|,
name|field
argument_list|)
operator|&&
endif|#
directive|endif
name|cp
operator|>=
name|NF
operator|&&
name|cp
operator|<=
name|LAST_PFIELD
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"f_pusha\t%s\n"
argument_list|,
name|reverse_find
argument_list|(
name|ST_FIELD
argument_list|,
operator|&
name|cp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"f_pusha\t$%d\n"
argument_list|,
name|field_addr_to_index
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
break|break ;
case|case
name|F_PUSHI
case|:
name|p
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"f_pushi\t$%d\n"
argument_list|,
name|p
operator|++
operator|->
name|op
argument_list|)
expr_stmt|;
break|break ;
case|case
name|AE_PUSHA
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"ae_pusha\t%s\n"
argument_list|,
name|reverse_find
argument_list|(
name|ST_ARRAY
argument_list|,
operator|&
name|p
operator|++
operator|->
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
break|break ;
case|case
name|AE_PUSHI
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"ae_pushi\t%s\n"
argument_list|,
name|reverse_find
argument_list|(
name|ST_ARRAY
argument_list|,
operator|&
name|p
operator|++
operator|->
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
break|break ;
case|case
name|A_PUSHA
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"a_pusha\t%s\n"
argument_list|,
name|reverse_find
argument_list|(
name|ST_ARRAY
argument_list|,
operator|&
name|p
operator|++
operator|->
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
break|break ;
case|case
name|_PUSHINT
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"pushint\t%d\n"
argument_list|,
name|p
operator|++
operator|->
name|op
argument_list|)
expr_stmt|;
break|break ;
case|case
name|_BUILTIN
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|find_bi_name
argument_list|(
operator|(
name|PF_CP
operator|)
name|p
operator|++
operator|->
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
break|break ;
case|case
name|_PRINT
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
operator|(
name|PF_CP
operator|)
name|p
operator|++
operator|->
name|ptr
operator|==
name|bi_printf
condition|?
literal|"printf"
else|:
literal|"print"
argument_list|)
expr_stmt|;
break|break ;
case|case
name|_JMP
case|:
case|case
name|_JNZ
case|:
case|case
name|_JZ
case|:
block|{
name|int
name|j
init|=
operator|(
name|p
operator|-
literal|1
operator|)
operator|->
name|op
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|j
operator|==
name|_JMP
condition|?
literal|"jmp"
else|:
name|j
operator|==
name|_JNZ
condition|?
literal|"jnz"
else|:
literal|"jz"
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\t\t%03d\n"
argument_list|,
name|s
argument_list|,
operator|(
name|p
operator|-
name|start
operator|)
operator|+
name|p
operator|->
name|op
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break ;
block|}
case|case
name|SET_ALOOP
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"s_aloop\t%03d\n"
argument_list|,
name|p
operator|+
name|p
operator|->
name|op
operator|-
name|start
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break ;
case|case
name|ALOOP
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"aloop\t%03d\n"
argument_list|,
name|p
operator|-
name|start
operator|+
name|p
operator|->
name|op
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
break|break ;
case|case
name|_CALL
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"call\t%s\t%d\n"
argument_list|,
operator|(
operator|(
name|FBLOCK
operator|*
operator|)
name|p
operator|->
name|ptr
operator|)
operator|->
name|name
argument_list|,
name|p
index|[
literal|1
index|]
operator|.
name|op
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
break|break ;
case|case
name|_RANGE
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"range\t%03d %03d %03d\n"
argument_list|,
comment|/* label for pat2, action, follow */
name|p
operator|-
name|start
operator|+
name|p
index|[
literal|1
index|]
operator|.
name|op
argument_list|,
name|p
operator|-
name|start
operator|+
name|p
index|[
literal|2
index|]
operator|.
name|op
argument_list|,
name|p
operator|-
name|start
operator|+
name|p
index|[
literal|3
index|]
operator|.
name|op
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
break|break ;
default|default :
block|{
name|struct
name|sc
modifier|*
name|q
init|=
name|simple_code
decl_stmt|;
name|int
name|k
init|=
operator|(
name|p
operator|-
literal|1
operator|)
operator|->
name|op
decl_stmt|;
while|while
condition|(
name|q
operator|->
name|op
operator|!=
name|_HALT
operator|&&
name|q
operator|->
name|op
operator|!=
name|k
condition|)
name|q
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|q
operator|->
name|op
operator|!=
name|_HALT
condition|?
name|q
operator|->
name|name
else|:
literal|"bad instruction"
argument_list|)
expr_stmt|;
block|}
break|break ;
block|}
block|}
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
name|PF_CP
name|action
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|special_cases
index|[]
init|=
block|{
name|bi_split
block|,
literal|"split"
block|,
name|bi_match
block|,
literal|"match"
block|,
name|bi_getline
block|,
literal|"getline"
block|,
name|bi_sub
block|,
literal|"sub"
block|,
name|bi_gsub
block|,
literal|"gsub"
block|,
operator|(
name|PF_CP
operator|)
literal|0
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|}
struct|;
end_struct

begin_function
specifier|static
name|char
modifier|*
name|find_bi_name
parameter_list|(
name|p
parameter_list|)
name|PF_CP
name|p
decl_stmt|;
block|{
name|BI_REC
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|q
operator|=
name|bi_funct
init|;
name|q
operator|->
name|name
condition|;
name|q
operator|++
control|)
if|if
condition|(
name|q
operator|->
name|fp
operator|==
name|p
condition|)
comment|/* found */
return|return
name|q
operator|->
name|name
return|;
comment|/* next check some special cases */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|special_cases
index|[
name|i
index|]
operator|.
name|action
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|special_cases
index|[
name|i
index|]
operator|.
name|action
operator|==
name|p
condition|)
return|return
name|special_cases
index|[
name|i
index|]
operator|.
name|name
return|;
return|return
literal|"unknown builtin"
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
name|fdump
block|{
name|struct
name|fdump
modifier|*
name|link
decl_stmt|;
name|FBLOCK
modifier|*
name|fbp
decl_stmt|;
block|}
modifier|*
name|fdump_list
struct|;
end_struct

begin_comment
comment|/* linked list of all user functions */
end_comment

begin_function
name|void
name|add_to_fdump_list
parameter_list|(
name|fbp
parameter_list|)
name|FBLOCK
modifier|*
name|fbp
decl_stmt|;
block|{
name|struct
name|fdump
modifier|*
name|p
init|=
operator|(
expr|struct
name|fdump
operator|*
operator|)
name|zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fdump
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|fbp
operator|=
name|fbp
expr_stmt|;
name|p
operator|->
name|link
operator|=
name|fdump_list
expr_stmt|;
name|fdump_list
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fdump
parameter_list|()
block|{
specifier|register
name|struct
name|fdump
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
init|=
name|fdump_list
decl_stmt|;
while|while
condition|(
name|p
operator|=
name|q
condition|)
block|{
name|q
operator|=
name|p
operator|->
name|link
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function %s\n"
argument_list|,
name|p
operator|->
name|fbp
operator|->
name|name
argument_list|)
expr_stmt|;
name|da
argument_list|(
name|p
operator|->
name|fbp
operator|->
name|code
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fdump
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SM_DOS */
end_comment

end_unit

