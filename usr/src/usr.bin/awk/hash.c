begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************** hash.c copyright 1991, Michael D. Brennan  This is a source file for mawk, an implementation of the AWK programming language.  Mawk is distributed without warranty under the terms of the GNU General Public License, version 2, 1991. ********************************************/
end_comment

begin_comment
comment|/* $Log:	hash.c,v $  * Revision 5.1  91/12/05  07:56:05  brennan  * 1.1 pre-release  *  */
end_comment

begin_comment
comment|/* hash.c */
end_comment

begin_include
include|#
directive|include
file|"mawk.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_include
include|#
directive|include
file|"symtype.h"
end_include

begin_function
name|unsigned
name|hash
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|unsigned
name|h
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|h
operator|+=
name|h
operator|+
operator|*
name|s
operator|++
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|hash
block|{
name|struct
name|hash
modifier|*
name|link
decl_stmt|;
name|SYMTAB
name|symtab
decl_stmt|;
block|}
name|HASHNODE
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|HASHNODE
modifier|*
name|PROTO
argument_list|(
name|delete
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|new_HASHNODE
parameter_list|()
value|(HASHNODE *) zmalloc(sizeof(HASHNODE))
end_define

begin_decl_stmt
specifier|static
name|HASHNODE
modifier|*
name|hash_table
index|[
name|HASH_PRIME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *   insert -- s is not there and need not be duplicated  *   -- used during initialization  */
end_comment

begin_function
name|SYMTAB
modifier|*
name|insert
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|HASHNODE
modifier|*
name|p
init|=
name|new_HASHNODE
argument_list|()
decl_stmt|;
specifier|register
name|unsigned
name|h
decl_stmt|;
name|p
operator|->
name|link
operator|=
name|hash_table
index|[
name|h
operator|=
name|hash
argument_list|(
name|s
argument_list|)
operator|%
name|HASH_PRIME
index|]
expr_stmt|;
name|p
operator|->
name|symtab
operator|.
name|name
operator|=
name|s
expr_stmt|;
name|hash_table
index|[
name|h
index|]
operator|=
name|p
expr_stmt|;
return|return
operator|&
name|p
operator|->
name|symtab
return|;
block|}
end_function

begin_comment
comment|/*  *  find --  s might be there, find it else insert and dup  *  s   */
end_comment

begin_function
name|SYMTAB
modifier|*
name|find
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|HASHNODE
modifier|*
name|p
decl_stmt|;
name|HASHNODE
modifier|*
name|q
decl_stmt|;
name|unsigned
name|h
decl_stmt|;
name|p
operator|=
name|hash_table
index|[
name|h
operator|=
name|hash
argument_list|(
name|s
argument_list|)
operator|%
name|HASH_PRIME
index|]
expr_stmt|;
name|q
operator|=
operator|(
name|HASHNODE
operator|*
operator|)
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|p
operator|=
name|new_HASHNODE
argument_list|()
expr_stmt|;
name|p
operator|->
name|symtab
operator|.
name|type
operator|=
name|ST_NONE
expr_stmt|;
name|p
operator|->
name|symtab
operator|.
name|name
operator|=
name|strcpy
argument_list|(
name|zmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break ;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|symtab
operator|.
name|name
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
comment|/* found */
if|if
condition|(
operator|!
name|q
condition|)
comment|/* already at the front */
return|return
operator|&
name|p
operator|->
name|symtab
return|;
else|else
comment|/* delete from the list */
block|{
name|q
operator|->
name|link
operator|=
name|p
operator|->
name|link
expr_stmt|;
break|break ;
block|}
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|link
expr_stmt|;
block|}
comment|/* put p on front of the list */
name|p
operator|->
name|link
operator|=
name|hash_table
index|[
name|h
index|]
expr_stmt|;
name|hash_table
index|[
name|h
index|]
operator|=
name|p
expr_stmt|;
return|return
operator|&
name|p
operator|->
name|symtab
return|;
block|}
end_function

begin_comment
comment|/* remove a node from the hash table    return a ptr to the node */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|last_hash
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|HASHNODE
modifier|*
name|delete
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|HASHNODE
modifier|*
name|p
decl_stmt|;
name|HASHNODE
modifier|*
name|q
init|=
operator|(
name|HASHNODE
operator|*
operator|)
literal|0
decl_stmt|;
name|unsigned
name|h
decl_stmt|;
name|p
operator|=
name|hash_table
index|[
name|last_hash
operator|=
name|h
operator|=
name|hash
argument_list|(
name|s
argument_list|)
operator|%
name|HASH_PRIME
index|]
expr_stmt|;
while|while
condition|(
name|p
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|symtab
operator|.
name|name
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
comment|/* found */
block|{
if|if
condition|(
name|q
condition|)
name|q
operator|->
name|link
operator|=
name|p
operator|->
name|link
expr_stmt|;
else|else
name|hash_table
index|[
name|h
index|]
operator|=
name|p
operator|->
name|link
expr_stmt|;
return|return
name|p
return|;
block|}
else|else
block|{
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|link
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
comment|/* we should not ever get here */
name|bozo
argument_list|(
literal|"delete"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|HASHNODE
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* when processing user functions,  global ids which are    replaced by local ids are saved on this list */
end_comment

begin_decl_stmt
specifier|static
name|HASHNODE
modifier|*
name|save_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* store a global id on the save list,    return a ptr to the local symtab  */
end_comment

begin_function
name|SYMTAB
modifier|*
name|save_id
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|HASHNODE
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|h
decl_stmt|;
name|p
operator|=
name|delete
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|q
operator|=
name|new_HASHNODE
argument_list|()
expr_stmt|;
name|q
operator|->
name|symtab
operator|.
name|type
operator|=
name|ST_LOCAL_NONE
expr_stmt|;
name|q
operator|->
name|symtab
operator|.
name|name
operator|=
name|p
operator|->
name|symtab
operator|.
name|name
expr_stmt|;
comment|/* put q in the hash table */
name|q
operator|->
name|link
operator|=
name|hash_table
index|[
name|h
operator|=
name|last_hash
index|]
expr_stmt|;
name|hash_table
index|[
name|h
index|]
operator|=
name|q
expr_stmt|;
comment|/* save p */
name|p
operator|->
name|link
operator|=
name|save_list
expr_stmt|;
name|save_list
operator|=
name|p
expr_stmt|;
return|return
operator|&
name|q
operator|->
name|symtab
return|;
block|}
end_function

begin_comment
comment|/* restore all global indentifiers */
end_comment

begin_function
name|void
name|restore_ids
parameter_list|()
block|{
specifier|register
name|HASHNODE
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|unsigned
name|h
decl_stmt|;
name|q
operator|=
name|save_list
expr_stmt|;
name|save_list
operator|=
operator|(
name|HASHNODE
operator|*
operator|)
literal|0
expr_stmt|;
while|while
condition|(
name|q
condition|)
block|{
name|p
operator|=
name|q
expr_stmt|;
name|q
operator|=
name|q
operator|->
name|link
expr_stmt|;
name|zfree
argument_list|(
name|delete
argument_list|(
name|p
operator|->
name|symtab
operator|.
name|name
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|link
operator|=
name|hash_table
index|[
name|h
operator|=
name|last_hash
index|]
expr_stmt|;
name|hash_table
index|[
name|h
index|]
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* search the symbol table backwards for the    disassembler.  This is slow -- so what */
end_comment

begin_if
if|#
directive|if
operator|!
name|SM_DOS
end_if

begin_function
name|char
modifier|*
name|reverse_find
parameter_list|(
name|type
parameter_list|,
name|ptr
parameter_list|)
name|int
name|type
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
block|{
name|CELL
modifier|*
name|cp
decl_stmt|;
name|ARRAY
name|array
decl_stmt|;
specifier|static
name|char
name|uk
index|[]
init|=
literal|"unknown"
decl_stmt|;
name|int
name|i
decl_stmt|;
name|HASHNODE
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ST_VAR
case|:
case|case
name|ST_FIELD
case|:
name|cp
operator|=
operator|*
operator|(
name|CELL
operator|*
operator|*
operator|)
name|ptr
expr_stmt|;
break|break ;
case|case
name|ST_ARRAY
case|:
name|array
operator|=
operator|*
operator|(
name|ARRAY
operator|*
operator|)
name|ptr
expr_stmt|;
break|break ;
default|default :
return|return
name|uk
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASH_PRIME
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|hash_table
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|symtab
operator|.
name|type
operator|==
name|type
condition|)
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ST_VAR
case|:
case|case
name|ST_FIELD
case|:
if|if
condition|(
name|cp
operator|==
name|p
operator|->
name|symtab
operator|.
name|stval
operator|.
name|cp
condition|)
return|return
name|p
operator|->
name|symtab
operator|.
name|name
return|;
break|break ;
case|case
name|ST_ARRAY
case|:
if|if
condition|(
name|array
operator|==
name|p
operator|->
name|symtab
operator|.
name|stval
operator|.
name|array
condition|)
return|return
name|p
operator|->
name|symtab
operator|.
name|name
return|;
break|break ;
block|}
name|p
operator|=
name|p
operator|->
name|link
expr_stmt|;
block|}
block|}
return|return
name|uk
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

