begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************** bi_funct.c copyright 1991, Michael D. Brennan  This is a source file for mawk, an implementation of the AWK programming language.  Mawk is distributed without warranty under the terms of the GNU General Public License, version 2, 1991. ********************************************/
end_comment

begin_comment
comment|/* $Log:	bi_funct.c,v $  * Revision 5.1  91/12/05  07:55:35  brennan  * 1.1 pre-release  *  */
end_comment

begin_include
include|#
directive|include
file|"mawk.h"
end_include

begin_include
include|#
directive|include
file|"bi_funct.h"
end_include

begin_include
include|#
directive|include
file|"bi_vars.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_include
include|#
directive|include
file|"init.h"
end_include

begin_include
include|#
directive|include
file|"files.h"
end_include

begin_include
include|#
directive|include
file|"fin.h"
end_include

begin_include
include|#
directive|include
file|"field.h"
end_include

begin_include
include|#
directive|include
file|"regexp.h"
end_include

begin_include
include|#
directive|include
file|"repl.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_comment
comment|/* statics */
end_comment

begin_decl_stmt
specifier|static
name|STRING
modifier|*
name|PROTO
argument_list|(
name|gsub
argument_list|,
operator|(
name|PTR
operator|,
name|CELL
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|fplib_err
argument_list|,
operator|(
name|char
operator|*
operator|,
name|double
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global for the disassembler */
end_comment

begin_decl_stmt
name|BI_REC
name|bi_funct
index|[]
init|=
block|{
comment|/* info to load builtins */
literal|"index"
block|,
name|bi_index
block|,
literal|2
block|,
literal|2
block|,
literal|"substr"
block|,
name|bi_substr
block|,
literal|2
block|,
literal|3
block|,
literal|"length"
block|,
name|bi_length
block|,
literal|0
block|,
literal|1
block|,
literal|"sprintf"
block|,
name|bi_sprintf
block|,
literal|1
block|,
literal|255
block|,
literal|"sin"
block|,
name|bi_sin
block|,
literal|1
block|,
literal|1
block|,
literal|"cos"
block|,
name|bi_cos
block|,
literal|1
block|,
literal|1
block|,
literal|"atan2"
block|,
name|bi_atan2
block|,
literal|2
block|,
literal|2
block|,
literal|"exp"
block|,
name|bi_exp
block|,
literal|1
block|,
literal|1
block|,
literal|"log"
block|,
name|bi_log
block|,
literal|1
block|,
literal|1
block|,
literal|"int"
block|,
name|bi_int
block|,
literal|1
block|,
literal|1
block|,
literal|"sqrt"
block|,
name|bi_sqrt
block|,
literal|1
block|,
literal|1
block|,
literal|"rand"
block|,
name|bi_rand
block|,
literal|0
block|,
literal|0
block|,
literal|"srand"
block|,
name|bi_srand
block|,
literal|0
block|,
literal|1
block|,
literal|"close"
block|,
name|bi_close
block|,
literal|1
block|,
literal|1
block|,
literal|"system"
block|,
name|bi_system
block|,
literal|1
block|,
literal|1
block|,
literal|"toupper"
block|,
name|bi_toupper
block|,
literal|1
block|,
literal|1
block|,
literal|"tolower"
block|,
name|bi_tolower
block|,
literal|1
block|,
literal|1
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|,
operator|(
name|PF_CP
operator|)
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|bi_funct_init
parameter_list|()
block|{
specifier|register
name|BI_REC
modifier|*
name|p
init|=
name|bi_funct
decl_stmt|;
specifier|register
name|SYMTAB
modifier|*
name|stp
decl_stmt|;
while|while
condition|(
name|p
operator|->
name|name
condition|)
block|{
name|stp
operator|=
name|insert
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|stp
operator|->
name|type
operator|=
name|ST_BUILTIN
expr_stmt|;
name|stp
operator|->
name|stval
operator|.
name|bip
operator|=
name|p
operator|++
expr_stmt|;
block|}
comment|/* seed rand() off the clock */
block|{
name|CELL
name|c
decl_stmt|;
name|c
operator|.
name|type
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|bi_srand
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**************************************************  string builtins (except split (in split.c) and [g]sub (at end))  **************************************************/
end_comment

begin_function
name|CELL
modifier|*
name|bi_length
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
name|unsigned
name|len
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|==
literal|0
condition|)
name|cellcpy
argument_list|(
name|sp
argument_list|,
name|field
argument_list|)
expr_stmt|;
else|else
name|sp
operator|--
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|len
operator|=
name|string
argument_list|(
name|sp
argument_list|)
operator|->
name|len
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
operator|(
name|double
operator|)
name|len
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|str_str
parameter_list|(
name|target
parameter_list|,
name|key
parameter_list|,
name|key_len
parameter_list|)
specifier|register
name|char
modifier|*
name|target
decl_stmt|,
decl|*
name|key
decl_stmt|;
end_function

begin_decl_stmt
name|unsigned
name|key_len
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|key_len
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
case|case
literal|1
case|:
return|return
name|strchr
argument_list|(
name|target
argument_list|,
operator|*
name|key
argument_list|)
return|;
case|case
literal|2
case|:
while|while
condition|(
name|target
operator|=
name|strchr
argument_list|(
name|target
argument_list|,
operator|*
name|key
argument_list|)
condition|)
if|if
condition|(
name|target
index|[
literal|1
index|]
operator|==
name|key
index|[
literal|1
index|]
condition|)
return|return
name|target
return|;
else|else
name|target
operator|++
expr_stmt|;
comment|/*failed*/
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
name|key_len
operator|--
expr_stmt|;
while|while
condition|(
name|target
operator|=
name|strchr
argument_list|(
name|target
argument_list|,
operator|*
name|key
argument_list|)
condition|)
if|if
condition|(
name|memcmp
argument_list|(
name|target
operator|+
literal|1
argument_list|,
name|key
operator|+
literal|1
argument_list|,
name|SIZE_T
argument_list|(
name|key_len
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|target
return|;
else|else
name|target
operator|++
expr_stmt|;
comment|/*failed*/
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
end_block

begin_function
name|CELL
modifier|*
name|bi_index
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
specifier|register
name|int
name|idx
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|sp
operator|--
expr_stmt|;
if|if
condition|(
name|TEST2
argument_list|(
name|sp
argument_list|)
operator|!=
name|TWO_STRINGS
condition|)
name|cast2_to_s
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|=
name|string
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
operator|->
name|len
condition|)
name|idx
operator|=
operator|(
name|p
operator|=
name|str_str
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
operator|->
name|str
argument_list|,
name|string
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
operator|->
name|str
argument_list|,
name|len
argument_list|)
operator|)
condition|?
name|p
operator|-
name|string
argument_list|(
name|sp
argument_list|)
operator|->
name|str
operator|+
literal|1
else|:
literal|0
expr_stmt|;
else|else
comment|/* index of the empty string */
name|idx
operator|=
literal|1
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
operator|(
name|double
operator|)
name|idx
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/*  substr(s, i, n)     if l = length(s)     then get the characters     from  max(1,i) to min(l,n-i-1) inclusive */
end_comment

begin_function
name|CELL
modifier|*
name|bi_substr
parameter_list|(
name|sp
parameter_list|)
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
name|int
name|n_args
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|STRING
modifier|*
name|sval
decl_stmt|;
comment|/* substr(sval->str, i, n) */
name|n_args
operator|=
name|sp
operator|->
name|type
expr_stmt|;
name|sp
operator|-=
name|n_args
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* don't use< C_STRING shortcut */
name|sval
operator|=
name|string
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|sval
operator|->
name|len
operator|)
operator|==
literal|0
condition|)
comment|/* substr on null string */
block|{
if|if
condition|(
name|n_args
operator|==
literal|3
condition|)
name|cell_destroy
argument_list|(
name|sp
operator|+
literal|2
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
if|if
condition|(
name|n_args
operator|==
literal|2
condition|)
block|{
name|n
operator|=
name|MAX__INT
expr_stmt|;
if|if
condition|(
name|sp
index|[
literal|1
index|]
operator|.
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TEST2
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
operator|!=
name|TWO_DOUBLES
condition|)
name|cast2_to_d
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|int
operator|)
name|sp
index|[
literal|2
index|]
operator|.
name|dval
expr_stmt|;
block|}
name|i
operator|=
operator|(
name|int
operator|)
name|sp
index|[
literal|1
index|]
operator|.
name|dval
operator|-
literal|1
expr_stmt|;
comment|/* i now indexes into string */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|n
operator|+=
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
name|len
operator|-
name|i
condition|)
name|n
operator|=
name|len
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
comment|/* the null string */
block|{
name|sp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
operator|&
name|null_str
expr_stmt|;
name|null_str
operator|.
name|ref_cnt
operator|++
expr_stmt|;
block|}
else|else
comment|/* got something */
block|{
name|sp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
operator|->
name|str
argument_list|,
name|sval
operator|->
name|str
operator|+
name|i
argument_list|,
name|SIZE_T
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free_STRING
argument_list|(
name|sval
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/*   match(s,r)   sp[0] holds r, sp[-1] holds s */
end_comment

begin_function
name|CELL
modifier|*
name|bi_match
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_RE
condition|)
name|cast_to_RE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|--
name|sp
operator|)
operator|->
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|RSTART
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|RLENGTH
argument_list|)
expr_stmt|;
name|RSTART
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|RLENGTH
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|p
operator|=
name|REmatch
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
operator|->
name|str
argument_list|,
operator|(
name|sp
operator|+
literal|1
operator|)
operator|->
name|ptr
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|sp
operator|->
name|dval
operator|=
call|(
name|double
call|)
argument_list|(
name|p
operator|-
name|string
argument_list|(
name|sp
argument_list|)
operator|->
name|str
operator|+
literal|1
argument_list|)
expr_stmt|;
name|RLENGTH
operator|->
name|dval
operator|=
operator|(
name|double
operator|)
name|length
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|dval
operator|=
literal|0.0
expr_stmt|;
name|RLENGTH
operator|->
name|dval
operator|=
operator|-
literal|1.0
expr_stmt|;
comment|/* posix */
block|}
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|RSTART
operator|->
name|dval
operator|=
name|sp
operator|->
name|dval
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
name|CELL
modifier|*
name|bi_toupper
parameter_list|(
name|sp
parameter_list|)
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
name|STRING
modifier|*
name|old
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|old
operator|=
name|string
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|old
operator|->
name|len
argument_list|)
expr_stmt|;
name|q
operator|=
name|string
argument_list|(
name|sp
argument_list|)
operator|->
name|str
expr_stmt|;
name|p
operator|=
name|old
operator|->
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
operator|*
name|q
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|>=
literal|'a'
operator|&&
operator|*
name|q
operator|<=
literal|'z'
condition|)
operator|*
name|q
operator|+=
literal|'A'
operator|-
literal|'a'
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
name|free_STRING
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
name|CELL
modifier|*
name|bi_tolower
parameter_list|(
name|sp
parameter_list|)
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
name|STRING
modifier|*
name|old
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|old
operator|=
name|string
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|old
operator|->
name|len
argument_list|)
expr_stmt|;
name|q
operator|=
name|string
argument_list|(
name|sp
argument_list|)
operator|->
name|str
expr_stmt|;
name|p
operator|=
name|old
operator|->
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
operator|*
name|q
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|>=
literal|'A'
operator|&&
operator|*
name|q
operator|<=
literal|'Z'
condition|)
operator|*
name|q
operator|+=
literal|'a'
operator|-
literal|'A'
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
name|free_STRING
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/************************************************   arithemetic builtins  ************************************************/
end_comment

begin_function
specifier|static
name|void
name|fplib_err
parameter_list|(
name|fname
parameter_list|,
name|val
parameter_list|,
name|error
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|double
name|val
decl_stmt|;
name|char
modifier|*
name|error
decl_stmt|;
block|{
name|rt_error
argument_list|(
literal|"%s(%g) : %s"
argument_list|,
name|fname
argument_list|,
name|val
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|CELL
modifier|*
name|bi_sin
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|STDC_MATHERR
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|sin
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
else|#
directive|else
name|double
name|x
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|x
operator|=
name|sp
operator|->
name|dval
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|sin
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|fplib_err
argument_list|(
literal|"sin"
argument_list|,
name|x
argument_list|,
literal|"loss of precision"
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|CELL
modifier|*
name|bi_cos
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|STDC_MATHERR
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|cos
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
else|#
directive|else
name|double
name|x
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|x
operator|=
name|sp
operator|->
name|dval
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|cos
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|fplib_err
argument_list|(
literal|"cos"
argument_list|,
name|x
argument_list|,
literal|"loss of precision"
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|CELL
modifier|*
name|bi_atan2
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|STDC_MATHERR
name|sp
operator|--
expr_stmt|;
if|if
condition|(
name|TEST2
argument_list|(
name|sp
argument_list|)
operator|!=
name|TWO_DOUBLES
condition|)
name|cast2_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|atan2
argument_list|(
name|sp
operator|->
name|dval
argument_list|,
operator|(
name|sp
operator|+
literal|1
operator|)
operator|->
name|dval
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
else|#
directive|else
name|errno
operator|=
literal|0
expr_stmt|;
name|sp
operator|--
expr_stmt|;
if|if
condition|(
name|TEST2
argument_list|(
name|sp
argument_list|)
operator|!=
name|TWO_DOUBLES
condition|)
name|cast2_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|atan2
argument_list|(
name|sp
operator|->
name|dval
argument_list|,
operator|(
name|sp
operator|+
literal|1
operator|)
operator|->
name|dval
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|rt_error
argument_list|(
literal|"atan2(0,0) : domain error"
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|CELL
modifier|*
name|bi_log
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|STDC_MATHERR
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|log
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
else|#
directive|else
name|double
name|x
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|x
operator|=
name|sp
operator|->
name|dval
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|log
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|fplib_err
argument_list|(
literal|"log"
argument_list|,
name|x
argument_list|,
literal|"domain error"
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|CELL
modifier|*
name|bi_exp
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|STDC_MATHERR
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|exp
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
else|#
directive|else
name|double
name|x
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|x
operator|=
name|sp
operator|->
name|dval
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|exp
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|&&
name|sp
operator|->
name|dval
condition|)
name|fplib_err
argument_list|(
literal|"exp"
argument_list|,
name|x
argument_list|,
literal|"overflow"
argument_list|)
expr_stmt|;
comment|/* on underflow sp->dval==0, ignore */
return|return
name|sp
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|CELL
modifier|*
name|bi_int
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|sp
operator|->
name|dval
operator|>=
literal|0.0
condition|?
name|floor
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
else|:
name|ceil
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
name|CELL
modifier|*
name|bi_sqrt
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|STDC_MATHERR
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|sqrt
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
else|#
directive|else
name|double
name|x
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|x
operator|=
name|sp
operator|->
name|dval
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|sqrt
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|fplib_err
argument_list|(
literal|"sqrt"
argument_list|,
name|x
argument_list|,
literal|"domain error"
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__TURBOC__
end_ifdef

begin_function_decl
name|long
name|biostime
parameter_list|(
name|int
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|time
parameter_list|(
name|x
parameter_list|)
value|biostime(0,0L)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|THINK_C
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For portability, we'll use our own random number generator , taken    from:  Park, SK and Miller KW, "Random Number Generators:    Good Ones are Hard to Find", CACM, 31, 1192-1201, 1988. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|seed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* must be>=1 and<= 2^31-1 */
end_comment

begin_decl_stmt
specifier|static
name|CELL
name|cseed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* argument of last call to srand() */
end_comment

begin_define
define|#
directive|define
name|M
value|0x7fffffff
end_define

begin_comment
comment|/* 2^31-1 */
end_comment

begin_function
name|CELL
modifier|*
name|bi_srand
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
name|CELL
name|c
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|==
literal|0
condition|)
comment|/* seed off clock */
block|{
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|sp
argument_list|,
operator|&
name|cseed
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
operator|&
name|cseed
argument_list|)
expr_stmt|;
name|cseed
operator|.
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|cseed
operator|.
name|dval
operator|=
operator|(
name|double
operator|)
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* user seed */
block|{
name|sp
operator|--
expr_stmt|;
comment|/* swap cseed and *sp ; don't need to adjust ref_cnts */
name|c
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
name|sp
operator|=
name|cseed
expr_stmt|;
name|cseed
operator|=
name|c
expr_stmt|;
block|}
comment|/* The old seed is now in *sp ; move the value in cseed to      seed in range 1 to M */
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
operator|&
name|c
argument_list|,
operator|&
name|cseed
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|.
name|type
operator|==
name|C_NOINIT
condition|)
name|cast1_to_d
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|seed
operator|=
name|c
operator|.
name|type
operator|==
name|C_DOUBLE
condition|?
operator|(
operator|(
name|int
operator|)
name|c
operator|.
name|dval
operator|&
name|M
operator|)
operator|%
name|M
operator|+
literal|1
else|:
name|hash
argument_list|(
name|string
argument_list|(
operator|&
name|c
argument_list|)
operator|->
name|str
argument_list|)
operator|%
name|M
operator|+
literal|1
expr_stmt|;
name|cell_destroy
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
comment|/* crank it once so close seeds don't give a close         first result  */
define|#
directive|define
name|A
value|16807
define|#
directive|define
name|Q
value|127773
comment|/* M/A */
define|#
directive|define
name|R
value|2836
comment|/* M%A */
name|seed
operator|=
name|A
operator|*
operator|(
name|seed
operator|%
name|Q
operator|)
operator|-
name|R
operator|*
operator|(
name|seed
operator|/
name|Q
operator|)
expr_stmt|;
if|if
condition|(
name|seed
operator|<=
literal|0
condition|)
name|seed
operator|+=
name|M
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
name|CELL
modifier|*
name|bi_rand
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
specifier|register
name|long
name|test
decl_stmt|;
name|test
operator|=
name|A
operator|*
operator|(
name|seed
operator|%
name|Q
operator|)
operator|-
name|R
operator|*
operator|(
name|seed
operator|/
name|Q
operator|)
expr_stmt|;
if|if
condition|(
name|test
operator|<=
literal|0
condition|)
name|test
operator|+=
name|M
expr_stmt|;
operator|(
operator|++
name|sp
operator|)
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
call|(
name|double
call|)
argument_list|(
name|seed
operator|=
name|test
argument_list|)
operator|/
operator|(
name|double
operator|)
name|M
expr_stmt|;
return|return
name|sp
return|;
undef|#
directive|undef
name|A
undef|#
directive|undef
name|M
undef|#
directive|undef
name|Q
undef|#
directive|undef
name|R
block|}
end_function

begin_comment
comment|/*************************************************  miscellaneous builtins  close, system and getline  *************************************************/
end_comment

begin_function
name|CELL
modifier|*
name|bi_close
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|x
operator|=
name|file_close
argument_list|(
operator|(
name|STRING
operator|*
operator|)
name|sp
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
operator|(
name|double
operator|)
name|x
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_if
if|#
directive|if
name|HAVE_REAL_PIPES
end_if

begin_function
name|CELL
modifier|*
name|bi_system
parameter_list|(
name|sp
parameter_list|)
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|unsigned
name|ret_val
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* fork failed */
name|errmsg
argument_list|(
name|errno
argument_list|,
literal|"could not create a new process"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
literal|127
expr_stmt|;
break|break ;
case|case
literal|0
case|:
comment|/* the child */
operator|(
name|void
operator|)
name|execl
argument_list|(
name|shell
argument_list|,
name|shell
argument_list|,
literal|"-c"
argument_list|,
name|string
argument_list|(
name|sp
argument_list|)
operator|->
name|str
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* if get here, execl() failed */
name|errmsg
argument_list|(
name|errno
argument_list|,
literal|"execute of %s failed"
argument_list|,
name|shell
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
default|default   :
comment|/* wait for the child */
name|ret_val
operator|=
name|wait_for
argument_list|(
name|pid
argument_list|)
expr_stmt|;
break|break ;
block|}
name|cell_destroy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
operator|(
name|double
operator|)
name|ret_val
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_REAL_PIPES */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|THINK_C
end_ifdef

begin_function
name|CELL
modifier|*
name|bi_system
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
name|rt_error
argument_list|(
literal|"no system call for the Macintosh Toy Operating System!!!"
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|MSDOS
end_if

begin_function
name|CELL
modifier|*
name|bi_system
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|retval
operator|=
name|DOSexec
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
operator|->
name|str
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
operator|(
name|double
operator|)
name|retval
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  getline()  */
end_comment

begin_comment
comment|/*  if type == 0 :  stack is 0 , target address      if type == F_IN : stack is F_IN, expr(filename), target address      if type == PIPE_IN : stack is PIPE_IN, target address, expr(pipename) */
end_comment

begin_function
name|CELL
modifier|*
name|bi_getline
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
name|CELL
name|tc
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|FIN
modifier|*
name|fin_p
decl_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|type
condition|)
block|{
case|case
literal|0
case|:
name|sp
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|main_fin
condition|)
name|open_main
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|FINgets
argument_list|(
name|main_fin
argument_list|,
operator|&
name|len
argument_list|)
operator|)
condition|)
goto|goto
name|eof
goto|;
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
name|sp
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
name|TEST2
argument_list|(
name|NR
argument_list|)
operator|!=
name|TWO_DOUBLES
condition|)
name|cast2_to_d
argument_list|(
name|NR
argument_list|)
expr_stmt|;
name|NR
operator|->
name|dval
operator|+=
literal|1.0
expr_stmt|;
name|FNR
operator|->
name|dval
operator|+=
literal|1.0
expr_stmt|;
break|break ;
case|case
name|F_IN
case|:
name|sp
operator|--
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|fin_p
operator|=
operator|(
name|FIN
operator|*
operator|)
name|file_find
argument_list|(
name|sp
operator|->
name|ptr
argument_list|,
name|F_IN
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|fin_p
condition|)
goto|goto
name|open_failure
goto|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|FINgets
argument_list|(
name|fin_p
argument_list|,
operator|&
name|len
argument_list|)
operator|)
condition|)
block|{
name|FINsemi_close
argument_list|(
name|fin_p
argument_list|)
expr_stmt|;
goto|goto
name|eof
goto|;
block|}
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
name|sp
operator|->
name|ptr
expr_stmt|;
break|break ;
case|case
name|PIPE_IN
case|:
name|sp
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|fin_p
operator|=
operator|(
name|FIN
operator|*
operator|)
name|file_find
argument_list|(
name|sp
operator|->
name|ptr
argument_list|,
name|PIPE_IN
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fin_p
condition|)
goto|goto
name|open_failure
goto|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|FINgets
argument_list|(
name|fin_p
argument_list|,
operator|&
name|len
argument_list|)
operator|)
condition|)
block|{
name|FINsemi_close
argument_list|(
name|fin_p
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_REAL_PIPES
comment|/* reclaim process slot */
operator|(
name|void
operator|)
name|wait_for
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|eof
goto|;
block|}
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
operator|(
name|sp
operator|+
literal|1
operator|)
operator|->
name|ptr
expr_stmt|;
break|break ;
default|default :
name|bozo
argument_list|(
literal|"type in bi_getline"
argument_list|)
expr_stmt|;
block|}
comment|/* we've read a line , store it */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|tc
operator|.
name|type
operator|=
name|C_STRING
expr_stmt|;
name|tc
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
operator|&
name|null_str
expr_stmt|;
name|null_str
operator|.
name|ref_cnt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|tc
operator|.
name|type
operator|=
name|C_MBSTRN
expr_stmt|;
name|tc
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|string
argument_list|(
operator|&
name|tc
argument_list|)
operator|->
name|str
argument_list|,
name|p
argument_list|,
name|SIZE_T
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|slow_cell_assign
argument_list|(
name|cp
argument_list|,
operator|&
name|tc
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
operator|&
name|tc
argument_list|)
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
literal|1.0
expr_stmt|;
goto|goto
name|done
goto|;
name|open_failure
label|:
name|sp
operator|->
name|dval
operator|=
operator|-
literal|1.0
expr_stmt|;
goto|goto
name|done
goto|;
name|eof
label|:
name|sp
operator|->
name|dval
operator|=
literal|0.0
expr_stmt|;
comment|/* fall thru to done  */
name|done
label|:
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/**********************************************  sub() and gsub()  **********************************************/
end_comment

begin_comment
comment|/* entry:  sp[0] = address of CELL to sub on            sp[-1] = substitution CELL            sp[-2] = regular expression to match */
end_comment

begin_function
name|CELL
modifier|*
name|bi_sub
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
name|CELL
modifier|*
name|cp
decl_stmt|;
comment|/* pointer to the replacement target */
name|CELL
name|tc
decl_stmt|;
comment|/* build the new string here */
name|CELL
name|sc
decl_stmt|;
comment|/* copy of the target CELL */
name|char
modifier|*
name|front
decl_stmt|,
modifier|*
name|middle
decl_stmt|,
modifier|*
name|back
decl_stmt|;
comment|/* pieces */
name|unsigned
name|front_len
decl_stmt|,
name|middle_len
decl_stmt|,
name|back_len
decl_stmt|;
name|sp
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_RE
condition|)
name|cast_to_RE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
index|[
literal|1
index|]
operator|.
name|type
operator|!=
name|C_REPL
operator|&&
name|sp
index|[
literal|1
index|]
operator|.
name|type
operator|!=
name|C_REPLV
condition|)
name|cast_to_REPL
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
operator|(
name|sp
operator|+
literal|2
operator|)
operator|->
name|ptr
expr_stmt|;
comment|/* make a copy of the target, because we won't change anything      including type unless the match works */
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
operator|&
name|sc
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|.
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
operator|&
name|sc
argument_list|)
expr_stmt|;
name|front
operator|=
name|string
argument_list|(
operator|&
name|sc
argument_list|)
operator|->
name|str
expr_stmt|;
if|if
condition|(
name|middle
operator|=
name|REmatch
argument_list|(
name|front
argument_list|,
name|sp
operator|->
name|ptr
argument_list|,
operator|&
name|middle_len
argument_list|)
condition|)
block|{
name|front_len
operator|=
name|middle
operator|-
name|front
expr_stmt|;
name|back
operator|=
name|middle
operator|+
name|middle_len
expr_stmt|;
name|back_len
operator|=
name|string
argument_list|(
operator|&
name|sc
argument_list|)
operator|->
name|len
operator|-
name|front_len
operator|-
name|middle_len
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|+
literal|1
operator|)
operator|->
name|type
operator|==
name|C_REPLV
condition|)
block|{
name|STRING
modifier|*
name|sval
init|=
name|new_STRING
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|middle_len
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|sval
operator|->
name|str
argument_list|,
name|middle
argument_list|,
name|SIZE_T
argument_list|(
name|middle_len
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|replv_to_repl
argument_list|(
name|sp
operator|+
literal|1
argument_list|,
name|sval
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|sval
argument_list|)
expr_stmt|;
block|}
name|tc
operator|.
name|type
operator|=
name|C_STRING
expr_stmt|;
name|tc
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|front_len
operator|+
name|string
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
operator|->
name|len
operator|+
name|back_len
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|string
argument_list|(
operator|&
name|tc
argument_list|)
operator|->
name|str
decl_stmt|;
if|if
condition|(
name|front_len
condition|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|p
argument_list|,
name|front
argument_list|,
name|SIZE_T
argument_list|(
name|front_len
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|front_len
expr_stmt|;
block|}
if|if
condition|(
name|string
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
operator|->
name|len
condition|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|p
argument_list|,
name|string
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
operator|->
name|str
argument_list|,
name|SIZE_T
argument_list|(
name|string
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|string
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
operator|->
name|len
expr_stmt|;
block|}
if|if
condition|(
name|back_len
condition|)
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|p
argument_list|,
name|back
argument_list|,
name|SIZE_T
argument_list|(
name|back_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|slow_cell_assign
argument_list|(
name|cp
argument_list|,
operator|&
name|tc
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
operator|&
name|tc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free_STRING
argument_list|(
name|string
argument_list|(
operator|&
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|repl_destroy
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|middle
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|unsigned
name|repl_cnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of global replacements */
end_comment

begin_comment
comment|/* recursive global subsitution     dealing with empty matches makes this mildly painful */
end_comment

begin_function
specifier|static
name|STRING
modifier|*
name|gsub
parameter_list|(
name|re
parameter_list|,
name|repl
parameter_list|,
name|target
parameter_list|,
name|flag
parameter_list|)
name|PTR
name|re
decl_stmt|;
name|CELL
modifier|*
name|repl
decl_stmt|;
comment|/* always of type REPL or REPLV,         destroyed by caller */
name|char
modifier|*
name|target
decl_stmt|;
name|int
name|flag
decl_stmt|;
comment|/* if on, match of empty string at front is OK */
block|{
name|char
modifier|*
name|front
decl_stmt|,
modifier|*
name|middle
decl_stmt|;
name|STRING
modifier|*
name|back
decl_stmt|;
name|unsigned
name|front_len
decl_stmt|,
name|middle_len
decl_stmt|;
name|STRING
modifier|*
name|ret_val
decl_stmt|;
name|CELL
name|xrepl
decl_stmt|;
comment|/* a copy of repl so we can change repl */
if|if
condition|(
operator|!
operator|(
name|middle
operator|=
name|REmatch
argument_list|(
name|target
argument_list|,
name|re
argument_list|,
operator|&
name|middle_len
argument_list|)
operator|)
condition|)
return|return
name|new_STRING
argument_list|(
name|target
argument_list|)
return|;
comment|/* no match */
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
operator|&
name|xrepl
argument_list|,
name|repl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag
operator|&&
name|middle_len
operator|==
literal|0
operator|&&
name|middle
operator|==
name|target
condition|)
block|{
comment|/* match at front that's not allowed */
if|if
condition|(
operator|*
name|target
operator|==
literal|0
condition|)
comment|/* target is empty string */
block|{
name|repl_destroy
argument_list|(
operator|&
name|xrepl
argument_list|)
expr_stmt|;
name|null_str
operator|.
name|ref_cnt
operator|++
expr_stmt|;
return|return
operator|&
name|null_str
return|;
block|}
else|else
block|{
name|char
name|xbuff
index|[
literal|2
index|]
decl_stmt|;
name|front_len
operator|=
literal|0
expr_stmt|;
comment|/* make new repl with target[0] */
name|repl_destroy
argument_list|(
name|repl
argument_list|)
expr_stmt|;
name|xbuff
index|[
literal|0
index|]
operator|=
operator|*
name|target
operator|++
expr_stmt|;
name|xbuff
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|repl
operator|->
name|type
operator|=
name|C_REPL
expr_stmt|;
name|repl
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
name|xbuff
argument_list|)
expr_stmt|;
name|back
operator|=
name|gsub
argument_list|(
name|re
argument_list|,
operator|&
name|xrepl
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* a match that counts */
block|{
name|repl_cnt
operator|++
expr_stmt|;
name|front
operator|=
name|target
expr_stmt|;
name|front_len
operator|=
name|middle
operator|-
name|target
expr_stmt|;
if|if
condition|(
operator|*
name|middle
operator|==
literal|0
condition|)
comment|/* matched back of target */
block|{
name|back
operator|=
operator|&
name|null_str
expr_stmt|;
name|null_str
operator|.
name|ref_cnt
operator|++
expr_stmt|;
block|}
else|else
name|back
operator|=
name|gsub
argument_list|(
name|re
argument_list|,
operator|&
name|xrepl
argument_list|,
name|middle
operator|+
name|middle_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* patch the&'s if needed */
if|if
condition|(
name|repl
operator|->
name|type
operator|==
name|C_REPLV
condition|)
block|{
name|STRING
modifier|*
name|sval
init|=
name|new_STRING
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|middle_len
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|sval
operator|->
name|str
argument_list|,
name|middle
argument_list|,
name|SIZE_T
argument_list|(
name|middle_len
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|replv_to_repl
argument_list|(
name|repl
argument_list|,
name|sval
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|sval
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* put the three pieces together */
name|ret_val
operator|=
name|new_STRING
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|front_len
operator|+
name|string
argument_list|(
name|repl
argument_list|)
operator|->
name|len
operator|+
name|back
operator|->
name|len
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|ret_val
operator|->
name|str
decl_stmt|;
if|if
condition|(
name|front_len
condition|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|p
argument_list|,
name|front
argument_list|,
name|SIZE_T
argument_list|(
name|front_len
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|front_len
expr_stmt|;
block|}
if|if
condition|(
name|string
argument_list|(
name|repl
argument_list|)
operator|->
name|len
condition|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|p
argument_list|,
name|string
argument_list|(
name|repl
argument_list|)
operator|->
name|str
argument_list|,
name|SIZE_T
argument_list|(
name|string
argument_list|(
name|repl
argument_list|)
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|string
argument_list|(
name|repl
argument_list|)
operator|->
name|len
expr_stmt|;
block|}
if|if
condition|(
name|back
operator|->
name|len
condition|)
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|p
argument_list|,
name|back
operator|->
name|str
argument_list|,
name|SIZE_T
argument_list|(
name|back
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* cleanup, repl is freed by the caller */
name|repl_destroy
argument_list|(
operator|&
name|xrepl
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|back
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/* set up for call to gsub() */
end_comment

begin_function
name|CELL
modifier|*
name|bi_gsub
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
block|{
name|CELL
modifier|*
name|cp
decl_stmt|;
comment|/* pts at the replacement target */
name|CELL
name|sc
decl_stmt|;
comment|/* copy of replacement target */
name|CELL
name|tc
decl_stmt|;
comment|/* build the result here */
name|sp
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_RE
condition|)
name|cast_to_RE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|+
literal|1
operator|)
operator|->
name|type
operator|!=
name|C_REPL
operator|&&
operator|(
name|sp
operator|+
literal|1
operator|)
operator|->
name|type
operator|!=
name|C_REPLV
condition|)
name|cast_to_REPL
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
operator|&
name|sc
argument_list|,
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
operator|(
name|sp
operator|+
literal|2
operator|)
operator|->
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|.
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
operator|&
name|sc
argument_list|)
expr_stmt|;
name|repl_cnt
operator|=
literal|0
expr_stmt|;
name|tc
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|gsub
argument_list|(
name|sp
operator|->
name|ptr
argument_list|,
name|sp
operator|+
literal|1
argument_list|,
name|string
argument_list|(
operator|&
name|sc
argument_list|)
operator|->
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|repl_cnt
condition|)
block|{
name|tc
operator|.
name|type
operator|=
name|C_STRING
expr_stmt|;
name|slow_cell_assign
argument_list|(
name|cp
argument_list|,
operator|&
name|tc
argument_list|)
expr_stmt|;
block|}
comment|/* cleanup */
name|free_STRING
argument_list|(
name|string
argument_list|(
operator|&
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
operator|&
name|tc
argument_list|)
argument_list|)
expr_stmt|;
name|repl_destroy
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
operator|(
name|double
operator|)
name|repl_cnt
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

end_unit

