begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************** fcall.c copyright 1991, Michael D. Brennan  This is a source file for mawk, an implementation of the AWK programming language.  Mawk is distributed without warranty under the terms of the GNU General Public License, version 2, 1991. ********************************************/
end_comment

begin_comment
comment|/*$Log:	fcall.c,v $  * Revision 5.1  91/12/05  07:55:54  brennan  * 1.1 pre-release  *  */
end_comment

begin_include
include|#
directive|include
file|"mawk.h"
end_include

begin_include
include|#
directive|include
file|"symtype.h"
end_include

begin_include
include|#
directive|include
file|"code.h"
end_include

begin_comment
comment|/* This file has functions involved with type checking of    function calls */
end_comment

begin_decl_stmt
specifier|static
name|FCALL_REC
modifier|*
name|PROTO
argument_list|(
name|first_pass
argument_list|,
operator|(
name|FCALL_REC
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CA_REC
modifier|*
name|PROTO
argument_list|(
name|call_arg_check
argument_list|,
operator|(
name|FBLOCK
operator|*
operator|,
name|CA_REC
operator|*
operator|,
name|INST
operator|*
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PROTO
argument_list|(
name|arg_cnt_ok
argument_list|,
operator|(
name|FBLOCK
operator|*
operator|,
name|CA_REC
operator|*
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_progress
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag that indicates call_arg_check() was able to type        check some call arguments */
end_comment

begin_comment
comment|/* type checks a list of call arguments,    returns a list of arguments whose type is still unknown */
end_comment

begin_function
specifier|static
name|CA_REC
modifier|*
name|call_arg_check
parameter_list|(
name|callee
parameter_list|,
name|entry_list
parameter_list|,
name|start
parameter_list|,
name|line_no
parameter_list|)
name|FBLOCK
modifier|*
name|callee
decl_stmt|;
name|CA_REC
modifier|*
name|entry_list
decl_stmt|;
name|INST
modifier|*
name|start
decl_stmt|;
comment|/* to locate patch */
name|unsigned
name|line_no
decl_stmt|;
comment|/* for error messages */
block|{
specifier|register
name|CA_REC
modifier|*
name|q
decl_stmt|;
name|CA_REC
modifier|*
name|exit_list
init|=
operator|(
name|CA_REC
operator|*
operator|)
literal|0
decl_stmt|;
name|check_progress
operator|=
literal|0
expr_stmt|;
comment|/* loop :        take q off entry_list        test it            if OK  zfree(q)  else put on exit_list   */
while|while
condition|(
name|q
operator|=
name|entry_list
condition|)
block|{
name|entry_list
operator|=
name|q
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|type
operator|==
name|ST_NONE
condition|)
block|{
comment|/* try to infer the type */
comment|/* it might now be in symbol table */
if|if
condition|(
name|q
operator|->
name|sym_p
operator|->
name|type
operator|==
name|ST_VAR
condition|)
block|{
comment|/* set type and patch */
name|q
operator|->
name|type
operator|=
name|CA_EXPR
expr_stmt|;
name|start
index|[
name|q
operator|->
name|call_offset
operator|+
literal|1
index|]
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|q
operator|->
name|sym_p
operator|->
name|stval
operator|.
name|cp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|sym_p
operator|->
name|type
operator|==
name|ST_ARRAY
condition|)
block|{
name|q
operator|->
name|type
operator|=
name|CA_ARRAY
expr_stmt|;
name|start
index|[
name|q
operator|->
name|call_offset
index|]
operator|.
name|op
operator|=
name|A_PUSHA
expr_stmt|;
name|start
index|[
name|q
operator|->
name|call_offset
operator|+
literal|1
index|]
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|q
operator|->
name|sym_p
operator|->
name|stval
operator|.
name|array
expr_stmt|;
block|}
else|else
comment|/* try to infer from callee */
block|{
switch|switch
condition|(
name|callee
operator|->
name|typev
index|[
name|q
operator|->
name|arg_num
index|]
condition|)
block|{
case|case
name|ST_LOCAL_VAR
case|:
name|q
operator|->
name|type
operator|=
name|CA_EXPR
expr_stmt|;
name|q
operator|->
name|sym_p
operator|->
name|type
operator|=
name|ST_VAR
expr_stmt|;
name|q
operator|->
name|sym_p
operator|->
name|stval
operator|.
name|cp
operator|=
name|new_CELL
argument_list|()
expr_stmt|;
name|q
operator|->
name|sym_p
operator|->
name|stval
operator|.
name|cp
operator|->
name|type
operator|=
name|C_NOINIT
expr_stmt|;
name|start
index|[
name|q
operator|->
name|call_offset
operator|+
literal|1
index|]
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|q
operator|->
name|sym_p
operator|->
name|stval
operator|.
name|cp
expr_stmt|;
break|break ;
case|case
name|ST_LOCAL_ARRAY
case|:
name|q
operator|->
name|type
operator|=
name|CA_ARRAY
expr_stmt|;
name|q
operator|->
name|sym_p
operator|->
name|type
operator|=
name|ST_ARRAY
expr_stmt|;
name|q
operator|->
name|sym_p
operator|->
name|stval
operator|.
name|array
operator|=
name|new_ARRAY
argument_list|()
expr_stmt|;
name|start
index|[
name|q
operator|->
name|call_offset
index|]
operator|.
name|op
operator|=
name|A_PUSHA
expr_stmt|;
name|start
index|[
name|q
operator|->
name|call_offset
operator|+
literal|1
index|]
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|q
operator|->
name|sym_p
operator|->
name|stval
operator|.
name|array
expr_stmt|;
break|break ;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|type
operator|==
name|ST_LOCAL_NONE
condition|)
block|{
comment|/* try to infer the type */
if|if
condition|(
operator|*
name|q
operator|->
name|type_p
operator|==
name|ST_LOCAL_VAR
condition|)
block|{
comment|/* set type , don't need to patch */
name|q
operator|->
name|type
operator|=
name|CA_EXPR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|q
operator|->
name|type_p
operator|==
name|ST_LOCAL_ARRAY
condition|)
block|{
name|q
operator|->
name|type
operator|=
name|CA_ARRAY
expr_stmt|;
name|start
index|[
name|q
operator|->
name|call_offset
index|]
operator|.
name|op
operator|=
name|LA_PUSHA
expr_stmt|;
comment|/* offset+1 op is OK */
block|}
else|else
comment|/* try to infer from callee */
block|{
switch|switch
condition|(
name|callee
operator|->
name|typev
index|[
name|q
operator|->
name|arg_num
index|]
condition|)
block|{
case|case
name|ST_LOCAL_VAR
case|:
name|q
operator|->
name|type
operator|=
name|CA_EXPR
expr_stmt|;
operator|*
name|q
operator|->
name|type_p
operator|=
name|ST_LOCAL_VAR
expr_stmt|;
comment|/* do not need to patch */
break|break ;
case|case
name|ST_LOCAL_ARRAY
case|:
name|q
operator|->
name|type
operator|=
name|CA_ARRAY
expr_stmt|;
operator|*
name|q
operator|->
name|type_p
operator|=
name|ST_LOCAL_ARRAY
expr_stmt|;
name|start
index|[
name|q
operator|->
name|call_offset
index|]
operator|.
name|op
operator|=
name|LA_PUSHA
expr_stmt|;
break|break ;
block|}
block|}
block|}
comment|/* if we still do not know the type put on the new list        else type check */
if|if
condition|(
name|q
operator|->
name|type
operator|==
name|ST_NONE
operator|||
name|q
operator|->
name|type
operator|==
name|ST_LOCAL_NONE
condition|)
block|{
name|q
operator|->
name|link
operator|=
name|exit_list
expr_stmt|;
name|exit_list
operator|=
name|q
expr_stmt|;
block|}
else|else
comment|/* type known */
block|{
if|if
condition|(
name|callee
operator|->
name|typev
index|[
name|q
operator|->
name|arg_num
index|]
operator|==
name|ST_LOCAL_NONE
condition|)
name|callee
operator|->
name|typev
index|[
name|q
operator|->
name|arg_num
index|]
operator|=
name|q
operator|->
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|->
name|type
operator|!=
name|callee
operator|->
name|typev
index|[
name|q
operator|->
name|arg_num
index|]
condition|)
block|{
name|errmsg
argument_list|(
literal|0
argument_list|,
literal|"line %u: type error in arg(%d) in call to %s"
argument_list|,
name|line_no
argument_list|,
name|q
operator|->
name|arg_num
operator|+
literal|1
argument_list|,
name|callee
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|compile_error_count
operator|==
name|MAX_COMPILE_ERRORS
condition|)
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|zfree
argument_list|(
name|q
argument_list|,
sizeof|sizeof
argument_list|(
name|CA_REC
argument_list|)
argument_list|)
expr_stmt|;
name|check_progress
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* while */
return|return
name|exit_list
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arg_cnt_ok
parameter_list|(
name|fbp
parameter_list|,
name|q
parameter_list|,
name|line_no
parameter_list|)
name|FBLOCK
modifier|*
name|fbp
decl_stmt|;
name|CA_REC
modifier|*
name|q
decl_stmt|;
name|unsigned
name|line_no
decl_stmt|;
block|{
if|if
condition|(
name|q
operator|->
name|arg_num
operator|>=
name|fbp
operator|->
name|nargs
condition|)
block|{
name|errmsg
argument_list|(
literal|0
argument_list|,
literal|"line %u: too many arguments in call to %s"
argument_list|,
name|line_no
argument_list|,
name|fbp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|compile_error_count
operator|==
name|MAX_COMPILE_ERRORS
condition|)
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
name|FCALL_REC
modifier|*
name|resolve_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function calls whose arg types need checking             are stored on this list */
end_comment

begin_comment
comment|/* on first pass thru the resolve list    we check :       if forward referenced functions were really defined       if right number of arguments    and compute call_start which is now known */
end_comment

begin_function
specifier|static
name|FCALL_REC
modifier|*
name|first_pass
parameter_list|(
name|p
parameter_list|)
specifier|register
name|FCALL_REC
modifier|*
name|p
decl_stmt|;
block|{
name|FCALL_REC
name|dummy
decl_stmt|;
specifier|register
name|FCALL_REC
modifier|*
name|q
init|=
operator|&
name|dummy
decl_stmt|;
comment|/* trails p */
name|q
operator|->
name|link
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|p
operator|->
name|callee
operator|->
name|code
condition|)
block|{
comment|/* callee never defined */
name|errmsg
argument_list|(
literal|0
argument_list|,
literal|"line %u: function %s never defined"
argument_list|,
name|p
operator|->
name|line_no
argument_list|,
name|p
operator|->
name|callee
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|compile_error_count
operator|==
name|MAX_COMPILE_ERRORS
condition|)
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* delete p from list */
name|q
operator|->
name|link
operator|=
name|p
operator|->
name|link
expr_stmt|;
comment|/* don't worry about freeing memory, we'll exit soon */
block|}
elseif|else
comment|/* note p->arg_list starts with last argument */
if|if
condition|(
operator|!
name|p
operator|->
name|arg_list
comment|/* nothing to do */
operator|||
operator|!
name|p
operator|->
name|arg_cnt_checked
operator|&&
operator|!
name|arg_cnt_ok
argument_list|(
name|p
operator|->
name|callee
argument_list|,
name|p
operator|->
name|arg_list
argument_list|,
name|p
operator|->
name|line_no
argument_list|)
condition|)
block|{
name|q
operator|->
name|link
operator|=
name|p
operator|->
name|link
expr_stmt|;
comment|/* delete p */
comment|/* the ! arg_list case is not an error so free memory */
name|zfree
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|FCALL_REC
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* keep p and set call_start */
name|q
operator|=
name|p
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|call_scope
condition|)
block|{
case|case
name|SCOPE_MAIN
case|:
name|p
operator|->
name|call_start
operator|=
name|main_start
expr_stmt|;
break|break ;
case|case
name|SCOPE_BEGIN
case|:
name|p
operator|->
name|call_start
operator|=
name|begin_code
operator|.
name|start
expr_stmt|;
break|break ;
case|case
name|SCOPE_END
case|:
name|p
operator|->
name|call_start
operator|=
name|end_code
operator|.
name|start
expr_stmt|;
break|break ;
case|case
name|SCOPE_FUNCT
case|:
name|p
operator|->
name|call_start
operator|=
name|p
operator|->
name|call
operator|->
name|code
expr_stmt|;
break|break ;
block|}
block|}
name|p
operator|=
name|q
operator|->
name|link
expr_stmt|;
block|}
return|return
name|dummy
operator|.
name|link
return|;
block|}
end_function

begin_comment
comment|/* continuously walk the resolve_list making type deductions    until this list goes empty or no more progress can be made    (An example where no more progress can be made is at end of file */
end_comment

begin_function
name|void
name|resolve_fcalls
parameter_list|()
block|{
specifier|register
name|FCALL_REC
modifier|*
name|p
decl_stmt|,
modifier|*
name|old_list
decl_stmt|,
modifier|*
name|new_list
decl_stmt|;
name|int
name|progress
decl_stmt|;
comment|/* a flag */
name|old_list
operator|=
name|first_pass
argument_list|(
name|resolve_list
argument_list|)
expr_stmt|;
name|new_list
operator|=
operator|(
name|FCALL_REC
operator|*
operator|)
literal|0
expr_stmt|;
name|progress
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|old_list
operator|)
condition|)
block|{
comment|/* flop the lists */
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|old_list
operator|=
name|new_list
operator|)
comment|/* nothing left */
operator|||
operator|!
name|progress
comment|/* can't do any more */
condition|)
return|return ;
comment|/* reset after flop */
name|new_list
operator|=
operator|(
name|FCALL_REC
operator|*
operator|)
literal|0
expr_stmt|;
name|progress
operator|=
literal|0
expr_stmt|;
block|}
name|old_list
operator|=
name|p
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|arg_list
operator|=
name|call_arg_check
argument_list|(
name|p
operator|->
name|callee
argument_list|,
name|p
operator|->
name|arg_list
argument_list|,
name|p
operator|->
name|call_start
argument_list|,
name|p
operator|->
name|line_no
argument_list|)
condition|)
block|{
comment|/* still have work to do , put on new_list   */
name|progress
operator||=
name|check_progress
expr_stmt|;
name|p
operator|->
name|link
operator|=
name|new_list
expr_stmt|;
name|new_list
operator|=
name|p
expr_stmt|;
block|}
else|else
comment|/* done with p */
block|{
name|progress
operator|=
literal|1
expr_stmt|;
name|zfree
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|FCALL_REC
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* the parser has just reduced a function call ;    the info needed to type check is passed in.  If type checking    can not be done yet (most common reason -- function referenced    but not defined), a node is added to the resolve list. */
end_comment

begin_function
name|void
name|check_fcall
parameter_list|(
name|callee
parameter_list|,
name|call_scope
parameter_list|,
name|call
parameter_list|,
name|arg_list
parameter_list|,
name|line_no
parameter_list|)
name|FBLOCK
modifier|*
name|callee
decl_stmt|;
name|int
name|call_scope
decl_stmt|;
name|FBLOCK
modifier|*
name|call
decl_stmt|;
name|CA_REC
modifier|*
name|arg_list
decl_stmt|;
name|unsigned
name|line_no
decl_stmt|;
block|{
name|FCALL_REC
modifier|*
name|p
decl_stmt|;
name|INST
modifier|*
name|call_start
decl_stmt|;
if|if
condition|(
operator|!
name|callee
operator|->
name|code
condition|)
block|{
comment|/* forward reference to a function to be defined later */
name|p
operator|=
operator|(
name|FCALL_REC
operator|*
operator|)
name|zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FCALL_REC
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|callee
operator|=
name|callee
expr_stmt|;
name|p
operator|->
name|call_scope
operator|=
name|call_scope
expr_stmt|;
name|p
operator|->
name|call
operator|=
name|call
expr_stmt|;
name|p
operator|->
name|arg_list
operator|=
name|arg_list
expr_stmt|;
name|p
operator|->
name|arg_cnt_checked
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|line_no
operator|=
name|line_no
expr_stmt|;
comment|/* add to resolve list */
name|p
operator|->
name|link
operator|=
name|resolve_list
expr_stmt|;
name|resolve_list
operator|=
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg_list
operator|&&
name|arg_cnt_ok
argument_list|(
name|callee
argument_list|,
name|arg_list
argument_list|,
name|line_no
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|call_scope
condition|)
block|{
case|case
name|SCOPE_MAIN
case|:
name|call_start
operator|=
name|main_start
expr_stmt|;
break|break ;
case|case
name|SCOPE_BEGIN
case|:
name|call_start
operator|=
name|begin_code
operator|.
name|start
expr_stmt|;
break|break ;
case|case
name|SCOPE_END
case|:
name|call_start
operator|=
name|end_code
operator|.
name|start
expr_stmt|;
break|break ;
case|case
name|SCOPE_FUNCT
case|:
name|call_start
operator|=
name|call
operator|->
name|code
expr_stmt|;
break|break ;
block|}
comment|/* usually arg_list disappears here and all is well          otherwise add to resolve list */
if|if
condition|(
name|arg_list
operator|=
name|call_arg_check
argument_list|(
name|callee
argument_list|,
name|arg_list
argument_list|,
name|call_start
argument_list|,
name|line_no
argument_list|)
condition|)
block|{
name|p
operator|=
operator|(
name|FCALL_REC
operator|*
operator|)
name|zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FCALL_REC
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|callee
operator|=
name|callee
expr_stmt|;
name|p
operator|->
name|call_scope
operator|=
name|call_scope
expr_stmt|;
name|p
operator|->
name|call
operator|=
name|call
expr_stmt|;
name|p
operator|->
name|arg_list
operator|=
name|arg_list
expr_stmt|;
name|p
operator|->
name|arg_cnt_checked
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|line_no
operator|=
name|line_no
expr_stmt|;
comment|/* add to resolve list */
name|p
operator|->
name|link
operator|=
name|resolve_list
expr_stmt|;
name|resolve_list
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  example where typing cannot progress  { f(z) }  function f(x) { print NR }  # this is legal, does something useful, but absurdly written # We have to design so this works */
end_comment

end_unit

