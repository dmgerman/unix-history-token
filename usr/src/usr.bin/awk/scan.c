begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************** scan.c copyright 1991, Michael D. Brennan  This is a source file for mawk, an implementation of the AWK programming language.  Mawk is distributed without warranty under the terms of the GNU General Public License, version 2, 1991. ********************************************/
end_comment

begin_comment
comment|/* $Log:	scan.c,v $  * Revision 5.2  92/02/21  14:16:53  brennan  * fix:  getline<=  *   * Revision 5.1  91/12/05  07:56:27  brennan  * 1.1 pre-release  *  */
end_comment

begin_include
include|#
directive|include
file|"mawk.h"
end_include

begin_include
include|#
directive|include
file|"sizes.h"
end_include

begin_include
include|#
directive|include
file|"scan.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_include
include|#
directive|include
file|"field.h"
end_include

begin_include
include|#
directive|include
file|"init.h"
end_include

begin_include
include|#
directive|include
file|"fin.h"
end_include

begin_include
include|#
directive|include
file|"repl.h"
end_include

begin_include
include|#
directive|include
file|"code.h"
end_include

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"files.h"
end_include

begin_comment
comment|/* static functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|scan_fillbuff
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|scan_open
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PROTO
argument_list|(
name|slow_next
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|eat_comment
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|eat_semi_colon
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|PROTO
argument_list|(
name|collect_decimal
argument_list|,
operator|(
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PROTO
argument_list|(
name|collect_string
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PROTO
argument_list|(
name|collect_RE
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-----------------------------   program file management  *----------------------------*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|pfile_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STRING
modifier|*
name|program_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PFILE
modifier|*
name|pfile_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|buffp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* unsigned so it works with 8 bit chars */
end_comment

begin_decl_stmt
specifier|static
name|int
name|program_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eof_flag
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|scan_init
parameter_list|(
name|cmdline_program
parameter_list|)
name|char
modifier|*
name|cmdline_program
decl_stmt|;
block|{
if|if
condition|(
name|cmdline_program
condition|)
block|{
name|program_fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* command line program */
name|program_string
operator|=
name|new_STRING
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|strlen
argument_list|(
name|cmdline_program
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|program_string
operator|->
name|str
argument_list|,
name|cmdline_program
argument_list|)
expr_stmt|;
comment|/* simulate file termination */
name|program_string
operator|->
name|str
index|[
name|program_string
operator|->
name|len
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buffp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|program_string
operator|->
name|str
expr_stmt|;
name|eof_flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* program from file[s] */
block|{
name|scan_open
argument_list|()
expr_stmt|;
name|buffp
operator|=
name|buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|zmalloc
argument_list|(
name|BUFFSZ
operator|+
literal|1
argument_list|)
expr_stmt|;
name|scan_fillbuff
argument_list|()
expr_stmt|;
block|}
name|eat_nl
argument_list|()
expr_stmt|;
comment|/* scan to first token */
if|if
condition|(
name|next
argument_list|()
operator|==
literal|0
condition|)
block|{
name|errmsg
argument_list|(
literal|0
argument_list|,
literal|"no program"
argument_list|)
expr_stmt|;
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|un_next
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scan_open
parameter_list|()
comment|/* open pfile_name */
block|{
if|if
condition|(
name|pfile_name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|pfile_name
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|program_fd
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|program_fd
operator|=
name|open
argument_list|(
name|pfile_name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|errmsg
argument_list|(
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|pfile_name
argument_list|)
expr_stmt|;
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|scan_cleanup
parameter_list|()
block|{
if|if
condition|(
name|program_fd
operator|>=
literal|0
condition|)
name|zfree
argument_list|(
name|buffer
argument_list|,
name|BUFFSZ
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|free_STRING
argument_list|(
name|program_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|program_fd
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|program_fd
argument_list|)
expr_stmt|;
comment|/* redefine SPACE as [ \t\n] */
name|scan_code
index|[
literal|'\n'
index|]
operator|=
name|posix_space_flag
operator|&&
name|rs_shadow
operator|.
name|type
operator|!=
name|SEP_MLR
condition|?
name|SC_UNEXPECTED
else|:
name|SC_SPACE
expr_stmt|;
name|scan_code
index|[
literal|'\f'
index|]
operator|=
name|SC_UNEXPECTED
expr_stmt|;
comment|/*value doesn't matter */
name|scan_code
index|[
literal|'\013'
index|]
operator|=
name|SC_UNEXPECTED
expr_stmt|;
comment|/* \v not space */
name|scan_code
index|[
literal|'\r'
index|]
operator|=
name|SC_UNEXPECTED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------   global variables shared by yyparse() and yylex()   and used for error messages too  *-------------------------------*/
end_comment

begin_decl_stmt
name|int
name|current_token
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|token_lineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|compile_error_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|NR_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* are we tracking NR */
end_comment

begin_decl_stmt
name|int
name|paren_cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|brace_cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|print_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* changes meaning of '>' */
end_comment

begin_decl_stmt
name|int
name|getline_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* changes meaning of '<' */
end_comment

begin_decl_stmt
specifier|extern
name|YYSTYPE
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*----------------------------------------  file reading functions  next() and un_next(c) are macros in scan.h   *---------------------*/
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|lineno
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|scan_fillbuff
parameter_list|()
block|{
name|unsigned
name|r
decl_stmt|;
name|r
operator|=
name|fillbuff
argument_list|(
name|program_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
argument_list|,
name|BUFFSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|BUFFSZ
condition|)
block|{
name|eof_flag
operator|=
literal|1
expr_stmt|;
comment|/* check eof is terminated */
if|if
condition|(
name|r
operator|&&
name|buffer
index|[
name|r
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|buffer
index|[
name|r
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buffer
index|[
name|r
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* read one character -- slowly */
end_comment

begin_function
specifier|static
name|int
name|slow_next
parameter_list|()
block|{
while|while
condition|(
operator|*
name|buffp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|eof_flag
condition|)
block|{
name|buffp
operator|=
name|buffer
expr_stmt|;
name|scan_fillbuff
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pfile_list
comment|/* open another program file */
condition|)
block|{
name|PFILE
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|program_fd
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|program_fd
argument_list|)
expr_stmt|;
name|eof_flag
operator|=
literal|0
expr_stmt|;
name|pfile_name
operator|=
name|pfile_list
operator|->
name|fname
expr_stmt|;
name|q
operator|=
name|pfile_list
expr_stmt|;
name|pfile_list
operator|=
name|pfile_list
operator|->
name|link
expr_stmt|;
name|ZFREE
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|scan_open
argument_list|()
expr_stmt|;
name|token_lineno
operator|=
name|lineno
operator|=
literal|1
expr_stmt|;
block|}
else|else
break|break
comment|/* real eof */
break|;
block|}
return|return
operator|*
name|buffp
operator|++
return|;
comment|/* note can un_next() , eof which is zero */
block|}
end_function

begin_function
specifier|static
name|void
name|eat_comment
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|next
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|scan_code
index|[
name|c
index|]
condition|)
empty_stmt|;
name|un_next
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* this is how we handle extra semi-colons that are    now allowed to separate pattern-action blocks     A proof that they are useless clutter to the language:    we throw them away */
end_comment

begin_function
specifier|static
name|void
name|eat_semi_colon
parameter_list|()
comment|/* eat one semi-colon on the current line */
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
name|scan_code
index|[
name|c
operator|=
name|next
argument_list|()
index|]
operator|==
name|SC_SPACE
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|!=
literal|';'
condition|)
name|un_next
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|eat_nl
parameter_list|()
comment|/* eat all space including newlines */
block|{
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|scan_code
index|[
name|next
argument_list|()
index|]
condition|)
block|{
case|case
name|SC_COMMENT
case|:
name|eat_comment
argument_list|()
expr_stmt|;
break|break ;
case|case
name|SC_NL
case|:
name|lineno
operator|++
expr_stmt|;
comment|/* fall thru  */
case|case
name|SC_SPACE
case|:
break|break ;
default|default :
name|un_next
argument_list|()
expr_stmt|;
return|return ;
block|}
block|}
end_function

begin_function
name|int
name|yylex
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|token_lineno
operator|=
name|lineno
expr_stmt|;
name|reswitch
label|:
switch|switch
condition|(
name|scan_code
index|[
name|c
operator|=
name|next
argument_list|()
index|]
condition|)
block|{
case|case
literal|0
case|:
name|ct_ret
argument_list|(
name|EOF
argument_list|)
expr_stmt|;
case|case
name|SC_SPACE
case|:
goto|goto
name|reswitch
goto|;
case|case
name|SC_COMMENT
case|:
name|eat_comment
argument_list|()
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|SC_NL
case|:
name|lineno
operator|++
expr_stmt|;
name|eat_nl
argument_list|()
expr_stmt|;
name|ct_ret
argument_list|(
name|NL
argument_list|)
expr_stmt|;
case|case
name|SC_ESCAPE
case|:
while|while
condition|(
name|scan_code
index|[
name|c
operator|=
name|next
argument_list|()
index|]
operator|==
name|SC_SPACE
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|token_lineno
operator|=
operator|++
name|lineno
expr_stmt|;
goto|goto
name|reswitch
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|ct_ret
argument_list|(
name|EOF
argument_list|)
expr_stmt|;
name|un_next
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
literal|'\\'
expr_stmt|;
name|ct_ret
argument_list|(
name|UNEXPECTED
argument_list|)
expr_stmt|;
case|case
name|SC_SEMI_COLON
case|:
name|eat_nl
argument_list|()
expr_stmt|;
name|ct_ret
argument_list|(
name|SEMI_COLON
argument_list|)
expr_stmt|;
case|case
name|SC_LBRACE
case|:
name|eat_nl
argument_list|()
expr_stmt|;
name|brace_cnt
operator|++
expr_stmt|;
name|ct_ret
argument_list|(
name|LBRACE
argument_list|)
expr_stmt|;
case|case
name|SC_PLUS
case|:
switch|switch
condition|(
name|next
argument_list|()
condition|)
block|{
case|case
literal|'+'
case|:
name|yylval
operator|.
name|ival
operator|=
literal|'+'
expr_stmt|;
name|string_buff
index|[
literal|0
index|]
operator|=
name|string_buff
index|[
literal|1
index|]
operator|=
literal|'+'
expr_stmt|;
name|string_buff
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ct_ret
argument_list|(
name|INC_or_DEC
argument_list|)
expr_stmt|;
case|case
literal|'='
case|:
name|ct_ret
argument_list|(
name|ADD_ASG
argument_list|)
expr_stmt|;
default|default :
name|un_next
argument_list|()
expr_stmt|;
name|ct_ret
argument_list|(
name|PLUS
argument_list|)
expr_stmt|;
block|}
case|case
name|SC_MINUS
case|:
switch|switch
condition|(
name|next
argument_list|()
condition|)
block|{
case|case
literal|'-'
case|:
name|yylval
operator|.
name|ival
operator|=
literal|'-'
expr_stmt|;
name|string_buff
index|[
literal|0
index|]
operator|=
name|string_buff
index|[
literal|1
index|]
operator|=
literal|'-'
expr_stmt|;
name|string_buff
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ct_ret
argument_list|(
name|INC_or_DEC
argument_list|)
expr_stmt|;
case|case
literal|'='
case|:
name|ct_ret
argument_list|(
name|SUB_ASG
argument_list|)
expr_stmt|;
default|default :
name|un_next
argument_list|()
expr_stmt|;
name|ct_ret
argument_list|(
name|MINUS
argument_list|)
expr_stmt|;
block|}
case|case
name|SC_COMMA
case|:
name|eat_nl
argument_list|()
expr_stmt|;
name|ct_ret
argument_list|(
name|COMMA
argument_list|)
expr_stmt|;
case|case
name|SC_MUL
case|:
name|test1_ret
argument_list|(
literal|'='
argument_list|,
name|MUL_ASG
argument_list|,
name|MUL
argument_list|)
expr_stmt|;
case|case
name|SC_DIV
case|:
block|{
specifier|static
name|int
name|can_precede_div
index|[]
init|=
block|{
name|DOUBLE
block|,
name|STRING_
block|,
name|RPAREN
block|,
name|ID
block|,
name|D_ID
block|,
name|RE
block|,
name|RBOX
block|,
name|FIELD
block|,
name|GETLINE
block|,
name|INC_or_DEC
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|int
modifier|*
name|p
init|=
name|can_precede_div
decl_stmt|;
do|do
if|if
condition|(
operator|*
name|p
operator|==
name|current_token
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
name|INC_or_DEC
condition|)
name|test1_ret
argument_list|(
literal|'='
argument_list|,
name|DIV_ASG
argument_list|,
name|DIV
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
argument_list|()
operator|==
literal|'='
condition|)
block|{
name|un_next
argument_list|()
expr_stmt|;
name|ct_ret
argument_list|(
name|collect_RE
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
operator|++
name|p
operator|!=
operator|-
literal|1
condition|)
do|;
name|ct_ret
argument_list|(
name|collect_RE
argument_list|()
argument_list|)
expr_stmt|;
block|}
case|case
name|SC_MOD
case|:
name|test1_ret
argument_list|(
literal|'='
argument_list|,
name|MOD_ASG
argument_list|,
name|MOD
argument_list|)
expr_stmt|;
case|case
name|SC_POW
case|:
name|test1_ret
argument_list|(
literal|'='
argument_list|,
name|POW_ASG
argument_list|,
name|POW
argument_list|)
expr_stmt|;
case|case
name|SC_LPAREN
case|:
name|paren_cnt
operator|++
expr_stmt|;
name|ct_ret
argument_list|(
name|LPAREN
argument_list|)
expr_stmt|;
case|case
name|SC_RPAREN
case|:
if|if
condition|(
operator|--
name|paren_cnt
operator|<
literal|0
condition|)
block|{
name|compile_error
argument_list|(
literal|"extra ')'"
argument_list|)
expr_stmt|;
name|paren_cnt
operator|=
literal|0
expr_stmt|;
goto|goto
name|reswitch
goto|;
block|}
name|ct_ret
argument_list|(
name|RPAREN
argument_list|)
expr_stmt|;
case|case
name|SC_LBOX
case|:
name|ct_ret
argument_list|(
name|LBOX
argument_list|)
expr_stmt|;
case|case
name|SC_RBOX
case|:
name|ct_ret
argument_list|(
name|RBOX
argument_list|)
expr_stmt|;
case|case
name|SC_MATCH
case|:
name|string_buff
index|[
literal|0
index|]
operator|=
literal|'~'
expr_stmt|;
name|string_buff
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
literal|1
expr_stmt|;
name|ct_ret
argument_list|(
name|MATCH
argument_list|)
expr_stmt|;
case|case
name|SC_EQUAL
case|:
name|test1_ret
argument_list|(
literal|'='
argument_list|,
name|EQ
argument_list|,
name|ASSIGN
argument_list|)
expr_stmt|;
case|case
name|SC_NOT
case|:
comment|/* !  */
if|if
condition|(
operator|(
name|c
operator|=
name|next
argument_list|()
operator|)
operator|==
literal|'~'
condition|)
block|{
name|string_buff
index|[
literal|0
index|]
operator|=
literal|'!'
expr_stmt|;
name|string_buff
index|[
literal|1
index|]
operator|=
literal|'~'
expr_stmt|;
name|string_buff
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
name|ct_ret
argument_list|(
name|MATCH
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
name|ct_ret
argument_list|(
name|NEQ
argument_list|)
expr_stmt|;
name|un_next
argument_list|()
expr_stmt|;
name|ct_ret
argument_list|(
name|NOT
argument_list|)
expr_stmt|;
case|case
name|SC_LT
case|:
comment|/* '<' */
if|if
condition|(
name|next
argument_list|()
operator|==
literal|'='
condition|)
name|ct_ret
argument_list|(
name|LTE
argument_list|)
expr_stmt|;
else|else
name|un_next
argument_list|()
expr_stmt|;
if|if
condition|(
name|getline_flag
condition|)
block|{
name|getline_flag
operator|=
literal|0
expr_stmt|;
name|ct_ret
argument_list|(
name|IO_IN
argument_list|)
expr_stmt|;
block|}
else|else
name|ct_ret
argument_list|(
name|LT
argument_list|)
expr_stmt|;
case|case
name|SC_GT
case|:
comment|/* '>' */
if|if
condition|(
name|print_flag
operator|&&
name|paren_cnt
operator|==
literal|0
condition|)
block|{
name|print_flag
operator|=
literal|0
expr_stmt|;
comment|/* there are 3 types of IO_OUT                 -- build the error string in string_buff */
name|string_buff
index|[
literal|0
index|]
operator|=
literal|'>'
expr_stmt|;
if|if
condition|(
name|next
argument_list|()
operator|==
literal|'>'
condition|)
block|{
name|yylval
operator|.
name|ival
operator|=
name|F_APPEND
expr_stmt|;
name|string_buff
index|[
literal|1
index|]
operator|=
literal|'>'
expr_stmt|;
name|string_buff
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|un_next
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|F_TRUNC
expr_stmt|;
name|string_buff
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|current_token
operator|=
name|IO_OUT
return|;
block|}
name|test1_ret
argument_list|(
literal|'='
argument_list|,
name|GTE
argument_list|,
name|GT
argument_list|)
expr_stmt|;
case|case
name|SC_OR
case|:
if|if
condition|(
name|next
argument_list|()
operator|==
literal|'|'
condition|)
block|{
name|eat_nl
argument_list|()
expr_stmt|;
name|ct_ret
argument_list|(
name|OR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|un_next
argument_list|()
expr_stmt|;
if|if
condition|(
name|print_flag
operator|&&
name|paren_cnt
operator|==
literal|0
condition|)
block|{
name|print_flag
operator|=
literal|0
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|PIPE_OUT
expr_stmt|;
name|string_buff
index|[
literal|0
index|]
operator|=
literal|'|'
expr_stmt|;
name|string_buff
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ct_ret
argument_list|(
name|IO_OUT
argument_list|)
expr_stmt|;
block|}
else|else
name|ct_ret
argument_list|(
name|PIPE
argument_list|)
expr_stmt|;
block|}
case|case
name|SC_AND
case|:
if|if
condition|(
name|next
argument_list|()
operator|==
literal|'&'
condition|)
block|{
name|eat_nl
argument_list|()
expr_stmt|;
name|ct_ret
argument_list|(
name|AND
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|un_next
argument_list|()
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
literal|'&'
expr_stmt|;
name|ct_ret
argument_list|(
name|UNEXPECTED
argument_list|)
expr_stmt|;
block|}
case|case
name|SC_QMARK
case|:
name|ct_ret
argument_list|(
name|QMARK
argument_list|)
expr_stmt|;
case|case
name|SC_COLON
case|:
name|ct_ret
argument_list|(
name|COLON
argument_list|)
expr_stmt|;
case|case
name|SC_RBRACE
case|:
if|if
condition|(
operator|--
name|brace_cnt
operator|<
literal|0
condition|)
block|{
name|compile_error
argument_list|(
literal|"extra '}'"
argument_list|)
expr_stmt|;
name|eat_semi_colon
argument_list|()
expr_stmt|;
name|brace_cnt
operator|=
literal|0
expr_stmt|;
goto|goto
name|reswitch
goto|;
block|}
if|if
condition|(
operator|(
name|c
operator|=
name|current_token
operator|)
operator|==
name|NL
operator|||
name|c
operator|==
name|SEMI_COLON
operator|||
name|c
operator|==
name|SC_FAKE_SEMI_COLON
operator|||
name|c
operator|==
name|RBRACE
condition|)
block|{
comment|/* if the brace_cnt is zero , we've completed                a pattern action block. If the user insists                on adding a semi-colon on the same line                we will eat it.  Note what we do below:                physical law -- conservation of semi-colons */
if|if
condition|(
name|brace_cnt
operator|==
literal|0
condition|)
name|eat_semi_colon
argument_list|()
expr_stmt|;
name|eat_nl
argument_list|()
expr_stmt|;
name|ct_ret
argument_list|(
name|RBRACE
argument_list|)
expr_stmt|;
block|}
comment|/* supply missing semi-colon to statement that              precedes a '}' */
name|brace_cnt
operator|++
expr_stmt|;
name|un_next
argument_list|()
expr_stmt|;
name|current_token
operator|=
name|SC_FAKE_SEMI_COLON
expr_stmt|;
return|return
name|SEMI_COLON
return|;
case|case
name|SC_DIGIT
case|:
case|case
name|SC_DOT
case|:
block|{
name|double
name|d
decl_stmt|;
name|int
name|flag
decl_stmt|;
specifier|static
name|double
name|double_zero
init|=
literal|0.0
decl_stmt|;
specifier|static
name|double
name|double_one
init|=
literal|1.0
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|collect_decimal
argument_list|(
name|c
argument_list|,
operator|&
name|flag
argument_list|)
operator|)
operator|==
literal|0.0
condition|)
if|if
condition|(
name|flag
condition|)
name|ct_ret
argument_list|(
name|flag
argument_list|)
expr_stmt|;
else|else
name|yylval
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
operator|&
name|double_zero
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|==
literal|1.0
condition|)
name|yylval
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
operator|&
name|double_one
expr_stmt|;
else|else
block|{
name|yylval
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|ZMALLOC
argument_list|(
name|double
argument_list|)
expr_stmt|;
operator|*
operator|(
name|double
operator|*
operator|)
name|yylval
operator|.
name|ptr
operator|=
name|d
expr_stmt|;
block|}
name|ct_ret
argument_list|(
name|DOUBLE
argument_list|)
expr_stmt|;
block|}
case|case
name|SC_DOLLAR
case|:
comment|/* '$' */
block|{
name|double
name|d
decl_stmt|;
name|int
name|flag
decl_stmt|;
while|while
condition|(
name|scan_code
index|[
name|c
operator|=
name|next
argument_list|()
index|]
operator|==
name|SC_SPACE
condition|)
empty_stmt|;
if|if
condition|(
name|scan_code
index|[
name|c
index|]
operator|!=
name|SC_DIGIT
operator|&&
name|scan_code
index|[
name|c
index|]
operator|!=
name|SC_DOT
condition|)
block|{
name|un_next
argument_list|()
expr_stmt|;
name|ct_ret
argument_list|(
name|DOLLAR
argument_list|)
expr_stmt|;
block|}
comment|/* compute field address at compile time */
if|if
condition|(
operator|(
name|d
operator|=
name|collect_decimal
argument_list|(
name|c
argument_list|,
operator|&
name|flag
argument_list|)
operator|)
operator|==
literal|0.0
condition|)
if|if
condition|(
name|flag
condition|)
name|ct_ret
argument_list|(
name|flag
argument_list|)
expr_stmt|;
comment|/* an error */
else|else
name|yylval
operator|.
name|cp
operator|=
operator|&
name|field
index|[
literal|0
index|]
expr_stmt|;
else|else
block|{
name|int
name|k
init|=
operator|(
name|int
operator|)
name|d
decl_stmt|;
if|if
condition|(
name|k
operator|>
name|MAX_FIELD
condition|)
block|{
name|compile_error
argument_list|(
literal|"$%g exceeds maximum field(%d)"
argument_list|,
name|d
argument_list|,
name|MAX_FIELD
argument_list|)
expr_stmt|;
name|k
operator|=
name|MAX_FIELD
expr_stmt|;
block|}
name|yylval
operator|.
name|cp
operator|=
name|field_ptr
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
name|ct_ret
argument_list|(
name|FIELD
argument_list|)
expr_stmt|;
block|}
case|case
name|SC_DQUOTE
case|:
return|return
name|current_token
operator|=
name|collect_string
argument_list|()
return|;
case|case
name|SC_IDCHAR
case|:
comment|/* collect an identifier */
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|string_buff
operator|+
literal|1
decl_stmt|;
name|SYMTAB
modifier|*
name|stp
decl_stmt|;
name|string_buff
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|scan_code
index|[
operator|*
name|p
operator|++
operator|=
name|next
argument_list|()
index|]
operator|)
operator|==
name|SC_IDCHAR
operator|||
name|c
operator|==
name|SC_DIGIT
condition|)
empty_stmt|;
name|un_next
argument_list|()
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|(
name|stp
operator|=
name|find
argument_list|(
name|string_buff
argument_list|)
operator|)
operator|->
name|type
condition|)
block|{
case|case
name|ST_NONE
case|:
comment|/* check for function call before defined */
if|if
condition|(
name|next
argument_list|()
operator|==
literal|'('
condition|)
block|{
name|stp
operator|->
name|type
operator|=
name|ST_FUNCT
expr_stmt|;
name|stp
operator|->
name|stval
operator|.
name|fbp
operator|=
operator|(
name|FBLOCK
operator|*
operator|)
name|zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FBLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|stp
operator|->
name|stval
operator|.
name|fbp
operator|->
name|name
operator|=
name|stp
operator|->
name|name
expr_stmt|;
name|stp
operator|->
name|stval
operator|.
name|fbp
operator|->
name|code
operator|=
operator|(
name|INST
operator|*
operator|)
literal|0
expr_stmt|;
name|yylval
operator|.
name|fbp
operator|=
name|stp
operator|->
name|stval
operator|.
name|fbp
expr_stmt|;
name|current_token
operator|=
name|FUNCT_ID
expr_stmt|;
block|}
else|else
block|{
name|yylval
operator|.
name|stp
operator|=
name|stp
expr_stmt|;
name|current_token
operator|=
name|current_token
operator|==
name|DOLLAR
condition|?
name|D_ID
else|:
name|ID
expr_stmt|;
block|}
name|un_next
argument_list|()
expr_stmt|;
break|break ;
case|case
name|ST_NR
case|:
name|NR_flag
operator|=
literal|1
expr_stmt|;
name|stp
operator|->
name|type
operator|=
name|ST_VAR
expr_stmt|;
comment|/* fall thru */
case|case
name|ST_VAR
case|:
case|case
name|ST_ARRAY
case|:
case|case
name|ST_LOCAL_NONE
case|:
case|case
name|ST_LOCAL_VAR
case|:
case|case
name|ST_LOCAL_ARRAY
case|:
name|yylval
operator|.
name|stp
operator|=
name|stp
expr_stmt|;
name|current_token
operator|=
name|current_token
operator|==
name|DOLLAR
condition|?
name|D_ID
else|:
name|ID
expr_stmt|;
break|break ;
case|case
name|ST_ENV
case|:
name|stp
operator|->
name|type
operator|=
name|ST_ARRAY
expr_stmt|;
name|stp
operator|->
name|stval
operator|.
name|array
operator|=
name|new_ARRAY
argument_list|()
expr_stmt|;
name|load_environ
argument_list|(
name|stp
operator|->
name|stval
operator|.
name|array
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|stp
operator|=
name|stp
expr_stmt|;
name|current_token
operator|=
name|current_token
operator|==
name|DOLLAR
condition|?
name|D_ID
else|:
name|ID
expr_stmt|;
break|break ;
case|case
name|ST_FUNCT
case|:
name|yylval
operator|.
name|fbp
operator|=
name|stp
operator|->
name|stval
operator|.
name|fbp
expr_stmt|;
name|current_token
operator|=
name|FUNCT_ID
expr_stmt|;
break|break ;
case|case
name|ST_KEYWORD
case|:
name|current_token
operator|=
name|stp
operator|->
name|stval
operator|.
name|kw
expr_stmt|;
break|break ;
case|case
name|ST_BUILTIN
case|:
name|yylval
operator|.
name|bip
operator|=
name|stp
operator|->
name|stval
operator|.
name|bip
expr_stmt|;
name|current_token
operator|=
name|BUILTIN
expr_stmt|;
break|break ;
case|case
name|ST_FIELD
case|:
name|yylval
operator|.
name|cp
operator|=
name|stp
operator|->
name|stval
operator|.
name|cp
expr_stmt|;
name|current_token
operator|=
name|FIELD
expr_stmt|;
break|break ;
default|default :
name|bozo
argument_list|(
literal|"find returned bad st type"
argument_list|)
expr_stmt|;
block|}
return|return
name|current_token
return|;
block|}
case|case
name|SC_UNEXPECTED
case|:
name|yylval
operator|.
name|ival
operator|=
name|c
operator|&
literal|0xff
expr_stmt|;
name|ct_ret
argument_list|(
name|UNEXPECTED
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* never get here make lint happy */
block|}
end_function

begin_comment
comment|/* collect a decimal constant in temp_buff.    Return the value and error conditions by reference */
end_comment

begin_function
specifier|static
name|double
name|collect_decimal
parameter_list|(
name|c
parameter_list|,
name|flag
parameter_list|)
name|int
name|c
decl_stmt|;
name|int
modifier|*
name|flag
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|string_buff
operator|+
literal|1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|endp
decl_stmt|;
name|double
name|d
decl_stmt|;
operator|*
name|flag
operator|=
literal|0
expr_stmt|;
name|string_buff
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|scan_code
index|[
operator|*
name|p
operator|++
operator|=
name|next
argument_list|()
index|]
operator|!=
name|SC_DIGIT
condition|)
block|{
operator|*
name|flag
operator|=
name|UNEXPECTED
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
literal|'.'
expr_stmt|;
return|return
literal|0.0
return|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|scan_code
index|[
operator|*
name|p
operator|++
operator|=
name|next
argument_list|()
index|]
operator|==
name|SC_DIGIT
condition|)
empty_stmt|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
condition|)
block|{
name|un_next
argument_list|()
expr_stmt|;
name|p
operator|--
expr_stmt|;
block|}
block|}
comment|/* get rest of digits after decimal point */
while|while
condition|(
name|scan_code
index|[
operator|*
name|p
operator|++
operator|=
name|next
argument_list|()
index|]
operator|==
name|SC_DIGIT
condition|)
empty_stmt|;
comment|/* check for exponent */
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'e'
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'E'
condition|)
block|{
name|un_next
argument_list|()
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
comment|/* get the exponent */
if|if
condition|(
name|scan_code
index|[
operator|*
name|p
operator|=
name|next
argument_list|()
index|]
operator|!=
name|SC_DIGIT
operator|&&
operator|*
name|p
operator|!=
literal|'-'
operator|&&
operator|*
name|p
operator|!=
literal|'+'
condition|)
block|{
operator|*
operator|++
name|p
operator|=
literal|0
expr_stmt|;
operator|*
name|flag
operator|=
name|BAD_DECIMAL
expr_stmt|;
return|return
literal|0.0
return|;
block|}
else|else
comment|/* get the rest of the exponent */
block|{
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|scan_code
index|[
operator|*
name|p
operator|++
operator|=
name|next
argument_list|()
index|]
operator|==
name|SC_DIGIT
condition|)
empty_stmt|;
name|un_next
argument_list|()
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* check for overflow/underflow */
name|d
operator|=
name|strtod
argument_list|(
name|string_buff
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|endp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|STRTOD_UNDERFLOW_ON_ZERO_BUG
if|if
condition|(
name|errno
condition|)
name|compile_error
argument_list|(
literal|"%s : decimal %sflow"
argument_list|,
name|string_buff
argument_list|,
name|d
operator|==
literal|0.0
condition|?
literal|"under"
else|:
literal|"over"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* sun4 bug */
if|if
condition|(
name|errno
operator|&&
name|d
operator|!=
literal|0.0
condition|)
name|compile_error
argument_list|(
literal|"%s : decimal overflow"
argument_list|,
name|string_buff
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|endp
operator|<
name|p
condition|)
block|{
operator|*
name|flag
operator|=
name|BAD_DECIMAL
expr_stmt|;
return|return
literal|0.0
return|;
block|}
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/*----------  process escape characters ---------------*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|hex_val
index|[
literal|'f'
operator|-
literal|'A'
operator|+
literal|1
index|]
init|=
block|{
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|isoctal
parameter_list|(
name|x
parameter_list|)
value|((x)>='0'&&(x)<='7')
end_define

begin_define
define|#
directive|define
name|hex_value
parameter_list|(
name|x
parameter_list|)
value|hex_val[(x)-'A']
end_define

begin_define
define|#
directive|define
name|ishex
parameter_list|(
name|x
parameter_list|)
value|(scan_code[x] == SC_DIGIT ||\                   'A'<= (x)&& (x)<= 'f'&& hex_value(x))
end_define

begin_decl_stmt
specifier|static
name|int
name|PROTO
argument_list|(
name|octal
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|PROTO
argument_list|(
name|hex
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* process one , two or three octal digits    moving a pointer forward by reference */
end_comment

begin_function
specifier|static
name|int
name|octal
parameter_list|(
name|start_p
parameter_list|)
name|char
modifier|*
modifier|*
name|start_p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|*
name|start_p
decl_stmt|;
specifier|register
name|unsigned
name|x
decl_stmt|;
name|x
operator|=
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isoctal
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|x
operator|=
operator|(
name|x
operator|<<
literal|3
operator|)
operator|+
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isoctal
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|x
operator|=
operator|(
name|x
operator|<<
literal|3
operator|)
operator|+
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
operator|*
name|start_p
operator|=
name|p
expr_stmt|;
return|return
name|x
operator|&
literal|0xff
return|;
block|}
end_function

begin_comment
comment|/* process one or two hex digits    moving a pointer forward by reference */
end_comment

begin_function
specifier|static
name|int
name|hex
parameter_list|(
name|start_p
parameter_list|)
name|char
modifier|*
modifier|*
name|start_p
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|*
name|start_p
decl_stmt|;
specifier|register
name|unsigned
name|x
decl_stmt|;
name|unsigned
name|t
decl_stmt|;
if|if
condition|(
name|scan_code
index|[
operator|*
name|p
index|]
operator|==
name|SC_DIGIT
condition|)
name|x
operator|=
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
else|else
name|x
operator|=
name|hex_value
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan_code
index|[
operator|*
name|p
index|]
operator|==
name|SC_DIGIT
condition|)
name|x
operator|=
operator|(
name|x
operator|<<
literal|4
operator|)
operator|+
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
literal|'A'
operator|<=
operator|*
name|p
operator|&&
operator|*
name|p
operator|<=
literal|'f'
operator|&&
operator|(
name|t
operator|=
name|hex_value
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
block|{
name|x
operator|=
operator|(
name|x
operator|<<
literal|4
operator|)
operator|+
name|t
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|start_p
operator|=
operator|(
name|char
operator|*
operator|)
name|p
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ET_END
value|9
end_define

begin_struct
specifier|static
struct|struct
block|{
name|char
name|in
decl_stmt|,
name|out
decl_stmt|;
block|}
name|escape_test
index|[
name|ET_END
operator|+
literal|1
index|]
init|=
block|{
literal|'n'
block|,
literal|'\n'
block|,
literal|'t'
block|,
literal|'\t'
block|,
literal|'f'
block|,
literal|'\f'
block|,
literal|'b'
block|,
literal|'\b'
block|,
literal|'r'
block|,
literal|'\r'
block|,
literal|'a'
block|,
literal|'\07'
block|,
literal|'v'
block|,
literal|'\013'
block|,
literal|'\\'
block|,
literal|'\\'
block|,
literal|'\"'
block|,
literal|'\"'
block|,
literal|0
block|,
literal|0
block|}
struct|;
end_struct

begin_comment
comment|/* process the escape characters in a string, in place . */
end_comment

begin_function
name|char
modifier|*
name|rm_escape
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
name|q
operator|=
name|p
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
name|escape_test
index|[
name|ET_END
index|]
operator|.
name|in
operator|=
operator|*
operator|++
name|p
expr_stmt|;
comment|/* sentinal */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|escape_test
index|[
name|i
index|]
operator|.
name|in
operator|!=
operator|*
name|p
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|ET_END
condition|)
comment|/* in table */
block|{
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|escape_test
index|[
name|i
index|]
operator|.
name|out
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isoctal
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|t
operator|=
name|p
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|octal
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|p
operator|=
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'x'
operator|&&
name|ishex
argument_list|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|t
operator|=
name|p
operator|+
literal|1
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|hex
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|p
operator|=
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
comment|/* can only happen with command line assign */
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
else|else
comment|/* not an escape sequence */
block|{
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|collect_string
parameter_list|()
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|string_buff
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|e_flag
init|=
literal|0
decl_stmt|;
comment|/* on if have an escape char */
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|scan_code
index|[
operator|*
name|p
operator|++
operator|=
name|next
argument_list|()
index|]
condition|)
block|{
case|case
name|SC_DQUOTE
case|:
comment|/* done */
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|SC_NL
case|:
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* fall thru */
case|case
literal|0
case|:
comment|/* unterminated string */
name|compile_error
argument_list|(
literal|"runaway string constant \"%.10s ..."
argument_list|,
name|string_buff
argument_list|,
name|token_lineno
argument_list|)
expr_stmt|;
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|SC_ESCAPE
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|next
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
block|{
name|p
operator|--
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|un_next
argument_list|()
expr_stmt|;
else|else
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|e_flag
operator|=
literal|1
expr_stmt|;
block|}
break|break ;
default|default :
break|break ;
block|}
name|out
label|:
name|yylval
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
name|e_flag
condition|?
name|rm_escape
argument_list|(
name|string_buff
argument_list|)
else|:
name|string_buff
argument_list|)
expr_stmt|;
return|return
name|STRING_
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|collect_RE
parameter_list|()
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|string_buff
decl_stmt|;
name|int
name|c
decl_stmt|;
name|STRING
modifier|*
name|sval
decl_stmt|;
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|scan_code
index|[
operator|*
name|p
operator|++
operator|=
name|next
argument_list|()
index|]
condition|)
block|{
case|case
name|SC_DIV
case|:
comment|/* done */
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|SC_NL
case|:
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* fall thru */
case|case
literal|0
case|:
comment|/* unterminated re */
name|compile_error
argument_list|(
literal|"runaway regular expression /%.10s ..."
argument_list|,
name|string_buff
argument_list|,
name|token_lineno
argument_list|)
expr_stmt|;
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|SC_ESCAPE
case|:
switch|switch
condition|(
name|c
operator|=
name|next
argument_list|()
condition|)
block|{
case|case
literal|'/'
case|:
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
break|break ;
case|case
literal|'\n'
case|:
name|p
operator|--
expr_stmt|;
break|break ;
case|case
literal|0
case|:
name|un_next
argument_list|()
expr_stmt|;
break|break ;
default|default :
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
break|break ;
block|}
break|break ;
block|}
name|out
label|:
comment|/* now we've got the RE, so compile it */
name|sval
operator|=
name|new_STRING
argument_list|(
name|string_buff
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ptr
operator|=
name|re_compile
argument_list|(
name|sval
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|sval
argument_list|)
expr_stmt|;
return|return
name|RE
return|;
block|}
end_function

end_unit

