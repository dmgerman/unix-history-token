begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************** files.c copyright 1991, Michael D. Brennan  This is a source file for mawk, an implementation of the AWK programming language.  Mawk is distributed without warranty under the terms of the GNU General Public License, version 2, 1991. ********************************************/
end_comment

begin_comment
comment|/*$Log:	files.c,v $  * Revision 5.1  91/12/05  07:56:00  brennan  * 1.1 pre-release  *  */
end_comment

begin_comment
comment|/* files.c */
end_comment

begin_include
include|#
directive|include
file|"mawk.h"
end_include

begin_include
include|#
directive|include
file|"files.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_include
include|#
directive|include
file|"fin.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|V7
end_ifdef

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_comment
comment|/* defines FIOCLEX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_define
define|#
directive|define
name|CLOSE_ON_EXEC
parameter_list|(
name|fd
parameter_list|)
value|(void) fcntl(fd, F_SETFD, 1)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CLOSE_ON_EXEC
parameter_list|(
name|fd
parameter_list|)
value|ioctl(fd, FIOCLEX, (PTR) 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We store dynamically created files on a linked linear    list with move to the front (big surprise)  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|file
block|{
name|struct
name|file
modifier|*
name|link
decl_stmt|;
name|STRING
modifier|*
name|name
decl_stmt|;
name|short
name|type
decl_stmt|;
name|int
name|pid
decl_stmt|;
comment|/* we need to wait() when we close an out pipe */
comment|/* holds temp file index under MSDOS */
name|PTR
name|ptr
decl_stmt|;
comment|/* FIN*   or  FILE*   */
block|}
name|FILE_NODE
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|FILE_NODE
modifier|*
name|file_list
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|set_stderr
parameter_list|()
block|{
name|file_list
operator|=
name|ZMALLOC
argument_list|(
name|FILE_NODE
argument_list|)
expr_stmt|;
name|file_list
operator|->
name|link
operator|=
operator|(
name|FILE_NODE
operator|*
operator|)
literal|0
expr_stmt|;
name|file_list
operator|->
name|type
operator|=
name|F_TRUNC
expr_stmt|;
name|file_list
operator|->
name|name
operator|=
name|new_STRING
argument_list|(
literal|"/dev/stderr"
argument_list|)
expr_stmt|;
name|file_list
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|stderr
expr_stmt|;
block|}
end_function

begin_function
name|PTR
name|file_find
parameter_list|(
name|sval
parameter_list|,
name|type
parameter_list|)
name|STRING
modifier|*
name|sval
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
specifier|register
name|FILE_NODE
modifier|*
name|p
init|=
name|file_list
decl_stmt|;
name|FILE_NODE
modifier|*
name|q
init|=
operator|(
name|FILE_NODE
operator|*
operator|)
literal|0
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|sval
operator|->
name|str
decl_stmt|;
name|char
modifier|*
name|ostr
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|p
condition|)
comment|/* open a new one */
block|{
name|p
operator|=
operator|(
name|FILE_NODE
operator|*
operator|)
name|zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FILE_NODE
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|type
operator|=
name|type
condition|)
block|{
case|case
name|F_TRUNC
case|:
if|#
directive|if
name|MSDOS
operator|&&
name|NO_BINMODE
operator|==
literal|0
name|ostr
operator|=
operator|(
name|binmode
argument_list|()
operator|&
literal|2
operator|)
condition|?
literal|"wb"
else|:
literal|"w"
expr_stmt|;
else|#
directive|else
name|ostr
operator|=
literal|"w"
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|fopen
argument_list|(
name|name
argument_list|,
name|ostr
argument_list|)
operator|)
condition|)
goto|goto
name|out_failure
goto|;
break|break ;
case|case
name|F_APPEND
case|:
if|#
directive|if
name|MSDOS
operator|&&
name|NO_BINMODE
operator|==
literal|0
name|ostr
operator|=
operator|(
name|binmode
argument_list|()
operator|&
literal|2
operator|)
condition|?
literal|"ab"
else|:
literal|"a"
expr_stmt|;
else|#
directive|else
name|ostr
operator|=
literal|"a"
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|fopen
argument_list|(
name|name
argument_list|,
name|ostr
argument_list|)
operator|)
condition|)
goto|goto
name|out_failure
goto|;
break|break ;
case|case
name|F_IN
case|:
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|FINopen
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|zfree
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|FILE_NODE
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PTR
operator|)
literal|0
return|;
block|}
break|break ;
case|case
name|PIPE_OUT
case|:
case|case
name|PIPE_IN
case|:
if|#
directive|if
name|HAVE_REAL_PIPES
operator|||
name|HAVE_FAKE_PIPES
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|ptr
operator|=
name|get_pipe
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
operator|&
name|p
operator|->
name|pid
argument_list|)
operator|)
condition|)
if|if
condition|(
name|type
operator|==
name|PIPE_OUT
condition|)
goto|goto
name|out_failure
goto|;
else|else
block|{
name|zfree
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|FILE_NODE
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PTR
operator|)
literal|0
return|;
block|}
else|#
directive|else
name|rt_error
argument_list|(
literal|"pipes not supported"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break ;
ifdef|#
directive|ifdef
name|DEBUG
default|default :
name|bozo
argument_list|(
literal|"bad file type"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* successful open */
name|p
operator|->
name|name
operator|=
name|sval
expr_stmt|;
name|sval
operator|->
name|ref_cnt
operator|++
expr_stmt|;
break|break ;
comment|/* while loop */
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|p
operator|->
name|name
operator|->
name|str
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* no distinction between F_APPEND and F_TRUNC here */
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|type
operator|&&
operator|(
name|p
operator|->
name|type
operator|<
name|F_APPEND
operator|||
name|type
operator|<
name|F_APPEND
operator|)
condition|)
goto|goto
name|type_failure
goto|;
if|if
condition|(
operator|!
name|q
condition|)
comment|/*at front of list */
return|return
name|p
operator|->
name|ptr
return|;
comment|/* delete from list for move to front */
name|q
operator|->
name|link
operator|=
name|p
operator|->
name|link
expr_stmt|;
break|break ;
block|}
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|link
expr_stmt|;
block|}
comment|/* put p at the front of the list */
name|p
operator|->
name|link
operator|=
name|file_list
expr_stmt|;
return|return
call|(
name|PTR
call|)
argument_list|(
name|file_list
operator|=
name|p
argument_list|)
operator|->
name|ptr
return|;
name|out_failure
label|:
name|errmsg
argument_list|(
name|errno
argument_list|,
literal|"cannot open \"%s\" for output"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|type_failure
label|:
name|rt_error
argument_list|(
literal|"use of file \"%s\"\n\tis inconsistent with previous use"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* close a file and delete it's node from the file_list */
end_comment

begin_function
name|int
name|file_close
parameter_list|(
name|sval
parameter_list|)
name|STRING
modifier|*
name|sval
decl_stmt|;
block|{
specifier|register
name|FILE_NODE
modifier|*
name|p
init|=
name|file_list
decl_stmt|;
name|FILE_NODE
modifier|*
name|q
init|=
operator|(
name|FILE_NODE
operator|*
operator|)
literal|0
decl_stmt|;
comment|/* trails p */
name|char
modifier|*
name|name
init|=
name|sval
operator|->
name|str
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|p
operator|->
name|name
operator|->
name|str
argument_list|)
operator|==
literal|0
condition|)
comment|/* found */
block|{
switch|switch
condition|(
name|p
operator|->
name|type
condition|)
block|{
case|case
name|F_TRUNC
case|:
case|case
name|F_APPEND
case|:
operator|(
name|void
operator|)
name|fclose
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|p
operator|->
name|ptr
argument_list|)
expr_stmt|;
break|break ;
case|case
name|PIPE_OUT
case|:
operator|(
name|void
operator|)
name|fclose
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|p
operator|->
name|ptr
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_REAL_PIPES
name|retval
operator|=
name|wait_for
argument_list|(
name|p
operator|->
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_FAKE_PIPES
name|retval
operator|=
name|close_fake_outpipe
argument_list|(
name|p
operator|->
name|name
operator|->
name|str
argument_list|,
name|p
operator|->
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break ;
case|case
name|F_IN
case|:
name|FINclose
argument_list|(
operator|(
name|FIN
operator|*
operator|)
name|p
operator|->
name|ptr
argument_list|)
expr_stmt|;
break|break ;
case|case
name|PIPE_IN
case|:
name|FINclose
argument_list|(
operator|(
name|FIN
operator|*
operator|)
name|p
operator|->
name|ptr
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_REAL_PIPES
name|retval
operator|=
name|wait_for
argument_list|(
name|p
operator|->
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_FAKE_PIPES
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmp_file_name
argument_list|(
name|p
operator|->
name|pid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break ;
block|}
name|free_STRING
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|q
operator|->
name|link
operator|=
name|p
operator|->
name|link
expr_stmt|;
else|else
name|file_list
operator|=
name|p
operator|->
name|link
expr_stmt|;
name|zfree
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|FILE_NODE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
else|else
block|{
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|link
expr_stmt|;
block|}
comment|/* its not on the list */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* When we exit, we need to close and wait for all output pipes */
end_comment

begin_if
if|#
directive|if
name|HAVE_REAL_PIPES
end_if

begin_function
name|void
name|close_out_pipes
parameter_list|()
block|{
specifier|register
name|FILE_NODE
modifier|*
name|p
init|=
name|file_list
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|PIPE_OUT
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|p
operator|->
name|ptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wait_for
argument_list|(
name|p
operator|->
name|pid
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|p
operator|->
name|link
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_FAKE_PIPES
end_if

begin_comment
comment|/* pipes are faked with temp files */
end_comment

begin_function
name|void
name|close_fake_pipes
parameter_list|()
block|{
specifier|register
name|FILE_NODE
modifier|*
name|p
init|=
name|file_list
decl_stmt|;
comment|/* close input pipes first to free descriptors for children */
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|PIPE_IN
condition|)
block|{
name|FINclose
argument_list|(
operator|(
name|FIN
operator|*
operator|)
name|p
operator|->
name|ptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmp_file_name
argument_list|(
name|p
operator|->
name|pid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|p
operator|->
name|link
expr_stmt|;
block|}
comment|/* doit again */
name|p
operator|=
name|file_list
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|PIPE_OUT
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|p
operator|->
name|ptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close_fake_outpipe
argument_list|(
name|p
operator|->
name|name
operator|->
name|str
argument_list|,
name|p
operator|->
name|pid
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|p
operator|->
name|link
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* hardwire to /bin/sh for portability of programs */
end_comment

begin_decl_stmt
name|char
modifier|*
name|shell
init|=
literal|"/bin/sh"
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HAVE_REAL_PIPES
end_if

begin_function
name|PTR
name|get_pipe
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|pid_ptr
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
modifier|*
name|pid_ptr
decl_stmt|;
block|{
name|int
name|the_pipe
index|[
literal|2
index|]
decl_stmt|,
name|local_fd
decl_stmt|,
name|remote_fd
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|the_pipe
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|PTR
operator|)
literal|0
return|;
name|local_fd
operator|=
name|the_pipe
index|[
name|type
operator|==
name|PIPE_OUT
index|]
expr_stmt|;
name|remote_fd
operator|=
name|the_pipe
index|[
name|type
operator|==
name|PIPE_IN
index|]
expr_stmt|;
comment|/* to keep output ordered correctly */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|pid_ptr
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
operator|(
name|void
operator|)
name|close
argument_list|(
name|local_fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|remote_fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|PTR
operator|)
literal|0
return|;
case|case
literal|0
case|:
operator|(
name|void
operator|)
name|close
argument_list|(
name|local_fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|type
operator|==
name|PIPE_IN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
name|remote_fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|remote_fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|execl
argument_list|(
name|shell
argument_list|,
name|shell
argument_list|,
literal|"-c"
argument_list|,
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|errmsg
argument_list|(
name|errno
argument_list|,
literal|"failed to exec %s -c %s"
argument_list|,
name|shell
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|128
argument_list|)
expr_stmt|;
default|default :
operator|(
name|void
operator|)
name|close
argument_list|(
name|remote_fd
argument_list|)
expr_stmt|;
comment|/* we could deadlock if future child inherit the local fd ,            set close on exec flag */
name|CLOSE_ON_EXEC
argument_list|(
name|local_fd
argument_list|)
expr_stmt|;
break|break ;
block|}
return|return
name|type
operator|==
name|PIPE_IN
condition|?
operator|(
name|PTR
operator|)
name|FINdopen
argument_list|(
name|local_fd
argument_list|,
literal|0
argument_list|)
else|:
operator|(
name|PTR
operator|)
name|fdopen
argument_list|(
name|local_fd
argument_list|,
literal|"w"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*------------ children ------------------*/
end_comment

begin_comment
comment|/* we need to wait for children at the end of output pipes to    complete so we know any files they have created are complete */
end_comment

begin_comment
comment|/* dead children are kept on this list */
end_comment

begin_struct
specifier|static
struct|struct
name|child
block|{
name|int
name|pid
decl_stmt|;
name|int
name|exit_status
decl_stmt|;
name|struct
name|child
modifier|*
name|link
decl_stmt|;
block|}
modifier|*
name|child_list
struct|;
end_struct

begin_function
specifier|static
name|void
name|add_to_child_list
parameter_list|(
name|pid
parameter_list|,
name|exit_status
parameter_list|)
name|int
name|pid
decl_stmt|,
name|exit_status
decl_stmt|;
block|{
specifier|register
name|struct
name|child
modifier|*
name|p
init|=
operator|(
expr|struct
name|child
operator|*
operator|)
name|zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|child
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
name|p
operator|->
name|exit_status
operator|=
name|exit_status
expr_stmt|;
name|p
operator|->
name|link
operator|=
name|child_list
expr_stmt|;
name|child_list
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|child
modifier|*
name|remove_from_child_list
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
specifier|register
name|struct
name|child
modifier|*
name|p
init|=
name|child_list
decl_stmt|;
name|struct
name|child
modifier|*
name|q
init|=
operator|(
expr|struct
name|child
operator|*
operator|)
literal|0
decl_stmt|;
while|while
condition|(
name|p
condition|)
if|if
condition|(
name|p
operator|->
name|pid
operator|==
name|pid
condition|)
block|{
if|if
condition|(
name|q
condition|)
name|q
operator|->
name|link
operator|=
name|p
operator|->
name|link
expr_stmt|;
else|else
name|child_list
operator|=
name|p
operator|->
name|link
expr_stmt|;
break|break ;
block|}
else|else
block|{
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|link
expr_stmt|;
block|}
return|return
name|p
return|;
comment|/* null return if not in the list */
block|}
end_function

begin_comment
comment|/* wait for a specific child to complete and return its     exit status      If pid is zero, wait for any single child */
end_comment

begin_function
name|int
name|wait_for
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|int
name|exit_status
decl_stmt|;
name|struct
name|child
modifier|*
name|p
decl_stmt|;
name|int
name|id
decl_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|id
operator|=
name|wait
argument_list|(
operator|&
name|exit_status
argument_list|)
expr_stmt|;
name|add_to_child_list
argument_list|(
name|id
argument_list|,
name|exit_status
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* see if an earlier wait() caught our child */
if|if
condition|(
name|p
operator|=
name|remove_from_child_list
argument_list|(
name|pid
argument_list|)
condition|)
block|{
name|exit_status
operator|=
name|p
operator|->
name|exit_status
expr_stmt|;
name|ZFREE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* need to really wait */
while|while
condition|(
operator|(
name|id
operator|=
name|wait
argument_list|(
operator|&
name|exit_status
argument_list|)
operator|)
operator|!=
name|pid
condition|)
if|if
condition|(
name|id
operator|==
operator|-
literal|1
condition|)
comment|/* can't happen */
name|bozo
argument_list|(
literal|"wait_for"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* we got the exit status of another child              put it on the child list and try again */
name|add_to_child_list
argument_list|(
name|id
argument_list|,
name|exit_status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exit_status
operator|&
literal|0xff
condition|)
name|exit_status
operator|=
literal|128
operator|+
operator|(
name|exit_status
operator|&
literal|0xff
operator|)
expr_stmt|;
else|else
name|exit_status
operator|=
operator|(
name|exit_status
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
return|return
name|exit_status
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_REAL_PIPES */
end_comment

end_unit

