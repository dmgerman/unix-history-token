begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************** zmalloc.c copyright 1991, Michael D. Brennan  This is a source file for mawk, an implementation of the AWK programming language.  Mawk is distributed without warranty under the terms of the GNU General Public License, version 2, 1991. ********************************************/
end_comment

begin_comment
comment|/*$Log:	zmalloc.c,v $  * Revision 5.1  91/12/05  07:56:35  brennan  * 1.1 pre-release  *  */
end_comment

begin_comment
comment|/*  zmalloc.c  */
end_comment

begin_include
include|#
directive|include
file|"mawk.h"
end_include

begin_include
include|#
directive|include
file|"zmalloc.h"
end_include

begin_decl_stmt
name|void
name|PROTO
argument_list|(
name|mawk_exit
argument_list|,
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|yacc_mem
modifier|*
name|yacc_memp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   zmalloc() gets mem from malloc() in CHUNKS of 2048 bytes   and cuts these blocks into smaller pieces that are multiples   of eight bytes.  When a piece is returned via zfree(), it goes   on a linked linear list indexed by its size.  The lists are   an array, pool[].    E.g., if you ask for 22 bytes with p = zmalloc(22), you actually get   a piece of size 24.  When you free it with zfree(p,22) , it is added   to the list at pool[2]. */
end_comment

begin_define
define|#
directive|define
name|POOLSZ
value|16
end_define

begin_define
define|#
directive|define
name|CHUNK
value|256
end_define

begin_comment
comment|/* number of blocks to get from malloc */
end_comment

begin_decl_stmt
specifier|static
name|PTR
name|PROTO
argument_list|(
name|emalloc
argument_list|,
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|PROTO
argument_list|(
name|errmsg
argument_list|,
operator|(
name|int
operator|,
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|PTR
name|emalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
name|PTR
name|p
decl_stmt|;
specifier|static
name|char
name|out
index|[]
init|=
literal|"out of memory"
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|SIZE_T
argument_list|(
name|size
argument_list|)
argument_list|)
operator|)
condition|)
if|if
condition|(
name|mawk_state
operator|==
name|EXECUTION
condition|)
name|rt_error
argument_list|(
name|out
argument_list|)
expr_stmt|;
else|else
comment|/* I don't think this will ever happen */
block|{
name|compile_error
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_typedef
typedef|typedef
union|union
name|zblock
block|{
name|char
name|dummy
index|[
name|ZBLOCKSZ
index|]
decl_stmt|;
name|union
name|zblock
modifier|*
name|link
decl_stmt|;
block|}
name|ZBLOCK
typedef|;
end_typedef

begin_comment
comment|/* ZBLOCKS of sizes 1, 2, ... 16    which is bytes of sizes 8, 16, ... , 128    are stored on the linked linear lists in    pool[0], pool[1], ... , pool[15] */
end_comment

begin_decl_stmt
specifier|static
name|ZBLOCK
modifier|*
name|pool
index|[
name|POOLSZ
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|PTR
name|bmalloc
parameter_list|(
name|blocks
parameter_list|)
specifier|register
name|unsigned
name|blocks
decl_stmt|;
block|{
specifier|register
name|ZBLOCK
modifier|*
name|p
decl_stmt|;
specifier|static
name|unsigned
name|amt_avail
decl_stmt|;
specifier|static
name|ZBLOCK
modifier|*
name|avail
decl_stmt|;
if|if
condition|(
name|blocks
operator|>
name|POOLSZ
condition|)
return|return
name|emalloc
argument_list|(
name|blocks
operator|<<
name|ZSHIFT
argument_list|)
return|;
if|if
condition|(
name|p
operator|=
name|pool
index|[
name|blocks
operator|-
literal|1
index|]
condition|)
block|{
name|pool
index|[
name|blocks
operator|-
literal|1
index|]
operator|=
name|p
operator|->
name|link
expr_stmt|;
return|return
operator|(
name|PTR
operator|)
name|p
return|;
block|}
if|if
condition|(
name|blocks
operator|>
name|amt_avail
condition|)
block|{
if|if
condition|(
name|amt_avail
condition|)
comment|/* free avail */
block|{
name|avail
operator|->
name|link
operator|=
name|pool
index|[
operator|--
name|amt_avail
index|]
expr_stmt|;
name|pool
index|[
name|amt_avail
index|]
operator|=
name|avail
expr_stmt|;
block|}
comment|/* use parser tables first */
if|if
condition|(
name|yacc_memp
operator|->
name|zblocks
operator|>=
name|blocks
condition|)
block|{
name|avail
operator|=
operator|(
name|ZBLOCK
operator|*
operator|)
name|yacc_memp
operator|->
name|mem
expr_stmt|;
name|amt_avail
operator|=
name|yacc_memp
operator|++
operator|->
name|zblocks
expr_stmt|;
comment|/* make sure its -- aligned */
if|if
condition|(
operator|(
name|int
operator|)
name|avail
operator|&
literal|7
condition|)
block|{
name|avail
operator|=
operator|(
name|ZBLOCK
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|avail
operator|+
literal|8
operator|-
operator|(
operator|(
name|int
operator|)
name|avail
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
name|amt_avail
operator|--
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|avail
operator|=
operator|(
name|ZBLOCK
operator|*
operator|)
name|malloc
argument_list|(
name|SIZE_T
argument_list|(
name|CHUNK
operator|*
name|ZBLOCKSZ
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* if we get here, almost out of memory */
name|amt_avail
operator|=
literal|0
expr_stmt|;
return|return
name|emalloc
argument_list|(
name|blocks
operator|<<
name|ZSHIFT
argument_list|)
return|;
block|}
else|else
name|amt_avail
operator|=
name|CHUNK
expr_stmt|;
block|}
comment|/* get p from the avail pile */
name|p
operator|=
name|avail
expr_stmt|;
name|avail
operator|+=
name|blocks
expr_stmt|;
name|amt_avail
operator|-=
name|blocks
expr_stmt|;
return|return
operator|(
name|PTR
operator|)
name|p
return|;
block|}
end_function

begin_function
name|void
name|bfree
parameter_list|(
name|p
parameter_list|,
name|blocks
parameter_list|)
specifier|register
name|PTR
name|p
decl_stmt|;
specifier|register
name|unsigned
name|blocks
decl_stmt|;
block|{
if|if
condition|(
name|blocks
operator|>
name|POOLSZ
condition|)
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
operator|(
name|ZBLOCK
operator|*
operator|)
name|p
operator|)
operator|->
name|link
operator|=
name|pool
index|[
operator|--
name|blocks
index|]
expr_stmt|;
name|pool
index|[
name|blocks
index|]
operator|=
operator|(
name|ZBLOCK
operator|*
operator|)
name|p
expr_stmt|;
block|}
block|}
end_function

begin_function
name|PTR
name|zrealloc
parameter_list|(
name|p
parameter_list|,
name|old_size
parameter_list|,
name|new_size
parameter_list|)
specifier|register
name|PTR
name|p
decl_stmt|;
name|unsigned
name|old_size
decl_stmt|,
name|new_size
decl_stmt|;
block|{
specifier|register
name|PTR
name|q
decl_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|q
operator|=
name|zmalloc
argument_list|(
name|new_size
argument_list|)
argument_list|,
name|p
argument_list|,
name|SIZE_T
argument_list|(
name|old_size
operator|<
name|new_size
condition|?
name|old_size
else|:
name|new_size
argument_list|)
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|p
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

end_unit

