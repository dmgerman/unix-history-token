begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************** init.c copyright 1991, Michael D. Brennan  This is a source file for mawk, an implementation of the AWK programming language.  Mawk is distributed without warranty under the terms of the GNU General Public License, version 2, 1991. ********************************************/
end_comment

begin_comment
comment|/* $Log:	init.c,v $  * Revision 5.2  92/01/09  08:46:14  brennan  * small change for MSC  *   * Revision 5.1  91/12/05  07:56:07  brennan  * 1.1 pre-release  *  */
end_comment

begin_comment
comment|/* init.c */
end_comment

begin_include
include|#
directive|include
file|"mawk.h"
end_include

begin_include
include|#
directive|include
file|"code.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_include
include|#
directive|include
file|"symtype.h"
end_include

begin_include
include|#
directive|include
file|"init.h"
end_include

begin_include
include|#
directive|include
file|"bi_vars.h"
end_include

begin_include
include|#
directive|include
file|"field.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|THINK_C
end_ifdef

begin_include
include|#
directive|include
file|<console.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|process_cmdline
argument_list|,
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|set_ARGV
argument_list|,
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|bad_option
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|PROTO
argument_list|(
name|print_version
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|PROTO
argument_list|(
name|is_cmdline_assign
argument_list|,
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_if
if|#
directive|if
name|MSDOS
operator|&&
operator|!
name|HAVE_REARGV
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
unit|static  void  PROTO(emit_prompt, (void) ) ;
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|initialize
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|bi_vars_init
argument_list|()
expr_stmt|;
comment|/* load the builtin variables */
name|bi_funct_init
argument_list|()
expr_stmt|;
comment|/* load the builtin functions */
name|kw_init
argument_list|()
expr_stmt|;
comment|/* load the keywords */
name|field_init
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|THINK_C
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/* (causes Think C console window to appear) */
name|SetWTitle
argument_list|(
name|FrontWindow
argument_list|()
argument_list|,
literal|"\pMacMAWK"
argument_list|)
expr_stmt|;
name|argc
operator|=
name|ccommand
argument_list|(
operator|&
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|MSDOS
operator|&&
name|NO_BINMODE
operator|==
literal|0
block|{
name|char
modifier|*
name|p
init|=
name|getenv
argument_list|(
literal|"MAWKBINMODE"
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
name|set_binmode
argument_list|(
name|atoi
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|process_cmdline
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|code_init
argument_list|()
expr_stmt|;
name|fpe_init
argument_list|()
expr_stmt|;
name|set_stderr
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|compile_cleanup
parameter_list|()
comment|/* program has parsed OK, free some memory    we don't need anymore */
block|{
name|scan_cleanup
argument_list|()
expr_stmt|;
name|code_cleanup
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|dump_code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if on dump internal code */
end_comment

begin_decl_stmt
name|int
name|posix_space_flag
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|dump_RE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if on dump compiled REs  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|bad_option
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|errmsg
argument_list|(
literal|0
argument_list|,
literal|"not an option: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_cmdline
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|nextarg
decl_stmt|;
name|char
modifier|*
name|optarg
decl_stmt|;
name|PFILE
name|dummy
decl_stmt|;
comment|/* starts linked list of filenames */
name|PFILE
modifier|*
name|tail
init|=
operator|&
name|dummy
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|;
name|i
operator|=
name|nextarg
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|0
condition|)
comment|/* -  alone */
block|{
if|if
condition|(
operator|!
name|pfile_name
condition|)
block|{
name|errmsg
argument_list|(
literal|0
argument_list|,
literal|"no program"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break ;
comment|/* the for loop */
block|}
comment|/* safe to look at argv[i][2] */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|argc
operator|-
literal|1
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
literal|"WFvf"
argument_list|,
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|errmsg
argument_list|(
literal|0
argument_list|,
literal|"option %s lacks argument"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bad_option
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|optarg
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|nextarg
operator|=
name|i
operator|+
literal|2
expr_stmt|;
block|}
else|else
comment|/* argument glued to option */
block|{
name|optarg
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
expr_stmt|;
name|nextarg
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'W'
case|:
if|if
condition|(
name|optarg
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|optarg
index|[
literal|0
index|]
operator|<=
literal|'z'
condition|)
name|optarg
index|[
literal|0
index|]
operator|+=
literal|'A'
operator|-
literal|'a'
expr_stmt|;
if|if
condition|(
name|optarg
index|[
literal|0
index|]
operator|==
literal|'V'
condition|)
name|print_version
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|optarg
index|[
literal|0
index|]
operator|==
literal|'D'
condition|)
block|{
name|dump_code
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|SM_DOS
name|errmsg
argument_list|(
literal|0
argument_list|,
literal|"-W dump option unavailable in small model"
argument_list|)
expr_stmt|;
name|dump_code
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|optarg
index|[
literal|0
index|]
operator|==
literal|'S'
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
decl_stmt|;
name|int
name|x
init|=
name|p
condition|?
name|atoi
argument_list|(
name|p
operator|+
literal|1
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|x
operator|>
name|SPRINTF_SZ
condition|)
block|{
name|sprintf_buff
operator|=
operator|(
name|char
operator|*
operator|)
name|zmalloc
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sprintf_limit
operator|=
name|sprintf_buff
operator|+
name|x
expr_stmt|;
block|}
block|}
if|#
directive|if
name|MSDOS
operator|&&
name|NO_BINMODE
operator|==
literal|0
elseif|else
if|if
condition|(
name|optarg
index|[
literal|0
index|]
operator|==
literal|'B'
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
decl_stmt|;
name|int
name|x
init|=
name|p
condition|?
name|atoi
argument_list|(
name|p
operator|+
literal|1
argument_list|)
else|:
literal|0
decl_stmt|;
name|set_binmode
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|optarg
index|[
literal|0
index|]
operator|==
literal|'P'
condition|)
block|{
name|posix_space_flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|errmsg
argument_list|(
literal|0
argument_list|,
literal|"vacuous option: -W %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break ;
case|case
literal|'v'
case|:
if|if
condition|(
operator|!
name|is_cmdline_assign
argument_list|(
name|optarg
argument_list|)
condition|)
block|{
name|errmsg
argument_list|(
literal|0
argument_list|,
literal|"improper assignment: -v %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break ;
case|case
literal|'F'
case|:
name|rm_escape
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
comment|/* recognize escape sequences */
name|cell_destroy
argument_list|(
name|FS
argument_list|)
expr_stmt|;
name|FS
operator|->
name|type
operator|=
name|C_STRING
expr_stmt|;
name|FS
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|cast_for_split
argument_list|(
name|cellcpy
argument_list|(
operator|&
name|fs_shadow
argument_list|,
name|FS
argument_list|)
argument_list|)
expr_stmt|;
break|break ;
case|case
literal|'-'
case|:
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|bad_option
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
goto|goto
name|no_more_opts
goto|;
case|case
literal|'f'
case|:
comment|/* first file goes in pfile_name ; any more go 	       on a list */
if|if
condition|(
operator|!
name|pfile_name
condition|)
name|pfile_name
operator|=
name|optarg
expr_stmt|;
else|else
block|{
name|tail
operator|=
name|tail
operator|->
name|link
operator|=
name|ZMALLOC
argument_list|(
name|PFILE
argument_list|)
expr_stmt|;
name|tail
operator|->
name|fname
operator|=
name|optarg
expr_stmt|;
block|}
break|break ;
default|default :
name|bad_option
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|nextarg
expr_stmt|;
block|}
name|no_more_opts
label|:
name|tail
operator|->
name|link
operator|=
operator|(
name|PFILE
operator|*
operator|)
literal|0
expr_stmt|;
name|pfile_list
operator|=
name|dummy
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|pfile_name
condition|)
block|{
name|set_ARGV
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|scan_init
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* program on command line */
block|{
if|#
directive|if
literal|0
if|#
directive|if
name|MSDOS
operator|&&
operator|!
name|HAVE_REARGV
comment|/* prompt for program */
block|set_ARGV(argc, argv, i) ;     emit_prompt() ;     pfile_name = "CON" ;     scan_init( (char *) 0 ) ;
else|#
directive|else
comment|/* the real world */
endif|#
directive|endif
endif|#
directive|endif
comment|/* 0 */
if|if
condition|(
name|i
operator|==
name|argc
condition|)
block|{
name|errmsg
argument_list|(
literal|0
argument_list|,
literal|"no program"
argument_list|)
expr_stmt|;
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|set_ARGV
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|MSDOS
operator|&&
operator|!
name|HAVE_REARGV
comment|/* reversed quotes */
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|argv
index|[
name|i
index|]
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
condition|)
operator|*
name|p
operator|=
literal|'\"'
expr_stmt|;
block|}
endif|#
directive|endif
name|scan_init
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* #endif  */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_ARGV
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|i
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* argv[i] = ARGV[1] */
block|{
name|SYMTAB
modifier|*
name|st_p
decl_stmt|;
name|CELL
name|argi
decl_stmt|;
specifier|register
name|CELL
modifier|*
name|cp
decl_stmt|;
name|st_p
operator|=
name|insert
argument_list|(
literal|"ARGV"
argument_list|)
expr_stmt|;
name|st_p
operator|->
name|type
operator|=
name|ST_ARRAY
expr_stmt|;
name|Argv
operator|=
name|st_p
operator|->
name|stval
operator|.
name|array
operator|=
name|new_ARRAY
argument_list|()
expr_stmt|;
name|argi
operator|.
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|argi
operator|.
name|dval
operator|=
literal|0.0
expr_stmt|;
name|cp
operator|=
name|array_find
argument_list|(
name|st_p
operator|->
name|stval
operator|.
name|array
argument_list|,
operator|&
name|argi
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
name|cp
operator|->
name|type
operator|=
name|C_STRING
expr_stmt|;
name|cp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
name|progname
argument_list|)
expr_stmt|;
comment|/* ARGV[0] is set, do the rest       The type of ARGV[1] ... should be C_MBSTRN      because the user might enter numbers from the command line */
for|for
control|(
name|argi
operator|.
name|dval
operator|=
literal|1.0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
operator|,
name|argi
operator|.
name|dval
operator|+=
literal|1.0
control|)
block|{
name|cp
operator|=
name|array_find
argument_list|(
name|st_p
operator|->
name|stval
operator|.
name|array
argument_list|,
operator|&
name|argi
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
name|cp
operator|->
name|type
operator|=
name|C_MBSTRN
expr_stmt|;
name|cp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|ARGC
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|ARGC
operator|->
name|dval
operator|=
name|argi
operator|.
name|dval
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_if
if|#
directive|if
name|MSDOS
operator|&&
operator|!
name|HAVE_REARGV
end_if

begin_endif
unit|static void  emit_prompt() {  static char prompt[] = "mawk> " ;    int fd = open("CON", O_WRONLY, 0) ;     (void) write(fd, prompt, strlen(prompt)) ;    (void) close(fd) ; }
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*----- ENVIRON ----------*/
end_comment

begin_function
name|void
name|load_environ
parameter_list|(
name|ENV
parameter_list|)
name|ARRAY
name|ENV
decl_stmt|;
block|{
name|CELL
name|c
decl_stmt|;
ifndef|#
directive|ifndef
name|MSDOS_MSC
comment|/* MSC declares it near */
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
endif|#
directive|endif
specifier|register
name|char
modifier|*
modifier|*
name|p
init|=
name|environ
decl_stmt|;
comment|/* walks environ */
name|char
modifier|*
name|s
decl_stmt|;
comment|/* looks for the '=' */
name|CELL
modifier|*
name|cp
decl_stmt|;
comment|/* pts at ENV[&c] */
name|c
operator|.
name|type
operator|=
name|C_STRING
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|s
operator|=
name|strchr
argument_list|(
operator|*
name|p
argument_list|,
literal|'='
argument_list|)
condition|)
comment|/* shouldn't fail */
block|{
operator|*
name|s
operator|=
literal|0
expr_stmt|;
name|c
operator|.
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'='
expr_stmt|;
name|cp
operator|=
name|array_find
argument_list|(
name|ENV
argument_list|,
operator|&
name|c
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
name|cp
operator|->
name|type
operator|=
name|C_MBSTRN
expr_stmt|;
name|cp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_STRING
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
operator|&
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

end_unit

