begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************** execute.c copyright 1991, Michael D. Brennan  This is a source file for mawk, an implementation of the AWK programming language.  Mawk is distributed without warranty under the terms of the GNU General Public License, version 2, 1991. ********************************************/
end_comment

begin_comment
comment|/* $Log:	execute.c,v $  * Revision 5.1  91/12/05  07:55:50  brennan  * 1.1 pre-release  *  */
end_comment

begin_include
include|#
directive|include
file|"mawk.h"
end_include

begin_include
include|#
directive|include
file|"code.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_include
include|#
directive|include
file|"symtype.h"
end_include

begin_include
include|#
directive|include
file|"field.h"
end_include

begin_include
include|#
directive|include
file|"bi_funct.h"
end_include

begin_include
include|#
directive|include
file|"bi_vars.h"
end_include

begin_include
include|#
directive|include
file|"regexp.h"
end_include

begin_include
include|#
directive|include
file|"repl.h"
end_include

begin_include
include|#
directive|include
file|"fin.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_comment
comment|/* static functions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|PROTO
argument_list|(
name|compare
argument_list|,
operator|(
name|CELL
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|PROTO
argument_list|(
name|eval_overflow
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|NOINFO_SIGFPE
end_if

begin_decl_stmt
specifier|static
name|char
name|dz_msg
index|[]
init|=
literal|"division by zero"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|inc_sp
parameter_list|()
value|if( ++sp == eval_stack+EVAL_STACK_SIZE )\                          eval_overflow()
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* If things are working, the eval stack should not overflow */
end_comment

begin_define
define|#
directive|define
name|inc_sp
parameter_list|()
value|sp++
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SAFETY
value|16
end_define

begin_define
define|#
directive|define
name|DANGER
value|(EVAL_STACK_SIZE-SAFETY)
end_define

begin_comment
comment|/*  The stack machine that executes the code */
end_comment

begin_decl_stmt
name|CELL
name|eval_stack
index|[
name|EVAL_STACK_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these can move for deep recursion */
end_comment

begin_decl_stmt
specifier|static
name|CELL
modifier|*
name|stack_base
init|=
name|eval_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CELL
modifier|*
name|stack_danger
init|=
name|eval_stack
operator|+
name|DANGER
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|eval_overflow
parameter_list|()
block|{
name|overflow
argument_list|(
literal|"eval stack"
argument_list|,
name|EVAL_STACK_SIZE
argument_list|)
expr_stmt|;
name|mawk_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|INST
modifier|*
name|restart_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* control flow labels */
end_comment

begin_decl_stmt
name|INST
modifier|*
name|next_label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CELL
name|tc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*useful temp */
end_comment

begin_function
name|void
name|execute
parameter_list|(
name|cdp
parameter_list|,
name|sp
parameter_list|,
name|fp
parameter_list|)
specifier|register
name|INST
modifier|*
name|cdp
decl_stmt|;
comment|/* code ptr, start execution here */
specifier|register
name|CELL
modifier|*
name|sp
decl_stmt|;
comment|/* eval_stack pointer */
name|CELL
modifier|*
name|fp
decl_stmt|;
comment|/* frame ptr into eval_stack for                            user defined functions */
block|{
comment|/* some useful temporaries */
name|CELL
modifier|*
name|cp
decl_stmt|;
name|int
name|t
decl_stmt|;
comment|/* for moving the stack (deep recursion) */
name|CELL
modifier|*
name|old_stack_base
decl_stmt|;
name|CELL
modifier|*
name|old_sp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|CELL
modifier|*
name|entry_sp
init|=
name|sp
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fp
condition|)
comment|/* we are a function call, check for deep recursion */
block|{
if|if
condition|(
name|sp
operator|>
name|stack_danger
condition|)
block|{
comment|/* change stacks */
name|old_stack_base
operator|=
name|stack_base
expr_stmt|;
name|old_sp
operator|=
name|sp
expr_stmt|;
name|stack_base
operator|=
operator|(
name|CELL
operator|*
operator|)
name|zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|CELL
argument_list|)
operator|*
name|EVAL_STACK_SIZE
argument_list|)
expr_stmt|;
name|stack_danger
operator|=
name|stack_base
operator|+
name|DANGER
expr_stmt|;
name|sp
operator|=
name|stack_base
expr_stmt|;
comment|/* waste 1 slot for ANSI, actually LM_DOS breaks in 	     RET if we don't */
ifdef|#
directive|ifdef
name|DEBUG
name|entry_sp
operator|=
name|sp
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|old_stack_base
operator|=
operator|(
name|CELL
operator|*
operator|)
literal|0
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|cdp
operator|++
operator|->
name|op
condition|)
block|{
comment|/* HALT only used by the disassemble now ; this remains    so compilers don't offset the jump table */
case|case
name|_HALT
case|:
case|case
name|_STOP
case|:
comment|/* only for range patterns */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sp
operator|!=
name|entry_sp
operator|+
literal|1
condition|)
name|bozo
argument_list|(
literal|"stop0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return ;
case|case
name|_PUSHC
case|:
name|inc_sp
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|sp
argument_list|,
name|cdp
operator|++
operator|->
name|ptr
argument_list|)
expr_stmt|;
break|break ;
case|case
name|_PUSHD
case|:
name|inc_sp
argument_list|()
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
operator|*
operator|(
name|double
operator|*
operator|)
name|cdp
operator|++
operator|->
name|ptr
expr_stmt|;
break|break ;
case|case
name|_PUSHS
case|:
name|inc_sp
argument_list|()
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_STRING
expr_stmt|;
name|sp
operator|->
name|ptr
operator|=
name|cdp
operator|++
operator|->
name|ptr
expr_stmt|;
name|string
argument_list|(
name|sp
argument_list|)
operator|->
name|ref_cnt
operator|++
expr_stmt|;
break|break ;
case|case
name|F_PUSHA
case|:
if|if
condition|(
operator|(
name|CELL
operator|*
operator|)
name|cdp
operator|->
name|ptr
operator|!=
name|field
operator|&&
name|nf
operator|<
literal|0
condition|)
name|split_field0
argument_list|()
expr_stmt|;
comment|/* fall thru */
case|case
name|_PUSHA
case|:
case|case
name|A_PUSHA
case|:
name|inc_sp
argument_list|()
expr_stmt|;
name|sp
operator|->
name|ptr
operator|=
name|cdp
operator|++
operator|->
name|ptr
expr_stmt|;
break|break ;
case|case
name|_PUSHI
case|:
comment|/* put contents of next address on stack*/
name|inc_sp
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|sp
argument_list|,
name|cdp
operator|++
operator|->
name|ptr
argument_list|)
expr_stmt|;
break|break ;
case|case
name|L_PUSHI
case|:
comment|/* put the contents of a local var on stack,                cdp->op holds the offset from the frame pointer */
name|inc_sp
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|sp
argument_list|,
name|fp
operator|+
name|cdp
operator|++
operator|->
name|op
argument_list|)
expr_stmt|;
break|break ;
case|case
name|L_PUSHA
case|:
comment|/* put a local address on eval stack */
name|inc_sp
argument_list|()
expr_stmt|;
name|sp
operator|->
name|ptr
operator|=
call|(
name|PTR
call|)
argument_list|(
name|fp
operator|+
name|cdp
operator|++
operator|->
name|op
argument_list|)
expr_stmt|;
break|break ;
case|case
name|F_PUSHI
case|:
comment|/* push contents of $i             cdp[0] holds& $i , cdp[1] holds i */
name|inc_sp
argument_list|()
expr_stmt|;
if|if
condition|(
name|nf
operator|<
literal|0
condition|)
name|split_field0
argument_list|()
expr_stmt|;
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
name|cdp
operator|->
name|ptr
expr_stmt|;
name|t
operator|=
operator|(
name|cdp
operator|+
literal|1
operator|)
operator|->
name|op
expr_stmt|;
name|cdp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|t
operator|<=
name|nf
condition|)
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|sp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
comment|/* an unset field */
block|{
name|sp
operator|->
name|type
operator|=
name|C_STRING
expr_stmt|;
name|sp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
operator|&
name|null_str
expr_stmt|;
name|null_str
operator|.
name|ref_cnt
operator|++
expr_stmt|;
block|}
break|break ;
case|case
name|NF_PUSHI
case|:
name|inc_sp
argument_list|()
expr_stmt|;
if|if
condition|(
name|nf
operator|<
literal|0
condition|)
name|split_field0
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|sp
argument_list|,
name|NF
argument_list|)
expr_stmt|;
break|break ;
case|case
name|FE_PUSHA
case|:
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
operator|(
name|int
operator|)
name|sp
operator|->
name|dval
operator|)
operator|<
literal|0
condition|)
name|rt_error
argument_list|(
literal|"negative field index $%d"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|nf
operator|<
literal|0
condition|)
name|split_field0
argument_list|()
expr_stmt|;
name|sp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|field_ptr
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break ;
case|case
name|FE_PUSHI
case|:
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
operator|(
name|int
operator|)
name|sp
operator|->
name|dval
operator|)
operator|<
literal|0
condition|)
name|rt_error
argument_list|(
literal|"negative field index $%d"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|<
literal|0
condition|)
name|split_field0
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|<=
name|nf
condition|)
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|sp
argument_list|,
name|field_ptr
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|sp
operator|->
name|type
operator|=
name|C_STRING
expr_stmt|;
name|sp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
operator|&
name|null_str
expr_stmt|;
name|null_str
operator|.
name|ref_cnt
operator|++
expr_stmt|;
block|}
break|break ;
case|case
name|AE_PUSHA
case|:
comment|/* top of stack has an expr, cdp->ptr points at an            array, replace the expr with the cell address inside            the array */
name|cp
operator|=
name|array_find
argument_list|(
operator|(
name|ARRAY
operator|)
name|cdp
operator|++
operator|->
name|ptr
argument_list|,
name|sp
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|cp
expr_stmt|;
break|break ;
case|case
name|AE_PUSHI
case|:
comment|/* top of stack has an expr, cdp->ptr points at an            array, replace the expr with the contents of the            cell inside the array */
name|cp
operator|=
name|array_find
argument_list|(
operator|(
name|ARRAY
operator|)
name|cdp
operator|++
operator|->
name|ptr
argument_list|,
name|sp
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|sp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break ;
case|case
name|LAE_PUSHI
case|:
comment|/*  sp[0] is an expression             cdp->op is offset from frame pointer of a CELL which                has an ARRAY in the ptr field, replace expr             with  array[expr]         */
name|cp
operator|=
name|array_find
argument_list|(
operator|(
name|ARRAY
operator|)
name|fp
index|[
name|cdp
operator|++
operator|->
name|op
index|]
operator|.
name|ptr
argument_list|,
name|sp
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|sp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break ;
case|case
name|LAE_PUSHA
case|:
comment|/*  sp[0] is an expression             cdp->op is offset from frame pointer of a CELL which                has an ARRAY in the ptr field, replace expr             with& array[expr]         */
name|cp
operator|=
name|array_find
argument_list|(
operator|(
name|ARRAY
operator|)
name|fp
index|[
name|cdp
operator|++
operator|->
name|op
index|]
operator|.
name|ptr
argument_list|,
name|sp
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|cp
expr_stmt|;
break|break ;
case|case
name|LA_PUSHA
case|:
comment|/*  cdp->op is offset from frame pointer of a CELL which                has an ARRAY in the ptr field. Push this ARRAY                on the eval stack         */
name|inc_sp
argument_list|()
expr_stmt|;
name|sp
operator|->
name|ptr
operator|=
name|fp
index|[
name|cdp
operator|++
operator|->
name|op
index|]
operator|.
name|ptr
expr_stmt|;
break|break ;
case|case
name|SET_ALOOP
case|:
block|{
name|ALOOP_STATE
modifier|*
name|ap
init|=
operator|(
name|ALOOP_STATE
operator|*
operator|)
operator|(
name|cdp
operator|+
name|cdp
operator|->
name|op
operator|+
literal|2
operator|)
operator|->
name|ptr
decl_stmt|;
name|ap
operator|->
name|var
operator|=
operator|(
name|CELL
operator|*
operator|)
name|sp
index|[
operator|-
literal|1
index|]
operator|.
name|ptr
expr_stmt|;
name|ap
operator|->
name|A
operator|=
operator|(
name|ARRAY
operator|)
name|sp
operator|->
name|ptr
expr_stmt|;
name|sp
operator|-=
literal|2
expr_stmt|;
name|ap
operator|->
name|index
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|inc_aloop_state
argument_list|(
name|ap
argument_list|)
condition|)
name|cdp
operator|++
expr_stmt|;
else|else
name|cdp
operator|+=
name|cdp
operator|->
name|op
operator|+
literal|3
expr_stmt|;
block|}
break|break ;
case|case
name|ALOOP
case|:
if|if
condition|(
name|inc_aloop_state
argument_list|(
operator|(
name|ALOOP_STATE
operator|*
operator|)
name|cdp
index|[
literal|1
index|]
operator|.
name|ptr
argument_list|)
condition|)
name|cdp
operator|+=
name|cdp
operator|->
name|op
expr_stmt|;
else|else
name|cdp
operator|+=
literal|2
expr_stmt|;
break|break ;
case|case
name|_POP
case|:
name|cell_destroy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|--
expr_stmt|;
break|break ;
case|case
name|_DUP
case|:
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|sp
operator|+
literal|1
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|++
expr_stmt|;
break|break ;
case|case
name|_ASSIGN
case|:
comment|/* top of stack has an expr, next down is an                address, put the expression in *address and                replace the address with the expression */
comment|/* don't propagate type C_MBSTRN */
if|if
condition|(
name|sp
operator|->
name|type
operator|==
name|C_MBSTRN
condition|)
name|check_strnum
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|--
expr_stmt|;
name|cell_destroy
argument_list|(
operator|(
operator|(
name|CELL
operator|*
operator|)
name|sp
operator|->
name|ptr
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|sp
argument_list|,
name|cellcpy
argument_list|(
name|sp
operator|->
name|ptr
argument_list|,
name|sp
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break ;
case|case
name|F_ASSIGN
case|:
comment|/* assign to a field  */
if|if
condition|(
name|sp
operator|->
name|type
operator|==
name|C_MBSTRN
condition|)
name|check_strnum
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|--
expr_stmt|;
name|field_assign
argument_list|(
operator|(
name|CELL
operator|*
operator|)
name|sp
operator|->
name|ptr
argument_list|,
name|sp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|sp
argument_list|,
operator|(
name|CELL
operator|*
operator|)
name|sp
operator|->
name|ptr
argument_list|)
expr_stmt|;
break|break ;
case|case
name|_ADD_ASG
case|:
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
operator|(
name|sp
operator|-
literal|1
operator|)
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
comment|/* specific to V7 and XNX23A */
name|clrerr
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|cp
operator|->
name|dval
operator|+=
name|sp
operator|--
operator|->
name|dval
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|fpcheck
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|cp
operator|->
name|dval
expr_stmt|;
break|break ;
case|case
name|_SUB_ASG
case|:
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
operator|(
name|sp
operator|-
literal|1
operator|)
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|clrerr
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|cp
operator|->
name|dval
operator|-=
name|sp
operator|--
operator|->
name|dval
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|fpcheck
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|cp
operator|->
name|dval
expr_stmt|;
break|break ;
case|case
name|_MUL_ASG
case|:
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
operator|(
name|sp
operator|-
literal|1
operator|)
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|clrerr
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|cp
operator|->
name|dval
operator|*=
name|sp
operator|--
operator|->
name|dval
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|fpcheck
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|cp
operator|->
name|dval
expr_stmt|;
break|break ;
case|case
name|_DIV_ASG
case|:
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
operator|(
name|sp
operator|-
literal|1
operator|)
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NOINFO_SIGFPE
name|CHECK_DIVZERO
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|SW_FP_CHECK
name|clrerr
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|cp
operator|->
name|dval
operator|/=
name|sp
operator|--
operator|->
name|dval
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|fpcheck
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|cp
operator|->
name|dval
expr_stmt|;
break|break ;
case|case
name|_MOD_ASG
case|:
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
operator|(
name|sp
operator|-
literal|1
operator|)
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NOINFO_SIGFPE
name|CHECK_DIVZERO
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|->
name|dval
operator|=
name|fmod
argument_list|(
name|cp
operator|->
name|dval
argument_list|,
name|sp
operator|--
operator|->
name|dval
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|cp
operator|->
name|dval
expr_stmt|;
break|break ;
case|case
name|_POW_ASG
case|:
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
operator|(
name|sp
operator|-
literal|1
operator|)
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|dval
operator|=
name|pow
argument_list|(
name|cp
operator|->
name|dval
argument_list|,
name|sp
operator|--
operator|->
name|dval
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|cp
operator|->
name|dval
expr_stmt|;
break|break ;
comment|/* will anyone ever use these ? */
case|case
name|F_ADD_ASG
case|:
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
operator|(
name|sp
operator|-
literal|1
operator|)
operator|->
name|ptr
expr_stmt|;
name|cast1_to_d
argument_list|(
name|cellcpy
argument_list|(
operator|&
name|tc
argument_list|,
name|cp
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|clrerr
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|tc
operator|.
name|dval
operator|+=
name|sp
operator|--
operator|->
name|dval
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|fpcheck
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|tc
operator|.
name|dval
expr_stmt|;
name|field_assign
argument_list|(
name|cp
argument_list|,
operator|&
name|tc
argument_list|)
expr_stmt|;
break|break ;
case|case
name|F_SUB_ASG
case|:
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
operator|(
name|sp
operator|-
literal|1
operator|)
operator|->
name|ptr
expr_stmt|;
name|cast1_to_d
argument_list|(
name|cellcpy
argument_list|(
operator|&
name|tc
argument_list|,
name|cp
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|clrerr
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|tc
operator|.
name|dval
operator|-=
name|sp
operator|--
operator|->
name|dval
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|fpcheck
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|tc
operator|.
name|dval
expr_stmt|;
name|field_assign
argument_list|(
name|cp
argument_list|,
operator|&
name|tc
argument_list|)
expr_stmt|;
break|break ;
case|case
name|F_MUL_ASG
case|:
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
operator|(
name|sp
operator|-
literal|1
operator|)
operator|->
name|ptr
expr_stmt|;
name|cast1_to_d
argument_list|(
name|cellcpy
argument_list|(
operator|&
name|tc
argument_list|,
name|cp
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|clrerr
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|tc
operator|.
name|dval
operator|*=
name|sp
operator|--
operator|->
name|dval
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|fpcheck
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|tc
operator|.
name|dval
expr_stmt|;
name|field_assign
argument_list|(
name|cp
argument_list|,
operator|&
name|tc
argument_list|)
expr_stmt|;
break|break ;
case|case
name|F_DIV_ASG
case|:
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
operator|(
name|sp
operator|-
literal|1
operator|)
operator|->
name|ptr
expr_stmt|;
name|cast1_to_d
argument_list|(
name|cellcpy
argument_list|(
operator|&
name|tc
argument_list|,
name|cp
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|NOINFO_SIGFPE
name|CHECK_DIVZERO
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|SW_FP_CHECK
name|clrerr
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|tc
operator|.
name|dval
operator|/=
name|sp
operator|--
operator|->
name|dval
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|fpcheck
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|tc
operator|.
name|dval
expr_stmt|;
name|field_assign
argument_list|(
name|cp
argument_list|,
operator|&
name|tc
argument_list|)
expr_stmt|;
break|break ;
case|case
name|F_MOD_ASG
case|:
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
operator|(
name|sp
operator|-
literal|1
operator|)
operator|->
name|ptr
expr_stmt|;
name|cast1_to_d
argument_list|(
name|cellcpy
argument_list|(
operator|&
name|tc
argument_list|,
name|cp
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|NOINFO_SIGFPE
name|CHECK_DIVZERO
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tc
operator|.
name|dval
operator|=
name|fmod
argument_list|(
name|tc
operator|.
name|dval
argument_list|,
name|sp
operator|--
operator|->
name|dval
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|tc
operator|.
name|dval
expr_stmt|;
name|field_assign
argument_list|(
name|cp
argument_list|,
operator|&
name|tc
argument_list|)
expr_stmt|;
break|break ;
case|case
name|F_POW_ASG
case|:
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
operator|(
name|sp
operator|-
literal|1
operator|)
operator|->
name|ptr
expr_stmt|;
name|cast1_to_d
argument_list|(
name|cellcpy
argument_list|(
operator|&
name|tc
argument_list|,
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|tc
operator|.
name|dval
operator|=
name|pow
argument_list|(
name|tc
operator|.
name|dval
argument_list|,
name|sp
operator|--
operator|->
name|dval
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|tc
operator|.
name|dval
expr_stmt|;
name|field_assign
argument_list|(
name|cp
argument_list|,
operator|&
name|tc
argument_list|)
expr_stmt|;
break|break ;
case|case
name|_ADD
case|:
name|sp
operator|--
expr_stmt|;
if|if
condition|(
name|TEST2
argument_list|(
name|sp
argument_list|)
operator|!=
name|TWO_DOUBLES
condition|)
name|cast2_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|clrerr
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sp
index|[
literal|0
index|]
operator|.
name|dval
operator|+=
name|sp
index|[
literal|1
index|]
operator|.
name|dval
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|fpcheck
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break ;
case|case
name|_SUB
case|:
name|sp
operator|--
expr_stmt|;
if|if
condition|(
name|TEST2
argument_list|(
name|sp
argument_list|)
operator|!=
name|TWO_DOUBLES
condition|)
name|cast2_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|clrerr
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sp
index|[
literal|0
index|]
operator|.
name|dval
operator|-=
name|sp
index|[
literal|1
index|]
operator|.
name|dval
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|fpcheck
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break ;
case|case
name|_MUL
case|:
name|sp
operator|--
expr_stmt|;
if|if
condition|(
name|TEST2
argument_list|(
name|sp
argument_list|)
operator|!=
name|TWO_DOUBLES
condition|)
name|cast2_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|clrerr
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sp
index|[
literal|0
index|]
operator|.
name|dval
operator|*=
name|sp
index|[
literal|1
index|]
operator|.
name|dval
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|fpcheck
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break ;
case|case
name|_DIV
case|:
name|sp
operator|--
expr_stmt|;
if|if
condition|(
name|TEST2
argument_list|(
name|sp
argument_list|)
operator|!=
name|TWO_DOUBLES
condition|)
name|cast2_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NOINFO_SIGFPE
name|CHECK_DIVZERO
argument_list|(
name|sp
index|[
literal|1
index|]
operator|.
name|dval
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|SW_FP_CHECK
name|clrerr
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sp
index|[
literal|0
index|]
operator|.
name|dval
operator|/=
name|sp
index|[
literal|1
index|]
operator|.
name|dval
expr_stmt|;
if|#
directive|if
name|SW_FP_CHECK
name|fpcheck
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break ;
case|case
name|_MOD
case|:
name|sp
operator|--
expr_stmt|;
if|if
condition|(
name|TEST2
argument_list|(
name|sp
argument_list|)
operator|!=
name|TWO_DOUBLES
condition|)
name|cast2_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NOINFO_SIGFPE
name|CHECK_DIVZERO
argument_list|(
name|sp
index|[
literal|1
index|]
operator|.
name|dval
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sp
index|[
literal|0
index|]
operator|.
name|dval
operator|=
name|fmod
argument_list|(
name|sp
index|[
literal|0
index|]
operator|.
name|dval
argument_list|,
name|sp
index|[
literal|1
index|]
operator|.
name|dval
argument_list|)
expr_stmt|;
break|break ;
case|case
name|_POW
case|:
name|sp
operator|--
expr_stmt|;
if|if
condition|(
name|TEST2
argument_list|(
name|sp
argument_list|)
operator|!=
name|TWO_DOUBLES
condition|)
name|cast2_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
index|[
literal|0
index|]
operator|.
name|dval
operator|=
name|pow
argument_list|(
name|sp
index|[
literal|0
index|]
operator|.
name|dval
argument_list|,
name|sp
index|[
literal|1
index|]
operator|.
name|dval
argument_list|)
expr_stmt|;
break|break ;
case|case
name|_NOT
case|:
name|reswitch_1
label|:
switch|switch
condition|(
name|sp
operator|->
name|type
condition|)
block|{
case|case
name|C_NOINIT
case|:
name|sp
operator|->
name|dval
operator|=
literal|1.0
expr_stmt|;
break|break ;
case|case
name|C_DOUBLE
case|:
name|sp
operator|->
name|dval
operator|=
name|D2BOOL
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
condition|?
literal|0.0
else|:
literal|1.0
expr_stmt|;
break|break ;
case|case
name|C_STRING
case|:
name|sp
operator|->
name|dval
operator|=
name|string
argument_list|(
name|sp
argument_list|)
operator|->
name|len
condition|?
literal|0.0
else|:
literal|1.0
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
break|break ;
case|case
name|C_STRNUM
case|:
comment|/* test as a number */
name|sp
operator|->
name|dval
operator|=
name|D2BOOL
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
condition|?
literal|0.0
else|:
literal|1.0
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
break|break ;
case|case
name|C_MBSTRN
case|:
name|check_strnum
argument_list|(
name|sp
argument_list|)
expr_stmt|;
goto|goto
name|reswitch_1
goto|;
default|default :
name|bozo
argument_list|(
literal|"bad type on eval stack"
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
break|break  ;
case|case
name|_TEST
case|:
name|reswitch_2
label|:
switch|switch
condition|(
name|sp
operator|->
name|type
condition|)
block|{
case|case
name|C_NOINIT
case|:
name|sp
operator|->
name|dval
operator|=
literal|0.0
expr_stmt|;
break|break ;
case|case
name|C_DOUBLE
case|:
name|sp
operator|->
name|dval
operator|=
name|D2BOOL
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
break|break ;
case|case
name|C_STRING
case|:
name|sp
operator|->
name|dval
operator|=
name|string
argument_list|(
name|sp
argument_list|)
operator|->
name|len
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
break|break ;
case|case
name|C_STRNUM
case|:
comment|/* test as a number */
name|sp
operator|->
name|dval
operator|=
name|D2BOOL
argument_list|(
name|sp
operator|->
name|dval
argument_list|)
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
break|break ;
case|case
name|C_MBSTRN
case|:
name|check_strnum
argument_list|(
name|sp
argument_list|)
expr_stmt|;
goto|goto
name|reswitch_2
goto|;
default|default :
name|bozo
argument_list|(
literal|"bad type on eval stack"
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
break|break ;
case|case
name|_UMINUS
case|:
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
operator|-
name|sp
operator|->
name|dval
expr_stmt|;
break|break ;
case|case
name|_UPLUS
case|:
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break ;
case|case
name|_CAT
case|:
block|{
name|unsigned
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|char
modifier|*
name|str1
decl_stmt|,
modifier|*
name|str2
decl_stmt|;
name|STRING
modifier|*
name|b
decl_stmt|;
name|sp
operator|--
expr_stmt|;
if|if
condition|(
name|TEST2
argument_list|(
name|sp
argument_list|)
operator|!=
name|TWO_STRINGS
condition|)
name|cast2_to_s
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|str1
operator|=
name|string
argument_list|(
name|sp
argument_list|)
operator|->
name|str
expr_stmt|;
name|len1
operator|=
name|string
argument_list|(
name|sp
argument_list|)
operator|->
name|len
expr_stmt|;
name|str2
operator|=
name|string
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
operator|->
name|str
expr_stmt|;
name|len2
operator|=
name|string
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
operator|->
name|len
expr_stmt|;
name|b
operator|=
name|new_STRING
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|len1
operator|+
name|len2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|b
operator|->
name|str
argument_list|,
name|str1
argument_list|,
name|SIZE_T
argument_list|(
name|len1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|b
operator|->
name|str
operator|+
name|len1
argument_list|,
name|str2
argument_list|,
name|SIZE_T
argument_list|(
name|len2
argument_list|)
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|b
expr_stmt|;
break|break ;
block|}
case|case
name|_PUSHINT
case|:
name|inc_sp
argument_list|()
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|cdp
operator|++
operator|->
name|op
expr_stmt|;
break|break ;
case|case
name|_BUILTIN
case|:
case|case
name|_PRINT
case|:
name|sp
operator|=
operator|(
operator|*
operator|(
name|PF_CP
operator|)
name|cdp
operator|++
operator|->
name|ptr
operator|)
operator|(
name|sp
operator|)
expr_stmt|;
break|break ;
case|case
name|_POST_INC
case|:
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|sp
argument_list|,
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
name|sp
operator|->
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|dval
operator|+=
literal|1.0
expr_stmt|;
break|break ;
case|case
name|_POST_DEC
case|:
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|sp
argument_list|,
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
name|sp
operator|->
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|dval
operator|-=
literal|1.0
expr_stmt|;
break|break ;
case|case
name|_PRE_INC
case|:
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
name|sp
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|cp
operator|->
name|dval
operator|+=
literal|1.0
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
break|break ;
case|case
name|_PRE_DEC
case|:
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
name|sp
operator|->
name|ptr
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|cp
operator|->
name|dval
operator|-=
literal|1.0
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
break|break ;
case|case
name|F_POST_INC
case|:
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
name|sp
operator|->
name|ptr
expr_stmt|;
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|sp
argument_list|,
name|cellcpy
argument_list|(
operator|&
name|tc
argument_list|,
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cast1_to_d
argument_list|(
operator|&
name|tc
argument_list|)
expr_stmt|;
name|tc
operator|.
name|dval
operator|+=
literal|1.0
expr_stmt|;
name|field_assign
argument_list|(
name|cp
argument_list|,
operator|&
name|tc
argument_list|)
expr_stmt|;
break|break ;
case|case
name|F_POST_DEC
case|:
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
name|sp
operator|->
name|ptr
expr_stmt|;
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|sp
argument_list|,
name|cellcpy
argument_list|(
operator|&
name|tc
argument_list|,
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cast1_to_d
argument_list|(
operator|&
name|tc
argument_list|)
expr_stmt|;
name|tc
operator|.
name|dval
operator|-=
literal|1.0
expr_stmt|;
name|field_assign
argument_list|(
name|cp
argument_list|,
operator|&
name|tc
argument_list|)
expr_stmt|;
break|break ;
case|case
name|F_PRE_INC
case|:
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
name|sp
operator|->
name|ptr
expr_stmt|;
name|cast1_to_d
argument_list|(
name|cellcpy
argument_list|(
operator|&
name|tc
argument_list|,
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|tc
operator|.
name|dval
operator|+=
literal|1.0
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|field_assign
argument_list|(
name|cp
argument_list|,
name|sp
argument_list|)
expr_stmt|;
break|break ;
case|case
name|F_PRE_DEC
case|:
name|cp
operator|=
operator|(
name|CELL
operator|*
operator|)
name|sp
operator|->
name|ptr
expr_stmt|;
name|cast1_to_d
argument_list|(
name|cellcpy
argument_list|(
operator|&
name|tc
argument_list|,
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|tc
operator|.
name|dval
operator|-=
literal|1.0
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|field_assign
argument_list|(
name|cp
argument_list|,
name|sp
argument_list|)
expr_stmt|;
break|break ;
case|case
name|_JMP
case|:
name|cdp
operator|+=
name|cdp
operator|->
name|op
expr_stmt|;
break|break ;
case|case
name|_JNZ
case|:
comment|/* jmp if top of stack is non-zero and pop stack */
if|if
condition|(
name|test
argument_list|(
name|sp
argument_list|)
condition|)
name|cdp
operator|+=
name|cdp
operator|->
name|op
expr_stmt|;
else|else
name|cdp
operator|++
expr_stmt|;
name|cell_destroy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|--
expr_stmt|;
break|break ;
case|case
name|_JZ
case|:
comment|/* jmp if top of stack is zero and pop stack */
if|if
condition|(
operator|!
name|test
argument_list|(
name|sp
argument_list|)
condition|)
name|cdp
operator|+=
name|cdp
operator|->
name|op
expr_stmt|;
else|else
name|cdp
operator|++
expr_stmt|;
name|cell_destroy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|--
expr_stmt|;
break|break ;
comment|/*  the relation operations */
comment|/*  compare() makes sure string ref counts are OK */
case|case
name|_EQ
case|:
name|t
operator|=
name|compare
argument_list|(
operator|--
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|t
operator|==
literal|0
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
break|break ;
case|case
name|_NEQ
case|:
name|t
operator|=
name|compare
argument_list|(
operator|--
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|t
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
break|break ;
case|case
name|_LT
case|:
name|t
operator|=
name|compare
argument_list|(
operator|--
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|t
operator|<
literal|0
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
break|break ;
case|case
name|_LTE
case|:
name|t
operator|=
name|compare
argument_list|(
operator|--
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|t
operator|<=
literal|0
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
break|break ;
case|case
name|_GT
case|:
name|t
operator|=
name|compare
argument_list|(
operator|--
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|t
operator|>
literal|0
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
break|break ;
case|case
name|_GTE
case|:
name|t
operator|=
name|compare
argument_list|(
operator|--
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|t
operator|>=
literal|0
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
break|break ;
case|case
name|_MATCH0
case|:
comment|/* does $0 match, the RE at cdp */
name|inc_sp
argument_list|()
expr_stmt|;
if|if
condition|(
name|field
operator|->
name|type
operator|>=
name|C_STRING
condition|)
block|{
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|REtest
argument_list|(
name|string
argument_list|(
name|field
argument_list|)
operator|->
name|str
argument_list|,
name|cdp
operator|++
operator|->
name|ptr
argument_list|)
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
break|break
comment|/* the case */
break|;
block|}
else|else
block|{
name|cellcpy
argument_list|(
name|sp
argument_list|,
name|field
argument_list|)
expr_stmt|;
comment|/* and FALL THRU */
block|}
case|case
name|_MATCH1
case|:
comment|/* does expr at sp[0] match RE at cdp */
if|if
condition|(
name|sp
operator|->
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|t
operator|=
name|REtest
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
operator|->
name|str
argument_list|,
name|cdp
operator|++
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|t
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
break|break ;
case|case
name|_MATCH2
case|:
comment|/* does sp[-1] match sp[0] as re */
name|cast_to_RE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|--
name|sp
operator|)
operator|->
name|type
operator|<
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|t
operator|=
name|REtest
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
operator|->
name|str
argument_list|,
operator|(
name|sp
operator|+
literal|1
operator|)
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
name|t
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
break|break ;
case|case
name|A_TEST
case|:
comment|/* entry :  sp[0].ptr-> an array                     sp[-1]  is an expression             we compute   expression in array  */
name|sp
operator|--
expr_stmt|;
name|cp
operator|=
name|array_find
argument_list|(
operator|(
name|sp
operator|+
literal|1
operator|)
operator|->
name|ptr
argument_list|,
name|sp
argument_list|,
name|NO_CREATE
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_DOUBLE
expr_stmt|;
name|sp
operator|->
name|dval
operator|=
operator|(
name|cp
operator|!=
operator|(
name|CELL
operator|*
operator|)
literal|0
operator|)
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
break|break ;
case|case
name|A_DEL
case|:
comment|/* sp[0].ptr ->  array            sp[-1] is an expr            delete  array[expr]  */
name|array_delete
argument_list|(
name|sp
operator|->
name|ptr
argument_list|,
name|sp
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|sp
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|-=
literal|2
expr_stmt|;
break|break ;
comment|/* form a multiple array index */
case|case
name|A_CAT
case|:
name|sp
operator|=
name|array_cat
argument_list|(
name|sp
argument_list|,
name|cdp
operator|++
operator|->
name|op
argument_list|)
expr_stmt|;
break|break ;
case|case
name|_EXIT
case|:
if|if
condition|(
name|sp
operator|->
name|type
operator|!=
name|C_DOUBLE
condition|)
name|cast1_to_d
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|exit_code
operator|=
operator|(
name|int
operator|)
name|sp
operator|--
operator|->
name|dval
expr_stmt|;
comment|/* fall thru */
case|case
name|_EXIT0
case|:
if|if
condition|(
operator|!
operator|(
name|cdp
operator|=
name|end_code
operator|.
name|start
operator|)
condition|)
name|mawk_exit
argument_list|(
name|exit_code
argument_list|)
expr_stmt|;
name|end_code
operator|.
name|start
operator|=
operator|(
name|INST
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* makes sure next exit exits */
if|if
condition|(
name|begin_code
operator|.
name|start
condition|)
name|zfree
argument_list|(
name|begin_code
operator|.
name|start
argument_list|,
name|begin_code
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|main_start
condition|)
name|zfree
argument_list|(
name|main_start
argument_list|,
name|main_size
argument_list|)
expr_stmt|;
name|sp
operator|=
name|eval_stack
operator|-
literal|1
expr_stmt|;
comment|/* might be in user function */
break|break ;
case|case
name|_JMAIN
case|:
comment|/* go from BEGIN code to MAIN code */
name|zfree
argument_list|(
name|begin_code
operator|.
name|start
argument_list|,
name|begin_code
operator|.
name|size
argument_list|)
expr_stmt|;
name|begin_code
operator|.
name|start
operator|=
operator|(
name|INST
operator|*
operator|)
literal|0
expr_stmt|;
name|cdp
operator|=
name|main_start
expr_stmt|;
break|break ;
case|case
name|_OMAIN
case|:
if|if
condition|(
operator|!
name|main_fin
condition|)
name|open_main
argument_list|()
expr_stmt|;
name|restart_label
operator|=
name|cdp
expr_stmt|;
name|cdp
operator|=
name|next_label
expr_stmt|;
break|break ;
case|case
name|_NEXT
case|:
name|cdp
operator|=
name|next_label
expr_stmt|;
break|break ;
case|case
name|OL_GL
case|:
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|FINgets
argument_list|(
name|main_fin
argument_list|,
operator|&
name|len
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|end_code
operator|.
name|start
condition|)
name|mawk_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cdp
operator|=
name|end_code
operator|.
name|start
expr_stmt|;
name|zfree
argument_list|(
name|main_start
argument_list|,
name|main_size
argument_list|)
expr_stmt|;
name|main_start
operator|=
name|end_code
operator|.
name|start
operator|=
operator|(
name|INST
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|set_field0
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cdp
operator|=
name|restart_label
expr_stmt|;
block|}
block|}
break|break ;
case|case
name|OL_GL_NR
case|:
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|FINgets
argument_list|(
name|main_fin
argument_list|,
operator|&
name|len
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|end_code
operator|.
name|start
condition|)
name|mawk_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cdp
operator|=
name|end_code
operator|.
name|start
expr_stmt|;
name|zfree
argument_list|(
name|main_start
argument_list|,
name|main_size
argument_list|)
expr_stmt|;
name|main_start
operator|=
name|end_code
operator|.
name|start
operator|=
operator|(
name|INST
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|set_field0
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cdp
operator|=
name|restart_label
expr_stmt|;
if|if
condition|(
name|TEST2
argument_list|(
name|NR
argument_list|)
operator|!=
name|TWO_DOUBLES
condition|)
name|cast2_to_d
argument_list|(
name|NR
argument_list|)
expr_stmt|;
name|NR
operator|->
name|dval
operator|+=
literal|1.0
expr_stmt|;
name|FNR
operator|->
name|dval
operator|+=
literal|1.0
expr_stmt|;
block|}
block|}
break|break ;
case|case
name|_RANGE
case|:
comment|/* test a range pattern:  pat1, pat2 { action }    entry :        cdp[0].op -- a flag, test pat1 if on else pat2        cdp[1].op -- offset of pat2 code from cdp        cdp[2].op -- offset of action code from cdp        cdp[3].op -- offset of code after the action from cdp        cdp[4] -- start of pat1 code */
define|#
directive|define
name|FLAG
value|cdp[0].op
define|#
directive|define
name|PAT2
value|cdp[1].op
define|#
directive|define
name|ACTION
value|cdp[2].op
define|#
directive|define
name|FOLLOW
value|cdp[3].op
define|#
directive|define
name|PAT1
value|4
if|if
condition|(
name|FLAG
condition|)
comment|/* test again pat1 */
block|{
name|execute
argument_list|(
name|cdp
operator|+
name|PAT1
argument_list|,
name|sp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|t
operator|=
name|test
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|FLAG
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|cdp
operator|+=
name|FOLLOW
expr_stmt|;
break|break ;
comment|/* break the switch */
block|}
block|}
comment|/* test against pat2 and then perform the action */
name|execute
argument_list|(
name|cdp
operator|+
name|PAT2
argument_list|,
name|sp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|FLAG
operator|=
name|test
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cdp
operator|+=
name|ACTION
expr_stmt|;
break|break ;
comment|/* function calls  */
case|case
name|_RET0
case|:
name|inc_sp
argument_list|()
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|C_NOINIT
expr_stmt|;
comment|/* fall thru */
case|case
name|_RET
case|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|sp
operator|!=
name|entry_sp
operator|+
literal|1
condition|)
name|bozo
argument_list|(
literal|"ret"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|old_stack_base
condition|)
comment|/* reset stack */
block|{
comment|/* move the return value */
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
name|old_sp
operator|+
literal|1
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|stack_base
argument_list|,
sizeof|sizeof
argument_list|(
name|CELL
argument_list|)
operator|*
name|EVAL_STACK_SIZE
argument_list|)
expr_stmt|;
name|stack_base
operator|=
name|old_stack_base
expr_stmt|;
name|stack_danger
operator|=
name|old_stack_base
operator|+
name|DANGER
expr_stmt|;
block|}
return|return  ;
case|case
name|_CALL
case|:
block|{
name|FBLOCK
modifier|*
name|fbp
init|=
operator|(
name|FBLOCK
operator|*
operator|)
name|cdp
operator|++
operator|->
name|ptr
decl_stmt|;
name|int
name|a_args
init|=
name|cdp
operator|++
operator|->
name|op
decl_stmt|;
comment|/* actual number of args */
name|CELL
modifier|*
name|nfp
init|=
name|sp
operator|-
name|a_args
operator|+
literal|1
decl_stmt|;
comment|/* new fp for callee */
name|CELL
modifier|*
name|local_p
init|=
name|sp
operator|+
literal|1
decl_stmt|;
comment|/* first local argument on stack */
name|char
modifier|*
name|type_p
decl_stmt|;
comment|/* pts to type of an argument */
if|if
condition|(
name|fbp
operator|->
name|nargs
condition|)
name|type_p
operator|=
name|fbp
operator|->
name|typev
operator|+
name|a_args
expr_stmt|;
comment|/* create space for locals */
if|if
condition|(
name|t
operator|=
name|fbp
operator|->
name|nargs
operator|-
name|a_args
condition|)
comment|/* have local args */
block|{
while|while
condition|(
name|t
operator|--
condition|)
block|{
operator|(
operator|++
name|sp
operator|)
operator|->
name|type
operator|=
name|C_NOINIT
expr_stmt|;
if|if
condition|(
operator|*
name|type_p
operator|++
operator|==
name|ST_LOCAL_ARRAY
condition|)
name|sp
operator|->
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|new_ARRAY
argument_list|()
expr_stmt|;
block|}
block|}
name|type_p
operator|--
expr_stmt|;
comment|/* *type_p is type of last arg */
name|execute
argument_list|(
name|fbp
operator|->
name|code
argument_list|,
name|sp
argument_list|,
name|nfp
argument_list|)
expr_stmt|;
comment|/* cleanup the callee's arguments */
if|if
condition|(
name|sp
operator|>=
name|nfp
condition|)
block|{
name|cp
operator|=
name|sp
operator|+
literal|1
expr_stmt|;
comment|/* cp -> the function return */
do|do
block|{
if|if
condition|(
operator|*
name|type_p
operator|--
operator|==
name|ST_LOCAL_ARRAY
condition|)
block|{
if|if
condition|(
name|sp
operator|>=
name|local_p
condition|)
name|array_free
argument_list|(
name|sp
operator|->
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
name|cell_destroy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|sp
operator|>=
name|nfp
condition|)
do|;
operator|(
name|void
operator|)
name|cellcpy
argument_list|(
operator|++
name|sp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cell_destroy
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
name|sp
operator|++
expr_stmt|;
comment|/* no arguments passed */
block|}
break|break ;
default|default :
name|bozo
argument_list|(
literal|"bad opcode"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|test
parameter_list|(
name|cp
parameter_list|)
comment|/* test if a cell is null or not */
specifier|register
name|CELL
modifier|*
name|cp
decl_stmt|;
block|{
name|reswitch
label|:
switch|switch
condition|(
name|cp
operator|->
name|type
condition|)
block|{
case|case
name|C_NOINIT
case|:
return|return
literal|0
return|;
case|case
name|C_STRNUM
case|:
comment|/* test as a number */
case|case
name|C_DOUBLE
case|:
return|return
name|cp
operator|->
name|dval
operator|!=
literal|0.0
return|;
case|case
name|C_STRING
case|:
return|return
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|len
return|;
case|case
name|C_MBSTRN
case|:
name|check_strnum
argument_list|(
name|cp
argument_list|)
expr_stmt|;
goto|goto
name|reswitch
goto|;
default|default :
name|bozo
argument_list|(
literal|"bad cell type in call to test"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* compare cells at cp and cp+1 and    frees STRINGs at those cells */
end_comment

begin_function
specifier|static
name|int
name|compare
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|CELL
modifier|*
name|cp
decl_stmt|;
block|{
name|int
name|k
decl_stmt|;
name|CELL
modifier|*
name|dp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|reswitch
label|:
switch|switch
condition|(
name|TEST2
argument_list|(
name|cp
argument_list|)
condition|)
block|{
case|case
name|TWO_NOINITS
case|:
return|return
literal|0
return|;
case|case
name|TWO_DOUBLES
case|:
name|two_d
label|:
return|return
name|cp
operator|->
name|dval
operator|>
operator|(
name|cp
operator|+
literal|1
operator|)
operator|->
name|dval
condition|?
literal|1
else|:
name|cp
operator|->
name|dval
operator|<
operator|(
name|cp
operator|+
literal|1
operator|)
operator|->
name|dval
condition|?
operator|-
literal|1
else|:
literal|0
return|;
case|case
name|TWO_STRINGS
case|:
name|k
operator|=
name|strcmp
argument_list|(
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|str
argument_list|,
name|string
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
operator|->
name|str
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|free_STRING
argument_list|(
name|string
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|k
return|;
case|case
name|STRING_AND_STRNUM
case|:
comment|/* posix numeric string bozosity */
case|case
name|NOINIT_AND_STRING
case|:
case|case
name|DOUBLE_AND_STRING
case|:
if|if
condition|(
name|cp
operator|->
name|type
operator|==
name|C_STRING
condition|)
block|{
name|sp
operator|=
name|cp
expr_stmt|;
name|dp
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dp
operator|=
name|cp
expr_stmt|;
name|sp
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
name|check_strnum
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|type
operator|==
name|C_STRING
condition|)
name|cast1_to_s
argument_list|(
name|dp
argument_list|)
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|NOINIT_AND_DOUBLE
case|:
case|case
name|NOINIT_AND_STRNUM
case|:
case|case
name|DOUBLE_AND_STRNUM
case|:
case|case
name|TWO_STRNUMS
case|:
name|cast2_to_d
argument_list|(
name|cp
argument_list|)
expr_stmt|;
goto|goto
name|two_d
goto|;
case|case
name|TWO_MBSTRNS
case|:
name|check_strnum
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|check_strnum
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|reswitch
goto|;
case|case
name|NOINIT_AND_MBSTRN
case|:
case|case
name|DOUBLE_AND_MBSTRN
case|:
case|case
name|STRING_AND_MBSTRN
case|:
case|case
name|STRNUM_AND_MBSTRN
case|:
name|check_strnum
argument_list|(
name|cp
operator|->
name|type
operator|==
name|C_MBSTRN
condition|?
name|cp
else|:
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|reswitch
goto|;
default|default :
comment|/* there are no default cases */
name|bozo
argument_list|(
literal|"bad cell type passed to compare"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* does not assume target was a cell, if so    then caller should have made a previous    call to cell_destroy  */
end_comment

begin_function
name|CELL
modifier|*
name|cellcpy
parameter_list|(
name|target
parameter_list|,
name|source
parameter_list|)
specifier|register
name|CELL
modifier|*
name|target
decl_stmt|,
decl|*
name|source
decl_stmt|;
end_function

begin_block
block|{
switch|switch
condition|(
name|target
operator|->
name|type
operator|=
name|source
operator|->
name|type
condition|)
block|{
case|case
name|C_NOINIT
case|:
case|case
name|C_SPACE
case|:
case|case
name|C_SNULL
case|:
break|break ;
case|case
name|C_DOUBLE
case|:
name|target
operator|->
name|dval
operator|=
name|source
operator|->
name|dval
expr_stmt|;
break|break ;
case|case
name|C_STRNUM
case|:
name|target
operator|->
name|dval
operator|=
name|source
operator|->
name|dval
expr_stmt|;
comment|/* fall thru */
case|case
name|C_REPL
case|:
case|case
name|C_MBSTRN
case|:
case|case
name|C_STRING
case|:
name|string
argument_list|(
name|source
argument_list|)
operator|->
name|ref_cnt
operator|++
expr_stmt|;
comment|/* fall thru */
case|case
name|C_RE
case|:
name|target
operator|->
name|ptr
operator|=
name|source
operator|->
name|ptr
expr_stmt|;
break|break ;
case|case
name|C_REPLV
case|:
operator|(
name|void
operator|)
name|replv_cpy
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
expr_stmt|;
break|break ;
default|default :
name|bozo
argument_list|(
literal|"bad cell passed to cellcpy()"
argument_list|)
expr_stmt|;
break|break ;
block|}
return|return
name|target
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|void
name|DB_cell_destroy
parameter_list|(
name|cp
parameter_list|)
comment|/* HANGOVER time */
specifier|register
name|CELL
modifier|*
name|cp
decl_stmt|;
block|{
switch|switch
condition|(
name|cp
operator|->
name|type
condition|)
block|{
case|case
name|C_NOINIT
case|:
case|case
name|C_DOUBLE
case|:
break|break ;
case|case
name|C_MBSTRN
case|:
case|case
name|C_STRING
case|:
case|case
name|C_STRNUM
case|:
if|if
condition|(
operator|--
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|ref_cnt
operator|==
literal|0
condition|)
name|zfree
argument_list|(
name|string
argument_list|(
name|cp
argument_list|)
argument_list|,
name|string
argument_list|(
name|cp
argument_list|)
operator|->
name|len
operator|+
name|STRING_OH
argument_list|)
expr_stmt|;
break|break ;
case|case
name|C_RE
case|:
name|bozo
argument_list|(
literal|"cell destroy called on RE cell"
argument_list|)
expr_stmt|;
default|default :
name|bozo
argument_list|(
literal|"cell destroy called on bad cell type"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

