begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  * Modified 1990 by Van Jacobson at Lawrence Berkeley Laboratory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)values.c	6.3 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Low level packing and unpacking of values for GDB.    Copyright (C) 1986, 1987, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_comment
comment|/* The value-history records all the values printed    by print commands during this session.  Each chunk    records 60 consecutive values.  The first chunk on    the chain records the most recent values.    The total number of values is in value_history_count.  */
end_comment

begin_define
define|#
directive|define
name|VALUE_HISTORY_CHUNK
value|60
end_define

begin_struct
struct|struct
name|value_history_chunk
block|{
name|struct
name|value_history_chunk
modifier|*
name|next
decl_stmt|;
name|value
name|values
index|[
name|VALUE_HISTORY_CHUNK
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Chain of chunks now in use.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|value_history_chunk
modifier|*
name|value_history_chain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|value_history_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Abs number of last entry stored */
end_comment

begin_escape
end_escape

begin_comment
comment|/* List of all value objects currently allocated    (except for those released by calls to release_value)    This is so they can be freed after each command.  */
end_comment

begin_decl_stmt
specifier|static
name|value
name|all_values
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate a  value  that has the correct length for type TYPE.  */
end_comment

begin_function
name|value
name|allocate_value
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
specifier|register
name|value
name|val
decl_stmt|;
comment|/* If the type we want had no definition in the file it first    * appeared in, it will be marked a `stub'.  The real definition    * probably appeared later so try to find it. */
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_STUB
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
literal|' '
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
else|else
name|cp
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|&&
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
name|bcopy
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|type
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
operator|(
name|value
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
operator|+
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_NEXT
argument_list|(
name|val
argument_list|)
operator|=
name|all_values
expr_stmt|;
name|all_values
operator|=
name|val
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|type
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|not_lval
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_FRAME
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_BITPOS
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_BITSIZE
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_REPEATED
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_REPETITIONS
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_REGNO
argument_list|(
name|val
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Allocate a  value  that has the correct length    for COUNT repetitions type TYPE.  */
end_comment

begin_function
name|value
name|allocate_repeat_value
parameter_list|(
name|type
parameter_list|,
name|count
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|value
name|val
decl_stmt|;
name|val
operator|=
operator|(
name|value
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|value
argument_list|)
operator|+
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|VALUE_NEXT
argument_list|(
name|val
argument_list|)
operator|=
name|all_values
expr_stmt|;
name|all_values
operator|=
name|val
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|type
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|not_lval
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_FRAME
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_BITPOS
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_BITSIZE
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VALUE_REPEATED
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
name|VALUE_REPETITIONS
argument_list|(
name|val
argument_list|)
operator|=
name|count
expr_stmt|;
name|VALUE_REGNO
argument_list|(
name|val
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Free all the values that have been allocated (except for those released).    Called after each command, successful or not.  */
end_comment

begin_function
name|void
name|free_all_values
parameter_list|()
block|{
specifier|register
name|value
name|val
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|val
operator|=
name|all_values
init|;
name|val
condition|;
name|val
operator|=
name|next
control|)
block|{
name|next
operator|=
name|VALUE_NEXT
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
name|all_values
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove VAL from the chain all_values    so it will not be freed automatically.  */
end_comment

begin_function
name|void
name|release_value
parameter_list|(
name|val
parameter_list|)
specifier|register
name|value
name|val
decl_stmt|;
block|{
specifier|register
name|value
name|v
decl_stmt|;
if|if
condition|(
name|all_values
operator|==
name|val
condition|)
block|{
name|all_values
operator|=
name|val
operator|->
name|next
expr_stmt|;
return|return;
block|}
for|for
control|(
name|v
operator|=
name|all_values
init|;
name|v
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
if|if
condition|(
name|v
operator|->
name|next
operator|==
name|val
condition|)
block|{
name|v
operator|->
name|next
operator|=
name|val
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return a copy of the value ARG.    It contains the same contents, for same memory address,    but it's a different block of storage.  */
end_comment

begin_function
specifier|static
name|value
name|value_copy
parameter_list|(
name|arg
parameter_list|)
name|value
name|arg
decl_stmt|;
block|{
specifier|register
name|value
name|val
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|VALUE_REPEATED
argument_list|(
name|arg
argument_list|)
condition|)
name|val
operator|=
name|allocate_repeat_value
argument_list|(
name|type
argument_list|,
name|VALUE_REPETITIONS
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_LVAL
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_ADDRESS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_OFFSET
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_BITPOS
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_BITPOS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_BITSIZE
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_BITSIZE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_REGNO
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_REGNO
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|*
operator|(
name|VALUE_REPEATED
argument_list|(
name|arg
argument_list|)
condition|?
name|VALUE_REPETITIONS
argument_list|(
name|arg
argument_list|)
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Access to the value history.  */
end_comment

begin_comment
comment|/* Record a new value in the value history.    Returns the absolute history index of the entry.  */
end_comment

begin_function
name|int
name|record_latest_value
parameter_list|(
name|val
parameter_list|)
name|value
name|val
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|double
name|foo
decl_stmt|;
comment|/* Check error now if about to store an invalid float.  We return -1      to the caller, but allow them to continue, e.g. to print it as "Nan". */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|foo
operator|=
name|unpack_double
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Indicate value not saved in history */
block|}
comment|/* Here we treat value_history_count as origin-zero      and applying to the value being stored now.  */
name|i
operator|=
name|value_history_count
operator|%
name|VALUE_HISTORY_CHUNK
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
specifier|register
name|struct
name|value_history_chunk
modifier|*
name|new
init|=
operator|(
expr|struct
name|value_history_chunk
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|value_history_chunk
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|new
operator|->
name|values
argument_list|,
sizeof|sizeof
name|new
operator|->
name|values
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|value_history_chain
expr_stmt|;
name|value_history_chain
operator|=
name|new
expr_stmt|;
block|}
name|value_history_chain
operator|->
name|values
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
name|release_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Now we regard value_history_count as origin-one      and applying to the value just stored.  */
return|return
operator|++
name|value_history_count
return|;
block|}
end_function

begin_comment
comment|/* Return a copy of the value in the history with sequence number NUM.  */
end_comment

begin_function
name|value
name|access_value_history
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
specifier|register
name|struct
name|value_history_chunk
modifier|*
name|chunk
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|absnum
init|=
name|num
decl_stmt|;
if|if
condition|(
name|absnum
operator|<=
literal|0
condition|)
name|absnum
operator|+=
name|value_history_count
expr_stmt|;
if|if
condition|(
name|absnum
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|num
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"The history is empty."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|==
literal|1
condition|)
name|error
argument_list|(
literal|"There is only one value in the history."
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"History does not go back to $$%d."
argument_list|,
operator|-
name|num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|absnum
operator|>
name|value_history_count
condition|)
name|error
argument_list|(
literal|"History has not yet reached $%d."
argument_list|,
name|absnum
argument_list|)
expr_stmt|;
name|absnum
operator|--
expr_stmt|;
comment|/* Now absnum is always absolute and origin zero.  */
name|chunk
operator|=
name|value_history_chain
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|value_history_count
operator|-
literal|1
operator|)
operator|/
name|VALUE_HISTORY_CHUNK
operator|-
name|absnum
operator|/
name|VALUE_HISTORY_CHUNK
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|chunk
operator|=
name|chunk
operator|->
name|next
expr_stmt|;
return|return
name|value_copy
argument_list|(
name|chunk
operator|->
name|values
index|[
name|absnum
operator|%
name|VALUE_HISTORY_CHUNK
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Clear the value history entirely.    Must be done when new symbol tables are loaded,    because the type pointers become invalid.  */
end_comment

begin_function
name|void
name|clear_value_history
parameter_list|()
block|{
specifier|register
name|struct
name|value_history_chunk
modifier|*
name|next
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|value
name|val
decl_stmt|;
while|while
condition|(
name|value_history_chain
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VALUE_HISTORY_CHUNK
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|val
operator|=
name|value_history_chain
operator|->
name|values
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|next
operator|=
name|value_history_chain
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|value_history_chain
argument_list|)
expr_stmt|;
name|value_history_chain
operator|=
name|next
expr_stmt|;
block|}
name|value_history_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|value_history_info
parameter_list|(
name|num_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|num_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|value
name|val
decl_stmt|;
specifier|static
name|int
name|num
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|num_exp
condition|)
block|{
if|if
condition|(
name|num_exp
index|[
literal|0
index|]
operator|==
literal|'+'
operator|&&
name|num_exp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
comment|/* "info history +" should print from the stored position.  */
empty_stmt|;
else|else
comment|/* "info history<exp>" should print around value number<exp>.  */
name|num
operator|=
name|parse_and_eval_address
argument_list|(
name|num_exp
argument_list|)
operator|-
literal|5
expr_stmt|;
block|}
else|else
block|{
comment|/* "info history" means print the last 10 values.  */
name|num
operator|=
name|value_history_count
operator|-
literal|9
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
name|num
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|num
init|;
name|i
operator|<
name|num
operator|+
literal|10
operator|&&
name|i
operator|<=
name|value_history_count
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|access_value_history
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"$%d = "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|val
argument_list|,
name|stdout
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* The next "info history +" should start after what we just printed.  */
name|num
operator|+=
literal|10
expr_stmt|;
comment|/* Hitting just return after this command should do the same thing as      "info history +".  If num_exp is null, this is unnecessary, since      "info history +" is not useful after "info history".  */
if|if
condition|(
name|from_tty
operator|&&
name|num_exp
condition|)
block|{
name|num_exp
index|[
literal|0
index|]
operator|=
literal|'+'
expr_stmt|;
name|num_exp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Internal variables.  These are variables within the debugger    that hold values assigned by debugger commands.    The user refers to them with a '$' prefix    that does not appear in the variable names stored internally.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|internalvar
modifier|*
name|internalvars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Look up an internal variable with name NAME.  NAME should not    normally include a dollar sign.     If the specified internal variable does not exist,    one is created, with a void value.  */
end_comment

begin_function
name|struct
name|internalvar
modifier|*
name|lookup_internalvar
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
for|for
control|(
name|var
operator|=
name|internalvars
init|;
name|var
condition|;
name|var
operator|=
name|var
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|var
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|var
return|;
name|var
operator|=
operator|(
expr|struct
name|internalvar
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|internalvar
argument_list|)
argument_list|)
expr_stmt|;
name|var
operator|->
name|name
operator|=
name|concat
argument_list|(
name|name
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|var
operator|->
name|value
operator|=
name|allocate_value
argument_list|(
name|builtin_type_void
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|var
operator|->
name|next
operator|=
name|internalvars
expr_stmt|;
name|internalvars
operator|=
name|var
expr_stmt|;
return|return
name|var
return|;
block|}
end_function

begin_function
name|value
name|value_of_internalvar
parameter_list|(
name|var
parameter_list|)
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
block|{
specifier|register
name|value
name|val
decl_stmt|;
ifdef|#
directive|ifdef
name|IS_TRAPPED_INTERNALVAR
if|if
condition|(
name|IS_TRAPPED_INTERNALVAR
argument_list|(
name|var
operator|->
name|name
argument_list|)
condition|)
return|return
name|VALUE_OF_TRAPPED_INTERNALVAR
argument_list|(
name|var
argument_list|)
return|;
endif|#
directive|endif
name|val
operator|=
name|value_copy
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|lval_internalvar
expr_stmt|;
name|VALUE_INTERNALVAR
argument_list|(
name|val
argument_list|)
operator|=
name|var
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|void
name|set_internalvar_component
parameter_list|(
name|var
parameter_list|,
name|offset
parameter_list|,
name|bitpos
parameter_list|,
name|bitsize
parameter_list|,
name|newval
parameter_list|)
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|bitpos
decl_stmt|,
name|bitsize
decl_stmt|;
name|value
name|newval
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|addr
init|=
name|VALUE_CONTENTS
argument_list|(
name|var
operator|->
name|value
argument_list|)
operator|+
name|offset
decl_stmt|;
ifdef|#
directive|ifdef
name|IS_TRAPPED_INTERNALVAR
if|if
condition|(
name|IS_TRAPPED_INTERNALVAR
argument_list|(
name|var
operator|->
name|name
argument_list|)
condition|)
name|SET_TRAPPED_INTERNALVAR
argument_list|(
name|var
argument_list|,
name|newval
argument_list|,
name|bitpos
argument_list|,
name|bitsize
argument_list|,
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bitsize
condition|)
name|modify_field
argument_list|(
name|addr
argument_list|,
operator|(
name|int
operator|)
name|value_as_long
argument_list|(
name|newval
argument_list|)
argument_list|,
name|bitpos
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|newval
argument_list|)
argument_list|,
name|addr
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|newval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_internalvar
parameter_list|(
name|var
parameter_list|,
name|val
parameter_list|)
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
name|value
name|val
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|IS_TRAPPED_INTERNALVAR
if|if
condition|(
name|IS_TRAPPED_INTERNALVAR
argument_list|(
name|var
operator|->
name|name
argument_list|)
condition|)
name|SET_TRAPPED_INTERNALVAR
argument_list|(
name|var
argument_list|,
name|val
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|var
operator|->
name|value
operator|=
name|value_copy
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|release_value
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|internalvar_name
parameter_list|(
name|var
parameter_list|)
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
block|{
return|return
name|var
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/* Free all internalvars.  Done when new symtabs are loaded,    because that makes the values invalid.  */
end_comment

begin_function
name|void
name|clear_internalvars
parameter_list|()
block|{
specifier|register
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
while|while
condition|(
name|internalvars
condition|)
block|{
name|var
operator|=
name|internalvars
expr_stmt|;
name|internalvars
operator|=
name|var
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|var
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|convenience_info
parameter_list|()
block|{
specifier|register
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
name|int
name|varseen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|var
operator|=
name|internalvars
init|;
name|var
condition|;
name|var
operator|=
name|var
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|IS_TRAPPED_INTERNALVAR
if|if
condition|(
name|IS_TRAPPED_INTERNALVAR
argument_list|(
name|var
operator|->
name|name
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
operator|!
name|varseen
condition|)
block|{
name|printf
argument_list|(
literal|"Debugger convenience variables:\n\n"
argument_list|)
expr_stmt|;
name|varseen
operator|=
literal|1
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"$%s: "
argument_list|,
name|var
operator|->
name|name
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|var
operator|->
name|value
argument_list|,
name|stdout
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|varseen
condition|)
name|printf
argument_list|(
literal|"No debugger convenience variables now defined.\n\ Convenience variables have names starting with \"$\";\n\ use \"set\" as in \"set $foo = 5\" to define them.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extract a value as a C number (either long or double).    Knows how to convert fixed values to double, or    floating values to long.    Does not deallocate the value.  */
end_comment

begin_function
name|LONGEST
name|value_as_long
parameter_list|(
name|val
parameter_list|)
specifier|register
name|value
name|val
decl_stmt|;
block|{
return|return
name|unpack_long
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|double
name|value_as_double
parameter_list|(
name|val
parameter_list|)
specifier|register
name|value
name|val
decl_stmt|;
block|{
name|double
name|foo
decl_stmt|;
name|int
name|inv
decl_stmt|;
name|foo
operator|=
name|unpack_double
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
operator|&
name|inv
argument_list|)
expr_stmt|;
if|if
condition|(
name|inv
condition|)
name|error
argument_list|(
literal|"Invalid floating value found in program."
argument_list|)
expr_stmt|;
return|return
name|foo
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Unpack raw data (copied from debugee) at VALADDR    as a long, or as a double, assuming the raw data is described    by type TYPE.  Knows how to convert different sizes of values    and can convert between fixed and floating point.     C++: It is assumed that the front-end has taken care of    all matters concerning pointers to members.  A pointer    to member which reaches here is considered to be equivalent    to an INT (or some size).  After all, it is only an offset.  */
end_comment

begin_function
name|LONGEST
name|unpack_long
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
block|{
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|nosign
init|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_ENUM
condition|)
name|code
operator|=
name|TYPE_CODE_INT
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
return|return
operator|*
operator|(
name|float
operator|*
operator|)
name|valaddr
return|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
return|return
operator|*
operator|(
name|double
operator|*
operator|)
name|valaddr
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_INT
operator|&&
name|nosign
condition|)
block|{
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|)
return|return
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|valaddr
return|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|short
argument_list|)
condition|)
return|return
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|valaddr
return|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
return|return
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|valaddr
return|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
return|return
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|valaddr
return|;
ifdef|#
directive|ifdef
name|LONG_LONG
if|if
condition|(
name|len
operator|==
expr|sizeof
operator|(
name|long
name|long
operator|)
condition|)
return|return
operator|*
operator|(
name|unsigned
name|long
name|long
operator|*
operator|)
name|valaddr
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_INT
condition|)
block|{
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|)
return|return
operator|*
operator|(
name|char
operator|*
operator|)
name|valaddr
return|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|short
argument_list|)
condition|)
return|return
operator|*
operator|(
name|short
operator|*
operator|)
name|valaddr
return|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|valaddr
return|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
return|return
operator|*
operator|(
name|long
operator|*
operator|)
name|valaddr
return|;
ifdef|#
directive|ifdef
name|LONG_LONG
if|if
condition|(
name|len
operator|==
expr|sizeof
operator|(
name|long
name|long
operator|)
condition|)
return|return
operator|*
operator|(
name|long
name|long
operator|*
operator|)
name|valaddr
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_PTR
operator|||
name|code
operator|==
name|TYPE_CODE_REF
condition|)
block|{
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
condition|)
return|return
operator|(
name|CORE_ADDR
operator|)
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|valaddr
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_MEMBER
condition|)
name|error
argument_list|(
literal|"not implemented: member types in unpack_long"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Value not integer or pointer."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a double value from the specified type and address.    INVP points to an int which is set to 0 for valid value,    1 for invalid value (bad float format).  In either case,    the returned double is OK to use.  */
end_comment

begin_function
name|double
name|unpack_double
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|invp
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|int
modifier|*
name|invp
decl_stmt|;
block|{
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|nosign
init|=
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
decl_stmt|;
operator|*
name|invp
operator|=
literal|0
expr_stmt|;
comment|/* Assume valid.   */
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
if|if
condition|(
name|INVALID_FLOAT
argument_list|(
name|valaddr
argument_list|,
name|len
argument_list|)
condition|)
block|{
operator|*
name|invp
operator|=
literal|1
expr_stmt|;
return|return
literal|1.234567891011121314
return|;
block|}
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
return|return
operator|*
operator|(
name|float
operator|*
operator|)
name|valaddr
return|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
block|{
comment|/* Some machines require doubleword alignment for doubles. 	     This code works on them, and on other machines.  */
name|double
name|temp
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|valaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_INT
operator|&&
name|nosign
condition|)
block|{
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|)
return|return
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|valaddr
return|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|short
argument_list|)
condition|)
return|return
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
name|valaddr
return|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
return|return
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|valaddr
return|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
return|return
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|valaddr
return|;
ifdef|#
directive|ifdef
name|LONG_LONG
if|if
condition|(
name|len
operator|==
expr|sizeof
operator|(
name|long
name|long
operator|)
condition|)
return|return
operator|*
operator|(
name|unsigned
name|long
name|long
operator|*
operator|)
name|valaddr
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_INT
condition|)
block|{
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|)
return|return
operator|*
operator|(
name|char
operator|*
operator|)
name|valaddr
return|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|short
argument_list|)
condition|)
return|return
operator|*
operator|(
name|short
operator|*
operator|)
name|valaddr
return|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|valaddr
return|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
return|return
operator|*
operator|(
name|long
operator|*
operator|)
name|valaddr
return|;
ifdef|#
directive|ifdef
name|LONG_LONG
if|if
condition|(
name|len
operator|==
expr|sizeof
operator|(
name|long
name|long
operator|)
condition|)
return|return
operator|*
operator|(
name|long
name|long
operator|*
operator|)
name|valaddr
return|;
endif|#
directive|endif
block|}
name|error
argument_list|(
literal|"Value not floating number."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
operator|(
name|double
operator|)
literal|0
return|;
comment|/* To silence compiler warning.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a value ARG1 of a struct or union type,    extract and return the value of one of its fields.    FIELDNO says which field.     For C++, must also be able to return values from static fields */
end_comment

begin_function
name|value
name|value_field
parameter_list|(
name|arg1
parameter_list|,
name|fieldno
parameter_list|)
specifier|register
name|value
name|arg1
decl_stmt|;
specifier|register
name|int
name|fieldno
decl_stmt|;
block|{
specifier|register
name|value
name|v
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
name|TYPE_FIELD_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|fieldno
argument_list|)
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|;
comment|/* Handle packed fields */
name|offset
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|fieldno
argument_list|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_BITSIZE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|fieldno
argument_list|)
condition|)
block|{
name|v
operator|=
name|value_from_long
argument_list|(
name|type
argument_list|,
name|unpack_field_as_long
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|fieldno
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_BITPOS
argument_list|(
name|v
argument_list|)
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|fieldno
argument_list|)
operator|%
literal|8
expr_stmt|;
name|VALUE_BITSIZE
argument_list|(
name|v
argument_list|)
operator|=
name|TYPE_FIELD_BITSIZE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|fieldno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|arg1
argument_list|)
operator|+
name|offset
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
operator|==
name|lval_internalvar
condition|)
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_internalvar_component
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_ADDRESS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
operator|=
name|offset
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|value
name|value_fn_field
parameter_list|(
name|arg1
parameter_list|,
name|fieldno
parameter_list|,
name|subfieldno
parameter_list|)
specifier|register
name|value
name|arg1
decl_stmt|;
specifier|register
name|int
name|fieldno
decl_stmt|;
block|{
specifier|register
name|value
name|v
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|fieldno
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|subfieldno
argument_list|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|subfieldno
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal error: could not find physical method named %s"
argument_list|,
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|subfieldno
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Return a virtual function as a value.    ARG1 is the object which provides the virtual function    table pointer.    F is the list of member functions which contains the desired virtual    function.    J is an index into F which provides the desired virtual function.    TYPE is the basetype which first provides the virtual function table.  */
end_comment

begin_function
name|value
name|value_virtual_fn_field
parameter_list|(
name|arg1
parameter_list|,
name|f
parameter_list|,
name|j
parameter_list|,
name|type
parameter_list|)
name|value
name|arg1
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
decl_stmt|;
name|int
name|j
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
comment|/* First, get the virtual function table pointer.  That comes      with a strange type, so cast it to type `pointer to long' (which      should serve just fine as a function type).  Then, index into      the table, and convert final value to appropriate function type.  */
name|value
name|vfn
decl_stmt|,
name|vtbl
decl_stmt|;
name|value
name|vi
init|=
name|value_from_long
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
operator|=
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* This type may have been defined before its virtual function table      was.  If so, fill in the virtual function table entry for the      type now.  */
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|<
literal|0
condition|)
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
name|fill_in_vptr_fieldno
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* The virtual function table is now an array of structures      which have the form { int16 offset, delta; void *pfn; }.  */
name|vtbl
operator|=
name|value_ind
argument_list|(
name|value_field
argument_list|(
name|arg1
argument_list|,
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Index into the virtual function table.  This is hard-coded because      looking up a field is not cheap, and it may be important to save      time, e.g. if the user has set a conditional breakpoint calling      a virtual function.  */
name|vfn
operator|=
name|value_field
argument_list|(
name|value_subscript
argument_list|(
name|vtbl
argument_list|,
name|vi
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Reinstantiate the function pointer with the correct type.  */
name|VALUE_TYPE
argument_list|(
name|vfn
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|vfn
return|;
block|}
end_function

begin_comment
comment|/* The value of a static class member does not depend    on its instance, only on its type.  If FIELDNO>= 0,    then fieldno is a valid field number and is used directly.    Otherwise, FIELDNAME is the name of the field we are    searching for.  If it is not a static field name, an    error is signaled.  TYPE is the type in which we look for the    static field member.  */
end_comment

begin_function
name|value
name|value_static_field
parameter_list|(
name|type
parameter_list|,
name|fieldname
parameter_list|,
name|fieldno
parameter_list|)
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|fieldname
decl_stmt|;
specifier|register
name|int
name|fieldno
decl_stmt|;
block|{
specifier|register
name|value
name|v
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|fieldno
operator|<
literal|0
condition|)
block|{
specifier|register
name|struct
name|type
modifier|*
name|t
init|=
name|type
decl_stmt|;
comment|/* Look for static field.  */
while|while
condition|(
name|t
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|fieldname
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fieldno
operator|=
name|i
expr_stmt|;
goto|goto
name|found
goto|;
block|}
else|else
name|error
argument_list|(
literal|"field `%s' is not static"
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|TYPE_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|?
name|TYPE_BASECLASS
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
else|:
literal|0
expr_stmt|;
block|}
name|t
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|destructor_name_p
argument_list|(
name|fieldname
argument_list|,
name|t
argument_list|)
condition|)
name|error
argument_list|(
literal|"use `info method' command to print out value of destructor"
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|t
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|fieldname
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"use `info method' command to print value of method \"%s\""
argument_list|,
name|fieldname
argument_list|)
expr_stmt|;
block|}
block|}
name|t
operator|=
name|TYPE_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|?
name|TYPE_BASECLASS
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
else|:
literal|0
expr_stmt|;
block|}
name|error
argument_list|(
literal|"there is no field named %s"
argument_list|,
name|fieldname
argument_list|)
expr_stmt|;
block|}
name|found
label|:
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|TYPE_FIELD_STATIC_PHYSNAME
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
condition|)
name|error
argument_list|(
literal|"Internal error: could not find physical static variable named %s"
argument_list|,
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
expr_stmt|;
name|v
operator|=
name|value_at
argument_list|(
name|type
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|long
name|unpack_field_as_long
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|fieldno
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|int
name|fieldno
decl_stmt|;
block|{
name|long
name|val
decl_stmt|;
name|int
name|bitpos
init|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
decl_stmt|;
name|int
name|bitsize
init|=
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|fieldno
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|valaddr
operator|+
name|bitpos
operator|/
literal|8
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
name|val
argument_list|)
expr_stmt|;
comment|/* Extracting bits depends on endianness of the machine.  */
ifdef|#
directive|ifdef
name|BITS_BIG_ENDIAN
name|val
operator|=
name|val
operator|>>
operator|(
sizeof|sizeof
name|val
operator|*
literal|8
operator|-
name|bitpos
operator|%
literal|8
operator|-
name|bitsize
operator|)
expr_stmt|;
else|#
directive|else
name|val
operator|=
name|val
operator|>>
operator|(
name|bitpos
operator|%
literal|8
operator|)
expr_stmt|;
endif|#
directive|endif
name|val
operator|&=
operator|(
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|void
name|modify_field
parameter_list|(
name|addr
parameter_list|,
name|fieldval
parameter_list|,
name|bitpos
parameter_list|,
name|bitsize
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|fieldval
decl_stmt|;
name|int
name|bitpos
decl_stmt|,
name|bitsize
decl_stmt|;
block|{
name|long
name|oword
decl_stmt|;
comment|/* Reject values too big to fit in the field in question.      Otherwise adjoining fields may be corrupted.  */
if|if
condition|(
name|fieldval
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
operator|)
condition|)
name|error
argument_list|(
literal|"Value %d does not fit in %d bits."
argument_list|,
name|fieldval
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|addr
argument_list|,
operator|&
name|oword
argument_list|,
sizeof|sizeof
name|oword
argument_list|)
expr_stmt|;
comment|/* Shifting for bit field depends on endianness of the machine.  */
ifdef|#
directive|ifdef
name|BITS_BIG_ENDIAN
name|bitpos
operator|=
sizeof|sizeof
argument_list|(
name|oword
argument_list|)
operator|*
literal|8
operator|-
name|bitpos
operator|-
name|bitsize
expr_stmt|;
endif|#
directive|endif
name|oword
operator|&=
operator|~
operator|(
operator|(
operator|(
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
operator|)
operator|<<
name|bitpos
operator|)
expr_stmt|;
name|oword
operator||=
name|fieldval
operator|<<
name|bitpos
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|oword
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
name|oword
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert C numbers into newly allocated values */
end_comment

begin_function
name|value
name|value_from_long
parameter_list|(
name|type
parameter_list|,
name|num
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
specifier|register
name|LONGEST
name|num
decl_stmt|;
block|{
specifier|register
name|value
name|val
init|=
name|allocate_value
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_INT
operator|||
name|code
operator|==
name|TYPE_CODE_ENUM
condition|)
block|{
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|)
operator|*
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
operator|=
name|num
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|short
argument_list|)
condition|)
operator|*
operator|(
name|short
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
operator|=
name|num
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
operator|=
name|num
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
operator|*
operator|(
name|long
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
operator|=
name|num
expr_stmt|;
ifdef|#
directive|ifdef
name|LONG_LONG
elseif|else
if|if
condition|(
name|len
operator|==
expr|sizeof
operator|(
name|long
name|long
operator|)
condition|)
operator|*
operator|(
name|long
name|long
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
operator|=
name|num
expr_stmt|;
endif|#
directive|endif
else|else
name|error
argument_list|(
literal|"Integer type encountered with unexpected data length."
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Unexpected type encountered for integer constant."
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|value
name|value_from_double
parameter_list|(
name|type
parameter_list|,
name|num
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|double
name|num
decl_stmt|;
block|{
specifier|register
name|value
name|val
init|=
name|allocate_value
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
operator|*
operator|(
name|float
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
operator|=
name|num
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
operator|*
operator|(
name|double
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
operator|=
name|num
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Floating type encountered with unexpected data length."
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Unexpected type encountered for floating constant."
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Deal with the value that is "about to be returned".  */
end_comment

begin_comment
comment|/* Return the value that a function returning now    would be returning to its caller, assuming its type is VALTYPE.    RETBUF is where we look for what ought to be the contents    of the registers (in raw form).  This is because it is often    desirable to restore old values to those registers    after saving the contents of interest, and then call    this function using the saved values.    struct_return is non-zero when the function in question is    using the structure return conventions on the machine in question;    0 when it is using the value returning conventions (this often    means returning pointer to where structure is vs. returning value). */
end_comment

begin_function
name|value
name|value_being_returned
parameter_list|(
name|valtype
parameter_list|,
name|retbuf
parameter_list|,
name|struct_return
parameter_list|)
specifier|register
name|struct
name|type
modifier|*
name|valtype
decl_stmt|;
name|char
name|retbuf
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
name|int
name|struct_return
decl_stmt|;
block|{
specifier|register
name|value
name|val
decl_stmt|;
if|if
condition|(
name|struct_return
condition|)
return|return
name|value_at
argument_list|(
name|valtype
argument_list|,
name|EXTRACT_STRUCT_VALUE_ADDRESS
argument_list|(
name|retbuf
argument_list|)
argument_list|)
return|;
name|val
operator|=
name|allocate_value
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
name|EXTRACT_RETURN_VALUE
argument_list|(
name|valtype
argument_list|,
name|retbuf
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return true if the function specified is using the structure returning    convention on this machine to return arguments, or 0 if it is using    the value returning convention.  FUNCTION is the value representing    the function, FUNCADDR is the address of the function, and VALUE_TYPE    is the type returned by the function */
end_comment

begin_function_decl
name|struct
name|block
modifier|*
name|block_for_pc
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|using_struct_return
parameter_list|(
name|function
parameter_list|,
name|funcaddr
parameter_list|,
name|value_type
parameter_list|)
name|value
name|function
decl_stmt|;
name|CORE_ADDR
name|funcaddr
decl_stmt|;
name|struct
name|type
modifier|*
name|value_type
decl_stmt|;
block|{
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|value_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|code
operator|==
name|TYPE_CODE_UNION
operator|||
name|code
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
name|struct
name|block
modifier|*
name|b
init|=
name|block_for_pc
argument_list|(
name|funcaddr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|BLOCK_GCC_COMPILED
argument_list|(
name|b
argument_list|)
operator|&&
name|TYPE_LENGTH
argument_list|(
name|value_type
argument_list|)
operator|<
literal|8
operator|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Store VAL so it will be returned if a function returns now.    Does not verify that VAL's type matches what the current    function wants to return.  */
end_comment

begin_function
name|void
name|set_return_value
parameter_list|(
name|val
parameter_list|)
name|value
name|val
decl_stmt|;
block|{
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|regbuf
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
name|double
name|dbuf
decl_stmt|;
name|LONGEST
name|lbuf
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|code
operator|==
name|TYPE_CODE_UNION
condition|)
name|error
argument_list|(
literal|"Specifying a struct or union return value is not supported."
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|dbuf
operator|=
name|value_as_double
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|STORE_RETURN_VALUE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
operator|&
name|dbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lbuf
operator|=
name|value_as_long
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|STORE_RETURN_VALUE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
operator|&
name|lbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_values
parameter_list|()
block|{
name|add_info
argument_list|(
literal|"convenience"
argument_list|,
name|convenience_info
argument_list|,
literal|"Debugger convenience (\"$foo\") variables.\n\ These variables are created when you assign them values;\n\ thus, \"print $foo=1\" gives \"$foo\" the value 1.  Values may be any type.\n\n\ A few convenience variables are given values automatically GDB:\n\ \"$_\"holds the last address examined with \"x\" or \"info lines\",\n\ \"$__\" holds the contents of the last address examined with \"x\"."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"values"
argument_list|,
name|value_history_info
argument_list|,
literal|"Elements of value history (around item number IDX, or last ten)."
argument_list|)
expr_stmt|;
name|add_info_alias
argument_list|(
literal|"history"
argument_list|,
name|value_history_info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

