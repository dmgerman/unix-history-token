begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Library for reading command lines and decoding commands.    Copyright (C) 1986, 1989 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Add element named NAME to command list *LIST.    FUN should be the function to execute the command;    it will get a character string as argument, with leading    and trailing blanks already eliminated.     DOC is a documentation string for the command.    Its first line should be a complete sentence.    It should start with ? for a command that is an abbreviation    or with * for a command that most users don't need to know about.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|add_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
name|list
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|class
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|doc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
init|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cmd_list_element
argument_list|)
argument_list|)
decl_stmt|;
name|delete_cmd
argument_list|(
name|name
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|c
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
name|c
operator|->
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|class
operator|=
name|class
expr_stmt|;
name|c
operator|->
name|function
operator|=
name|fun
expr_stmt|;
name|c
operator|->
name|doc
operator|=
name|doc
expr_stmt|;
name|c
operator|->
name|prefixlist
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|allow_unknown
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|abbrev_flag
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
operator|*
name|list
operator|=
name|c
expr_stmt|;
return|return
name|c
return|;
block|}
end_block

begin_comment
comment|/* Same as above, except that the abbrev_flag is set. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|add_abbrev_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
name|list
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|class
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|doc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
init|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cmd_list_element
argument_list|)
argument_list|)
decl_stmt|;
name|delete_cmd
argument_list|(
name|name
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|c
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
name|c
operator|->
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|class
operator|=
name|class
expr_stmt|;
name|c
operator|->
name|function
operator|=
name|fun
expr_stmt|;
name|c
operator|->
name|doc
operator|=
name|doc
expr_stmt|;
name|c
operator|->
name|prefixlist
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|allow_unknown
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|abbrev_flag
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
operator|*
name|list
operator|=
name|c
expr_stmt|;
return|return
name|c
return|;
block|}
end_block

begin_function
name|struct
name|cmd_list_element
modifier|*
name|add_alias_cmd
parameter_list|(
name|name
parameter_list|,
name|oldname
parameter_list|,
name|class
parameter_list|,
name|abbrev_flag
parameter_list|,
name|list
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|oldname
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|abbrev_flag
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
decl_stmt|;
block|{
comment|/* Must do this since lookup_cmd tries to side-effect its first arg */
name|char
modifier|*
name|copied_name
decl_stmt|;
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|old
decl_stmt|;
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|copied_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|oldname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|copied_name
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
name|old
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|copied_name
argument_list|,
operator|*
name|list
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
literal|0
condition|)
block|{
name|delete_cmd
argument_list|(
name|name
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|=
name|add_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|old
operator|->
name|function
argument_list|,
name|old
operator|->
name|doc
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|c
operator|->
name|prefixlist
operator|=
name|old
operator|->
name|prefixlist
expr_stmt|;
name|c
operator|->
name|prefixname
operator|=
name|old
operator|->
name|prefixname
expr_stmt|;
name|c
operator|->
name|allow_unknown
operator|=
name|old
operator|->
name|allow_unknown
expr_stmt|;
name|c
operator|->
name|abbrev_flag
operator|=
name|abbrev_flag
expr_stmt|;
name|c
operator|->
name|aux
operator|=
name|old
operator|->
name|aux
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Like add_cmd but adds an element for a command prefix:    a name that should be followed by a subcommand to be looked up    in another command list.  PREFIXLIST should be the address    of the variable containing that list.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|add_prefix_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
name|prefixlist
argument_list|,
name|prefixname
argument_list|,
name|allow_unknown
argument_list|,
name|list
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|class
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|doc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|prefixlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|prefixname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|allow_unknown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
init|=
name|add_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|c
operator|->
name|prefixlist
operator|=
name|prefixlist
expr_stmt|;
name|c
operator|->
name|prefixname
operator|=
name|prefixname
expr_stmt|;
name|c
operator|->
name|allow_unknown
operator|=
name|allow_unknown
expr_stmt|;
return|return
name|c
return|;
block|}
end_block

begin_comment
comment|/* Like add_prefix_cmd butsets the abbrev_flag on the new command. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|add_abbrev_prefix_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
name|prefixlist
argument_list|,
name|prefixname
argument_list|,
name|allow_unknown
argument_list|,
name|list
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|class
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|doc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|prefixlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|prefixname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|allow_unknown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
init|=
name|add_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|c
operator|->
name|prefixlist
operator|=
name|prefixlist
expr_stmt|;
name|c
operator|->
name|prefixname
operator|=
name|prefixname
expr_stmt|;
name|c
operator|->
name|allow_unknown
operator|=
name|allow_unknown
expr_stmt|;
name|c
operator|->
name|abbrev_flag
operator|=
literal|1
expr_stmt|;
return|return
name|c
return|;
block|}
end_block

begin_comment
comment|/* Remove the command named NAME from the command list.  */
end_comment

begin_function
name|void
name|delete_cmd
parameter_list|(
name|name
parameter_list|,
name|list
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
decl_stmt|;
block|{
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
while|while
condition|(
operator|*
name|list
operator|&&
operator|!
name|strcmp
argument_list|(
operator|(
operator|*
name|list
operator|)
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
operator|*
name|list
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|list
condition|)
for|for
control|(
name|c
operator|=
operator|*
name|list
init|;
name|c
operator|->
name|next
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|c
operator|->
name|next
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
name|c
operator|->
name|next
operator|=
name|c
operator|->
name|next
operator|->
name|next
expr_stmt|;
else|else
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|void
name|help_cmd
argument_list|()
decl_stmt|,
name|help_list
argument_list|()
decl_stmt|,
name|help_cmd_list
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This command really has to deal with two things:  *     1) I want documentation on *this string* (usually called by  * "help commandname").  *     2) I want documentation on *this list* (usually called by  * giving a command that requires subcommands.  Also called by saying  * just "help".)  *  *   I am going to split this into two seperate comamnds, help_cmd and  * help_list.   */
end_comment

begin_function
name|void
name|help_cmd
parameter_list|(
name|command
parameter_list|,
name|stream
parameter_list|)
name|char
modifier|*
name|command
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
if|if
condition|(
operator|!
name|command
condition|)
block|{
name|help_list
argument_list|(
name|cmdlist
argument_list|,
literal|""
argument_list|,
operator|-
literal|2
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|command
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return;
comment|/* There are three cases here.      If c->prefixlist is nonzer, we have a prefix command.      Print its documentation, then list its subcommands.            If c->function is nonzero, we really have a command.      Print its documentation and return.            If c->function is zero, we have a class name.      Print its documentation (as if it were a command)      and then set class to he number of this class      so that the commands in the class will be listed.  */
name|fputs_filtered
argument_list|(
name|c
operator|->
name|doc
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|prefixlist
operator|==
literal|0
operator|&&
name|c
operator|->
name|function
operator|!=
literal|0
condition|)
return|return;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* If this is a prefix command, print it's subcommands */
if|if
condition|(
name|c
operator|->
name|prefixlist
condition|)
name|help_list
argument_list|(
operator|*
name|c
operator|->
name|prefixlist
argument_list|,
name|c
operator|->
name|prefixname
argument_list|,
operator|-
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* If this is a class name, print all of the commands in the class */
if|if
condition|(
name|c
operator|->
name|function
operator|==
literal|0
condition|)
name|help_list
argument_list|(
name|cmdlist
argument_list|,
literal|""
argument_list|,
name|c
operator|->
name|class
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a specific kind of help on a command list.  *  * LIST is the list.  * CMDTYPE is the prefix to use in the title string.  * CLASS is the class with which to list the nodes of this list (see  * documentation for help_cmd_list below),  As usual, -1 for  * everything, -2 for just classes, and non-negative for only things  * in a specific class.  * and STREAM is the output stream on which to print things.  * If you call this routine with a class>= 0, it recurses.  */
end_comment

begin_function
name|void
name|help_list
parameter_list|(
name|list
parameter_list|,
name|cmdtype
parameter_list|,
name|class
parameter_list|,
name|stream
parameter_list|)
name|struct
name|cmd_list_element
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|cmdtype
decl_stmt|;
name|int
name|class
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|cmdtype1
decl_stmt|,
modifier|*
name|cmdtype2
decl_stmt|;
comment|/* If CMDTYPE is "foo ", CMDTYPE1 gets " foo" and CMDTYPE2 gets "foo sub"  */
name|len
operator|=
name|strlen
argument_list|(
name|cmdtype
argument_list|)
expr_stmt|;
name|cmdtype1
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cmdtype1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|cmdtype2
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|4
argument_list|)
expr_stmt|;
name|cmdtype2
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|cmdtype1
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|strncpy
argument_list|(
name|cmdtype1
operator|+
literal|1
argument_list|,
name|cmdtype
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cmdtype1
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|cmdtype2
argument_list|,
name|cmdtype
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cmdtype2
operator|+
name|len
operator|-
literal|1
argument_list|,
literal|" sub"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|class
operator|==
operator|-
literal|2
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"List of classes of %scommands:\n\n"
argument_list|,
name|cmdtype2
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"List of %scommands:\n\n"
argument_list|,
name|cmdtype2
argument_list|)
expr_stmt|;
name|help_cmd_list
argument_list|(
name|list
argument_list|,
name|class
argument_list|,
name|cmdtype
argument_list|,
operator|(
name|class
operator|>=
literal|0
operator|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
operator|-
literal|2
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n\ Type \"help%s\" followed by a class name for a list of commands in that class."
argument_list|,
name|cmdtype1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n\ Type \"help%s\" followed by %scommand name for full documentation.\n\ Command name abbreviations are allowed if unambiguous.\n"
argument_list|,
name|cmdtype1
argument_list|,
name|cmdtype2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Implement a help command on command list LIST.  * RECURSE should be non-zero if this should be done recursively on  * all sublists of LIST.  * PREFIX is the prefix to print before each command name.  * STREAM is the stream upon which the output should be written.  * CLASS should be:  *	A non-negative class number to list only commands in that  * class.  *	-1 to list all commands in list.  *	-2 to list all classes in list.  *  *   Note that RECURSE will be active on *all* sublists, not just the  * ones seclected by the criteria above (ie. the selection mechanism  * is at the low level, not the high-level).  */
end_comment

begin_function
name|void
name|help_cmd_list
parameter_list|(
name|list
parameter_list|,
name|class
parameter_list|,
name|prefix
parameter_list|,
name|recurse
parameter_list|,
name|stream
parameter_list|)
name|struct
name|cmd_list_element
modifier|*
name|list
decl_stmt|;
name|int
name|class
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
modifier|*
name|line_buffer
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|line_size
decl_stmt|;
if|if
condition|(
operator|!
name|line_buffer
condition|)
block|{
name|line_size
operator|=
literal|80
expr_stmt|;
name|line_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|line_size
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|c
operator|=
name|list
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c
operator|->
name|abbrev_flag
operator|==
literal|0
operator|&&
operator|(
name|class
operator|==
operator|-
literal|1
operator|||
operator|(
name|class
operator|==
operator|-
literal|2
operator|&&
name|c
operator|->
name|function
operator|==
literal|0
operator|)
operator|||
operator|(
name|class
operator|==
name|c
operator|->
name|class
operator|&&
name|c
operator|->
name|function
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s%s -- "
argument_list|,
name|prefix
argument_list|,
name|c
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Print just the first line */
name|p
operator|=
name|c
operator|->
name|doc
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|-
name|c
operator|->
name|doc
operator|>
name|line_size
operator|-
literal|1
condition|)
block|{
name|line_size
operator|=
name|p
operator|-
name|c
operator|->
name|doc
operator|+
literal|1
expr_stmt|;
name|free
argument_list|(
name|line_buffer
argument_list|)
expr_stmt|;
name|line_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|line_size
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|line_buffer
argument_list|,
name|c
operator|->
name|doc
argument_list|,
name|p
operator|-
name|c
operator|->
name|doc
argument_list|)
expr_stmt|;
name|line_buffer
index|[
name|p
operator|-
name|c
operator|->
name|doc
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fputs_filtered
argument_list|(
name|line_buffer
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recurse
operator|&&
name|c
operator|->
name|prefixlist
operator|!=
literal|0
operator|&&
name|c
operator|->
name|abbrev_flag
operator|==
literal|0
condition|)
name|help_cmd_list
argument_list|(
operator|*
name|c
operator|->
name|prefixlist
argument_list|,
name|class
argument_list|,
name|c
operator|->
name|prefixname
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This routine takes a line of TEXT and a CLIST in which to    start the lookup.  When it returns it will have incremented the text    pointer past the section of text it matched, set *RESULT_LIST to    the list in which the last word was matched, and will return the    cmd list element which the text matches.  It will return 0 if no    match at all was possible.  It will return -1 if ambigous matches are    possible; in this case *RESULT_LIST will be set to the list in which    there are ambiguous choices (and text will be set to the ambiguous    text string).     It does no error reporting whatsoever; control will always return    to the superior routine.     In the case of an ambiguous return (-1), *RESULT_LIST will be set to    point at the prefix_command (ie. the best match) *or* (special    case) will be 0 if no prefix command was ever found.  For example,    in the case of "info a", "info" matches without ambiguity, but "a"    could be "args" or "address", so *RESULT_LIST is set to    the cmd_list_element for "info".  So in this case    result list should not be interpeted as a pointer to the beginning    of a list; it simply points to a specific command.     This routine does *not* modify the text pointed to by TEXT.        If INGNORE_HELP_CLASSES is nonzero, ignore any command list    elements which are actually help classes rather than commands (i.e.    the function field of the struct cmd_list_element is 0).  */
end_comment

begin_function
name|struct
name|cmd_list_element
modifier|*
name|lookup_cmd_1
parameter_list|(
name|text
parameter_list|,
name|clist
parameter_list|,
name|result_list
parameter_list|,
name|ignore_help_classes
parameter_list|)
name|char
modifier|*
modifier|*
name|text
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|clist
decl_stmt|,
decl|*
modifier|*
name|result_list
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|ignore_help_classes
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|command
decl_stmt|;
name|int
name|len
decl_stmt|,
name|tmp
decl_stmt|,
name|nfound
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|found
decl_stmt|,
modifier|*
name|c
decl_stmt|;
while|while
condition|(
operator|*
operator|*
name|text
operator|==
literal|' '
operator|||
operator|*
operator|*
name|text
operator|==
literal|'\t'
condition|)
operator|(
operator|*
name|text
operator|)
operator|++
expr_stmt|;
comment|/* Treating underscores as part of command words is important      so that "set args_foo()" doesn't get interpreted as      "set args _foo()".  */
for|for
control|(
name|p
operator|=
operator|*
name|text
init|;
operator|*
name|p
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'-'
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
comment|/* If nothing but whitespace, return 0.  */
if|if
condition|(
name|p
operator|==
operator|*
name|text
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|p
operator|-
operator|*
name|text
expr_stmt|;
comment|/* *text and p now bracket the first command word to lookup (and      it's length is len).  We copy this into a local temporary,      converting to lower case as we go.  */
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|len
condition|;
name|tmp
operator|++
control|)
block|{
name|char
name|x
init|=
operator|(
operator|*
name|text
operator|)
index|[
name|tmp
index|]
decl_stmt|;
name|command
index|[
name|tmp
index|]
operator|=
operator|(
name|x
operator|>=
literal|'A'
operator|&&
name|x
operator|<=
literal|'Z'
operator|)
condition|?
name|x
operator|-
literal|'A'
operator|+
literal|'a'
else|:
name|x
expr_stmt|;
block|}
name|command
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Look it up.  */
name|found
operator|=
literal|0
expr_stmt|;
name|nfound
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|clist
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|command
argument_list|,
name|c
operator|->
name|name
argument_list|,
name|len
argument_list|)
operator|&&
operator|(
operator|!
name|ignore_help_classes
operator|||
name|c
operator|->
name|function
operator|)
condition|)
block|{
name|found
operator|=
name|c
expr_stmt|;
name|nfound
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|name
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
block|{
name|nfound
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* If nothing matches, we have a simple failure.  */
if|if
condition|(
name|nfound
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|nfound
operator|>
literal|1
condition|)
block|{
operator|*
name|result_list
operator|=
literal|0
expr_stmt|;
comment|/* Will be modified in calling routine 				   if we know what the prefix command is. 				   */
return|return
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
return|;
comment|/* Ambiguous.  */
block|}
comment|/* We've matched something on this list.  Move text pointer forward. */
operator|*
name|text
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|found
operator|->
name|prefixlist
condition|)
block|{
name|c
operator|=
name|lookup_cmd_1
argument_list|(
name|text
argument_list|,
operator|*
name|found
operator|->
name|prefixlist
argument_list|,
name|result_list
argument_list|,
name|ignore_help_classes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
comment|/* Didn't find anything; this is as far as we got.  */
operator|*
name|result_list
operator|=
name|clist
expr_stmt|;
return|return
name|found
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* We've gotten this far properley, but the next step 	     is ambiguous.  We need to set the result list to the best 	     we've found (if an inferior hasn't already set it).  */
if|if
condition|(
operator|!
operator|*
name|result_list
condition|)
comment|/* This used to say *result_list = *found->prefixlist 	       If that was correct, need to modify the documentation 	       at the top of this function to clarify what is supposed 	       to be going on.  */
operator|*
name|result_list
operator|=
name|found
expr_stmt|;
return|return
name|c
return|;
block|}
else|else
block|{
comment|/* We matched!  */
return|return
name|c
return|;
block|}
block|}
else|else
block|{
operator|*
name|result_list
operator|=
name|clist
expr_stmt|;
return|return
name|found
return|;
block|}
block|}
end_block

begin_comment
comment|/* Look up the contents of *LINE as a command in the command list LIST.    LIST is a chain of struct cmd_list_element's.    If it is found, return the struct cmd_list_element for that command    and update *LINE to point after the command name, at the first argument.    If not found, call error if ALLOW_UNKNOWN is zero    otherwise (or if error returns) return zero.    Call error if specified command is ambiguous,    unless ALLOW_UNKNOWN is negative.    CMDTYPE precedes the word "command" in the error message.     If INGNORE_HELP_CLASSES is nonzero, ignore any command list    elements which are actually help classes rather than commands (i.e.    the function field of the struct cmd_list_element is 0).  */
end_comment

begin_function
name|struct
name|cmd_list_element
modifier|*
name|lookup_cmd
parameter_list|(
name|line
parameter_list|,
name|list
parameter_list|,
name|cmdtype
parameter_list|,
name|allow_unknown
parameter_list|,
name|ignore_help_classes
parameter_list|)
name|char
modifier|*
modifier|*
name|line
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|cmdtype
decl_stmt|;
name|int
name|allow_unknown
decl_stmt|;
name|int
name|ignore_help_classes
decl_stmt|;
block|{
name|struct
name|cmd_list_element
modifier|*
name|last_list
init|=
literal|0
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
init|=
name|lookup_cmd_1
argument_list|(
name|line
argument_list|,
name|list
argument_list|,
operator|&
name|last_list
argument_list|,
name|ignore_help_classes
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
operator|(
operator|*
name|line
operator|)
operator|+
name|strlen
argument_list|(
operator|*
name|line
argument_list|)
operator|-
literal|1
decl_stmt|;
comment|/* Clear off trailing whitespace.  */
while|while
condition|(
name|ptr
operator|>=
operator|*
name|line
operator|&&
operator|(
operator|*
name|ptr
operator|==
literal|' '
operator|||
operator|*
name|ptr
operator|==
literal|'\t'
operator|)
condition|)
name|ptr
operator|--
expr_stmt|;
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
if|if
condition|(
operator|!
name|allow_unknown
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|line
condition|)
name|error
argument_list|(
literal|"Lack of needed %scommand"
argument_list|,
name|cmdtype
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|line
decl_stmt|,
modifier|*
name|q
decl_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
name|p
operator|++
expr_stmt|;
name|q
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|q
argument_list|,
operator|*
name|line
argument_list|,
name|p
operator|-
operator|*
name|line
argument_list|)
expr_stmt|;
name|q
index|[
name|p
operator|-
operator|*
name|line
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
argument_list|(
literal|"Undefined %scommand: \"%s\"."
argument_list|,
name|cmdtype
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* Ambigous.  Local values should be off prefixlist or called 	 values.  */
name|int
name|local_allow_unknown
init|=
operator|(
name|last_list
condition|?
name|last_list
operator|->
name|allow_unknown
else|:
name|allow_unknown
operator|)
decl_stmt|;
name|char
modifier|*
name|local_cmdtype
init|=
name|last_list
condition|?
name|last_list
operator|->
name|prefixname
else|:
name|cmdtype
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|local_list
init|=
operator|(
name|last_list
condition|?
operator|*
operator|(
name|last_list
operator|->
name|prefixlist
operator|)
else|:
name|list
operator|)
decl_stmt|;
if|if
condition|(
name|local_allow_unknown
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|last_list
condition|)
return|return
name|last_list
return|;
comment|/* Found something.  */
else|else
return|return
literal|0
return|;
comment|/* Found nothing.  */
block|}
else|else
block|{
comment|/* Report as error.  */
name|int
name|amb_len
decl_stmt|;
name|char
name|ambbuf
index|[
literal|100
index|]
decl_stmt|;
for|for
control|(
name|amb_len
operator|=
literal|0
init|;
operator|(
operator|(
operator|*
name|line
operator|)
index|[
name|amb_len
index|]
operator|&&
operator|(
operator|*
name|line
operator|)
index|[
name|amb_len
index|]
operator|!=
literal|' '
operator|&&
operator|(
operator|*
name|line
operator|)
index|[
name|amb_len
index|]
operator|!=
literal|'\t'
operator|)
condition|;
name|amb_len
operator|++
control|)
empty_stmt|;
name|ambbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|local_list
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|line
argument_list|,
name|c
operator|->
name|name
argument_list|,
name|amb_len
argument_list|)
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|ambbuf
argument_list|)
operator|+
name|strlen
argument_list|(
name|c
operator|->
name|name
argument_list|)
operator|+
literal|6
operator|<
sizeof|sizeof
name|ambbuf
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|ambbuf
argument_list|)
condition|)
name|strcat
argument_list|(
name|ambbuf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ambbuf
argument_list|,
name|c
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcat
argument_list|(
name|ambbuf
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|error
argument_list|(
literal|"Ambiguous %scommand \"%s\": %s."
argument_list|,
name|local_cmdtype
argument_list|,
operator|*
name|line
argument_list|,
name|ambbuf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We've got something.  It may still not be what the caller          wants (if this command *needs* a subcommand).  */
while|while
condition|(
operator|*
operator|*
name|line
operator|==
literal|' '
operator|||
operator|*
operator|*
name|line
operator|==
literal|'\t'
condition|)
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|prefixlist
operator|&&
operator|*
operator|*
name|line
operator|&&
operator|!
name|c
operator|->
name|allow_unknown
condition|)
name|error
argument_list|(
literal|"Undefined %scommand: \"%s\"."
argument_list|,
name|c
operator|->
name|prefixname
argument_list|,
operator|*
name|line
argument_list|)
expr_stmt|;
comment|/* Seems to be what he wants.  Return it.  */
return|return
name|c
return|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Look up the contents of *LINE as a command in the command list LIST.    LIST is a chain of struct cmd_list_element's.    If it is found, return the struct cmd_list_element for that command    and update *LINE to point after the command name, at the first argument.    If not found, call error if ALLOW_UNKNOWN is zero    otherwise (or if error returns) return zero.    Call error if specified command is ambiguous,    unless ALLOW_UNKNOWN is negative.    CMDTYPE precedes the word "command" in the error message.  */
end_comment

begin_comment
unit|struct cmd_list_element * lookup_cmd (line, list, cmdtype, allow_unknown)      char **line;      struct cmd_list_element *list;      char *cmdtype;      int allow_unknown; {   register char *p;   register struct cmd_list_element *c, *found;   int nfound;   char ambbuf[100];   char *processed_cmd;   int i, cmd_len;
comment|/* Skip leading whitespace.  */
end_comment

begin_comment
unit|while (**line == ' ' || **line == '\t')     (*line)++;
comment|/* Clear out trailing whitespace.  */
end_comment

begin_comment
unit|p = *line + strlen (*line);   while (p != *line&& (p[-1] == ' ' || p[-1] == '\t'))     p--;   *p = 0;
comment|/* Find end of command name.  */
end_comment

begin_comment
unit|p = *line;   while (*p == '-' 	 || (*p>= 'a'&& *p<= 'z') 	 || (*p>= 'A'&& *p<= 'Z') 	 || (*p>= '0'&& *p<= '9'))     p++;
comment|/* Look up the command name.      If exact match, keep that.      Otherwise, take command abbreviated, if unique.  Note that (in my      opinion) a null string does *not* indicate ambiguity; simply the      end of the argument.  */
end_comment

begin_comment
unit|if (p == *line)     {       if (!allow_unknown) 	error ("Lack of needed %scommand", cmdtype);       return 0;     }
comment|/* Copy over to a local buffer, converting to lowercase on the way.      This is in case the command being parsed is a subcommand which      doesn't match anything, and that's ok.  We want the original      untouched for the routine of the original command.  */
end_comment

begin_comment
unit|processed_cmd = (char *) alloca (p - *line + 1);   for (cmd_len = 0; cmd_len< p - *line; cmd_len++)     {       char x = (*line)[cmd_len];       if (x>= 'A'&& x<= 'Z') 	processed_cmd[cmd_len] = x - 'A' + 'a';       else 	processed_cmd[cmd_len] = x;     }   processed_cmd[cmd_len] = '\0';
comment|/* Check all possibilities in the current command list.  */
end_comment

begin_comment
unit|found = 0;   nfound = 0;   for (c = list; c; c = c->next)     {       if (!strncmp (processed_cmd, c->name, cmd_len)) 	{ 	  found = c; 	  nfound++; 	  if (c->name[cmd_len] == 0) 	    { 	      nfound = 1; 	      break; 	    } 	}     }
comment|/* Report error for undefined command name.  */
end_comment

begin_comment
unit|if (nfound != 1)     {       if (nfound> 1&& allow_unknown>= 0) 	{ 	  ambbuf[0] = 0; 	  for (c = list; c; c = c->next) 	    if (!strncmp (processed_cmd, c->name, cmd_len)) 	      { 		if (strlen (ambbuf) + strlen (c->name) + 6< sizeof ambbuf) 		  { 		    if (strlen (ambbuf)) 		      strcat (ambbuf, ", "); 		    strcat (ambbuf, c->name); 		  } 		else 		  { 		    strcat (ambbuf, ".."); 		    break; 		  } 	      } 	  error ("Ambiguous %scommand \"%s\": %s.", cmdtype, 		 processed_cmd, ambbuf); 	}       else if (!allow_unknown) 	error ("Undefined %scommand: \"%s\".", cmdtype, processed_cmd);       return 0;     }
comment|/* Skip whitespace before the argument.  */
end_comment

begin_endif
unit|while (*p == ' ' || *p == '\t') p++;   *line = p;    if (found->prefixlist&& *p)     {       c = lookup_cmd (line, *found->prefixlist, found->prefixname, 		      found->allow_unknown);       if (c) 	return c;     }    return found; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Helper function for SYMBOL_COMPLETION_FUNCTION.  */
end_comment

begin_comment
comment|/* Return a vector of char pointers which point to the different    possible completions in LIST of TEXT.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|complete_on_cmdlist
parameter_list|(
name|list
parameter_list|,
name|text
parameter_list|)
name|struct
name|cmd_list_element
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|{
name|struct
name|cmd_list_element
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
modifier|*
name|matchlist
decl_stmt|;
name|int
name|sizeof_matchlist
decl_stmt|;
name|int
name|matches
decl_stmt|;
name|int
name|textlen
init|=
name|strlen
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|sizeof_matchlist
operator|=
literal|10
expr_stmt|;
name|matchlist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|sizeof_matchlist
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|matches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|list
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ptr
operator|->
name|name
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|)
operator|&&
operator|!
name|ptr
operator|->
name|abbrev_flag
operator|&&
operator|(
name|ptr
operator|->
name|function
operator|||
name|ptr
operator|->
name|prefixlist
operator|)
condition|)
block|{
if|if
condition|(
name|matches
operator|==
name|sizeof_matchlist
condition|)
block|{
name|sizeof_matchlist
operator|*=
literal|2
expr_stmt|;
name|matchlist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|matchlist
argument_list|,
operator|(
name|sizeof_matchlist
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|matchlist
index|[
name|matches
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|ptr
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|matchlist
index|[
name|matches
operator|++
index|]
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|matches
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|matchlist
argument_list|)
expr_stmt|;
name|matchlist
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|matchlist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|matchlist
argument_list|,
operator|(
operator|(
name|matches
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|matchlist
index|[
name|matches
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
return|return
name|matchlist
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|shell_escape
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|,
name|status
decl_stmt|,
name|pid
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|user_shell
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
if|if
condition|(
operator|(
name|user_shell
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|user_shell
operator|=
literal|"/bin/sh"
expr_stmt|;
comment|/* Get the name of the shell for arg0 */
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|user_shell
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|p
operator|=
name|user_shell
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
comment|/* Get past '/' */
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|arg
condition|)
name|execl
argument_list|(
name|user_shell
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|execl
argument_list|(
name|user_shell
argument_list|,
name|p
argument_list|,
literal|"-c"
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Exec of shell failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|!=
operator|-
literal|1
condition|)
while|while
condition|(
operator|(
name|rc
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|pid
operator|&&
name|rc
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
else|else
name|error
argument_list|(
literal|"Fork failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_command
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"shell"
argument_list|,
name|class_support
argument_list|,
name|shell_escape
argument_list|,
literal|"Execute the rest of the line as a shell command.  \n\ With no arguments, run an inferior shell."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

