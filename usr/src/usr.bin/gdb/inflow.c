begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  * Modified 1990 by Van Jacobson at Lawrence Berkeley Laboratory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)inflow.c	6.5 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Low level interface to ptrace, for GDB when running under Unix.    Copyright (C) 1986, 1987, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some USG-esque systems (some of which are BSD-esque enough so that USG    is not defined) want this header, and it won't do any harm.  */
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERMIO
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_undef
undef|#
directive|undef
name|TIOCGETP
end_undef

begin_define
define|#
directive|define
name|TIOCGETP
value|TCGETA
end_define

begin_undef
undef|#
directive|undef
name|TIOCSETN
end_undef

begin_define
define|#
directive|define
name|TIOCSETN
value|TCSETA
end_define

begin_undef
undef|#
directive|undef
name|TIOCSETP
end_undef

begin_define
define|#
directive|define
name|TIOCSETP
value|TCSETAF
end_define

begin_define
define|#
directive|define
name|TERMINAL
value|struct termio
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_define
define|#
directive|define
name|TERMINAL
value|struct sgttyb
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SET_STACK_LIMIT_HUGE
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|original_stack_limit
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SET_STACK_LIMIT_HUGE */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we are debugging an attached outside process    rather than an inferior.  */
end_comment

begin_decl_stmt
name|int
name|attach_flag
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Record terminal status separately for debugger and inferior.  */
end_comment

begin_decl_stmt
specifier|static
name|TERMINAL
name|sg_inferior
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TERMINAL
name|sg_ours
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tflags_inferior
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tflags_ours
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGETC_BROKEN
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|struct
name|tchars
name|tc_inferior
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tchars
name|tc_ours
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGLTC
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|ltchars
name|ltc_inferior
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ltchars
name|ltc_ours
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCLGET
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|lmode_inferior
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lmode_ours
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGPGRP
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|pgrp_inferior
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pgrp_ours
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|sigint_ours
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|sigquit_ours
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TIOCGPGRP */
end_comment

begin_comment
comment|/* Copy of inferior_io_terminal when inferior was last started.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|inferior_thisrun_terminal
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|terminal_ours_1
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Nonzero if our terminal settings are in effect.    Zero if the inferior's settings are in effect.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|terminal_is_ours
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the terminal settings we record for the inferior,    before we actually run the inferior.  */
end_comment

begin_function
name|void
name|terminal_init_inferior
parameter_list|()
block|{
if|if
condition|(
name|remote_debugging
condition|)
return|return;
name|sg_inferior
operator|=
name|sg_ours
expr_stmt|;
name|tflags_inferior
operator|=
name|tflags_ours
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGETC_BROKEN
argument_list|)
name|tc_inferior
operator|=
name|tc_ours
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGLTC
name|ltc_inferior
operator|=
name|ltc_ours
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCLGET
name|lmode_inferior
operator|=
name|lmode_ours
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGPGRP
name|pgrp_inferior
operator|=
name|inferior_pid
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGPGRP */
name|terminal_is_ours
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put the inferior's terminal settings into effect.    This is preparation for starting or resuming the inferior.  */
end_comment

begin_function
name|void
name|terminal_inferior
parameter_list|()
block|{
if|if
condition|(
name|remote_debugging
condition|)
return|return;
if|if
condition|(
name|terminal_is_ours
condition|)
comment|/*&& inferior_thisrun_terminal == 0) */
block|{
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|tflags_inferior
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|tflags_inferior
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|sg_inferior
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGETC_BROKEN
argument_list|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|tc_inferior
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGLTC
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|ltc_inferior
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCLGET
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|lmode_inferior
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGPGRP
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|&
name|pgrp_inferior
argument_list|)
expr_stmt|;
else|#
directive|else
name|sigint_ours
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|sigquit_ours
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGPGRP */
block|}
name|terminal_is_ours
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put some of our terminal settings into effect,    enough to get proper results from our output,    but do not change into or out of RAW mode    so that no input is discarded.     After doing this, either terminal_ours or terminal_inferior    should be called to get back to a normal state of affairs.  */
end_comment

begin_function
name|void
name|terminal_ours_for_output
parameter_list|()
block|{
if|if
condition|(
name|remote_debugging
condition|)
return|return;
name|terminal_ours_1
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put our terminal settings into effect.    First record the inferior's terminal settings    so they can be restored properly later.  */
end_comment

begin_function
name|void
name|terminal_ours
parameter_list|()
block|{
if|if
condition|(
name|remote_debugging
condition|)
return|return;
name|terminal_ours_1
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|terminal_ours_1
parameter_list|(
name|output_only
parameter_list|)
name|int
name|output_only
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TIOCGPGRP
comment|/* Ignore this signal since it will happen when we try to set the pgrp.  */
name|void
function_decl|(
modifier|*
name|osigttou
function_decl|)
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/* TIOCGPGRP */
if|if
condition|(
operator|!
name|terminal_is_ours
condition|)
comment|/*&& inferior_thisrun_terminal == 0)  */
block|{
name|terminal_is_ours
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCGPGRP
name|osigttou
operator|=
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|&
name|pgrp_inferior
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|&
name|pgrp_ours
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|osigttou
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigint_ours
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|sigquit_ours
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGPGRP */
name|tflags_inferior
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|sg_inferior
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGETC_BROKEN
argument_list|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|tc_inferior
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGLTC
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|ltc_inferior
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCLGET
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|lmode_inferior
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|HAVE_TERMIO
name|sg_ours
operator|.
name|c_lflag
operator||=
name|ICANON
expr_stmt|;
if|if
condition|(
name|output_only
operator|&&
operator|!
operator|(
name|sg_inferior
operator|.
name|c_lflag
operator|&
name|ICANON
operator|)
condition|)
name|sg_ours
operator|.
name|c_lflag
operator|&=
operator|~
name|ICANON
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_TERMIO */
name|sg_ours
operator|.
name|sg_flags
operator|&=
operator|~
name|RAW
operator|&
operator|~
name|CBREAK
expr_stmt|;
if|if
condition|(
name|output_only
condition|)
name|sg_ours
operator|.
name|sg_flags
operator||=
operator|(
name|RAW
operator||
name|CBREAK
operator|)
operator|&
name|sg_inferior
operator|.
name|sg_flags
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TERMIO */
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|tflags_ours
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|tflags_ours
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|sg_ours
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGETC_BROKEN
argument_list|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|tc_ours
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGLTC
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|ltc_ours
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCLGET
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|lmode_ours
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TERMIO
name|sg_ours
operator|.
name|c_lflag
operator||=
name|ICANON
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_TERMIO */
name|sg_ours
operator|.
name|sg_flags
operator|&=
operator|~
name|RAW
operator|&
operator|~
name|CBREAK
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TERMIO */
block|}
end_function

begin_function
specifier|static
name|void
name|term_status_command
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"No terminal status when remote debugging.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf_filtered
argument_list|(
literal|"Inferior's terminal status (currently saved by GDB):\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIO
name|printf_filtered
argument_list|(
literal|"fcntl flags = 0x%x, c_iflag = 0x%x, c_oflag = 0x%x,\n"
argument_list|,
name|tflags_inferior
argument_list|,
name|sg_inferior
operator|.
name|c_iflag
argument_list|,
name|sg_inferior
operator|.
name|c_oflag
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"c_cflag = 0x%x, c_lflag = 0x%x, c_line = 0x%x.\n"
argument_list|,
name|sg_inferior
operator|.
name|c_cflag
argument_list|,
name|sg_inferior
operator|.
name|c_lflag
argument_list|,
name|sg_inferior
operator|.
name|c_line
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"c_cc: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|NCC
operator|)
condition|;
name|i
operator|+=
literal|1
control|)
name|printf_filtered
argument_list|(
literal|"0x%x "
argument_list|,
name|sg_inferior
operator|.
name|c_cc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAVE_TERMIO */
name|printf_filtered
argument_list|(
literal|"fcntl flags = 0x%x, sgttyb.sg_flags = 0x%x, owner pid = %d.\n"
argument_list|,
name|tflags_inferior
argument_list|,
name|sg_inferior
operator|.
name|sg_flags
argument_list|,
name|pgrp_inferior
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TERMIO */
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGETC_BROKEN
argument_list|)
name|printf_filtered
argument_list|(
literal|"tchars: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|tchars
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf_filtered
argument_list|(
literal|"0x%x "
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tc_inferior
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGLTC
name|printf_filtered
argument_list|(
literal|"ltchars: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ltchars
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf_filtered
argument_list|(
literal|"0x%x "
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ltc_inferior
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|ltc_ours
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCLGET
name|printf_filtered
argument_list|(
literal|"lmode:  %x\n"
argument_list|,
name|lmode_inferior
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|new_tty
parameter_list|(
name|ttyname
parameter_list|)
name|char
modifier|*
name|ttyname
decl_stmt|;
block|{
specifier|register
name|int
name|tty
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCNOTTY
comment|/* Disconnect the child process from our controlling terminal.  */
name|tty
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
operator|>
literal|0
condition|)
block|{
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCNOTTY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tty
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Now open the specified new terminal.  */
name|tty
operator|=
name|open
argument_list|(
name|ttyname
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
operator|==
operator|-
literal|1
condition|)
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Avoid use of dup2; doesn't exist on all systems.  */
if|if
condition|(
name|tty
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|tty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tty
operator|!=
literal|1
condition|)
block|{
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|tty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tty
operator|!=
literal|2
condition|)
block|{
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|tty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tty
operator|>
literal|2
condition|)
name|close
argument_list|(
name|tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start an inferior process and returns its pid.    ALLARGS is a string containing shell command to run the program.    ENV is the environment vector to pass.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SHELL_FILE
end_ifndef

begin_define
define|#
directive|define
name|SHELL_FILE
value|"/bin/sh"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|create_inferior
parameter_list|(
name|allargs
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|allargs
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|char
modifier|*
name|shell_command
decl_stmt|;
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
comment|/* If desired, concat something onto the front of ALLARGS.      SHELL_COMMAND is the result.  */
ifdef|#
directive|ifdef
name|SHELL_COMMAND_CONCAT
name|shell_command
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|SHELL_COMMAND_CONCAT
argument_list|)
operator|+
name|strlen
argument_list|(
name|allargs
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|shell_command
argument_list|,
name|SHELL_COMMAND_CONCAT
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|shell_command
argument_list|,
name|allargs
argument_list|)
expr_stmt|;
else|#
directive|else
name|shell_command
operator|=
name|allargs
expr_stmt|;
endif|#
directive|endif
comment|/* exec is said to fail if the executable is open.  */
name|close_exec_file
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_VFORK
argument_list|)
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"vfork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|TIOCGPGRP
comment|/* Run inferior in a separate process group.  */
name|setpgrp
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGPGRP */
ifdef|#
directive|ifdef
name|SET_STACK_LIMIT_HUGE
comment|/* Reset the stack limit back to what it was.  */
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|original_stack_limit
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SET_STACK_LIMIT_HUGE */
name|inferior_thisrun_terminal
operator|=
name|inferior_io_terminal
expr_stmt|;
if|if
condition|(
name|inferior_io_terminal
operator|!=
literal|0
condition|)
name|new_tty
argument_list|(
name|inferior_io_terminal
argument_list|)
expr_stmt|;
comment|/* It seems that changing the signal handlers for the inferior after    a vfork also changes them for the superior.  See comments in    initialize_signals for how we get the right signal handlers    for the inferior.  */
comment|/* Not needed on Sun, at least, and loses there    because it clobbers the superior.  */
comment|/*???      signal (SIGQUIT, SIG_DFL);       signal (SIGINT, SIG_DFL);  */
name|call_ptrace
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|execle
argument_list|(
name|SHELL_FILE
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|shell_command
argument_list|,
literal|0
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot exec %s: %s.\n"
argument_list|,
name|SHELL_FILE
argument_list|,
name|errno
operator|<
name|sys_nerr
condition|?
name|sys_errlist
index|[
name|errno
index|]
else|:
literal|"unknown error"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TIOCGPGRP
comment|/* Avoid race with TIOCSPGRP: guarantee that inferior's pgrp exists.  */
name|setpgrp
argument_list|(
name|pid
argument_list|,
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGPGRP */
ifdef|#
directive|ifdef
name|CREATE_INFERIOR_HOOK
name|CREATE_INFERIOR_HOOK
argument_list|(
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|pid
return|;
block|}
end_function

begin_comment
comment|/* Kill the inferior process.  Make us have no inferior.  */
end_comment

begin_function
specifier|static
name|void
name|kill_command
parameter_list|()
block|{
if|if
condition|(
name|remote_debugging
condition|)
block|{
name|inferior_pid
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"The program is not being run."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Kill the inferior process? "
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
name|kill_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|inferior_died
parameter_list|()
block|{
name|inferior_pid
operator|=
literal|0
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
name|mark_breakpoints_out
argument_list|()
expr_stmt|;
name|select_frame
argument_list|(
operator|(
name|FRAME
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|reopen_exec_file
argument_list|()
expr_stmt|;
if|if
condition|(
name|have_core_file_p
argument_list|()
condition|)
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|set_current_frame
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This function is just for testing, and on some systems (Sony NewsOS    3.2)<sys/user.h> also includes<sys/time.h> which leads to errors    (since on this system at least sys/time.h is not protected against    multiple inclusion).  */
end_comment

begin_comment
unit|static void try_writing_regs_command () {   register int i;   register int value;   extern int errno;    if (inferior_pid == 0)     error ("There is no inferior process now.");
comment|/* A Sun 3/50 or 3/60 (at least) running SunOS 4.0.3 will have a      kernel panic if we try to write past the end of the user area.      Presumably Sun will fix this bug (it has been reported), but it      is tacky to crash the system, so at least on SunOS4 we need to      stop writing when we hit the end of the user area.  */
end_comment

begin_endif
unit|for (i = 0; i< sizeof (struct user); i += 2)     {       QUIT;       errno = 0;       value = call_ptrace (3, inferior_pid, i, 0);       call_ptrace (6, inferior_pid, i, value);       if (errno == 0) 	{ 	  printf (" Succeeded with address 0x%x; value 0x%x (%d).\n", 		  i, value, value); 	}       else if ((i& 0377) == 0) 	printf (" Failed at 0x%x.\n", i);     } }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|void
name|_initialize_inflow
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"term-status"
argument_list|,
name|class_obscure
argument_list|,
name|term_status_command
argument_list|,
literal|"Print info on inferior's saved terminal status."
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|add_com ("try-writing-regs", class_obscure, try_writing_regs_command, 	   "Try writing all locations in inferior's system block.\n\ Report which ones can be written.");
endif|#
directive|endif
name|add_com
argument_list|(
literal|"kill"
argument_list|,
name|class_run
argument_list|,
name|kill_command
argument_list|,
literal|"Kill execution of program being debugged."
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|sg_ours
argument_list|)
expr_stmt|;
name|tflags_ours
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TIOCGETC_BROKEN
argument_list|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|tc_ours
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGLTC
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|ltc_ours
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCLGET
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|lmode_ours
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGPGRP
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|&
name|pgrp_ours
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGPGRP */
name|terminal_is_ours
operator|=
literal|1
expr_stmt|;
block|}
end_function

end_unit

