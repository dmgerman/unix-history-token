begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convex stuff for GDB.    Copyright (C) 1990 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/thread.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<convex/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<convex/filehdr.h>
end_include

begin_include
include|#
directive|include
file|<convex/opthdr.h>
end_include

begin_include
include|#
directive|include
file|<convex/scnhdr.h>
end_include

begin_include
include|#
directive|include
file|<convex/core.h>
end_include

begin_comment
comment|/* Per-thread data, read from the inferior at each stop and written    back at each resume.  */
end_comment

begin_comment
comment|/* Number of active threads.    Tables are valid for thread numbers less than this.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_threads
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXTHREADS
value|8
end_define

begin_comment
comment|/* Thread state.  The remaining data is valid only if this is PI_TALIVE.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|thread_state
index|[
name|MAXTHREADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stop pc, signal, signal subcode */
end_comment

begin_decl_stmt
specifier|static
name|int
name|thread_pc
index|[
name|MAXTHREADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|thread_signal
index|[
name|MAXTHREADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|thread_sigcode
index|[
name|MAXTHREADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Thread registers.    If thread is selected, the regs are in registers[] instead.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|thread_regs
index|[
name|MAXTHREADS
index|]
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if the top frame on the thread's stack was a context frame,    meaning that the kernel is up to something and we should not    touch the thread at all except to resume it.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|thread_is_in_kernel
index|[
name|MAXTHREADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The currently selected thread's number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inferior_thread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Inferior process's file handle and a process control block    to feed args to ioctl with.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inferior_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcntl
name|ps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SOFF file headers for exec or core file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILEHDR
name|filehdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|OPTHDR
name|opthdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SCNHDR
name|scnhdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address maps constructed from section headers of exec and core files.    Defines process address -> file address translation.  */
end_comment

begin_struct
struct|struct
name|pmap
block|{
name|long
name|mem_addr
decl_stmt|;
comment|/* process start address */
name|long
name|mem_end
decl_stmt|;
comment|/* process end+1 address */
name|long
name|file_addr
decl_stmt|;
comment|/* file start address */
name|long
name|thread
decl_stmt|;
comment|/* -1 shared; 0,1,... thread-local */
name|long
name|type
decl_stmt|;
comment|/* S_TEXT S_DATA S_BSS S_TBSS etc */
name|long
name|which
decl_stmt|;
comment|/* used to sort map for info files */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|n_exec
decl_stmt|,
name|n_core
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pmap
name|exec_map
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pmap
name|core_map
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offsets in the core file of core_context and core_tcontext blocks.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|context_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tcontext_offset
index|[
name|MAXTHREADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Core file control blocks.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|core_context_v70
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|core_tcontext_v70
name|tc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|user
name|u
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|thread_t
name|th
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|proc_t
name|pr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The registers of the currently selected thread.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|registers
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector and communication registers from core dump or from inferior.    These are read on demand, ie, not normally valid.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|vecst
name|vector_registers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|creg_ctx
name|comm_registers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag, set on a vanilla CONT command and cleared when the inferior    is continued.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|all_continue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag, set when the inferior is continued by a vanilla CONT command,    cleared if it is continued for any other purpose.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|thread_switch_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of signals recieved from threads but not yet delivered to gdb.  */
end_comment

begin_struct
struct|struct
name|threadpid
block|{
name|int
name|pid
decl_stmt|;
name|int
name|thread
decl_stmt|;
name|int
name|signo
decl_stmt|;
name|int
name|subsig
decl_stmt|;
name|int
name|pc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|threadpid
name|signal_stack_bot
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|threadpid
modifier|*
name|signal_stack
init|=
name|signal_stack_bot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to detect empty stack -- bottom frame is all zero.  */
end_comment

begin_define
define|#
directive|define
name|signal_stack_is_empty
parameter_list|()
value|(signal_stack->pid == 0)
end_define

begin_comment
comment|/* Mode controlled by SET PIPE command, controls the psw SEQ bit    which forces each instruction to complete before the next one starts.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sequential
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode controlled by the SET PARALLEL command.  Values are:    0  concurrency limit 1 thread, dynamic scheduling    1  no concurrency limit, dynamic scheduling    2  no concurrency limit, fixed scheduling  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|parallel
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode controlled by SET BASE command, output radix for unformatted    integer typeout, as in argument lists, aggregates, and so on.    Zero means guess whether it's an address (hex) or not (decimal).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|output_radix
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Signal subcode at last thread stop.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stop_sigcode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hack, see wait() below.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exec_trap_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined commands.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined set subcommands */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|setlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hook for `exec_file_command' command to call.  */
end_comment

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|exec_file_display_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* File names of core file and executable file.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|corefile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|execfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptors on which core file and executable file are open.    Note that the execchan is closed when an inferior is created    and reopened if the inferior dies or is killed.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|corechan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|execchan
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last modification time of executable file.    Also used in source.c to compare against mtime of a source file.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|exec_mtime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Virtual addresses of bounds of the two areas of memory in the core file.    NB: These variables are set to plausible but useless values on convex.  */
end_comment

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|data_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|data_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|stack_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|stack_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Virtual addresses of bounds of two areas of memory in the exec file.    NB: Only text_start and text_end have meaningful values on convex.  */
end_comment

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|text_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|text_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|exec_data_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|exec_data_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in executable file of start of text area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|text_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in executable file of start of data area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|exec_data_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in core file of start of data area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|data_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in core file of start of stack area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|stack_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a.out header saved in core file.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|exec
name|core_aouthdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a.out header of exec file.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|exec
name|exec_aouthdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Routine to check for exec-core mismatch.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|validate_files
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Nonzero if we are debugging an attached outside process    rather than an inferior.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|attach_flag
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|vector_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
modifier|*
name|read_vector_register
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
modifier|*
name|read_vector_register_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_vector_register
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|REGISTER_TYPE
name|read_comm_register
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_comm_register
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|convex_cont_command
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|thread_continue
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|select_thread
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scan_stack
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_fixed_scheduling
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|subsig_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|psw_info
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|sig_noop
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|ptr_cmp
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_siglist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Execute ptrace.  Convex V7 replaced ptrace with pattach.    Allow ptrace (0) as a no-op.  */
end_comment

begin_function
name|int
name|call_ptrace
parameter_list|(
name|request
parameter_list|,
name|pid
parameter_list|,
name|procaddr
parameter_list|,
name|buf
parameter_list|)
name|int
name|request
decl_stmt|,
name|pid
decl_stmt|,
name|procaddr
decl_stmt|,
name|buf
decl_stmt|;
block|{
if|if
condition|(
name|request
operator|==
literal|0
condition|)
return|return;
name|error
argument_list|(
literal|"no ptrace"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Replacement for system execle routine.    Convert it to an equivalent exect, which pattach insists on.  */
end_comment

begin_macro
name|execle
argument_list|(
argument|name
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
modifier|*
modifier|*
name|envp
init|=
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
operator|&
name|argv
decl_stmt|;
while|while
condition|(
operator|*
name|envp
operator|++
condition|)
empty_stmt|;
name|signal
argument_list|(
name|SIGTRAP
argument_list|,
name|sig_noop
argument_list|)
expr_stmt|;
name|exect
argument_list|(
name|name
argument_list|,
operator|&
name|argv
argument_list|,
operator|*
name|envp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Stupid handler for stupid trace trap that otherwise causes    startup to stupidly hang.  */
end_comment

begin_expr_stmt
specifier|static
name|sig_noop
argument_list|()
block|{}
comment|/* Read registers from inferior into registers[] array.    For convex, they are already there, read in when the inferior stops.  */
name|void
name|fetch_inferior_registers
argument_list|()
block|{ }
comment|/* Store our register values back into the inferior.    For Convex, do this only once, right before resuming inferior.  */
name|store_inferior_registers
argument_list|(
argument|regno
argument_list|)
name|int
name|regno
expr_stmt|;
end_expr_stmt

begin_block
block|{ }
end_block

begin_comment
comment|/* Copy LEN bytes from inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.     On failure (cannot read from inferior, usually because address is out    of bounds) returns the value of errno. */
end_comment

begin_function
name|int
name|read_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* little-known undocumented max request size */
name|int
name|i
init|=
operator|(
name|len
operator|<
literal|12288
operator|)
condition|?
name|len
else|:
literal|12288
decl_stmt|;
name|lseek
argument_list|(
name|inferior_fd
argument_list|,
name|memaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|inferior_fd
argument_list|,
name|myaddr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|memaddr
operator|+=
name|i
expr_stmt|;
name|myaddr
operator|+=
name|i
expr_stmt|;
name|len
operator|-=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|errno
condition|)
name|bzero
argument_list|(
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|errno
return|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.    Returns errno on failure (cannot write the inferior) */
end_comment

begin_function
name|int
name|write_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|lseek
argument_list|(
name|inferior_fd
argument_list|,
name|memaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|inferior_fd
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|errno
return|;
block|}
end_function

begin_comment
comment|/* Here from create_inferior when the inferior process has been created    and started up.  We must do a pattach to grab it for debugging.     Also, intercept the CONT command by altering its dispatch address.  */
end_comment

begin_macro
name|create_inferior_hook
argument_list|(
argument|pid
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pid
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|cont
index|[]
init|=
literal|"cont"
decl_stmt|;
specifier|static
name|char
name|cont1
index|[]
init|=
literal|"c"
decl_stmt|;
name|char
modifier|*
name|linep
init|=
name|cont
decl_stmt|;
name|char
modifier|*
name|linep1
init|=
name|cont1
decl_stmt|;
name|char
modifier|*
modifier|*
name|line
init|=
operator|&
name|linep
decl_stmt|;
name|char
modifier|*
modifier|*
name|line1
init|=
operator|&
name|linep1
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|lookup_cmd
argument_list|(
name|line
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|=
name|convex_cont_command
expr_stmt|;
name|c
operator|=
name|lookup_cmd
argument_list|(
name|line1
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|=
name|convex_cont_command
expr_stmt|;
name|inferior_fd
operator|=
name|pattach
argument_list|(
name|pid
argument_list|,
name|O_EXCL
argument_list|)
expr_stmt|;
if|if
condition|(
name|inferior_fd
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"pattach"
argument_list|)
expr_stmt|;
name|inferior_thread
operator|=
literal|0
expr_stmt|;
name|set_fixed_scheduling
argument_list|(
name|pid
argument_list|,
name|parallel
operator|==
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Attach process PID for debugging.  */
end_comment

begin_macro
name|attach
argument_list|(
argument|pid
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pid
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fd
init|=
name|pattach
argument_list|(
name|pid
argument_list|,
name|O_EXCL
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"pattach"
argument_list|)
expr_stmt|;
name|attach_flag
operator|=
literal|1
expr_stmt|;
comment|/* wait for strange kernel reverberations to go away */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|setpgrp
argument_list|(
name|pid
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|inferior_fd
operator|=
name|fd
expr_stmt|;
name|inferior_thread
operator|=
literal|0
expr_stmt|;
return|return
name|pid
return|;
block|}
end_block

begin_comment
comment|/* Stop debugging the process whose number is PID    and continue it with signal number SIGNAL.    SIGNAL = 0 means just continue it.  */
end_comment

begin_function
name|void
name|detach
parameter_list|(
name|signal
parameter_list|)
name|int
name|signal
decl_stmt|;
block|{
name|signal_stack
operator|=
name|signal_stack_bot
expr_stmt|;
name|thread_continue
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|signal
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXDETACH
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|inferior_fd
argument_list|)
expr_stmt|;
name|inferior_fd
operator|=
literal|0
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Kill off the inferior process.  */
end_comment

begin_macro
name|kill_inferior
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|remote_debugging
condition|)
return|return;
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
return|return;
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXTERMINATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|inferior_died
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This is used when GDB is exiting.  It gives less chance of error.*/
end_comment

begin_macro
name|kill_inferior_fast
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|remote_debugging
condition|)
return|return;
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
return|return;
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXTERMINATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Read vector register REG, and return a pointer to the value.  */
end_comment

begin_function
specifier|static
name|long
modifier|*
name|read_vector_register
parameter_list|(
name|reg
parameter_list|)
name|int
name|reg
decl_stmt|;
block|{
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pi_buffer
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|vector_registers
expr_stmt|;
name|ps
operator|.
name|pi_nbytes
operator|=
sizeof|sizeof
name|vector_registers
expr_stmt|;
name|ps
operator|.
name|pi_offset
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pi_thread
operator|=
name|inferior_thread
expr_stmt|;
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXRDVREGS
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|bzero
argument_list|(
operator|&
name|vector_registers
argument_list|,
sizeof|sizeof
name|vector_registers
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|corechan
operator|>=
literal|0
condition|)
block|{
name|lseek
argument_list|(
name|corechan
argument_list|,
name|tcontext_offset
index|[
name|inferior_thread
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|tc
argument_list|,
sizeof|sizeof
name|tc
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|corechan
argument_list|,
name|tc
operator|.
name|core_thread_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|th
argument_list|,
sizeof|sizeof
name|th
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|corechan
argument_list|,
name|tc
operator|.
name|core_vregs_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|vector_registers
argument_list|,
literal|16
operator|*
literal|128
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|vector_registers
operator|.
name|vm
index|[
literal|0
index|]
operator|=
name|th
operator|.
name|t_vect_ctx
operator|.
name|vc_vm
index|[
literal|0
index|]
expr_stmt|;
name|vector_registers
operator|.
name|vm
index|[
literal|1
index|]
operator|=
name|th
operator|.
name|t_vect_ctx
operator|.
name|vc_vm
index|[
literal|1
index|]
expr_stmt|;
name|vector_registers
operator|.
name|vls
operator|=
name|th
operator|.
name|t_vect_ctx
operator|.
name|vc_vls
expr_stmt|;
block|}
return|return
name|read_vector_register_1
argument_list|(
name|reg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to vector register REG, which must already have been    fetched from the inferior or core file.  */
end_comment

begin_function
specifier|static
name|long
modifier|*
name|read_vector_register_1
parameter_list|(
name|reg
parameter_list|)
name|int
name|reg
decl_stmt|;
block|{
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|VM_REGNUM
case|:
return|return
operator|(
name|long
operator|*
operator|)
name|vector_registers
operator|.
name|vm
return|;
case|case
name|VS_REGNUM
case|:
return|return
operator|(
name|long
operator|*
operator|)
operator|&
name|vector_registers
operator|.
name|vls
return|;
case|case
name|VL_REGNUM
case|:
return|return
literal|1
operator|+
operator|(
name|long
operator|*
operator|)
operator|&
name|vector_registers
operator|.
name|vls
return|;
default|default:
return|return
operator|(
name|long
operator|*
operator|)
operator|&
name|vector_registers
operator|.
name|vr
index|[
name|reg
index|]
return|;
block|}
block|}
end_function

begin_comment
comment|/* Write vector register REG, element ELEMENT, new value VAL.    NB: must use read-modify-write on the entire vector state,    since pattach does not do offsetted writes correctly.  */
end_comment

begin_function
specifier|static
name|void
name|write_vector_register
parameter_list|(
name|reg
parameter_list|,
name|element
parameter_list|,
name|val
parameter_list|)
name|int
name|reg
decl_stmt|,
name|element
decl_stmt|;
name|REGISTER_TYPE
name|val
decl_stmt|;
block|{
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pi_thread
operator|=
name|inferior_thread
expr_stmt|;
name|ps
operator|.
name|pi_offset
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pi_buffer
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|vector_registers
expr_stmt|;
name|ps
operator|.
name|pi_nbytes
operator|=
sizeof|sizeof
name|vector_registers
expr_stmt|;
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXRDVREGS
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|VL_REGNUM
case|:
name|vector_registers
operator|.
name|vls
operator|=
operator|(
name|vector_registers
operator|.
name|vls
operator|&
literal|0xffffffff00000000LL
operator|)
operator|+
operator|(
name|unsigned
name|long
operator|)
name|val
expr_stmt|;
break|break;
case|case
name|VS_REGNUM
case|:
name|vector_registers
operator|.
name|vls
operator|=
operator|(
name|val
operator|<<
literal|32
operator|)
operator|+
operator|(
name|unsigned
name|long
operator|)
name|vector_registers
operator|.
name|vls
expr_stmt|;
break|break;
default|default:
name|vector_registers
operator|.
name|vr
index|[
name|reg
index|]
operator|.
name|el
index|[
name|element
index|]
operator|=
name|val
expr_stmt|;
break|break;
block|}
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXWRVREGS
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"writing vector register"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the contents of communication register NUM.  */
end_comment

begin_function
specifier|static
name|REGISTER_TYPE
name|read_comm_register
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
block|{
name|ps
operator|.
name|pi_buffer
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|comm_registers
expr_stmt|;
name|ps
operator|.
name|pi_nbytes
operator|=
sizeof|sizeof
name|comm_registers
expr_stmt|;
name|ps
operator|.
name|pi_offset
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pi_thread
operator|=
name|inferior_thread
expr_stmt|;
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXRDCREGS
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
block|}
return|return
name|comm_registers
operator|.
name|crreg
operator|.
name|r4
index|[
name|num
index|]
return|;
block|}
end_function

begin_comment
comment|/* Store a new value VAL into communication register NUM.      NB: Must use read-modify-write on the whole comm register set    since pattach does not do offsetted writes correctly.  */
end_comment

begin_function
specifier|static
name|void
name|write_comm_register
parameter_list|(
name|num
parameter_list|,
name|val
parameter_list|)
name|int
name|num
decl_stmt|;
name|REGISTER_TYPE
name|val
decl_stmt|;
block|{
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
block|{
name|ps
operator|.
name|pi_buffer
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|comm_registers
expr_stmt|;
name|ps
operator|.
name|pi_nbytes
operator|=
sizeof|sizeof
name|comm_registers
expr_stmt|;
name|ps
operator|.
name|pi_offset
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pi_thread
operator|=
name|inferior_thread
expr_stmt|;
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXRDCREGS
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
name|comm_registers
operator|.
name|crreg
operator|.
name|r4
index|[
name|num
index|]
operator|=
name|val
expr_stmt|;
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXWRCREGS
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Resume execution of the inferior process.    If STEP is nonzero, single-step it.    If SIGNAL is nonzero, give it that signal.  */
end_comment

begin_function
name|void
name|resume
parameter_list|(
name|step
parameter_list|,
name|signal
parameter_list|)
name|int
name|step
decl_stmt|;
name|int
name|signal
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
name|remote_resume
argument_list|(
name|step
argument_list|,
name|signal
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|step
operator|||
name|signal
condition|)
name|thread_continue
argument_list|(
name|inferior_thread
argument_list|,
name|step
argument_list|,
name|signal
argument_list|)
expr_stmt|;
else|else
name|thread_continue
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Maybe resume some threads.    THREAD is which thread to resume, or -1 to resume them all.    STEP and SIGNAL are as in resume.     Global variable ALL_CONTINUE is set when we are here to do a    `cont' command; otherwise we may be doing `finish' or a call or    something else that will not tolerate an automatic thread switch.     If there are stopped threads waiting to deliver signals, and    ALL_CONTINUE, do not actually resume anything.  gdb will do a wait    and see one of the stopped threads in the queue.  */
end_comment

begin_function
specifier|static
name|void
name|thread_continue
parameter_list|(
name|thread
parameter_list|,
name|step
parameter_list|,
name|signal
parameter_list|)
name|int
name|thread
decl_stmt|,
name|step
decl_stmt|,
name|signal
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
comment|/* If we are to continue all threads, but not for the CONTINUE command,      pay no attention and continue only the selected thread.  */
if|if
condition|(
name|thread
operator|<
literal|0
operator|&&
operator|!
name|all_continue
condition|)
name|thread
operator|=
name|inferior_thread
expr_stmt|;
comment|/* If we are not stepping, we have now executed the continue part      of a CONTINUE command.  */
if|if
condition|(
operator|!
name|step
condition|)
name|all_continue
operator|=
literal|0
expr_stmt|;
comment|/* Allow wait() to switch threads if this is an all-out continue.  */
name|thread_switch_ok
operator|=
name|thread
operator|<
literal|0
expr_stmt|;
comment|/* If there are threads queued up, don't resume.  */
if|if
condition|(
name|thread_switch_ok
operator|&&
operator|!
name|signal_stack_is_empty
argument_list|()
condition|)
return|return;
comment|/* OK, do it.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_threads
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|thread_state
index|[
name|n
index|]
operator|==
name|PI_TALIVE
condition|)
block|{
name|select_thread
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|thread
operator|<
literal|0
operator|||
name|n
operator|==
name|thread
operator|)
operator|&&
operator|!
name|thread_is_in_kernel
index|[
name|n
index|]
condition|)
block|{
comment|/* Blam the trace bits in the stack's saved psws to match  	       the desired step mode.  This is required so that 	       single-stepping a return doesn't restore a psw with a 	       clear trace bit and fly away, and conversely, 	       proceeding through a return in a routine that was 	       stepped into doesn't cause a phantom break by restoring 	       a psw with the trace bit set. */
name|scan_stack
argument_list|(
name|PSW_T_BIT
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|scan_stack
argument_list|(
name|PSW_S_BIT
argument_list|,
name|sequential
argument_list|)
expr_stmt|;
block|}
name|ps
operator|.
name|pi_buffer
operator|=
name|registers
expr_stmt|;
name|ps
operator|.
name|pi_nbytes
operator|=
name|REGISTER_BYTES
expr_stmt|;
name|ps
operator|.
name|pi_offset
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pi_thread
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|!
name|thread_is_in_kernel
index|[
name|n
index|]
condition|)
if|if
condition|(
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXWRREGS
argument_list|,
operator|&
name|ps
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"PIXWRREGS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|<
literal|0
operator|||
name|n
operator|==
name|thread
condition|)
block|{
name|ps
operator|.
name|pi_pc
operator|=
literal|1
expr_stmt|;
name|ps
operator|.
name|pi_signo
operator|=
name|signal
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|step
condition|?
name|PIXSTEP
else|:
name|PIXCONTINUE
argument_list|,
operator|&
name|ps
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"PIXCONTINUE"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXRUN
argument_list|,
operator|&
name|ps
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"PIXRUN"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Replacement for system wait routine.       The system wait returns with one or more threads stopped by    signals.  Put stopped threads on a stack and return them one by    one, so that it appears that wait returns one thread at a time.     Global variable THREAD_SWITCH_OK is set when gdb can tolerate wait    returning a new thread.  If it is false, then only one thread is    running; we will do a real wait, the thread will do something, and    we will return that.  */
end_comment

begin_function
name|pid_t
name|wait
parameter_list|(
name|w
parameter_list|)
name|union
name|wait
modifier|*
name|w
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
return|return
name|wait3
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Do a real wait if we were told to, or if there are no queued threads.  */
if|if
condition|(
operator|!
name|thread_switch_ok
operator|||
name|signal_stack_is_empty
argument_list|()
condition|)
block|{
name|int
name|thread
decl_stmt|;
name|pid
operator|=
name|wait3
argument_list|(
name|w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
operator|*
name|w
argument_list|)
operator|||
name|pid
operator|!=
name|inferior_pid
condition|)
return|return
name|pid
return|;
comment|/* The inferior has done something and stopped.  Read in all the 	 threads' registers, and queue up any signals that happened.  */
if|if
condition|(
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXGETTHCOUNT
argument_list|,
operator|&
name|ps
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"PIXGETTHCOUNT"
argument_list|)
expr_stmt|;
name|n_threads
operator|=
name|ps
operator|.
name|pi_othdcnt
expr_stmt|;
for|for
control|(
name|thread
operator|=
literal|0
init|;
name|thread
operator|<
name|n_threads
condition|;
name|thread
operator|++
control|)
block|{
name|ps
operator|.
name|pi_thread
operator|=
name|thread
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXGETSUBCODE
argument_list|,
operator|&
name|ps
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"PIXGETSUBCODE"
argument_list|)
expr_stmt|;
name|thread_state
index|[
name|thread
index|]
operator|=
name|ps
operator|.
name|pi_otstate
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|pi_otstate
operator|==
name|PI_TALIVE
condition|)
block|{
name|select_thread
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|ps
operator|.
name|pi_buffer
operator|=
name|registers
expr_stmt|;
name|ps
operator|.
name|pi_nbytes
operator|=
name|REGISTER_BYTES
expr_stmt|;
name|ps
operator|.
name|pi_offset
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pi_thread
operator|=
name|thread
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXRDREGS
argument_list|,
operator|&
name|ps
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"PIXRDREGS"
argument_list|)
expr_stmt|;
name|thread_pc
index|[
name|thread
index|]
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|thread_signal
index|[
name|thread
index|]
operator|=
name|ps
operator|.
name|pi_osigno
expr_stmt|;
name|thread_sigcode
index|[
name|thread
index|]
operator|=
name|ps
operator|.
name|pi_osigcode
expr_stmt|;
comment|/* If the thread's stack has a context frame 		 on top, something fucked is going on.  I do not 		 know what, but do I know this: the only thing you 		 can do with such a thread is continue it.  */
name|thread_is_in_kernel
index|[
name|thread
index|]
operator|=
operator|(
operator|(
name|read_register
argument_list|(
name|PS_REGNUM
argument_list|)
operator|>>
literal|25
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
expr_stmt|;
comment|/* Signals push an extended frame and then fault 		 with a ridiculous pc.  Pop the frame.  */
if|if
condition|(
name|thread_pc
index|[
name|thread
index|]
operator|>
name|STACK_END_ADDR
condition|)
block|{
name|POP_FRAME
expr_stmt|;
if|if
condition|(
name|is_break_pc
argument_list|(
name|thread_pc
index|[
name|thread
index|]
argument_list|)
condition|)
name|thread_pc
index|[
name|thread
index|]
operator|=
name|read_pc
argument_list|()
operator|-
literal|2
expr_stmt|;
else|else
name|thread_pc
index|[
name|thread
index|]
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|thread_pc
index|[
name|thread
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ps
operator|.
name|pi_osigno
operator|||
name|ps
operator|.
name|pi_osigcode
condition|)
block|{
name|signal_stack
operator|++
expr_stmt|;
name|signal_stack
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
name|signal_stack
operator|->
name|thread
operator|=
name|thread
expr_stmt|;
name|signal_stack
operator|->
name|signo
operator|=
name|thread_signal
index|[
name|thread
index|]
expr_stmt|;
name|signal_stack
operator|->
name|subsig
operator|=
name|thread_sigcode
index|[
name|thread
index|]
expr_stmt|;
name|signal_stack
operator|->
name|pc
operator|=
name|thread_pc
index|[
name|thread
index|]
expr_stmt|;
block|}
comment|/* The following hackery is caused by a unix 7.1 feature: 		 the inferior's fixed scheduling mode is cleared when 		 it execs the shell (since the shell is not a parallel 		 program).  So, note the 5.4 trap we get when 		 the shell does its exec, then catch the 5.0 trap  		 that occurs when the debuggee starts, and set fixed 		 scheduling mode properly.  */
if|if
condition|(
name|ps
operator|.
name|pi_osigno
operator|==
literal|5
operator|&&
name|ps
operator|.
name|pi_osigcode
operator|==
literal|4
condition|)
name|exec_trap_timer
operator|=
literal|1
expr_stmt|;
else|else
name|exec_trap_timer
operator|--
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|pi_osigno
operator|==
literal|5
operator|&&
name|exec_trap_timer
operator|==
literal|0
condition|)
name|set_fixed_scheduling
argument_list|(
name|pid
argument_list|,
name|parallel
operator|==
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|signal_stack_is_empty
argument_list|()
condition|)
name|error
argument_list|(
literal|"no active threads?!"
argument_list|)
expr_stmt|;
block|}
comment|/* Select the thread that stopped, and return *w saying why.  */
name|select_thread
argument_list|(
name|signal_stack
operator|->
name|thread
argument_list|)
expr_stmt|;
name|stop_signal
operator|=
name|signal_stack
operator|->
name|signo
expr_stmt|;
name|stop_sigcode
operator|=
name|signal_stack
operator|->
name|subsig
expr_stmt|;
name|WSETSTOP
argument_list|(
operator|*
name|w
argument_list|,
name|signal_stack
operator|->
name|signo
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_thread
operator|=
name|signal_stack
operator|->
name|thread
expr_stmt|;
return|return
operator|(
name|signal_stack
operator|--
operator|)
operator|->
name|pid
return|;
block|}
end_function

begin_comment
comment|/* Select thread THREAD -- its registers, stack, per-thread memory.    This is the only routine that may assign to inferior_thread    or thread_regs[].  */
end_comment

begin_function
specifier|static
name|void
name|select_thread
parameter_list|(
name|thread
parameter_list|)
name|int
name|thread
decl_stmt|;
block|{
if|if
condition|(
name|thread
operator|==
name|inferior_thread
condition|)
return|return;
name|bcopy
argument_list|(
name|registers
argument_list|,
name|thread_regs
index|[
name|inferior_thread
index|]
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
name|ps
operator|.
name|pi_thread
operator|=
name|inferior_thread
operator|=
name|thread
expr_stmt|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PISETRWTID
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|thread_regs
index|[
name|thread
index|]
argument_list|,
name|registers
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Routine to set or clear a psw bit in the psw and also all psws    saved on the stack.  Quits when we get to a frame in which the    saved psw is correct. */
end_comment

begin_function
specifier|static
name|void
name|scan_stack
parameter_list|(
name|bit
parameter_list|,
name|val
parameter_list|)
name|long
name|bit
decl_stmt|,
name|val
decl_stmt|;
block|{
name|long
name|ps
init|=
name|read_register
argument_list|(
name|PS_REGNUM
argument_list|)
decl_stmt|;
name|long
name|fp
decl_stmt|;
if|if
condition|(
name|val
condition|?
operator|!
operator|(
name|ps
operator|&
name|bit
operator|)
else|:
operator|(
name|ps
operator|&
name|bit
operator|)
condition|)
block|{
name|ps
operator|^=
name|bit
expr_stmt|;
name|write_register
argument_list|(
name|PS_REGNUM
argument_list|,
name|ps
argument_list|)
expr_stmt|;
name|fp
operator|=
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
expr_stmt|;
while|while
condition|(
name|fp
operator|&
literal|0x80000000
condition|)
block|{
name|ps
operator|=
name|read_memory_integer
argument_list|(
name|fp
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|?
operator|(
name|ps
operator|&
name|bit
operator|)
else|:
operator|!
operator|(
name|ps
operator|&
name|bit
operator|)
condition|)
break|break;
name|ps
operator|^=
name|bit
expr_stmt|;
name|write_memory
argument_list|(
name|fp
operator|+
literal|4
argument_list|,
operator|&
name|ps
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fp
operator|=
name|read_memory_integer
argument_list|(
name|fp
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Set fixed scheduling (alliant mode) of process PID to ARG (0 or 1).  */
end_comment

begin_function
specifier|static
name|void
name|set_fixed_scheduling
parameter_list|(
name|pid
parameter_list|,
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|struct
name|pattributes
name|pattr
decl_stmt|;
name|getpattr
argument_list|(
name|pid
argument_list|,
operator|&
name|pattr
argument_list|)
expr_stmt|;
name|pattr
operator|.
name|pattr_pfixed
operator|=
name|arg
expr_stmt|;
name|setpattr
argument_list|(
name|pid
argument_list|,
operator|&
name|pattr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|core_file_command
argument_list|(
argument|filename
argument_list|,
argument|from_tty
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|from_tty
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
comment|/* Discard all vestiges of any previous core file      and mark data and stack spaces as empty.  */
if|if
condition|(
name|corefile
condition|)
name|free
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|corefile
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|corechan
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|corechan
argument_list|)
expr_stmt|;
name|corechan
operator|=
operator|-
literal|1
expr_stmt|;
name|data_start
operator|=
literal|0
expr_stmt|;
name|data_end
operator|=
literal|0
expr_stmt|;
name|stack_start
operator|=
name|STACK_END_ADDR
expr_stmt|;
name|stack_end
operator|=
name|STACK_END_ADDR
expr_stmt|;
name|n_core
operator|=
literal|0
expr_stmt|;
comment|/* Now, if a new core file was specified, open it and digest it.  */
if|if
condition|(
name|filename
condition|)
block|{
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"To look at a core file, you must kill the inferior with \"kill\"."
argument_list|)
expr_stmt|;
name|corechan
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|corechan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|filehdr
argument_list|,
sizeof|sizeof
name|filehdr
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_CORE_SOFF_MAGIC
argument_list|(
name|filehdr
operator|.
name|h_magic
argument_list|)
condition|)
name|error
argument_list|(
literal|"%s: not a core file.\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|opthdr
argument_list|,
name|filehdr
operator|.
name|h_opthdr
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Read through the section headers. 	 For text, data, etc, record an entry in the core file map. 	 For context and tcontext, record the file address of 	 the context blocks.  */
name|lseek
argument_list|(
name|corechan
argument_list|,
operator|(
name|long
operator|)
name|filehdr
operator|.
name|h_scnptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n_threads
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|filehdr
operator|.
name|h_nscns
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|scnhdr
argument_list|,
sizeof|sizeof
name|scnhdr
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scnhdr
operator|.
name|s_flags
operator|&
name|S_TYPMASK
operator|)
operator|>=
name|S_TEXT
operator|&&
operator|(
name|scnhdr
operator|.
name|s_flags
operator|&
name|S_TYPMASK
operator|)
operator|<=
name|S_COMON
condition|)
block|{
name|core_map
index|[
name|n_core
index|]
operator|.
name|mem_addr
operator|=
name|scnhdr
operator|.
name|s_vaddr
expr_stmt|;
name|core_map
index|[
name|n_core
index|]
operator|.
name|mem_end
operator|=
name|scnhdr
operator|.
name|s_vaddr
operator|+
name|scnhdr
operator|.
name|s_size
expr_stmt|;
name|core_map
index|[
name|n_core
index|]
operator|.
name|file_addr
operator|=
name|scnhdr
operator|.
name|s_scnptr
expr_stmt|;
name|core_map
index|[
name|n_core
index|]
operator|.
name|type
operator|=
name|scnhdr
operator|.
name|s_flags
operator|&
name|S_TYPMASK
expr_stmt|;
if|if
condition|(
name|core_map
index|[
name|n_core
index|]
operator|.
name|type
operator|!=
name|S_TBSS
operator|&&
name|core_map
index|[
name|n_core
index|]
operator|.
name|type
operator|!=
name|S_TDATA
operator|&&
name|core_map
index|[
name|n_core
index|]
operator|.
name|type
operator|!=
name|S_TTEXT
condition|)
name|core_map
index|[
name|n_core
index|]
operator|.
name|thread
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|n_core
operator|==
literal|0
operator|||
name|core_map
index|[
name|n_core
operator|-
literal|1
index|]
operator|.
name|mem_addr
operator|!=
name|scnhdr
operator|.
name|s_vaddr
condition|)
name|core_map
index|[
name|n_core
index|]
operator|.
name|thread
operator|=
literal|0
expr_stmt|;
else|else
name|core_map
index|[
name|n_core
index|]
operator|.
name|thread
operator|=
name|core_map
index|[
name|n_core
operator|-
literal|1
index|]
operator|.
name|thread
operator|+
literal|1
expr_stmt|;
name|n_core
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scnhdr
operator|.
name|s_flags
operator|&
name|S_TYPMASK
operator|)
operator|==
name|S_CONTEXT
condition|)
name|context_offset
operator|=
name|scnhdr
operator|.
name|s_scnptr
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|scnhdr
operator|.
name|s_flags
operator|&
name|S_TYPMASK
operator|)
operator|==
name|S_TCONTEXT
condition|)
name|tcontext_offset
index|[
name|n_threads
operator|++
index|]
operator|=
name|scnhdr
operator|.
name|s_scnptr
expr_stmt|;
block|}
comment|/* Read the context block, struct user, struct proc, 	 and the comm regs.  */
name|lseek
argument_list|(
name|corechan
argument_list|,
name|context_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
name|c
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|corechan
argument_list|,
name|c
operator|.
name|core_user_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|corechan
argument_list|,
name|c
operator|.
name|core_proc_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|pr
argument_list|,
sizeof|sizeof
name|pr
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|comm_registers
operator|=
name|pr
operator|.
name|p_creg
expr_stmt|;
comment|/* Core file apparently is really there.  Make it really exist 	 for xfer_core_file so we can do read_memory on it. */
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|corefile
operator|=
name|savestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|corefile
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Program %s "
argument_list|,
name|u
operator|.
name|u_comm
argument_list|)
expr_stmt|;
comment|/* Read the thread registers and fill in the thread_xxx[] data.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_threads
condition|;
name|n
operator|++
control|)
block|{
name|select_thread
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|corechan
argument_list|,
name|tcontext_offset
index|[
name|n
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|tc
argument_list|,
sizeof|sizeof
name|tc
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|corechan
argument_list|,
name|tc
operator|.
name|core_thread_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|th
argument_list|,
sizeof|sizeof
name|th
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|corechan
argument_list|,
name|tc
operator|.
name|core_syscall_context_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
name|registers
argument_list|,
name|REGISTER_BYTES
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|thread_signal
index|[
name|n
index|]
operator|=
name|th
operator|.
name|t_cursig
expr_stmt|;
name|thread_sigcode
index|[
name|n
index|]
operator|=
name|th
operator|.
name|t_code
expr_stmt|;
name|thread_state
index|[
name|n
index|]
operator|=
name|th
operator|.
name|t_state
expr_stmt|;
name|thread_pc
index|[
name|n
index|]
operator|=
name|read_pc
argument_list|()
expr_stmt|;
if|if
condition|(
name|thread_pc
index|[
name|n
index|]
operator|>
name|STACK_END_ADDR
condition|)
block|{
name|POP_FRAME
expr_stmt|;
if|if
condition|(
name|is_break_pc
argument_list|(
name|thread_pc
index|[
name|n
index|]
argument_list|)
condition|)
name|thread_pc
index|[
name|n
index|]
operator|=
name|read_pc
argument_list|()
operator|-
literal|2
expr_stmt|;
else|else
name|thread_pc
index|[
name|n
index|]
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|thread_pc
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"thread %d received signal %d, %s\n"
argument_list|,
name|n
argument_list|,
name|thread_signal
index|[
name|n
index|]
argument_list|,
name|thread_signal
index|[
name|n
index|]
operator|<
name|NSIG
condition|?
name|sys_siglist
index|[
name|thread_signal
index|[
name|n
index|]
index|]
else|:
literal|"(undocumented)"
argument_list|)
expr_stmt|;
block|}
comment|/* Select an interesting thread -- also-rans died with SIGKILL, 	 so find one that didn't.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_threads
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|thread_signal
index|[
name|n
index|]
operator|!=
literal|0
operator|&&
name|thread_signal
index|[
name|n
index|]
operator|!=
name|SIGKILL
condition|)
block|{
name|select_thread
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|stop_signal
operator|=
name|thread_signal
index|[
name|n
index|]
expr_stmt|;
name|stop_sigcode
operator|=
name|thread_sigcode
index|[
name|n
index|]
expr_stmt|;
break|break;
block|}
name|core_aouthdr
operator|.
name|a_magic
operator|=
literal|0
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|validate_files
argument_list|()
expr_stmt|;
name|print_sel_frame
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"No core file now.\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|exec_file_command
argument_list|(
argument|filename
argument_list|,
argument|from_tty
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|from_tty
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|stat
name|st_exec
decl_stmt|;
comment|/* Eliminate all traces of old exec file.      Mark text segment as empty.  */
if|if
condition|(
name|execfile
condition|)
name|free
argument_list|(
name|execfile
argument_list|)
expr_stmt|;
name|execfile
operator|=
literal|0
expr_stmt|;
name|data_start
operator|=
literal|0
expr_stmt|;
name|data_end
operator|=
literal|0
expr_stmt|;
name|text_start
operator|=
literal|0
expr_stmt|;
name|text_end
operator|=
literal|0
expr_stmt|;
name|exec_data_start
operator|=
literal|0
expr_stmt|;
name|exec_data_end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|execchan
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|execchan
argument_list|)
expr_stmt|;
name|execchan
operator|=
operator|-
literal|1
expr_stmt|;
name|n_exec
operator|=
literal|0
expr_stmt|;
comment|/* Now open and digest the file the user requested, if any.  */
if|if
condition|(
name|filename
condition|)
block|{
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|execchan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|execfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|execchan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|execchan
argument_list|,
operator|&
name|filehdr
argument_list|,
sizeof|sizeof
name|filehdr
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_SOFF_MAGIC
argument_list|(
name|filehdr
operator|.
name|h_magic
argument_list|)
condition|)
name|error
argument_list|(
literal|"%s: not an executable file."
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|execchan
argument_list|,
operator|&
name|opthdr
argument_list|,
name|filehdr
operator|.
name|h_opthdr
argument_list|)
operator|<=
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Read through the section headers. 	 For text, data, etc, record an entry in the exec file map. 	 Record text_start and text_end.  */
name|lseek
argument_list|(
name|execchan
argument_list|,
operator|(
name|long
operator|)
name|filehdr
operator|.
name|h_scnptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|filehdr
operator|.
name|h_nscns
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|myread
argument_list|(
name|execchan
argument_list|,
operator|&
name|scnhdr
argument_list|,
sizeof|sizeof
name|scnhdr
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scnhdr
operator|.
name|s_flags
operator|&
name|S_TYPMASK
operator|)
operator|>=
name|S_TEXT
operator|&&
operator|(
name|scnhdr
operator|.
name|s_flags
operator|&
name|S_TYPMASK
operator|)
operator|<=
name|S_COMON
condition|)
block|{
name|exec_map
index|[
name|n_exec
index|]
operator|.
name|mem_addr
operator|=
name|scnhdr
operator|.
name|s_vaddr
expr_stmt|;
name|exec_map
index|[
name|n_exec
index|]
operator|.
name|mem_end
operator|=
name|scnhdr
operator|.
name|s_vaddr
operator|+
name|scnhdr
operator|.
name|s_size
expr_stmt|;
name|exec_map
index|[
name|n_exec
index|]
operator|.
name|file_addr
operator|=
name|scnhdr
operator|.
name|s_scnptr
expr_stmt|;
name|exec_map
index|[
name|n_exec
index|]
operator|.
name|type
operator|=
name|scnhdr
operator|.
name|s_flags
operator|&
name|S_TYPMASK
expr_stmt|;
name|n_exec
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|scnhdr
operator|.
name|s_flags
operator|&
name|S_TYPMASK
operator|)
operator|==
name|S_TEXT
condition|)
block|{
name|text_start
operator|=
name|scnhdr
operator|.
name|s_vaddr
expr_stmt|;
name|text_end
operator|=
name|scnhdr
operator|.
name|s_vaddr
operator|+
name|scnhdr
operator|.
name|s_size
expr_stmt|;
block|}
block|}
block|}
name|fstat
argument_list|(
name|execchan
argument_list|,
operator|&
name|st_exec
argument_list|)
expr_stmt|;
name|exec_mtime
operator|=
name|st_exec
operator|.
name|st_mtime
expr_stmt|;
name|validate_files
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"No exec file now.\n"
argument_list|)
expr_stmt|;
comment|/* Tell display code (if any) about the changed file name.  */
if|if
condition|(
name|exec_file_display_hook
condition|)
call|(
modifier|*
name|exec_file_display_hook
call|)
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Read data from SOFF exec or core file.    Return 0 on success, 1 if address could not be read. */
end_comment

begin_function
name|int
name|xfer_core_file
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|val
decl_stmt|;
name|int
name|xferchan
decl_stmt|;
name|char
modifier|*
modifier|*
name|xferfile
decl_stmt|;
name|int
name|fileptr
decl_stmt|;
name|int
name|returnval
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|xferfile
operator|=
literal|0
expr_stmt|;
name|xferchan
operator|=
literal|0
expr_stmt|;
comment|/* Determine which file the next bunch of addresses reside in, 	 and where in the file.  Set the file's read/write pointer 	 to point at the proper place for the desired address 	 and set xferfile and xferchan for the correct file. 	 If desired address is nonexistent, leave them zero. 	 i is set to the number of bytes that can be handled 	 along with the next address.  */
name|i
operator|=
name|len
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_core
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|memaddr
operator|>=
name|core_map
index|[
name|n
index|]
operator|.
name|mem_addr
operator|&&
name|memaddr
operator|<
name|core_map
index|[
name|n
index|]
operator|.
name|mem_end
operator|&&
operator|(
name|core_map
index|[
name|n
index|]
operator|.
name|thread
operator|==
operator|-
literal|1
operator|||
name|core_map
index|[
name|n
index|]
operator|.
name|thread
operator|==
name|inferior_thread
operator|)
condition|)
block|{
name|i
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|core_map
index|[
name|n
index|]
operator|.
name|mem_end
operator|-
name|memaddr
argument_list|)
expr_stmt|;
name|fileptr
operator|=
name|core_map
index|[
name|n
index|]
operator|.
name|file_addr
operator|+
name|memaddr
operator|-
name|core_map
index|[
name|n
index|]
operator|.
name|mem_addr
expr_stmt|;
if|if
condition|(
name|core_map
index|[
name|n
index|]
operator|.
name|file_addr
condition|)
block|{
name|xferfile
operator|=
operator|&
name|corefile
expr_stmt|;
name|xferchan
operator|=
name|corechan
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|core_map
index|[
name|n
index|]
operator|.
name|mem_addr
operator|>=
name|memaddr
operator|&&
name|core_map
index|[
name|n
index|]
operator|.
name|mem_addr
operator|<
name|memaddr
operator|+
name|i
condition|)
name|i
operator|=
name|core_map
index|[
name|n
index|]
operator|.
name|mem_addr
operator|-
name|memaddr
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|xferfile
condition|)
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_exec
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|memaddr
operator|>=
name|exec_map
index|[
name|n
index|]
operator|.
name|mem_addr
operator|&&
name|memaddr
operator|<
name|exec_map
index|[
name|n
index|]
operator|.
name|mem_end
condition|)
block|{
name|i
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|exec_map
index|[
name|n
index|]
operator|.
name|mem_end
operator|-
name|memaddr
argument_list|)
expr_stmt|;
name|fileptr
operator|=
name|exec_map
index|[
name|n
index|]
operator|.
name|file_addr
operator|+
name|memaddr
operator|-
name|exec_map
index|[
name|n
index|]
operator|.
name|mem_addr
expr_stmt|;
if|if
condition|(
name|exec_map
index|[
name|n
index|]
operator|.
name|file_addr
condition|)
block|{
name|xferfile
operator|=
operator|&
name|execfile
expr_stmt|;
name|xferchan
operator|=
name|execchan
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|exec_map
index|[
name|n
index|]
operator|.
name|mem_addr
operator|>=
name|memaddr
operator|&&
name|exec_map
index|[
name|n
index|]
operator|.
name|mem_addr
operator|<
name|memaddr
operator|+
name|i
condition|)
name|i
operator|=
name|exec_map
index|[
name|n
index|]
operator|.
name|mem_addr
operator|-
name|memaddr
expr_stmt|;
block|}
comment|/* Now we know which file to use. 	 Set up its pointer and transfer the data.  */
if|if
condition|(
name|xferfile
condition|)
block|{
if|if
condition|(
operator|*
name|xferfile
operator|==
literal|0
condition|)
if|if
condition|(
name|xferfile
operator|==
operator|&
name|execfile
condition|)
name|error
argument_list|(
literal|"No program file to examine."
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No core dump file or running program to examine."
argument_list|)
expr_stmt|;
name|val
operator|=
name|lseek
argument_list|(
name|xferchan
argument_list|,
name|fileptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
operator|*
name|xferfile
argument_list|)
expr_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|xferchan
argument_list|,
name|myaddr
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
operator|*
name|xferfile
argument_list|)
expr_stmt|;
block|}
comment|/* If this address is for nonexistent memory, 	 read zeros if reading, or do nothing if writing.  */
else|else
block|{
name|bzero
argument_list|(
name|myaddr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|returnval
operator|=
literal|1
expr_stmt|;
block|}
name|memaddr
operator|+=
name|i
expr_stmt|;
name|myaddr
operator|+=
name|i
expr_stmt|;
name|len
operator|-=
name|i
expr_stmt|;
block|}
return|return
name|returnval
return|;
block|}
end_function

begin_comment
comment|/* Here from info files command to print an address map.  */
end_comment

begin_macro
name|print_maps
argument_list|()
end_macro

begin_block
block|{
name|struct
name|pmap
name|ptrs
index|[
literal|200
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* ID strings for core and executable file sections */
specifier|static
name|char
modifier|*
name|idstr
index|[]
init|=
block|{
literal|"0"
block|,
literal|"text"
block|,
literal|"data"
block|,
literal|"tdata"
block|,
literal|"bss"
block|,
literal|"tbss"
block|,
literal|"common"
block|,
literal|"ttext"
block|,
literal|"ctx"
block|,
literal|"tctx"
block|,
literal|"10"
block|,
literal|"11"
block|,
literal|"12"
block|,     }
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_core
condition|;
name|n
operator|++
control|)
block|{
name|core_map
index|[
name|n
index|]
operator|.
name|which
operator|=
literal|0
expr_stmt|;
name|ptrs
index|[
name|n
index|]
operator|=
name|core_map
index|[
name|n
index|]
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_exec
condition|;
name|n
operator|++
control|)
block|{
name|exec_map
index|[
name|n
index|]
operator|.
name|which
operator|=
literal|1
expr_stmt|;
name|ptrs
index|[
name|n_core
operator|+
name|n
index|]
operator|=
name|exec_map
index|[
name|n
index|]
expr_stmt|;
block|}
name|qsort
argument_list|(
name|ptrs
argument_list|,
name|n_core
operator|+
name|n_exec
argument_list|,
sizeof|sizeof
expr|*
name|ptrs
argument_list|,
name|ptr_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_core
operator|+
name|n_exec
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|pmap
modifier|*
name|p
init|=
operator|&
name|ptrs
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|mem_addr
operator|<
name|ptrs
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|mem_end
condition|)
name|p
operator|->
name|mem_addr
operator|=
name|ptrs
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|mem_end
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|mem_addr
operator|>=
name|p
operator|->
name|mem_end
condition|)
continue|continue;
block|}
name|printf_filtered
argument_list|(
literal|"%08x .. %08x  %-6s  %s\n"
argument_list|,
name|p
operator|->
name|mem_addr
argument_list|,
name|p
operator|->
name|mem_end
argument_list|,
name|idstr
index|[
name|p
operator|->
name|type
index|]
argument_list|,
name|p
operator|->
name|which
condition|?
name|execfile
else|:
name|corefile
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Compare routine to put file sections in order.    Sort into increasing order on address, and put core file sections    before exec file sections if both files contain the same addresses.  */
end_comment

begin_expr_stmt
specifier|static
name|ptr_cmp
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
expr|struct
name|pmap
operator|*
name|a
operator|,
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|a
operator|->
name|mem_addr
operator|!=
name|b
operator|->
name|mem_addr
condition|)
return|return
name|a
operator|->
name|mem_addr
operator|-
name|b
operator|->
name|mem_addr
return|;
return|return
name|a
operator|->
name|which
operator|-
name|b
operator|->
name|which
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Trapped internal variables are used to handle special registers.    A trapped i.v. calls a hook here every time it is dereferenced,    to provide a new value for the variable, and it calls a hook here    when a new value is assigned, to do something with the value.        The vector registers are $vl, $vs, $vm, $vN, $VN (N in 0..7).    The communication registers are $cN, $CN (N in 0..63).    They not handled as regular registers because it's expensive to    read them, and their size varies, and they have too many names.  */
end_comment

begin_comment
comment|/* Return 1 if NAME is a trapped internal variable, else 0. */
end_comment

begin_function
name|int
name|is_trapped_internalvar
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'c'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'C'
operator|)
operator|&&
name|name
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|name
index|[
literal|1
index|]
operator|<=
literal|'9'
operator|&&
operator|(
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|name
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|name
index|[
literal|2
index|]
operator|<=
literal|'9'
operator|&&
name|name
index|[
literal|3
index|]
operator|==
literal|'\0'
operator|&&
name|name
index|[
literal|1
index|]
operator|!=
literal|'0'
operator|)
operator|)
operator|&&
name|atoi
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|)
operator|<
literal|64
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'v'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'V'
operator|)
operator|&&
operator|(
operator|(
operator|(
name|name
index|[
literal|1
index|]
operator|&
operator|-
literal|8
operator|)
operator|==
literal|'0'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"vl"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"vs"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"vm"
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the value of trapped internal variable VAR */
end_comment

begin_function
name|value
name|value_of_trapped_internalvar
parameter_list|(
name|var
parameter_list|)
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|var
operator|->
name|name
decl_stmt|;
name|value
name|val
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|long
name|len
init|=
operator|*
name|read_vector_register
argument_list|(
name|VL_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
name|len
operator|>
literal|128
condition|)
name|len
operator|=
literal|128
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"vl"
argument_list|)
condition|)
block|{
name|val
operator|=
name|value_from_long
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
operator|*
name|read_vector_register_1
argument_list|(
name|VL_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"vs"
argument_list|)
condition|)
block|{
name|val
operator|=
name|value_from_long
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
operator|*
name|read_vector_register_1
argument_list|(
name|VS_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"vm"
argument_list|)
condition|)
block|{
name|long
name|vm
index|[
literal|4
index|]
decl_stmt|;
name|long
name|i
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|bcopy
argument_list|(
name|read_vector_register_1
argument_list|(
name|VM_REGNUM
argument_list|)
argument_list|,
name|vm
argument_list|,
sizeof|sizeof
name|vm
argument_list|)
expr_stmt|;
name|type
operator|=
name|vector_type
argument_list|(
name|builtin_type_int
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|val
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|long
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|!
operator|!
operator|(
name|vm
index|[
literal|3
operator|-
operator|(
name|i
operator|>>
literal|5
operator|)
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|&
literal|037
operator|)
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'V'
condition|)
block|{
name|type
operator|=
name|vector_type
argument_list|(
name|builtin_type_long_long
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|val
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|read_vector_register_1
argument_list|(
name|name
index|[
literal|1
index|]
operator|-
literal|'0'
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'v'
condition|)
block|{
name|long
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|type
operator|=
name|vector_type
argument_list|(
name|builtin_type_long
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|val
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|p1
operator|=
name|read_vector_register_1
argument_list|(
name|name
index|[
literal|1
index|]
operator|-
literal|'0'
argument_list|)
expr_stmt|;
name|p2
operator|=
operator|(
name|long
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
name|p1
operator|++
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'c'
condition|)
name|val
operator|=
name|value_from_long
argument_list|(
name|builtin_type_int
argument_list|,
name|read_comm_register
argument_list|(
name|atoi
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'C'
condition|)
name|val
operator|=
name|value_from_long
argument_list|(
name|builtin_type_long_long
argument_list|,
name|read_comm_register
argument_list|(
name|atoi
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|lval_internalvar
expr_stmt|;
name|VALUE_INTERNALVAR
argument_list|(
name|val
argument_list|)
operator|=
name|var
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Construct the type for a vector register's value --    array[LENGTH] of ELEMENT_TYPE.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|vector_type
parameter_list|(
name|element_type
parameter_list|,
name|length
parameter_list|)
name|struct
name|type
modifier|*
name|element_type
decl_stmt|;
name|long
name|length
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
init|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|type
argument_list|,
sizeof|sizeof
name|type
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ARRAY
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|element_type
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|length
operator|*
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Handle a new value assigned to a trapped internal variable */
end_comment

begin_function
name|void
name|set_trapped_internalvar
parameter_list|(
name|var
parameter_list|,
name|val
parameter_list|,
name|bitpos
parameter_list|,
name|bitsize
parameter_list|,
name|offset
parameter_list|)
name|struct
name|internalvar
modifier|*
name|var
decl_stmt|;
name|value
name|val
decl_stmt|;
name|int
name|bitpos
decl_stmt|,
name|bitsize
decl_stmt|,
name|offset
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|var
operator|->
name|name
decl_stmt|;
name|long
name|long
name|newval
init|=
name|value_as_long
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"vl"
argument_list|)
condition|)
name|write_vector_register
argument_list|(
name|VL_REGNUM
argument_list|,
literal|0
argument_list|,
name|newval
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"vs"
argument_list|)
condition|)
name|write_vector_register
argument_list|(
name|VS_REGNUM
argument_list|,
literal|0
argument_list|,
name|newval
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'c'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'C'
condition|)
name|write_comm_register
argument_list|(
name|atoi
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|newval
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"vm"
argument_list|)
condition|)
name|error
argument_list|(
literal|"can't assign to $vm"
argument_list|)
expr_stmt|;
else|else
block|{
name|offset
operator|/=
name|bitsize
operator|/
literal|8
expr_stmt|;
name|write_vector_register
argument_list|(
name|name
index|[
literal|1
index|]
operator|-
literal|'0'
argument_list|,
name|offset
argument_list|,
name|newval
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print an integer value when no format was specified.  gdb normally    prints these values in decimal, but the the leading 0x80000000 of    pointers produces intolerable 10-digit negative numbers.    If it looks like an address, print it in hex instead.  */
end_comment

begin_macro
name|decout
argument_list|(
argument|stream
argument_list|,
argument|type
argument_list|,
argument|val
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|stream
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LONGEST
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|lv
init|=
name|val
decl_stmt|;
switch|switch
condition|(
name|output_radix
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|(
name|lv
operator|==
name|val
operator|||
operator|(
name|unsigned
operator|)
name|lv
operator|==
name|val
operator|)
operator|&&
operator|(
operator|(
name|lv
operator|&
literal|0xf0000000
operator|)
operator|==
literal|0x80000000
operator|||
operator|(
operator|(
name|lv
operator|&
literal|0xf0000000
operator|)
operator|==
literal|0xf0000000
operator|&&
name|lv
operator|<
name|STACK_END_ADDR
operator|)
operator|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%#x"
argument_list|,
name|lv
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|10
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|"%llu"
else|:
literal|"%lld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
case|case
literal|8
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<=
sizeof|sizeof
name|lv
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%#o"
argument_list|,
name|lv
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%#llo"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
case|case
literal|16
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<=
sizeof|sizeof
name|lv
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%#x"
argument_list|,
name|lv
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%#llx"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_comment
comment|/* Change the default output radix to 10 or 16, or set it to 0 (heuristic).    This command is mostly obsolete now that the print command allows    formats to apply to aggregates, but is still handy occasionally.  */
end_comment

begin_function
specifier|static
name|void
name|set_base_command
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|new_radix
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|output_radix
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|new_radix
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_radix
operator|!=
literal|10
operator|&&
name|new_radix
operator|!=
literal|16
operator|&&
name|new_radix
operator|!=
literal|8
condition|)
name|error
argument_list|(
literal|"base must be 8, 10 or 16, or null"
argument_list|)
expr_stmt|;
else|else
name|output_radix
operator|=
name|new_radix
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Turn pipelining on or off in the inferior. */
end_comment

begin_function
specifier|static
name|void
name|set_pipelining_command
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|arg
condition|)
block|{
name|sequential
operator|=
operator|!
name|sequential
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\n"
argument_list|,
name|sequential
condition|?
literal|"off"
else|:
literal|"on"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"on"
argument_list|)
condition|)
name|sequential
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"off"
argument_list|)
condition|)
name|sequential
operator|=
literal|1
expr_stmt|;
else|else
name|error
argument_list|(
literal|"valid args are `on', to allow instructions to overlap, or\n\ `off', to prevent it and thereby pinpoint exceptions."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enable, disable, or force parallel execution in the inferior.  */
end_comment

begin_function
specifier|static
name|void
name|set_parallel_command
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|rlimit
name|rl
decl_stmt|;
name|int
name|prevparallel
init|=
name|parallel
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"fixed"
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|parallel
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"on"
argument_list|)
condition|)
name|parallel
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"off"
argument_list|)
condition|)
name|parallel
operator|=
literal|0
expr_stmt|;
else|else
name|error
argument_list|(
literal|"valid args are `on', to allow multiple threads, or\n\ `fixed', to force multiple threads, or\n\ `off', to run with one thread only."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prevparallel
operator|==
literal|0
operator|)
operator|!=
operator|(
name|parallel
operator|==
literal|0
operator|)
operator|&&
name|inferior_pid
condition|)
name|printf_filtered
argument_list|(
literal|"will take effect at next run.\n"
argument_list|)
expr_stmt|;
name|getrlimit
argument_list|(
name|RLIMIT_CONCUR
argument_list|,
operator|&
name|rl
argument_list|)
expr_stmt|;
name|rl
operator|.
name|rlim_cur
operator|=
name|parallel
condition|?
name|rl
operator|.
name|rlim_max
else|:
literal|1
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_CONCUR
argument_list|,
operator|&
name|rl
argument_list|)
expr_stmt|;
if|if
condition|(
name|inferior_pid
condition|)
name|set_fixed_scheduling
argument_list|(
name|inferior_pid
argument_list|,
name|parallel
operator|==
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a new name for an existing command.  */
end_comment

begin_function
specifier|static
name|void
name|alias_command
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|aliaserr
init|=
literal|"usage is `alias NEW OLD', no args allowed"
decl_stmt|;
name|char
modifier|*
name|newname
init|=
name|arg
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|new
decl_stmt|,
modifier|*
name|old
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"newname oldname"
argument_list|)
expr_stmt|;
name|new
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|arg
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&&
operator|!
name|strncmp
argument_list|(
name|newname
argument_list|,
name|new
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|new
operator|->
name|name
argument_list|)
argument_list|)
condition|)
block|{
name|newname
operator|=
name|new
operator|->
name|name
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|arg
operator|==
literal|'-'
operator|||
operator|(
operator|*
name|arg
operator|>=
literal|'a'
operator|&&
operator|*
name|arg
operator|<=
literal|'z'
operator|)
operator|||
operator|(
operator|*
name|arg
operator|>=
literal|'A'
operator|&&
operator|*
name|arg
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
operator|*
name|arg
operator|>=
literal|'0'
operator|&&
operator|*
name|arg
operator|<=
literal|'9'
operator|)
operator|)
condition|)
name|error
argument_list|(
name|aliaserr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|=
name|newname
expr_stmt|;
while|while
condition|(
operator|*
name|arg
operator|==
literal|'-'
operator|||
operator|(
operator|*
name|arg
operator|>=
literal|'a'
operator|&&
operator|*
name|arg
operator|<=
literal|'z'
operator|)
operator|||
operator|(
operator|*
name|arg
operator|>=
literal|'A'
operator|&&
operator|*
name|arg
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
operator|*
name|arg
operator|>=
literal|'0'
operator|&&
operator|*
name|arg
operator|<=
literal|'9'
operator|)
condition|)
name|arg
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|!=
literal|' '
operator|&&
operator|*
name|arg
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
name|aliaserr
argument_list|)
expr_stmt|;
operator|*
name|arg
operator|=
literal|'\0'
expr_stmt|;
name|arg
operator|++
expr_stmt|;
block|}
name|old
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|arg
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|!=
literal|'\0'
condition|)
name|error
argument_list|(
name|aliaserr
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|&&
operator|!
name|strncmp
argument_list|(
name|newname
argument_list|,
name|new
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|new
operator|->
name|name
argument_list|)
argument_list|)
condition|)
block|{
name|char
modifier|*
name|tem
decl_stmt|;
if|if
condition|(
name|new
operator|->
name|class
operator|==
operator|(
name|int
operator|)
name|class_user
operator|||
name|new
operator|->
name|class
operator|==
operator|(
name|int
operator|)
name|class_alias
condition|)
name|tem
operator|=
literal|"Redefine command \"%s\"? "
expr_stmt|;
else|else
name|tem
operator|=
literal|"Really redefine built-in command \"%s\"? "
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
name|tem
argument_list|,
name|new
operator|->
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Command \"%s\" not redefined."
argument_list|,
name|new
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|add_com
argument_list|(
name|newname
argument_list|,
name|class_alias
argument_list|,
name|old
operator|->
name|function
argument_list|,
name|old
operator|->
name|doc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the current thread number, and any threads with signals in the    queue.  */
end_comment

begin_macro
name|thread_info
argument_list|()
end_macro

begin_block
block|{
name|struct
name|threadpid
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
block|{
name|ps
operator|.
name|pi_buffer
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|comm_registers
expr_stmt|;
name|ps
operator|.
name|pi_nbytes
operator|=
sizeof|sizeof
name|comm_registers
expr_stmt|;
name|ps
operator|.
name|pi_offset
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pi_thread
operator|=
name|inferior_thread
expr_stmt|;
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXRDCREGS
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"Current thread %d stopped with signal %d.%d (%s).\n"
argument_list|,
name|inferior_thread
argument_list|,
name|stop_signal
argument_list|,
name|stop_sigcode
argument_list|,
name|subsig_name
argument_list|(
name|stop_signal
argument_list|,
name|stop_sigcode
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|signal_stack
init|;
name|p
operator|->
name|pid
condition|;
name|p
operator|--
control|)
name|printf_filtered
argument_list|(
literal|"Thread %d stopped with signal %d.%d (%s).\n"
argument_list|,
name|p
operator|->
name|thread
argument_list|,
name|p
operator|->
name|signo
argument_list|,
name|p
operator|->
name|subsig
argument_list|,
name|subsig_name
argument_list|(
name|p
operator|->
name|signo
argument_list|,
name|p
operator|->
name|subsig
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iscrlbit
argument_list|(
name|comm_registers
operator|.
name|crctl
operator|.
name|lbits
operator|.
name|cc
argument_list|,
literal|64
operator|+
literal|13
argument_list|)
condition|)
name|printf_filtered
argument_list|(
literal|"New thread start pc %#x\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|comm_registers
operator|.
name|crreg
operator|.
name|pcpsw
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return string describing a signal.subcode number */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|subsig_name
parameter_list|(
name|signo
parameter_list|,
name|subcode
parameter_list|)
name|int
name|signo
decl_stmt|,
name|subcode
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|subsig4
index|[]
init|=
block|{
literal|"error exit"
block|,
literal|"privileged instruction"
block|,
literal|"unknown"
block|,
literal|"unknown"
block|,
literal|"undefined opcode"
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|subsig5
index|[]
init|=
block|{
literal|0
block|,
literal|"breakpoint"
block|,
literal|"single step"
block|,
literal|"fork trap"
block|,
literal|"exec trap"
block|,
literal|"pfork trap"
block|,
literal|"join trap"
block|,
literal|"idle trap"
block|,
literal|"last thread"
block|,
literal|"wfork trap"
block|,
literal|"process breakpoint"
block|,
literal|"trap instruction"
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|subsig8
index|[]
init|=
block|{
literal|0
block|,
literal|"int overflow"
block|,
literal|"int divide check"
block|,
literal|"float overflow"
block|,
literal|"float divide check"
block|,
literal|"float underflow"
block|,
literal|"reserved operand"
block|,
literal|"sqrt error"
block|,
literal|"exp error"
block|,
literal|"ln error"
block|,
literal|"sin error"
block|,
literal|"cos error"
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|subsig10
index|[]
init|=
block|{
literal|0
block|,
literal|"invalid inward ring address"
block|,
literal|"invalid outward ring call"
block|,
literal|"invalid inward ring return"
block|,
literal|"invalid syscall gate"
block|,
literal|"invalid rtn frame length"
block|,
literal|"invalid comm reg address"
block|,
literal|"invalid trap gate"
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|subsig11
index|[]
init|=
block|{
literal|0
block|,
literal|"read access denied"
block|,
literal|"write access denied"
block|,
literal|"execute access denied"
block|,
literal|"segment descriptor fault"
block|,
literal|"page table fault"
block|,
literal|"data reference fault"
block|,
literal|"i/o access denied"
block|,
literal|"levt pte invalid"
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
modifier|*
name|subsig_list
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|subsig4
block|,
name|subsig5
block|,
literal|0
block|,
literal|0
block|,
name|subsig8
block|,
literal|0
block|,
name|subsig10
block|,
name|subsig11
block|,
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|signo
operator|<
name|NSIG
condition|?
name|sys_siglist
index|[
name|signo
index|]
else|:
literal|"unknown"
decl_stmt|;
if|if
condition|(
name|signo
operator|>=
operator|(
sizeof|sizeof
name|subsig_list
operator|/
sizeof|sizeof
expr|*
name|subsig_list
operator|)
operator|||
operator|!
name|subsig_list
index|[
name|signo
index|]
condition|)
return|return
name|p
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|subsig_list
index|[
name|signo
index|]
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|subcode
condition|)
return|return
name|subsig_list
index|[
name|signo
index|]
index|[
name|subcode
index|]
return|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Print a compact display of thread status, essentially x/i $pc    for all active threads.  */
end_comment

begin_function
specifier|static
name|void
name|threadstat
parameter_list|()
block|{
name|int
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|n_threads
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|thread_state
index|[
name|t
index|]
operator|==
name|PI_TALIVE
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%d%c %08x%c %d.%d "
argument_list|,
name|t
argument_list|,
operator|(
name|t
operator|==
name|inferior_thread
condition|?
literal|'*'
else|:
literal|' '
operator|)
argument_list|,
name|thread_pc
index|[
name|t
index|]
argument_list|,
operator|(
name|thread_is_in_kernel
index|[
name|t
index|]
condition|?
literal|'#'
else|:
literal|' '
operator|)
argument_list|,
name|thread_signal
index|[
name|t
index|]
argument_list|,
name|thread_sigcode
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|print_insn
argument_list|(
name|thread_pc
index|[
name|t
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Change the current thread to ARG.  */
end_comment

begin_macro
name|set_thread_command
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|thread
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
block|{
name|threadstat
argument_list|()
expr_stmt|;
return|return;
block|}
name|thread
operator|=
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|<
literal|0
operator|||
name|thread
operator|>
name|n_threads
operator|||
name|thread_state
index|[
name|thread
index|]
operator|!=
name|PI_TALIVE
condition|)
name|error
argument_list|(
literal|"no such thread."
argument_list|)
expr_stmt|;
name|select_thread
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|stop_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_sel_frame
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Here on CONT command; gdb's dispatch address is changed to come here.    Set global variable ALL_CONTINUE to tell resume() that it should    start up all threads, and that a thread switch will not blow gdb's    mind.  */
end_comment

begin_function
specifier|static
name|void
name|convex_cont_command
parameter_list|(
name|proc_count_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|proc_count_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|all_continue
operator|=
literal|1
expr_stmt|;
name|cont_command
argument_list|(
name|proc_count_exp
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Here on 1CONT command.  Resume only the current thread.  */
end_comment

begin_macro
name|one_cont_command
argument_list|(
argument|proc_count_exp
argument_list|,
argument|from_tty
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|proc_count_exp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|from_tty
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cont_command
argument_list|(
name|proc_count_exp
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print the contents and lock bits of all communication registers,    or just register ARG if ARG is a communication register,    or the 3-word resource structure in memory at address ARG.  */
end_comment

begin_macro
name|comm_registers_info
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|regnum
decl_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|arg
argument_list|,
literal|"0x%x"
argument_list|,
operator|&
name|regnum
argument_list|)
operator|==
literal|1
operator|||
name|sscanf
argument_list|(
name|argc
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|regnum
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|regnum
operator|>
literal|0
condition|)
name|regnum
operator|&=
operator|~
literal|0x8000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|arg
argument_list|,
literal|"$c%d"
argument_list|,
operator|&
name|regnum
argument_list|)
operator|==
literal|1
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|arg
argument_list|,
literal|"$C%d"
argument_list|,
operator|&
name|regnum
argument_list|)
operator|==
literal|1
condition|)
empty_stmt|;
else|else
name|regnum
operator|=
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|>=
literal|64
condition|)
name|error
argument_list|(
literal|"%s: invalid register name."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* if we got a (user) address, examine the resource struct there */
if|if
condition|(
name|regnum
operator|<
literal|0
condition|)
block|{
specifier|static
name|int
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|read_memory
argument_list|(
name|regnum
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%08x  %08x%08x%s\n"
argument_list|,
name|regnum
argument_list|,
name|buf
index|[
literal|1
index|]
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|0
index|]
operator|&
literal|0xff
condition|?
literal|" locked"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ps
operator|.
name|pi_buffer
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|comm_registers
expr_stmt|;
name|ps
operator|.
name|pi_nbytes
operator|=
sizeof|sizeof
name|comm_registers
expr_stmt|;
name|ps
operator|.
name|pi_offset
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pi_thread
operator|=
name|inferior_thread
expr_stmt|;
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXRDCREGS
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|arg
operator|||
name|i
operator|==
name|regnum
condition|)
name|printf_filtered
argument_list|(
literal|"%2d 0x8%03x %016llx%s\n"
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
name|comm_registers
operator|.
name|crreg
operator|.
name|r4
index|[
name|i
index|]
argument_list|,
operator|(
name|iscrlbit
argument_list|(
name|comm_registers
operator|.
name|crctl
operator|.
name|lbits
operator|.
name|cc
argument_list|,
name|i
argument_list|)
condition|?
literal|" locked"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print the psw */
end_comment

begin_function
specifier|static
name|void
name|psw_info
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
struct|struct
name|pswbit
block|{
name|int
name|bit
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|pswbit
name|pswbit
index|[]
init|=
block|{
block|{
literal|0x80000000
block|,
operator|-
literal|1
block|,
literal|"A carry"
block|}
block|,
block|{
literal|0x40000000
block|,
operator|-
literal|1
block|,
literal|"A integer overflow"
block|}
block|,
block|{
literal|0x20000000
block|,
operator|-
literal|1
block|,
literal|"A zero divide"
block|}
block|,
block|{
literal|0x10000000
block|,
operator|-
literal|1
block|,
literal|"Integer overflow enable"
block|}
block|,
block|{
literal|0x08000000
block|,
operator|-
literal|1
block|,
literal|"Trace"
block|}
block|,
block|{
literal|0x06000000
block|,
literal|25
block|,
literal|"Frame length"
block|}
block|,
block|{
literal|0x01000000
block|,
operator|-
literal|1
block|,
literal|"Sequential"
block|}
block|,
block|{
literal|0x00800000
block|,
operator|-
literal|1
block|,
literal|"S carry"
block|}
block|,
block|{
literal|0x00400000
block|,
operator|-
literal|1
block|,
literal|"S integer overflow"
block|}
block|,
block|{
literal|0x00200000
block|,
operator|-
literal|1
block|,
literal|"S zero divide"
block|}
block|,
block|{
literal|0x00100000
block|,
operator|-
literal|1
block|,
literal|"Zero divide enable"
block|}
block|,
block|{
literal|0x00080000
block|,
operator|-
literal|1
block|,
literal|"Floating underflow"
block|}
block|,
block|{
literal|0x00040000
block|,
operator|-
literal|1
block|,
literal|"Floating overflow"
block|}
block|,
block|{
literal|0x00020000
block|,
operator|-
literal|1
block|,
literal|"Floating reserved operand"
block|}
block|,
block|{
literal|0x00010000
block|,
operator|-
literal|1
block|,
literal|"Floating zero divide"
block|}
block|,
block|{
literal|0x00008000
block|,
operator|-
literal|1
block|,
literal|"Floating error enable"
block|}
block|,
block|{
literal|0x00004000
block|,
operator|-
literal|1
block|,
literal|"Floating underflow enable"
block|}
block|,
block|{
literal|0x00002000
block|,
operator|-
literal|1
block|,
literal|"IEEE"
block|}
block|,
block|{
literal|0x00001000
block|,
operator|-
literal|1
block|,
literal|"Sequential stores"
block|}
block|,
block|{
literal|0x00000800
block|,
operator|-
literal|1
block|,
literal|"Intrinsic error"
block|}
block|,
block|{
literal|0x00000400
block|,
operator|-
literal|1
block|,
literal|"Intrinsic error enable"
block|}
block|,
block|{
literal|0x00000200
block|,
operator|-
literal|1
block|,
literal|"Trace thread creates"
block|}
block|,
block|{
literal|0x00000100
block|,
operator|-
literal|1
block|,
literal|"Thread init trap"
block|}
block|,
block|{
literal|0x000000e0
block|,
literal|5
block|,
literal|"Reserved"
block|}
block|,
block|{
literal|0x0000001f
block|,
literal|0
block|,
literal|"Intrinsic error code"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,     }
decl_stmt|;
name|long
name|psw
decl_stmt|;
name|struct
name|pswbit
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|arg
condition|)
name|psw
operator|=
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
name|psw
operator|=
name|read_register
argument_list|(
name|PS_REGNUM
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pswbit
init|;
name|p
operator|->
name|bit
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|pos
operator|<
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"%08x  %s  %s\n"
argument_list|,
name|p
operator|->
name|bit
argument_list|,
operator|(
name|psw
operator|&
name|p
operator|->
name|bit
operator|)
condition|?
literal|"yes"
else|:
literal|"no "
argument_list|,
name|p
operator|->
name|text
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"%08x %3d   %s\n"
argument_list|,
name|p
operator|->
name|bit
argument_list|,
operator|(
name|psw
operator|&
name|p
operator|->
name|bit
operator|)
operator|>>
name|p
operator|->
name|pos
argument_list|,
name|p
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_macro
name|_initialize_convex_dep
argument_list|()
end_macro

begin_block
block|{
name|add_com
argument_list|(
literal|"alias"
argument_list|,
name|class_support
argument_list|,
name|alias_command
argument_list|,
literal|"Add a new name for an existing command."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"base"
argument_list|,
name|class_vars
argument_list|,
name|set_base_command
argument_list|,
literal|"Change the integer output radix to 8, 10 or 16\n\ or use just `set base' with no args to return to the ad-hoc default,\n\ which is 16 for integers that look like addresses, 10 otherwise."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"pipeline"
argument_list|,
name|class_run
argument_list|,
name|set_pipelining_command
argument_list|,
literal|"Enable or disable overlapped execution of instructions.\n\ With `set pipe off', exceptions are reported with\n\ $pc pointing at the instruction after the faulting one.\n\ The default is `set pipe on', which runs faster."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"parallel"
argument_list|,
name|class_run
argument_list|,
name|set_parallel_command
argument_list|,
literal|"Enable or disable multi-threaded execution of parallel code.\n\ `set parallel off' means run the program on a single CPU.\n\ `set parallel fixed' means run the program with all CPUs assigned to it.\n\ `set parallel on' means run the program on any CPUs that are available."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"1cont"
argument_list|,
name|class_run
argument_list|,
name|one_cont_command
argument_list|,
literal|"Continue the program, activating only the current thread.\n\ Args are the same as the `cont' command."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"thread"
argument_list|,
name|class_run
argument_list|,
name|set_thread_command
argument_list|,
literal|"Change the current thread, the one under scrutiny and control.\n\ With no arg, show the active threads, the current one marked with *."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"threads"
argument_list|,
name|thread_info
argument_list|,
literal|"List status of active threads."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"comm-registers"
argument_list|,
name|comm_registers_info
argument_list|,
literal|"List communication registers and their contents.\n\ A communication register name as argument means describe only that register.\n\ An address as argument means describe the resource structure at that address.\n\ `Locked' means that the register has been sent to but not yet received from."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"psw"
argument_list|,
name|psw_info
argument_list|,
literal|"Display $ps, the processor status word, bit by bit.\n\ An argument means display that value's interpretation as a psw."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"convex"
argument_list|,
name|no_class
argument_list|,
literal|0
argument_list|,
literal|"Convex-specific commands.\n\ 32-bit registers  $pc $ps $sp $ap $fp $a1-5 $s0-7 $v0-7 $vl $vs $vm $c0-63\n\ 64-bit registers  $S0-7 $V0-7 $C0-63\n\ \n\ info threads	    display info on stopped threads waiting to signal\n\ thread		    display list of active threads\n\ thread N	    select thread N (its registers, stack, memory, etc.)\n\ step, next, etc     step selected thread only\n\ 1cont		    continue selected thread only\n\ cont		    continue all threads\n\ info comm-registers display contents of comm register(s) or a resource struct\n\ info psw	    display processor status word $ps\n\ set base N	    change integer radix used by `print' without a format\n\ set pipeline off    exceptions are precise, $pc points after the faulting insn\n\ set pipeline on     normal mode, $pc is somewhere ahead of faulting insn\n\ set parallel off    program runs on a single CPU\n\ set parallel fixed  all CPUs are assigned to the program\n\ set parallel on     normal mode, parallel execution on random available CPUs\n\ "
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

