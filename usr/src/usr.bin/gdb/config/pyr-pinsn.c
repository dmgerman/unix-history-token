begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Disassembler for the Pyramid Technology 90x    Copyright (C) 1988,1989 Free Software Foundation, Inc.  This file is part of GDB, the GNU disassembler.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"opcode.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*  A couple of functions used for debugging frame-handling on     Pyramids. (The Pyramid-dependent handling of register values for     windowed registers is known to be buggy.)      When debugging, these functions supplant the normal definitions of some     of the macros in m-pyramid.h  The quantity of information produced     when these functions are used makes the gdb  unusable as a     debugger for user programs.  */
end_comment

begin_decl_stmt
specifier|extern
name|unsigned
name|pyr_saved_pc
argument_list|()
decl_stmt|,
name|pyr_frame_chain
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|CORE_ADDR
name|pyr_frame_chain
parameter_list|(
name|frame
parameter_list|)
name|CORE_ADDR
name|frame
decl_stmt|;
block|{
name|int
name|foo
init|=
name|frame
operator|-
name|CONTROL_STACK_FRAME_SIZE
decl_stmt|;
comment|/* printf ("...following chain from %x: got %x\n", frame, foo);*/
return|return
name|foo
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|pyr_saved_pc
parameter_list|(
name|frame
parameter_list|)
name|CORE_ADDR
name|frame
decl_stmt|;
block|{
name|int
name|foo
init|=
literal|0
decl_stmt|;
name|foo
operator|=
name|read_memory_integer
argument_list|(
operator|(
call|(
name|CORE_ADDR
call|)
argument_list|(
name|frame
argument_list|)
operator|)
operator|+
literal|60
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"..reading pc from frame 0x%0x+%d regs: got %0x\n"
argument_list|,
name|frame
argument_list|,
literal|60
operator|/
literal|4
argument_list|,
name|foo
argument_list|)
expr_stmt|;
return|return
name|foo
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pyramid instructions are never longer than this many bytes.  */
end_comment

begin_define
define|#
directive|define
name|MAXLEN
value|24
end_define

begin_comment
comment|/* Number of elements in the opcode table.  */
end_comment

begin_comment
comment|/*const*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|nopcodes
init|=
operator|(
sizeof|sizeof
argument_list|(
name|pyr_opcodes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pyr_opcodes
index|[
literal|0
index|]
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NOPCODES
value|(nopcodes)
end_define

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|reg_names
index|[]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Let's be byte-independent so we can use this as a cross-assembler.    (will this ever be useful?  */
end_comment

begin_define
define|#
directive|define
name|NEXTLONG
parameter_list|(
name|p
parameter_list|)
define|\
value|(p += 4, (((((p[-4]<< 8) + p[-3])<< 8) + p[-2])<< 8) + p[-1])
end_define

begin_escape
end_escape

begin_comment
comment|/* Print one instruction at address MEMADDR in debugged memory,    on STREAM.  Returns length of the instruction, in bytes.  */
end_comment

begin_function
name|int
name|print_insn
parameter_list|(
name|memaddr
parameter_list|,
name|stream
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|unsigned
name|char
name|buffer
index|[
name|MAXLEN
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|nargs
decl_stmt|,
name|insn_size
init|=
literal|4
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|insn_opcode
decl_stmt|,
name|operand_mode
decl_stmt|;
specifier|register
name|int
name|index_multiplier
decl_stmt|,
name|index_reg_regno
decl_stmt|,
name|op_1_regno
decl_stmt|,
name|op_2_regno
decl_stmt|;
name|long
name|insn
decl_stmt|;
comment|/* first word of the insn, not broken down. */
name|pyr_insn_format
name|insn_decode
decl_stmt|;
comment|/* the same, broken out into op{code,erands} */
name|long
name|extra_1
decl_stmt|,
name|extra_2
decl_stmt|;
name|read_memory
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_decode
operator|=
operator|*
operator|(
operator|(
name|pyr_insn_format
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|insn
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|insn_opcode
operator|=
name|insn_decode
operator|.
name|operator
expr_stmt|;
name|operand_mode
operator|=
name|insn_decode
operator|.
name|mode
expr_stmt|;
name|index_multiplier
operator|=
name|insn_decode
operator|.
name|index_scale
expr_stmt|;
name|index_reg_regno
operator|=
name|insn_decode
operator|.
name|index_reg
expr_stmt|;
name|op_1_regno
operator|=
name|insn_decode
operator|.
name|operand_1
expr_stmt|;
name|op_2_regno
operator|=
name|insn_decode
operator|.
name|operand_2
expr_stmt|;
if|if
condition|(
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
operator|==
literal|0x0
condition|)
block|{
comment|/* "halt" looks just like an invalid "jump" to the insn decoder,        so is dealt with as a special case */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"halt"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|4
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOPCODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pyr_opcodes
index|[
name|i
index|]
operator|.
name|datum
operator|.
name|code
operator|==
name|insn_opcode
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|NOPCODES
condition|)
comment|/* FIXME: Handle unrecognised instructions better.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"???\t#%08x\t(op=%x mode =%x)"
argument_list|,
name|insn
argument_list|,
name|insn_decode
operator|.
name|operator
argument_list|,
name|insn_decode
operator|.
name|mode
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Print the mnemonic for the instruction.  Pyramid insn operands          are so regular that we can deal with almost all of them          separately. 	 Unconditional branches are an exception: they are encoded as 	 conditional branches (branch if false condition, I think) 	 with no condition specified. The average user will not be 	 aware of this. To maintain their illusion that an 	 unconditional branch insn exists, we will have to FIXME to 	 treat the insn mnemnonic of all branch instructions here as a 	 special case: check the operands of branch insn and print an 	 appropriate mnemonic. */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s\t"
argument_list|,
name|pyr_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* Print the operands of the insn (as specified in        insn.operand_mode).         Branch operands of branches are a special case: they are a word        offset, not a byte offset. */
if|if
condition|(
name|insn_decode
operator|.
name|operator
operator|==
literal|0x01
operator|||
name|insn_decode
operator|.
name|operator
operator|==
literal|0x02
condition|)
block|{
specifier|register
name|int
name|bit_codes
init|=
operator|(
name|insn
operator|>>
literal|16
operator|)
operator|&
literal|0xf
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|displacement
init|=
operator|(
name|insn
operator|&
literal|0x0000ffff
operator|)
operator|<<
literal|2
decl_stmt|;
specifier|static
name|char
name|cc_bit_names
index|[]
init|=
literal|"cvzn"
decl_stmt|;
comment|/* z,n,c,v: strange order? */
comment|/* Is bfc and no bits specified an unconditional branch?*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bit_codes
operator|)
operator|&
literal|0x1
condition|)
name|fputc
argument_list|(
name|cc_bit_names
index|[
name|i
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|bit_codes
operator|>>=
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|",%0x"
argument_list|,
name|displacement
operator|+
name|memaddr
argument_list|)
expr_stmt|;
return|return
operator|(
name|insn_size
operator|)
return|;
block|}
switch|switch
condition|(
name|operand_mode
condition|)
block|{
case|case
literal|0
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s,%s"
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" 0x%0x,%s"
argument_list|,
name|op_1_regno
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_1
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" $0x%0x,%s"
argument_list|,
name|extra_1
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" (%s),%s"
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_1
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" 0x%0x(%s),%s"
argument_list|,
name|extra_1
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|)
expr_stmt|;
break|break;
comment|/* S1 destination mode */
case|case
literal|5
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|"%s,(%s)[%s*%1d]"
else|:
literal|"%s,(%s)"
operator|)
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|" $%#0x,(%s)[%s*%1d]"
else|:
literal|" $%#0x,(%s)"
operator|)
argument_list|,
name|op_1_regno
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_1
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|" $%#0x,(%s)[%s*%1d]"
else|:
literal|" $%#0x,(%s)"
operator|)
argument_list|,
name|extra_1
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|" (%s),(%s)[%s*%1d]"
else|:
literal|" (%s),(%s)"
operator|)
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_1
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|"%#0x(%s),(%s)[%s*%1d]"
else|:
literal|"%#0x(%s),(%s)"
operator|)
argument_list|,
name|extra_1
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
comment|/* S2 destination mode */
case|case
literal|10
case|:
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_1
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|"%s,%#0x(%s)[%s*%1d]"
else|:
literal|"%s,%#0x(%s)"
operator|)
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|extra_1
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_1
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|" $%#0x,%#0x(%s)[%s*%1d]"
else|:
literal|" $%#0x,%#0x(%s)"
operator|)
argument_list|,
name|op_1_regno
argument_list|,
name|extra_1
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_1
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|8
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_2
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|" $%#0x,%#0x(%s)[%s*%1d]"
else|:
literal|" $%#0x,%#0x(%s)"
operator|)
argument_list|,
name|extra_1
argument_list|,
name|extra_2
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_1
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|" (%s),%#0x(%s)[%s*%1d]"
else|:
literal|" (%s),%#0x(%s)"
operator|)
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|extra_1
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_1
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|read_memory
argument_list|(
name|memaddr
operator|+
literal|8
argument_list|,
name|buffer
argument_list|,
name|MAXLEN
argument_list|)
expr_stmt|;
name|insn_size
operator|+=
literal|4
expr_stmt|;
name|extra_2
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|buffer
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|"%#0x(%s),%#0x(%s)[%s*%1d]"
else|:
literal|"%#0x(%s),%#0x(%s) "
operator|)
argument_list|,
name|extra_1
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|extra_2
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stream
argument_list|,
operator|(
operator|(
name|index_reg_regno
operator|)
condition|?
literal|"%s,%s [%s*%1d]"
else|:
literal|"%s,%s"
operator|)
argument_list|,
name|reg_names
index|[
name|op_1_regno
index|]
argument_list|,
name|reg_names
index|[
name|op_2_regno
index|]
argument_list|,
name|reg_names
index|[
name|index_reg_regno
index|]
argument_list|,
name|index_multiplier
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t\t# unknown mode in %08x"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
block|{
return|return
name|insn_size
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

