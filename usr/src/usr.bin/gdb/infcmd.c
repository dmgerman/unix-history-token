begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  * Modified 1990 by Van Jacobson at Lawrence Berkeley Laboratory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)infcmd.c	6.4 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Memory-access and commands for inferior process, for GDB.    Copyright (C) 1986, 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"environ.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_siglist
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ERROR_NO_INFERIOR
define|\
value|if (inferior_pid == 0) error ("The program is not being run.");
end_define

begin_comment
comment|/* String containing arguments to give to the program,    with a space added at the front.  Just a space means no args.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|inferior_args
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File name for default use for standard in/out in the inferior.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|inferior_io_terminal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pid of our debugged inferior, or 0 if no inferior now.  */
end_comment

begin_decl_stmt
name|int
name|inferior_pid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last signal that the inferior received (why it stopped).  */
end_comment

begin_decl_stmt
name|int
name|stop_signal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address at which inferior stopped.  */
end_comment

begin_decl_stmt
name|CORE_ADDR
name|stop_pc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack frame when program stopped.  */
end_comment

begin_decl_stmt
name|FRAME_ADDR
name|stop_frame_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of breakpoint it stopped at, or 0 if none.  */
end_comment

begin_decl_stmt
name|int
name|stop_breakpoint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if stopped due to a step command.  */
end_comment

begin_decl_stmt
name|int
name|stop_step
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if stopped due to completion of a stack dummy routine.  */
end_comment

begin_decl_stmt
name|int
name|stop_stack_dummy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if stopped due to a random (unexpected) signal in inferior    process.  */
end_comment

begin_decl_stmt
name|int
name|stopped_by_random_signal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Range to single step within.    If this is nonzero, respond to a single-step signal    by continuing to step if the pc is in this range.  */
end_comment

begin_decl_stmt
name|CORE_ADDR
name|step_range_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Inclusive */
end_comment

begin_decl_stmt
name|CORE_ADDR
name|step_range_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exclusive */
end_comment

begin_comment
comment|/* Stack frame address as of when stepping command was issued.    This is how we know when we step into a subroutine call,    and how to set the frame for the breakpoint used to step out.  */
end_comment

begin_decl_stmt
name|FRAME_ADDR
name|step_frame_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 means step over all subroutine calls.    -1 means step over calls to undebuggable functions.  */
end_comment

begin_decl_stmt
name|int
name|step_over_calls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If stepping, nonzero means step count is> 1    so don't print frame next time inferior stops    if it stops due to stepping.  */
end_comment

begin_decl_stmt
name|int
name|step_multi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Environment to use for running inferior,    in format described in environ.h.  */
end_comment

begin_decl_stmt
name|struct
name|environ
modifier|*
name|inferior_environ
decl_stmt|;
end_decl_stmt

begin_function_decl
name|CORE_ADDR
name|read_pc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|command_line
modifier|*
name|get_breakpoint_commands
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|breakpoint_clear_ignore_counts
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_function
name|int
name|have_inferior_p
parameter_list|()
block|{
return|return
name|inferior_pid
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_args_command
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|free
argument_list|(
name|inferior_args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|args
operator|=
literal|""
expr_stmt|;
name|inferior_args
operator|=
name|concat
argument_list|(
literal|" "
argument_list|,
name|args
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tty_command
parameter_list|(
name|file
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|file
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"terminal name for running target process"
argument_list|)
expr_stmt|;
name|inferior_io_terminal
operator|=
name|savestring
argument_list|(
name|file
argument_list|,
name|strlen
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|run_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|allargs
decl_stmt|;
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|inferior_pid
condition|)
block|{
specifier|extern
name|int
name|inhibit_confirm
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|inhibit_confirm
operator|||
name|query
argument_list|(
literal|"The program being debugged has been started already.\n\ Start it from the beginning? "
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"Program not restarted."
argument_list|)
expr_stmt|;
name|kill_inferior
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* On the other hand, some users want to do 	 break open 	 ignore 1 40 	 run      So it's not clear what is best.  */
comment|/* It is confusing to the user for ignore counts to stick around      from previous runs of the inferior.  So clear them.  */
block|breakpoint_clear_ignore_counts ();
endif|#
directive|endif
name|exec_file
operator|=
operator|(
name|char
operator|*
operator|)
name|get_exec_file
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"Starting program: %s\n"
argument_list|,
name|exec_file
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|args
condition|)
name|set_args_command
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"Starting program: %s%s\n"
argument_list|,
name|exec_file
argument_list|,
name|inferior_args
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|allargs
operator|=
name|concat
argument_list|(
literal|"exec "
argument_list|,
name|exec_file
argument_list|,
name|inferior_args
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
name|create_inferior
argument_list|(
name|allargs
argument_list|,
name|environ_vector
argument_list|(
name|inferior_environ
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|start_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|cont_command
parameter_list|(
name|proc_count_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|proc_count_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|ERROR_NO_INFERIOR
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* If have argument, set proceed count of breakpoint we stopped at.  */
if|if
condition|(
name|stop_breakpoint
operator|>
literal|0
operator|&&
name|proc_count_exp
condition|)
block|{
name|set_ignore_count
argument_list|(
name|stop_breakpoint
argument_list|,
name|parse_and_eval_address
argument_list|(
name|proc_count_exp
argument_list|)
operator|-
literal|1
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Continuing.\n"
argument_list|)
expr_stmt|;
name|proceed
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Step until outside of current statement.  */
end_comment

begin_function_decl
specifier|static
name|void
name|step_1
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|step_command
parameter_list|(
name|count_string
parameter_list|)
block|{
name|step_1
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|count_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Likewise, but skip over subroutine calls as if single instructions.  */
end_comment

begin_function
specifier|static
name|void
name|next_command
parameter_list|(
name|count_string
parameter_list|)
block|{
name|step_1
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|count_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Likewise, but step only one instruction.  */
end_comment

begin_function
specifier|static
name|void
name|stepi_command
parameter_list|(
name|count_string
parameter_list|)
block|{
name|step_1
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|count_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nexti_command
parameter_list|(
name|count_string
parameter_list|)
block|{
name|step_1
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
name|count_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|step_1
parameter_list|(
name|skip_subroutines
parameter_list|,
name|single_inst
parameter_list|,
name|count_string
parameter_list|)
name|int
name|skip_subroutines
decl_stmt|;
name|int
name|single_inst
decl_stmt|;
name|char
modifier|*
name|count_string
decl_stmt|;
block|{
specifier|register
name|int
name|count
init|=
literal|1
decl_stmt|;
name|ERROR_NO_INFERIOR
expr_stmt|;
name|count
operator|=
name|count_string
condition|?
name|parse_and_eval_address
argument_list|(
name|count_string
argument_list|)
else|:
literal|1
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|step_frame_address
operator|=
name|FRAME_FP
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|single_inst
condition|)
block|{
name|find_pc_line_pc_range
argument_list|(
name|stop_pc
argument_list|,
operator|&
name|step_range_start
argument_list|,
operator|&
name|step_range_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|step_range_end
operator|==
literal|0
condition|)
block|{
name|int
name|misc
decl_stmt|;
name|misc
operator|=
name|find_pc_misc_function
argument_list|(
name|stop_pc
argument_list|)
expr_stmt|;
name|terminal_ours
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Current function has no line number information.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* No info or after _etext ("Can't happen") */
if|if
condition|(
name|misc
operator|==
operator|-
literal|1
operator|||
name|misc
operator|==
name|misc_function_count
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"No data available on pc function."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Single stepping until function exit.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|step_range_start
operator|=
name|misc_function_vector
index|[
name|misc
index|]
operator|.
name|address
expr_stmt|;
name|step_range_end
operator|=
name|misc_function_vector
index|[
name|misc
operator|+
literal|1
index|]
operator|.
name|address
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Say we are stepping, but stop after one insn whatever it does. 	     Don't step through subroutine calls even to undebuggable 	     functions.  */
name|step_range_start
operator|=
name|step_range_end
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|skip_subroutines
condition|)
name|step_over_calls
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|skip_subroutines
condition|)
name|step_over_calls
operator|=
literal|1
expr_stmt|;
name|step_multi
operator|=
operator|(
name|count
operator|>
literal|1
operator|)
expr_stmt|;
name|proceed
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stop_step
condition|)
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Continue program at specified address.  */
end_comment

begin_function
specifier|static
name|void
name|jump_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|ERROR_NO_INFERIOR
expr_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"starting address"
argument_list|)
expr_stmt|;
name|sals
operator|=
name|decode_line_spec_1
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sals
operator|.
name|nelts
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Unreasonable jump request"
argument_list|)
expr_stmt|;
block|}
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
operator|&&
name|sal
operator|.
name|pc
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No source file has been specified."
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|pc
operator|==
literal|0
condition|)
name|sal
operator|.
name|pc
operator|=
name|find_line_pc
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|fn
init|=
name|get_frame_function
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sfn
init|=
name|find_pc_function
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn
operator|!=
literal|0
operator|&&
name|sfn
operator|!=
name|fn
operator|&&
operator|!
name|query
argument_list|(
literal|"Line %d is not in `%s'.  Jump anyway? "
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sal
operator|.
name|pc
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No line %d in file \"%s\"."
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|addr
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Continuing at 0x%x.\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|proceed
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Continue program giving it specified signal.  */
end_comment

begin_function
specifier|static
name|void
name|signal_command
parameter_list|(
name|signum_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|signum_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|int
name|signum
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* Too dangerous.  */
name|ERROR_NO_INFERIOR
expr_stmt|;
if|if
condition|(
operator|!
name|signum_exp
condition|)
name|error_no_arg
argument_list|(
literal|"signal number"
argument_list|)
expr_stmt|;
name|signum
operator|=
name|parse_and_eval_address
argument_list|(
name|signum_exp
argument_list|)
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Continuing with signal %d.\n"
argument_list|,
name|signum
argument_list|)
expr_stmt|;
name|proceed
argument_list|(
name|stop_pc
argument_list|,
name|signum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Execute a "stack dummy", a piece of code stored in the stack    by the debugger to be executed in the inferior.     To call: first, do PUSH_DUMMY_FRAME.    Then push the contents of the dummy.  It should end with a breakpoint insn.    Then call here, passing address at which to start the dummy.     The contents of all registers are saved before the dummy frame is popped    and copied into the buffer BUFFER.     The dummy's frame is automatically popped whenever that break is hit.    If that is the first time the program stops, run_stack_dummy    returns to its caller with that frame already gone.    Otherwise, the caller never gets returned to.  */
end_comment

begin_comment
comment|/* 4 => return instead of letting the stack dummy run.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stack_dummy_testing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|run_stack_dummy
parameter_list|(
name|addr
parameter_list|,
name|buffer
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|REGISTER_TYPE
modifier|*
name|buffer
decl_stmt|;
block|{
comment|/* Now proceed, having reached the desired place.  */
name|clear_proceed_status
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|stack_dummy_testing
operator|&
literal|4
condition|)
block|{
name|POP_FRAME
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|proceed
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stop_stack_dummy
condition|)
name|error
argument_list|(
literal|"Cannot continue previously requested operation."
argument_list|)
expr_stmt|;
comment|/* On return, the stack dummy has been popped already.  */
name|read_register_bytes
argument_list|(
literal|0
argument_list|,
name|buffer
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Proceed until we reach the given line as argument or exit the    function.  When called with no argument, proceed until we reach a    different source line with pc greater than our current one or exit    the function.  We skip calls in both cases.     The effect of this command with an argument is identical to setting    a momentary breakpoint at the line specified and executing    "finish".     Note that eventually this command should probably be changed so    that only source lines are printed out when we hit the breakpoint    we set.  I'm going to postpone this until after a hopeful rewrite    of wait_for_inferior and the proceed status code. -- randy */
end_comment

begin_function
name|void
name|until_next_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|FRAME
name|frame
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|struct
name|symbol
modifier|*
name|func
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|frame
operator|=
name|get_current_frame
argument_list|()
expr_stmt|;
comment|/* Step until either exited from this function or greater      than the current line (if in symbolic section) or pc (if      not). */
name|pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|func
operator|=
name|find_pc_function
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|func
condition|)
block|{
name|int
name|misc_func
init|=
name|find_pc_misc_function
argument_list|(
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|misc_func
operator|!=
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Execution is not within a known function."
argument_list|)
expr_stmt|;
name|step_range_start
operator|=
name|misc_function_vector
index|[
name|misc_func
index|]
operator|.
name|address
expr_stmt|;
name|step_range_end
operator|=
name|pc
expr_stmt|;
block|}
else|else
block|{
name|sal
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|step_range_start
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|func
argument_list|)
argument_list|)
expr_stmt|;
name|step_range_end
operator|=
name|sal
operator|.
name|end
expr_stmt|;
block|}
name|step_over_calls
operator|=
literal|1
expr_stmt|;
name|step_frame_address
operator|=
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|step_multi
operator|=
literal|0
expr_stmt|;
comment|/* Only one call to proceed */
name|proceed
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|until_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|have_inferior_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"The program is not being run."
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|until_break_command
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|else
name|until_next_command
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* "finish": Set a temporary breakpoint at the place    the selected frame will return to, then continue.  */
end_comment

begin_function
specifier|static
name|void
name|finish_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
specifier|register
name|FRAME
name|frame
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|function
decl_stmt|;
if|if
condition|(
operator|!
name|have_inferior_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"The program is not being run."
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|error
argument_list|(
literal|"The \"finish\" command does not take any arguments."
argument_list|)
expr_stmt|;
name|frame
operator|=
name|get_prev_frame
argument_list|(
name|selected_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"\"finish\" not meaningful in the outermost frame."
argument_list|)
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sal
operator|.
name|pc
operator|=
name|fi
operator|->
name|pc
expr_stmt|;
name|set_momentary_breakpoint
argument_list|(
name|sal
argument_list|,
name|frame
argument_list|)
expr_stmt|;
comment|/* Find the function we will return from.  */
name|fi
operator|=
name|get_frame_info
argument_list|(
name|selected_frame
argument_list|)
expr_stmt|;
name|function
operator|=
name|find_pc_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"Run till exit from "
argument_list|)
expr_stmt|;
name|print_selected_frame
argument_list|()
expr_stmt|;
block|}
name|proceed
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stop_breakpoint
operator|==
operator|-
literal|3
operator|&&
name|function
operator|!=
literal|0
condition|)
block|{
name|struct
name|type
modifier|*
name|value_type
decl_stmt|;
specifier|register
name|value
name|val
decl_stmt|;
name|CORE_ADDR
name|funcaddr
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
name|value_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value_type
condition|)
name|fatal
argument_list|(
literal|"internal: finish_command: function has no target type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|value_type
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
return|return;
name|funcaddr
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|value_being_returned
argument_list|(
name|value_type
argument_list|,
name|registers
argument_list|,
name|using_struct_return
argument_list|(
name|function
argument_list|,
name|funcaddr
argument_list|,
name|value_type
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Value returned is $%d = "
argument_list|,
name|record_latest_value
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|val
argument_list|,
name|stdout
argument_list|,
literal|0
argument_list|,
name|Val_no_prettyprint
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|program_info
parameter_list|()
block|{
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"The program being debugged is not being run.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"Program being debugged is in process %d, stopped at 0x%x.\n"
argument_list|,
name|inferior_pid
argument_list|,
name|stop_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stop_step
condition|)
name|printf
argument_list|(
literal|"It stopped after being stepped.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|stop_breakpoint
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"It stopped at breakpoint %d.\n"
argument_list|,
name|stop_breakpoint
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|stop_signal
condition|)
name|printf
argument_list|(
literal|"It stopped with signal %d (%s).\n"
argument_list|,
name|stop_signal
argument_list|,
name|sys_siglist
index|[
name|stop_signal
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nType \"info stack\" or \"info reg\" for more information.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|environment_info
parameter_list|(
name|var
parameter_list|)
name|char
modifier|*
name|var
decl_stmt|;
block|{
if|if
condition|(
name|var
condition|)
block|{
specifier|register
name|char
modifier|*
name|val
init|=
name|get_in_environ
argument_list|(
name|inferior_environ
argument_list|,
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
condition|)
name|printf
argument_list|(
literal|"%s = %s\n"
argument_list|,
name|var
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Environment variable \"%s\" not defined.\n"
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|char
modifier|*
modifier|*
name|vector
init|=
name|environ_vector
argument_list|(
name|inferior_environ
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|vector
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
operator|*
name|vector
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_environment_command
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|val
decl_stmt|,
modifier|*
name|var
decl_stmt|;
name|int
name|nullset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"environment variable and value"
argument_list|)
expr_stmt|;
comment|/* Find seperation between variable name and value */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|arg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|arg
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
operator|&&
name|val
operator|!=
literal|0
condition|)
block|{
comment|/* We have both a space and an equals.  If the space is before the 	 equals and the only thing between the two is more space, use 	 the equals */
if|if
condition|(
name|p
operator|>
name|val
condition|)
while|while
condition|(
operator|*
name|val
operator|==
literal|' '
condition|)
name|val
operator|++
expr_stmt|;
comment|/* Take the smaller of the two.  If there was space before the 	 "=", they will be the same right now. */
name|p
operator|=
name|arg
operator|+
name|min
argument_list|(
name|p
operator|-
name|arg
argument_list|,
name|val
operator|-
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|!=
literal|0
operator|&&
name|p
operator|==
literal|0
condition|)
name|p
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"environment variable to set"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|nullset
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|p
operator|=
name|arg
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* So that savestring below will work */
block|}
else|else
block|{
comment|/* Not setting variable value to null */
name|val
operator|=
name|p
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|val
operator|==
literal|' '
operator|||
operator|*
name|val
operator|==
literal|'\t'
condition|)
name|val
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|!=
name|arg
operator|&&
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|p
operator|--
expr_stmt|;
name|var
operator|=
name|savestring
argument_list|(
name|arg
argument_list|,
name|p
operator|-
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|nullset
condition|)
block|{
name|printf
argument_list|(
literal|"Setting environment variable \"%s\" to null value.\n"
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|set_in_environ
argument_list|(
name|inferior_environ
argument_list|,
name|var
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|set_in_environ
argument_list|(
name|inferior_environ
argument_list|,
name|var
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unset_environment_command
parameter_list|(
name|var
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|var
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|var
operator|==
literal|0
condition|)
comment|/* If there is no argument, delete all environment variables.        Ask for confirmation if reading from the terminal.  */
if|if
condition|(
operator|!
name|from_tty
operator|||
name|query
argument_list|(
literal|"Delete all environment variables? "
argument_list|)
condition|)
block|{
name|free_environ
argument_list|(
name|inferior_environ
argument_list|)
expr_stmt|;
name|inferior_environ
operator|=
name|make_environ
argument_list|()
expr_stmt|;
block|}
name|unset_in_environ
argument_list|(
name|inferior_environ
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read an integer from debugged memory, given address and number of bytes.  */
end_comment

begin_function
name|long
name|read_memory_integer
parameter_list|(
name|memaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
name|cbuf
decl_stmt|;
name|short
name|sbuf
decl_stmt|;
name|int
name|ibuf
decl_stmt|;
name|long
name|lbuf
decl_stmt|;
name|int
name|result_err
decl_stmt|;
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|)
block|{
name|result_err
operator|=
name|read_memory
argument_list|(
name|memaddr
argument_list|,
operator|&
name|cbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_err
condition|)
name|error
argument_list|(
literal|"Error reading memory address 0x%x: %s (%d)."
argument_list|,
name|memaddr
argument_list|,
operator|(
name|result_err
operator|<
name|sys_nerr
condition|?
name|sys_errlist
index|[
name|result_err
index|]
else|:
literal|"uknown error"
operator|)
argument_list|,
name|result_err
argument_list|)
expr_stmt|;
return|return
name|cbuf
return|;
block|}
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|short
argument_list|)
condition|)
block|{
name|result_err
operator|=
name|read_memory
argument_list|(
name|memaddr
argument_list|,
operator|&
name|sbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_err
condition|)
name|error
argument_list|(
literal|"Error reading memory address 0x%x: %s (%d)."
argument_list|,
name|memaddr
argument_list|,
operator|(
name|result_err
operator|<
name|sys_nerr
condition|?
name|sys_errlist
index|[
name|result_err
index|]
else|:
literal|"uknown error"
operator|)
argument_list|,
name|result_err
argument_list|)
expr_stmt|;
return|return
name|sbuf
return|;
block|}
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|result_err
operator|=
name|read_memory
argument_list|(
name|memaddr
argument_list|,
operator|&
name|ibuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_err
condition|)
name|error
argument_list|(
literal|"Error reading memory address 0x%x: %s (%d)."
argument_list|,
name|memaddr
argument_list|,
operator|(
name|result_err
operator|<
name|sys_nerr
condition|?
name|sys_errlist
index|[
name|result_err
index|]
else|:
literal|"uknown error"
operator|)
argument_list|,
name|result_err
argument_list|)
expr_stmt|;
return|return
name|ibuf
return|;
block|}
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|lbuf
argument_list|)
condition|)
block|{
name|result_err
operator|=
name|read_memory
argument_list|(
name|memaddr
argument_list|,
operator|&
name|lbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_err
condition|)
name|error
argument_list|(
literal|"Error reading memory address 0x%x: %s (%d)."
argument_list|,
name|memaddr
argument_list|,
operator|(
name|result_err
operator|<
name|sys_nerr
condition|?
name|sys_errlist
index|[
name|result_err
index|]
else|:
literal|"uknown error"
operator|)
argument_list|,
name|result_err
argument_list|)
expr_stmt|;
return|return
name|lbuf
return|;
block|}
name|error
argument_list|(
literal|"Cannot handle integers of %d bytes."
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|CORE_ADDR
name|read_pc
parameter_list|()
block|{
return|return
operator|(
name|CORE_ADDR
operator|)
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|write_pc
parameter_list|(
name|val
parameter_list|)
name|CORE_ADDR
name|val
decl_stmt|;
block|{
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NPC_REGNUM
name|write_register
argument_list|(
name|NPC_REGNUM
argument_list|,
operator|(
name|long
operator|)
name|val
operator|+
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|reg_names
index|[]
init|=
name|REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DO_REGISTERS_INFO
argument_list|)
end_if

begin_function
specifier|static
name|void
name|print_one_register
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|unsigned
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|unsigned
name|char
name|virtual_buffer
index|[
name|MAX_REGISTER_VIRTUAL_SIZE
index|]
decl_stmt|;
name|REGISTER_TYPE
name|val
decl_stmt|;
comment|/* Get the data in raw format, then convert also to virtual format.  */
name|read_relative_register_raw_bytes
argument_list|(
name|i
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
name|REGISTER_CONVERT_TO_VIRTUAL
argument_list|(
name|i
argument_list|,
name|raw_buffer
argument_list|,
name|virtual_buffer
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|reg_names
index|[
name|i
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|15
operator|-
name|strlen
argument_list|(
name|reg_names
index|[
name|i
index|]
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* If virtual format is floating, print it that way.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
operator|!
name|INVALID_FLOAT
argument_list|(
name|virtual_buffer
argument_list|,
name|REGISTER_VIRTUAL_SIZE
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
name|val_print
argument_list|(
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|i
argument_list|)
argument_list|,
name|virtual_buffer
argument_list|,
literal|0
argument_list|,
name|stdout
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
comment|/* Else if virtual format is too long for printf, 	   print in hex a byte at a time.  */
elseif|else
if|if
condition|(
name|REGISTER_VIRTUAL_SIZE
argument_list|(
name|i
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGISTER_VIRTUAL_SIZE
argument_list|(
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|printf_filtered
argument_list|(
literal|"%02x"
argument_list|,
name|virtual_buffer
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Else print as integer in hex and in decimal.  */
else|else
block|{
name|long
name|val
decl_stmt|;
name|bcopy
argument_list|(
name|virtual_buffer
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"0x%08x  %d"
argument_list|,
name|val
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* If register has different raw and virtual formats, 	   print the raw format in hex now.  */
if|if
condition|(
name|REGISTER_CONVERTIBLE
argument_list|(
name|i
argument_list|)
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"  (raw 0x"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|printf_filtered
argument_list|(
literal|"%02x"
argument_list|,
name|raw_buffer
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out the machine register regnum. If regnum is -1,    print all registers.    For most machines, having all_registers_info() print the    register(s) one per line is good enough. If a different format    is required, (eg, for SPARC or Pyramid 90x, which both have    lots of regs), or there is an existing convention for showing    all the registers, define the macro DO_REGISTERS_INFO(regnum)    to provide that format.  */
end_comment

begin_function
specifier|static
name|void
name|do_registers_info
parameter_list|(
name|regnum
parameter_list|,
name|fpregs
parameter_list|)
name|int
name|regnum
decl_stmt|;
name|int
name|fpregs
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|regnum
operator|>=
literal|0
condition|)
block|{
name|print_one_register
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|notdef
name|printf_filtered
argument_list|(
literal|"Register       Contents (relative to selected stack frame)\n\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_FLT
operator|||
name|fpregs
condition|)
name|print_one_register
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no DO_REGISTERS_INFO.  */
end_comment

begin_function
specifier|static
name|void
name|registers_info
parameter_list|(
name|addr_exp
parameter_list|,
name|fpregs
parameter_list|)
name|char
modifier|*
name|addr_exp
decl_stmt|;
name|int
name|fpregs
decl_stmt|;
block|{
name|int
name|regnum
decl_stmt|;
if|if
condition|(
operator|!
name|have_inferior_p
argument_list|()
operator|&&
operator|!
name|have_core_file_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"No inferior or core file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_exp
condition|)
block|{
if|if
condition|(
operator|*
name|addr_exp
operator|>=
literal|'0'
operator|&&
operator|*
name|addr_exp
operator|<=
literal|'9'
condition|)
name|regnum
operator|=
name|atoi
argument_list|(
name|addr_exp
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|addr_exp
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
name|p
operator|++
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
condition|;
name|regnum
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
name|reg_names
index|[
name|regnum
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|regnum
operator|==
name|NUM_REGS
condition|)
name|error
argument_list|(
literal|"%s: invalid register name."
argument_list|,
name|addr_exp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|regnum
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_REGISTERS_INFO
name|DO_REGISTERS_INFO
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
else|#
directive|else
name|do_registers_info
argument_list|(
name|regnum
argument_list|,
name|fpregs
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|all_registers_info
parameter_list|(
name|addr_exp
parameter_list|)
name|char
modifier|*
name|addr_exp
decl_stmt|;
block|{
name|registers_info
argument_list|(
name|addr_exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nofp_registers_info
parameter_list|(
name|addr_exp
parameter_list|)
name|char
modifier|*
name|addr_exp
decl_stmt|;
block|{
name|registers_info
argument_list|(
name|addr_exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|ATTACH_DETACH
end_ifdef

begin_define
define|#
directive|define
name|PROCESS_ATTACH_ALLOWED
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PROCESS_ATTACH_ALLOWED
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * TODO:  * Should save/restore the tty state since it might be that the  * program to be debugged was started on this tty and it wants  * the tty in some state other than what we want.  If it's running  * on another terminal or without a terminal, then saving and  * restoring the tty state is a harmless no-op.  * This only needs to be done if we are attaching to a process.  */
end_comment

begin_comment
comment|/*  * attach_command --  * takes a program started up outside of gdb and ``attaches'' to it.  * This stops it cold in its tracks and allows us to start tracing it.  * For this to work, we must be able to send the process a  * signal and we must have the same effective uid as the program.  */
end_comment

begin_function
specifier|static
name|void
name|attach_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|exec_file
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|remote
init|=
literal|0
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"process-id or device file to attach"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|args
operator|==
literal|' '
operator|||
operator|*
name|args
operator|==
literal|'\t'
condition|)
name|args
operator|++
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|<
literal|'0'
operator|||
name|args
index|[
literal|0
index|]
operator|>
literal|'9'
condition|)
name|remote
operator|=
literal|1
expr_stmt|;
else|else
ifndef|#
directive|ifndef
name|ATTACH_DETACH
name|error
argument_list|(
literal|"Can't attach to a process on this machine."
argument_list|)
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|inferior_pid
condition|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"A program is being debugged already.  Kill it? "
argument_list|)
condition|)
name|kill_inferior
argument_list|()
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Inferior not killed."
argument_list|)
expr_stmt|;
block|}
name|exec_file
operator|=
operator|(
name|char
operator|*
operator|)
name|get_exec_file
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
if|if
condition|(
name|remote
condition|)
name|printf
argument_list|(
literal|"Attaching remote machine\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Attaching program: %s pid %d\n"
argument_list|,
name|exec_file
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remote
condition|)
block|{
name|remote_open
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|start_remote
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ATTACH_DETACH
else|else
name|attach_program
argument_list|(
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * detach_command --  * takes a program previously attached to and detaches it.  * The program resumes execution and will no longer stop  * on signals, etc.  We better not have left any breakpoints  * in the program or it'll die when it hits one.  For this  * to work, it may be necessary for the process to have been  * previously attached.  It *might* work if the program was  * started via the normal ptrace (PTRACE_TRACEME).  */
end_comment

begin_function
specifier|static
name|void
name|detach_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|signal
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|ATTACH_DETACH
if|if
condition|(
name|inferior_pid
operator|&&
operator|!
name|remote_debugging
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
block|{
name|char
modifier|*
name|exec_file
init|=
operator|(
name|char
operator|*
operator|)
name|get_exec_file
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|exec_file
operator|==
literal|0
condition|)
name|exec_file
operator|=
literal|""
expr_stmt|;
name|printf
argument_list|(
literal|"Detaching program: %s pid %d\n"
argument_list|,
name|exec_file
argument_list|,
name|inferior_pid
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
condition|)
name|signal
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|detach
argument_list|(
name|signal
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
operator|!
name|remote_debugging
condition|)
name|error
argument_list|(
literal|"Not currently attached to subsidiary or remote process."
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Argument given to \"detach\" when remotely debugging."
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
name|remote_close
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|float_info
parameter_list|(
name|addr_exp
parameter_list|)
name|char
modifier|*
name|addr_exp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|FLOAT_INFO
name|FLOAT_INFO
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"No floating point info available for this processor.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|setlist
decl_stmt|,
modifier|*
name|deletelist
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_infcmd
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"tty"
argument_list|,
name|class_run
argument_list|,
name|tty_command
argument_list|,
literal|"Set terminal for future runs of program being debugged."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"args"
argument_list|,
name|class_run
argument_list|,
name|set_args_command
argument_list|,
literal|"Specify arguments to give program being debugged when it is started.\n\ Follow this command with any number of args, to be passed to the program."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"environment"
argument_list|,
name|environment_info
argument_list|,
literal|"The environment to give the program, or one variable's value.\n\ With an argument VAR, prints the value of environment variable VAR to\n\ give the program being debugged.  With no arguments, prints the entire\n\ environment to be given to the program."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"environment"
argument_list|,
name|class_run
argument_list|,
name|unset_environment_command
argument_list|,
literal|"Cancel environment variable VAR for the program.\n\ This does not affect the program until the next \"run\" command."
argument_list|,
operator|&
name|deletelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"environment"
argument_list|,
name|class_run
argument_list|,
name|set_environment_command
argument_list|,
literal|"Set environment variable value to give the program.\n\ Arguments are VAR VALUE where VAR is variable name and VALUE is value.\n\ VALUES of environment variables are uninterpreted strings.\n\ This does not affect the program until the next \"run\" command."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATTACH_DETACH
name|add_com
argument_list|(
literal|"attach"
argument_list|,
name|class_run
argument_list|,
name|attach_command
argument_list|,
literal|"Attach to a process that was started up outside of GDB.\n\ This command may take as argument a process id or a device file.\n\ For a process id, you must have permission to send the process a signal,\n\ and it must have the same effective uid as the debugger.\n\ For a device file, the file must be a connection to a remote debug server.\n\n\ Before using \"attach\", you must use the \"exec-file\" command\n\ to specify the program running in the process,\n\ and the \"symbol-file\" command to load its symbol table."
argument_list|)
expr_stmt|;
else|#
directive|else
name|add_com
argument_list|(
literal|"attach"
argument_list|,
name|class_run
argument_list|,
name|attach_command
argument_list|,
literal|"Attach to a process that was started up outside of GDB.\n\ This commands takes as an argument the name of a device file.\n\ This file must be a connection to a remote debug server.\n\n\ Before using \"attach\", you must use the \"exec-file\" command\n\ to specify the program running in the process,\n\ and the \"symbol-file\" command to load its symbol table."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_com
argument_list|(
literal|"detach"
argument_list|,
name|class_run
argument_list|,
name|detach_command
argument_list|,
literal|"Detach the process previously attached.\n\ The process is no longer traced and continues its execution."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"signal"
argument_list|,
name|class_run
argument_list|,
name|signal_command
argument_list|,
literal|"Continue program giving it signal number SIGNUMBER."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"stepi"
argument_list|,
name|class_run
argument_list|,
name|stepi_command
argument_list|,
literal|"Step one instruction exactly.\n\ Argument N means do this N times (or till program stops for another reason)."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"si"
argument_list|,
literal|"stepi"
argument_list|,
name|class_alias
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"nexti"
argument_list|,
name|class_run
argument_list|,
name|nexti_command
argument_list|,
literal|"Step one instruction, but proceed through subroutine calls.\n\ Argument N means do this N times (or till program stops for another reason)."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"ni"
argument_list|,
literal|"nexti"
argument_list|,
name|class_alias
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"finish"
argument_list|,
name|class_run
argument_list|,
name|finish_command
argument_list|,
literal|"Execute until selected stack frame returns.\n\ Upon return, the value returned is printed and put in the value history."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"next"
argument_list|,
name|class_run
argument_list|,
name|next_command
argument_list|,
literal|"Step program, proceeding through subroutine calls.\n\ Like the \"step\" command as long as subroutine calls do not happen;\n\ when they do, the call is treated as one instruction.\n\ Argument N means do this N times (or till program stops for another reason)."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"n"
argument_list|,
literal|"next"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"step"
argument_list|,
name|class_run
argument_list|,
name|step_command
argument_list|,
literal|"Step program until it reaches a different source line.\n\ Argument N means do this N times (or till program stops for another reason)."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"s"
argument_list|,
literal|"step"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"until"
argument_list|,
name|class_run
argument_list|,
name|until_command
argument_list|,
literal|"Execute until the program reaches a source line greater than the current\n\ or a specified line or address or function (same args as break command).\n\ Execution will also stop upon exit from the current stack frame."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"u"
argument_list|,
literal|"until"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"jump"
argument_list|,
name|class_run
argument_list|,
name|jump_command
argument_list|,
literal|"Continue program being debugged at specified line or address.\n\ Give as argument either LINENUM or *ADDR, where ADDR is an expression\n\ for an address to start at."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"cont"
argument_list|,
name|class_run
argument_list|,
name|cont_command
argument_list|,
literal|"Continue program being debugged, after signal or breakpoint.\n\ If proceeding from breakpoint, a number N may be used as an argument:\n\ then the same breakpoint won't break until the Nth time it is reached."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"c"
argument_list|,
literal|"cont"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"run"
argument_list|,
name|class_run
argument_list|,
name|run_command
argument_list|,
literal|"Start debugged program.  You may specify arguments to give it.\n\ Args may include \"*\", or \"[...]\"; they are expanded using \"sh\".\n\ Input and output redirection with \">\", \"<\", or \">>\" are also allowed.\n\n\ With no arguments, uses arguments last specified (with \"run\" or \"set args\".\n\ To cancel previous arguments and run with no arguments,\n\ use \"set args\" without arguments."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"r"
argument_list|,
literal|"run"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"registers"
argument_list|,
name|nofp_registers_info
argument_list|,
literal|"List of registers and their contents, for selected stack frame.\n\ Register name as argument means describe only that register.\n\ (Doesn't display floating point registers; use 'info all-registers'.)\n"
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"all-registers"
argument_list|,
name|all_registers_info
argument_list|,
literal|"List of registers and their contents, for selected stack frame.\n\ Register name as argument means describe only that register."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"program"
argument_list|,
name|program_info
argument_list|,
literal|"Execution status of the program."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"float"
argument_list|,
name|float_info
argument_list|,
literal|"Print the status of the floating point unit\n"
argument_list|)
expr_stmt|;
name|inferior_args
operator|=
name|savestring
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* By default, no args.  */
name|inferior_environ
operator|=
name|make_environ
argument_list|()
expr_stmt|;
name|init_environ
argument_list|(
name|inferior_environ
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

