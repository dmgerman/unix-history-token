begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1984-1987 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)telnet.c	1.2 (Berkeley) 9/25/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|unix
argument_list|)
end_if

begin_comment
comment|/* By the way, we need to include curses.h before telnet.h since,  * among other things, telnet.h #defines 'DO', which is a variable  * declared in curses.h.  */
end_comment

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(unix) */
end_comment

begin_include
include|#
directive|include
file|<arpa/telnet.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NOT43
argument_list|)
end_if

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !defined(NOT43) */
end_comment

begin_function_decl
specifier|extern
name|unsigned
name|long
name|inet_addr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|inet_ntoa
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(NOT43) */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|unix
argument_list|)
end_if

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined(unix) */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(unix) */
end_comment

begin_include
include|#
directive|include
file|"ring.h"
end_include

begin_include
include|#
directive|include
file|"defines.h"
end_include

begin_include
include|#
directive|include
file|"externs.h"
end_include

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_decl_stmt
name|void
name|setcommandmode
argument_list|()
decl_stmt|,
name|command
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* forward declarations */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FD_SETSIZE
end_ifndef

begin_comment
comment|/*  * The following is defined just in case someone should want to run  * this telnet on a 4.2 system.  *  */
end_comment

begin_define
define|#
directive|define
name|FD_SET
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|)
value|((p)->fds_bits[0] |= (1<<(n)))
end_define

begin_define
define|#
directive|define
name|FD_CLR
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|)
value|((p)->fds_bits[0]&= ~(1<<(n)))
end_define

begin_define
define|#
directive|define
name|FD_ISSET
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|)
value|((p)->fds_bits[0]& (1<<(n)))
end_define

begin_define
define|#
directive|define
name|FD_ZERO
parameter_list|(
name|p
parameter_list|)
value|((p)->fds_bits[0] = 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_define
define|#
directive|define
name|strip
parameter_list|(
name|x
parameter_list|)
value|((x)&0x7f)
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x<y)? x:y)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|Ibuf
index|[
literal|8
operator|*
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|Ifrontp
decl_stmt|,
modifier|*
name|Ibackp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(TN3270) */
end_comment

begin_decl_stmt
specifier|static
name|char
name|subbuffer
index|[
name|SUBBUFSIZE
index|]
decl_stmt|,
modifier|*
name|subpointer
decl_stmt|,
modifier|*
name|subend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for sub-options */
end_comment

begin_define
define|#
directive|define
name|SB_CLEAR
parameter_list|()
value|subpointer = subbuffer;
end_define

begin_define
define|#
directive|define
name|SB_TERM
parameter_list|()
value|subend = subpointer;
end_define

begin_define
define|#
directive|define
name|SB_ACCUM
parameter_list|(
name|c
parameter_list|)
value|if (subpointer< (subbuffer+sizeof subbuffer)) { \ 				*subpointer++ = (c); \ 			}
end_define

begin_decl_stmt
specifier|static
name|char
name|sb_terminal
index|[]
init|=
block|{
name|IAC
block|,
name|SB
block|,
name|TELOPT_TTYPE
block|,
name|TELQUAL_IS
block|,
literal|'I'
block|,
literal|'B'
block|,
literal|'M'
block|,
literal|'-'
block|,
literal|'3'
block|,
literal|'2'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'-'
block|,
literal|'2'
block|,
name|IAC
block|,
name|SE
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SBTERMMODEL
value|13
end_define

begin_decl_stmt
name|char
name|hisopts
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|myopts
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|doopt
index|[]
init|=
block|{
name|IAC
block|,
name|DO
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|dont
index|[]
init|=
block|{
name|IAC
block|,
name|DONT
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|will
index|[]
init|=
block|{
name|IAC
block|,
name|WILL
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|wont
index|[]
init|=
block|{
name|IAC
block|,
name|WONT
block|,
literal|'%'
block|,
literal|'c'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Ring
name|netiring
decl_stmt|,
name|ttyiring
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|netibuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ttyibuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fd_set
name|ibits
decl_stmt|,
name|obits
decl_stmt|,
name|xbits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|connected
decl_stmt|,
name|net
decl_stmt|,
name|showoptions
decl_stmt|,
name|In3270
decl_stmt|,
comment|/* Are we in 3270 mode? */
name|ISend
decl_stmt|,
comment|/* trying to send network data in */
name|debug
init|=
literal|0
decl_stmt|,
name|crmod
decl_stmt|,
name|netdata
decl_stmt|,
comment|/* Print out network data flow */
name|crlf
decl_stmt|,
comment|/* Should '\r' be mapped to<CR><LF> (or<CR><NUL>)? */
name|noasynch
init|=
literal|0
decl_stmt|,
comment|/* User specified "-noasynch" on command line */
name|askedSGA
init|=
literal|0
decl_stmt|,
comment|/* We have talked about suppress go ahead */
name|telnetport
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CONTROL
parameter_list|(
name|x
parameter_list|)
value|((x)&0x1f)
end_define

begin_comment
comment|/* CTRL(x) is not portable */
end_comment

begin_decl_stmt
name|char
modifier|*
name|prompt
init|=
literal|0
decl_stmt|,
name|escape
decl_stmt|,
name|echoc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|SYNCHing
decl_stmt|,
comment|/* we are in TELNET SYNCH mode */
name|flushout
decl_stmt|,
comment|/* flush output */
name|autoflush
init|=
literal|0
decl_stmt|,
comment|/* flush output when interrupting? */
name|autosynch
decl_stmt|,
comment|/* send interrupt characters with SYNCH? */
name|localchars
decl_stmt|,
comment|/* we recognize interrupt/quit */
name|donelclchars
decl_stmt|,
comment|/* the user has set "localchars" */
name|donebinarytoggle
decl_stmt|,
comment|/* the user has put us in binary */
name|dontlecho
decl_stmt|,
comment|/* do we suppress local echoing right now? */
name|globalmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*	The following are some tn3270 specific flags */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|Sent3270TerminalType
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Have we said we are a 3270? */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(TN3270) */
end_comment

begin_decl_stmt
name|int
name|tout
decl_stmt|,
comment|/* Output file descriptor */
name|tin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Input file descriptor */
end_comment

begin_comment
comment|/*  * Telnet receiver states for fsm  */
end_comment

begin_define
define|#
directive|define
name|TS_DATA
value|0
end_define

begin_define
define|#
directive|define
name|TS_IAC
value|1
end_define

begin_define
define|#
directive|define
name|TS_WILL
value|2
end_define

begin_define
define|#
directive|define
name|TS_WONT
value|3
end_define

begin_define
define|#
directive|define
name|TS_DO
value|4
end_define

begin_define
define|#
directive|define
name|TS_DONT
value|5
end_define

begin_define
define|#
directive|define
name|TS_CR
value|6
end_define

begin_define
define|#
directive|define
name|TS_SB
value|7
end_define

begin_comment
comment|/* sub-option collection */
end_comment

begin_define
define|#
directive|define
name|TS_SE
value|8
end_define

begin_comment
comment|/* looking for sub-option end */
end_comment

begin_decl_stmt
specifier|static
name|int
name|telrcv_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|toplevel
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|peerdied
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flushline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following are some clocks used to decide how to interpret  * the relationship between various variables.  */
end_comment

begin_decl_stmt
name|Clocks
name|clocks
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
name|Modelist
name|modelist
index|[]
init|=
block|{
block|{
literal|"telnet command mode"
block|,
name|COMMAND_LINE
block|}
block|,
block|{
literal|"character-at-a-time mode"
block|,
literal|0
block|}
block|,
block|{
literal|"character-at-a-time mode (local echo)"
block|,
name|LOCAL_ECHO
operator||
name|LOCAL_CHARS
block|}
block|,
block|{
literal|"line-by-line mode (remote echo)"
block|,
name|LINE
operator||
name|LOCAL_CHARS
block|}
block|,
block|{
literal|"line-by-line mode"
block|,
name|LINE
operator||
name|LOCAL_ECHO
operator||
name|LOCAL_CHARS
block|}
block|,
block|{
literal|"line-by-line mode (local echoing suppressed)"
block|,
name|LINE
operator||
name|LOCAL_CHARS
block|}
block|,
block|{
literal|"3270 mode"
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  * Initialize telnet environment.  */
end_comment

begin_macro
name|init_telnet
argument_list|()
end_macro

begin_block
block|{
comment|/* Don't change telnetport */
name|SB_CLEAR
argument_list|()
expr_stmt|;
name|ClearArray
argument_list|(
name|hisopts
argument_list|)
expr_stmt|;
name|ClearArray
argument_list|(
name|myopts
argument_list|)
expr_stmt|;
name|ring_init
argument_list|(
operator|&
name|netiring
argument_list|,
name|netibuf
argument_list|,
sizeof|sizeof
name|netibuf
argument_list|)
expr_stmt|;
name|ring_init
argument_list|(
operator|&
name|ttyiring
argument_list|,
name|ttyibuf
argument_list|,
sizeof|sizeof
name|ttyibuf
argument_list|)
expr_stmt|;
name|connected
operator|=
name|net
operator|=
name|In3270
operator|=
name|ISend
operator|=
name|donebinarytoggle
operator|=
literal|0
expr_stmt|;
name|telnetport
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|unix
argument_list|)
operator|&&
name|defined
argument_list|(
name|TN3270
argument_list|)
name|HaveInput
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* defined(unix)&& defined(TN3270) */
name|SYNCHing
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* Don't change NetTrace */
name|escape
operator|=
name|CONTROL
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|echoc
operator|=
name|CONTROL
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
block|}
end_block

begin_function
name|void
name|willoption
parameter_list|(
name|option
parameter_list|,
name|reply
parameter_list|)
name|int
name|option
decl_stmt|,
name|reply
decl_stmt|;
block|{
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_ECHO
case|:
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
comment|/* 	     * The following is a pain in the rear-end. 	     * Various IBM servers (some versions of Wiscnet, 	     * possibly Fibronics/Spartacus, and who knows who 	     * else) will NOT allow us to send "DO SGA" too early 	     * in the setup proceedings.  On the other hand, 	     * 4.2 servers (telnetd) won't set SGA correctly. 	     * So, we are stuck.  Empirically (but, based on 	     * a VERY small sample), the IBM servers don't send 	     * out anything about ECHO, so we postpone our sending 	     * "DO SGA" until we see "WILL ECHO" (which 4.2 servers 	     * DO send). 	     */
block|{
if|if
condition|(
name|askedSGA
operator|==
literal|0
condition|)
block|{
name|askedSGA
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|hisopts
index|[
name|TELOPT_SGA
index|]
condition|)
block|{
name|willoption
argument_list|(
name|TELOPT_SGA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Fall through */
case|case
name|TELOPT_EOR
case|:
case|case
name|TELOPT_BINARY
case|:
endif|#
directive|endif
comment|/* defined(TN3270) */
case|case
name|TELOPT_SGA
case|:
name|settimer
argument_list|(
name|modenegotiated
argument_list|)
expr_stmt|;
name|hisopts
index|[
name|option
index|]
operator|=
literal|1
expr_stmt|;
name|fmt
operator|=
name|doopt
expr_stmt|;
name|setconnmode
argument_list|()
expr_stmt|;
comment|/* possibly set new tty mode */
break|break;
case|case
name|TELOPT_TM
case|:
return|return;
comment|/* Never reply to TM will's/wont's */
default|default:
name|fmt
operator|=
name|dont
expr_stmt|;
break|break;
block|}
name|netoprint
argument_list|(
name|fmt
argument_list|,
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
name|printoption
argument_list|(
literal|">SENT"
argument_list|,
name|fmt
argument_list|,
name|option
argument_list|,
name|reply
argument_list|)
expr_stmt|;
else|else
name|printoption
argument_list|(
literal|"<SENT"
argument_list|,
name|fmt
argument_list|,
name|option
argument_list|,
name|reply
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wontoption
parameter_list|(
name|option
parameter_list|,
name|reply
parameter_list|)
name|int
name|option
decl_stmt|,
name|reply
decl_stmt|;
block|{
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_ECHO
case|:
case|case
name|TELOPT_SGA
case|:
name|settimer
argument_list|(
name|modenegotiated
argument_list|)
expr_stmt|;
name|hisopts
index|[
name|option
index|]
operator|=
literal|0
expr_stmt|;
name|fmt
operator|=
name|dont
expr_stmt|;
name|setconnmode
argument_list|()
expr_stmt|;
comment|/* Set new tty mode */
break|break;
case|case
name|TELOPT_TM
case|:
return|return;
comment|/* Never reply to TM will's/wont's */
default|default:
name|fmt
operator|=
name|dont
expr_stmt|;
block|}
name|netoprint
argument_list|(
name|fmt
argument_list|,
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
name|printoption
argument_list|(
literal|">SENT"
argument_list|,
name|fmt
argument_list|,
name|option
argument_list|,
name|reply
argument_list|)
expr_stmt|;
else|else
name|printoption
argument_list|(
literal|"<SENT"
argument_list|,
name|fmt
argument_list|,
name|option
argument_list|,
name|reply
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dooption
parameter_list|(
name|option
parameter_list|)
name|int
name|option
decl_stmt|;
block|{
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_TM
case|:
name|fmt
operator|=
name|will
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
case|case
name|TELOPT_EOR
case|:
case|case
name|TELOPT_BINARY
case|:
endif|#
directive|endif
comment|/* defined(TN3270) */
case|case
name|TELOPT_TTYPE
case|:
comment|/* terminal type option */
case|case
name|TELOPT_SGA
case|:
comment|/* no big deal */
name|fmt
operator|=
name|will
expr_stmt|;
name|myopts
index|[
name|option
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TELOPT_ECHO
case|:
comment|/* We're never going to echo... */
default|default:
name|fmt
operator|=
name|wont
expr_stmt|;
break|break;
block|}
name|netoprint
argument_list|(
name|fmt
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|">SENT"
argument_list|,
name|fmt
argument_list|,
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * suboption()  *  *	Look at the sub-option buffer, and try to be helpful to the other  * side.  *  *	Currently we recognize:  *  *		Terminal type, send request.  */
end_comment

begin_function
specifier|static
name|void
name|suboption
parameter_list|()
block|{
name|printsub
argument_list|(
literal|"<"
argument_list|,
name|subbuffer
argument_list|,
name|subend
operator|-
name|subbuffer
operator|+
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|subbuffer
index|[
literal|0
index|]
operator|&
literal|0xff
condition|)
block|{
case|case
name|TELOPT_TTYPE
case|:
if|if
condition|(
operator|(
name|subbuffer
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|!=
name|TELQUAL_SEND
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|namebuf
index|[
literal|41
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|int
name|len
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
comment|/* 	     * Try to send a 3270 type terminal name.  Decide which one based 	     * on the format of our screen, and (in the future) color 	     * capaiblities. 	     */
if|#
directive|if
name|defined
argument_list|(
name|unix
argument_list|)
if|if
condition|(
name|initscr
argument_list|()
operator|!=
name|ERR
condition|)
block|{
comment|/* Initialize curses to get line size */
name|MaxNumberLines
operator|=
name|LINES
expr_stmt|;
name|MaxNumberColumns
operator|=
name|COLS
expr_stmt|;
block|}
else|#
directive|else
comment|/* defined(unix) */
name|InitTerminal
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* defined(unix) */
if|if
condition|(
operator|(
name|MaxNumberLines
operator|>=
literal|24
operator|)
operator|&&
operator|(
name|MaxNumberColumns
operator|>=
literal|80
operator|)
condition|)
block|{
name|Sent3270TerminalType
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|MaxNumberLines
operator|>=
literal|27
operator|)
operator|&&
operator|(
name|MaxNumberColumns
operator|>=
literal|132
operator|)
condition|)
block|{
name|MaxNumberLines
operator|=
literal|27
expr_stmt|;
name|MaxNumberColumns
operator|=
literal|132
expr_stmt|;
name|sb_terminal
index|[
name|SBTERMMODEL
index|]
operator|=
literal|'5'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MaxNumberLines
operator|>=
literal|43
condition|)
block|{
name|MaxNumberLines
operator|=
literal|43
expr_stmt|;
name|MaxNumberColumns
operator|=
literal|80
expr_stmt|;
name|sb_terminal
index|[
name|SBTERMMODEL
index|]
operator|=
literal|'4'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MaxNumberLines
operator|>=
literal|32
condition|)
block|{
name|MaxNumberLines
operator|=
literal|32
expr_stmt|;
name|MaxNumberColumns
operator|=
literal|80
expr_stmt|;
name|sb_terminal
index|[
name|SBTERMMODEL
index|]
operator|=
literal|'3'
expr_stmt|;
block|}
else|else
block|{
name|MaxNumberLines
operator|=
literal|24
expr_stmt|;
name|MaxNumberColumns
operator|=
literal|80
expr_stmt|;
name|sb_terminal
index|[
name|SBTERMMODEL
index|]
operator|=
literal|'2'
expr_stmt|;
block|}
name|NumberLines
operator|=
literal|24
expr_stmt|;
comment|/* before we start out... */
name|NumberColumns
operator|=
literal|80
expr_stmt|;
name|ScreenSize
operator|=
name|NumberLines
operator|*
name|NumberColumns
expr_stmt|;
if|if
condition|(
operator|(
name|MaxNumberLines
operator|*
name|MaxNumberColumns
operator|)
operator|>
name|MAXSCREENSIZE
condition|)
block|{
name|ExitString
argument_list|(
literal|"Programming error:  MAXSCREENSIZE too small.\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|printsub
argument_list|(
literal|">"
argument_list|,
name|sb_terminal
operator|+
literal|2
argument_list|,
sizeof|sizeof
name|sb_terminal
operator|-
literal|2
argument_list|)
expr_stmt|;
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|sb_terminal
argument_list|,
sizeof|sizeof
name|sb_terminal
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* defined(TN3270) */
name|name
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|)
operator|>
literal|40
operator|)
condition|)
block|{
name|name
operator|=
literal|"UNKNOWN"
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|len
operator|+
literal|4
operator|+
literal|2
operator|)
operator|<
name|NETROOM
argument_list|()
condition|)
block|{
name|strcpy
argument_list|(
name|namebuf
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|upcase
argument_list|(
name|namebuf
argument_list|)
expr_stmt|;
name|netoprint
argument_list|(
literal|"%c%c%c%c%s%c%c"
argument_list|,
name|IAC
argument_list|,
name|SB
argument_list|,
name|TELOPT_TTYPE
argument_list|,
name|TELQUAL_IS
argument_list|,
name|namebuf
argument_list|,
name|IAC
argument_list|,
name|SE
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* printsub(">", nfrontp+2, 4+strlen(namebuf)+2-2-2); */
block|}
else|else
block|{
name|ExitString
argument_list|(
literal|"No room in buffer for terminal type.\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
end_if

begin_function
specifier|static
name|void
name|SetIn3270
parameter_list|()
block|{
if|if
condition|(
name|Sent3270TerminalType
operator|&&
name|myopts
index|[
name|TELOPT_BINARY
index|]
operator|&&
name|hisopts
index|[
name|TELOPT_BINARY
index|]
operator|&&
operator|!
name|donebinarytoggle
condition|)
block|{
if|if
condition|(
operator|!
name|In3270
condition|)
block|{
name|In3270
operator|=
literal|1
expr_stmt|;
name|Init3270
argument_list|()
expr_stmt|;
comment|/* Initialize 3270 functions */
comment|/* initialize terminal key mapping */
name|InitTerminal
argument_list|()
expr_stmt|;
comment|/* Start terminal going */
name|setconnmode
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|In3270
condition|)
block|{
name|StopScreen
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|In3270
operator|=
literal|0
expr_stmt|;
name|Stop3270
argument_list|()
expr_stmt|;
comment|/* Tell 3270 we aren't here anymore */
name|setconnmode
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(TN3270) */
end_comment

begin_escape
end_escape

begin_function
specifier|static
name|int
name|telrcv
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|scc
decl_stmt|;
specifier|register
name|char
modifier|*
name|sbp
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|returnValue
init|=
literal|0
decl_stmt|;
name|scc
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TTYROOM
argument_list|()
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|scc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|count
condition|)
block|{
name|ring_consumed
argument_list|(
operator|&
name|netiring
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|returnValue
operator|=
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|sbp
operator|=
name|netiring
operator|.
name|consume
expr_stmt|;
name|scc
operator|=
name|ring_full_consecutive
argument_list|(
operator|&
name|netiring
argument_list|)
expr_stmt|;
if|if
condition|(
name|scc
operator|==
literal|0
condition|)
block|{
comment|/* No more data coming in */
break|break;
block|}
block|}
name|c
operator|=
operator|*
name|sbp
operator|++
operator|&
literal|0xff
operator|,
name|scc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
switch|switch
condition|(
name|telrcv_state
condition|)
block|{
case|case
name|TS_CR
case|:
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
break|break;
comment|/* Ignore \0 after CR */
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|hisopts
index|[
name|TELOPT_ECHO
index|]
operator|&&
operator|!
name|crmod
condition|)
block|{
name|TTYADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Else, fall through */
case|case
name|TS_DATA
case|:
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|telrcv_state
operator|=
name|TS_IAC
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
if|if
condition|(
name|In3270
condition|)
block|{
operator|*
name|Ifrontp
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|scc
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|sbp
operator|++
operator|&
literal|0377
operator|,
name|scc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|telrcv_state
operator|=
name|TS_IAC
expr_stmt|;
break|break;
block|}
operator|*
name|Ifrontp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
comment|/* defined(TN3270) */
comment|/* 		     * The 'crmod' hack (see following) is needed 		     * since we can't * set CRMOD on output only. 		     * Machines like MULTICS like to send \r without 		     * \n; since we must turn off CRMOD to get proper 		     * input, the mapping is done here (sigh). 		     */
if|if
condition|(
operator|(
name|c
operator|==
literal|'\r'
operator|)
operator|&&
operator|!
name|hisopts
index|[
name|TELOPT_BINARY
index|]
condition|)
block|{
if|if
condition|(
name|scc
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|sbp
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|sbp
operator|++
operator|,
name|scc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
comment|/* a "true" CR */
name|TTYADD
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|hisopts
index|[
name|TELOPT_ECHO
index|]
operator|&&
operator|(
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|sbp
operator|++
operator|,
name|scc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|TTYADD
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TTYADD
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|crmod
condition|)
block|{
name|TTYADD
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|telrcv_state
operator|=
name|TS_CR
expr_stmt|;
name|TTYADD
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|crmod
condition|)
block|{
name|TTYADD
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|TTYADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|TS_IAC
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|WILL
case|:
name|telrcv_state
operator|=
name|TS_WILL
expr_stmt|;
continue|continue;
case|case
name|WONT
case|:
name|telrcv_state
operator|=
name|TS_WONT
expr_stmt|;
continue|continue;
case|case
name|DO
case|:
name|telrcv_state
operator|=
name|TS_DO
expr_stmt|;
continue|continue;
case|case
name|DONT
case|:
name|telrcv_state
operator|=
name|TS_DONT
expr_stmt|;
continue|continue;
case|case
name|DM
case|:
comment|/* 		     * We may have missed an urgent notification, 		     * so make sure we flush whatever is in the 		     * buffer currently. 		     */
name|SYNCHing
operator|=
literal|1
expr_stmt|;
name|ttyflush
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SYNCHing
operator|=
name|stilloob
argument_list|(
name|net
argument_list|)
expr_stmt|;
name|settimer
argument_list|(
name|gotDM
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOP
case|:
case|case
name|GA
case|:
break|break;
case|case
name|SB
case|:
name|SB_CLEAR
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_SB
expr_stmt|;
continue|continue;
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
case|case
name|EOR
case|:
if|if
condition|(
name|In3270
condition|)
block|{
name|Ibackp
operator|+=
name|DataFromNetwork
argument_list|(
name|Ibackp
argument_list|,
name|Ifrontp
operator|-
name|Ibackp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ibackp
operator|==
name|Ifrontp
condition|)
block|{
name|Ibackp
operator|=
name|Ifrontp
operator|=
name|Ibuf
expr_stmt|;
name|ISend
operator|=
literal|0
expr_stmt|;
comment|/* should have been! */
block|}
else|else
block|{
name|ISend
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
comment|/* defined(TN3270) */
case|case
name|IAC
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TN3270
argument_list|)
name|TTYADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !defined(TN3270) */
if|if
condition|(
name|In3270
condition|)
block|{
operator|*
name|Ifrontp
operator|++
operator|=
name|IAC
expr_stmt|;
block|}
else|else
block|{
name|TTYADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !defined(TN3270) */
break|break;
default|default:
break|break;
block|}
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_WILL
case|:
name|printoption
argument_list|(
literal|">RCVD"
argument_list|,
name|will
argument_list|,
name|c
argument_list|,
operator|!
name|hisopts
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|TELOPT_TM
condition|)
block|{
if|if
condition|(
name|flushout
condition|)
block|{
name|flushout
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|hisopts
index|[
name|c
index|]
condition|)
block|{
name|willoption
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_WONT
case|:
name|printoption
argument_list|(
literal|">RCVD"
argument_list|,
name|wont
argument_list|,
name|c
argument_list|,
name|hisopts
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|TELOPT_TM
condition|)
block|{
if|if
condition|(
name|flushout
condition|)
block|{
name|flushout
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|hisopts
index|[
name|c
index|]
condition|)
block|{
name|wontoption
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_DO
case|:
name|printoption
argument_list|(
literal|">RCVD"
argument_list|,
name|doopt
argument_list|,
name|c
argument_list|,
operator|!
name|myopts
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|myopts
index|[
name|c
index|]
condition|)
name|dooption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_DONT
case|:
name|printoption
argument_list|(
literal|">RCVD"
argument_list|,
name|dont
argument_list|,
name|c
argument_list|,
name|myopts
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|myopts
index|[
name|c
index|]
condition|)
block|{
name|myopts
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
name|netoprint
argument_list|(
name|wont
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
name|setconnmode
argument_list|()
expr_stmt|;
comment|/* set new tty mode (maybe) */
name|printoption
argument_list|(
literal|">SENT"
argument_list|,
name|wont
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_SB
case|:
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|telrcv_state
operator|=
name|TS_SE
expr_stmt|;
block|}
else|else
block|{
name|SB_ACCUM
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|TS_SE
case|:
if|if
condition|(
name|c
operator|!=
name|SE
condition|)
block|{
if|if
condition|(
name|c
operator|!=
name|IAC
condition|)
block|{
name|SB_ACCUM
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
block|}
name|SB_ACCUM
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|telrcv_state
operator|=
name|TS_SB
expr_stmt|;
block|}
else|else
block|{
name|SB_TERM
argument_list|()
expr_stmt|;
name|suboption
argument_list|()
expr_stmt|;
comment|/* handle sub-option */
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
block|}
block|}
block|}
name|ring_consumed
argument_list|(
operator|&
name|netiring
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|returnValue
operator|||
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|telsnd
parameter_list|(
name|ring
parameter_list|)
name|Ring
modifier|*
name|ring
decl_stmt|;
comment|/* Input ring */
block|{
name|int
name|tcc
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|returnValue
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tbp
decl_stmt|;
name|tcc
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|NETROOM
argument_list|()
operator|>
literal|2
condition|)
block|{
specifier|register
name|int
name|sc
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|tcc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|count
condition|)
block|{
name|ring_consumed
argument_list|(
operator|&
name|ttyiring
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|returnValue
operator|=
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|tbp
operator|=
name|ttyiring
operator|.
name|consume
expr_stmt|;
name|tcc
operator|=
name|ring_full_consecutive
argument_list|(
operator|&
name|ttyiring
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcc
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|c
operator|=
operator|*
name|tbp
operator|++
operator|&
literal|0xff
operator|,
name|sc
operator|=
name|strip
argument_list|(
name|c
argument_list|)
operator|,
name|tcc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|escape
condition|)
block|{
name|command
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tcc
operator|=
literal|0
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|MODE_LINE
argument_list|(
name|globalmode
argument_list|)
operator|&&
operator|(
name|sc
operator|==
name|echoc
operator|)
condition|)
block|{
if|if
condition|(
name|tcc
operator|>
literal|0
operator|&&
name|strip
argument_list|(
operator|*
name|tbp
argument_list|)
operator|==
name|echoc
condition|)
block|{
name|tcc
operator|--
expr_stmt|;
name|tbp
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|dontlecho
operator|=
operator|!
name|dontlecho
expr_stmt|;
name|settimer
argument_list|(
name|echotoggle
argument_list|)
expr_stmt|;
name|setconnmode
argument_list|()
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|localchars
condition|)
block|{
if|if
condition|(
name|TerminalSpecialChars
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|myopts
index|[
name|TELOPT_BINARY
index|]
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* 		     * If we are in CRMOD mode (\r ==> \n) 		     * on our local machine, then probably 		     * a newline (unix) is CRLF (TELNET). 		     */
if|if
condition|(
name|MODE_LOCAL_CHARS
argument_list|(
name|globalmode
argument_list|)
condition|)
block|{
name|NETADD
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
name|NETADD
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
if|if
condition|(
operator|!
name|crlf
condition|)
block|{
name|NET2ADD
argument_list|(
literal|'\r'
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NET2ADD
argument_list|(
literal|'\r'
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|flushline
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IAC
case|:
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|IAC
argument_list|)
expr_stmt|;
break|break;
default|default:
name|NETADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|IAC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NETADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|ring_consumed
argument_list|(
operator|&
name|ttyiring
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|returnValue
operator|||
name|count
return|;
comment|/* Non-zero if we did anything */
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
end_if

begin_function
specifier|static
name|void
name|SetForExit
parameter_list|()
block|{
name|setconnmode
argument_list|()
expr_stmt|;
if|if
condition|(
name|In3270
condition|)
block|{
name|Finish3270
argument_list|()
expr_stmt|;
block|}
name|setcommandmode
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|In3270
condition|)
block|{
name|StopScreen
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|setconnmode
argument_list|()
expr_stmt|;
name|setcommandmode
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Exit
parameter_list|(
name|returnCode
parameter_list|)
name|int
name|returnCode
decl_stmt|;
block|{
name|SetForExit
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|returnCode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ExitString
parameter_list|(
name|string
parameter_list|,
name|returnCode
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|returnCode
decl_stmt|;
block|{
name|SetForExit
argument_list|()
expr_stmt|;
name|fwrite
argument_list|(
name|string
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|returnCode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ExitPerror
parameter_list|(
name|string
parameter_list|,
name|returnCode
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|returnCode
decl_stmt|;
block|{
name|SetForExit
argument_list|()
expr_stmt|;
name|perror
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|returnCode
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(TN3270) */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * Scheduler()  *  * Try to do something.  *  * If we do something useful, return 1; else return 0.  *  */
end_comment

begin_function
name|int
name|Scheduler
parameter_list|(
name|block
parameter_list|)
name|int
name|block
decl_stmt|;
comment|/* should we block in the select ? */
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* One wants to be a bit careful about setting returnValue 		 * to one, since a one implies we did some useful work, 		 * and therefore probably won't be called to block next 		 * time (TN3270 mode only). 		 */
name|int
name|returnValue
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|timeval
name|TimeValue
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|MODE_LINE
argument_list|(
name|globalmode
argument_list|)
operator|||
name|flushline
operator|)
operator|&&
name|NETBYTES
argument_list|()
condition|)
block|{
name|FD_SET
argument_list|(
name|net
argument_list|,
operator|&
name|obits
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
if|if
condition|(
name|TTYBYTES
argument_list|()
condition|)
block|{
name|FD_SET
argument_list|(
name|tout
argument_list|,
operator|&
name|obits
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
if|if
condition|(
operator|(
name|tcc
operator|==
literal|0
operator|)
operator|&&
name|NETROOM
argument_list|()
operator|&&
operator|(
name|shell_active
operator|==
literal|0
operator|)
condition|)
block|{
name|FD_SET
argument_list|(
name|tin
argument_list|,
operator|&
name|ibits
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* defined(TN3270) */
if|if
condition|(
name|ring_empty_count
argument_list|(
operator|&
name|netiring
argument_list|)
operator|&&
name|NETROOM
argument_list|()
condition|)
block|{
name|FD_SET
argument_list|(
name|tin
argument_list|,
operator|&
name|ibits
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(TN3270) */
endif|#
directive|endif
comment|/* !defined(MSDOS) */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TN3270
argument_list|)
if|if
condition|(
name|TTYROOM
argument_list|()
condition|)
block|{
name|FD_SET
argument_list|(
name|net
argument_list|,
operator|&
name|ibits
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !defined(TN3270) */
if|if
condition|(
operator|!
name|ISend
operator|&&
name|TTYROOM
argument_list|()
condition|)
block|{
name|FD_SET
argument_list|(
name|net
argument_list|,
operator|&
name|ibits
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !defined(TN3270) */
if|if
condition|(
operator|!
name|SYNCHing
condition|)
block|{
name|FD_SET
argument_list|(
name|net
argument_list|,
operator|&
name|xbits
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
operator|&&
name|defined
argument_list|(
name|unix
argument_list|)
if|if
condition|(
name|HaveInput
condition|)
block|{
name|HaveInput
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|inputAvailable
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(TN3270)&& defined(unix) */
if|if
condition|(
operator|(
name|c
operator|=
name|select
argument_list|(
literal|16
argument_list|,
operator|&
name|ibits
argument_list|,
operator|&
name|obits
argument_list|,
operator|&
name|xbits
argument_list|,
name|block
condition|?
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
else|:
operator|&
name|TimeValue
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		     * we can get EINTR if we are in line mode, 		     * and the user does an escape (TSTP), or 		     * some other signal generator. 		     */
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
return|return
literal|0
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
comment|/* 		     * we can get EBADF if we were in transparent 		     * mode, and the transcom process died. 		    */
if|if
condition|(
name|errno
operator|==
name|EBADF
condition|)
block|{
comment|/* 			 * zero the bits (even though kernel does it) 			 * to make sure we are selecting on the right 			 * ones. 			*/
name|FD_ZERO
argument_list|(
operator|&
name|ibits
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|obits
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|xbits
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* defined(TN3270) */
comment|/* I don't like this, does it ever happen? */
name|printf
argument_list|(
literal|"sleep(5) from telnet, after select\r\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|unix
argument_list|)
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(unix) */
block|}
return|return
literal|0
return|;
block|}
comment|/*      * Any urgent data?      */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|net
argument_list|,
operator|&
name|xbits
argument_list|)
condition|)
block|{
name|FD_CLR
argument_list|(
name|net
argument_list|,
operator|&
name|xbits
argument_list|)
expr_stmt|;
name|SYNCHing
operator|=
literal|1
expr_stmt|;
name|ttyflush
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* flush already enqueued data */
block|}
comment|/*      * Something to read from the network...      */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|net
argument_list|,
operator|&
name|ibits
argument_list|)
condition|)
block|{
name|int
name|canread
decl_stmt|;
name|FD_CLR
argument_list|(
name|net
argument_list|,
operator|&
name|ibits
argument_list|)
expr_stmt|;
name|canread
operator|=
name|ring_empty_consecutive
argument_list|(
operator|&
name|netiring
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SO_OOBINLINE
argument_list|)
comment|/* 	     * In 4.2 (and some early 4.3) systems, the 	     * OOB indication and data handling in the kernel 	     * is such that if two separate TCP Urgent requests 	     * come in, one byte of TCP data will be overlaid. 	     * This is fatal for Telnet, but we try to live 	     * with it. 	     * 	     * In addition, in 4.2 (and...), a special protocol 	     * is needed to pick up the TCP Urgent data in 	     * the correct sequence. 	     * 	     * What we do is:  if we think we are in urgent 	     * mode, we look to see if we are "at the mark". 	     * If we are, we do an OOB receive.  If we run 	     * this twice, we will do the OOB receive twice, 	     * but the second will fail, since the second 	     * time we were "at the mark", but there wasn't 	     * any data there (the kernel doesn't reset 	     * "at the mark" until we do a normal read). 	     * Once we've read the OOB data, we go ahead 	     * and do normal reads. 	     * 	     * There is also another problem, which is that 	     * since the OOB byte we read doesn't put us 	     * out of OOB state, and since that byte is most 	     * likely the TELNET DM (data mark), we would 	     * stay in the TELNET SYNCH (SYNCHing) state. 	     * So, clocks to the rescue.  If we've "just" 	     * received a DM, then we test for the 	     * presence of OOB data when the receive OOB 	     * fails (and AFTER we did the normal mode read 	     * to clear "at the mark"). 	     */
if|if
condition|(
name|SYNCHing
condition|)
block|{
name|int
name|atmark
decl_stmt|;
name|ioctl
argument_list|(
name|net
argument_list|,
name|SIOCATMARK
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|atmark
argument_list|)
expr_stmt|;
if|if
condition|(
name|atmark
condition|)
block|{
name|c
operator|=
name|recv
argument_list|(
name|net
argument_list|,
name|sbp
operator|+
name|scc
argument_list|,
name|canread
argument_list|,
name|MSG_OOB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EINVAL
operator|)
condition|)
block|{
name|c
operator|=
name|recv
argument_list|(
name|net
argument_list|,
name|sbp
operator|+
name|scc
argument_list|,
name|canread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|clocks
operator|.
name|didnetreceive
operator|<
name|clocks
operator|.
name|gotDM
condition|)
block|{
name|SYNCHing
operator|=
name|stilloob
argument_list|(
name|net
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|c
operator|=
name|recv
argument_list|(
name|net
argument_list|,
name|sbp
operator|+
name|scc
argument_list|,
name|canread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|c
operator|=
name|recv
argument_list|(
name|net
argument_list|,
name|sbp
operator|+
name|scc
argument_list|,
name|canread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|settimer
argument_list|(
name|didnetreceive
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !defined(SO_OOBINLINE) */
name|c
operator|=
name|recv
argument_list|(
name|net
argument_list|,
name|netiring
operator|.
name|supply
argument_list|,
name|canread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(SO_OOBINLINE) */
if|if
condition|(
name|c
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|netdata
condition|)
block|{
name|Dump
argument_list|(
literal|'<'
argument_list|,
name|netiring
operator|.
name|supply
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|ring_supplied
argument_list|(
operator|&
name|netiring
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|returnValue
operator|=
literal|1
expr_stmt|;
block|}
comment|/*      * Something to read from the tty...      */
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
if|if
condition|(
operator|(
name|tcc
operator|==
literal|0
operator|)
operator|&&
name|NETROOM
argument_list|()
operator|&&
operator|(
name|shell_active
operator|==
literal|0
operator|)
operator|&&
name|TerminalCanRead
argument_list|()
condition|)
else|#
directive|else
comment|/* defined(MSDOS) */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|tin
argument_list|,
operator|&
name|ibits
argument_list|)
condition|)
endif|#
directive|endif
comment|/* defined(MSDOS) */
block|{
name|FD_CLR
argument_list|(
name|tin
argument_list|,
operator|&
name|ibits
argument_list|)
expr_stmt|;
name|c
operator|=
name|TerminalRead
argument_list|(
name|tin
argument_list|,
name|ttyiring
operator|.
name|supply
argument_list|,
name|ring_empty_consecutive
argument_list|(
operator|&
name|ttyiring
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|unix
argument_list|)
comment|/* EOF detection for line mode!!!! */
if|if
condition|(
name|c
operator|==
literal|0
operator|&&
name|MODE_LOCAL_CHARS
argument_list|(
name|globalmode
argument_list|)
condition|)
block|{
comment|/* must be an EOF... */
operator|*
name|ttyiring
operator|.
name|supply
operator|=
name|termEofChar
expr_stmt|;
name|c
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(unix) */
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
name|ring_supplied
argument_list|(
operator|&
name|ttyiring
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|returnValue
operator|=
literal|1
expr_stmt|;
comment|/* did something useful */
block|}
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
if|if
condition|(
name|ring_full_count
argument_list|(
operator|&
name|ttyiring
argument_list|)
condition|)
block|{
if|if
condition|(
name|In3270
condition|)
block|{
name|c
operator|=
name|DataFromTerminal
argument_list|(
name|ttyiring
operator|.
name|send
argument_list|,
name|ring_full_consecutive
argument_list|(
operator|&
name|ttyiring
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
name|returnValue
operator|=
literal|1
expr_stmt|;
block|}
name|ring_consumed
argument_list|(
operator|&
name|ttyiring
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* defined(TN3270) */
name|returnValue
operator||=
name|telsnd
argument_list|(
operator|&
name|ttyiring
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
block|}
block|}
endif|#
directive|endif
comment|/* defined(TN3270) */
if|if
condition|(
operator|(
operator|!
name|MODE_LINE
argument_list|(
name|globalmode
argument_list|)
operator|||
name|flushline
operator|||
name|myopts
index|[
name|TELOPT_BINARY
index|]
operator|)
operator|&&
name|FD_ISSET
argument_list|(
name|net
argument_list|,
operator|&
name|obits
argument_list|)
operator|&&
operator|(
name|NETBYTES
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
name|FD_CLR
argument_list|(
name|net
argument_list|,
operator|&
name|obits
argument_list|)
expr_stmt|;
name|returnValue
operator|=
name|netflush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ring_full_count
argument_list|(
operator|&
name|netiring
argument_list|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TN3270
argument_list|)
name|returnValue
operator||=
name|telrcv
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* !defined(TN3270) */
name|returnValue
operator|=
name|Push3270
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(TN3270) */
block|}
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
if|if
condition|(
name|TTYBYTES
argument_list|()
condition|)
else|#
directive|else
comment|/* defined(MSDOS) */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|tout
argument_list|,
operator|&
name|obits
argument_list|)
operator|&&
operator|(
name|TTYBYTES
argument_list|()
operator|>
literal|0
operator|)
condition|)
endif|#
directive|endif
comment|/* defined(MSDOS) */
block|{
name|FD_CLR
argument_list|(
name|tout
argument_list|,
operator|&
name|obits
argument_list|)
expr_stmt|;
name|returnValue
operator|=
name|ttyflush
argument_list|(
name|SYNCHing
operator||
name|flushout
argument_list|)
expr_stmt|;
block|}
return|return
name|returnValue
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Select from tty and network...  */
end_comment

begin_function
name|void
name|telnet
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
define|#
directive|define
name|SCHED_BLOCK
value|0
comment|/* Don't block in MSDOS */
else|#
directive|else
comment|/* defined(MSDOS) */
define|#
directive|define
name|SCHED_BLOCK
value|1
endif|#
directive|endif
comment|/* defined(MSDOS) */
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
operator|&&
name|defined
argument_list|(
name|unix
argument_list|)
name|int
name|myPid
decl_stmt|;
endif|#
directive|endif
comment|/* defined(TN3270) */
name|tout
operator|=
name|fileno
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|tin
operator|=
name|fileno
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|setconnmode
argument_list|()
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ibits
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|obits
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|xbits
argument_list|)
expr_stmt|;
name|NetNonblockingIO
argument_list|(
name|net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
if|if
condition|(
name|noasynch
operator|==
literal|0
condition|)
block|{
comment|/* DBX can't handle! */
name|NetSigIO
argument_list|(
name|net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|NetSetPgrp
argument_list|(
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(TN3270) */
if|#
directive|if
name|defined
argument_list|(
name|SO_OOBINLINE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
name|SetSockOpt
argument_list|(
name|net
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_OOBINLINE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(SO_OOBINLINE)&& !defined(MSDOS) */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TN3270
argument_list|)
if|if
condition|(
name|telnetport
condition|)
block|{
if|if
condition|(
operator|!
name|hisopts
index|[
name|TELOPT_SGA
index|]
condition|)
block|{
name|willoption
argument_list|(
name|TELOPT_SGA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|myopts
index|[
name|TELOPT_TTYPE
index|]
condition|)
block|{
name|dooption
argument_list|(
name|TELOPT_TTYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* !defined(TN3270) */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TN3270
argument_list|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|schedValue
decl_stmt|;
while|while
condition|(
operator|(
name|schedValue
operator|=
name|Scheduler
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|schedValue
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|Scheduler
argument_list|(
name|SCHED_BLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|#
directive|else
comment|/* !defined(TN3270) */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|schedValue
decl_stmt|;
while|while
condition|(
operator|!
name|In3270
operator|&&
operator|!
name|shell_active
condition|)
block|{
if|if
condition|(
name|Scheduler
argument_list|(
name|SCHED_BLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
while|while
condition|(
operator|(
name|schedValue
operator|=
name|Scheduler
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|schedValue
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/* If there is data waiting to go out to terminal, don't 		 * schedule any more data for the terminal. 		 */
if|if
condition|(
name|tfrontp
operator|-
name|tbackp
condition|)
block|{
name|schedValue
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|shell_active
condition|)
block|{
if|if
condition|(
name|shell_continue
argument_list|()
operator|==
literal|0
condition|)
block|{
name|ConnectScreen
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|In3270
condition|)
block|{
name|schedValue
operator|=
name|DoTerminalOutput
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|schedValue
operator|&&
operator|(
name|shell_active
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|Scheduler
argument_list|(
name|SCHED_BLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* !defined(TN3270) */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * These routines add various telnet commands to the data stream.  */
end_comment

begin_function
name|void
name|xmitAO
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|AO
argument_list|)
expr_stmt|;
if|if
condition|(
name|autoflush
condition|)
block|{
name|doflush
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xmitEL
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|EL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xmitEC
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|EC
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NOT43
argument_list|)
end_if

begin_function
name|int
else|#
directive|else
comment|/* defined(NOT43) */
name|void
endif|#
directive|endif
comment|/* defined(NOT43) */
name|dosynch
parameter_list|()
block|{
name|netclear
argument_list|()
expr_stmt|;
comment|/* clear the path to the network */
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|DM
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NOT43
argument_list|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* defined(NOT43) */
block|}
end_function

begin_function
name|void
name|doflush
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|DO
argument_list|)
expr_stmt|;
name|NETADD
argument_list|(
name|TELOPT_TM
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
name|flushout
operator|=
literal|1
expr_stmt|;
name|ttyflush
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Flush/drop output */
comment|/* do printoption AFTER flush, otherwise the output gets tossed... */
name|printoption
argument_list|(
literal|"<SENT"
argument_list|,
name|doopt
argument_list|,
name|TELOPT_TM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|intp
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|IP
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|autoflush
condition|)
block|{
name|doflush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|autosynch
condition|)
block|{
name|dosynch
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sendbrk
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|BREAK
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|autoflush
condition|)
block|{
name|doflush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|autosynch
condition|)
block|{
name|dosynch
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

