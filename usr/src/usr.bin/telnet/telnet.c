begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)telnet.c	5.50 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERBEROS
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<kerberosIV/des.h>
end_include

begin_include
include|#
directive|include
file|<kerberosIV/krb.h>
end_include

begin_include
include|#
directive|include
file|"krb4-proto.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|unix
argument_list|)
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/* By the way, we need to include curses.h before telnet.h since,  * among other things, telnet.h #defines 'DO', which is a variable  * declared in curses.h.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(unix) */
end_comment

begin_include
include|#
directive|include
file|<arpa/telnet.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|unix
argument_list|)
end_if

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined(unix) */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(unix) */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"ring.h"
end_include

begin_include
include|#
directive|include
file|"defines.h"
end_include

begin_include
include|#
directive|include
file|"externs.h"
end_include

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_escape
end_escape

begin_define
define|#
directive|define
name|strip
parameter_list|(
name|x
parameter_list|)
value|((x)&0x7f)
end_define

begin_function_decl
specifier|extern
name|char
modifier|*
name|env_getvalue
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
name|subbuffer
index|[
name|SUBBUFSIZE
index|]
decl_stmt|,
modifier|*
name|subpointer
decl_stmt|,
modifier|*
name|subend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for sub-options */
end_comment

begin_define
define|#
directive|define
name|SB_CLEAR
parameter_list|()
value|subpointer = subbuffer;
end_define

begin_define
define|#
directive|define
name|SB_TERM
parameter_list|()
value|subend = subpointer;
end_define

begin_define
define|#
directive|define
name|SB_ACCUM
parameter_list|(
name|c
parameter_list|)
value|if (subpointer< (subbuffer+sizeof subbuffer)) { \ 				*subpointer++ = (c); \ 			}
end_define

begin_decl_stmt
name|char
name|options
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The combined options */
end_comment

begin_decl_stmt
name|char
name|do_dont_resp
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|will_wont_resp
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|connected
decl_stmt|,
name|showoptions
decl_stmt|,
name|In3270
decl_stmt|,
comment|/* Are we in 3270 mode? */
name|ISend
decl_stmt|,
comment|/* trying to send network data in */
ifdef|#
directive|ifdef
name|KERBEROS
name|kerberized
init|=
literal|0
decl_stmt|,
comment|/* Are we using Kerberos authentication ? */
endif|#
directive|endif
name|debug
init|=
literal|0
decl_stmt|,
name|crmod
decl_stmt|,
name|netdata
decl_stmt|,
comment|/* Print out network data flow */
name|crlf
decl_stmt|,
comment|/* Should '\r' be mapped to<CR><LF> (or<CR><NUL>)? */
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
name|noasynchtty
init|=
literal|0
decl_stmt|,
comment|/* User specified "-noasynch" on command line */
name|noasynchnet
init|=
literal|0
decl_stmt|,
comment|/* User specified "-noasynch" on command line */
name|askedSGA
init|=
literal|0
decl_stmt|,
comment|/* We have talked about suppress go ahead */
endif|#
directive|endif
comment|/* defined(TN3270) */
name|telnetport
decl_stmt|,
name|SYNCHing
decl_stmt|,
comment|/* we are in TELNET SYNCH mode */
name|flushout
decl_stmt|,
comment|/* flush output */
name|autoflush
init|=
literal|0
decl_stmt|,
comment|/* flush output when interrupting? */
name|autosynch
decl_stmt|,
comment|/* send interrupt characters with SYNCH? */
name|localflow
decl_stmt|,
comment|/* we handle flow control locally */
name|localchars
decl_stmt|,
comment|/* we recognize interrupt/quit */
name|donelclchars
decl_stmt|,
comment|/* the user has set "localchars" */
name|donebinarytoggle
decl_stmt|,
comment|/* the user has put us in binary */
name|dontlecho
decl_stmt|,
comment|/* do we suppress local echoing right now? */
name|globalmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|prompt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cc_t
name|escape
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
end_ifdef

begin_decl_stmt
name|cc_t
name|echoc
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Telnet receiver states for fsm  */
end_comment

begin_define
define|#
directive|define
name|TS_DATA
value|0
end_define

begin_define
define|#
directive|define
name|TS_IAC
value|1
end_define

begin_define
define|#
directive|define
name|TS_WILL
value|2
end_define

begin_define
define|#
directive|define
name|TS_WONT
value|3
end_define

begin_define
define|#
directive|define
name|TS_DO
value|4
end_define

begin_define
define|#
directive|define
name|TS_DONT
value|5
end_define

begin_define
define|#
directive|define
name|TS_CR
value|6
end_define

begin_define
define|#
directive|define
name|TS_SB
value|7
end_define

begin_comment
comment|/* sub-option collection */
end_comment

begin_define
define|#
directive|define
name|TS_SE
value|8
end_define

begin_comment
comment|/* looking for sub-option end */
end_comment

begin_decl_stmt
specifier|static
name|int
name|telrcv_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|toplevel
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|peerdied
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flushline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linemode
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
end_ifdef

begin_decl_stmt
name|int
name|kludgelinemode
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The following are some clocks used to decide how to interpret  * the relationship between various variables.  */
end_comment

begin_decl_stmt
name|Clocks
name|clocks
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_decl_stmt
name|Modelist
name|modelist
index|[]
init|=
block|{
block|{
literal|"telnet command mode"
block|,
name|COMMAND_LINE
block|}
block|,
block|{
literal|"character-at-a-time mode"
block|,
literal|0
block|}
block|,
block|{
literal|"character-at-a-time mode (local echo)"
block|,
name|LOCAL_ECHO
operator||
name|LOCAL_CHARS
block|}
block|,
block|{
literal|"line-by-line mode (remote echo)"
block|,
name|LINE
operator||
name|LOCAL_CHARS
block|}
block|,
block|{
literal|"line-by-line mode"
block|,
name|LINE
operator||
name|LOCAL_ECHO
operator||
name|LOCAL_CHARS
block|}
block|,
block|{
literal|"line-by-line mode (local echoing suppressed)"
block|,
name|LINE
operator||
name|LOCAL_CHARS
block|}
block|,
block|{
literal|"3270 mode"
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  * Initialize telnet environment.  */
end_comment

begin_macro
name|init_telnet
argument_list|()
end_macro

begin_block
block|{
name|env_init
argument_list|()
expr_stmt|;
name|SB_CLEAR
argument_list|()
expr_stmt|;
name|ClearArray
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|connected
operator|=
name|In3270
operator|=
name|ISend
operator|=
name|localflow
operator|=
name|donebinarytoggle
operator|=
literal|0
expr_stmt|;
name|SYNCHing
operator|=
literal|0
expr_stmt|;
comment|/* Don't change NetTrace */
name|escape
operator|=
name|CONTROL
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
name|echoc
operator|=
name|CONTROL
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flushline
operator|=
literal|1
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
specifier|static
name|void
name|printring
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
comment|/* where things go */
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|Ring
modifier|*
name|ring
decl_stmt|;
name|int
name|i
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ring
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|Ring
operator|*
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
operator|*
name|format
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|'%'
condition|)
block|{
name|i
operator|=
operator|*
name|format
operator|++
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'c'
case|:
operator|*
name|ptr
operator|++
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|string
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|ring_supply_data
argument_list|(
name|ring
argument_list|,
name|buffer
argument_list|,
name|ptr
operator|-
name|buffer
argument_list|)
expr_stmt|;
name|ring_supply_data
argument_list|(
name|ring
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|buffer
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|ExitString
argument_list|(
literal|"printring: trailing %%.\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
default|default:
name|ExitString
argument_list|(
literal|"printring: unknown format character.\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
else|else
block|{
operator|*
name|ptr
operator|++
operator|=
name|i
expr_stmt|;
block|}
block|}
name|ring_supply_data
argument_list|(
name|ring
argument_list|,
name|buffer
argument_list|,
name|ptr
operator|-
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * These routines are in charge of sending option negotiations  * to the other side.  *  * The basic idea is that we send the negotiation if either side  * is in disagreement as to what the current state should be.  */
end_comment

begin_expr_stmt
name|send_do
argument_list|(
name|c
argument_list|,
name|init
argument_list|)
specifier|register
name|int
name|c
operator|,
name|init
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|do_dont_resp
index|[
name|c
index|]
operator|==
literal|0
operator|)
operator|&&
name|my_state_is_do
argument_list|(
name|c
argument_list|)
operator|)
operator|||
name|my_want_state_is_do
argument_list|(
name|c
argument_list|)
condition|)
return|return;
name|set_my_want_state_do
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|do_dont_resp
index|[
name|c
index|]
operator|++
expr_stmt|;
block|}
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|DO
argument_list|)
expr_stmt|;
name|NETADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
literal|"do"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|send_dont
parameter_list|(
name|c
parameter_list|,
name|init
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|,
name|init
decl_stmt|;
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|do_dont_resp
index|[
name|c
index|]
operator|==
literal|0
operator|)
operator|&&
name|my_state_is_dont
argument_list|(
name|c
argument_list|)
operator|)
operator|||
name|my_want_state_is_dont
argument_list|(
name|c
argument_list|)
condition|)
return|return;
name|set_my_want_state_dont
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|do_dont_resp
index|[
name|c
index|]
operator|++
expr_stmt|;
block|}
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|DONT
argument_list|)
expr_stmt|;
name|NETADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
literal|"dont"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|send_will
parameter_list|(
name|c
parameter_list|,
name|init
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|,
name|init
decl_stmt|;
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|will_wont_resp
index|[
name|c
index|]
operator|==
literal|0
operator|)
operator|&&
name|my_state_is_will
argument_list|(
name|c
argument_list|)
operator|)
operator|||
name|my_want_state_is_will
argument_list|(
name|c
argument_list|)
condition|)
return|return;
name|set_my_want_state_will
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|will_wont_resp
index|[
name|c
index|]
operator|++
expr_stmt|;
block|}
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|WILL
argument_list|)
expr_stmt|;
name|NETADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
literal|"will"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|send_wont
parameter_list|(
name|c
parameter_list|,
name|init
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|,
name|init
decl_stmt|;
block|{
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|will_wont_resp
index|[
name|c
index|]
operator|==
literal|0
operator|)
operator|&&
name|my_state_is_wont
argument_list|(
name|c
argument_list|)
operator|)
operator|||
name|my_want_state_is_wont
argument_list|(
name|c
argument_list|)
condition|)
return|return;
name|set_my_want_state_wont
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|will_wont_resp
index|[
name|c
index|]
operator|++
expr_stmt|;
block|}
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|WONT
argument_list|)
expr_stmt|;
name|NETADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
literal|"wont"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|willoption
parameter_list|(
name|option
parameter_list|)
name|int
name|option
decl_stmt|;
block|{
name|int
name|new_state_ok
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
condition|)
block|{
operator|--
name|do_dont_resp
index|[
name|option
index|]
expr_stmt|;
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
operator|&&
name|my_state_is_do
argument_list|(
name|option
argument_list|)
condition|)
operator|--
name|do_dont_resp
index|[
name|option
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|do_dont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|)
operator|&&
name|my_want_state_is_dont
argument_list|(
name|option
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_ECHO
case|:
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
comment|/* 		 * The following is a pain in the rear-end. 		 * Various IBM servers (some versions of Wiscnet, 		 * possibly Fibronics/Spartacus, and who knows who 		 * else) will NOT allow us to send "DO SGA" too early 		 * in the setup proceedings.  On the other hand, 		 * 4.2 servers (telnetd) won't set SGA correctly. 		 * So, we are stuck.  Empirically (but, based on 		 * a VERY small sample), the IBM servers don't send 		 * out anything about ECHO, so we postpone our sending 		 * "DO SGA" until we see "WILL ECHO" (which 4.2 servers 		 * DO send). 		  */
block|{
if|if
condition|(
name|askedSGA
operator|==
literal|0
condition|)
block|{
name|askedSGA
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|my_want_state_is_dont
argument_list|(
name|TELOPT_SGA
argument_list|)
condition|)
name|send_do
argument_list|(
name|TELOPT_SGA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fall through */
case|case
name|TELOPT_EOR
case|:
endif|#
directive|endif
comment|/* defined(TN3270) */
case|case
name|TELOPT_BINARY
case|:
case|case
name|TELOPT_SGA
case|:
name|settimer
argument_list|(
name|modenegotiated
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|TELOPT_STATUS
case|:
name|new_state_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TELOPT_TM
case|:
if|if
condition|(
name|flushout
condition|)
name|flushout
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Special case for TM.  If we get back a WILL, 		 * pretend we got back a WONT. 		 */
name|set_my_want_state_dont
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|set_my_state_dont
argument_list|(
name|option
argument_list|)
expr_stmt|;
return|return;
comment|/* Never reply to TM will's/wont's */
case|case
name|TELOPT_LINEMODE
case|:
default|default:
break|break;
block|}
if|if
condition|(
name|new_state_ok
condition|)
block|{
name|set_my_want_state_do
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|send_do
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setconnmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* possibly set new tty mode */
block|}
else|else
block|{
name|do_dont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
name|send_dont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|set_my_state_do
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wontoption
parameter_list|(
name|option
parameter_list|)
name|int
name|option
decl_stmt|;
block|{
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
condition|)
block|{
operator|--
name|do_dont_resp
index|[
name|option
index|]
expr_stmt|;
if|if
condition|(
name|do_dont_resp
index|[
name|option
index|]
operator|&&
name|my_state_is_dont
argument_list|(
name|option
argument_list|)
condition|)
operator|--
name|do_dont_resp
index|[
name|option
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|do_dont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|)
operator|&&
name|my_want_state_is_do
argument_list|(
name|option
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
case|case
name|TELOPT_SGA
case|:
if|if
condition|(
operator|!
name|kludgelinemode
condition|)
break|break;
comment|/* FALL THROUGH */
endif|#
directive|endif
case|case
name|TELOPT_ECHO
case|:
name|settimer
argument_list|(
name|modenegotiated
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELOPT_TM
case|:
if|if
condition|(
name|flushout
condition|)
name|flushout
operator|=
literal|0
expr_stmt|;
name|set_my_want_state_dont
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|set_my_state_dont
argument_list|(
name|option
argument_list|)
expr_stmt|;
return|return;
comment|/* Never reply to TM will's/wont's */
default|default:
break|break;
block|}
name|set_my_want_state_dont
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_state_is_do
argument_list|(
name|option
argument_list|)
condition|)
name|send_dont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setconnmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Set new tty mode */
block|}
elseif|else
if|if
condition|(
name|option
operator|==
name|TELOPT_TM
condition|)
block|{
comment|/* 	     * Special case for TM. 	     */
if|if
condition|(
name|flushout
condition|)
name|flushout
operator|=
literal|0
expr_stmt|;
name|set_my_want_state_dont
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
name|set_my_state_dont
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dooption
parameter_list|(
name|option
parameter_list|)
name|int
name|option
decl_stmt|;
block|{
name|int
name|new_state_ok
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
condition|)
block|{
operator|--
name|will_wont_resp
index|[
name|option
index|]
expr_stmt|;
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
operator|&&
name|my_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
operator|--
name|will_wont_resp
index|[
name|option
index|]
expr_stmt|;
block|}
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|option
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_TM
case|:
comment|/* 		 * Special case for TM.  We send a WILL, but pretend 		 * we sent WONT. 		 */
name|send_will
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_my_want_state_wont
argument_list|(
name|TELOPT_TM
argument_list|)
expr_stmt|;
name|set_my_state_wont
argument_list|(
name|TELOPT_TM
argument_list|)
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|KERBEROS
case|case
name|TELOPT_AUTHENTICATION
case|:
if|if
condition|(
name|kerberized
condition|)
name|new_state_ok
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
case|case
name|TELOPT_EOR
case|:
comment|/* end of record */
endif|#
directive|endif
comment|/* defined(TN3270) */
case|case
name|TELOPT_BINARY
case|:
comment|/* binary mode */
case|case
name|TELOPT_NAWS
case|:
comment|/* window size */
case|case
name|TELOPT_TSPEED
case|:
comment|/* terminal speed */
case|case
name|TELOPT_LFLOW
case|:
comment|/* local flow control */
case|case
name|TELOPT_TTYPE
case|:
comment|/* terminal type option */
case|case
name|TELOPT_SGA
case|:
comment|/* no big deal */
case|case
name|TELOPT_ENVIRON
case|:
comment|/* environment variable option */
name|new_state_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TELOPT_XDISPLOC
case|:
comment|/* X Display location */
if|if
condition|(
name|env_getvalue
argument_list|(
literal|"DISPLAY"
argument_list|)
condition|)
name|new_state_ok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TELOPT_LINEMODE
case|:
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
name|kludgelinemode
operator|=
literal|0
expr_stmt|;
name|send_do
argument_list|(
name|TELOPT_SGA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_my_want_state_will
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_my_state_will
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
expr_stmt|;
name|slc_init
argument_list|()
expr_stmt|;
return|return;
case|case
name|TELOPT_ECHO
case|:
comment|/* We're never going to echo... */
default|default:
break|break;
block|}
if|if
condition|(
name|new_state_ok
condition|)
block|{
name|set_my_want_state_will
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|will_wont_resp
index|[
name|option
index|]
operator|++
expr_stmt|;
name|send_wont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	     * Handle options that need more things done after the 	     * other side has acknowledged the option. 	     */
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_LINEMODE
case|:
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
name|kludgelinemode
operator|=
literal|0
expr_stmt|;
name|send_do
argument_list|(
name|TELOPT_SGA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_my_state_will
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|slc_init
argument_list|()
expr_stmt|;
name|send_do
argument_list|(
name|TELOPT_SGA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|set_my_state_will
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dontoption
parameter_list|(
name|option
parameter_list|)
name|int
name|option
decl_stmt|;
block|{
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
condition|)
block|{
operator|--
name|will_wont_resp
index|[
name|option
index|]
expr_stmt|;
if|if
condition|(
name|will_wont_resp
index|[
name|option
index|]
operator|&&
name|my_state_is_wont
argument_list|(
name|option
argument_list|)
condition|)
operator|--
name|will_wont_resp
index|[
name|option
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|will_wont_resp
index|[
name|option
index|]
operator|==
literal|0
operator|)
operator|&&
name|my_want_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|TELOPT_LINEMODE
case|:
name|linemode
operator|=
literal|0
expr_stmt|;
comment|/* put us back to the default state */
break|break;
block|}
comment|/* we always accept a DONT */
name|set_my_want_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_state_is_will
argument_list|(
name|option
argument_list|)
condition|)
name|send_wont
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setconnmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Set new tty mode */
block|}
name|set_my_state_wont
argument_list|(
name|option
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a buffer returned by tgetent(), this routine will turn  * the pipe seperated list of names in the buffer into an array  * of pointers to null terminated names.  We toss out any bad,  * duplicate, or verbose names (names with spaces).  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|unknown
index|[]
init|=
block|{
literal|"UNKNOWN"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
modifier|*
name|mklist
parameter_list|(
name|buf
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|,
decl|*
name|name
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|argvp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|,
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|>
literal|40
condition|)
name|name
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|unknown
index|[
literal|0
index|]
operator|=
name|name
expr_stmt|;
name|upcase
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Count up the number of names. 	 */
for|for
control|(
name|n
operator|=
literal|1
operator|,
name|cp
operator|=
name|buf
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|':'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'|'
condition|)
name|n
operator|++
expr_stmt|;
block|}
comment|/* 	 * Allocate an array to put the name pointers into 	 */
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|n
operator|+
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
operator|==
literal|0
condition|)
return|return
operator|(
name|unknown
operator|)
return|;
comment|/* 	 * Fill up the array of pointers to names. 	 */
operator|*
name|argv
operator|=
literal|0
expr_stmt|;
name|argvp
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cp2
operator|=
name|buf
init|;
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'|'
operator|||
name|c
operator|==
literal|':'
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* 			 * Skip entries that have spaces or are over 40 			 * characters long.  If this is our environment 			 * name, then put it up front.  Otherwise, as 			 * long as this is not a duplicate name (case 			 * insensitive) add it to the list. 			 */
if|if
condition|(
name|n
operator|||
operator|(
name|cp
operator|-
name|cp2
operator|>
literal|41
operator|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|name
operator|&&
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
name|cp2
argument_list|,
name|cp
operator|-
name|cp2
argument_list|)
operator|==
literal|0
operator|)
condition|)
operator|*
name|argv
operator|=
name|cp2
expr_stmt|;
elseif|else
if|if
condition|(
name|is_unique
argument_list|(
name|cp2
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
name|argvp
argument_list|)
condition|)
operator|*
name|argvp
operator|++
operator|=
name|cp2
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
break|break;
comment|/* 			 * Skip multiple delimiters. Reset cp2 to 			 * the beginning of the next name. Reset n, 			 * the flag for names with spaces. 			 */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
operator|==
literal|'|'
condition|)
name|cp
operator|++
expr_stmt|;
name|cp2
operator|=
name|cp
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Skip entries with spaces or non-ascii values. 		 * Convert lower case letters to upper case. 		 */
if|if
condition|(
operator|(
name|c
operator|==
literal|' '
operator|)
operator|||
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
name|n
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|toupper
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check for an old V6 2 character name.  If the second 	 * name points to the beginning of the buffer, and is 	 * only 2 characters long, move it to the end of the array. 	 */
if|if
condition|(
operator|(
name|argv
index|[
literal|1
index|]
operator|==
name|buf
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|2
operator|)
condition|)
block|{
operator|*
name|argvp
operator|++
operator|=
name|buf
expr_stmt|;
name|cp
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
operator|*
name|argv
operator|=
name|cp
expr_stmt|;
block|}
comment|/* 	 * Duplicate last name, for TTYPE option, and null 	 * terminate the array.  If we didn't find a match on 	 * our terminal name, put that name at the beginning. 	 */
name|cp
operator|=
operator|*
operator|(
name|argvp
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|argvp
operator|++
operator|=
name|cp
expr_stmt|;
operator|*
name|argvp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|argv
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|name
condition|)
operator|*
name|argv
operator|=
name|name
expr_stmt|;
else|else
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|argv
condition|)
return|return
operator|(
name|argv
operator|)
return|;
else|else
return|return
operator|(
name|unknown
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|is_unique
argument_list|(
name|name
argument_list|,
name|as
argument_list|,
name|ae
argument_list|)
specifier|register
name|char
operator|*
name|name
operator|,
operator|*
operator|*
name|as
operator|,
operator|*
operator|*
name|ae
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|as
init|;
name|ap
operator|<
name|ae
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|strncasecmp
argument_list|(
operator|*
name|ap
argument_list|,
name|name
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|TERMCAP
end_ifdef

begin_decl_stmt
name|char
name|termbuf
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|setupterm
argument_list|(
argument|tname
argument_list|,
argument|fd
argument_list|,
argument|errp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|tname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fd
decl_stmt|,
modifier|*
name|errp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|tgetent
argument_list|(
name|termbuf
argument_list|,
name|tname
argument_list|)
operator|==
literal|1
condition|)
block|{
name|termbuf
index|[
literal|1023
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|errp
condition|)
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|errp
condition|)
operator|*
name|errp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|termbuf
value|ttytype
end_define

begin_decl_stmt
specifier|extern
name|char
name|ttytype
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
name|gettermname
parameter_list|()
block|{
name|char
modifier|*
name|tname
decl_stmt|;
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
specifier|static
name|char
modifier|*
modifier|*
name|tnamep
decl_stmt|;
specifier|static
name|char
modifier|*
modifier|*
name|next
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|tname
operator|=
name|env_getvalue
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|&&
operator|(
name|setupterm
argument_list|(
name|tname
argument_list|,
literal|1
argument_list|,
operator|&
name|err
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|tnamep
operator|=
name|mklist
argument_list|(
name|termbuf
argument_list|,
name|tname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tname
operator|&&
operator|(
name|strlen
argument_list|(
name|tname
argument_list|)
operator|<=
literal|40
operator|)
condition|)
block|{
name|unknown
index|[
literal|0
index|]
operator|=
name|tname
expr_stmt|;
name|upcase
argument_list|(
name|tname
argument_list|)
expr_stmt|;
block|}
name|tnamep
operator|=
name|unknown
expr_stmt|;
block|}
name|next
operator|=
name|tnamep
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|next
operator|==
literal|0
condition|)
name|next
operator|=
name|tnamep
expr_stmt|;
return|return
operator|(
operator|*
name|next
operator|++
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * suboption()  *  *	Look at the sub-option buffer, and try to be helpful to the other  * side.  *  *	Currently we recognize:  *  *		Terminal type, send request.  *		Terminal speed (send request).  *		Local flow control (is request).  *		Linemode  */
end_comment

begin_function
specifier|static
name|void
name|suboption
parameter_list|()
block|{
name|printsub
argument_list|(
literal|'<'
argument_list|,
name|subbuffer
argument_list|,
name|subend
operator|-
name|subbuffer
operator|+
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|subbuffer
index|[
literal|0
index|]
operator|&
literal|0xff
condition|)
block|{
case|case
name|TELOPT_TTYPE
case|:
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_TTYPE
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|subbuffer
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|!=
name|TELQUAL_SEND
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|temp
index|[
literal|50
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
if|if
condition|(
name|tn3270_ttype
argument_list|()
condition|)
block|{
return|return;
block|}
endif|#
directive|endif
comment|/* defined(TN3270) */
name|name
operator|=
name|gettermname
argument_list|()
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|4
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|NETROOM
argument_list|()
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%c%c%c%c%s%c%c"
argument_list|,
name|IAC
argument_list|,
name|SB
argument_list|,
name|TELOPT_TTYPE
argument_list|,
name|TELQUAL_IS
argument_list|,
name|name
argument_list|,
name|IAC
argument_list|,
name|SE
argument_list|)
expr_stmt|;
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|temp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
operator|&
name|temp
index|[
literal|2
index|]
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ExitString
argument_list|(
literal|"No room in buffer for terminal type.\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
break|break;
case|case
name|TELOPT_TSPEED
case|:
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_TSPEED
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|subbuffer
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|==
name|TELQUAL_SEND
condition|)
block|{
name|int
name|ospeed
decl_stmt|,
name|ispeed
decl_stmt|;
name|char
name|temp
index|[
literal|50
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|TerminalSpeeds
argument_list|(
operator|&
name|ispeed
argument_list|,
operator|&
name|ospeed
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%c%c%c%c%d,%d%c%c"
argument_list|,
name|IAC
argument_list|,
name|SB
argument_list|,
name|TELOPT_TSPEED
argument_list|,
name|TELQUAL_IS
argument_list|,
name|ospeed
argument_list|,
name|ispeed
argument_list|,
name|IAC
argument_list|,
name|SE
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|temp
operator|+
literal|4
argument_list|)
operator|+
literal|4
expr_stmt|;
comment|/* temp[3] is 0 ... */
if|if
condition|(
name|len
operator|<
name|NETROOM
argument_list|()
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|temp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
name|temp
operator|+
literal|2
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/*@*/
else|else
name|printf
argument_list|(
literal|"lm_will: not enough room in buffer\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TELOPT_LFLOW
case|:
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_LFLOW
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|subbuffer
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|==
literal|1
condition|)
block|{
name|localflow
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|subbuffer
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|==
literal|0
condition|)
block|{
name|localflow
operator|=
literal|0
expr_stmt|;
block|}
name|setcommandmode
argument_list|()
expr_stmt|;
name|setconnmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELOPT_LINEMODE
case|:
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|subbuffer
index|[
literal|1
index|]
operator|&
literal|0xff
condition|)
block|{
case|case
name|WILL
case|:
name|lm_will
argument_list|(
operator|&
name|subbuffer
index|[
literal|2
index|]
argument_list|,
name|subend
operator|-
operator|&
name|subbuffer
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|WONT
case|:
name|lm_wont
argument_list|(
operator|&
name|subbuffer
index|[
literal|2
index|]
argument_list|,
name|subend
operator|-
operator|&
name|subbuffer
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DO
case|:
name|lm_do
argument_list|(
operator|&
name|subbuffer
index|[
literal|2
index|]
argument_list|,
name|subend
operator|-
operator|&
name|subbuffer
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DONT
case|:
name|lm_dont
argument_list|(
operator|&
name|subbuffer
index|[
literal|2
index|]
argument_list|,
name|subend
operator|-
operator|&
name|subbuffer
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|LM_SLC
case|:
name|slc
argument_list|(
operator|&
name|subbuffer
index|[
literal|2
index|]
argument_list|,
name|subend
operator|-
operator|&
name|subbuffer
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|LM_MODE
case|:
name|lm_mode
argument_list|(
operator|&
name|subbuffer
index|[
literal|2
index|]
argument_list|,
name|subend
operator|-
operator|&
name|subbuffer
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|TELOPT_ENVIRON
case|:
switch|switch
condition|(
name|subbuffer
index|[
literal|1
index|]
operator|&
literal|0xff
condition|)
block|{
case|case
name|TELQUAL_IS
case|:
case|case
name|TELQUAL_INFO
case|:
if|if
condition|(
name|my_want_state_is_dont
argument_list|(
name|TELOPT_ENVIRON
argument_list|)
condition|)
return|return;
break|break;
case|case
name|TELQUAL_SEND
case|:
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_ENVIRON
argument_list|)
condition|)
block|{
return|return;
block|}
break|break;
default|default:
return|return;
block|}
name|env_opt
argument_list|(
operator|&
name|subbuffer
index|[
literal|1
index|]
argument_list|,
name|subend
operator|-
operator|&
name|subbuffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELOPT_XDISPLOC
case|:
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_XDISPLOC
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|subbuffer
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|==
name|TELQUAL_SEND
condition|)
block|{
name|char
name|temp
index|[
literal|50
index|]
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|env_getvalue
argument_list|(
literal|"DISPLAY"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Something happened, we no longer have a DISPLAY 		 * variable.  So, turn off the option. 		 */
name|send_wont
argument_list|(
name|TELOPT_XDISPLOC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%c%c%c%c%s%c%c"
argument_list|,
name|IAC
argument_list|,
name|SB
argument_list|,
name|TELOPT_XDISPLOC
argument_list|,
name|TELQUAL_IS
argument_list|,
name|dp
argument_list|,
name|IAC
argument_list|,
name|SE
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|temp
operator|+
literal|4
argument_list|)
operator|+
literal|4
expr_stmt|;
comment|/* temp[3] is 0 ... */
if|if
condition|(
name|len
operator|<
name|NETROOM
argument_list|()
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|temp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
name|temp
operator|+
literal|2
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/*@*/
else|else
name|printf
argument_list|(
literal|"lm_will: not enough room in buffer\n"
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|KERBEROS
case|case
name|TELOPT_AUTHENTICATION
case|:
if|if
condition|(
operator|(
name|subbuffer
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|==
name|TELQUAL_SEND
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
operator|&
name|subbuffer
index|[
literal|2
index|]
decl_stmt|;
name|char
name|tmp
index|[
literal|256
index|]
decl_stmt|;
name|int
name|dokrb4
init|=
literal|0
decl_stmt|,
name|unknowntypes
init|=
literal|0
decl_stmt|,
name|noresponse
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|cp
operator|<
name|subend
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
name|TELQUAL_AUTHTYPE_KERBEROS_V4
case|:
name|dokrb4
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|unknowntypes
operator|++
expr_stmt|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|noresponse
operator|&&
name|dokrb4
condition|)
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|ucp
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|cp
decl_stmt|;
name|char
modifier|*
name|krb_realm
decl_stmt|;
name|char
name|hst_inst
index|[
name|INST_SZ
index|]
decl_stmt|;
name|KTEXT_ST
name|authent_st
decl_stmt|;
name|int
name|space
init|=
literal|0
decl_stmt|;
name|int
name|retval
decl_stmt|;
specifier|extern
name|char
modifier|*
name|krb_realmofhost
argument_list|()
decl_stmt|,
modifier|*
name|krb_get_phost
argument_list|()
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[Trying Kerberos V4 authentication]\n"
argument_list|)
expr_stmt|;
name|krb_realm
operator|=
name|krb_get_phost
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|hst_inst
argument_list|,
sizeof|sizeof
argument_list|(
name|hst_inst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|krb_realm
condition|)
name|strncpy
argument_list|(
name|hst_inst
argument_list|,
name|krb_realm
argument_list|,
sizeof|sizeof
argument_list|(
name|hst_inst
argument_list|)
argument_list|)
expr_stmt|;
name|hst_inst
index|[
sizeof|sizeof
argument_list|(
name|hst_inst
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|krb_realm
operator|=
name|krb_realmofhost
argument_list|(
name|hst_inst
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no realm for %s\n"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
goto|goto
name|cantsend4
goto|;
block|}
if|if
condition|(
name|retval
operator|=
name|krb_mk_req
argument_list|(
operator|&
name|authent_st
argument_list|,
literal|"rcmd"
argument_list|,
name|hst_inst
argument_list|,
name|krb_realm
argument_list|,
literal|0L
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mk_req failed: %s\n"
argument_list|,
name|krb_err_txt
index|[
name|retval
index|]
argument_list|)
expr_stmt|;
goto|goto
name|cantsend4
goto|;
block|}
name|space
operator|=
name|authent_st
operator|.
name|length
expr_stmt|;
for|for
control|(
name|ucp
operator|=
name|authent_st
operator|.
name|dat
init|;
name|ucp
operator|<
name|authent_st
operator|.
name|dat
operator|+
name|authent_st
operator|.
name|length
condition|;
name|ucp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ucp
operator|==
name|IAC
condition|)
name|space
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|NETROOM
argument_list|()
operator|<
literal|6
operator|+
literal|1
operator|+
literal|2
operator|+
name|space
operator|+
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no room to send V4 ticket/authenticator\n"
argument_list|)
expr_stmt|;
name|cantsend4
label|:
if|if
condition|(
literal|7
operator|<
name|NETROOM
argument_list|()
condition|)
block|{
name|printring
argument_list|(
operator|&
name|netoring
argument_list|,
literal|"%c%c%c%c%c%c%c"
argument_list|,
name|IAC
argument_list|,
name|SB
argument_list|,
name|TELOPT_AUTHENTICATION
argument_list|,
name|TELQUAL_IS
argument_list|,
name|TELQUAL_AUTHTYPE_NONE
argument_list|,
name|IAC
argument_list|,
name|SE
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%c%c%c%c%c"
argument_list|,
name|TELOPT_AUTHENTICATION
argument_list|,
name|TELQUAL_IS
argument_list|,
name|TELQUAL_AUTHTYPE_NONE
argument_list|,
name|IAC
argument_list|,
name|SE
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|">"
argument_list|,
name|tmp
argument_list|,
literal|4
operator|+
literal|2
operator|-
literal|2
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|notdef
name|printring
argument_list|(
operator|&
name|netoring
argument_list|,
literal|"%c%c%c%c%c%c"
argument_list|,
name|IAC
argument_list|,
name|SB
argument_list|,
name|TELOPT_AUTHENTICATION
argument_list|,
name|TELQUAL_IS
argument_list|,
name|TELQUAL_AUTHTYPE_KERBEROS
argument_list|,
name|TELQUAL_AUTHTYPE_KERBEROS_V4
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%c%c%c%c%c%c"
argument_list|,
name|TELOPT_AUTHENTICATION
argument_list|,
name|TELQUAL_IS
argument_list|,
name|TELQUAL_AUTHTYPE_KERBEROS
argument_list|,
name|TELQUAL_AUTHTYPE_KERBEROS_V4
argument_list|,
name|IAC
argument_list|,
name|SE
argument_list|)
expr_stmt|;
else|#
directive|else
name|printring
argument_list|(
operator|&
name|netoring
argument_list|,
literal|"%c%c%c%c%c"
argument_list|,
name|IAC
argument_list|,
name|SB
argument_list|,
name|TELOPT_AUTHENTICATION
argument_list|,
name|TELQUAL_IS
argument_list|,
name|TELQUAL_AUTHTYPE_KERBEROS_V4
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%c%c%c%c%c"
argument_list|,
name|TELOPT_AUTHENTICATION
argument_list|,
name|TELQUAL_IS
argument_list|,
name|TELQUAL_AUTHTYPE_KERBEROS_V4
argument_list|,
name|IAC
argument_list|,
name|SE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printsub
argument_list|(
literal|">"
argument_list|,
name|tmp
argument_list|,
literal|4
operator|+
literal|2
operator|-
literal|2
operator|-
literal|2
argument_list|)
expr_stmt|;
name|ring_supply_bindata
argument_list|(
operator|&
name|netoring
argument_list|,
operator|(
name|char
operator|*
operator|)
name|authent_st
operator|.
name|dat
argument_list|,
name|authent_st
operator|.
name|length
argument_list|,
name|IAC
argument_list|)
expr_stmt|;
name|printring
argument_list|(
operator|&
name|netoring
argument_list|,
literal|"%c%c"
argument_list|,
name|IAC
argument_list|,
name|SE
argument_list|)
expr_stmt|;
block|}
name|noresponse
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|noresponse
condition|)
block|{
if|if
condition|(
name|NETROOM
argument_list|()
operator|<
literal|7
condition|)
block|{
name|ExitString
argument_list|(
literal|"not enough room to reject unhandled authtype\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[Sending empty auth info in response to request for %d unknown type(s):\n\t"
argument_list|,
name|unknowntypes
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|cp
operator|=
operator|&
name|subbuffer
index|[
literal|3
index|]
expr_stmt|;
else|#
directive|else
name|cp
operator|=
operator|&
name|subbuffer
index|[
literal|2
index|]
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|cp
operator|<
name|subend
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
name|TELQUAL_AUTHTYPE_KERBEROS_V4
case|:
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d,"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
name|cp
operator|++
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"]\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|printring
argument_list|(
operator|&
name|netoring
argument_list|,
literal|"%c%c%c%c%c%c%c"
argument_list|,
name|IAC
argument_list|,
name|SB
argument_list|,
name|TELOPT_AUTHENTICATION
argument_list|,
name|TELQUAL_IS
argument_list|,
name|TELQUAL_AUTHTYPE_NONE
argument_list|,
name|IAC
argument_list|,
name|SE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
endif|#
directive|endif
comment|/* KERBEROS */
default|default:
break|break;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|str_lm
index|[]
init|=
block|{
name|IAC
block|,
name|SB
block|,
name|TELOPT_LINEMODE
block|,
literal|0
block|,
literal|0
block|,
name|IAC
block|,
name|SE
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|lm_will
argument_list|(
argument|cmd
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|len
operator|<
literal|1
condition|)
block|{
comment|/*@*/
name|printf
argument_list|(
literal|"lm_will: no command!!!\n"
argument_list|)
expr_stmt|;
comment|/* Should not happen... */
return|return;
block|}
switch|switch
condition|(
name|cmd
index|[
literal|0
index|]
condition|)
block|{
case|case
name|LM_FORWARDMASK
case|:
comment|/* We shouldn't ever get this... */
default|default:
name|str_lm
index|[
literal|3
index|]
operator|=
name|DONT
expr_stmt|;
name|str_lm
index|[
literal|4
index|]
operator|=
name|cmd
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|NETROOM
argument_list|()
operator|>
sizeof|sizeof
argument_list|(
name|str_lm
argument_list|)
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|str_lm
argument_list|,
sizeof|sizeof
argument_list|(
name|str_lm
argument_list|)
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
operator|&
name|str_lm
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|str_lm
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/*@*/
else|else
name|printf
argument_list|(
literal|"lm_will: not enough room in buffer\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_macro
name|lm_wont
argument_list|(
argument|cmd
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|len
operator|<
literal|1
condition|)
block|{
comment|/*@*/
name|printf
argument_list|(
literal|"lm_wont: no command!!!\n"
argument_list|)
expr_stmt|;
comment|/* Should not happen... */
return|return;
block|}
switch|switch
condition|(
name|cmd
index|[
literal|0
index|]
condition|)
block|{
case|case
name|LM_FORWARDMASK
case|:
comment|/* We shouldn't ever get this... */
default|default:
comment|/* We are always DONT, so don't respond */
return|return;
block|}
block|}
end_block

begin_macro
name|lm_do
argument_list|(
argument|cmd
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|len
operator|<
literal|1
condition|)
block|{
comment|/*@*/
name|printf
argument_list|(
literal|"lm_do: no command!!!\n"
argument_list|)
expr_stmt|;
comment|/* Should not happen... */
return|return;
block|}
switch|switch
condition|(
name|cmd
index|[
literal|0
index|]
condition|)
block|{
case|case
name|LM_FORWARDMASK
case|:
default|default:
name|str_lm
index|[
literal|3
index|]
operator|=
name|WONT
expr_stmt|;
name|str_lm
index|[
literal|4
index|]
operator|=
name|cmd
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|NETROOM
argument_list|()
operator|>
sizeof|sizeof
argument_list|(
name|str_lm
argument_list|)
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|str_lm
argument_list|,
sizeof|sizeof
argument_list|(
name|str_lm
argument_list|)
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
operator|&
name|str_lm
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|str_lm
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/*@*/
else|else
name|printf
argument_list|(
literal|"lm_do: not enough room in buffer\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_macro
name|lm_dont
argument_list|(
argument|cmd
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|len
operator|<
literal|1
condition|)
block|{
comment|/*@*/
name|printf
argument_list|(
literal|"lm_dont: no command!!!\n"
argument_list|)
expr_stmt|;
comment|/* Should not happen... */
return|return;
block|}
switch|switch
condition|(
name|cmd
index|[
literal|0
index|]
condition|)
block|{
case|case
name|LM_FORWARDMASK
case|:
default|default:
comment|/* we are always WONT, so don't respond */
break|break;
block|}
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|str_lm_mode
index|[]
init|=
block|{
name|IAC
block|,
name|SB
block|,
name|TELOPT_LINEMODE
block|,
name|LM_MODE
block|,
literal|0
block|,
name|IAC
block|,
name|SE
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|lm_mode
argument_list|(
argument|cmd
argument_list|,
argument|len
argument_list|,
argument|init
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|,
name|init
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|len
operator|!=
literal|1
condition|)
return|return;
if|if
condition|(
operator|(
name|linemode
operator|&
name|MODE_MASK
operator|&
operator|~
name|MODE_ACK
operator|)
operator|==
operator|*
name|cmd
condition|)
return|return;
if|if
condition|(
operator|*
name|cmd
operator|&
name|MODE_ACK
condition|)
return|return;
name|linemode
operator|=
operator|*
name|cmd
operator|&
operator|(
name|MODE_MASK
operator|&
operator|~
name|MODE_ACK
operator|)
expr_stmt|;
name|str_lm_mode
index|[
literal|4
index|]
operator|=
name|linemode
expr_stmt|;
if|if
condition|(
operator|!
name|init
condition|)
name|str_lm_mode
index|[
literal|4
index|]
operator||=
name|MODE_ACK
expr_stmt|;
if|if
condition|(
name|NETROOM
argument_list|()
operator|>
sizeof|sizeof
argument_list|(
name|str_lm_mode
argument_list|)
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|str_lm_mode
argument_list|,
sizeof|sizeof
argument_list|(
name|str_lm_mode
argument_list|)
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
operator|&
name|str_lm_mode
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|str_lm_mode
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/*@*/
else|else
name|printf
argument_list|(
literal|"lm_mode: not enough room in buffer\n"
argument_list|)
expr_stmt|;
name|setconnmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* set changed mode */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * slc()  * Handle special character suboption of LINEMODE.  */
end_comment

begin_struct
struct|struct
name|spc
block|{
name|cc_t
name|val
decl_stmt|;
name|cc_t
modifier|*
name|valp
decl_stmt|;
name|char
name|flags
decl_stmt|;
comment|/* Current flags& level */
name|char
name|mylevel
decl_stmt|;
comment|/* Maximum level& flags */
block|}
name|spc_data
index|[
name|NSLC
operator|+
literal|1
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|SLC_IMPORT
value|0
end_define

begin_define
define|#
directive|define
name|SLC_EXPORT
value|1
end_define

begin_define
define|#
directive|define
name|SLC_RVALUE
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|slc_mode
init|=
name|SLC_EXPORT
decl_stmt|;
end_decl_stmt

begin_macro
name|slc_init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|spc
modifier|*
name|spcp
decl_stmt|;
specifier|extern
name|cc_t
modifier|*
name|tcval
parameter_list|()
function_decl|;
name|localchars
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|spcp
operator|=
name|spc_data
init|;
name|spcp
operator|<
operator|&
name|spc_data
index|[
name|NSLC
operator|+
literal|1
index|]
condition|;
name|spcp
operator|++
control|)
block|{
name|spcp
operator|->
name|val
operator|=
literal|0
expr_stmt|;
name|spcp
operator|->
name|valp
operator|=
literal|0
expr_stmt|;
name|spcp
operator|->
name|flags
operator|=
name|spcp
operator|->
name|mylevel
operator|=
name|SLC_NOSUPPORT
expr_stmt|;
block|}
define|#
directive|define
name|initfunc
parameter_list|(
name|func
parameter_list|,
name|flags
parameter_list|)
value|{ \ 					spcp =&spc_data[func]; \ 					if (spcp->valp = tcval(func)) { \ 					    spcp->val = *spcp->valp; \ 					    spcp->mylevel = SLC_VARIABLE|flags; \ 					} else { \ 					    spcp->val = 0; \ 					    spcp->mylevel = SLC_DEFAULT; \ 					} \ 				    }
name|initfunc
argument_list|(
name|SLC_SYNCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* No BRK */
name|initfunc
argument_list|(
name|SLC_AO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initfunc
argument_list|(
name|SLC_AYT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* No EOR */
name|initfunc
argument_list|(
name|SLC_ABORT
argument_list|,
name|SLC_FLUSHIN
operator||
name|SLC_FLUSHOUT
argument_list|)
expr_stmt|;
name|initfunc
argument_list|(
name|SLC_EOF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYSV_TERMIO
name|initfunc
argument_list|(
name|SLC_SUSP
argument_list|,
name|SLC_FLUSHIN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|initfunc
argument_list|(
name|SLC_EC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initfunc
argument_list|(
name|SLC_EL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYSV_TERMIO
name|initfunc
argument_list|(
name|SLC_EW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initfunc
argument_list|(
name|SLC_RP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initfunc
argument_list|(
name|SLC_LNEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|initfunc
argument_list|(
name|SLC_XON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initfunc
argument_list|(
name|SLC_XOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSV_TERMIO
name|spc_data
index|[
name|SLC_XON
index|]
operator|.
name|mylevel
operator|=
name|SLC_CANTCHANGE
expr_stmt|;
name|spc_data
index|[
name|SLC_XOFF
index|]
operator|.
name|mylevel
operator|=
name|SLC_CANTCHANGE
expr_stmt|;
endif|#
directive|endif
name|initfunc
argument_list|(
name|SLC_FORW1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_TERMIO
name|initfunc
argument_list|(
name|SLC_FORW2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* No FORW2 */
endif|#
directive|endif
name|initfunc
argument_list|(
name|SLC_IP
argument_list|,
name|SLC_FLUSHIN
operator||
name|SLC_FLUSHOUT
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|initfunc
if|if
condition|(
name|slc_mode
operator|==
name|SLC_EXPORT
condition|)
name|slc_export
argument_list|()
expr_stmt|;
else|else
name|slc_import
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|slcstate
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"Special characters are %s values\n"
argument_list|,
name|slc_mode
operator|==
name|SLC_IMPORT
condition|?
literal|"remote default"
else|:
name|slc_mode
operator|==
name|SLC_EXPORT
condition|?
literal|"local"
else|:
literal|"remote"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|slc_mode_export
argument_list|()
end_macro

begin_block
block|{
name|slc_mode
operator|=
name|SLC_EXPORT
expr_stmt|;
if|if
condition|(
name|my_state_is_will
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
condition|)
name|slc_export
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|slc_mode_import
argument_list|(
argument|def
argument_list|)
end_macro

begin_block
block|{
name|slc_mode
operator|=
name|def
condition|?
name|SLC_IMPORT
else|:
name|SLC_RVALUE
expr_stmt|;
if|if
condition|(
name|my_state_is_will
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
condition|)
name|slc_import
argument_list|(
name|def
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
name|slc_import_val
index|[]
init|=
block|{
name|IAC
block|,
name|SB
block|,
name|TELOPT_LINEMODE
block|,
name|LM_SLC
block|,
literal|0
block|,
name|SLC_VARIABLE
block|,
literal|0
block|,
name|IAC
block|,
name|SE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|slc_import_def
index|[]
init|=
block|{
name|IAC
block|,
name|SB
block|,
name|TELOPT_LINEMODE
block|,
name|LM_SLC
block|,
literal|0
block|,
name|SLC_DEFAULT
block|,
literal|0
block|,
name|IAC
block|,
name|SE
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|slc_import
argument_list|(
argument|def
argument_list|)
end_macro

begin_decl_stmt
name|int
name|def
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|NETROOM
argument_list|()
operator|>
sizeof|sizeof
argument_list|(
name|slc_import_val
argument_list|)
condition|)
block|{
if|if
condition|(
name|def
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|slc_import_def
argument_list|,
sizeof|sizeof
argument_list|(
name|slc_import_def
argument_list|)
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
operator|&
name|slc_import_def
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|slc_import_def
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|slc_import_val
argument_list|,
sizeof|sizeof
argument_list|(
name|slc_import_val
argument_list|)
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
operator|&
name|slc_import_val
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|slc_import_val
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*@*/
else|else
name|printf
argument_list|(
literal|"slc_import: not enough room\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|slc_export
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|spc
modifier|*
name|spcp
decl_stmt|;
name|TerminalDefaultChars
argument_list|()
expr_stmt|;
name|slc_start_reply
argument_list|()
expr_stmt|;
for|for
control|(
name|spcp
operator|=
operator|&
name|spc_data
index|[
literal|1
index|]
init|;
name|spcp
operator|<
operator|&
name|spc_data
index|[
name|NSLC
operator|+
literal|1
index|]
condition|;
name|spcp
operator|++
control|)
block|{
if|if
condition|(
name|spcp
operator|->
name|mylevel
operator|!=
name|SLC_NOSUPPORT
condition|)
block|{
name|spcp
operator|->
name|flags
operator|=
name|spcp
operator|->
name|mylevel
expr_stmt|;
if|if
condition|(
name|spcp
operator|->
name|valp
condition|)
name|spcp
operator|->
name|val
operator|=
operator|*
name|spcp
operator|->
name|valp
expr_stmt|;
name|slc_add_reply
argument_list|(
name|spcp
operator|-
name|spc_data
argument_list|,
name|spcp
operator|->
name|mylevel
argument_list|,
name|spcp
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
block|}
name|slc_end_reply
argument_list|()
expr_stmt|;
if|if
condition|(
name|slc_update
argument_list|()
condition|)
name|setconnmode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* set the  new character values */
block|}
end_block

begin_expr_stmt
name|slc
argument_list|(
name|cp
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|spc
modifier|*
name|spcp
decl_stmt|;
specifier|register
name|int
name|func
decl_stmt|,
name|level
decl_stmt|;
name|slc_start_reply
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>=
literal|3
condition|;
name|len
operator|-=
literal|3
operator|,
name|cp
operator|+=
literal|3
control|)
block|{
name|func
operator|=
name|cp
index|[
name|SLC_FUNC
index|]
expr_stmt|;
if|if
condition|(
name|func
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Client side: always ignore 0 function. 			 */
continue|continue;
block|}
if|if
condition|(
name|func
operator|>
name|NSLC
condition|)
block|{
if|if
condition|(
name|cp
index|[
name|SLC_FLAGS
index|]
operator|&
name|SLC_LEVELBITS
operator|!=
name|SLC_NOSUPPORT
condition|)
name|slc_add_reply
argument_list|(
name|func
argument_list|,
name|SLC_NOSUPPORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|spcp
operator|=
operator|&
name|spc_data
index|[
name|func
index|]
expr_stmt|;
name|level
operator|=
name|cp
index|[
name|SLC_FLAGS
index|]
operator|&
operator|(
name|SLC_LEVELBITS
operator||
name|SLC_ACK
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
index|[
name|SLC_VALUE
index|]
operator|==
operator|(
name|unsigned
name|char
operator|)
name|spcp
operator|->
name|val
operator|)
operator|&&
operator|(
operator|(
name|level
operator|&
name|SLC_LEVELBITS
operator|)
operator|==
operator|(
name|spcp
operator|->
name|flags
operator|&
name|SLC_LEVELBITS
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|level
operator|==
operator|(
name|SLC_DEFAULT
operator||
name|SLC_ACK
operator|)
condition|)
block|{
comment|/* 			 * This is an error condition, the SLC_ACK 			 * bit should never be set for the SLC_DEFAULT 			 * level.  Our best guess to recover is to 			 * ignore the SLC_ACK bit. 			 */
name|cp
index|[
name|SLC_FLAGS
index|]
operator|&=
operator|~
name|SLC_ACK
expr_stmt|;
block|}
if|if
condition|(
name|level
operator|==
operator|(
operator|(
name|spcp
operator|->
name|flags
operator|&
name|SLC_LEVELBITS
operator|)
operator||
name|SLC_ACK
operator|)
condition|)
block|{
name|spcp
operator|->
name|val
operator|=
operator|(
name|cc_t
operator|)
name|cp
index|[
name|SLC_VALUE
index|]
expr_stmt|;
name|spcp
operator|->
name|flags
operator|=
name|cp
index|[
name|SLC_FLAGS
index|]
expr_stmt|;
comment|/* include SLC_ACK */
continue|continue;
block|}
name|level
operator|&=
operator|~
name|SLC_ACK
expr_stmt|;
if|if
condition|(
name|level
operator|<=
operator|(
name|spcp
operator|->
name|mylevel
operator|&
name|SLC_LEVELBITS
operator|)
condition|)
block|{
name|spcp
operator|->
name|flags
operator|=
name|cp
index|[
name|SLC_FLAGS
index|]
operator||
name|SLC_ACK
expr_stmt|;
name|spcp
operator|->
name|val
operator|=
operator|(
name|cc_t
operator|)
name|cp
index|[
name|SLC_VALUE
index|]
expr_stmt|;
block|}
if|if
condition|(
name|level
operator|==
name|SLC_DEFAULT
condition|)
block|{
if|if
condition|(
operator|(
name|spcp
operator|->
name|mylevel
operator|&
name|SLC_LEVELBITS
operator|)
operator|!=
name|SLC_DEFAULT
condition|)
name|spcp
operator|->
name|flags
operator|=
name|spcp
operator|->
name|mylevel
expr_stmt|;
else|else
name|spcp
operator|->
name|flags
operator|=
name|SLC_NOSUPPORT
expr_stmt|;
block|}
name|slc_add_reply
argument_list|(
name|func
argument_list|,
name|spcp
operator|->
name|flags
argument_list|,
name|spcp
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
name|slc_end_reply
argument_list|()
expr_stmt|;
if|if
condition|(
name|slc_update
argument_list|()
condition|)
name|setconnmode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* set the  new character values */
block|}
end_block

begin_macro
name|slc_check
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|spc
modifier|*
name|spcp
decl_stmt|;
name|slc_start_reply
argument_list|()
expr_stmt|;
for|for
control|(
name|spcp
operator|=
operator|&
name|spc_data
index|[
literal|1
index|]
init|;
name|spcp
operator|<
operator|&
name|spc_data
index|[
name|NSLC
operator|+
literal|1
index|]
condition|;
name|spcp
operator|++
control|)
block|{
if|if
condition|(
name|spcp
operator|->
name|valp
operator|&&
name|spcp
operator|->
name|val
operator|!=
operator|*
name|spcp
operator|->
name|valp
condition|)
block|{
name|spcp
operator|->
name|val
operator|=
operator|*
name|spcp
operator|->
name|valp
expr_stmt|;
name|slc_add_reply
argument_list|(
name|spcp
operator|-
name|spc_data
argument_list|,
name|spcp
operator|->
name|mylevel
argument_list|,
name|spcp
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
block|}
name|slc_end_reply
argument_list|()
expr_stmt|;
name|setconnmode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|unsigned
name|char
name|slc_reply
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|slc_replyp
decl_stmt|;
end_decl_stmt

begin_macro
name|slc_start_reply
argument_list|()
end_macro

begin_block
block|{
name|slc_replyp
operator|=
name|slc_reply
expr_stmt|;
operator|*
name|slc_replyp
operator|++
operator|=
name|IAC
expr_stmt|;
operator|*
name|slc_replyp
operator|++
operator|=
name|SB
expr_stmt|;
operator|*
name|slc_replyp
operator|++
operator|=
name|TELOPT_LINEMODE
expr_stmt|;
operator|*
name|slc_replyp
operator|++
operator|=
name|LM_SLC
expr_stmt|;
block|}
end_block

begin_macro
name|slc_add_reply
argument_list|(
argument|func
argument_list|,
argument|flags
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|char
name|func
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cc_t
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
operator|*
name|slc_replyp
operator|++
operator|=
name|func
operator|)
operator|==
name|IAC
condition|)
operator|*
name|slc_replyp
operator|++
operator|=
name|IAC
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|slc_replyp
operator|++
operator|=
name|flags
operator|)
operator|==
name|IAC
condition|)
operator|*
name|slc_replyp
operator|++
operator|=
name|IAC
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|slc_replyp
operator|++
operator|=
operator|(
name|unsigned
name|char
operator|)
name|value
operator|)
operator|==
name|IAC
condition|)
operator|*
name|slc_replyp
operator|++
operator|=
name|IAC
expr_stmt|;
block|}
end_block

begin_macro
name|slc_end_reply
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|len
decl_stmt|;
operator|*
name|slc_replyp
operator|++
operator|=
name|IAC
expr_stmt|;
operator|*
name|slc_replyp
operator|++
operator|=
name|SE
expr_stmt|;
name|len
operator|=
name|slc_replyp
operator|-
name|slc_reply
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|6
condition|)
return|return;
if|if
condition|(
name|NETROOM
argument_list|()
operator|>
name|len
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|slc_reply
argument_list|,
name|slc_replyp
operator|-
name|slc_reply
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
operator|&
name|slc_reply
index|[
literal|2
index|]
argument_list|,
name|slc_replyp
operator|-
name|slc_reply
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/*@*/
else|else
name|printf
argument_list|(
literal|"slc_end_reply: not enough room\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|slc_update
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|spc
modifier|*
name|spcp
decl_stmt|;
name|int
name|need_update
init|=
literal|0
decl_stmt|;
for|for
control|(
name|spcp
operator|=
operator|&
name|spc_data
index|[
literal|1
index|]
init|;
name|spcp
operator|<
operator|&
name|spc_data
index|[
name|NSLC
operator|+
literal|1
index|]
condition|;
name|spcp
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|spcp
operator|->
name|flags
operator|&
name|SLC_ACK
operator|)
condition|)
continue|continue;
name|spcp
operator|->
name|flags
operator|&=
operator|~
name|SLC_ACK
expr_stmt|;
if|if
condition|(
name|spcp
operator|->
name|valp
operator|&&
operator|(
operator|*
name|spcp
operator|->
name|valp
operator|!=
name|spcp
operator|->
name|val
operator|)
condition|)
block|{
operator|*
name|spcp
operator|->
name|valp
operator|=
name|spcp
operator|->
name|val
expr_stmt|;
name|need_update
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|need_update
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|env_opt
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
specifier|register
name|char
operator|*
name|buf
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ep
init|=
literal|0
decl_stmt|,
modifier|*
name|epc
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
name|TELQUAL_SEND
case|:
name|env_opt_start
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
name|env_opt_add
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|buf
index|[
name|i
index|]
condition|)
block|{
case|case
name|ENV_VALUE
case|:
if|if
condition|(
name|ep
condition|)
block|{
operator|*
name|epc
operator|=
literal|0
expr_stmt|;
name|env_opt_add
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
name|ep
operator|=
name|epc
operator|=
operator|&
name|buf
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|ENV_ESC
case|:
name|i
operator|++
expr_stmt|;
comment|/*FALL THROUGH*/
default|default:
if|if
condition|(
name|epc
condition|)
operator|*
name|epc
operator|++
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ep
condition|)
block|{
operator|*
name|epc
operator|=
literal|0
expr_stmt|;
name|env_opt_add
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
block|}
name|env_opt_end
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TELQUAL_IS
case|:
case|case
name|TELQUAL_INFO
case|:
comment|/* Ignore for now.  We shouldn't get it anyway. */
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|OPT_REPLY_SIZE
value|256
end_define

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|opt_reply
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|opt_replyp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|opt_replyend
decl_stmt|;
end_decl_stmt

begin_macro
name|env_opt_start
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
if|if
condition|(
name|opt_reply
condition|)
name|opt_reply
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|opt_reply
argument_list|,
name|OPT_REPLY_SIZE
argument_list|)
expr_stmt|;
else|else
name|opt_reply
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|OPT_REPLY_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_reply
operator|==
name|NULL
condition|)
block|{
comment|/*@*/
name|printf
argument_list|(
literal|"env_opt_start: malloc()/realloc() failed!!!\n"
argument_list|)
expr_stmt|;
name|opt_reply
operator|=
name|opt_replyp
operator|=
name|opt_replyend
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|opt_replyp
operator|=
name|opt_reply
expr_stmt|;
name|opt_replyend
operator|=
name|opt_reply
operator|+
name|OPT_REPLY_SIZE
expr_stmt|;
operator|*
name|opt_replyp
operator|++
operator|=
name|IAC
expr_stmt|;
operator|*
name|opt_replyp
operator|++
operator|=
name|SB
expr_stmt|;
operator|*
name|opt_replyp
operator|++
operator|=
name|TELOPT_ENVIRON
expr_stmt|;
operator|*
name|opt_replyp
operator|++
operator|=
name|TELQUAL_IS
expr_stmt|;
block|}
end_block

begin_macro
name|env_opt_start_info
argument_list|()
end_macro

begin_block
block|{
name|env_opt_start
argument_list|()
expr_stmt|;
if|if
condition|(
name|opt_replyp
condition|)
name|opt_replyp
index|[
operator|-
literal|1
index|]
operator|=
name|TELQUAL_INFO
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|env_opt_add
argument_list|(
name|ep
argument_list|)
specifier|register
name|char
operator|*
name|ep
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|vp
decl_stmt|,
name|c
decl_stmt|;
specifier|extern
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|env_default
parameter_list|()
function_decl|;
if|if
condition|(
name|opt_reply
operator|==
name|NULL
condition|)
comment|/*XXX*/
return|return;
comment|/*XXX*/
if|if
condition|(
name|ep
operator|==
name|NULL
operator|||
operator|*
name|ep
operator|==
literal|'\0'
condition|)
block|{
name|env_default
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|ep
operator|=
name|env_default
argument_list|(
literal|0
argument_list|)
condition|)
name|env_opt_add
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
name|vp
operator|=
name|env_getvalue
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_replyp
operator|+
operator|(
name|vp
condition|?
name|strlen
argument_list|(
name|vp
argument_list|)
else|:
literal|0
operator|)
operator|+
name|strlen
argument_list|(
name|ep
argument_list|)
operator|+
literal|6
operator|>
name|opt_replyend
condition|)
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|opt_replyend
operator|+=
name|OPT_REPLY_SIZE
expr_stmt|;
name|len
operator|=
name|opt_replyend
operator|-
name|opt_reply
expr_stmt|;
name|opt_reply
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|opt_reply
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_reply
operator|==
name|NULL
condition|)
block|{
comment|/*@*/
name|printf
argument_list|(
literal|"env_opt_add: realloc() failed!!!\n"
argument_list|)
expr_stmt|;
name|opt_reply
operator|=
name|opt_replyp
operator|=
name|opt_replyend
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|opt_replyp
operator|=
name|opt_reply
operator|+
name|len
operator|-
operator|(
name|opt_replyend
operator|-
name|opt_replyp
operator|)
expr_stmt|;
name|opt_replyend
operator|=
name|opt_reply
operator|+
name|len
expr_stmt|;
block|}
operator|*
name|opt_replyp
operator|++
operator|=
name|ENV_VAR
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|c
operator|=
operator|*
name|ep
operator|++
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|IAC
case|:
operator|*
name|opt_replyp
operator|++
operator|=
name|IAC
expr_stmt|;
break|break;
case|case
name|ENV_VALUE
case|:
case|case
name|ENV_VAR
case|:
case|case
name|ENV_ESC
case|:
operator|*
name|opt_replyp
operator|++
operator|=
name|ENV_ESC
expr_stmt|;
break|break;
block|}
operator|*
name|opt_replyp
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|=
name|vp
condition|)
block|{
operator|*
name|opt_replyp
operator|++
operator|=
name|ENV_VALUE
expr_stmt|;
name|vp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
end_block

begin_expr_stmt
name|env_opt_end
argument_list|(
name|emptyok
argument_list|)
specifier|register
name|int
name|emptyok
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|len
operator|=
name|opt_replyp
operator|-
name|opt_reply
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|emptyok
operator|||
name|len
operator|>
literal|6
condition|)
block|{
operator|*
name|opt_replyp
operator|++
operator|=
name|IAC
expr_stmt|;
operator|*
name|opt_replyp
operator|++
operator|=
name|SE
expr_stmt|;
if|if
condition|(
name|NETROOM
argument_list|()
operator|>
name|len
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|opt_reply
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
operator|&
name|opt_reply
index|[
literal|2
index|]
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/*@*/
else|else
name|printf
argument_list|(
literal|"slc_end_reply: not enough room\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opt_reply
condition|)
block|{
name|free
argument_list|(
name|opt_reply
argument_list|)
expr_stmt|;
name|opt_reply
operator|=
name|opt_replyp
operator|=
name|opt_replyend
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_function
name|int
name|telrcv
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|scc
decl_stmt|;
specifier|register
name|char
modifier|*
name|sbp
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|returnValue
init|=
literal|0
decl_stmt|;
name|scc
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TTYROOM
argument_list|()
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|scc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|count
condition|)
block|{
name|ring_consumed
argument_list|(
operator|&
name|netiring
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|returnValue
operator|=
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|sbp
operator|=
name|netiring
operator|.
name|consume
expr_stmt|;
name|scc
operator|=
name|ring_full_consecutive
argument_list|(
operator|&
name|netiring
argument_list|)
expr_stmt|;
if|if
condition|(
name|scc
operator|==
literal|0
condition|)
block|{
comment|/* No more data coming in */
break|break;
block|}
block|}
name|c
operator|=
operator|*
name|sbp
operator|++
operator|&
literal|0xff
operator|,
name|scc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
switch|switch
condition|(
name|telrcv_state
condition|)
block|{
case|case
name|TS_CR
case|:
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
break|break;
comment|/* Ignore \0 after CR */
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'\n'
operator|)
operator|&&
name|my_want_state_is_dont
argument_list|(
name|TELOPT_ECHO
argument_list|)
operator|&&
operator|!
name|crmod
condition|)
block|{
name|TTYADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Else, fall through */
case|case
name|TS_DATA
case|:
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|telrcv_state
operator|=
name|TS_IAC
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
if|if
condition|(
name|In3270
condition|)
block|{
operator|*
name|Ifrontp
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|scc
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|sbp
operator|++
operator|&
literal|0377
operator|,
name|scc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|telrcv_state
operator|=
name|TS_IAC
expr_stmt|;
break|break;
block|}
operator|*
name|Ifrontp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
comment|/* defined(TN3270) */
comment|/* 		     * The 'crmod' hack (see following) is needed 		     * since we can't * set CRMOD on output only. 		     * Machines like MULTICS like to send \r without 		     * \n; since we must turn off CRMOD to get proper 		     * input, the mapping is done here (sigh). 		     */
if|if
condition|(
operator|(
name|c
operator|==
literal|'\r'
operator|)
operator|&&
name|my_want_state_is_dont
argument_list|(
name|TELOPT_BINARY
argument_list|)
condition|)
block|{
if|if
condition|(
name|scc
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|sbp
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|sbp
operator|++
operator|,
name|scc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
comment|/* a "true" CR */
name|TTYADD
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|my_want_state_is_dont
argument_list|(
name|TELOPT_ECHO
argument_list|)
operator|&&
operator|(
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|sbp
operator|++
operator|,
name|scc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|TTYADD
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TTYADD
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|crmod
condition|)
block|{
name|TTYADD
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|telrcv_state
operator|=
name|TS_CR
expr_stmt|;
name|TTYADD
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|crmod
condition|)
block|{
name|TTYADD
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|TTYADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|TS_IAC
case|:
name|process_iac
label|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|WILL
case|:
name|telrcv_state
operator|=
name|TS_WILL
expr_stmt|;
continue|continue;
case|case
name|WONT
case|:
name|telrcv_state
operator|=
name|TS_WONT
expr_stmt|;
continue|continue;
case|case
name|DO
case|:
name|telrcv_state
operator|=
name|TS_DO
expr_stmt|;
continue|continue;
case|case
name|DONT
case|:
name|telrcv_state
operator|=
name|TS_DONT
expr_stmt|;
continue|continue;
case|case
name|DM
case|:
comment|/* 		     * We may have missed an urgent notification, 		     * so make sure we flush whatever is in the 		     * buffer currently. 		     */
name|SYNCHing
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|ttyflush
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SYNCHing
operator|=
name|stilloob
argument_list|()
expr_stmt|;
name|settimer
argument_list|(
name|gotDM
argument_list|)
expr_stmt|;
break|break;
case|case
name|SB
case|:
name|SB_CLEAR
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_SB
expr_stmt|;
name|printoption
argument_list|(
literal|"RCVD"
argument_list|,
literal|"IAC"
argument_list|,
name|SB
argument_list|)
expr_stmt|;
continue|continue;
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
case|case
name|EOR
case|:
if|if
condition|(
name|In3270
condition|)
block|{
if|if
condition|(
name|Ibackp
operator|==
name|Ifrontp
condition|)
block|{
name|Ibackp
operator|=
name|Ifrontp
operator|=
name|Ibuf
expr_stmt|;
name|ISend
operator|=
literal|0
expr_stmt|;
comment|/* should have been! */
block|}
else|else
block|{
name|Ibackp
operator|+=
name|DataFromNetwork
argument_list|(
name|Ibackp
argument_list|,
name|Ifrontp
operator|-
name|Ibackp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ISend
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
comment|/* defined(TN3270) */
case|case
name|IAC
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TN3270
argument_list|)
name|TTYADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !defined(TN3270) */
if|if
condition|(
name|In3270
condition|)
block|{
operator|*
name|Ifrontp
operator|++
operator|=
name|IAC
expr_stmt|;
block|}
else|else
block|{
name|TTYADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !defined(TN3270) */
break|break;
case|case
name|NOP
case|:
case|case
name|GA
case|:
default|default:
name|printoption
argument_list|(
literal|"RCVD"
argument_list|,
literal|"IAC"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_WILL
case|:
name|printoption
argument_list|(
literal|"RCVD"
argument_list|,
literal|"will"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|willoption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_WONT
case|:
name|printoption
argument_list|(
literal|"RCVD"
argument_list|,
literal|"wont"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|wontoption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_DO
case|:
name|printoption
argument_list|(
literal|"RCVD"
argument_list|,
literal|"do"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|dooption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|SetIn3270
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|TELOPT_NAWS
condition|)
block|{
name|sendnaws
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|TELOPT_LFLOW
condition|)
block|{
name|localflow
operator|=
literal|1
expr_stmt|;
name|setcommandmode
argument_list|()
expr_stmt|;
name|setconnmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_DONT
case|:
name|printoption
argument_list|(
literal|"RCVD"
argument_list|,
literal|"dont"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|dontoption
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
name|setconnmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* set new tty mode (maybe) */
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
continue|continue;
case|case
name|TS_SB
case|:
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|telrcv_state
operator|=
name|TS_SE
expr_stmt|;
block|}
else|else
block|{
name|SB_ACCUM
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|TS_SE
case|:
if|if
condition|(
name|c
operator|!=
name|SE
condition|)
block|{
if|if
condition|(
name|c
operator|!=
name|IAC
condition|)
block|{
comment|/* 		     * This is an error.  We only expect to get 		     * "IAC IAC" or "IAC SE".  Several things may 		     * have happend.  An IAC was not doubled, the 		     * IAC SE was left off, or another option got 		     * inserted into the suboption are all possibilities. 		     * If we assume that the IAC was not doubled, 		     * and really the IAC SE was left off, we could 		     * get into an infinate loop here.  So, instead, 		     * we terminate the suboption, and process the 		     * partial suboption if we can. 		     */
name|SB_TERM
argument_list|()
expr_stmt|;
name|SB_ACCUM
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
name|SB_ACCUM
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"In SUBOPTION processing, RCVD"
argument_list|,
literal|"IAC"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|suboption
argument_list|()
expr_stmt|;
comment|/* handle sub-option */
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_IAC
expr_stmt|;
goto|goto
name|process_iac
goto|;
block|}
name|SB_ACCUM
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|telrcv_state
operator|=
name|TS_SB
expr_stmt|;
block|}
else|else
block|{
name|SB_TERM
argument_list|()
expr_stmt|;
name|SB_ACCUM
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
name|SB_ACCUM
argument_list|(
name|SE
argument_list|)
expr_stmt|;
name|suboption
argument_list|()
expr_stmt|;
comment|/* handle sub-option */
name|SetIn3270
argument_list|()
expr_stmt|;
name|telrcv_state
operator|=
name|TS_DATA
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|count
condition|)
name|ring_consumed
argument_list|(
operator|&
name|netiring
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|returnValue
operator|||
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|telsnd
parameter_list|()
block|{
name|int
name|tcc
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|returnValue
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tbp
decl_stmt|;
name|tcc
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|NETROOM
argument_list|()
operator|>
literal|2
condition|)
block|{
specifier|register
name|int
name|sc
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|tcc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|count
condition|)
block|{
name|ring_consumed
argument_list|(
operator|&
name|ttyiring
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|returnValue
operator|=
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|tbp
operator|=
name|ttyiring
operator|.
name|consume
expr_stmt|;
name|tcc
operator|=
name|ring_full_consecutive
argument_list|(
operator|&
name|ttyiring
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcc
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|c
operator|=
operator|*
name|tbp
operator|++
operator|&
literal|0xff
operator|,
name|sc
operator|=
name|strip
argument_list|(
name|c
argument_list|)
operator|,
name|tcc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|escape
condition|)
block|{
comment|/* 	     * Double escape is a pass through of a single escape character. 	     */
if|if
condition|(
name|tcc
operator|&&
name|strip
argument_list|(
operator|*
name|tbp
argument_list|)
operator|==
name|escape
condition|)
block|{
name|tbp
operator|++
expr_stmt|;
name|tcc
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|command
argument_list|(
literal|0
argument_list|,
name|tbp
argument_list|,
name|tcc
argument_list|)
expr_stmt|;
name|count
operator|+=
name|tcc
expr_stmt|;
name|tcc
operator|=
literal|0
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
if|if
condition|(
name|kludgelinemode
operator|&&
operator|(
name|globalmode
operator|&
name|MODE_EDIT
operator|)
operator|&&
operator|(
name|sc
operator|==
name|echoc
operator|)
condition|)
block|{
if|if
condition|(
name|tcc
operator|>
literal|0
operator|&&
name|strip
argument_list|(
operator|*
name|tbp
argument_list|)
operator|==
name|echoc
condition|)
block|{
name|tcc
operator|--
expr_stmt|;
name|tbp
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|dontlecho
operator|=
operator|!
name|dontlecho
expr_stmt|;
name|settimer
argument_list|(
name|echotoggle
argument_list|)
expr_stmt|;
name|setconnmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|MODE_LOCAL_CHARS
argument_list|(
name|globalmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|TerminalSpecialChars
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_BINARY
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* 		     * If we are in CRMOD mode (\r ==> \n) 		     * on our local machine, then probably 		     * a newline (unix) is CRLF (TELNET). 		     */
if|if
condition|(
name|MODE_LOCAL_CHARS
argument_list|(
name|globalmode
argument_list|)
condition|)
block|{
name|NETADD
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
name|NETADD
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
if|if
condition|(
operator|!
name|crlf
condition|)
block|{
name|NET2ADD
argument_list|(
literal|'\r'
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NET2ADD
argument_list|(
literal|'\r'
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|flushline
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IAC
case|:
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|IAC
argument_list|)
expr_stmt|;
break|break;
default|default:
name|NETADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|IAC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NETADD
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
condition|)
name|ring_consumed
argument_list|(
operator|&
name|ttyiring
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|returnValue
operator|||
name|count
return|;
comment|/* Non-zero if we did anything */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Scheduler()  *  * Try to do something.  *  * If we do something useful, return 1; else return 0.  *  */
end_comment

begin_function
name|int
name|Scheduler
parameter_list|(
name|block
parameter_list|)
name|int
name|block
decl_stmt|;
comment|/* should we block in the select ? */
block|{
comment|/* One wants to be a bit careful about setting returnValue 		 * to one, since a one implies we did some useful work, 		 * and therefore probably won't be called to block next 		 * time (TN3270 mode only). 		 */
name|int
name|returnValue
decl_stmt|;
name|int
name|netin
decl_stmt|,
name|netout
decl_stmt|,
name|netex
decl_stmt|,
name|ttyin
decl_stmt|,
name|ttyout
decl_stmt|;
comment|/* Decide which rings should be processed */
name|netout
operator|=
name|ring_full_count
argument_list|(
operator|&
name|netoring
argument_list|)
operator|&&
operator|(
name|flushline
operator|||
operator|(
name|my_want_state_is_wont
argument_list|(
name|TELOPT_LINEMODE
argument_list|)
ifdef|#
directive|ifdef
name|KLUDGELINEMODE
operator|&&
operator|(
operator|!
name|kludgelinemode
operator|||
name|my_want_state_is_do
argument_list|(
name|TELOPT_SGA
argument_list|)
operator|)
endif|#
directive|endif
operator|)
operator|||
name|my_want_state_is_will
argument_list|(
name|TELOPT_BINARY
argument_list|)
operator|)
expr_stmt|;
name|ttyout
operator|=
name|ring_full_count
argument_list|(
operator|&
name|ttyoring
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
name|ttyin
operator|=
name|ring_empty_count
argument_list|(
operator|&
name|ttyiring
argument_list|)
operator|&&
operator|(
name|shell_active
operator|==
literal|0
operator|)
expr_stmt|;
else|#
directive|else
comment|/* defined(TN3270) */
name|ttyin
operator|=
name|ring_empty_count
argument_list|(
operator|&
name|ttyiring
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(TN3270) */
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
name|netin
operator|=
name|ring_empty_count
argument_list|(
operator|&
name|netiring
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !defined(TN3270) */
name|netin
operator|=
operator|!
name|ISend
operator|&&
name|ring_empty_count
argument_list|(
operator|&
name|netiring
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(TN3270) */
name|netex
operator|=
operator|!
name|SYNCHing
expr_stmt|;
comment|/* If we have seen a signal recently, reset things */
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
operator|&&
name|defined
argument_list|(
name|unix
argument_list|)
if|if
condition|(
name|HaveInput
condition|)
block|{
name|HaveInput
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|inputAvailable
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(TN3270)&& defined(unix) */
comment|/* Call to system code to process rings */
name|returnValue
operator|=
name|process_rings
argument_list|(
name|netin
argument_list|,
name|netout
argument_list|,
name|netex
argument_list|,
name|ttyin
argument_list|,
name|ttyout
argument_list|,
operator|!
name|block
argument_list|)
expr_stmt|;
comment|/* Now, look at the input rings, looking for work to do. */
if|if
condition|(
name|ring_full_count
argument_list|(
operator|&
name|ttyiring
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
if|if
condition|(
name|In3270
condition|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|DataFromTerminal
argument_list|(
name|ttyiring
operator|.
name|consume
argument_list|,
name|ring_full_consecutive
argument_list|(
operator|&
name|ttyiring
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
name|returnValue
operator|=
literal|1
expr_stmt|;
name|ring_consumed
argument_list|(
operator|&
name|ttyiring
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
comment|/* defined(TN3270) */
name|returnValue
operator||=
name|telsnd
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TN3270
argument_list|)
block|}
endif|#
directive|endif
comment|/* defined(TN3270) */
block|}
if|if
condition|(
name|ring_full_count
argument_list|(
operator|&
name|netiring
argument_list|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TN3270
argument_list|)
name|returnValue
operator||=
name|telrcv
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* !defined(TN3270) */
name|returnValue
operator|=
name|Push3270
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(TN3270) */
block|}
return|return
name|returnValue
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Select from tty and network...  */
end_comment

begin_function
name|void
name|telnet
parameter_list|()
block|{
name|sys_telnet_init
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TN3270
argument_list|)
if|if
condition|(
name|telnetport
condition|)
block|{
name|send_do
argument_list|(
name|TELOPT_SGA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|TELOPT_TTYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|TELOPT_NAWS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|TELOPT_TSPEED
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|TELOPT_LFLOW
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|TELOPT_LINEMODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KERBEROS
if|if
condition|(
name|kerberized
condition|)
name|send_will
argument_list|(
name|TELOPT_AUTHENTICATION
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|send_do
argument_list|(
name|TELOPT_STATUS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_getvalue
argument_list|(
literal|"DISPLAY"
argument_list|)
condition|)
name|send_will
argument_list|(
name|TELOPT_XDISPLOC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|send_will
argument_list|(
name|TELOPT_ENVIRON
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !defined(TN3270) */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TN3270
argument_list|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|schedValue
decl_stmt|;
while|while
condition|(
operator|(
name|schedValue
operator|=
name|Scheduler
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|schedValue
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|Scheduler
argument_list|(
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|#
directive|else
comment|/* !defined(TN3270) */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|schedValue
decl_stmt|;
while|while
condition|(
operator|!
name|In3270
operator|&&
operator|!
name|shell_active
condition|)
block|{
if|if
condition|(
name|Scheduler
argument_list|(
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
while|while
condition|(
operator|(
name|schedValue
operator|=
name|Scheduler
argument_list|(
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|schedValue
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/* If there is data waiting to go out to terminal, don't 		 * schedule any more data for the terminal. 		 */
if|if
condition|(
name|ring_full_count
argument_list|(
operator|&
name|ttyoring
argument_list|)
condition|)
block|{
name|schedValue
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|shell_active
condition|)
block|{
if|if
condition|(
name|shell_continue
argument_list|()
operator|==
literal|0
condition|)
block|{
name|ConnectScreen
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|In3270
condition|)
block|{
name|schedValue
operator|=
name|DoTerminalOutput
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|schedValue
operator|&&
operator|(
name|shell_active
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|Scheduler
argument_list|(
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setcommandmode
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* !defined(TN3270) */
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* XXX - this not being in is a bug */
end_comment

begin_comment
comment|/*  * nextitem()  *  *	Return the address of the next "item" in the TELNET data  * stream.  This will be the address of the next character if  * the current address is a user data character, or it will  * be the address of the character following the TELNET command  * if the current address is a TELNET IAC ("I Am a Command")  * character.  */
end_comment

begin_comment
unit|static char * nextitem(current) char	*current; {     if ((*current&0xff) != IAC) { 	return current+1;     }     switch (*(current+1)&0xff) {     case DO:     case DONT:     case WILL:     case WONT: 	return current+3;     case SB:
comment|/* loop forever looking for the SE */
end_comment

begin_endif
unit|{ 	    register char *look = current+2;  	    for (;;) { 		if ((*look++&0xff) == IAC) { 		    if ((*look++&0xff) == SE) { 			return look; 		    } 		} 	    } 	}     default: 	return current+2;     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/*  * netclear()  *  *	We are about to do a TELNET SYNCH operation.  Clear  * the path to the network.  *  *	Things are a bit tricky since we may have sent the first  * byte or so of a previous TELNET command into the network.  * So, we have to scan the network buffer from the beginning  * until we are up to where we want to be.  *  *	A side effect of what we do, just to keep things  * simple, is to clear the urgent data pointer.  The principal  * caller should be setting the urgent data pointer AFTER calling  * us in any case.  */
end_comment

begin_function
specifier|static
name|void
name|netclear
parameter_list|()
block|{
if|#
directive|if
literal|0
comment|/* XXX */
block|register char *thisitem, *next;     char *good;
define|#
directive|define
name|wewant
parameter_list|(
name|p
parameter_list|)
value|((nfrontp> p)&& ((*p&0xff) == IAC)&& \ 				((*(p+1)&0xff) != EC)&& ((*(p+1)&0xff) != EL))
block|thisitem = netobuf;      while ((next = nextitem(thisitem))<= netobuf.send) { 	thisitem = next;     }
comment|/* Now, thisitem is first before/at boundary. */
block|good = netobuf;
comment|/* where the good bytes go */
block|while (netoring.add> thisitem) { 	if (wewant(thisitem)) { 	    int length;  	    next = thisitem; 	    do { 		next = nextitem(next); 	    } while (wewant(next)&& (nfrontp> next)); 	    length = next-thisitem; 	    memcpy(good, thisitem, length); 	    good += length; 	    thisitem = next; 	} else { 	    thisitem = nextitem(thisitem); 	}     }
endif|#
directive|endif
comment|/* 0 */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * These routines add various telnet commands to the data stream.  */
end_comment

begin_function
specifier|static
name|void
name|doflush
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|DO
argument_list|)
expr_stmt|;
name|NETADD
argument_list|(
name|TELOPT_TM
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
name|flushout
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|ttyflush
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Flush/drop output */
comment|/* do printoption AFTER flush, otherwise the output gets tossed... */
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
literal|"do"
argument_list|,
name|TELOPT_TM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xmitAO
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|AO
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
literal|"IAC"
argument_list|,
name|AO
argument_list|)
expr_stmt|;
if|if
condition|(
name|autoflush
condition|)
block|{
name|doflush
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xmitEL
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|EL
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
literal|"IAC"
argument_list|,
name|EL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xmitEC
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|EC
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
literal|"IAC"
argument_list|,
name|EC
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NOT43
argument_list|)
end_if

begin_function
name|int
else|#
directive|else
comment|/* defined(NOT43) */
name|void
endif|#
directive|endif
comment|/* defined(NOT43) */
name|dosynch
parameter_list|()
block|{
name|netclear
argument_list|()
expr_stmt|;
comment|/* clear the path to the network */
name|NETADD
argument_list|(
name|IAC
argument_list|)
expr_stmt|;
name|setneturg
argument_list|()
expr_stmt|;
name|NETADD
argument_list|(
name|DM
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
literal|"IAC"
argument_list|,
name|DM
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NOT43
argument_list|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* defined(NOT43) */
block|}
end_function

begin_function
name|void
name|get_status
parameter_list|()
block|{
name|char
name|tmp
index|[
literal|16
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|my_want_state_is_dont
argument_list|(
name|TELOPT_STATUS
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Remote side does not support STATUS option\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|showoptions
condition|)
name|printf
argument_list|(
literal|"You will not see the response unless you set \"options\"\n"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|tmp
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|IAC
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|SB
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|TELOPT_STATUS
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|TELQUAL_SEND
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|IAC
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|SE
expr_stmt|;
if|if
condition|(
name|NETROOM
argument_list|()
operator|>=
name|cp
operator|-
name|tmp
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|tmp
argument_list|,
name|cp
operator|-
name|tmp
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
name|tmp
operator|+
literal|2
argument_list|,
name|cp
operator|-
name|tmp
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|intp
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|IP
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
literal|"IAC"
argument_list|,
name|IP
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|autoflush
condition|)
block|{
name|doflush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|autosynch
condition|)
block|{
name|dosynch
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sendbrk
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|BREAK
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
literal|"IAC"
argument_list|,
name|BREAK
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|autoflush
condition|)
block|{
name|doflush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|autosynch
condition|)
block|{
name|dosynch
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sendabort
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|ABORT
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
literal|"IAC"
argument_list|,
name|ABORT
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|autoflush
condition|)
block|{
name|doflush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|autosynch
condition|)
block|{
name|dosynch
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sendsusp
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|SUSP
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
literal|"IAC"
argument_list|,
name|SUSP
argument_list|)
expr_stmt|;
name|flushline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|autoflush
condition|)
block|{
name|doflush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|autosynch
condition|)
block|{
name|dosynch
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sendeof
parameter_list|()
block|{
name|NET2ADD
argument_list|(
name|IAC
argument_list|,
name|xEOF
argument_list|)
expr_stmt|;
name|printoption
argument_list|(
literal|"SENT"
argument_list|,
literal|"IAC"
argument_list|,
name|xEOF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a window size update to the remote system.  */
end_comment

begin_function
name|void
name|sendnaws
parameter_list|()
block|{
name|long
name|rows
decl_stmt|,
name|cols
decl_stmt|;
name|unsigned
name|char
name|tmp
index|[
literal|16
index|]
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|my_state_is_wont
argument_list|(
name|TELOPT_NAWS
argument_list|)
condition|)
return|return;
define|#
directive|define
name|PUTSHORT
parameter_list|(
name|cp
parameter_list|,
name|x
parameter_list|)
value|{ if ((*cp++ = ((x)>>8)&0xff) == IAC) *cp++ = IAC; \ 			    if ((*cp++ = ((x))&0xff) == IAC) *cp++ = IAC; }
if|if
condition|(
name|TerminalWindowSize
argument_list|(
operator|&
name|rows
argument_list|,
operator|&
name|cols
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Failed */
return|return;
block|}
name|cp
operator|=
name|tmp
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|IAC
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|SB
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|TELOPT_NAWS
expr_stmt|;
name|PUTSHORT
argument_list|(
name|cp
argument_list|,
name|cols
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|cp
argument_list|,
name|rows
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|IAC
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|SE
expr_stmt|;
if|if
condition|(
name|NETROOM
argument_list|()
operator|>=
name|cp
operator|-
name|tmp
condition|)
block|{
name|ring_supply_data
argument_list|(
operator|&
name|netoring
argument_list|,
name|tmp
argument_list|,
name|cp
operator|-
name|tmp
argument_list|)
expr_stmt|;
name|printsub
argument_list|(
literal|'>'
argument_list|,
name|tmp
operator|+
literal|2
argument_list|,
name|cp
operator|-
name|tmp
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|tel_enter_binary
argument_list|(
argument|rw
argument_list|)
end_macro

begin_decl_stmt
name|int
name|rw
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|rw
operator|&
literal|1
condition|)
name|send_do
argument_list|(
name|TELOPT_BINARY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|&
literal|2
condition|)
name|send_will
argument_list|(
name|TELOPT_BINARY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|tel_leave_binary
argument_list|(
argument|rw
argument_list|)
end_macro

begin_decl_stmt
name|int
name|rw
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|rw
operator|&
literal|1
condition|)
name|send_dont
argument_list|(
name|TELOPT_BINARY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|&
literal|2
condition|)
name|send_wont
argument_list|(
name|TELOPT_BINARY
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

