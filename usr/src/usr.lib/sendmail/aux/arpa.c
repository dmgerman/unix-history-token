begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* **  Sendmail **  Copyright (c) 1983  Eric P. Allman **  Berkeley, California ** **  Copyright (c) 1983 Regents of the University of California. **  All rights reserved.  The Berkeley software License Agreement **  specifies the terms and conditions for redistribution. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|SccsId
index|[]
init|=
literal|"@(#)arpa.c	5.1 (Berkeley) 6/7/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<whoami.h>
end_include

begin_include
include|#
directive|include
file|"useful.h"
end_include

begin_decl_stmt
name|char
name|Version
index|[]
init|=
literal|"@(#)Arpa-mailer version 5.1 of 6/7/85"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|void
value|int
end_define

begin_comment
comment|/* **  ARPA MAILER -- Queue ARPANET mail for eventual delivery ** **	The standard input is stuck away in the outgoing arpanet **	mail queue for delivery by the true arpanet mailer. ** **		CUSTOMIZED FOR THE C/70 ** **	Usage: **		/usr/lib/mailers/arpa from host user ** **	Positional Parameters: **		from -- the person sending the mail. **		host -- the host to send the mail to. **		user -- the user to send the mail to. ** **	Flags: **		-T -- debug flag. ** **	Files: **		/usr/spool/netmail/* -- the queue file. ** **	Return Codes: **		0 -- all messages successfully mailed. **		2 -- user or host unknown. **		3 -- service unavailable, probably temporary **			file system condition. **		4 -- syntax error in address. ** **	Compilation Flags: **		SPOOLDIR -- the spool directory ** **	Compilation Instructions: **		cc -n -O -s arpa-mailer.c -o arpa-mailer -lX **		chmod 755 arpa-mailer **		mv arpa-mailer /usr/lib/mailers/arpa ** **	Author: **		Eric Allman, UCB/INGRES (eric@berkeley) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|C70
end_ifdef

begin_define
define|#
directive|define
name|SPOOLDIR
value|"/usr/netmail"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SPOOLDIR
value|"/usr/spool/netmail"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|From
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* person sending this mail */
end_comment

begin_decl_stmt
name|char
modifier|*
name|To
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current "To:" person */
end_comment

begin_decl_stmt
name|int
name|State
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the current state (for exit codes) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|bool
name|Tflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -T given */
end_comment

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

begin_decl_stmt
name|char
name|FromHost
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string to prepend to addresses */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **  MAIN -- Main program for arpa mailer ** **	Processes arguments, and calls sendmail successively on **	the To: list. ** **	Algorithm: **		Scan for debug flag. **		Catch interrupt signals. **		Collect input file name and from person. **		If more than one person in the to list, and **			if the input file is not a real file, **			collect input into a temp file. **		For each person in the to list **			Send to that person. ** **	Parameters: **		argc **		argv -- as usual ** **	Returns: **		via exit ** **	Side Effects: **		Mail gets sent. ** **	Author: **		Eric Allman UCB/INGRES. */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|ifd
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
specifier|extern
name|int
name|done
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|locv
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|lastmark
decl_stmt|;
name|State
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|done
argument_list|)
expr_stmt|;
comment|/* process flags */
name|argv
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-T"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Tflag
operator|++
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|rexit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
comment|/* decode parameters */
name|From
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|lastmark
operator|=
operator|&
name|FromHost
index|[
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
name|From
operator|,
name|q
operator|=
name|FromHost
init|;
operator|(
operator|*
name|q
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
condition|;
name|p
operator|++
operator|,
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
operator|*
name|q
operator|=
operator|*
name|p
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'.'
operator|||
operator|*
name|q
operator|==
literal|'!'
operator|||
operator|*
name|q
operator|==
literal|'@'
condition|)
name|lastmark
operator|=
name|q
expr_stmt|;
block|}
name|lastmark
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* start sending mail */
name|State
operator|=
name|sendmail
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* all done, clean up */
name|done
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  DONE -- Finish up, remove temp files, etc. ** **	This does basic cleanup on interrupt, error, or **	normal termination.  It uses "State" to tell which **	is happening. ** **	Parameters: **		none ** **	Returns: **		none ** **	Side Effects: **		Exit(State). */
end_comment

begin_macro
name|done
argument_list|()
end_macro

begin_block
block|{
name|rexit
argument_list|(
name|State
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** REXIT -- exit, reporting error code if -T given ** **	Parameters: **		e -- error code to exit with; see sysexits.h ** **	Returns: **		none ** **	Side Effects: **		Exit(e). */
end_comment

begin_macro
name|rexit
argument_list|(
argument|e
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Tflag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"arpa-mail: return code %d\n"
argument_list|,
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SENDMAIL -- Queue up mail for the arpanet mailer. ** **	The mail is inserted with proper headers into the **	arpanet queue directory. ** **	Algorithm: **		decode "to" address **			if error, exit. **		create a spool file name. **		output the header information to spool file, **		  separate names in To:, CC: fields with commas. **		copy the mail to the spool file. ** **	Parameters: **		host -- the host to send to. **		user -- the user to send to. ** **	Returns: **		none ** **	Side Effects: **		the mail is copied into a file in the network **			queue directory (/usr/spool/netmail). */
end_comment

begin_macro
name|sendmail
argument_list|(
argument|host
argument_list|,
argument|user
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|host
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|user
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|spoolfile
index|[
literal|50
index|]
decl_stmt|;
comment|/* gets the spool file name */
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|int
name|callnum
decl_stmt|;
comment|/* for the final letter on spoolfile */
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|sfp
decl_stmt|;
comment|/* spool file */
specifier|register
name|int
name|c
decl_stmt|;
specifier|extern
name|char
modifier|*
name|matchhdr
parameter_list|()
function_decl|;
comment|/* verify that the host exists */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"/dev/net/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|host
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|C70
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|Tflag
condition|)
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|host
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|access
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EX_NOHOST
operator|)
return|;
endif|#
directive|endif
endif|C70
comment|/* 	**  Create spool file name. 	**	Format is "username000nnX", where username is 	**	padded on the right with zeros and nn (the process 	**	id) is padded on the left with zeros; X is a unique 	**	sequence character. 	*/
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Tflag
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|spoolfile
argument_list|,
literal|"arpa.out"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
endif|DEBUG
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|spoolfile
argument_list|,
literal|"%s/arpamail%05d%c"
argument_list|,
name|SPOOLDIR
argument_list|,
name|getpid
argument_list|()
argument_list|,
literal|'a'
operator|+
name|callnum
operator|++
argument_list|)
expr_stmt|;
comment|/* create spool file */
name|sfp
operator|=
name|fopen
argument_list|(
name|spoolfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfp
operator|==
name|NULL
condition|)
block|{
name|spoolerr
label|:
return|return
operator|(
name|EX_OSERR
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|Tflag
condition|)
endif|#
directive|endif
endif|DEBUG
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|spoolfile
argument_list|,
literal|0400
argument_list|)
expr_stmt|;
comment|/* 	** Output mailer control lines. 	**	These lines are as follows: 	**		/dev/net/<hostname> {target host} 	**		user-name {at target host} 	**		/mnt/eric {pathname of sender; not used} 	**		eric {name of user who is sending} 	**	These are different (but close) on the C/70. 	*/
ifdef|#
directive|ifdef
name|C70
name|fputs
argument_list|(
name|host
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|":"
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|user
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|":"
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|From
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
else|#
directive|else
name|fputs
argument_list|(
name|buf
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|user
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|From
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	**  Output the mail 	**	Check the first line for the date.  If not found, 	**	assume the message is not in arpanet standard format 	**	and output a "Date:" and "From:" header. 	*/
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* no message */
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|spoolfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_OK
operator|)
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
literal|"From "
argument_list|,
name|buf
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* strip Unix "From" line */
comment|/* should save the date here */
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|matchhdr
argument_list|(
name|buf
argument_list|,
literal|"mail-from"
argument_list|)
operator|!=
name|NULL
operator|||
name|matchhdr
argument_list|(
name|buf
argument_list|,
literal|"sender-path"
argument_list|)
operator|!=
name|NULL
operator|||
name|matchhdr
argument_list|(
name|buf
argument_list|,
literal|"received"
argument_list|)
operator|!=
name|NULL
operator|||
name|matchhdr
argument_list|(
name|buf
argument_list|,
literal|"via"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fputs
argument_list|(
name|buf
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|matchhdr
argument_list|(
name|buf
argument_list|,
literal|"date"
argument_list|)
operator|==
name|NULL
condition|)
name|putdate
argument_list|(
name|sfp
argument_list|)
expr_stmt|;
else|else
block|{
name|fputs
argument_list|(
name|buf
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|matchhdr
argument_list|(
name|buf
argument_list|,
literal|"from"
argument_list|)
operator|==
name|NULL
condition|)
name|putfrom
argument_list|(
name|sfp
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* hack to support sendmail -- for a while */
if|if
condition|(
name|index
argument_list|(
name|buf
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
name|putfrom
argument_list|(
name|sfp
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|buf
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ishdr
argument_list|(
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
goto|goto
name|hdrdone
goto|;
block|}
comment|/* 	** At this point, we have a message with REAL headers. 	** We look at each head line and insert commas if it 	** is a To: or Cc: field. 	*/
do|do
block|{
if|if
condition|(
operator|!
name|ishdr
argument_list|(
name|buf
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|matchhdr
argument_list|(
name|buf
argument_list|,
literal|"to"
argument_list|)
operator|&&
operator|!
name|matchhdr
argument_list|(
name|buf
argument_list|,
literal|"cc"
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
name|buf
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* gotcha! */
name|fixaddr
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|c
operator|=
name|peekc
argument_list|(
name|stdin
argument_list|)
argument_list|)
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|fixaddr
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
do|;
name|hdrdone
label|:
comment|/* output the rest of the header& the body of the letter */
do|do
block|{
name|fputs
argument_list|(
name|buf
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|sfp
argument_list|)
condition|)
goto|goto
name|spoolerr
goto|;
block|}
do|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
do|;
comment|/* all done! */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|sfp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_OK
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  FIXADDR -- Output header line with needed commas. ** **	Parameters: **		buf -- header line **		first -- true if this is not a continuation ** **	Returns: **		none ** **	Side effects: **		The contents of buf is copied onto the spool file with **		with the right commas interlaced ** **	Called by: **		sendmail */
end_comment

begin_macro
name|fixaddr
argument_list|(
argument|buf
argument_list|,
argument|first
argument_list|,
argument|spf
argument_list|)
end_macro

begin_decl_stmt
name|char
name|buf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|spf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
name|word
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|word2
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|gword
parameter_list|()
function_decl|;
specifier|static
name|char
name|wsep
index|[]
init|=
literal|", "
decl_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
while|while
condition|(
operator|*
name|cp
operator|!=
literal|':'
operator|&&
operator|*
name|cp
condition|)
name|putc
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|spf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|':'
condition|)
block|{
name|fputs
argument_list|(
literal|": "
argument_list|,
name|spf
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
block|}
else|else
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|putc
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|spf
argument_list|)
expr_stmt|;
name|cp
operator|=
name|gword
argument_list|(
name|word
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|word
argument_list|)
operator|==
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|spf
argument_list|)
expr_stmt|;
goto|goto
name|test
goto|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|cp
operator|=
name|gword
argument_list|(
name|word2
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|word2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|putaddr
argument_list|(
name|word
argument_list|,
name|spf
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|word2
argument_list|,
literal|"%"
argument_list|)
operator|==
literal|0
condition|)
name|word2
index|[
literal|0
index|]
operator|=
literal|'@'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|word2
argument_list|,
literal|"@"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|word2
argument_list|,
literal|"at"
argument_list|)
condition|)
block|{
name|putaddr
argument_list|(
name|word
argument_list|,
name|spf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|wsep
argument_list|,
name|spf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|word
argument_list|,
name|word2
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fputs
argument_list|(
name|word
argument_list|,
name|spf
argument_list|)
expr_stmt|;
if|if
condition|(
name|word2
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
name|putc
argument_list|(
literal|'@'
argument_list|,
name|spf
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|" at "
argument_list|,
name|spf
argument_list|)
expr_stmt|;
name|cp
operator|=
name|gword
argument_list|(
name|word
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|word
argument_list|,
name|spf
argument_list|)
expr_stmt|;
name|cp
operator|=
name|gword
argument_list|(
name|word
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|word
argument_list|)
condition|)
name|fputs
argument_list|(
name|wsep
argument_list|,
name|spf
argument_list|)
expr_stmt|;
block|}
name|test
label|:
name|c
operator|=
name|peekc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|fputs
argument_list|(
literal|",\n"
argument_list|,
name|spf
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|spf
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PUTADDR -- output address onto file ** **	Putaddr prepends the network header onto the address **	unless one already exists. ** **	Parameters: **		name -- the name to output. **		fp -- the file to put it on. ** **	Returns: **		none. ** **	Side Effects: **		name is put onto fp. */
end_comment

begin_macro
name|putaddr
argument_list|(
argument|name
argument_list|,
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|'.'
operator|&&
operator|*
name|p
operator|!=
literal|'@'
operator|&&
operator|*
name|p
operator|!=
literal|'!'
operator|&&
operator|*
name|p
operator|!=
literal|'^'
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
operator|*
name|p
operator|=
literal|'.'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|fputs
argument_list|(
name|FromHost
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|name
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'@'
condition|)
name|fputs
argument_list|(
literal|"@Berkeley"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PEEKC -- peek at next character in input file ** **	Parameters: **		fp -- stdio file buffer ** **	Returns: **		the next character in the input or EOF ** **	Side effects: **		None. */
end_comment

begin_expr_stmt
name|peekc
argument_list|(
name|fp
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  GWORD -- get the next liberal word from a string ** **	Parameters: **		buf -- place to put scanned word **		p -- place to start looking for word ** **	Returns: **		updated value of p or 0 if no more left after this ** **	Side effects: **		buf gets the liberal word scanned. **		buf will be length 0 if there is no more input, **		or if p was passed as 0 */
end_comment

begin_function
name|char
modifier|*
name|gword
parameter_list|(
name|buf
parameter_list|,
name|p
parameter_list|)
name|char
name|buf
index|[]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|atfound
init|=
literal|0
decl_stmt|;
comment|/* weither or not a '@' found in the scan */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sp
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|&&
operator|(
name|isspace
argument_list|(
operator|*
name|sp
argument_list|)
operator|||
operator|*
name|sp
operator|==
literal|','
operator|)
condition|)
name|sp
operator|++
expr_stmt|;
name|dp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|!=
literal|'%'
operator|&&
operator|*
name|sp
operator|!=
literal|'@'
condition|)
block|{
while|while
condition|(
operator|*
name|sp
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|sp
argument_list|)
operator|&&
operator|*
name|sp
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'@'
operator|||
operator|*
name|sp
operator|==
literal|'%'
condition|)
name|atfound
operator|++
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|atfound
condition|)
block|{
name|dp
operator|--
expr_stmt|;
while|while
condition|(
operator|*
name|dp
operator|!=
literal|'@'
operator|&&
operator|*
name|dp
operator|!=
literal|'%'
condition|)
name|dp
operator|--
operator|,
name|sp
operator|--
expr_stmt|;
name|sp
operator|--
expr_stmt|;
block|}
block|}
else|else
operator|*
name|dp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  ISHDR -- see if the passed line is a ARPA style header line ** **	Parameters: **		buf -- header line ** **	Returns: **		non-zero if the line is a header line, else zero ** **	Side effects: **		none ** **	Called by: **		sendmail */
end_comment

begin_macro
name|ishdr
argument_list|(
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|char
name|buf
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
comment|/* check for continuation lines */
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
block|{
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|!=
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PUTDATE -- Put the date field into the message. ** **	Parameters: **		fp -- file to put it onto. ** **	Returns: **		none ** **	Side Effects: **		output onto fp. */
end_comment

begin_expr_stmt
name|putdate
argument_list|(
name|fp
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|arpadate
parameter_list|()
function_decl|;
name|fputs
argument_list|(
literal|"Date: "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|arpadate
argument_list|(
name|NULL
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PUTFROM -- Put the from field into the message. ** **	Parameters: **		fp -- file to put it onto. ** **	Returns: **		none ** **	Side Effects: **		output onto fp. */
end_comment

begin_expr_stmt
name|putfrom
argument_list|(
name|fp
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|fputs
argument_list|(
literal|"From: "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|From
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@Berkeley\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

