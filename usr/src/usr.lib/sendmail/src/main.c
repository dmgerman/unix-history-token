begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Eric P. Allman  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1988 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)main.c	5.18 (Berkeley) 6/30/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_define
define|#
directive|define
name|_DEFINE
end_define

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_decl_stmt
name|char
name|edata
decl_stmt|,
name|end
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/* **  SENDMAIL -- Post mail to a set of destinations. ** **	This is the basic mail router.  All user mail programs should **	call this routine to actually deliver mail.  Sendmail in **	turn calls a bunch of mail servers that do the real work of **	delivering the mail. ** **	Sendmail is driven by tables read in from /usr/lib/sendmail.cf **	(read by readcf.c).  Some more static configuration info, **	including some code that you may want to tailor for your **	installation, is in conf.c.  You may also want to touch **	daemon.c (if you have some other IPC mechanism), acct.c **	(to change your accounting), names.c (to adjust the name **	server mechanism). ** **	Usage: **		/usr/lib/sendmail [flags] addr ... ** **		See the associated documentation for details. ** **	Author: **		Eric Allman, UCB/INGRES (until 10/81) **			     Britton-Lee, Inc., purveyors of fine **				database computers (from 11/81) **		The support of the INGRES Project and Britton-Lee is **			gratefully acknowledged.  Britton-Lee in **			particular had absolutely nothing to gain from **			my involvement in this project. */
end_comment

begin_decl_stmt
name|int
name|NextMailer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "free" index into Mailer struct */
end_comment

begin_decl_stmt
name|char
modifier|*
name|FullName
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sender's full name */
end_comment

begin_decl_stmt
name|ENVELOPE
name|BlankEnvelope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a "blank" envelope */
end_comment

begin_decl_stmt
name|ENVELOPE
name|MainEnvelope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the envelope around the basic letter */
end_comment

begin_decl_stmt
name|ADDRESS
name|NullAddress
init|=
comment|/* a null address */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  Pointers for setproctitle. **	This allows "ps" listings to give more useful information. **	These must be kept out of BSS for frozen configuration files **		to work. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SETPROCTITLE
end_ifdef

begin_decl_stmt
name|char
modifier|*
modifier|*
name|Argv
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to argument vector */
end_comment

begin_decl_stmt
name|char
modifier|*
name|LastArgv
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of argv */
end_comment

begin_endif
endif|#
directive|endif
endif|SETPROCTITLE
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DAEMON
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|SMTP
end_ifndef

begin_expr_stmt
name|ERROR
operator|%
operator|%
operator|%
operator|%
name|Cannot
name|have
name|daemon
name|mode
name|without
name|SMTP
operator|%
operator|%
operator|%
operator|%
name|ERROR
endif|#
directive|endif
endif|SMTP
endif|#
directive|endif
endif|DAEMON
expr|main
operator|(
name|argc
operator|,
name|argv
operator|,
name|envp
operator|)
name|int
name|argc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
specifier|extern
name|int
name|finis
parameter_list|()
function_decl|;
specifier|extern
name|char
name|Version
index|[]
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|fnptr
function_decl|)
parameter_list|()
function_decl|;
name|STAB
modifier|*
name|st
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|bool
name|readconfig
init|=
name|TRUE
decl_stmt|;
name|bool
name|queuemode
init|=
name|FALSE
decl_stmt|;
comment|/* process queue requests */
name|bool
name|nothaw
decl_stmt|;
specifier|static
name|bool
name|reenter
init|=
name|FALSE
decl_stmt|;
name|char
name|jbuf
index|[
literal|30
index|]
decl_stmt|;
comment|/* holds MyHostName */
specifier|extern
name|bool
name|safefile
parameter_list|()
function_decl|;
specifier|extern
name|time_t
name|convtime
parameter_list|()
function_decl|;
extern|extern putheader(
block|)
end_block

begin_operator
operator|,
end_operator

begin_expr_stmt
name|putbody
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|extern
name|ENVELOPE
modifier|*
name|newenvelope
parameter_list|()
function_decl|;
end_function_decl

begin_extern
extern|extern intsig(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
modifier|*
name|myhostname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|arpadate
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	**  Check to see if we reentered. 	**	This would normally happen if e_putheader or e_putbody 	**	were NULL when invoked. 	*/
end_comment

begin_if
if|if
condition|(
name|reenter
condition|)
block|{
name|syserr
argument_list|(
literal|"main: reentered!"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|reenter
operator|=
name|TRUE
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Enforce use of local time */
end_comment

begin_expr_stmt
name|unsetenv
argument_list|(
literal|"TZ"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	**  Be sure we have enough file descriptors. 	**	But also be sure that 0, 1,& 2 are open. 	*/
end_comment

begin_expr_stmt
name|i
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
literal|2
condition|)
name|i
operator|=
name|dup
argument_list|(
name|i
argument_list|)
expr_stmt|;
end_while

begin_for
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
literal|50
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
end_for

begin_expr_stmt
name|errno
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	**  Set default values for variables. 	**	These cannot be in initialized data space. 	*/
end_comment

begin_expr_stmt
name|setdefaults
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* set up the blank envelope */
end_comment

begin_expr_stmt
name|BlankEnvelope
operator|.
name|e_puthdr
operator|=
name|putheader
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BlankEnvelope
operator|.
name|e_putbody
operator|=
name|putbody
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BlankEnvelope
operator|.
name|e_xfp
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRUCTCOPY
argument_list|(
name|NullAddress
argument_list|,
name|BlankEnvelope
operator|.
name|e_from
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CurEnv
operator|=
operator|&
name|BlankEnvelope
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRUCTCOPY
argument_list|(
name|NullAddress
argument_list|,
name|MainEnvelope
operator|.
name|e_from
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	**  Do a quick prescan of the argument list. 	**	We do this to find out if we can potentially thaw the 	**	configuration file.  If not, we do the thaw now so that 	**	the argument processing applies to this run rather than 	**	to the run that froze the configuration. 	*/
end_comment

begin_expr_stmt
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|av
operator|=
name|argv
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nothaw
operator|=
name|FALSE
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|(
name|p
operator|=
operator|*
operator|++
name|av
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"-C"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ConfFile
operator|=
operator|&
name|p
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|ConfFile
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|ConfFile
operator|=
literal|"sendmail.cf"
expr_stmt|;
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|getrgid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|getruid
argument_list|()
argument_list|)
expr_stmt|;
name|nothaw
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"-bz"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|nothaw
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"-d"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tTsetup
argument_list|(
name|tTdvect
argument_list|,
sizeof|sizeof
name|tTdvect
argument_list|,
literal|"0-99.1"
argument_list|)
expr_stmt|;
name|tTflag
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Version %s\n"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
block|}
end_while

begin_if
if|if
condition|(
operator|!
name|nothaw
condition|)
name|readconfig
operator|=
operator|!
name|thaw
argument_list|(
name|FreezeFile
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* reset the environment after the thaw */
end_comment

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXUSERENVIRON
operator|&&
name|envp
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|UserEnviron
index|[
name|i
index|]
operator|=
name|newstr
argument_list|(
name|envp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
end_for

begin_expr_stmt
name|UserEnviron
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|environ
operator|=
name|UserEnviron
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SETPROCTITLE
end_ifdef

begin_comment
comment|/* 	**  Save start and extent of argv for setproctitle. 	*/
end_comment

begin_expr_stmt
name|Argv
operator|=
name|argv
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|LastArgv
operator|=
name|envp
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|strlen
argument_list|(
name|envp
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|LastArgv
operator|=
name|argv
index|[
name|argc
operator|-
literal|1
index|]
operator|+
name|strlen
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
endif|SETPROCTITLE
end_endif

begin_comment
comment|/* 	**  Now do basic initialization 	*/
end_comment

begin_expr_stmt
name|InChannel
operator|=
name|stdin
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|OutChannel
operator|=
name|stdout
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|OldUmask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|OpMode
operator|=
name|MD_DELIVER
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MotherPid
operator|=
name|getpid
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|FullName
operator|=
name|getenv
argument_list|(
literal|"NAME"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_expr_stmt
name|openlog
argument_list|(
literal|"sendmail"
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_MAIL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
endif|LOG
end_endif

begin_expr_stmt
name|errno
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|from
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|readconfig
condition|)
block|{
comment|/* initialize some macros, etc. */
name|initmacros
argument_list|()
expr_stmt|;
comment|/* hostname */
name|av
operator|=
name|myhostname
argument_list|(
name|jbuf
argument_list|,
sizeof|sizeof
name|jbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|jbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"canonical name: %s\n"
argument_list|,
name|jbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|p
operator|=
name|newstr
argument_list|(
name|jbuf
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'w'
argument_list|,
name|p
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'w'
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|av
operator|!=
name|NULL
operator|&&
operator|*
name|av
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\ta.k.a.: %s\n"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|setclass
argument_list|(
literal|'w'
argument_list|,
operator|*
name|av
operator|++
argument_list|)
expr_stmt|;
block|}
comment|/* version */
name|define
argument_list|(
literal|'v'
argument_list|,
name|Version
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* current time */
end_comment

begin_expr_stmt
name|define
argument_list|(
literal|'b'
argument_list|,
name|arpadate
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	** Crack argv. 	*/
end_comment

begin_expr_stmt
name|av
operator|=
name|argv
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|p
operator|=
name|rindex
argument_list|(
operator|*
name|av
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|p
operator|++
operator|==
name|NULL
condition|)
name|p
operator|=
operator|*
name|av
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"newaliases"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_INITALIAS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"mailq"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_PRINT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"smtpd"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_DAEMON
expr_stmt|;
end_if

begin_while
while|while
condition|(
operator|(
name|p
operator|=
operator|*
operator|++
name|av
operator|)
operator|!=
name|NULL
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* operations mode */
switch|switch
condition|(
name|p
index|[
literal|2
index|]
condition|)
block|{
case|case
name|MD_DAEMON
case|:
ifndef|#
directive|ifndef
name|DAEMON
name|syserr
argument_list|(
literal|"Daemon mode not implemented"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|DAEMON
case|case
name|MD_SMTP
case|:
ifndef|#
directive|ifndef
name|SMTP
name|syserr
argument_list|(
literal|"I don't speak SMTP"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|SMTP
case|case
name|MD_ARPAFTP
case|:
case|case
name|MD_DELIVER
case|:
case|case
name|MD_VERIFY
case|:
case|case
name|MD_TEST
case|:
case|case
name|MD_INITALIAS
case|:
case|case
name|MD_PRINT
case|:
case|case
name|MD_FREEZE
case|:
name|OpMode
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"Invalid operation mode %c"
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* select configuration file (already done) */
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'d'
case|:
comment|/* debugging -- redo in case frozen */
name|tTsetup
argument_list|(
name|tTdvect
argument_list|,
sizeof|sizeof
name|tTdvect
argument_list|,
literal|"0-99.1"
argument_list|)
expr_stmt|;
name|tTflag
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|_res
operator|.
name|options
operator||=
name|RES_DEBUG
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'f'
case|:
comment|/* from address */
case|case
literal|'r'
case|:
comment|/* obsolete -f flag */
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|&&
operator|(
operator|(
name|p
operator|=
operator|*
operator|++
name|av
operator|)
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
literal|'-'
operator|)
condition|)
block|{
name|p
operator|=
operator|*
operator|++
name|av
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|syserr
argument_list|(
literal|"No \"from\" person"
argument_list|)
expr_stmt|;
name|av
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|from
operator|!=
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"More than one \"from\" person"
argument_list|)
expr_stmt|;
break|break;
block|}
name|from
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* set full name */
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|&&
operator|(
operator|(
name|p
operator|=
operator|*
operator|++
name|av
operator|)
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
literal|'-'
operator|)
condition|)
block|{
name|syserr
argument_list|(
literal|"Bad -F flag"
argument_list|)
expr_stmt|;
name|av
operator|--
expr_stmt|;
break|break;
block|}
name|FullName
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* hop count */
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|&&
operator|(
operator|(
name|p
operator|=
operator|*
operator|++
name|av
operator|)
operator|==
name|NULL
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
block|{
name|syserr
argument_list|(
literal|"Bad hop count (%s)"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|av
operator|--
expr_stmt|;
break|break;
block|}
name|CurEnv
operator|->
name|e_hopcount
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* don't alias */
name|NoAlias
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* set option */
name|setoption
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|,
operator|&
name|p
index|[
literal|3
index|]
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* run queue files at intervals */
ifdef|#
directive|ifdef
name|QUEUE
name|queuemode
operator|=
name|TRUE
expr_stmt|;
name|QueueIntvl
operator|=
name|convtime
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
else|QUEUE
name|syserr
argument_list|(
literal|"I don't know about queues"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|QUEUE
break|break;
case|case
literal|'t'
case|:
comment|/* read recipients from message */
name|GrabTo
operator|=
name|TRUE
expr_stmt|;
break|break;
comment|/* compatibility flags */
case|case
literal|'c'
case|:
comment|/* connect to non-local mailers */
case|case
literal|'e'
case|:
comment|/* error message disposition */
case|case
literal|'i'
case|:
comment|/* don't let dot stop me */
case|case
literal|'m'
case|:
comment|/* send to me too */
case|case
literal|'T'
case|:
comment|/* set timeout interval */
case|case
literal|'v'
case|:
comment|/* give blow-by-blow description */
name|setoption
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|,
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* save From lines in headers */
name|setoption
argument_list|(
literal|'f'
argument_list|,
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DBM
case|case
literal|'I'
case|:
comment|/* initialize alias DBM file */
name|OpMode
operator|=
name|MD_INITALIAS
expr_stmt|;
break|break;
endif|#
directive|endif
endif|DBM
block|}
block|}
end_while

begin_comment
comment|/* 	**  Do basic initialization. 	**	Read system control file. 	**	Extract special fields for local use. 	*/
end_comment

begin_if
if|if
condition|(
name|OpMode
operator|==
name|MD_FREEZE
operator|||
name|readconfig
condition|)
name|readcf
argument_list|(
name|ConfFile
argument_list|)
expr_stmt|;
end_if

begin_switch
switch|switch
condition|(
name|OpMode
condition|)
block|{
case|case
name|MD_FREEZE
case|:
comment|/* this is critical to avoid forgeries of the frozen config */
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* freeze the configuration */
name|freeze
argument_list|(
name|FreezeFile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
case|case
name|MD_INITALIAS
case|:
name|Verbose
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
end_switch

begin_comment
comment|/* do heuristic mode adjustment */
end_comment

begin_if
if|if
condition|(
name|Verbose
condition|)
block|{
comment|/* turn off noconnect option */
name|setoption
argument_list|(
literal|'c'
argument_list|,
literal|"F"
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* turn on interactive delivery */
name|setoption
argument_list|(
literal|'d'
argument_list|,
literal|""
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* our name for SMTP codes */
end_comment

begin_expr_stmt
name|expand
argument_list|(
literal|"\001j"
argument_list|,
name|jbuf
argument_list|,
operator|&
name|jbuf
index|[
sizeof|sizeof
name|jbuf
operator|-
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MyHostName
operator|=
name|jbuf
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* the indices of local and program mailers */
end_comment

begin_expr_stmt
name|st
operator|=
name|stab
argument_list|(
literal|"local"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"No local mailer defined"
argument_list|)
expr_stmt|;
else|else
name|LocalMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
end_if

begin_expr_stmt
name|st
operator|=
name|stab
argument_list|(
literal|"prog"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"No prog mailer defined"
argument_list|)
expr_stmt|;
else|else
name|ProgMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
end_if

begin_comment
comment|/* operate in queue directory */
end_comment

begin_if
if|if
condition|(
name|chdir
argument_list|(
name|QueueDir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"cannot chdir(%s)"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* 	**  Do operation-mode-dependent initialization. 	*/
end_comment

begin_switch
switch|switch
condition|(
name|OpMode
condition|)
block|{
case|case
name|MD_PRINT
case|:
comment|/* print the queue */
ifdef|#
directive|ifdef
name|QUEUE
name|dropenvelope
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
name|printqueue
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
else|#
directive|else
else|QUEUE
name|usrerr
argument_list|(
literal|"No queue to print"
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|QUEUE
case|case
name|MD_INITALIAS
case|:
comment|/* initialize alias database */
name|initaliases
argument_list|(
name|AliasFile
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
case|case
name|MD_DAEMON
case|:
comment|/* don't open alias database -- done in srvrsmtp */
break|break;
default|default:
comment|/* open the alias database */
name|initaliases
argument_list|(
name|AliasFile
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
end_switch

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_if
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|15
argument_list|)
condition|)
block|{
comment|/* print configuration table (or at least part of it) */
name|printrules
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXMAILERS
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|mailer
modifier|*
name|m
init|=
name|Mailer
index|[
name|i
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
continue|continue;
name|printf
argument_list|(
literal|"mailer %d (%s): P=%s S=%d R=%d M=%ld F="
argument_list|,
name|i
argument_list|,
name|m
operator|->
name|m_name
argument_list|,
name|m
operator|->
name|m_mailer
argument_list|,
name|m
operator|->
name|m_s_rwset
argument_list|,
name|m
operator|->
name|m_r_rwset
argument_list|,
name|m
operator|->
name|m_maxsize
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|'\0'
init|;
name|j
operator|<=
literal|'\177'
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|bitnset
argument_list|(
name|j
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" E="
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|m
operator|->
name|m_eol
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

begin_comment
comment|/* 	**  Switch to the main envelope. 	*/
end_comment

begin_expr_stmt
name|CurEnv
operator|=
name|newenvelope
argument_list|(
operator|&
name|MainEnvelope
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MainEnvelope
operator|.
name|e_flags
operator|=
name|BlankEnvelope
operator|.
name|e_flags
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	**  If test mode, read addresses from stdin and process. 	*/
end_comment

begin_if
if|if
condition|(
name|OpMode
operator|==
name|MD_TEST
condition|)
block|{
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"ADDRESS TEST MODE\nEnter<ruleset><address>\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
specifier|extern
name|char
modifier|*
name|DelimChar
decl_stmt|;
name|printf
argument_list|(
literal|"> "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
name|finis
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|*
name|p
operator|++
control|)
continue|continue;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
continue|continue;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|prescan
parameter_list|()
function_decl|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
name|pvp
operator|=
name|prescan
argument_list|(
operator|++
name|p
argument_list|,
literal|','
argument_list|,
name|pvpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
continue|continue;
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|rewrite
argument_list|(
name|pvp
argument_list|,
name|atoi
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
continue|continue;
block|}
block|}
do|while
condition|(
operator|*
operator|(
name|p
operator|=
name|DelimChar
operator|)
operator|!=
literal|'\0'
condition|)
do|;
block|}
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|QUEUE
end_ifdef

begin_comment
comment|/* 	**  If collecting stuff from the queue, go start doing that. 	*/
end_comment

begin_if
if|if
condition|(
name|queuemode
operator|&&
name|OpMode
operator|!=
name|MD_DAEMON
operator|&&
name|QueueIntvl
operator|==
literal|0
condition|)
block|{
name|runqueue
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
endif|QUEUE
end_endif

begin_comment
comment|/* 	**  If a daemon, wait for a request. 	**	getrequests will always return in a child. 	**	If we should also be processing the queue, start 	**		doing it in background. 	**	We check for any errors that might have happened 	**		during startup. 	*/
end_comment

begin_if
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
operator|||
name|QueueIntvl
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|tTd
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* put us in background */
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"daemon: cannot fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* get our pid right */
name|MotherPid
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* disconnect from our controlling tty */
name|disconnect
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QUEUE
if|if
condition|(
name|queuemode
condition|)
block|{
name|runqueue
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|OpMode
operator|!=
name|MD_DAEMON
condition|)
for|for
control|(
init|;
condition|;
control|)
name|pause
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
endif|QUEUE
name|dropenvelope
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DAEMON
name|getrequests
argument_list|()
expr_stmt|;
comment|/* at this point we are in a child: reset state */
name|OpMode
operator|=
name|MD_SMTP
expr_stmt|;
operator|(
name|void
operator|)
name|newenvelope
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
name|openxscript
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DAEMON
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|SMTP
end_ifdef

begin_comment
comment|/* 	**  If running SMTP protocol, start collecting and executing 	**  commands.  This will never return. 	*/
end_comment

begin_if
if|if
condition|(
name|OpMode
operator|==
name|MD_SMTP
condition|)
name|smtp
argument_list|()
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
endif|SMTP
end_endif

begin_comment
comment|/* 	**  Do basic system initialization and set the sender 	*/
end_comment

begin_expr_stmt
name|initsys
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setsender
argument_list|(
name|from
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|OpMode
operator|!=
name|MD_ARPAFTP
operator|&&
operator|*
name|av
operator|==
name|NULL
operator|&&
operator|!
name|GrabTo
condition|)
block|{
name|usrerr
argument_list|(
literal|"Recipient names must be specified"
argument_list|)
expr_stmt|;
comment|/* collect body for UUCP return */
if|if
condition|(
name|OpMode
operator|!=
name|MD_VERIFY
condition|)
name|collect
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|OpMode
operator|==
name|MD_VERIFY
condition|)
name|SendMode
operator|=
name|SM_VERIFY
expr_stmt|;
end_if

begin_comment
comment|/* 	**  Scan argv and deliver the message to everyone. 	*/
end_comment

begin_expr_stmt
name|sendtoargv
argument_list|(
name|av
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* if we have had errors sofar, arrange a meaningful exit stat */
end_comment

begin_if
if|if
condition|(
name|Errors
operator|>
literal|0
operator|&&
name|ExitStat
operator|==
name|EX_OK
condition|)
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
end_if

begin_comment
comment|/* 	**  Read the input mail. 	*/
end_comment

begin_expr_stmt
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|OpMode
operator|!=
name|MD_VERIFY
operator|||
name|GrabTo
condition|)
name|collect
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|errno
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* collect statistics */
end_comment

begin_if
if|if
condition|(
name|OpMode
operator|!=
name|MD_VERIFY
condition|)
name|markstats
argument_list|(
name|CurEnv
argument_list|,
operator|(
name|ADDRESS
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_if
if|if
condition|(
name|tTd
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"From person = \"%s\"\n"
argument_list|,
name|CurEnv
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

begin_comment
comment|/* 	**  Actually send everything. 	**	If verifying, just ack. 	*/
end_comment

begin_expr_stmt
name|CurEnv
operator|->
name|e_from
operator|.
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sendall
argument_list|(
name|CurEnv
argument_list|,
name|SM_DEFAULT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	** All done. 	*/
end_comment

begin_expr_stmt
name|finis
argument_list|()
expr_stmt|;
end_expr_stmt

begin_escape
unit|}
end_escape

begin_comment
comment|/* **  FINIS -- Clean up and exit. ** **	Parameters: **		none ** **	Returns: **		never ** **	Side Effects: **		exits sendmail */
end_comment

begin_expr_stmt
unit|finis
operator|(
operator|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\n====finis: stat %d e_flags %o\n"
argument_list|,
name|ExitStat
argument_list|,
name|CurEnv
operator|->
name|e_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
comment|/* clean up temp files */
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dropenvelope
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* post statistics */
end_comment

begin_expr_stmt
name|poststats
argument_list|(
name|StatFile
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* and exit */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_if
if|if
condition|(
name|LogLevel
operator|>
literal|11
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"finis, pid=%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
endif|LOG
end_endif

begin_if
if|if
condition|(
name|ExitStat
operator|==
name|EX_TEMPFAIL
condition|)
name|ExitStat
operator|=
name|EX_OK
expr_stmt|;
end_if

begin_expr_stmt
name|exit
argument_list|(
name|ExitStat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_escape
unit|}
end_escape

begin_comment
comment|/* **  INTSIG -- clean up on interrupt ** **	This just arranges to exit.  It pessimises in that it **	may resend a message. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		Unlocks the current job. */
end_comment

begin_expr_stmt
unit|intsig
operator|(
operator|)
block|{
name|FileName
operator|=
name|NULL
block|;
name|unlockqueue
argument_list|(
name|CurEnv
argument_list|)
block|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
block|; }
comment|/* **  INITMACROS -- initialize the macro system ** **	This just involves defining some macros that are actually **	used internally as metasymbols to be themselves. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		initializes several macros to be themselves. */
expr|struct
name|metamac
block|{
name|char
name|metaname
block|;
name|char
name|metaval
block|; }
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|metamac
name|MetaMacros
index|[]
init|=
block|{
comment|/* LHS pattern matching characters */
literal|'*'
block|,
name|MATCHZANY
block|,
literal|'+'
block|,
name|MATCHANY
block|,
literal|'-'
block|,
name|MATCHONE
block|,
literal|'='
block|,
name|MATCHCLASS
block|,
literal|'~'
block|,
name|MATCHNCLASS
block|,
comment|/* these are RHS metasymbols */
literal|'#'
block|,
name|CANONNET
block|,
literal|'@'
block|,
name|CANONHOST
block|,
literal|':'
block|,
name|CANONUSER
block|,
literal|'>'
block|,
name|CALLSUBR
block|,
comment|/* the conditional operations */
literal|'?'
block|,
name|CONDIF
block|,
literal|'|'
block|,
name|CONDELSE
block|,
literal|'.'
block|,
name|CONDFI
block|,
comment|/* and finally the hostname lookup characters */
literal|'['
block|,
name|HOSTBEGIN
block|,
literal|']'
block|,
name|HOSTEND
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|initmacros
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|metamac
modifier|*
name|m
decl_stmt|;
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
for|for
control|(
name|m
operator|=
name|MetaMacros
init|;
name|m
operator|->
name|metaname
operator|!=
literal|'\0'
condition|;
name|m
operator|++
control|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|m
operator|->
name|metaval
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|define
argument_list|(
name|m
operator|->
name|metaname
argument_list|,
name|newstr
argument_list|(
name|buf
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|MATCHREPL
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'0'
init|;
name|c
operator|<=
literal|'9'
condition|;
name|c
operator|++
control|)
block|{
name|buf
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|define
argument_list|(
name|c
argument_list|,
name|newstr
argument_list|(
name|buf
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  FREEZE -- freeze BSS& allocated memory ** **	This will be used to efficiently load the configuration file. ** **	Parameters: **		freezefile -- the name of the file to freeze to. ** **	Returns: **		none. ** **	Side Effects: **		Writes BSS and malloc'ed memory to freezefile */
end_comment

begin_union
union|union
name|frz
block|{
name|char
name|frzpad
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* insure we are on a BUFSIZ boundary */
struct|struct
block|{
name|time_t
name|frzstamp
decl_stmt|;
comment|/* timestamp on this freeze */
name|char
modifier|*
name|frzbrk
decl_stmt|;
comment|/* the current break */
name|char
modifier|*
name|frzedata
decl_stmt|;
comment|/* address of edata */
name|char
modifier|*
name|frzend
decl_stmt|;
comment|/* address of end */
name|char
name|frzver
index|[
literal|252
index|]
decl_stmt|;
comment|/* sendmail version */
block|}
name|frzinfo
struct|;
block|}
union|;
end_union

begin_macro
name|freeze
argument_list|(
argument|freezefile
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|freezefile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|f
decl_stmt|;
name|union
name|frz
name|fhdr
decl_stmt|;
specifier|extern
name|char
name|edata
decl_stmt|,
name|end
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
specifier|extern
name|char
name|Version
index|[]
decl_stmt|;
if|if
condition|(
name|freezefile
operator|==
name|NULL
condition|)
return|return;
comment|/* try to open the freeze file */
name|f
operator|=
name|creat
argument_list|(
name|freezefile
argument_list|,
name|FileMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"Cannot freeze"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* build the freeze header */
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzstamp
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzbrk
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzedata
operator|=
operator|&
name|edata
expr_stmt|;
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzend
operator|=
operator|&
name|end
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzver
argument_list|,
name|Version
argument_list|)
expr_stmt|;
comment|/* write out the freeze header */
if|if
condition|(
name|write
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fhdr
argument_list|,
sizeof|sizeof
name|fhdr
argument_list|)
operator|!=
sizeof|sizeof
name|fhdr
operator|||
name|write
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|edata
argument_list|,
call|(
name|int
call|)
argument_list|(
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzbrk
operator|-
operator|&
name|edata
argument_list|)
argument_list|)
operator|!=
call|(
name|int
call|)
argument_list|(
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzbrk
operator|-
operator|&
name|edata
argument_list|)
condition|)
block|{
name|syserr
argument_list|(
literal|"Cannot freeze"
argument_list|)
expr_stmt|;
block|}
comment|/* fine, clean up */
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  THAW -- read in the frozen configuration file. ** **	Parameters: **		freezefile -- the name of the file to thaw from. ** **	Returns: **		TRUE if it successfully read the freeze file. **		FALSE otherwise. ** **	Side Effects: **		reads freezefile in to BSS area. */
end_comment

begin_macro
name|thaw
argument_list|(
argument|freezefile
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|freezefile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|f
decl_stmt|;
name|union
name|frz
name|fhdr
decl_stmt|;
specifier|extern
name|char
name|edata
decl_stmt|,
name|end
decl_stmt|;
specifier|extern
name|char
name|Version
index|[]
decl_stmt|;
specifier|extern
name|caddr_t
name|brk
parameter_list|()
function_decl|;
if|if
condition|(
name|freezefile
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* open the freeze file */
name|f
operator|=
name|open
argument_list|(
name|freezefile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* read in the header */
if|if
condition|(
name|read
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fhdr
argument_list|,
sizeof|sizeof
name|fhdr
argument_list|)
operator|<
sizeof|sizeof
name|fhdr
operator|||
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzedata
operator|!=
operator|&
name|edata
operator|||
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzend
operator|!=
operator|&
name|end
operator|||
name|strcmp
argument_list|(
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzver
argument_list|,
name|Version
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* arrange to have enough space */
if|if
condition|(
name|brk
argument_list|(
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzbrk
argument_list|)
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|syserr
argument_list|(
literal|"Cannot break to %x"
argument_list|,
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzbrk
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* now read in the freeze file */
if|if
condition|(
name|read
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|edata
argument_list|,
call|(
name|int
call|)
argument_list|(
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzbrk
operator|-
operator|&
name|edata
argument_list|)
argument_list|)
operator|!=
call|(
name|int
call|)
argument_list|(
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzbrk
operator|-
operator|&
name|edata
argument_list|)
condition|)
block|{
comment|/* oops!  we have trashed memory..... */
operator|(
name|void
operator|)
name|write
argument_list|(
literal|2
argument_list|,
literal|"Cannot read freeze file\n"
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  DISCONNECT -- remove our connection with any foreground process ** **	Parameters: **		fulldrop -- if set, we should also drop the controlling **			TTY if possible -- this should only be done when **			setting up the daemon since otherwise UUCP can **			leave us trying to open a dialin, and we will **			wait for the carrier. ** **	Returns: **		none ** **	Side Effects: **		Trys to insure that we are immune to vagaries of **		the controlling tty. */
end_comment

begin_macro
name|disconnect
argument_list|(
argument|fulldrop
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|fulldrop
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fd
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|52
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"disconnect: In %d Out %d\n"
argument_list|,
name|fileno
argument_list|(
name|InChannel
argument_list|)
argument_list|,
name|fileno
argument_list|(
name|OutChannel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|52
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"don't\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
endif|DEBUG
comment|/* be sure we don't get nasty signals */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* we can't communicate with our caller, so.... */
name|HoldErrs
operator|=
name|TRUE
expr_stmt|;
name|ErrorMode
operator|=
name|EM_MAIL
expr_stmt|;
name|Verbose
operator|=
name|FALSE
expr_stmt|;
comment|/* all input from /dev/null */
if|if
condition|(
name|InChannel
operator|!=
name|stdin
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|InChannel
argument_list|)
expr_stmt|;
name|InChannel
operator|=
name|stdin
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
comment|/* output to the transcript */
if|if
condition|(
name|OutChannel
operator|!=
name|stdout
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|OutChannel
argument_list|)
expr_stmt|;
name|OutChannel
operator|=
name|stdout
expr_stmt|;
block|}
if|if
condition|(
name|CurEnv
operator|->
name|e_xfp
operator|==
name|NULL
condition|)
name|CurEnv
operator|->
name|e_xfp
operator|=
name|fopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fd
operator|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|CurEnv
operator|->
name|e_xfp
argument_list|)
argument_list|)
operator|)
operator|<
literal|2
operator|&&
name|fd
operator|>
literal|0
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|TIOCNOTTY
comment|/* drop our controlling TTY completely if possible */
if|if
condition|(
name|fulldrop
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
operator|(
name|int
operator|)
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|setpgrp
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
endif|TIOCNOTTY
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|11
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"in background, pid=%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
name|errno
operator|=
literal|0
expr_stmt|;
block|}
end_block

end_unit

