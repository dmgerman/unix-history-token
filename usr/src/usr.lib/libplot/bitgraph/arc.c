begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)arc.c	5.2 (Berkeley) 4/30/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"bg.h"
end_include

begin_comment
comment|/* should include test for equality? */
end_comment

begin_define
define|#
directive|define
name|side
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(a*(x)+b*(y)+c> 0.0 ? 1 : -1)
end_define

begin_comment
comment|/* The beginning and ending points must be distinct. */
end_comment

begin_macro
name|arc
argument_list|(
argument|xc
argument_list|,
argument|yc
argument_list|,
argument|xbeg
argument_list|,
argument|ybeg
argument_list|,
argument|xend
argument_list|,
argument|yend
argument_list|)
end_macro

begin_decl_stmt
name|int
name|xc
decl_stmt|,
name|yc
decl_stmt|,
name|xbeg
decl_stmt|,
name|ybeg
decl_stmt|,
name|xend
decl_stmt|,
name|yend
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|r
decl_stmt|,
name|radius
decl_stmt|,
name|costheta
decl_stmt|,
name|sintheta
decl_stmt|;
name|double
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|tempX
decl_stmt|;
name|int
name|right_side
decl_stmt|;
name|int
name|screen_xc
init|=
name|scaleX
argument_list|(
name|xc
argument_list|)
decl_stmt|;
name|int
name|screen_yc
init|=
name|scaleY
argument_list|(
name|yc
argument_list|)
decl_stmt|;
comment|/* It is more convienient to beg and end relative to center. */
name|int
name|screen_xbeg
init|=
name|scaleX
argument_list|(
name|xbeg
argument_list|)
operator|-
name|screen_xc
decl_stmt|;
name|int
name|screen_ybeg
init|=
name|scaleY
argument_list|(
name|ybeg
argument_list|)
operator|-
name|screen_yc
decl_stmt|;
name|int
name|screen_xend
init|=
name|scaleX
argument_list|(
name|xend
argument_list|)
operator|-
name|screen_xc
decl_stmt|;
name|int
name|screen_yend
init|=
name|scaleY
argument_list|(
name|yend
argument_list|)
operator|-
name|screen_yc
decl_stmt|;
comment|/* probably should check that arc is truely circular */
name|r
operator|=
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|screen_xbeg
operator|*
name|screen_xbeg
operator|+
name|screen_ybeg
operator|*
name|screen_ybeg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	This method is reasonably efficient, clean, and clever. 	The easy part is generating the next point on the arc.  This is 	done by rotating the points by the angle theta.  Theta is chosen 	so that no rotation will cause more than one pixel of a move. 	This corresponds to a triangle having x side of r and y side of 1. 	The rotation is done (way) below inside the loop.  	Note:  all calculations are done in screen coordinates. 	*/
if|if
condition|(
name|r
operator|<=
literal|1.0
condition|)
block|{
comment|/* radius is mapped to length< 1*/
name|point
argument_list|(
name|xc
argument_list|,
name|yc
argument_list|)
expr_stmt|;
return|return;
block|}
name|radius
operator|=
name|sqrt
argument_list|(
name|r
operator|*
name|r
operator|+
literal|1.0
argument_list|)
expr_stmt|;
name|sintheta
operator|=
literal|1.0
operator|/
name|radius
expr_stmt|;
name|costheta
operator|=
name|r
operator|/
name|radius
expr_stmt|;
comment|/* 	The hard part of drawing an arc is figuring out when to stop. 	This method works by drawing the line from the beginning point 	to the ending point.  This splits the plane in half, with the 	arc that we wish to draw on one side of the line.  If we evaluate 	side(x,y) = a*x + b*y + c, then all of the points on one side of the 	line will result in side being positive, and all the points on the 	other side of the line will result in side being negative.  	We want to draw the arc in a counter-clockwise direction, so we 	must find out what the sign of "side" is for a point which is to the  	"right" of a line drawn from "beg" to "end".  A point which must lie  	on the right is [xbeg + (yend-ybeg), ybeg - (xend-xbeg)].  (This 	point is perpendicular to the line at "beg").  	Thus, we compute side of the above point, and then compare the 	sign of side for each new point with the sign of the above point. 	When they are different, we terminate the loop. 	*/
name|a
operator|=
call|(
name|double
call|)
argument_list|(
name|screen_yend
operator|-
name|screen_ybeg
argument_list|)
expr_stmt|;
name|b
operator|=
call|(
name|double
call|)
argument_list|(
name|screen_xend
operator|-
name|screen_xbeg
argument_list|)
expr_stmt|;
name|c
operator|=
call|(
name|double
call|)
argument_list|(
name|screen_yend
operator|*
name|screen_xbeg
operator|-
name|screen_xend
operator|*
name|screen_ybeg
argument_list|)
expr_stmt|;
name|right_side
operator|=
name|side
argument_list|(
name|screen_xbeg
operator|+
operator|(
name|screen_yend
operator|-
name|screen_ybeg
operator|)
argument_list|,
name|screen_ybeg
operator|-
operator|(
name|screen_xend
operator|-
name|screen_xbeg
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|screen_xbeg
expr_stmt|;
name|y
operator|=
name|screen_ybeg
expr_stmt|;
name|move
argument_list|(
name|xbeg
argument_list|,
name|ybeg
argument_list|)
expr_stmt|;
do|do
block|{
name|currentx
operator|=
name|screen_xc
operator|+
call|(
name|int
call|)
argument_list|(
name|x
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|currenty
operator|=
name|screen_yc
operator|+
call|(
name|int
call|)
argument_list|(
name|y
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|ESC
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":%d;%dd"
argument_list|,
name|currentx
argument_list|,
name|currenty
argument_list|)
expr_stmt|;
name|tempX
operator|=
name|x
expr_stmt|;
name|x
operator|=
name|x
operator|*
name|costheta
operator|-
name|y
operator|*
name|sintheta
expr_stmt|;
name|y
operator|=
name|tempX
operator|*
name|sintheta
operator|+
name|y
operator|*
name|costheta
expr_stmt|;
block|}
do|while
condition|(
name|side
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|==
name|right_side
condition|)
do|;
block|}
end_block

end_unit

