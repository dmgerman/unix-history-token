begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|Notice
index|[]
init|=
literal|"Copyright (c) 1985 Adobe Systems Incorporated"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSID
init|=
literal|"$Header: enscript.c,v 1.7 89/03/12 01:31:55 van Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * enscript.c   *  * Copyright (c) 1985 Adobe Systems Incorporated   *  * inspired by Gosling's cz there have been major overhauls, but the input  * language is the same: new widths format generate PostScript (much easier  * than Press) new and renamed switches (to match 4.2bsd lpr spooler) obeys  * PostScript comment conventions doesn't worry so much about fonts  * (everything is scalable and rotatable, use PS font names, no face  * properties)   *  * enscript generates POSTSCRIPT print files of a special kind the coordinate  * system is in 20ths of a point. (1440 per inch)   *  * Edit History: Andrew Shore: Mon Nov 18 14:05:05 1985 End Edit History.   *  * RCSLOG: $Log:	enscript.c,v $  * Revision 1.7  89/03/12  01:31:55  van  * we have to escape special chars in title strings.  *   * Revision 1.6  89/03/10  00:30:39  van  * might as well let the user change everything.  *   * Revision 1.5  89/03/09  23:19:17  van  * gcc lint.  *   * Revision 1.4  89/03/09  23:08:50  van  * let user set the fonts used in 'gaudy' mode  *   * Revision 1.3  88/03/06  17:23:58  leres  * Fix logic bug; only spool output if that's want we want.  *   * Revision 1.2  86/07/03  00:06:31  van  * reformatted.  removed SYSV ifdefs.  *  Revision 1.1  86/07/03  00:03:12  van Initial  * revision   *  * Revision 2.1  85/11/24  11:48:55  shore Product Release 2.0   *  * Revision 1.3  85/11/20  00:10:01  shore Added System V support (input options  * and spooling) margins/linecount reworked (Dataproducts) incompatible  * options changes, getopt! Guy Riddle's Gaudy mode and other changes output  * spooling messages, pages, copies   *  * Revision 1.2  85/05/14  11:22:14  shore *** empty log message ***   *  *  */
end_comment

begin_define
define|#
directive|define
name|POSTSCRIPTPRINTER
value|"PostScript"
end_define

begin_define
define|#
directive|define
name|BODYROMAN
value|"Courier"
end_define

begin_define
define|#
directive|define
name|HEADFONT
value|"Courier-Bold"
end_define

begin_define
define|#
directive|define
name|SHEADFONT
value|"Times-Bold"
end_define

begin_define
define|#
directive|define
name|PGNUMFONT
value|"Helvetica-Bold"
end_define

begin_define
define|#
directive|define
name|DATEFONT
value|"Times-Bold"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|debugp
parameter_list|(
name|x
parameter_list|)
value|{fprintf x ; VOIDC fflush(stderr);}
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debugp
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|UperInch
value|(1440L)
end_define

begin_define
define|#
directive|define
name|PtsPerInch
value|72
end_define

begin_define
define|#
directive|define
name|UperPt
value|20
end_define

begin_comment
comment|/* virtual page is 8 x 10.5 inches (for Toshiba compat) */
end_comment

begin_define
define|#
directive|define
name|PageWidth
value|((long) UperInch*8)
end_define

begin_define
define|#
directive|define
name|PageLength
value|((long)((UperInch*21)/2))
end_define

begin_comment
comment|/* #define PageLength ((long) ((long) (UperInch*(8*11-3)))/8) */
end_comment

begin_comment
comment|/* #define PageWidth  ((long) ((long) (UperInch*(8*17-3)))/8) */
end_comment

begin_comment
comment|/* true page is 8.5 x 11 inches */
end_comment

begin_define
define|#
directive|define
name|TruePageWidth
value|(UperInch*17/2)
end_define

begin_define
define|#
directive|define
name|TruePageLength
value|((long)(UperInch*11))
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"transcript.h"
end_include

begin_define
define|#
directive|define
name|LPR
value|"lpr"
end_define

begin_define
define|#
directive|define
name|MAXBAD
value|20
end_define

begin_comment
comment|/* number of bad chars to pass before 				 * complaint */
end_comment

begin_decl_stmt
name|private
name|struct
name|stat
name|S
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|double
name|atof
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* getopt current opt char */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* getopt argv index */
end_comment

begin_function_decl
name|private
name|VOID
name|int1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|FlushShow
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FSIZEMAX
value|256
end_define

begin_comment
comment|/* number of chars per font */
end_comment

begin_comment
comment|/* the layout of a font information block */
end_comment

begin_macro
name|private
end_macro

begin_struct
struct|struct
name|font
block|{
name|char
name|name
index|[
literal|100
index|]
decl_stmt|;
comment|/* PostScript font name */
name|int
name|dsize
decl_stmt|;
comment|/* size */
name|int
name|Xwid
index|[
name|FSIZEMAX
index|]
decl_stmt|;
comment|/* X widths for each character */
block|}
struct|;
end_struct

begin_decl_stmt
name|private
name|struct
name|font
name|fonts
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 16 possible fonts at one time */
end_comment

begin_decl_stmt
name|private
name|int
name|nf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of fonts known about */
end_comment

begin_decl_stmt
name|private
name|int
name|TabWidth
init|=
name|TruePageWidth
operator|/
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* width of a tab */
end_comment

begin_decl_stmt
name|private
name|int
name|BSWidth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* width of a backspace */
end_comment

begin_decl_stmt
name|private
name|long
name|UperLine
init|=
name|UperInch
operator|/
literal|7
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|long
name|UperHLine
init|=
name|UperInch
operator|/
literal|7
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program name argv[0] */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|libdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place for prolog and widths files */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|tempdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place for temp file */
end_comment

begin_decl_stmt
name|private
name|char
name|TempName
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of temporary PostScript file */
end_comment

begin_decl_stmt
name|private
name|char
name|OutName
index|[
literal|256
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* filename for disk output */
end_comment

begin_decl_stmt
name|private
name|int
name|PipeOut
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output to stdout (-p -) */
end_comment

begin_decl_stmt
name|private
name|int
name|ListOmitted
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list omitted chars on the tty */
end_comment

begin_decl_stmt
name|private
name|int
name|BeQuiet
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* suppress stderr info messages */
end_comment

begin_decl_stmt
name|private
name|int
name|Gaudy
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pretty bars along the top */
end_comment

begin_decl_stmt
name|private
name|int
name|LPTsimulate
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* an lpt should be simulated */
end_comment

begin_decl_stmt
name|private
name|int
name|Lines
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max lines per page */
end_comment

begin_decl_stmt
name|private
name|int
name|LinesLeft
init|=
literal|66
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lines left on page when in LPT mode */
end_comment

begin_decl_stmt
name|private
name|int
name|LineMax
init|=
literal|64
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ? */
end_comment

begin_decl_stmt
name|private
name|int
name|col
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* column number on current line */
end_comment

begin_decl_stmt
name|private
name|int
name|SeenText
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if seen some text on this page */
end_comment

begin_decl_stmt
name|private
name|int
name|OutOnly
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PS file only wanted */
end_comment

begin_decl_stmt
name|private
name|int
name|Rotated
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pages to be rotated landscape */
end_comment

begin_decl_stmt
name|private
name|int
name|PreFeed
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prefeed should be enabled */
end_comment

begin_decl_stmt
name|private
name|int
name|TwoColumn
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* two-column mode */
end_comment

begin_decl_stmt
name|private
name|int
name|FirstCol
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* we're printing column 1 */
end_comment

begin_decl_stmt
name|private
name|int
name|NoTitle
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* title line is suppressed */
end_comment

begin_decl_stmt
name|private
name|int
name|Cvted
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* converted a file to PS format */
end_comment

begin_decl_stmt
name|private
name|int
name|IgnoreGarbage
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* garbage should be ignored */
end_comment

begin_decl_stmt
name|private
name|int
name|SeenFile
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a file has been processed */
end_comment

begin_decl_stmt
name|private
name|int
name|SeenFont
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* we've seen a font request */
end_comment

begin_decl_stmt
name|private
name|int
name|ScannedFonts
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* we've scanned the font file */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|FileName
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of file currently being PSed */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|FileDate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last mod date of file being PSed */
end_comment

begin_decl_stmt
name|private
name|char
name|DateStr
index|[
literal|27
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* thanks, but no thanks ctime! */
end_comment

begin_decl_stmt
name|private
name|int
name|spoolNoBurst
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* no break page flag for spooler */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_decl_stmt
name|private
name|char
modifier|*
name|spoolJobClass
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|spoolJobName
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|private
name|char
modifier|*
name|PrinterName
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|spoolNotify
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|spoolCopies
init|=
literal|"1"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
name|tempstr
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* various path names */
end_comment

begin_decl_stmt
name|private
name|int
name|CurFont
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current Font */
end_comment

begin_decl_stmt
name|private
name|int
name|fontindex
index|[
literal|26
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of fonts, indexed by font designator 				 * ('a' to 'z') */
end_comment

begin_comment
comment|/* indexes for default fonts */
end_comment

begin_define
define|#
directive|define
name|Roman
value|fontindex['r'-'a']
end_define

begin_define
define|#
directive|define
name|HeaderFont
value|fontindex['h'-'a']
end_define

begin_define
define|#
directive|define
name|SHeaderFont
value|fontindex['i'-'a']
end_define

begin_define
define|#
directive|define
name|DateFont
value|fontindex['j'-'a']
end_define

begin_define
define|#
directive|define
name|PgNumFont
value|fontindex['k'-'a']
end_define

begin_decl_stmt
name|private
name|long
name|cX
decl_stmt|,
name|cY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current page positions */
end_comment

begin_decl_stmt
name|private
name|long
name|dX
decl_stmt|,
name|dY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* desired page positions */
end_comment

begin_decl_stmt
name|private
name|long
name|lX
decl_stmt|,
name|lY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* page positions of the start of the line */
end_comment

begin_decl_stmt
name|private
name|long
name|crX
decl_stmt|,
name|crY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* X and Y increments to apply to CR's */
end_comment

begin_decl_stmt
name|private
name|long
name|maxX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum x coord on line */
end_comment

begin_decl_stmt
name|private
name|long
name|minY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* minimum y coord on page */
end_comment

begin_decl_stmt
name|private
name|long
name|Xoffset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* amount to offset left margin */
end_comment

begin_define
define|#
directive|define
name|None
value|0
end_define

begin_define
define|#
directive|define
name|RelX
value|1
end_define

begin_define
define|#
directive|define
name|RelY
value|2
end_define

begin_define
define|#
directive|define
name|RelXY
value|3
end_define

begin_define
define|#
directive|define
name|AbsX
value|4
end_define

begin_define
define|#
directive|define
name|AbsY
value|8
end_define

begin_define
define|#
directive|define
name|AbsXY
value|12
end_define

begin_decl_stmt
name|private
name|int
name|movepending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* moveto pending coords on stack */
end_comment

begin_decl_stmt
name|private
name|int
name|showpending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of characters waiting to be shown */
end_comment

begin_decl_stmt
name|private
name|int
name|pagepending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start on next page when have something to 				 * print */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|UsersHeader
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user specified heading */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|Header
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* generated header (usually FileName) */
end_comment

begin_decl_stmt
name|private
name|int
name|Page
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current page number */
end_comment

begin_decl_stmt
name|private
name|int
name|TotalPages
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of pages printed */
end_comment

begin_decl_stmt
name|private
name|int
name|TruncChars
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of characters truncated */
end_comment

begin_decl_stmt
name|private
name|int
name|UndefChars
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of characters skipped because they 				 * weren't defined in some font */
end_comment

begin_decl_stmt
name|private
name|int
name|BadChars
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bad characters seen so far */
end_comment

begin_decl_stmt
name|private
name|FILE
modifier|*
name|OutFile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output ps file */
end_comment

begin_comment
comment|/* decode a fontname string - e.g. Courier10 Helvetica-Bold12 */
end_comment

begin_function
name|private
name|decodefont
parameter_list|(
name|name
parameter_list|,
name|f
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|font
modifier|*
name|f
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|SeenFont
operator|=
name|TRUE
expr_stmt|;
name|p
operator|=
name|name
expr_stmt|;
name|d
operator|=
name|f
operator|->
name|name
expr_stmt|;
name|f
operator|->
name|dsize
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'-'
operator|)
operator|)
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|d
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|f
operator|->
name|dsize
operator|=
name|f
operator|->
name|dsize
operator|*
literal|10
operator|+
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|||
operator|!
name|f
operator|->
name|dsize
operator|||
operator|!
name|f
operator|->
name|name
index|[
literal|0
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: poorly formed font name& size: \"%s\"\n"
argument_list|,
name|prog
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|NOTDEF
value|0x8000
end_define

begin_define
define|#
directive|define
name|ForAllFonts
parameter_list|(
name|p
parameter_list|)
value|for(p =&fonts[nf-1]; p>=&fonts[0]; p--)
end_define

begin_comment
comment|/*  * Scan the font metrics directory looking for entries that match the entries  * in ``fonts''.  For entries that are found the data in the font description  * is filled in, if any are missing, it dies horribly.   */
end_comment

begin_function
name|private
name|VOID
name|ScanFont
parameter_list|()
block|{
specifier|register
name|struct
name|font
modifier|*
name|f
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|FontData
decl_stmt|;
comment|/* afm file */
name|char
modifier|*
name|c
decl_stmt|;
name|int
name|ccode
decl_stmt|,
name|cwidth
decl_stmt|,
name|inChars
decl_stmt|;
name|char
name|FontFile
index|[
literal|512
index|]
decl_stmt|;
comment|/* afm file name */
name|char
name|afmbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|SeenFont
condition|)
block|{
if|if
condition|(
name|Lines
operator|==
literal|0
condition|)
name|Lines
operator|=
literal|64
expr_stmt|;
if|if
condition|(
name|Rotated
operator|&&
name|TwoColumn
condition|)
name|fonts
index|[
name|Roman
index|]
operator|.
name|dsize
operator|=
literal|7
expr_stmt|;
block|}
comment|/* loop through fonts, find and read metric entry in dir */
name|ForAllFonts
argument_list|(
argument|f
argument_list|)
block|{
name|VOIDC
name|mstrcat
argument_list|(
name|FontFile
argument_list|,
name|libdir
argument_list|,
literal|"/"
argument_list|,
sizeof|sizeof
name|FontFile
argument_list|)
decl_stmt|;
name|VOIDC
name|mstrcat
argument_list|(
name|FontFile
argument_list|,
name|FontFile
argument_list|,
name|f
operator|->
name|name
argument_list|,
sizeof|sizeof
name|FontFile
argument_list|)
decl_stmt|;
name|VOIDC
name|mstrcat
argument_list|(
name|FontFile
argument_list|,
name|FontFile
argument_list|,
literal|".afm"
argument_list|,
sizeof|sizeof
name|FontFile
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|FontData
operator|=
name|fopen
argument_list|(
name|FontFile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open font metrics file %s\n"
argument_list|,
name|prog
argument_list|,
name|FontFile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* read the .afm file to get the widths */
for|for
control|(
name|ccode
operator|=
literal|0
init|;
name|ccode
operator|<
name|FSIZEMAX
condition|;
name|ccode
operator|++
control|)
name|f
operator|->
name|Xwid
index|[
name|ccode
index|]
operator|=
name|NOTDEF
expr_stmt|;
name|inChars
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|afmbuf
argument_list|,
sizeof|sizeof
name|afmbuf
argument_list|,
name|FontData
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* strip off newline */
if|if
condition|(
operator|(
name|c
operator|=
name|INDEX
argument_list|(
name|afmbuf
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: AFM file %s line too long %s\n"
argument_list|,
name|prog
argument_list|,
name|FontFile
argument_list|,
name|afmbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|c
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|afmbuf
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|afmbuf
argument_list|,
literal|"StartCharMetrics"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|inChars
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|afmbuf
argument_list|,
literal|"EndCharMetrics"
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|inChars
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|afmbuf
argument_list|,
literal|"C %d ; WX %d ;"
argument_list|,
operator|&
name|ccode
argument_list|,
operator|&
name|cwidth
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: trouble with AFM file %s\n"
argument_list|,
name|prog
argument_list|,
name|FontFile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* get out once we see an unencoded char */
if|if
condition|(
name|ccode
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|ccode
operator|>
literal|255
condition|)
continue|continue;
name|f
operator|->
name|Xwid
index|[
name|ccode
index|]
operator|=
call|(
name|short
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|cwidth
operator|*
operator|(
name|long
operator|)
name|f
operator|->
name|dsize
operator|*
operator|(
name|long
operator|)
name|UperPt
operator|)
operator|/
literal|1000L
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|VOIDC
name|fclose
argument_list|(
name|FontData
argument_list|)
decl_stmt|;
block|}
name|TabWidth
operator|=
name|fonts
index|[
name|Roman
index|]
operator|.
name|Xwid
index|[
literal|'0'
index|]
operator|*
literal|8
expr_stmt|;
comment|/* 8 * figure width */
name|BSWidth
operator|=
name|fonts
index|[
name|Roman
index|]
operator|.
name|Xwid
index|[
literal|' '
index|]
expr_stmt|;
comment|/* space width */
name|UperLine
operator|=
operator|(
name|fonts
index|[
name|Roman
index|]
operator|.
name|dsize
operator|+
literal|1
operator|)
operator|*
name|UperPt
expr_stmt|;
if|if
condition|(
name|LPTsimulate
condition|)
block|{
name|UperHLine
operator|=
name|UperLine
expr_stmt|;
name|Lines
operator|=
name|LineMax
operator|=
literal|66
expr_stmt|;
block|}
else|else
block|{
name|UperHLine
operator|=
operator|(
name|fonts
index|[
name|HeaderFont
index|]
operator|.
name|dsize
operator|+
literal|1
operator|)
operator|*
name|UperPt
expr_stmt|;
block|}
name|crX
operator|=
literal|0
expr_stmt|;
name|crY
operator|=
operator|-
name|UperLine
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return a font number for the font with the indicated name and size.  Adds  * info to the font list for the eventual search.   */
end_comment

begin_function
name|private
name|int
name|DefineFont
parameter_list|(
name|name
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|font
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|&
name|fonts
index|[
name|nf
index|]
expr_stmt|;
name|VOIDC
name|strcpy
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|p
operator|->
name|dsize
operator|=
name|size
expr_stmt|;
return|return
operator|(
name|nf
operator|++
operator|)
return|;
block|}
end_function

begin_comment
comment|/* dump the fonts to the PS file for setup */
end_comment

begin_function
name|private
name|VOID
name|DumpFonts
parameter_list|()
block|{
specifier|register
name|struct
name|font
modifier|*
name|f
decl_stmt|;
name|ForAllFonts
argument_list|(
argument|f
argument_list|)
block|{
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%d %d /%s\n"
argument_list|,
name|f
operator|-
operator|&
name|fonts
index|[
literal|0
index|]
argument_list|,
name|f
operator|->
name|dsize
operator|*
name|UperPt
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%d SetUpFonts\n"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* add a shown character to the PS file */
end_comment

begin_function
name|private
name|VOID
name|OUTputc
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|showpending
condition|)
block|{
name|putc
argument_list|(
literal|'('
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
name|showpending
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|')'
condition|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|>
literal|0176
operator|)
operator|||
operator|(
name|c
operator|<
literal|040
operator|)
condition|)
block|{
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator|+
literal|'0'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|(
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
literal|07
operator|)
operator|+
literal|'0'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|(
name|c
operator|&
literal|07
operator|)
operator|+
literal|'0'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
block|}
else|else
name|putc
argument_list|(
name|c
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* put a correctly escaped string to the PS file */
end_comment

begin_function
name|private
name|VOID
name|OUTstr
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|showpending
condition|)
block|{
name|putc
argument_list|(
literal|'('
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
name|showpending
operator|=
name|TRUE
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|s
condition|)
name|OUTputc
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|')'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
name|showpending
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the current font */
end_comment

begin_function
name|private
name|VOID
name|SetFont
parameter_list|(
name|f
parameter_list|)
name|int
name|f
decl_stmt|;
block|{
name|FlushShow
argument_list|()
expr_stmt|;
name|CurFont
operator|=
name|f
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%d F\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * put a character onto the page at the desired X and Y positions. If the  * current position doesn't agree with the desired position, put out movement  * directives.  Leave the current position updated to account for the  * character.   */
end_comment

begin_function
name|private
name|VOID
name|ShowChar
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|struct
name|font
modifier|*
name|f
decl_stmt|;
specifier|register
name|long
name|nX
decl_stmt|,
name|nY
decl_stmt|;
specifier|static
name|level
operator|=
literal|0
expr_stmt|;
name|level
operator|++
expr_stmt|;
name|f
operator|=
operator|&
name|fonts
index|[
name|CurFont
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|Xwid
index|[
name|c
index|]
operator|==
name|NOTDEF
condition|)
block|{
name|UndefChars
operator|++
expr_stmt|;
if|if
condition|(
name|ListOmitted
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: \\%03o not found in font %s\n"
argument_list|,
name|prog
argument_list|,
name|c
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|<=
literal|1
condition|)
block|{
name|ShowChar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|ShowChar
argument_list|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|ShowChar
argument_list|(
operator|(
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
literal|07
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|ShowChar
argument_list|(
operator|(
name|c
operator|&
literal|07
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|3
expr_stmt|;
block|}
name|level
operator|--
expr_stmt|;
return|return;
block|}
name|nX
operator|=
name|dX
operator|+
name|f
operator|->
name|Xwid
index|[
name|c
index|]
expr_stmt|;
comment|/* resulting position after showing this char */
name|nY
operator|=
name|dY
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|' '
operator|||
operator|(
operator|(
name|cX
operator|==
name|dX
operator|)
operator|&&
operator|(
name|cY
operator|==
name|dY
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|nX
operator|<=
name|maxX
condition|)
block|{
if|if
condition|(
name|cX
operator|!=
name|dX
condition|)
block|{
if|if
condition|(
name|cY
operator|!=
name|dY
condition|)
block|{
name|FlushShow
argument_list|()
expr_stmt|;
comment|/* absolute x, relative y */
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%ld %ld"
argument_list|,
name|dX
argument_list|,
name|dY
argument_list|)
expr_stmt|;
name|movepending
operator|=
name|AbsXY
expr_stmt|;
block|}
else|else
block|{
name|FlushShow
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%ld"
argument_list|,
name|dX
operator|-
name|cX
argument_list|)
expr_stmt|;
comment|/* relative x */
name|movepending
operator|=
name|RelX
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cY
operator|!=
name|dY
condition|)
block|{
name|FlushShow
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%ld"
argument_list|,
name|dY
operator|-
name|cY
argument_list|)
expr_stmt|;
comment|/* relative y */
name|movepending
operator|=
name|RelY
expr_stmt|;
block|}
name|OUTputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|showpending
operator|=
name|TRUE
expr_stmt|;
name|cX
operator|=
name|nX
expr_stmt|;
name|cY
operator|=
name|nY
expr_stmt|;
block|}
else|else
name|TruncChars
operator|++
expr_stmt|;
block|}
name|dX
operator|=
name|nX
expr_stmt|;
name|dY
operator|=
name|nY
expr_stmt|;
name|level
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* put out a shown string to the PS file */
end_comment

begin_function
name|private
name|VOID
name|ShowStr
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|>=
literal|040
condition|)
name|ShowChar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* flush pending show */
end_comment

begin_function
name|private
name|FlushShow
parameter_list|()
block|{
if|if
condition|(
name|showpending
condition|)
block|{
name|putc
argument_list|(
literal|')'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|movepending
condition|)
block|{
case|case
name|RelX
case|:
name|putc
argument_list|(
literal|'X'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
break|break;
case|case
name|RelY
case|:
name|putc
argument_list|(
literal|'Y'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
break|break;
case|case
name|AbsXY
case|:
name|putc
argument_list|(
literal|'B'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
break|break;
case|case
name|None
case|:
name|putc
argument_list|(
literal|'S'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
break|break;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|OutFile
argument_list|)
expr_stmt|;
name|movepending
operator|=
name|None
expr_stmt|;
name|showpending
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* put out a page heading to the PS file */
end_comment

begin_function
name|private
name|VOID
name|InitPage
parameter_list|()
block|{
name|char
name|header
index|[
literal|200
index|]
decl_stmt|;
specifier|register
name|int
name|OldFont
init|=
name|CurFont
decl_stmt|;
name|TotalPages
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%%%%Page: ? %d\n"
argument_list|,
name|TotalPages
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"StartPage\n"
argument_list|)
expr_stmt|;
name|SeenText
operator|=
name|FALSE
expr_stmt|;
name|cX
operator|=
name|cY
operator|=
operator|-
literal|1
expr_stmt|;
name|showpending
operator|=
name|pagepending
operator|=
name|FALSE
expr_stmt|;
name|FirstCol
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|Rotated
condition|)
block|{
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"Landscape\n"
argument_list|)
expr_stmt|;
name|lX
operator|=
name|dX
operator|=
name|UperInch
operator|/
literal|4
operator|+
name|Xoffset
expr_stmt|;
name|lY
operator|=
name|dY
operator|=
name|PageLength
operator|-
operator|(
name|UperHLine
operator|*
literal|3
operator|)
operator|/
literal|2
expr_stmt|;
name|maxX
operator|=
name|TruePageLength
expr_stmt|;
comment|/* minY = (PageLength - TruePageWidth) + 3*UperLine+480; */
name|minY
operator|=
operator|(
name|TruePageLength
operator|-
name|TruePageWidth
operator|)
operator|+
operator|(
name|TruePageWidth
operator|-
name|PageWidth
operator|)
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|lX
operator|=
name|dX
operator|=
name|Xoffset
operator|+
operator|(
name|TwoColumn
condition|?
operator|(
name|UperInch
operator|*
literal|0.3
operator|)
else|:
operator|(
operator|(
name|UperInch
operator|*
literal|5
operator|)
operator|/
literal|8
operator|)
operator|)
expr_stmt|;
name|lY
operator|=
name|dY
operator|=
name|PageLength
operator|-
name|UperHLine
expr_stmt|;
name|maxX
operator|=
name|TruePageWidth
expr_stmt|;
name|minY
operator|=
operator|(
name|UperInch
operator|/
literal|4
operator|)
expr_stmt|;
comment|/* 0.25 inches */
block|}
name|movepending
operator|=
name|None
expr_stmt|;
name|cX
operator|=
name|dX
expr_stmt|;
name|cY
operator|=
name|dY
expr_stmt|;
if|if
condition|(
operator|!
name|NoTitle
condition|)
block|{
if|if
condition|(
name|Gaudy
condition|)
block|{
name|OUTstr
argument_list|(
name|UsersHeader
argument_list|)
expr_stmt|;
name|OUTstr
argument_list|(
name|Header
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"[%s](%d)Gaudy\n"
argument_list|,
name|FileDate
argument_list|,
operator|++
name|Page
argument_list|)
expr_stmt|;
name|cX
operator|=
name|cY
operator|=
literal|0
expr_stmt|;
comment|/* force moveto here */
block|}
else|else
block|{
name|SetFont
argument_list|(
name|HeaderFont
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%ld %ld "
argument_list|,
name|cX
argument_list|,
name|cY
argument_list|)
expr_stmt|;
name|movepending
operator|=
name|AbsXY
expr_stmt|;
if|if
condition|(
name|UsersHeader
condition|)
block|{
if|if
condition|(
operator|*
name|UsersHeader
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"()B\n"
argument_list|)
expr_stmt|;
name|movepending
operator|=
name|None
expr_stmt|;
name|showpending
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|ShowStr
argument_list|(
name|UsersHeader
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VOIDC
name|sprintf
argument_list|(
name|header
argument_list|,
literal|"%s        %s        %d"
argument_list|,
name|Header
condition|?
name|Header
else|:
literal|"              "
argument_list|,
name|FileDate
argument_list|,
operator|++
name|Page
argument_list|)
decl_stmt|;
name|ShowStr
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
name|FlushShow
argument_list|()
expr_stmt|;
block|}
name|dX
operator|=
name|lX
operator|=
name|lX
operator|+
name|crX
operator|*
literal|2
expr_stmt|;
name|dY
operator|=
name|lY
operator|=
name|lY
operator|+
name|crY
operator|*
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* fake it to force a moveto */
name|cX
operator|=
name|cY
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TwoColumn
condition|)
name|maxX
operator|=
name|maxX
operator|/
literal|2
operator|-
name|BSWidth
expr_stmt|;
else|else
name|maxX
operator|-=
operator|(
call|(
name|long
call|)
argument_list|(
name|UperInch
operator|*
literal|0.3
argument_list|)
operator|)
expr_stmt|;
name|LineMax
operator|=
operator|(
name|lY
operator|-
name|minY
operator|)
operator|/
operator|(
operator|-
name|crY
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|Lines
operator|<=
literal|0
operator|)
operator|||
operator|(
name|Lines
operator|>
name|LineMax
operator|)
condition|)
name|Lines
operator|=
name|LinesLeft
operator|=
name|LineMax
expr_stmt|;
else|else
name|LinesLeft
operator|=
name|Lines
expr_stmt|;
name|SetFont
argument_list|(
name|OldFont
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|VOID
name|ClosePage
parameter_list|()
block|{
name|FlushShow
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pagepending
condition|)
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"EndPage\n"
argument_list|)
expr_stmt|;
name|pagepending
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* skip to a new page */
end_comment

begin_function
name|private
name|VOID
name|PageEject
parameter_list|()
block|{
if|if
condition|(
name|TwoColumn
operator|&&
name|FirstCol
condition|)
block|{
name|FirstCol
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|Rotated
condition|)
block|{
name|lY
operator|=
name|dY
operator|=
name|PageLength
operator|-
operator|(
name|UperHLine
operator|*
literal|3
operator|)
operator|/
literal|2
expr_stmt|;
name|lX
operator|=
name|dX
operator|=
name|Xoffset
operator|+
name|TruePageLength
operator|/
literal|2
expr_stmt|;
name|maxX
operator|=
name|TruePageLength
operator|-
name|UperInch
operator|*
literal|0.3
expr_stmt|;
block|}
else|else
block|{
name|lY
operator|=
name|dY
operator|=
name|PageLength
operator|-
name|UperHLine
expr_stmt|;
name|lX
operator|=
name|dX
operator|=
name|Xoffset
operator|+
name|TruePageWidth
operator|/
literal|2
expr_stmt|;
name|maxX
operator|=
name|TruePageWidth
operator|-
name|UperInch
operator|*
literal|0.3
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|NoTitle
condition|)
block|{
name|dX
operator|=
name|lX
operator|=
name|lX
operator|+
name|crX
operator|*
literal|2
expr_stmt|;
name|dY
operator|=
name|lY
operator|=
name|lY
operator|+
name|crY
operator|*
literal|2
expr_stmt|;
block|}
block|}
else|else
name|ClosePage
argument_list|()
expr_stmt|;
name|LinesLeft
operator|=
name|Lines
expr_stmt|;
name|SeenText
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
name|private
name|VOID
name|CommentHeader
parameter_list|()
block|{
name|long
name|clock
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pswd
decl_stmt|;
name|char
name|hostname
index|[
literal|40
index|]
decl_stmt|;
comment|/* copy the file, prepending a new comment header */
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%%!%s\n"
argument_list|,
name|COMMENTVERSION
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%%%%Creator: "
argument_list|)
expr_stmt|;
name|pswd
operator|=
name|getpwuid
argument_list|(
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|VOIDC
name|gethostname
argument_list|(
name|hostname
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
name|hostname
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%s:%s (%s)\n"
argument_list|,
name|hostname
argument_list|,
name|pswd
operator|->
name|pw_name
argument_list|,
name|pswd
operator|->
name|pw_gecos
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%%%%Title: %s\n"
argument_list|,
operator|(
name|FileName
condition|?
name|FileName
else|:
literal|"stdin"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%%%%CreationDate: %s"
argument_list|,
operator|(
name|VOIDC
name|time
argument_list|(
operator|&
name|clock
argument_list|)
operator|,
name|ctime
argument_list|(
operator|&
name|clock
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the standard input file to the PS file */
end_comment

begin_function
name|private
name|VOID
name|CopyFile
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|col
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|OutFile
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|OutOnly
condition|)
block|{
name|OutFile
operator|=
name|PipeOut
condition|?
name|stdout
else|:
name|fopen
argument_list|(
name|OutName
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VOIDC
name|mktemp
argument_list|(
name|mstrcat
argument_list|(
name|TempName
argument_list|,
name|tempdir
argument_list|,
name|ENSCRIPTTEMP
argument_list|,
sizeof|sizeof
name|TempName
argument_list|)
argument_list|)
decl_stmt|;
name|VOIDC
name|strcpy
argument_list|(
name|OutName
argument_list|,
name|TempName
argument_list|)
decl_stmt|;
name|VOIDC
name|umask
argument_list|(
literal|077
argument_list|)
decl_stmt|;
name|OutFile
operator|=
name|fopen
argument_list|(
name|TempName
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|OutFile
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't create PS file %s\n"
argument_list|,
name|prog
argument_list|,
name|TempName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ScannedFonts
condition|)
block|{
name|ScannedFonts
operator|=
name|TRUE
expr_stmt|;
name|ScanFont
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Cvted
condition|)
block|{
name|CommentHeader
argument_list|()
expr_stmt|;
if|if
condition|(
name|nf
condition|)
block|{
specifier|register
name|struct
name|font
modifier|*
name|f
decl_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%%%%DocumentFonts:"
argument_list|)
expr_stmt|;
name|ForAllFonts
argument_list|(
argument|f
argument_list|)
block|{
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|" %s"
argument_list|,
name|f
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* copy in fixed prolog */
if|if
condition|(
name|copyfile
argument_list|(
name|mstrcat
argument_list|(
name|tempstr
argument_list|,
name|libdir
argument_list|,
name|ENSCRIPTPRO
argument_list|,
sizeof|sizeof
name|tempstr
argument_list|)
argument_list|,
name|OutFile
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: trouble copying prolog file\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"StartEnscriptDoc %% end fixed prolog\n"
argument_list|)
expr_stmt|;
name|DumpFonts
argument_list|()
expr_stmt|;
if|if
condition|(
name|Gaudy
condition|)
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%s %s InitGaudy\n"
argument_list|,
name|Rotated
condition|?
literal|"10.55"
else|:
literal|"8.0"
argument_list|,
name|TwoColumn
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PreFeed
condition|)
block|{
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"true DoPreFeed\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%%%%EndProlog\n"
argument_list|)
expr_stmt|;
block|}
name|Cvted
operator|=
name|TRUE
expr_stmt|;
name|Page
operator|=
literal|0
expr_stmt|;
name|BadChars
operator|=
literal|0
expr_stmt|;
comment|/* give each file a clean slate */
name|pagepending
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
operator|(
name|c
operator|>
literal|0177
operator|||
name|c
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|!
name|IgnoreGarbage
operator|)
condition|)
block|{
if|if
condition|(
name|BadChars
operator|++
operator|>
name|MAXBAD
condition|)
block|{
comment|/* allow some kruft but 							 * not much */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: \"%s\" not a text file? Try -g.\n"
argument_list|,
name|prog
argument_list|,
name|FileName
condition|?
name|FileName
else|:
literal|"(stdin)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PipeOut
condition|)
name|VOIDC
name|unlink
argument_list|(
name|OutName
argument_list|)
decl_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|' '
condition|)
block|{
if|if
condition|(
name|pagepending
condition|)
name|InitPage
argument_list|()
expr_stmt|;
name|ShowChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|010
case|:
comment|/* backspace */
name|dX
operator|-=
name|BSWidth
expr_stmt|;
break|break;
case|case
literal|015
case|:
comment|/* carriage return ^M */
name|dY
operator|=
name|lY
expr_stmt|;
name|dX
operator|=
name|lX
expr_stmt|;
break|break;
case|case
literal|012
case|:
comment|/* linefeed ^J */
if|if
condition|(
name|pagepending
condition|)
name|InitPage
argument_list|()
expr_stmt|;
if|if
condition|(
name|dX
operator|!=
name|lX
operator|||
name|dY
operator|!=
name|lY
operator|||
operator|!
name|LPTsimulate
operator|||
name|SeenText
condition|)
block|{
name|SeenText
operator|=
name|TRUE
expr_stmt|;
name|dY
operator|=
name|lY
operator|=
name|lY
operator|+
name|crY
expr_stmt|;
name|dX
operator|=
name|lX
operator|=
name|lX
operator|+
name|crX
expr_stmt|;
block|}
else|else
name|LinesLeft
operator|=
name|LineMax
expr_stmt|;
if|if
condition|(
operator|(
name|dY
operator|<
name|minY
operator|)
operator|||
operator|(
operator|--
name|LinesLeft
operator|<=
literal|0
operator|)
condition|)
name|PageEject
argument_list|()
expr_stmt|;
name|col
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|033
case|:
comment|/* escape */
switch|switch
condition|(
name|c
operator|=
name|getchar
argument_list|()
condition|)
block|{
case|case
literal|'7'
case|:
comment|/* backup one line */
name|dY
operator|=
name|lY
operator|=
name|lY
operator|-
name|crY
expr_stmt|;
name|dX
operator|=
name|lX
operator|=
name|lX
operator|-
name|crX
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
comment|/* backup 1/2 line */
name|dY
operator|-=
name|crY
operator|/
literal|2
expr_stmt|;
name|dX
operator|-=
name|crX
operator|/
literal|2
expr_stmt|;
break|break;
case|case
literal|'9'
case|:
comment|/* forward 1/2 linefeed */
name|dY
operator|+=
name|crY
operator|/
literal|2
expr_stmt|;
name|dX
operator|+=
name|crX
operator|/
literal|2
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* font setting */
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
literal|'a'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'z'
condition|)
if|if
condition|(
name|fontindex
index|[
name|c
operator|-
literal|'a'
index|]
operator|>=
literal|0
condition|)
name|SetFont
argument_list|(
name|fontindex
index|[
name|c
operator|-
literal|'a'
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: font '%c' not defined\n"
argument_list|,
name|prog
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad font code in file: '%c'\n"
argument_list|,
name|prog
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'D'
case|:
comment|/* date string */
name|VOIDC
name|fgets
argument_list|(
name|DateStr
argument_list|,
sizeof|sizeof
argument_list|(
name|DateStr
argument_list|)
argument_list|,
name|stdin
argument_list|)
decl_stmt|;
name|FileDate
operator|=
name|DateStr
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* new "user's" heading */
block|{
specifier|static
name|char
name|header
index|[
literal|100
index|]
decl_stmt|;
name|VOIDC
name|fgets
argument_list|(
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|,
name|stdin
argument_list|)
decl_stmt|;
name|UsersHeader
operator|=
name|header
expr_stmt|;
break|break;
block|}
case|case
literal|'H'
case|:
comment|/* new heading */
block|{
specifier|static
name|char
name|header
index|[
literal|100
index|]
decl_stmt|;
name|VOIDC
name|fgets
argument_list|(
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|,
name|stdin
argument_list|)
decl_stmt|;
name|ClosePage
argument_list|()
expr_stmt|;
name|Header
operator|=
name|header
expr_stmt|;
name|Page
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'%'
case|:
comment|/* included PostScript line */
block|{
name|char
name|psline
index|[
literal|200
index|]
decl_stmt|;
name|VOIDC
name|fgets
argument_list|(
name|psline
argument_list|,
sizeof|sizeof
argument_list|(
name|psline
argument_list|)
argument_list|,
name|stdin
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%s\n"
argument_list|,
name|psline
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|014
case|:
comment|/* form feed ^L */
name|PageEject
argument_list|()
expr_stmt|;
name|col
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|011
case|:
comment|/* tab ^I */
if|if
condition|(
name|pagepending
condition|)
name|InitPage
argument_list|()
expr_stmt|;
name|col
operator|=
operator|(
name|col
operator|-
literal|1
operator|)
operator|/
literal|8
operator|*
literal|8
operator|+
literal|9
expr_stmt|;
name|dX
operator|=
name|lX
operator|+
operator|(
name|col
operator|-
literal|1
operator|)
operator|/
literal|8
operator|*
name|TabWidth
expr_stmt|;
break|break;
default|default:
comment|/* other control character, take your 					 * chances */
if|if
condition|(
name|pagepending
condition|)
name|InitPage
argument_list|()
expr_stmt|;
name|ShowChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
name|ClosePage
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * close the PS file   */
end_comment

begin_function
name|private
name|VOID
name|ClosePS
parameter_list|()
block|{
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"%%%%Trailer\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|PreFeed
condition|)
block|{
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"false DoPreFeed\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|OutFile
argument_list|,
literal|"EndEnscriptDoc\nEnscriptJob restore\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|VOID
name|SetTime
parameter_list|(
name|tval
parameter_list|)
name|long
name|tval
decl_stmt|;
block|{
name|struct
name|tm
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|Gaudy
condition|)
block|{
name|tp
operator|=
name|localtime
argument_list|(
operator|&
name|tval
argument_list|)
expr_stmt|;
name|VOIDC
name|sprintf
argument_list|(
name|DateStr
argument_list|,
literal|"(%02d/%02d/%02d)(%02d:%02d:%02d)"
argument_list|,
name|tp
operator|->
name|tm_year
argument_list|,
name|tp
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tp
operator|->
name|tm_mday
argument_list|,
name|tp
operator|->
name|tm_hour
argument_list|,
name|tp
operator|->
name|tm_min
argument_list|,
name|tp
operator|->
name|tm_sec
argument_list|)
decl_stmt|;
block|}
else|else
block|{
name|VOIDC
name|strcpy
argument_list|(
name|DateStr
argument_list|,
name|ctime
argument_list|(
operator|&
name|tval
argument_list|)
argument_list|)
decl_stmt|;
name|DateStr
index|[
literal|24
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* get rid of newline */
block|}
name|FileDate
operator|=
name|DateStr
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ARGS
value|"12gGBlL:oqrRkKf:F:b:p:J:C:P:#:mhO:"
end_define

begin_function
name|private
name|VOID
name|ParseArgs
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
block|{
name|int
name|argp
decl_stmt|;
while|while
condition|(
operator|(
name|argp
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
name|ARGS
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"option: %c\n"
operator|,
name|argp
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|argp
condition|)
block|{
case|case
literal|'1'
case|:
name|TwoColumn
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|TwoColumn
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|Gaudy
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|UsersHeader
operator|==
name|NULL
condition|)
name|UsersHeader
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|Header
operator|==
name|NULL
condition|)
name|Header
operator|=
literal|""
expr_stmt|;
name|SHeaderFont
operator|=
name|DefineFont
argument_list|(
name|SHEADFONT
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|DateFont
operator|=
name|DefineFont
argument_list|(
name|DATEFONT
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|PgNumFont
operator|=
name|DefineFont
argument_list|(
name|PGNUMFONT
argument_list|,
literal|24
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|IgnoreGarbage
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|NoTitle
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|LPTsimulate
operator|=
name|TRUE
expr_stmt|;
name|NoTitle
operator|=
name|TRUE
expr_stmt|;
name|Lines
operator|=
literal|66
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|Lines
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|ListOmitted
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|BeQuiet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|Rotated
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|Rotated
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|PreFeed
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|PreFeed
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
block|{
specifier|register
name|char
name|font
init|=
literal|'r'
decl_stmt|;
name|int
modifier|*
name|whichfont
decl_stmt|;
if|if
condition|(
operator|*
name|optarg
operator|==
literal|'-'
condition|)
block|{
name|font
operator|=
operator|*
operator|++
name|optarg
expr_stmt|;
name|optarg
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|font
operator|<
literal|'a'
operator|)
operator|||
operator|(
literal|'z'
operator|<
name|font
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: '%c' isn't a valid font designator.\n"
argument_list|,
name|prog
argument_list|,
name|font
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|whichfont
operator|=
operator|&
name|fontindex
index|[
name|font
operator|-
literal|'a'
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|whichfont
operator|<
literal|0
condition|)
operator|*
name|whichfont
operator|=
name|nf
operator|++
expr_stmt|;
name|decodefont
argument_list|(
name|optarg
argument_list|,
operator|&
name|fonts
index|[
operator|*
name|whichfont
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
name|decodefont
argument_list|(
name|optarg
argument_list|,
operator|&
name|fonts
index|[
name|HeaderFont
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|UsersHeader
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|OutOnly
operator|=
name|TRUE
expr_stmt|;
name|VOIDC
name|strcpy
argument_list|(
name|OutName
argument_list|,
name|optarg
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|OutName
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|PipeOut
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|spoolNoBurst
operator|=
name|TRUE
expr_stmt|;
break|break;
comment|/* BSD lpr options processing */
case|case
literal|'m'
case|:
name|spoolNotify
operator|=
name|argp
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|spoolCopies
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|spoolJobClass
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|spoolJobName
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|PrinterName
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* bad option */
break|break;
case|case
literal|'O'
case|:
name|Xoffset
operator|=
name|atof
argument_list|(
name|optarg
argument_list|)
operator|*
operator|(
name|double
operator|)
name|UperInch
expr_stmt|;
if|if
condition|(
name|Xoffset
operator|<
literal|0
condition|)
name|Xoffset
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* addarg is used to construct an argv for the spooler */
end_comment

begin_function
name|private
name|VOID
name|addarg
parameter_list|(
name|argv
parameter_list|,
name|argstr
parameter_list|,
name|argc
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|argstr
decl_stmt|;
specifier|register
name|int
modifier|*
name|argc
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|argstr
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|VOIDC
name|strcpy
argument_list|(
name|p
argument_list|,
name|argstr
argument_list|)
decl_stmt|;
name|argv
index|[
operator|(
operator|*
name|argc
operator|)
operator|++
index|]
operator|=
name|p
expr_stmt|;
name|argv
index|[
operator|*
name|argc
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|private
name|VOID
name|SpoolIt
parameter_list|()
block|{
name|char
name|temparg
index|[
literal|200
index|]
decl_stmt|;
name|char
modifier|*
name|argstr
index|[
literal|200
index|]
decl_stmt|;
name|int
name|nargs
init|=
literal|0
decl_stmt|;
name|addarg
argument_list|(
name|argstr
argument_list|,
name|LPR
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
comment|/* BSD spooler */
if|if
condition|(
name|atoi
argument_list|(
name|spoolCopies
argument_list|)
operator|>
literal|1
condition|)
block|{
name|VOIDC
name|sprintf
argument_list|(
name|temparg
argument_list|,
literal|"-#%s"
argument_list|,
name|spoolCopies
argument_list|)
decl_stmt|;
name|addarg
argument_list|(
name|argstr
argument_list|,
name|temparg
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|PrinterName
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|PrinterName
operator|=
name|envget
argument_list|(
literal|"PRINTER"
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|PrinterName
operator|=
name|POSTSCRIPTPRINTER
expr_stmt|;
block|}
name|VOIDC
name|sprintf
argument_list|(
name|temparg
argument_list|,
literal|"-P%s"
argument_list|,
name|PrinterName
argument_list|)
decl_stmt|;
name|addarg
argument_list|(
name|argstr
argument_list|,
name|temparg
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BeQuiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"spooled to %s\n"
argument_list|,
name|PrinterName
argument_list|)
expr_stmt|;
if|if
condition|(
name|spoolJobClass
condition|)
block|{
name|addarg
argument_list|(
name|argstr
argument_list|,
literal|"-C"
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
name|argstr
argument_list|,
name|spoolJobClass
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
block|}
name|addarg
argument_list|(
name|argstr
argument_list|,
literal|"-J"
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|spoolJobName
condition|)
block|{
name|addarg
argument_list|(
name|argstr
argument_list|,
name|spoolJobName
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|FileName
condition|)
name|addarg
argument_list|(
name|argstr
argument_list|,
literal|"stdin"
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
else|else
name|addarg
argument_list|(
name|argstr
argument_list|,
name|FileName
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spoolNotify
condition|)
block|{
name|addarg
argument_list|(
name|argstr
argument_list|,
literal|"-m"
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spoolNoBurst
condition|)
block|{
name|addarg
argument_list|(
name|argstr
argument_list|,
literal|"-h"
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
block|}
comment|/* remove the temporary file after spooling */
name|addarg
argument_list|(
name|argstr
argument_list|,
literal|"-r"
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
comment|/* should we use a symbolic link too? */
name|addarg
argument_list|(
name|argstr
argument_list|,
name|TempName
argument_list|,
operator|&
name|nargs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"called spooler with: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(%s)"
argument_list|,
name|argstr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|execvp
argument_list|(
name|LPR
argument_list|,
name|argstr
argument_list|)
expr_stmt|;
name|pexit2
argument_list|(
name|prog
argument_list|,
literal|"can't exec spooler"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|private
name|char
modifier|*
name|eargv
index|[
literal|60
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|eargc
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* pointer to "ENSCRIPT" in env */
name|prog
operator|=
operator|*
name|argv
expr_stmt|;
comment|/* argv[0] is program name */
name|debugp
argument_list|(
operator|(
name|stderr
operator|,
literal|"PL %ld PW %ld TPL %ld TPW %ld\n"
operator|,
name|PageLength
operator|,
name|PageWidth
operator|,
name|TruePageLength
operator|,
name|TruePageWidth
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|int1
argument_list|)
operator|==
name|SIG_IGN
condition|)
block|{
name|VOIDC
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
block|}
else|else
block|{
name|VOIDC
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|int1
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|int1
argument_list|)
decl_stmt|;
name|VOIDC
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|int1
argument_list|)
decl_stmt|;
block|}
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
name|fontindex
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|libdir
operator|=
name|envget
argument_list|(
literal|"PSLIBDIR"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|libdir
operator|=
name|LibDir
expr_stmt|;
if|if
condition|(
operator|(
name|tempdir
operator|=
name|envget
argument_list|(
literal|"PSTEMPDIR"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|tempdir
operator|=
name|TempDir
expr_stmt|;
name|Roman
operator|=
name|CurFont
operator|=
name|DefineFont
argument_list|(
name|BODYROMAN
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|HeaderFont
operator|=
name|DefineFont
argument_list|(
name|HEADFONT
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* process args in environment variable ENSCRIPT */
if|if
condition|(
name|p
operator|=
name|envget
argument_list|(
literal|"ENSCRIPT"
argument_list|)
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|char
name|quote
init|=
literal|' '
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'"'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'\''
operator|)
condition|)
name|quote
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|eargv
index|[
name|eargc
operator|++
index|]
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|!=
name|quote
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'\0'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|ParseArgs
argument_list|(
name|eargc
argument_list|,
name|eargv
argument_list|)
expr_stmt|;
if|if
condition|(
name|eargc
operator|!=
name|optind
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad environment variable ENSCRIPT \"%s\"\n"
argument_list|,
name|prog
argument_list|,
name|envget
argument_list|(
literal|"ENSCRIPT"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* process the command line arguments */
name|optind
operator|=
literal|1
expr_stmt|;
comment|/* reset getopt global */
name|ParseArgs
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* process non-option args */
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
name|FileName
operator|=
name|Header
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
name|FileName
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open %s\n"
argument_list|,
name|prog
argument_list|,
name|FileName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|VOIDC
name|fstat
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|S
argument_list|)
decl_stmt|;
name|SetTime
argument_list|(
name|S
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|CopyFile
argument_list|()
expr_stmt|;
name|VOIDC
name|fclose
argument_list|(
name|stdin
argument_list|)
decl_stmt|;
name|SeenFile
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SeenFile
condition|)
block|{
name|FileName
operator|=
name|Header
operator|=
name|Gaudy
condition|?
literal|""
else|:
literal|0
expr_stmt|;
name|VOIDC
name|fstat
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|S
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|S
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
condition|)
name|SetTime
argument_list|(
name|S
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
else|else
name|SetTime
argument_list|(
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|CopyFile
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|Cvted
condition|)
block|{
name|ClosePS
argument_list|()
expr_stmt|;
name|VOIDC
name|fclose
argument_list|(
name|OutFile
argument_list|)
decl_stmt|;
name|OutFile
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TruncChars
operator|&&
operator|!
name|BeQuiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %d characters omitted because of long lines.\n"
argument_list|,
name|prog
argument_list|,
name|TruncChars
argument_list|)
expr_stmt|;
if|if
condition|(
name|UndefChars
operator|&&
operator|!
name|BeQuiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %d characters omitted because of incomplete fonts.\n"
argument_list|,
name|prog
argument_list|,
name|UndefChars
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BeQuiet
operator|&&
operator|(
name|TotalPages
operator|>
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[ %d page%s * %s cop%s ] "
argument_list|,
name|TotalPages
argument_list|,
name|TotalPages
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|spoolCopies
argument_list|,
name|atoi
argument_list|(
name|spoolCopies
argument_list|)
operator|>
literal|1
condition|?
literal|"ies"
else|:
literal|"y"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Cvted
condition|)
block|{
if|if
condition|(
operator|!
name|BeQuiet
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"left in %s\n"
argument_list|,
name|OutName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|OutOnly
condition|)
block|{
name|SpoolIt
argument_list|()
expr_stmt|;
comment|/* does an exec */
block|}
block|}
block|}
end_function

begin_comment
comment|/* signal catcher */
end_comment

begin_function
name|private
name|VOID
name|int1
parameter_list|()
block|{
if|if
condition|(
operator|(
operator|!
name|PipeOut
operator|)
operator|&&
operator|(
name|OutName
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|OutName
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|VOIDC
name|unlink
argument_list|(
name|OutName
argument_list|)
decl_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

