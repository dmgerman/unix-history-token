begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|Notice
index|[]
init|=
literal|"Copyright (c) 1985 Adobe Systems Incorporated"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSID
init|=
literal|"$Header: psrev.c,v 2.1 85/11/24 11:51:02 shore Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* psrev.c  *  * Copyright (c) 1985 Adobe Systems Incorporated  *  * page reversal and selection filter  *  * Original Version: Tom Malloy  * Edit History:  * Andrew Shore: Fri Nov 22 11:20:20 1985  * End Edit History.  *  * RCSLOG:  * $Log:	psrev.c,v $  * Revision 2.1  85/11/24  11:51:02  shore  * Product Release 2.0  *   * Revision 1.4  85/11/22  11:31:05  shore  * Last line of trailer was dropped if it didn't end in a newline  *   * Revision 1.3  85/11/20  00:52:21  shore  * Support for System V  * getopt!  * made lint a little happier  *   * Revision 1.2  85/05/14  11:26:38  shore  *   *   *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"transcript.h"
end_include

begin_define
define|#
directive|define
name|SCVERID
value|"%!PS-Adobe-"
end_define

begin_define
define|#
directive|define
name|ichMaxPage
value|7
end_define

begin_define
define|#
directive|define
name|SCPAGE
value|"%%Page:"
end_define

begin_define
define|#
directive|define
name|ichMaxTrailer
value|9
end_define

begin_define
define|#
directive|define
name|SCTRAILER
value|"%%Trailer"
end_define

begin_define
define|#
directive|define
name|ipgMax
value|2000
end_define

begin_comment
comment|/* Maximum number of pages - first page index is 0 */
end_comment

begin_define
define|#
directive|define
name|irngMax
value|30
end_define

begin_comment
comment|/* Maximum number of intervals in a page range spec */
end_comment

begin_macro
name|private
end_macro

begin_struct
struct|struct
name|Range
comment|/* continuous interval of pages to be printed */
comment|/* from a page range specification (i.e. -s) */
comment|/* page numbers match the second parameter */
comment|/* of the "%%Page: " comment */
block|{
name|int
name|pgnFst
decl_stmt|;
name|int
name|pgnLst
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|private
end_macro

begin_struct
struct|struct
name|Params
comment|/* interesting info collected from command line */
block|{
name|int
name|fReverse
decl_stmt|;
comment|/* true => reverse page order */
name|int
name|fRemove
decl_stmt|;
comment|/* true => remove input file */
name|char
modifier|*
name|scSrcFile
decl_stmt|;
comment|/* c-string containing source file name */
name|char
modifier|*
name|scDstFile
decl_stmt|;
comment|/* c-string containing destination file name */
name|int
name|irngMac
decl_stmt|;
comment|/* number of intervals in rgrange */
name|struct
name|Range
name|rgrange
index|[
name|irngMax
index|]
decl_stmt|;
comment|/* array of intervals of pages */
comment|/* to be printed.  One entry per */
comment|/* entry in the "-s" parameter */
block|}
struct|;
end_struct

begin_macro
name|private
end_macro

begin_struct
struct|struct
name|Psd
comment|/* PS file descriptor */
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* unix file descriptor  of source */
name|FILE
modifier|*
name|fpTemp
decl_stmt|;
comment|/* temp file descriptor.  Contains a  			   copy of source when fd is not a regular file */
name|long
name|int
name|posLineFst
decl_stmt|,
name|posMac
decl_stmt|;
comment|/* file positions - current, beginning of line, eof */
block|}
struct|;
end_struct

begin_decl_stmt
name|private
name|struct
name|stat
name|S
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reads a signed integer from c-string */
end_comment

begin_comment
comment|/* Input is a pointer to pointer to string */
end_comment

begin_comment
comment|/* On return, it points to first character following the parsed numeral */
end_comment

begin_function
name|private
name|IntGet
parameter_list|(
name|prgch
parameter_list|)
name|char
modifier|*
modifier|*
name|prgch
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|fNeg
decl_stmt|;
name|char
modifier|*
name|rgch
decl_stmt|,
name|ch
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|rgch
operator|=
operator|*
name|prgch
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|rgch
operator|)
operator|==
literal|'-'
condition|)
block|{
name|fNeg
operator|=
name|TRUE
expr_stmt|;
name|rgch
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
name|rgch
operator|++
expr_stmt|;
name|fNeg
operator|=
name|FALSE
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|(
name|ch
operator|=
operator|*
name|rgch
operator|)
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|rgch
operator|++
expr_stmt|;
name|i
operator|=
literal|10
operator|*
name|i
operator|+
operator|(
name|ch
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
operator|*
name|prgch
operator|=
name|rgch
expr_stmt|;
return|return
operator|(
name|fNeg
condition|?
operator|-
name|i
else|:
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parses the "-s" parameter.  Fills the array params.rgrange */
end_comment

begin_comment
comment|/* with a page interval range for each entry int the comma separated list */
end_comment

begin_comment
comment|/* *prgch points at the character following the "s" command */
end_comment

begin_function
name|private
name|SetPageRanges
parameter_list|(
name|rgch
parameter_list|,
name|pparams
parameter_list|)
name|char
modifier|*
name|rgch
decl_stmt|;
name|struct
name|Params
modifier|*
name|pparams
decl_stmt|;
block|{
name|char
name|ch
decl_stmt|;
name|char
modifier|*
name|scError
decl_stmt|;
name|struct
name|Range
modifier|*
name|rgrange
decl_stmt|;
define|#
directive|define
name|pgnMax
value|30000
name|scError
operator|=
literal|"Syntax error in page range specification while parsing "
expr_stmt|;
name|rgrange
operator|=
name|pparams
operator|->
name|rgrange
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|rgch
operator|)
operator|==
literal|'-'
condition|)
block|{
name|rgrange
index|[
name|pparams
operator|->
name|irngMac
index|]
operator|.
name|pgnFst
operator|=
literal|1
expr_stmt|;
name|rgch
operator|++
expr_stmt|;
name|rgrange
index|[
name|pparams
operator|->
name|irngMac
index|]
operator|.
name|pgnLst
operator|=
name|IntGet
argument_list|(
operator|&
name|rgch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rgrange
index|[
name|pparams
operator|->
name|irngMac
index|]
operator|.
name|pgnFst
operator|=
name|IntGet
argument_list|(
operator|&
name|rgch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|rgch
operator|)
operator|==
literal|'-'
condition|)
block|{
name|rgch
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ch
operator|=
operator|*
name|rgch
operator|)
operator|==
literal|','
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'\0'
operator|)
condition|)
name|rgrange
index|[
name|pparams
operator|->
name|irngMac
index|]
operator|.
name|pgnLst
operator|=
name|pgnMax
expr_stmt|;
else|else
name|rgrange
index|[
name|pparams
operator|->
name|irngMac
index|]
operator|.
name|pgnLst
operator|=
name|IntGet
argument_list|(
operator|&
name|rgch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|ch
operator|=
operator|*
name|rgch
operator|)
operator|==
literal|','
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|rgrange
index|[
name|pparams
operator|->
name|irngMac
index|]
operator|.
name|pgnLst
operator|=
name|rgrange
index|[
name|pparams
operator|->
name|irngMac
index|]
operator|.
name|pgnFst
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rgrange
index|[
name|pparams
operator|->
name|irngMac
index|]
operator|.
name|pgnFst
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%s\n"
argument_list|,
name|scError
argument_list|,
name|rgch
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|rgrange
index|[
name|pparams
operator|->
name|irngMac
index|]
operator|.
name|pgnFst
operator|==
literal|0
operator|)
operator|||
operator|(
name|rgrange
index|[
name|pparams
operator|->
name|irngMac
index|]
operator|.
name|pgnLst
operator|==
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%s\n"
argument_list|,
name|scError
argument_list|,
name|rgch
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|pparams
operator|->
name|irngMac
operator|>=
name|irngMax
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many intervals in page range specificaiton\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|rgch
operator|)
operator|==
literal|','
condition|)
name|rgch
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
break|break;
else|else
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Returns TRUE if ipg is to be printed; i.e. if it is in one of the    intervals in pparams->rgrange[0..pparams->irngMac) */
end_comment

begin_function
name|private
name|FPageInRange
parameter_list|(
name|pgn
parameter_list|,
name|pparams
parameter_list|)
name|int
name|pgn
decl_stmt|;
name|struct
name|Params
modifier|*
name|pparams
decl_stmt|;
block|{
name|int
name|irng
decl_stmt|;
name|struct
name|Range
modifier|*
name|rgrange
decl_stmt|;
define|#
directive|define
name|ichTMax
value|50
define|#
directive|define
name|ichColon
value|6
if|if
condition|(
name|pparams
operator|->
name|irngMac
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|rgrange
operator|=
name|pparams
operator|->
name|rgrange
expr_stmt|;
for|for
control|(
name|irng
operator|=
literal|0
init|;
name|irng
operator|<
name|pparams
operator|->
name|irngMac
condition|;
name|irng
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pgn
operator|>=
name|rgrange
index|[
name|irng
index|]
operator|.
name|pgnFst
operator|)
operator|&&
operator|(
name|pgn
operator|<=
name|rgrange
index|[
name|irng
index|]
operator|.
name|pgnLst
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Reads a line from the source PS file */
end_comment

begin_comment
comment|/* Fills the c-string, scDst, with the first ichMacRead characters */
end_comment

begin_comment
comment|/* of the line.  Returns TRUE if it hits end of file, FALSE otherwise */
end_comment

begin_function
name|private
name|FEofReadSc
parameter_list|(
name|scDst
parameter_list|,
name|ichMacRead
parameter_list|,
name|ppsd
parameter_list|)
name|char
name|scDst
index|[]
decl_stmt|;
name|int
name|ichMacRead
decl_stmt|;
name|struct
name|Psd
modifier|*
name|ppsd
decl_stmt|;
block|{
name|int
name|ich
decl_stmt|;
name|int
name|ch
decl_stmt|;
specifier|static
name|int
name|ateof
init|=
name|FALSE
decl_stmt|;
name|scDst
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ppsd
operator|->
name|posLineFst
operator|=
name|ftell
argument_list|(
name|ppsd
operator|->
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ateof
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
for|for
control|(
name|ich
operator|=
literal|0
init|;
name|ich
operator|<
name|ichMacRead
condition|;
name|ich
operator|++
control|)
block|{
name|scDst
index|[
name|ich
index|]
operator|=
name|ch
operator|=
name|getc
argument_list|(
name|ppsd
operator|->
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|ch
operator|==
name|EOF
operator|)
condition|)
break|break;
block|}
name|scDst
index|[
name|ich
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|ch
operator|!=
name|EOF
operator|)
condition|)
block|{
name|ch
operator|=
name|getc
argument_list|(
name|ppsd
operator|->
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|ateof
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|ich
operator|==
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if the source is a conforming PS file; */
end_comment

begin_comment
comment|/* i.e. first line of the source PS file contains "%!PS-Adobe-" */
end_comment

begin_function
name|private
name|FConforming
parameter_list|(
name|ppsd
parameter_list|)
name|struct
name|Psd
modifier|*
name|ppsd
decl_stmt|;
block|{
define|#
directive|define
name|ichMaxVerId
value|11
name|char
name|scVerIdT
index|[
name|ichMaxVerId
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|FEofReadSc
argument_list|(
name|scVerIdT
argument_list|,
name|ichMaxVerId
argument_list|,
name|ppsd
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|scVerIdT
argument_list|,
name|SCVERID
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Finds the beginning of pages.  Loads rgposPage with the file position */
end_comment

begin_comment
comment|/* of the "%%Page:" comment line */
end_comment

begin_function
name|private
name|FindPageStarts
parameter_list|(
name|ppsd
parameter_list|,
name|rgposPage
parameter_list|,
name|rgpgnPage
parameter_list|,
name|pipgMac
parameter_list|)
name|struct
name|Psd
modifier|*
name|ppsd
decl_stmt|;
name|long
name|rgposPage
index|[]
decl_stmt|;
name|int
name|rgpgnPage
index|[]
decl_stmt|;
name|int
modifier|*
name|pipgMac
decl_stmt|;
block|{
define|#
directive|define
name|ichMaxScT
value|40
name|char
name|scT
index|[
name|ichMaxScT
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|scT1
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|FEofReadSc
argument_list|(
name|scT
argument_list|,
name|ichMaxScT
argument_list|,
name|ppsd
argument_list|)
condition|)
block|{
name|rgposPage
index|[
operator|*
name|pipgMac
index|]
operator|=
name|ppsd
operator|->
name|posLineFst
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|scT
argument_list|,
name|SCPAGE
argument_list|,
name|ichMaxPage
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rgposPage
index|[
operator|*
name|pipgMac
index|]
operator|=
name|ppsd
operator|->
name|posLineFst
expr_stmt|;
name|scT1
operator|=
operator|&
name|scT
index|[
name|ichColon
operator|+
literal|1
index|]
expr_stmt|;
comment|/* skip blanks */
while|while
condition|(
operator|*
name|scT1
operator|==
literal|' '
condition|)
name|scT1
operator|++
expr_stmt|;
comment|/* skip label */
while|while
condition|(
operator|(
operator|*
name|scT1
operator|!=
literal|' '
operator|)
operator|&&
operator|(
operator|*
name|scT1
operator|!=
literal|'\n'
operator|)
condition|)
name|scT1
operator|++
expr_stmt|;
comment|/* skip blanks */
while|while
condition|(
operator|*
name|scT1
operator|==
literal|' '
condition|)
name|scT1
operator|++
expr_stmt|;
name|rgpgnPage
index|[
operator|*
name|pipgMac
index|]
operator|=
name|IntGet
argument_list|(
operator|&
name|scT1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pipgMac
operator|)
operator|<
operator|(
name|ipgMax
operator|-
literal|1
operator|)
condition|)
operator|(
operator|*
name|pipgMac
operator|)
operator|++
expr_stmt|;
else|else
break|break;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|scT
argument_list|,
name|SCTRAILER
argument_list|,
name|ichMaxTrailer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rgposPage
index|[
operator|*
name|pipgMac
index|]
operator|=
name|ppsd
operator|->
name|posLineFst
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
operator|!
name|FEofReadSc
argument_list|(
name|scT
argument_list|,
literal|1
argument_list|,
name|ppsd
argument_list|)
condition|)
empty_stmt|;
name|ppsd
operator|->
name|posMac
operator|=
name|ppsd
operator|->
name|posLineFst
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move the bytes from posFst to posLim from source to destination PS file */
end_comment

begin_function
name|private
name|MovePage
parameter_list|(
name|fdPsSrc
parameter_list|,
name|posFst
parameter_list|,
name|posLim
parameter_list|,
name|fdPsDst
parameter_list|)
name|int
name|fdPsSrc
decl_stmt|;
name|long
name|int
name|posFst
decl_stmt|,
name|posLim
decl_stmt|;
name|int
name|fdPsDst
decl_stmt|;
block|{
define|#
directive|define
name|ichMaxBuf
value|4096
name|char
name|rgchBuf
index|[
name|ichMaxBuf
index|]
decl_stmt|;
name|int
name|cchRead
decl_stmt|,
name|cchMove
decl_stmt|,
name|cchWrite
decl_stmt|;
specifier|register
name|unsigned
name|nbr
decl_stmt|;
name|VOIDC
name|lseek
argument_list|(
name|fdPsSrc
argument_list|,
name|posFst
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|cchMove
operator|=
name|posLim
operator|-
name|posFst
expr_stmt|;
while|while
condition|(
name|cchMove
operator|>
literal|0
condition|)
block|{
name|nbr
operator|=
operator|(
name|unsigned
operator|)
operator|(
name|cchMove
operator|<
name|ichMaxBuf
operator|)
condition|?
name|cchMove
else|:
name|ichMaxBuf
expr_stmt|;
name|cchRead
operator|=
name|read
argument_list|(
name|fdPsSrc
argument_list|,
name|rgchBuf
argument_list|,
name|nbr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cchRead
operator|!=
name|ichMaxBuf
operator|)
operator|&&
operator|(
name|cchRead
operator|!=
name|cchMove
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: problem reading source file\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|cchWrite
operator|=
name|write
argument_list|(
name|fdPsDst
argument_list|,
name|rgchBuf
argument_list|,
operator|(
name|unsigned
operator|)
name|cchRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|cchWrite
operator|!=
name|cchRead
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: problem writing new file\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|cchMove
operator|=
name|cchMove
operator|-
name|cchRead
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|ARGS
value|"Rrp:s:"
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|ipgMac
decl_stmt|,
name|ipgT
decl_stmt|;
name|struct
name|Psd
name|psd
decl_stmt|;
name|struct
name|Params
name|params
decl_stmt|;
name|long
name|rgposPage
index|[
name|ipgMax
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|rgpgnPage
index|[
name|ipgMax
operator|+
literal|1
index|]
decl_stmt|;
name|FILE
modifier|*
name|fpPsDst
decl_stmt|;
name|char
name|scTemp
index|[
literal|50
index|]
decl_stmt|,
modifier|*
name|tempdir
decl_stmt|;
name|int
name|fSpooledPage
decl_stmt|;
name|int
name|fdPsSrc
decl_stmt|,
name|fdPsDst
decl_stmt|;
name|int
name|ch
decl_stmt|;
specifier|register
name|int
name|argp
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
name|prog
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
operator|(
name|tempdir
operator|=
name|envget
argument_list|(
literal|"PSTEMPDIR"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|tempdir
operator|=
name|TempDir
expr_stmt|;
name|VOIDC
name|mstrcat
argument_list|(
name|scTemp
argument_list|,
name|tempdir
argument_list|,
name|REVTEMP
argument_list|,
sizeof|sizeof
name|scTemp
argument_list|)
decl_stmt|;
name|ipgMac
operator|=
literal|0
expr_stmt|;
name|params
operator|.
name|scSrcFile
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|scDstFile
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|fReverse
operator|=
name|TRUE
expr_stmt|;
name|params
operator|.
name|fRemove
operator|=
name|FALSE
expr_stmt|;
name|params
operator|.
name|irngMac
operator|=
literal|0
expr_stmt|;
name|psd
operator|.
name|fp
operator|=
name|NULL
expr_stmt|;
name|psd
operator|.
name|fpTemp
operator|=
name|NULL
expr_stmt|;
comment|/* process the command line arguments */
while|while
condition|(
operator|(
name|argp
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|ARGS
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|argp
condition|)
block|{
case|case
literal|'r'
case|:
name|params
operator|.
name|fRemove
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|params
operator|.
name|fReverse
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|params
operator|.
name|scDstFile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|SetPageRanges
argument_list|(
name|optarg
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown option -%c\n"
argument_list|,
name|prog
argument_list|,
name|argp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|params
operator|.
name|scSrcFile
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|psd
operator|.
name|fp
operator|=
name|fopen
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open %s\n"
argument_list|,
name|prog
argument_list|,
name|params
operator|.
name|scSrcFile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|psd
operator|.
name|fp
operator|=
name|stdin
expr_stmt|;
name|VOIDC
name|fstat
argument_list|(
name|fileno
argument_list|(
name|psd
operator|.
name|fp
argument_list|)
argument_list|,
operator|&
name|S
argument_list|)
decl_stmt|;
comment|/* if its not a regular file then copy it to a temp file and use */
comment|/* the temp from now on */
if|if
condition|(
operator|(
name|S
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
condition|)
block|{
name|VOIDC
name|mktemp
argument_list|(
name|scTemp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|psd
operator|.
name|fpTemp
operator|=
name|fopen
argument_list|(
name|scTemp
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: could not open temp file\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|psd
operator|.
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|ch
argument_list|,
name|psd
operator|.
name|fpTemp
argument_list|)
expr_stmt|;
name|VOIDC
name|fclose
argument_list|(
name|psd
operator|.
name|fpTemp
argument_list|)
decl_stmt|;
name|psd
operator|.
name|fpTemp
operator|=
name|fopen
argument_list|(
name|scTemp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|VOIDC
name|unlink
argument_list|(
name|scTemp
argument_list|)
decl_stmt|;
name|psd
operator|.
name|fp
operator|=
name|psd
operator|.
name|fpTemp
expr_stmt|;
block|}
if|if
condition|(
name|FConforming
argument_list|(
operator|&
name|psd
argument_list|)
condition|)
block|{
name|FindPageStarts
argument_list|(
operator|&
name|psd
argument_list|,
name|rgposPage
argument_list|,
name|rgpgnPage
argument_list|,
operator|&
name|ipgMac
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipgMac
operator|==
name|ipgMax
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Too many pages in PS file, sorry\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rgposPage
index|[
name|ipgMac
index|]
operator|==
name|psd
operator|.
name|posMac
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: PS file does not contain a conforming trailer\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* remove the input file if it was requested from */
comment|/* command line */
if|if
condition|(
name|params
operator|.
name|fRemove
condition|)
block|{
name|VOIDC
name|unlink
argument_list|(
name|params
operator|.
name|scSrcFile
argument_list|)
decl_stmt|;
name|params
operator|.
name|scSrcFile
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|.
name|scDstFile
operator|==
name|NULL
condition|)
block|{
name|fpPsDst
operator|=
name|stdout
expr_stmt|;
block|}
else|else
block|{
comment|/* remove the input file if output file = input file */
if|if
condition|(
operator|(
name|params
operator|.
name|scSrcFile
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|params
operator|.
name|scSrcFile
argument_list|,
name|params
operator|.
name|scDstFile
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|VOIDC
name|unlink
argument_list|(
name|params
operator|.
name|scSrcFile
argument_list|)
decl_stmt|;
name|fpPsDst
operator|=
name|fopen
argument_list|(
name|params
operator|.
name|scDstFile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpPsDst
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: could not open output file %s\n"
argument_list|,
name|prog
argument_list|,
name|params
operator|.
name|scDstFile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|fdPsSrc
operator|=
name|fileno
argument_list|(
name|psd
operator|.
name|fp
argument_list|)
expr_stmt|;
name|fdPsDst
operator|=
name|fileno
argument_list|(
name|fpPsDst
argument_list|)
expr_stmt|;
name|MovePage
argument_list|(
name|fdPsSrc
argument_list|,
literal|0L
argument_list|,
name|rgposPage
index|[
literal|0
index|]
argument_list|,
name|fdPsDst
argument_list|)
expr_stmt|;
name|fSpooledPage
operator|=
name|FALSE
expr_stmt|;
name|ipgT
operator|=
name|params
operator|.
name|fReverse
condition|?
name|ipgMac
operator|-
literal|1
else|:
literal|0
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
name|FPageInRange
argument_list|(
name|rgpgnPage
index|[
name|ipgT
index|]
argument_list|,
operator|&
name|params
argument_list|)
condition|)
block|{
name|fSpooledPage
operator|=
name|TRUE
expr_stmt|;
name|MovePage
argument_list|(
name|fdPsSrc
argument_list|,
name|rgposPage
index|[
name|ipgT
index|]
argument_list|,
name|rgposPage
index|[
name|ipgT
operator|+
literal|1
index|]
argument_list|,
name|fdPsDst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|.
name|fReverse
condition|)
block|{
if|if
condition|(
name|ipgT
operator|==
literal|0
condition|)
break|break;
name|ipgT
operator|--
expr_stmt|;
block|}
else|else
block|{
name|ipgT
operator|++
expr_stmt|;
if|if
condition|(
name|ipgT
operator|==
name|ipgMac
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|fSpooledPage
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: No pages in specified range!\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|MovePage
argument_list|(
name|fdPsSrc
argument_list|,
name|rgposPage
index|[
name|ipgMac
index|]
argument_list|,
name|psd
operator|.
name|posMac
argument_list|,
name|fdPsDst
argument_list|)
expr_stmt|;
name|VOIDC
name|fclose
argument_list|(
name|fpPsDst
argument_list|)
decl_stmt|;
if|if
condition|(
name|psd
operator|.
name|fpTemp
operator|!=
name|NULL
condition|)
name|VOIDC
name|fclose
argument_list|(
name|psd
operator|.
name|fpTemp
argument_list|)
decl_stmt|;
else|else
name|VOIDC
name|fclose
argument_list|(
name|psd
operator|.
name|fp
argument_list|)
decl_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: PS file does not begin with a version identifier\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

