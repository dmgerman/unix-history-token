begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	@(#)psdit.c	1.3 %G%	*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|Notice
index|[]
init|=
literal|"Copyright (c) 1984, 1985 Adobe Systems Incorporated"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSID
init|=
literal|"$Header: psdit.c,v 2.1 85/11/24 11:50:41 shore Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|XMOD
end_define

begin_comment
comment|/*  * Changed by Edward Wang (edward@ucbarpa.berkeley.edu) to handle graphics,  * 17 Feb, 87, with code provided by John Coker (john@renoir.berkeley.edu)  * and Peehong Chen (phc@renoir.berkeley.edu).  */
end_comment

begin_comment
comment|/* psdit.c  *  * Copyright (c) 1984, 1985 Adobe Systems Incorporated  *  * ditroff intermediate file to PostScript translator  *  * Original Version: Barry Hayes spring/summer 1984  * Edit History:  * Andrew Shore: Sat Nov 23 20:05:26 1985  * End Edit History.  *  * RCSLOG:  * $Log:	psdit.c,v $  * Revision 2.1  85/11/24  11:50:41  shore  * Product Release 2.0  *  * Revision 1.8  85/11/23  20:09:44  shore  * test for termination of included PostScript was bad  *  * Revision 1.7  85/11/21  14:23:56  shore  * added envget check for PSLIBDIR  *  * Revision 1.6  85/11/20  00:43:43  shore  * support for included PostScript  * big rework on FlushShow, word "breaks"  * removed FlushFont and made them instant  * Still no Gremlin support yet  *  * Revision 1.5  85/10/03  10:48:09  shore  * added FlushShow to xf fix !  *  * Revision 1.4  85/10/02  16:20:32  shore  * fixed xf bug  * mounting a font causes a font switch!  *  * Revision 1.3  85/07/09  13:10:20  shore  * added fclose on map file  *  * Revision 1.2  85/05/14  11:24:23  shore  * added flush to trailer  * fixed read bug when mounting fonts  */
end_comment

begin_comment
comment|/* output language from troff: all numbers are character strings  sn	size in points fn	font as number from 1-n cx	ascii character x Cxyz	funny char xyz. terminated by white space Hn	go to absolute horizontal position n Vn	go to absolute vertical position n (down is positive) hn	go n units horizontally (relative) vn	ditto vertically nnc	move right nn, then print c (exactly 2 digits!) 		(this wart is an optimization that shrinks output file size 		 about 35% and run-time about 15% while preserving ascii-ness) Dt ...\n	draw operation 't': 	Dl x y		line from here by x,y 	Dc d		circle of diameter d with left side here 	De x y		ellipse of axes x,y with left side here 	Da x y r	arc counter-clockwise by x,y of radius r 	Dp ...		bordered polygon 	DP ...		unbordered polygon 	D~ x y x y ...	b-spline by x,y then x,y ... 	Dg ...		gremlin curve 	Dz ...		bezier curve nb a	end of line (information only -- no action needed) 	a = space before line, a = after w	paddable word space -- no action needed pn	new page begins -- set v to 0 {	push current environment (font info& location) }	pop a saved environment txxxx	print string xxxx using natural widths #...\n	comment x ...\n	device control functions: 	x i[nit]	init 	x T s		name of device is s 	x r[es] n h v	resolution is n/inch 			h = min horizontal motion, v = min vert 	x p[ause]	pause (can restart) 	x s[top]	stop -- done for ever 	x t[railer]	generate trailer 	x f[font] n s	font position n contains font s 	x H[eight] n	set character height to n 	x S[slant] n	set slant to N  Adobe Extension for included PostScript: % (raw postscript...) .\n  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_function_decl
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"transcript.h"
end_include

begin_include
include|#
directive|include
file|"dev.h"
end_include

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NFONT
value|10
end_define

begin_comment
comment|/* DIT state consists of: */
end_comment

begin_decl_stmt
name|int
name|hpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current horizontal position */
end_comment

begin_decl_stmt
name|int
name|vpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current vertical position */
end_comment

begin_decl_stmt
name|int
name|fontsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current font size */
end_comment

begin_decl_stmt
name|int
name|fontheight
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current character height */
end_comment

begin_decl_stmt
name|int
name|fontslant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current font slant */
end_comment

begin_decl_stmt
name|int
name|font
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current font */
end_comment

begin_decl_stmt
name|int
name|resolution
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device resolution */
end_comment

begin_decl_stmt
name|int
name|minhoriz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* minimum horizontal motion */
end_comment

begin_decl_stmt
name|int
name|minvert
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* minimum vertical motion */
end_comment

begin_decl_stmt
name|int
name|onspecial
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|specfont
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prevfont
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pfont
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* {} push/pop stack */
end_comment

begin_define
define|#
directive|define
name|DSTACK
value|10
end_define

begin_struct
struct|struct
name|ditstack
block|{
name|int
name|hpos
decl_stmt|,
name|vpos
decl_stmt|,
name|fontsize
decl_stmt|,
name|fontheight
decl_stmt|,
name|fontslant
decl_stmt|,
name|font
decl_stmt|;
block|}
name|ditstack
index|[
name|DSTACK
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|dlevel
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ErrorTolerance
value|48
end_define

begin_define
define|#
directive|define
name|PSWID
value|0x00000FFF
end_define

begin_define
define|#
directive|define
name|ISPSPROC
value|0x000FF000
end_define

begin_comment
comment|/* PSscale is equivalent to (x * PSmag / 72000) + 0.5 */
end_comment

begin_define
define|#
directive|define
name|PSmag
value|16
end_define

begin_define
define|#
directive|define
name|PSscale
parameter_list|(
name|x
parameter_list|)
value|(((x) + 2250) / 4500)
end_define

begin_comment
comment|/* we maintain PS coords with PSmag times the precision */
end_comment

begin_comment
comment|/* current PS state is: */
end_comment

begin_decl_stmt
name|int
name|PSx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current horizontal position */
end_comment

begin_decl_stmt
name|int
name|PSy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current vertical position */
end_comment

begin_decl_stmt
name|int
name|savex
decl_stmt|,
name|savey
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* position of start of current show string */
end_comment

begin_comment
comment|/* ps move types -- note that XMOVE|YMOVE == XYMOVE ! */
end_comment

begin_define
define|#
directive|define
name|NONE
value|0
end_define

begin_define
define|#
directive|define
name|XMOVE
value|1
end_define

begin_define
define|#
directive|define
name|YMOVE
value|2
end_define

begin_define
define|#
directive|define
name|XYMOVE
value|3
end_define

begin_decl_stmt
name|int
name|movepending
init|=
name|NONE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer string for show -- save up adjacent chars */
end_comment

begin_define
define|#
directive|define
name|SHOWSIZE
value|400
end_define

begin_decl_stmt
name|char
name|showbuf
index|[
name|SHOWSIZE
operator|+
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* extras are for quoting */
end_comment

begin_decl_stmt
name|int
name|showind
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index into string of next available byte */
end_comment

begin_decl_stmt
name|int
name|PSshowlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size in big units of buffered string */
end_comment

begin_decl_stmt
name|int
name|nshow
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* actual number of show chars in showbuf */
end_comment

begin_decl_stmt
name|int
name|startx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* troff starting pos of current string */
end_comment

begin_decl_stmt
name|int
name|thisw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #define NONE 0 */
end_comment

begin_define
define|#
directive|define
name|HMOT
value|1
end_define

begin_define
define|#
directive|define
name|VMOT
value|2
end_define

begin_define
define|#
directive|define
name|CPUT
value|4
end_define

begin_define
define|#
directive|define
name|BRK
value|8
end_define

begin_define
define|#
directive|define
name|FNT
value|16
end_define

begin_decl_stmt
name|int
name|lastcmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|output
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* do we do output at all? */
end_comment

begin_decl_stmt
name|int
name|nolist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output page list if> 0 */
end_comment

begin_decl_stmt
name|int
name|olist
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pairs of page numbers */
end_comment

begin_decl_stmt
name|int
name|spage
init|=
literal|9999
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stop every spage pages */
end_comment

begin_decl_stmt
name|int
name|scount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stopped
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pageno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|firstpage
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dev
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|font
modifier|*
name|fontbase
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|pstab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dres
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* resolution from DESC */
end_comment

begin_decl_stmt
name|int
name|nsizes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of point sizes from DESC */
end_comment

begin_decl_stmt
name|int
name|nfonts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of fonts from DESC */
end_comment

begin_decl_stmt
name|int
name|smnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of first special font */
end_comment

begin_decl_stmt
name|int
name|nchtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|chname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|chtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fitab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|widthtab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* widtab would be a better name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|codetab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device codes */
end_comment

begin_decl_stmt
name|int
modifier|*
name|pswidths
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ps width tables */
end_comment

begin_decl_stmt
name|int
name|fontdelta
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nonzero if xf overwrites font i */
end_comment

begin_comment
comment|/* font position info: */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
name|fontname
index|[
name|NFONT
operator|+
literal|1
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|FATAL
value|1
end_define

begin_define
define|#
directive|define
name|BMASK
value|0377
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|dbg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fdbg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|debugp
parameter_list|(
name|xxx
parameter_list|)
value|(dbg != 0 ? (dbg--, printf xxx, fflush(stdout)) : 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debugp
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|devname
index|[
literal|20
index|]
init|=
literal|"psc"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|infilename
init|=
literal|"stdin"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|prologfile
init|=
name|PSDITPRO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ditdir
init|=
name|DitDir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* argv[0] - program name */
end_comment

begin_comment
comment|/* For curve drawing */
end_comment

begin_define
define|#
directive|define
name|MAXPOINTS
value|200
end_define

begin_struct
struct|struct
name|point
block|{
name|double
name|p_x
decl_stmt|,
name|p_y
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|done
parameter_list|()
function_decl|;
name|prog
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
condition|)
name|ditdir
operator|=
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
else|else
block|{
name|ditdir
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
condition|)
name|prologfile
operator|=
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|outlist
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|dbg
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
operator|==
literal|0
condition|)
name|dbg
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
break|break;
case|case
literal|'b'
case|:
comment|/* ignore busy */
break|break;
case|case
literal|'w'
case|:
comment|/* ignore wait */
break|break;
case|case
literal|'s'
case|:
name|spage
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|spage
operator|<=
literal|0
condition|)
name|spage
operator|=
literal|9999
expr_stmt|;
break|break;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|done
argument_list|)
operator|==
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|done
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|done
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|done
argument_list|)
expr_stmt|;
name|preface
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|conv
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
operator|++
name|argv
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|fp
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open %s\n"
argument_list|,
name|prog
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|prog
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|infilename
operator|=
operator|*
name|argv
expr_stmt|;
name|conv
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|done
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* process list of page numbers to be printed */
end_comment

begin_expr_stmt
name|outlist
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|,
name|i
decl_stmt|;
name|nolist
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|n1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|do
name|n1
operator|=
literal|10
operator|*
name|n1
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
else|else
name|n1
operator|=
operator|-
literal|9999
expr_stmt|;
name|n2
operator|=
name|n1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|n2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|do
name|n2
operator|=
literal|10
operator|*
name|n2
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
else|else
name|n2
operator|=
literal|9999
expr_stmt|;
block|}
name|olist
index|[
name|nolist
operator|++
index|]
operator|=
name|n1
expr_stmt|;
name|olist
index|[
name|nolist
operator|++
index|]
operator|=
name|n2
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|olist
index|[
name|nolist
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|dbg
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nolist
condition|;
name|i
operator|+=
literal|2
control|)
name|printf
argument_list|(
literal|"%3d %3d\n"
argument_list|,
name|olist
index|[
name|i
index|]
argument_list|,
name|olist
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|conv
argument_list|(
name|fp
argument_list|)
comment|/* convert a file */
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|k
decl_stmt|;
name|int
name|m
decl_stmt|,
name|n
decl_stmt|,
name|n1
decl_stmt|,
name|m1
decl_stmt|;
name|char
name|str
index|[
literal|100
index|]
decl_stmt|,
name|buf
index|[
literal|300
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
case|case
literal|' '
case|:
case|case
literal|'\0'
case|:
break|break;
case|case
literal|'{'
case|:
comment|/* push down current environment */
name|t_push
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|t_pop
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* two motion digits plus a character */
name|hmot
argument_list|(
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|getc
argument_list|(
name|fp
argument_list|)
operator|-
literal|'0'
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|HMOT
expr_stmt|;
name|put1
argument_list|(
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|CPUT
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* single ascii character */
name|put1
argument_list|(
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|CPUT
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|put1s
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|CPUT
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* straight text */
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|t_text
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|CPUT
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* draw function */
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'l'
case|:
comment|/* draw a line */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|drawline
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* circle */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawcirc
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* ellipse */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawellip
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* arc */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d %d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n1
argument_list|,
operator|&
name|m1
argument_list|)
expr_stmt|;
name|drawarc
argument_list|(
name|n
argument_list|,
name|m
argument_list|,
name|n1
argument_list|,
name|m1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
comment|/* b-spline */
name|drawbspline
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* gremlin curve */
name|drawcurve
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
comment|/* bezier cubic */
name|drawbezier
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* filled polygon */
case|case
literal|'P'
case|:
comment|/* bordered filled polygon */
name|drawpoly
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
operator|*
name|buf
operator|==
literal|'p'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* line thickness */
case|case
literal|'s'
case|:
comment|/* line style */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d D%c\n"
argument_list|,
name|n
argument_list|,
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown drawing function %s\n"
argument_list|,
name|prog
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d Di\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_size
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|FNT
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|setfont
argument_list|(
name|t_font
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|FNT
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* absolute horizontal motion */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
do|do
name|k
operator|=
literal|10
operator|*
name|k
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|hgoto
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|HMOT
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* relative horizontal motion */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
do|do
name|k
operator|=
literal|10
operator|*
name|k
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|HMOT
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|BRK
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|vgoto
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|VMOT
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|VMOT
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* new page */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_page
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|NONE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* end of line -- ignore */
while|while
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|BRK
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* comment */
comment|/* maybe should pass through as a PS comment */
while|while
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* device control */
name|devcntrl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
comment|/* imbedded PostScript */
comment|/* copy everything up to but NOT including a line */
comment|/* with at single "." */
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\n%% included PostScript\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|".\n"
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad input char \\%03o (%c)\n"
argument_list|,
name|prog
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* put in PostScript prolog */
end_comment

begin_macro
name|preface
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|prolog
decl_stmt|;
name|char
name|hostname
index|[
literal|256
index|]
decl_stmt|;
name|char
name|tempfile
index|[
literal|512
index|]
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pswd
decl_stmt|;
name|long
name|clock
decl_stmt|;
name|char
modifier|*
name|libdir
decl_stmt|;
name|printf
argument_list|(
literal|"%%!%s\n"
argument_list|,
name|COMMENTVERSION
argument_list|)
expr_stmt|;
name|pswd
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
name|hostname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%%%%Creator: %s:%s (%s)\n"
argument_list|,
name|hostname
argument_list|,
name|pswd
operator|->
name|pw_name
argument_list|,
name|pswd
operator|->
name|pw_gecos
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%%%%Title: %s (ditroff)\n"
argument_list|,
name|infilename
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%%%%CreationDate: %s"
argument_list|,
operator|(
name|time
argument_list|(
operator|&
name|clock
argument_list|)
operator|,
name|ctime
argument_list|(
operator|&
name|clock
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%%%%EndComments\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|libdir
operator|=
name|envget
argument_list|(
literal|"PSLIBDIR"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|libdir
operator|=
name|LibDir
expr_stmt|;
name|mstrcat
argument_list|(
name|tempfile
argument_list|,
name|libdir
argument_list|,
name|prologfile
argument_list|,
sizeof|sizeof
name|tempfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyfile
argument_list|(
name|tempfile
argument_list|,
name|stdout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't copy prolog file %s\n"
argument_list|,
name|prog
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ditstart\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|devcntrl
argument_list|(
argument|fp
argument_list|)
end_macro

begin_comment
comment|/* interpret device control functions */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|str
index|[
literal|20
index|]
decl_stmt|,
name|str1
index|[
literal|50
index|]
decl_stmt|,
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|int
name|c
decl_stmt|,
name|n
decl_stmt|,
name|res
decl_stmt|,
name|minh
decl_stmt|,
name|minv
decl_stmt|;
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|str
index|[
literal|0
index|]
condition|)
block|{
comment|/* crude for now */
case|case
literal|'i'
case|:
comment|/* initialize */
name|fileinit
argument_list|()
expr_stmt|;
name|t_init
argument_list|()
expr_stmt|;
name|lastcmd
operator|=
name|NONE
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* device name */
comment|/* 		fscanf(fp, "%s", devname); 		if (strcmp(devname, "psc")) { 			fprintf(stderr, "%s: device not psc\n", prog); 			exit(2); 		} 		*/
name|printf
argument_list|(
literal|"(%s)xT\n"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|NONE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* trailer */
name|t_trailer
argument_list|()
expr_stmt|;
name|lastcmd
operator|=
name|NONE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* pause -- can restart */
name|t_reset
argument_list|(
literal|'p'
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|NONE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* stop */
name|t_reset
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|NONE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* resolution assumed when prepared */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d %d %d"
argument_list|,
operator|&
name|res
argument_list|,
operator|&
name|minh
argument_list|,
operator|&
name|minv
argument_list|)
expr_stmt|;
name|t_res
argument_list|(
name|res
argument_list|,
name|minh
argument_list|,
name|minv
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|NONE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* font used */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d %s"
argument_list|,
operator|&
name|n
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* in case theres a filename */
name|ungetc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* fgets goes too far */
name|str1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* in case there is nothing to come in */
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
name|str1
argument_list|)
expr_stmt|;
name|loadfont
argument_list|(
name|n
argument_list|,
name|str
argument_list|,
name|str1
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|FNT
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* char height */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_charht
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|FNT
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* slant */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_slant
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|FNT
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|XMOD
case|case
literal|'X'
case|:
block|{
comment|/* \X command from ditroff */
name|int
name|last
decl_stmt|;
name|char
name|largebuf
index|[
literal|128
index|]
decl_stmt|;
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%1s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|str
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'p'
case|:
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
name|fgets
argument_list|(
name|largebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|largebuf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|last
operator|=
name|strlen
argument_list|(
name|largebuf
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|last
operator|>=
literal|0
operator|&&
name|largebuf
index|[
name|last
index|]
operator|==
literal|'\n'
condition|)
block|{
name|ungetc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|largebuf
index|[
name|last
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|puts
argument_list|(
name|largebuf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
if|if
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|largebuf
argument_list|)
operator|==
literal|1
condition|)
block|{
name|char
modifier|*
name|nl
init|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|largebuf
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
name|nl
condition|)
operator|*
name|nl
operator|=
literal|'\0'
expr_stmt|;
name|includefile
argument_list|(
name|largebuf
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning - include cmd w/o path.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
endif|#
directive|endif
block|}
comment|/* skip rest of input line */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|XMOD
end_ifdef

begin_macro
name|includefile
argument_list|(
argument|filenm
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filenm
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|inf
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|firstch
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|inf
operator|=
name|fopen
argument_list|(
name|filenm
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"psdit: fopen(%s): "
argument_list|,
name|filenm
argument_list|)
expr_stmt|;
name|perror
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|c1
operator|=
name|fgetc
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|c2
operator|=
name|fgetc
argument_list|(
name|inf
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
literal|'%'
operator|||
name|c2
operator|!=
literal|'!'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"psdit: %s not a postscript file.\n"
argument_list|,
name|filenm
argument_list|)
operator|,
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"%!"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|fgetc
argument_list|(
name|inf
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstch
operator|&&
name|ch
operator|==
literal|'%'
condition|)
block|{
comment|/* we have to double leading '%'s */
name|putchar
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
block|}
name|firstch
operator|=
operator|(
name|ch
operator|==
literal|'\n'
operator|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|fileinit
argument_list|()
end_macro

begin_comment
comment|/* read in font and code files, etc. */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|,
name|fin
decl_stmt|,
name|nw
decl_stmt|;
name|char
modifier|*
name|filebase
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|temp
index|[
literal|60
index|]
decl_stmt|;
name|unsigned
name|msize
decl_stmt|;
comment|/* 	 * Open table for device, 	 * read in resolution, size info, font info, etc., and set params. 	 */
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/dev%s/DESC.out"
argument_list|,
name|ditdir
argument_list|,
name|devname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|open
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open %s - %s\n"
argument_list|,
name|prog
argument_list|,
name|devname
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|prog
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fin
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dev
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|dev
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't read %s\n"
argument_list|,
name|prog
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|prog
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|dres
operator|=
name|dev
operator|.
name|res
expr_stmt|;
name|nfonts
operator|=
name|dev
operator|.
name|nfonts
expr_stmt|;
name|nsizes
operator|=
name|dev
operator|.
name|nsizes
expr_stmt|;
name|nchtab
operator|=
name|dev
operator|.
name|nchtab
expr_stmt|;
comment|/* enough room for whole file */
name|filebase
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|dev
operator|.
name|filesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fin
argument_list|,
name|filebase
argument_list|,
name|dev
operator|.
name|filesize
argument_list|)
operator|!=
name|dev
operator|.
name|filesize
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: trouble reading %s\n"
argument_list|,
name|prog
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|prog
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|pstab
operator|=
operator|(
name|short
operator|*
operator|)
name|filebase
expr_stmt|;
comment|/* point size table */
name|chtab
operator|=
name|pstab
operator|+
name|nsizes
operator|+
literal|1
expr_stmt|;
comment|/* char index table */
name|chname
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|chtab
operator|+
name|dev
operator|.
name|nchtab
operator|)
expr_stmt|;
comment|/* char name table */
name|p
operator|=
name|chname
operator|+
name|dev
operator|.
name|lchname
expr_stmt|;
comment|/* end of char name table */
comment|/* parse the preloaded font tables */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nfonts
condition|;
name|i
operator|++
control|)
block|{
name|fontdelta
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fontbase
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|font
operator|*
operator|)
name|p
expr_stmt|;
name|nw
operator|=
operator|*
name|p
operator|&
name|BMASK
expr_stmt|;
comment|/* number of width entries */
if|if
condition|(
operator|(
name|smnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fontbase
index|[
name|i
index|]
operator|->
name|specfont
operator|==
literal|1
operator|)
condition|)
name|smnt
operator|=
name|i
expr_stmt|;
comment|/* first special font */
name|p
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
expr_stmt|;
comment|/* skip header */
name|widthtab
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
comment|/* width table */
comment|/* kern table is next */
name|codetab
index|[
name|i
index|]
operator|=
name|p
operator|+
literal|2
operator|*
name|nw
expr_stmt|;
comment|/* device codes */
name|fitab
index|[
name|i
index|]
operator|=
name|p
operator|+
literal|3
operator|*
name|nw
expr_stmt|;
comment|/* font index table */
name|p
operator|+=
literal|3
operator|*
name|nw
operator|+
name|dev
operator|.
name|nchtab
operator|+
operator|(
literal|128
operator|-
literal|32
operator|)
expr_stmt|;
comment|/* next font */
name|t_fp
argument_list|(
name|i
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|namefont
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|intname
argument_list|)
expr_stmt|;
name|loadpswidths
argument_list|(
name|i
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|namefont
argument_list|)
expr_stmt|;
name|sayload
argument_list|(
name|i
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|namefont
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|fdbg
operator|>
literal|1
condition|)
name|fontprint
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|fontdelta
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|msize
operator|=
literal|3
operator|*
literal|255
operator|+
name|dev
operator|.
name|nchtab
operator|+
operator|(
literal|128
operator|-
literal|32
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
expr_stmt|;
name|fontbase
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|font
operator|*
operator|)
name|malloc
argument_list|(
name|msize
argument_list|)
expr_stmt|;
name|widthtab
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
literal|0
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
expr_stmt|;
name|fontbase
index|[
literal|0
index|]
operator|->
name|nwfont
operator|=
literal|255
expr_stmt|;
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|loadpswidths
argument_list|(
argument|i
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|temp
index|[
literal|60
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|auxin
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|wid
decl_stmt|,
name|funny
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/dev%s/%s.aux"
argument_list|,
name|ditdir
argument_list|,
name|devname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|auxin
operator|=
name|fopen
argument_list|(
name|temp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* allocate table */
if|if
condition|(
name|pswidths
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|pswidths
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
literal|256
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* initialize to not-there */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|255
condition|;
name|pswidths
index|[
name|i
index|]
index|[
name|j
operator|++
index|]
operator|=
operator|-
literal|1
control|)
empty_stmt|;
comment|/* read them in */
while|while
condition|(
name|fscanf
argument_list|(
name|auxin
argument_list|,
literal|"%d %d %d"
argument_list|,
operator|&
name|cc
argument_list|,
operator|&
name|wid
argument_list|,
operator|&
name|funny
argument_list|)
operator|!=
name|EOF
condition|)
name|pswidths
index|[
name|i
index|]
index|[
name|cc
index|]
operator|=
name|wid
operator||
operator|(
name|funny
operator|<<
literal|12
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|auxin
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|fontprint
argument_list|(
argument|i
argument_list|)
end_macro

begin_comment
comment|/* debugging print of font i (0, ...) */
end_comment

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|j
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"font %d:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
name|i
index|]
expr_stmt|;
name|n
operator|=
name|fontbase
index|[
name|i
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
name|printf
argument_list|(
literal|"base=0%o, nchars=%d, spec=%d, name=%s, widtab=0%o, fitab=0%o\n"
argument_list|,
name|p
argument_list|,
name|n
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|specfont
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|namefont
argument_list|,
name|widthtab
index|[
name|i
index|]
argument_list|,
name|fitab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"widths:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2d"
argument_list|,
name|widthtab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\ncodetab:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2d"
argument_list|,
name|codetab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nfitab:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|dev
operator|.
name|nchtab
operator|+
literal|128
operator|-
literal|32
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2d"
argument_list|,
name|fitab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|loadfont
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|,
argument|s1
argument_list|)
end_macro

begin_comment
comment|/* load font info for font s on position n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|temp
index|[
literal|60
index|]
decl_stmt|;
name|int
name|fin
decl_stmt|,
name|nw
decl_stmt|,
name|norig
decl_stmt|;
name|int
name|bcount
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|NFONT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: illegal fp command %d %s\n"
argument_list|,
name|prog
argument_list|,
name|n
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|namefont
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|fontbase
index|[
name|n
index|]
operator|->
name|namefont
operator|!=
literal|0
condition|)
name|fontdelta
index|[
name|n
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|s1
operator|==
name|NULL
operator|||
name|s1
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/dev%s/%s.out"
argument_list|,
name|ditdir
argument_list|,
name|devname
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/%s.out"
argument_list|,
name|s1
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|open
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open font table %s\n"
argument_list|,
name|prog
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|prog
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|norig
operator|=
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
name|bcount
operator|=
literal|3
operator|*
name|norig
operator|+
name|nchtab
operator|+
literal|128
operator|-
literal|32
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|fin
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
name|n
index|]
argument_list|,
name|bcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|&
name|BMASK
operator|)
operator|>
name|norig
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Font %s too big for position %d\n"
argument_list|,
name|prog
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|nw
operator|=
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
name|widthtab
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
name|n
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
expr_stmt|;
name|codetab
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|widthtab
index|[
name|n
index|]
operator|+
literal|2
operator|*
name|nw
expr_stmt|;
name|fitab
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|widthtab
index|[
name|n
index|]
operator|+
literal|3
operator|*
name|nw
expr_stmt|;
name|t_fp
argument_list|(
name|n
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|namefont
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|intname
argument_list|)
expr_stmt|;
name|loadpswidths
argument_list|(
name|n
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|namefont
argument_list|)
expr_stmt|;
name|sayload
argument_list|(
name|n
argument_list|,
name|s
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|=
name|norig
expr_stmt|;
comment|/* so can later use full original size */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|fdbg
operator|>
literal|1
condition|)
name|fontprint
argument_list|(
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|sayload
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|,
argument|s1
argument_list|)
end_macro

begin_comment
comment|/* position n contains font s (internal s1) */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|pass
index|[
literal|60
index|]
decl_stmt|;
name|FILE
modifier|*
name|ptrfile
decl_stmt|;
name|char
name|Adobefont
index|[
literal|60
index|]
decl_stmt|;
if|if
condition|(
name|s1
operator|==
name|NULL
operator|||
name|s1
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|pass
argument_list|,
literal|"%s/dev%s/%s.map"
argument_list|,
name|ditdir
argument_list|,
name|devname
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|pass
argument_list|,
literal|"%s/%s.map"
argument_list|,
name|s1
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ptrfile
operator|=
name|fopen
argument_list|(
name|pass
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open font map file %s\n"
argument_list|,
name|prog
argument_list|,
name|pass
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|prog
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|fscanf
argument_list|(
name|ptrfile
argument_list|,
literal|"%s"
argument_list|,
name|Adobefont
argument_list|)
expr_stmt|;
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d(%s)xf %d f\n"
argument_list|,
name|n
argument_list|,
name|Adobefont
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|font
operator|=
name|n
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ptrfile
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|done
argument_list|()
end_macro

begin_block
block|{
name|t_reset
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|t_init
argument_list|()
end_macro

begin_comment
comment|/* "x i" - initialize device */
end_comment

begin_block
block|{
name|movepending
operator|=
name|NONE
expr_stmt|;
name|savex
operator|=
name|savey
operator|=
literal|0
expr_stmt|;
name|t_size
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* start somewhere */
name|t_slant
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setfont
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* set font */
name|printf
argument_list|(
literal|"xi\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%%%%EndProlog\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|t_push
argument_list|()
end_macro

begin_comment
comment|/* begin a new block */
end_comment

begin_block
block|{
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
if|if
condition|(
name|dlevel
operator|==
name|DSTACK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: ditroff push/pop overflow!\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|hpos
operator|=
name|hpos
expr_stmt|;
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|vpos
operator|=
name|vpos
expr_stmt|;
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|fontsize
operator|=
name|fontsize
expr_stmt|;
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|fontheight
operator|=
name|fontheight
expr_stmt|;
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|fontslant
operator|=
name|fontslant
expr_stmt|;
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|font
operator|=
name|font
expr_stmt|;
name|dlevel
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"\nditpush\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|t_pop
argument_list|()
end_macro

begin_comment
comment|/* pop to previous state */
end_comment

begin_block
block|{
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
if|if
condition|(
name|dlevel
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: ditroff push/pop underflow!\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|dlevel
operator|--
expr_stmt|;
name|hpos
operator|=
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|hpos
expr_stmt|;
name|vpos
operator|=
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|vpos
expr_stmt|;
name|fontsize
operator|=
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|fontsize
expr_stmt|;
name|fontheight
operator|=
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|fontheight
expr_stmt|;
name|fontslant
operator|=
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|fontslant
expr_stmt|;
name|font
operator|=
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|font
expr_stmt|;
name|printf
argument_list|(
literal|"%d s %d xH %d xS %d f\n"
argument_list|,
name|fontsize
argument_list|,
name|fontheight
argument_list|,
name|fontslant
argument_list|,
name|font
argument_list|)
expr_stmt|;
name|startx
operator|=
name|savex
operator|=
name|hpos
expr_stmt|;
name|savey
operator|=
name|vpos
expr_stmt|;
name|PSx
operator|=
name|hpos
operator|*
name|PSmag
expr_stmt|;
name|PSy
operator|=
name|vpos
operator|*
name|PSmag
expr_stmt|;
name|printf
argument_list|(
literal|"%d %d MXY\n"
argument_list|,
name|savex
argument_list|,
name|savey
argument_list|)
expr_stmt|;
name|movepending
operator|=
name|NONE
expr_stmt|;
name|printf
argument_list|(
literal|"\nditpop\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|t_page
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* do whatever new page functions */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|output
operator|&&
operator|++
name|scount
operator|>=
name|spage
condition|)
block|{
name|t_reset
argument_list|(
literal|'p'
argument_list|)
expr_stmt|;
name|scount
operator|=
literal|0
expr_stmt|;
block|}
name|output
operator|=
literal|1
expr_stmt|;
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|firstpage
condition|)
name|printf
argument_list|(
literal|"\n%d p"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|firstpage
operator|=
name|FALSE
expr_stmt|;
name|printf
argument_list|(
literal|"\n%%%%Page: %d %d\n"
argument_list|,
name|n
argument_list|,
operator|++
name|pageno
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nfonts
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fontdelta
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|sayload
argument_list|(
name|i
argument_list|,
name|fontname
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|vpos
operator|=
literal|0
expr_stmt|;
name|PSy
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%d s %d xH %d xS %d f\n"
argument_list|,
name|fontsize
argument_list|,
name|fontheight
argument_list|,
name|fontslant
argument_list|,
name|font
argument_list|)
expr_stmt|;
if|if
condition|(
name|nolist
operator|==
literal|0
condition|)
return|return;
name|output
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nolist
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
name|n
operator|>=
name|olist
index|[
name|i
index|]
operator|&&
name|n
operator|<=
name|olist
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|output
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_macro
name|t_size
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* convert integer to internal size number*/
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontsize
operator|!=
name|n
condition|)
block|{
name|fontsize
operator|=
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|XMOD
name|fontheight
operator|=
name|n
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"%d s\n"
argument_list|,
name|fontsize
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|t_charht
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set character height to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontheight
operator|!=
name|n
condition|)
block|{
name|fontheight
operator|=
name|n
expr_stmt|;
name|printf
argument_list|(
literal|"%d xH\n"
argument_list|,
name|fontheight
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|t_slant
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set slant to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontslant
operator|!=
name|n
condition|)
block|{
name|fontslant
operator|=
name|n
expr_stmt|;
name|printf
argument_list|(
literal|"%d xS\n"
argument_list|,
name|fontslant
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|t_font
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* convert string to internal font number */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|nfonts
condition|?
literal|1
else|:
name|n
return|;
block|}
end_block

begin_macro
name|t_text
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* print string s as text??? */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: ditroff t<%s> unimplemented!\n"
argument_list|,
name|prog
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|t_reset
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
name|output
operator|=
literal|1
expr_stmt|;
comment|/* by God */
if|if
condition|(
name|c
operator|==
literal|'p'
condition|)
name|printf
argument_list|(
literal|"\nxp\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|stopped
condition|)
block|{
name|printf
argument_list|(
literal|"\nxs\n"
argument_list|)
expr_stmt|;
name|stopped
operator|=
literal|1
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|t_res
argument_list|(
argument|res
argument_list|,
argument|minh
argument_list|,
argument|minv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|res
decl_stmt|,
name|minh
decl_stmt|,
name|minv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|resolution
operator|=
name|res
expr_stmt|;
name|minhoriz
operator|=
name|minh
expr_stmt|;
name|minvert
operator|=
name|minv
expr_stmt|;
name|printf
argument_list|(
literal|"%d %d %d xr\n"
argument_list|,
name|res
argument_list|,
name|minh
argument_list|,
name|minv
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|t_trailer
argument_list|()
end_macro

begin_block
block|{
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%d p"
argument_list|,
name|pageno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%%%%Trailer\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xt\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|put1s
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* s is a funny char name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
return|return;
name|debugp
argument_list|(
operator|(
literal|"%s "
operator|,
name|s
operator|)
argument_list|)
expr_stmt|;
comment|/* search for s in the funny char name table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchtab
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|chname
index|[
name|chtab
index|[
name|i
index|]
index|]
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|nchtab
condition|)
name|put1
argument_list|(
name|i
operator|+
literal|128
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|debugp
argument_list|(
operator|(
literal|"not found "
operator|)
argument_list|)
expr_stmt|;
name|putnf
argument_list|(
literal|0
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|needsescape
parameter_list|(
name|c
parameter_list|)
value|((c) == '\\' || (c) == '(' || (c) == ')')
end_define

begin_macro
name|put1
argument_list|(
argument|c
argument_list|,
argument|s
argument_list|)
end_macro

begin_comment
comment|/* output char c */
end_comment

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|pw
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|int
name|cc
decl_stmt|;
name|int
name|ofont
decl_stmt|,
name|code
decl_stmt|;
name|int
name|psinfo
decl_stmt|,
name|pswid
decl_stmt|,
name|tw
decl_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
return|return;
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
block|{
name|thisw
operator|=
literal|0
expr_stmt|;
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
operator|<
literal|' '
condition|)
block|{
name|debugp
argument_list|(
operator|(
literal|"non-exist 0%o\n"
operator|,
name|c
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|-=
literal|32
expr_stmt|;
comment|/* offset char code */
name|k
operator|=
name|ofont
operator|=
name|pfont
operator|=
name|font
expr_stmt|;
if|if
condition|(
name|onspecial
condition|)
name|pfont
operator|=
name|prevfont
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|fitab
index|[
name|pfont
index|]
index|[
name|c
index|]
operator|&
name|BMASK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* char on this font */
name|p
operator|=
name|codetab
index|[
name|pfont
index|]
expr_stmt|;
name|pw
operator|=
name|widthtab
index|[
name|pfont
index|]
expr_stmt|;
if|if
condition|(
name|onspecial
condition|)
block|{
name|setfont
argument_list|(
name|prevfont
argument_list|)
expr_stmt|;
name|thisw
operator|=
literal|0
expr_stmt|;
name|onspecial
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|smnt
operator|>
literal|0
condition|)
block|{
comment|/* on special (we hope) */
for|for
control|(
name|k
operator|=
name|smnt
init|;
name|k
operator|<=
name|nfonts
condition|;
name|k
operator|+=
literal|1
control|)
if|if
condition|(
operator|(
name|i
operator|=
name|fitab
index|[
name|k
index|]
index|[
name|c
index|]
operator|&
name|BMASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|codetab
index|[
name|k
index|]
expr_stmt|;
name|pw
operator|=
name|widthtab
index|[
name|k
index|]
expr_stmt|;
name|prevfont
operator|=
name|pfont
expr_stmt|;
if|if
condition|(
name|onspecial
operator|&&
name|k
operator|==
name|specfont
condition|)
break|break;
name|setfont
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|thisw
operator|=
literal|0
expr_stmt|;
name|onspecial
operator|=
literal|1
expr_stmt|;
name|specfont
operator|=
name|k
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|k
operator|>
name|nfonts
operator|||
operator|(
name|code
operator|=
name|p
index|[
name|i
index|]
operator|&
name|BMASK
operator|)
operator|==
literal|0
condition|)
block|{
name|debugp
argument_list|(
operator|(
literal|"not found 0%o\n"
operator|,
name|c
operator|+
literal|32
operator|)
argument_list|)
expr_stmt|;
name|putnf
argument_list|(
name|c
operator|+
literal|32
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * when we get here, 	 *  c == biased character code 	 *	k == font number 	 *  i == index into codetab and widthtab for this character 	 *  p == codetab for this font 	 *  pw == width tab for this font 	 *  code == character code for this char 	 */
name|cc
operator|=
name|c
operator|+
literal|32
expr_stmt|;
name|debugp
argument_list|(
operator|(
operator|(
name|isascii
argument_list|(
name|cc
argument_list|)
operator|&&
name|isprint
argument_list|(
name|cc
argument_list|)
operator|)
condition|?
literal|"%c %d\n"
else|:
literal|"%03o %d\n"
operator|,
name|cc
operator|,
name|code
operator|)
argument_list|)
expr_stmt|;
name|psinfo
operator|=
name|pswidths
index|[
name|font
index|]
index|[
name|code
index|]
expr_stmt|;
comment|/* PS specific char info */
name|pswid
operator|=
name|psinfo
operator|&
name|PSWID
expr_stmt|;
comment|/* PS character width */
name|thisw
operator|=
name|pw
index|[
name|i
index|]
operator|&
name|BMASK
expr_stmt|;
comment|/* troff char width */
name|tw
operator|=
name|thisw
operator|=
operator|(
name|thisw
operator|*
name|fontsize
operator|+
name|dev
operator|.
name|unitwidth
operator|/
literal|2
operator|)
operator|/
name|dev
operator|.
name|unitwidth
expr_stmt|;
if|if
condition|(
name|psinfo
operator|&
name|ISPSPROC
operator|&&
name|psinfo
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* character is implemented by a PostScript proc */
name|showspecial
argument_list|(
name|s
argument_list|,
name|code
argument_list|,
name|pswid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pswid
operator|>
literal|0
condition|)
name|PSx
operator|+=
name|PSscale
argument_list|(
name|pswid
operator|*
name|fontsize
operator|*
name|dres
argument_list|)
expr_stmt|;
name|thisw
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|showchar
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|pswid
operator|>
literal|0
condition|)
name|PSshowlen
operator|+=
name|PSscale
argument_list|(
name|pswid
operator|*
name|fontsize
operator|*
name|dres
argument_list|)
expr_stmt|;
block|}
comment|/* 	if (font != ofont) { 		setfont(ofont); 		startx = hpos + tw; 		thisw = 0; 		lastcmd = FNT; 	} 	*/
name|debugp
argument_list|(
operator|(
literal|"...width (%d)\n"
operator|,
name|pw
index|[
name|i
index|]
operator|&
name|BMASK
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putnf
argument_list|(
argument|c
argument_list|,
argument|s
argument_list|)
end_macro

begin_comment
comment|/* note that a character wasnt found */
end_comment

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|thisw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|*
name|s
operator|==
literal|'\0'
condition|)
name|printf
argument_list|(
literal|"(\%3o)cb\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"\\|"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"\\^"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"\\&"
argument_list|)
operator|==
literal|0
condition|)
return|return;
else|else
name|printf
argument_list|(
literal|"(%s)cb\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|t_fp
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|,
argument|si
argument_list|)
end_macro

begin_comment
comment|/* font position n now contains font s, intname si */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* position */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* font (ditname) */
end_comment

begin_decl_stmt
name|char
modifier|*
name|si
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* font (intname = number) */
end_comment

begin_block
block|{
name|fontname
index|[
name|n
index|]
operator|.
name|name
operator|=
name|s
expr_stmt|;
name|fontname
index|[
name|n
index|]
operator|.
name|number
operator|=
name|atoi
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|setfont
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set font to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|NFONT
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: illegal font %d\n"
argument_list|,
name|prog
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|!=
name|n
condition|)
block|{
name|font
operator|=
name|n
expr_stmt|;
name|printf
argument_list|(
literal|"%d f\n"
argument_list|,
name|font
argument_list|)
expr_stmt|;
block|}
name|onspecial
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|drawline
argument_list|(
argument|dx
argument_list|,
argument|dy
argument_list|)
end_macro

begin_comment
comment|/* draw line from here to dx, dy */
end_comment

begin_decl_stmt
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%d %d Dl\n"
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
name|hpos
operator|+=
name|dx
expr_stmt|;
name|PSx
operator|=
name|hpos
operator|*
name|PSmag
expr_stmt|;
name|vpos
operator|+=
name|dy
expr_stmt|;
name|PSy
operator|=
name|vpos
operator|*
name|PSmag
expr_stmt|;
block|}
end_block

begin_macro
name|drawcurve
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|point
name|points
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|int
name|npoints
decl_stmt|;
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
name|getpoints
argument_list|(
name|line
argument_list|,
name|points
argument_list|,
operator|&
name|npoints
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d %d moveto\n"
argument_list|,
name|hpos
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
name|makecurve
argument_list|(
name|npoints
argument_list|,
name|points
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|drawbspline
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|point
name|points
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|int
name|npoints
decl_stmt|;
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
name|getpoints
argument_list|(
name|line
argument_list|,
name|points
argument_list|,
operator|&
name|npoints
argument_list|)
expr_stmt|;
name|makebspline
argument_list|(
name|npoints
argument_list|,
name|points
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|drawbezier
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|point
name|points
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|int
name|npoints
decl_stmt|;
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
name|getpoints
argument_list|(
name|line
argument_list|,
name|points
argument_list|,
operator|&
name|npoints
argument_list|)
expr_stmt|;
name|makebezier
argument_list|(
name|npoints
argument_list|,
name|points
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|drawpoly
argument_list|(
name|line
argument_list|,
name|border
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|point
name|points
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|int
name|npoints
decl_stmt|;
name|int
name|stipple
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|int
name|minx
decl_stmt|,
name|miny
decl_stmt|,
name|maxx
decl_stmt|,
name|maxy
decl_stmt|;
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|isspace
argument_list|(
operator|*
name|line
argument_list|)
condition|;
name|line
operator|++
control|)
empty_stmt|;
for|for
control|(
name|stipple
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|*
name|line
argument_list|)
condition|;
name|stipple
operator|=
name|stipple
operator|*
literal|10
operator|+
operator|*
name|line
operator|++
operator|-
literal|'0'
control|)
empty_stmt|;
name|getpoints
argument_list|(
name|line
argument_list|,
name|points
argument_list|,
operator|&
name|npoints
argument_list|)
expr_stmt|;
name|minx
operator|=
name|maxx
operator|=
name|hpos
expr_stmt|;
name|miny
operator|=
name|maxy
operator|=
name|vpos
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npoints
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %lg %lg lineto\n"
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|p_x
argument_list|,
name|points
index|[
name|i
index|]
operator|.
name|p_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|points
index|[
name|i
index|]
operator|.
name|p_x
operator|>
name|maxx
condition|)
name|maxx
operator|=
name|points
index|[
name|i
index|]
operator|.
name|p_x
expr_stmt|;
if|if
condition|(
name|points
index|[
name|i
index|]
operator|.
name|p_x
operator|<
name|minx
condition|)
name|minx
operator|=
name|points
index|[
name|i
index|]
operator|.
name|p_x
expr_stmt|;
if|if
condition|(
name|points
index|[
name|i
index|]
operator|.
name|p_y
operator|>
name|maxy
condition|)
name|maxy
operator|=
name|points
index|[
name|i
index|]
operator|.
name|p_y
expr_stmt|;
if|if
condition|(
name|points
index|[
name|i
index|]
operator|.
name|p_y
operator|<
name|miny
condition|)
name|miny
operator|=
name|points
index|[
name|i
index|]
operator|.
name|p_y
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"closepath %d %d %d %d %d D%c\n"
argument_list|,
name|stipple
argument_list|,
name|minx
argument_list|,
name|miny
argument_list|,
name|maxx
argument_list|,
name|maxy
argument_list|,
name|border
condition|?
literal|'p'
else|:
literal|'P'
argument_list|)
expr_stmt|;
name|PSx
operator|=
operator|(
name|hpos
operator|=
name|points
index|[
name|npoints
operator|-
literal|1
index|]
operator|.
name|p_x
operator|)
operator|*
name|PSmag
expr_stmt|;
name|PSy
operator|=
operator|(
name|vpos
operator|=
name|points
index|[
name|npoints
operator|-
literal|1
index|]
operator|.
name|p_y
operator|)
operator|*
name|PSmag
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|getpoints
argument_list|(
name|s
argument_list|,
name|points
argument_list|,
name|npoints
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|point
modifier|*
name|points
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|npoints
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|neg
decl_stmt|;
name|int
name|h
init|=
name|hpos
decl_stmt|,
name|v
init|=
name|vpos
decl_stmt|;
operator|*
name|npoints
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|points
operator|->
name|p_x
operator|=
name|h
expr_stmt|;
name|points
operator|->
name|p_y
operator|=
name|v
expr_stmt|;
name|points
operator|++
expr_stmt|;
if|if
condition|(
operator|++
operator|*
name|npoints
operator|>=
name|MAXPOINTS
condition|)
break|break;
for|for
control|(
init|;
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|neg
operator|=
operator|*
name|s
operator|==
literal|'-'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
break|break;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|x
operator|=
name|x
operator|*
literal|10
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
control|)
empty_stmt|;
if|if
condition|(
name|neg
condition|)
name|x
operator|=
operator|-
name|x
expr_stmt|;
for|for
control|(
init|;
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|neg
operator|=
operator|*
name|s
operator|==
literal|'-'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
break|break;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|y
operator|=
name|y
operator|*
literal|10
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
control|)
empty_stmt|;
if|if
condition|(
name|neg
condition|)
name|y
operator|=
operator|-
name|y
expr_stmt|;
name|h
operator|+=
name|x
expr_stmt|;
name|v
operator|+=
name|y
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|drawcirc
argument_list|(
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|int
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%d Dc\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|drawarc
argument_list|(
argument|dx1
argument_list|,
argument|dy1
argument_list|,
argument|dx2
argument_list|,
argument|dy2
argument_list|)
end_macro

begin_decl_stmt
name|int
name|dx1
decl_stmt|,
name|dy1
decl_stmt|,
name|dx2
decl_stmt|,
name|dy2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%d %d %d %d Da\n"
argument_list|,
name|dx1
argument_list|,
name|dy1
argument_list|,
name|dx2
argument_list|,
name|dy2
argument_list|)
expr_stmt|;
name|hpos
operator|+=
name|dx1
operator|+
name|dx2
expr_stmt|;
name|PSx
operator|=
name|hpos
operator|*
name|PSmag
expr_stmt|;
name|vpos
operator|+=
name|dy1
operator|+
name|dy2
expr_stmt|;
name|PSy
operator|=
name|vpos
operator|*
name|PSmag
expr_stmt|;
block|}
end_block

begin_macro
name|drawellip
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%d %d De\n"
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hmot
argument_list|(
argument|a
argument_list|)
end_macro

begin_comment
comment|/* relative horizontal motion */
end_comment

begin_decl_stmt
name|int
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|aa
decl_stmt|;
name|aa
operator|=
name|abs
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aa
operator|<
literal|8
operator|||
name|aa
operator|>
literal|10
operator|*
name|thisw
operator|||
name|a
operator|>=
literal|100
operator|||
name|thisw
operator|!=
literal|0
operator|&&
name|abs
argument_list|(
name|thisw
operator|-
name|a
argument_list|)
operator|>
literal|4
condition|)
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|hpos
operator|+=
name|a
expr_stmt|;
if|if
condition|(
name|lastcmd
operator|!=
name|CPUT
condition|)
name|startx
operator|=
name|hpos
expr_stmt|;
block|}
end_block

begin_macro
name|hgoto
argument_list|(
argument|a
argument_list|)
end_macro

begin_comment
comment|/* absolute horizontal motion */
end_comment

begin_decl_stmt
name|int
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|startx
operator|=
name|hpos
operator|=
name|a
expr_stmt|;
name|thisw
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|vmot
argument_list|(
argument|a
argument_list|)
end_macro

begin_comment
comment|/* relative vertical motion */
end_comment

begin_decl_stmt
name|int
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|vpos
operator|+=
name|a
expr_stmt|;
name|thisw
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|vgoto
argument_list|(
argument|a
argument_list|)
end_macro

begin_comment
comment|/* absolute vertical motion */
end_comment

begin_decl_stmt
name|int
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|vpos
operator|=
name|a
expr_stmt|;
name|thisw
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|showspecial
argument_list|(
argument|s
argument_list|,
argument|cc
argument_list|,
argument|wid
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wid
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|sp
decl_stmt|;
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|s
init|;
operator|*
name|sp
operator|!=
literal|'\0'
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|needsescape
argument_list|(
operator|*
name|sp
argument_list|)
condition|)
name|putchar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|sp
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")%d %d oc\n"
argument_list|,
name|cc
argument_list|,
name|wid
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|showchar
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|showind
operator|==
literal|0
condition|)
name|MoveTo
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|vpos
operator|*
name|PSmag
operator|!=
name|PSy
condition|)
block|{
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|showind
operator|>=
name|SHOWSIZE
condition|)
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
name|showbuf
index|[
name|showind
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
comment|/* fall through */
default|default:
name|showbuf
index|[
name|showind
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|showbuf
index|[
name|showind
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|showbuf
index|[
name|showind
operator|++
index|]
operator|=
operator|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator|&
literal|03
operator|)
operator|+
literal|'0'
expr_stmt|;
name|showbuf
index|[
name|showind
operator|++
index|]
operator|=
operator|(
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
literal|07
operator|)
operator|+
literal|'0'
expr_stmt|;
name|showbuf
index|[
name|showind
operator|++
index|]
operator|=
operator|(
name|c
operator|&
literal|07
operator|)
operator|+
literal|'0'
expr_stmt|;
block|}
name|showbuf
index|[
name|showind
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nshow
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|MoveTo
argument_list|()
end_macro

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|x
operator|=
name|hpos
operator|*
name|PSmag
expr_stmt|;
name|y
operator|=
name|vpos
operator|*
name|PSmag
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|PSx
condition|)
block|{
name|startx
operator|=
name|savex
operator|=
name|hpos
expr_stmt|;
name|PSx
operator|=
name|x
expr_stmt|;
name|movepending
operator||=
name|XMOVE
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|!=
name|PSy
condition|)
block|{
name|savey
operator|=
name|vpos
expr_stmt|;
name|PSy
operator|=
name|y
expr_stmt|;
name|movepending
operator||=
name|YMOVE
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|FlushMove
argument_list|()
end_macro

begin_block
block|{
switch|switch
condition|(
name|movepending
condition|)
block|{
case|case
name|NONE
case|:
break|break;
case|case
name|XMOVE
case|:
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|savex
argument_list|)
expr_stmt|;
break|break;
case|case
name|YMOVE
case|:
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|savey
argument_list|)
expr_stmt|;
break|break;
case|case
name|XYMOVE
case|:
name|printf
argument_list|(
literal|"%d %d"
argument_list|,
name|savex
argument_list|,
name|savey
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: invalid move code %d\n"
argument_list|,
name|prog
argument_list|,
name|movepending
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|movecmds
index|[]
init|=
block|{
literal|"MX"
block|,
literal|"MY"
block|,
literal|"MXY"
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|DoMove
argument_list|()
end_macro

begin_block
block|{
name|FlushMove
argument_list|()
expr_stmt|;
if|if
condition|(
name|movepending
operator|!=
name|NONE
condition|)
block|{
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|movecmds
index|[
name|movepending
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|movepending
operator|=
name|NONE
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
name|char
name|showops
index|[]
init|=
literal|"SXYN"
decl_stmt|;
end_decl_stmt

begin_macro
name|FlushShow
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|int
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|err
decl_stmt|,
name|tlen
decl_stmt|;
name|float
name|cerror
decl_stmt|;
if|if
condition|(
name|showind
operator|==
literal|0
condition|)
block|{
name|thisw
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|movepending
operator|!=
name|NONE
condition|)
name|FlushMove
argument_list|()
expr_stmt|;
name|tlen
operator|=
name|hpos
operator|-
name|startx
expr_stmt|;
if|if
condition|(
name|lastcmd
operator|==
name|CPUT
condition|)
name|tlen
operator|+=
name|thisw
expr_stmt|;
name|err
operator|=
name|tlen
operator|*
name|PSmag
operator|-
name|PSshowlen
expr_stmt|;
if|if
condition|(
name|nshow
operator|!=
literal|1
operator|&&
name|abs
argument_list|(
name|err
argument_list|)
operator|>
name|ErrorTolerance
condition|)
block|{
name|cerror
operator|=
operator|(
name|float
operator|)
name|err
operator|/
operator|(
operator|(
name|nshow
operator|-
literal|1
operator|)
operator|*
name|PSmag
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"F%d lc %d thisw %d "
argument_list|,
name|t
argument_list|,
name|lastcmd
argument_list|,
name|thisw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"x %ld h %ld tn %ld %ld "
argument_list|,
name|startx
argument_list|,
name|hpos
argument_list|,
name|tlen
operator|*
name|PSmag
argument_list|,
name|PSshowlen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error %d %.4f %s\n"
argument_list|,
name|nshow
argument_list|,
name|cerror
argument_list|,
name|showbuf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|" %.4f(%s)A%c\n"
argument_list|,
name|cerror
argument_list|,
name|showbuf
argument_list|,
name|showops
index|[
name|movepending
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"(%s)%c\n"
argument_list|,
name|showbuf
argument_list|,
name|showops
index|[
name|movepending
index|]
argument_list|)
expr_stmt|;
name|showind
operator|=
literal|0
expr_stmt|;
name|nshow
operator|=
literal|0
expr_stmt|;
name|showbuf
index|[
name|showind
index|]
operator|=
literal|'\0'
expr_stmt|;
name|PSx
operator|+=
name|PSshowlen
expr_stmt|;
name|PSshowlen
operator|=
literal|0
expr_stmt|;
name|startx
operator|=
name|hpos
expr_stmt|;
if|if
condition|(
name|lastcmd
operator|==
name|CPUT
condition|)
name|startx
operator|+=
name|thisw
expr_stmt|;
name|thisw
operator|=
literal|0
expr_stmt|;
name|movepending
operator|=
name|NONE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The following stolen (with modifications) from ... */
end_comment

begin_comment
comment|/*  * This program is part of gr2ps.  It converts Gremlin's curve output to  * control vertices of Bezier Cubics, as supported by PostScript.  * Gremlin currently supports three kinds of curves:  *	(1) cubic interpolated spline with  *	     i) periodic end condition, if two end points coincide  *	    ii) natural end condition, otherwise  *	(2) uniform cubic B-spline with  *	     i) closed curve (no vertex interpolated), if end vertices coincide  *	    ii) end vertex interpolation, otherwise  *	(3) Bezier cubics  *  * The basic idea of the conversion algorithm for the first two is  *	(1) take each curve segment's two end points as Bezier end vertices.  *	(2) find two intermediate points in the orginal curve segment  *	    (with u=1/4 and u=1/2, for example).  *	(3) solve for the two intermediate control vertices.  * The conversion between Bezier Cubics of Gremlin and that of PostScript  * is straightforward.  *  * Author: Peehong Chen (phc@renoir.berkeley.edu)  * Date: 9/17/1986  */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_define
define|#
directive|define
name|BezierMax
value|5
end_define

begin_define
define|#
directive|define
name|BC1
value|1.0/9
end_define

begin_comment
comment|/* coefficient of Bezier conversion */
end_comment

begin_define
define|#
directive|define
name|BC2
value|4*BC1
end_define

begin_define
define|#
directive|define
name|BC3
value|3*BC2
end_define

begin_define
define|#
directive|define
name|BC4
value|8*BC2
end_define

begin_decl_stmt
name|double
name|Qx
decl_stmt|,
name|Qy
decl_stmt|,
name|x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|y
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|h
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|dx
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|dy
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d2x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d2y
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numpoints
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This routine copies the list of points into an array.  */
end_comment

begin_macro
name|MakePoints
argument_list|(
argument|count
argument_list|,
argument|list
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|point
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Assign points from list to array for convenience of processing */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|count
condition|;
name|i
operator|++
control|)
block|{
name|x
index|[
name|i
index|]
operator|=
name|list
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|p_x
expr_stmt|;
name|y
index|[
name|i
index|]
operator|=
name|list
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|p_y
expr_stmt|;
block|}
name|numpoints
operator|=
name|count
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end MakePoints */
end_comment

begin_comment
comment|/*  * This routine converts each segment of a curve, P1, P2, P3, and P4  * to a set of two intermediate control vertices, V2 and V3, in a Bezier  * segment, plus a third vertex of the end point P4 (assuming the current  * position is P1), and then writes a PostScript command "V2 V3 V4 curveto"  * to the output file.  * The two intermediate vertices are obtained using  *    Q(u) = V1 * (1-u)^3 + V2 * 3u(1-u)^2 + V3 * 3(1-u)u^2 + V4 * u^3  * with u=1/4, and u=1/2,  *	Q(1/4) = Q2 = (x2, y2)  *	Q(1/2) = Q3 = (x3, y3)  *	V1 = P1  *	V4 = P4  * and  *	V2 = (32/9)*Q2 - (4/3)*(Q3 + V1) + (1/9)*V4  *	V3 = -(32/9)*Q2 + 4*Q3 + V1 - (4/9)*V4  */
end_comment

begin_macro
name|BezierSegment
argument_list|(
argument|x1
argument_list|,
argument|y1
argument_list|,
argument|x2
argument_list|,
argument|y2
argument_list|,
argument|x3
argument_list|,
argument|y3
argument_list|,
argument|x4
argument_list|,
argument|y4
argument_list|)
end_macro

begin_decl_stmt
name|double
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|x3
decl_stmt|,
name|y3
decl_stmt|,
name|x4
decl_stmt|,
name|y4
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|V2x
decl_stmt|,
name|V2y
decl_stmt|,
name|V3x
decl_stmt|,
name|V3y
decl_stmt|;
name|V2x
operator|=
name|BC4
operator|*
name|x2
operator|-
name|BC3
operator|*
operator|(
name|x3
operator|+
name|x1
operator|)
operator|+
name|BC1
operator|*
name|x4
expr_stmt|;
name|V2y
operator|=
name|BC4
operator|*
name|y2
operator|-
name|BC3
operator|*
operator|(
name|y3
operator|+
name|y1
operator|)
operator|+
name|BC1
operator|*
name|y4
expr_stmt|;
name|V3x
operator|=
operator|-
name|BC4
operator|*
name|x2
operator|+
literal|4
operator|*
name|x3
operator|+
name|x1
operator|-
name|BC2
operator|*
name|x4
expr_stmt|;
name|V3y
operator|=
operator|-
name|BC4
operator|*
name|y2
operator|+
literal|4
operator|*
name|y3
operator|+
name|y1
operator|-
name|BC2
operator|*
name|y4
expr_stmt|;
name|printf
argument_list|(
literal|" %lg %lg %lg %lg %lg %lg curveto\n"
argument_list|,
name|V2x
argument_list|,
name|V2y
argument_list|,
name|V3x
argument_list|,
name|V3y
argument_list|,
name|x4
argument_list|,
name|y4
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end BezierSegment */
end_comment

begin_comment
comment|/*  * This routine calculates parameteric values for use in calculating  * curves.  The values are an approximation of cumulative arc lengths  * of the curve (uses cord * length).  For additional information,  * see paper cited below.  *  * This is from Gremlin (called Paramaterize in gremlin),  * with minor modifications (elimination of param list)  *  */
end_comment

begin_macro
name|IS_Parameterize
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|double
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|double
name|u
index|[
name|MAXPOINTS
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|numpoints
condition|;
name|i
operator|++
control|)
block|{
name|u
index|[
name|i
index|]
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|t1
operator|=
name|x
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|x
index|[
name|j
index|]
expr_stmt|;
name|t2
operator|=
name|y
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|y
index|[
name|j
index|]
expr_stmt|;
name|u
index|[
name|i
index|]
operator|+=
operator|(
name|double
operator|)
name|sqrt
argument_list|(
name|t1
operator|*
name|t1
operator|+
name|t2
operator|*
name|t2
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|numpoints
condition|;
name|i
operator|++
control|)
name|h
index|[
name|i
index|]
operator|=
name|u
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|u
index|[
name|i
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end IS_Parameterize */
end_comment

begin_comment
comment|/*  * This routine solves for the cubic polynomial to fit a spline  * curve to the the points  specified by the list of values.  * The curve generated is periodic.  The alogrithms for this  * curve are from the "Spline Curve Techniques" paper cited below.  *  * This is from Gremlin (called PeriodicSpline in gremlin)  *  */
end_comment

begin_macro
name|IS_PeriodicEnd
argument_list|(
argument|h
argument_list|,
argument|z
argument_list|,
argument|dz
argument_list|,
argument|d2z
argument_list|,
argument|d3z
argument_list|)
end_macro

begin_decl_stmt
name|double
name|h
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parameterizeaterization */
end_comment

begin_decl_stmt
name|double
name|z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* point list */
end_comment

begin_decl_stmt
name|double
name|dz
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to return the 1st derivative */
end_comment

begin_decl_stmt
name|double
name|d2z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2nd derivative */
end_comment

begin_decl_stmt
name|double
name|d3z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* and 3rd derivative */
end_comment

begin_block
block|{
name|double
name|a
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|double
name|b
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|double
name|c
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|double
name|d
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|double
name|deltaz
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|double
name|r
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|double
name|s
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|double
name|ftmp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
comment|/* step 1 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|numpoints
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|h
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|deltaz
index|[
name|i
index|]
operator|=
operator|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
expr_stmt|;
else|else
name|deltaz
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|h
index|[
literal|0
index|]
operator|=
name|h
index|[
name|numpoints
operator|-
literal|1
index|]
expr_stmt|;
name|deltaz
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
name|numpoints
operator|-
literal|1
index|]
expr_stmt|;
comment|/* step 2 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|numpoints
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|d
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|deltaz
index|[
name|i
index|]
expr_stmt|;
name|d
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
literal|1
index|]
operator|-
name|deltaz
index|[
literal|0
index|]
expr_stmt|;
comment|/* step 3a */
name|a
index|[
literal|1
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
literal|0
index|]
operator|+
name|h
index|[
literal|1
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|1
index|]
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 3 consecutive knots at same point */
name|b
index|[
literal|1
index|]
operator|=
name|d
index|[
literal|0
index|]
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
name|h
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|numpoints
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|ftmp
operator|=
name|h
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|a
index|[
name|i
index|]
operator|=
name|ftmp
operator|+
name|ftmp
operator|+
name|h
index|[
name|i
index|]
operator|+
name|h
index|[
name|i
index|]
operator|-
name|ftmp
operator|*
name|ftmp
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|a
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 3 consec knots at same point */
name|b
index|[
name|i
index|]
operator|=
name|d
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|ftmp
operator|*
name|b
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|c
index|[
name|i
index|]
operator|=
operator|-
name|ftmp
operator|*
name|c
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* step 3b */
name|r
index|[
name|numpoints
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|s
index|[
name|numpoints
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|numpoints
operator|-
literal|2
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|r
index|[
name|i
index|]
operator|=
operator|-
operator|(
name|h
index|[
name|i
index|]
operator|*
name|r
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|c
index|[
name|i
index|]
operator|)
operator|/
name|a
index|[
name|i
index|]
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
operator|(
literal|6
operator|*
name|b
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
name|s
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
name|a
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* step 4 */
name|d2z
index|[
name|numpoints
operator|-
literal|1
index|]
operator|=
operator|(
literal|6
operator|*
name|d
index|[
name|numpoints
operator|-
literal|2
index|]
operator|-
name|h
index|[
literal|0
index|]
operator|*
name|s
index|[
literal|1
index|]
operator|-
name|h
index|[
name|numpoints
operator|-
literal|1
index|]
operator|*
name|s
index|[
name|numpoints
operator|-
literal|2
index|]
operator|)
operator|/
operator|(
name|h
index|[
literal|0
index|]
operator|*
name|r
index|[
literal|1
index|]
operator|+
name|h
index|[
name|numpoints
operator|-
literal|1
index|]
operator|*
name|r
index|[
name|numpoints
operator|-
literal|2
index|]
operator|+
literal|2
operator|*
operator|(
name|h
index|[
name|numpoints
operator|-
literal|2
index|]
operator|+
name|h
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|numpoints
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|d2z
index|[
name|i
index|]
operator|=
name|r
index|[
name|i
index|]
operator|*
name|d2z
index|[
name|numpoints
operator|-
literal|1
index|]
operator|+
name|s
index|[
name|i
index|]
expr_stmt|;
name|d2z
index|[
name|numpoints
index|]
operator|=
name|d2z
index|[
literal|1
index|]
expr_stmt|;
comment|/* step 5 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|numpoints
condition|;
name|i
operator|++
control|)
block|{
name|dz
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
operator|(
literal|2
operator|*
name|d2z
index|[
name|i
index|]
operator|+
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
literal|6
expr_stmt|;
if|if
condition|(
name|h
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|d3z
index|[
name|i
index|]
operator|=
operator|(
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|d2z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
expr_stmt|;
else|else
name|d3z
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* end IS_PeriodicEnd */
end_comment

begin_comment
comment|/*  * This routine solves for the cubic polynomial to fit a spline  * curve from the points specified by the list of values.  The alogrithms for  * this curve are from the "Spline Curve Techniques" paper cited below.  *  * This is from Gremlin (called NaturalEndSpline in gremlin)  */
end_comment

begin_macro
name|IS_NaturalEnd
argument_list|(
argument|h
argument_list|,
argument|z
argument_list|,
argument|dz
argument_list|,
argument|d2z
argument_list|,
argument|d3z
argument_list|)
end_macro

begin_decl_stmt
name|double
name|h
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* parameterization */
end_comment

begin_decl_stmt
name|double
name|z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* point list */
end_comment

begin_decl_stmt
name|double
name|dz
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to return the 1st derivative */
end_comment

begin_decl_stmt
name|double
name|d2z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2nd derivative */
end_comment

begin_decl_stmt
name|double
name|d3z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* and 3rd derivative */
end_comment

begin_block
block|{
name|double
name|a
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|double
name|b
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|double
name|d
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|double
name|deltaz
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|double
name|ftmp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
comment|/* step 1 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|numpoints
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|h
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|deltaz
index|[
name|i
index|]
operator|=
operator|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
expr_stmt|;
else|else
name|deltaz
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|deltaz
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
name|numpoints
operator|-
literal|1
index|]
expr_stmt|;
comment|/* step 2 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|numpoints
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|d
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|deltaz
index|[
name|i
index|]
expr_stmt|;
name|d
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
literal|1
index|]
operator|-
name|deltaz
index|[
literal|0
index|]
expr_stmt|;
comment|/* step 3 */
name|a
index|[
literal|0
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
literal|2
index|]
operator|+
name|h
index|[
literal|1
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|==
literal|0
condition|)
comment|/* 3 consec knots at same point */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|b
index|[
literal|0
index|]
operator|=
name|d
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|numpoints
operator|-
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|ftmp
operator|=
name|h
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|a
index|[
name|i
index|]
operator|=
name|ftmp
operator|+
name|ftmp
operator|+
name|h
index|[
name|i
operator|+
literal|2
index|]
operator|+
name|h
index|[
name|i
operator|+
literal|2
index|]
operator|-
operator|(
name|ftmp
operator|*
name|ftmp
operator|)
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|a
index|[
name|i
index|]
operator|==
literal|0
condition|)
comment|/* 3 consec knots at same point */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|b
index|[
name|i
index|]
operator|=
name|d
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|ftmp
operator|*
name|b
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* step 4 */
name|d2z
index|[
name|numpoints
index|]
operator|=
name|d2z
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|numpoints
operator|-
literal|1
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|--
control|)
name|d2z
index|[
name|i
index|]
operator|=
operator|(
literal|6
operator|*
name|b
index|[
name|i
operator|-
literal|2
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
name|a
index|[
name|i
operator|-
literal|2
index|]
expr_stmt|;
comment|/* step 5 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|numpoints
condition|;
name|i
operator|++
control|)
block|{
name|dz
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
operator|(
literal|2
operator|*
name|d2z
index|[
name|i
index|]
operator|+
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
literal|6
expr_stmt|;
if|if
condition|(
name|h
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|d3z
index|[
name|i
index|]
operator|=
operator|(
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|d2z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
expr_stmt|;
else|else
name|d3z
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* end IS_NaturalEnd */
end_comment

begin_comment
comment|/*  * Use the same algorithm Gremlin uses to interpolate a given  * set of points, as described in ``Spline Curve Techniques,''  * by Pattrick Baudelaire, Robert M. Flegal, and Robert F. Sproull,  * Xerox PARC Tech Report No. 78CSL-059.  */
end_comment

begin_macro
name|IS_Initialize
argument_list|(
argument|count
argument_list|,
argument|list
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|point
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|MakePoints
argument_list|(
name|count
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|IS_Parameterize
argument_list|()
expr_stmt|;
comment|/* Solve for derivatives of the curve at each point 	   separately for x and y (parametric). */
if|if
condition|(
name|x
index|[
literal|1
index|]
operator|==
name|x
index|[
name|numpoints
index|]
operator|&&
name|y
index|[
literal|1
index|]
operator|==
name|y
index|[
name|numpoints
index|]
condition|)
block|{
comment|/* closed curve */
name|IS_PeriodicEnd
argument_list|(
name|h
argument_list|,
name|x
argument_list|,
name|dx
argument_list|,
name|d2x
argument_list|,
name|d3x
argument_list|)
expr_stmt|;
name|IS_PeriodicEnd
argument_list|(
name|h
argument_list|,
name|y
argument_list|,
name|dy
argument_list|,
name|d2y
argument_list|,
name|d3y
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IS_NaturalEnd
argument_list|(
name|h
argument_list|,
name|x
argument_list|,
name|dx
argument_list|,
name|d2x
argument_list|,
name|d3x
argument_list|)
expr_stmt|;
name|IS_NaturalEnd
argument_list|(
name|h
argument_list|,
name|y
argument_list|,
name|dy
argument_list|,
name|d2y
argument_list|,
name|d3y
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * This routine converts cubic interpolatory spline to Bezier control vertices  */
end_comment

begin_macro
name|IS_Convert
argument_list|()
end_macro

begin_block
block|{
name|double
name|t
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|x3
decl_stmt|,
name|y3
decl_stmt|;
specifier|register
name|j
operator|,
name|j1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|numpoints
condition|;
name|j
operator|++
control|)
block|{
name|t
operator|=
literal|.25
operator|*
name|h
index|[
name|j
index|]
expr_stmt|;
name|t2
operator|=
name|t
operator|*
name|t
expr_stmt|;
name|t3
operator|=
name|t2
operator|*
name|t
expr_stmt|;
name|x2
operator|=
name|x
index|[
name|j
index|]
operator|+
name|t
operator|*
name|dx
index|[
name|j
index|]
operator|+
name|t2
operator|*
name|d2x
index|[
name|j
index|]
operator|/
literal|2.0
operator|+
name|t3
operator|*
name|d3x
index|[
name|j
index|]
operator|/
literal|6.0
expr_stmt|;
name|y2
operator|=
name|y
index|[
name|j
index|]
operator|+
name|t
operator|*
name|dy
index|[
name|j
index|]
operator|+
name|t2
operator|*
name|d2y
index|[
name|j
index|]
operator|/
literal|2.0
operator|+
name|t3
operator|*
name|d3y
index|[
name|j
index|]
operator|/
literal|6.0
expr_stmt|;
name|t
operator|=
literal|2
operator|*
name|t
expr_stmt|;
name|t2
operator|=
name|t
operator|*
name|t
expr_stmt|;
name|t3
operator|=
name|t2
operator|*
name|t
expr_stmt|;
name|x3
operator|=
name|x
index|[
name|j
index|]
operator|+
name|t
operator|*
name|dx
index|[
name|j
index|]
operator|+
name|t2
operator|*
name|d2x
index|[
name|j
index|]
operator|/
literal|2.0
operator|+
name|t3
operator|*
name|d3x
index|[
name|j
index|]
operator|/
literal|6.0
expr_stmt|;
name|y3
operator|=
name|y
index|[
name|j
index|]
operator|+
name|t
operator|*
name|dy
index|[
name|j
index|]
operator|+
name|t2
operator|*
name|d2y
index|[
name|j
index|]
operator|/
literal|2.0
operator|+
name|t3
operator|*
name|d3y
index|[
name|j
index|]
operator|/
literal|6.0
expr_stmt|;
name|j1
operator|=
name|j
operator|+
literal|1
expr_stmt|;
name|BezierSegment
argument_list|(
name|x
index|[
name|j
index|]
argument_list|,
name|y
index|[
name|j
index|]
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|,
name|x
index|[
name|j1
index|]
argument_list|,
name|y
index|[
name|j1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end IS_Convert */
end_comment

begin_comment
comment|/*  * This routine converts cubic interpolatory splines to Bezier cubics.  */
end_comment

begin_macro
name|makecurve
argument_list|(
argument|count
argument_list|,
argument|list
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|point
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|IS_Initialize
argument_list|(
name|count
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|IS_Convert
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Dstroke\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This routine computes a point in B-spline segment, given i, and u.  * Details of this algorithm can be found in the tech. report cited below.  */
end_comment

begin_macro
name|BS_ComputePoint
argument_list|(
argument|i
argument_list|,
argument|u
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|u
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|float
name|u2
decl_stmt|,
name|u3
decl_stmt|,
name|b_2
decl_stmt|,
name|b_1
decl_stmt|,
name|b0
decl_stmt|,
name|b1
decl_stmt|;
specifier|register
name|i1
operator|,
name|i_2
operator|,
name|i_1
expr_stmt|;
name|i1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|i_1
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|i_2
operator|=
name|i
operator|-
literal|2
expr_stmt|;
name|u2
operator|=
name|u
operator|*
name|u
expr_stmt|;
name|u3
operator|=
name|u2
operator|*
name|u
expr_stmt|;
name|b_2
operator|=
operator|(
literal|1
operator|-
literal|3
operator|*
name|u
operator|+
literal|3
operator|*
name|u2
operator|-
name|u3
operator|)
operator|/
literal|6.0
expr_stmt|;
name|b_1
operator|=
operator|(
literal|4
operator|-
literal|6
operator|*
name|u2
operator|+
literal|3
operator|*
name|u3
operator|)
operator|/
literal|6.0
expr_stmt|;
name|b0
operator|=
operator|(
literal|1
operator|+
literal|3
operator|*
name|u
operator|+
literal|3
operator|*
name|u2
operator|-
literal|3
operator|*
name|u3
operator|)
operator|/
literal|6.0
expr_stmt|;
name|b1
operator|=
name|u3
operator|/
literal|6.0
expr_stmt|;
name|Qx
operator|=
name|b_2
operator|*
name|x
index|[
name|i_2
index|]
operator|+
name|b_1
operator|*
name|x
index|[
name|i_1
index|]
operator|+
name|b0
operator|*
name|x
index|[
name|i
index|]
operator|+
name|b1
operator|*
name|x
index|[
name|i1
index|]
expr_stmt|;
name|Qy
operator|=
name|b_2
operator|*
name|y
index|[
name|i_2
index|]
operator|+
name|b_1
operator|*
name|y
index|[
name|i_1
index|]
operator|+
name|b0
operator|*
name|y
index|[
name|i
index|]
operator|+
name|b1
operator|*
name|y
index|[
name|i1
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end BS_ComputePoint */
end_comment

begin_comment
comment|/*  * This routine initializes the array of control vertices  * We consider two end conditions here:  *   (1) closed curve -- C2 continuation and end vertex not interpolated, i.e.  *		V[0] = V[n-1], and  *		V[n+1] = V[2].  *   (2) open curve -- end vertex interpolation, i.e.  *		V[0] = 2*V[1] - V[2], and  *		V[n+1] = 2*V[n] - V[n-1].  * Details of uniform cubic B-splines, including other end conditions  * and important properties can be found in Chapters 4-5 of  * Richard H. Bartels and Brian A. Barsky,  * "An Introduction to the Use of Splines in Computer Graphics",  * Tech. Report CS-83-136, Computer Science Division,  * University of California, Berkeley, 1984.  */
end_comment

begin_macro
name|BS_Initialize
argument_list|(
argument|count
argument_list|,
argument|list
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|point
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|n_1
operator|,
name|n1
expr_stmt|;
name|MakePoints
argument_list|(
name|count
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|n_1
operator|=
name|numpoints
operator|-
literal|1
expr_stmt|;
name|n1
operator|=
name|numpoints
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|x
index|[
literal|1
index|]
operator|==
name|x
index|[
name|numpoints
index|]
operator|&&
name|y
index|[
literal|1
index|]
operator|==
name|y
index|[
name|numpoints
index|]
condition|)
block|{
comment|/* closed curve */
name|x
index|[
literal|0
index|]
operator|=
name|x
index|[
name|n_1
index|]
expr_stmt|;
comment|/* V[0] */
name|y
index|[
literal|0
index|]
operator|=
name|y
index|[
name|n_1
index|]
expr_stmt|;
name|x
index|[
name|n1
index|]
operator|=
name|x
index|[
literal|2
index|]
expr_stmt|;
comment|/* V[n+1] */
name|y
index|[
name|n1
index|]
operator|=
name|y
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* end vertex interpolation */
name|x
index|[
literal|0
index|]
operator|=
literal|2
operator|*
name|x
index|[
literal|1
index|]
operator|-
name|x
index|[
literal|2
index|]
expr_stmt|;
comment|/* V[0] */
name|y
index|[
literal|0
index|]
operator|=
literal|2
operator|*
name|y
index|[
literal|1
index|]
operator|-
name|y
index|[
literal|2
index|]
expr_stmt|;
name|x
index|[
name|n1
index|]
operator|=
literal|2
operator|*
name|x
index|[
name|numpoints
index|]
operator|-
name|x
index|[
name|n_1
index|]
expr_stmt|;
comment|/* V[n+1] */
name|y
index|[
name|n1
index|]
operator|=
literal|2
operator|*
name|y
index|[
name|numpoints
index|]
operator|-
name|y
index|[
name|n_1
index|]
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end BS_Initialize */
end_comment

begin_comment
comment|/*  * This routine converts uniform cubic B-spline to Bezier control vertices  */
end_comment

begin_macro
name|BS_Convert
argument_list|()
end_macro

begin_block
block|{
name|double
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|x3
decl_stmt|,
name|y3
decl_stmt|;
specifier|register
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<=
name|numpoints
condition|;
name|i
operator|++
control|)
block|{
name|BS_ComputePoint
argument_list|(
name|i
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|x1
operator|=
name|Qx
expr_stmt|;
name|y1
operator|=
name|Qy
expr_stmt|;
name|BS_ComputePoint
argument_list|(
name|i
argument_list|,
literal|0.25
argument_list|)
expr_stmt|;
name|x2
operator|=
name|Qx
expr_stmt|;
name|y2
operator|=
name|Qy
expr_stmt|;
name|BS_ComputePoint
argument_list|(
name|i
argument_list|,
literal|0.5
argument_list|)
expr_stmt|;
name|x3
operator|=
name|Qx
expr_stmt|;
name|y3
operator|=
name|Qy
expr_stmt|;
name|BS_ComputePoint
argument_list|(
name|i
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|BezierSegment
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|,
name|Qx
argument_list|,
name|Qy
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end BS_Convert */
end_comment

begin_comment
comment|/*  * This routine converts B-spline to Bezier Cubics  */
end_comment

begin_macro
name|makebspline
argument_list|(
argument|count
argument_list|,
argument|list
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|point
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BS_Initialize
argument_list|(
name|count
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|BS_ComputePoint
argument_list|(
literal|2
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|BS_Convert
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Dstroke\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This routine copies the offset between two consecutive control points  * into an array.  That is,  * 	O[i] = (x[i], y[i]) = V[i+1] - V[i],  * for i=1 to N-1, where N is the number of points given.  * The starting end point (V[1]) is saved in (Qx, Qy).  */
end_comment

begin_macro
name|BZ_Offsets
argument_list|(
argument|count
argument_list|,
argument|list
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|point
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|double
name|Lx
decl_stmt|,
name|Ly
decl_stmt|;
comment|/* Assign offsets btwn points to array for convenience of processing */
name|Qx
operator|=
name|Lx
operator|=
name|list
index|[
literal|0
index|]
operator|.
name|p_x
expr_stmt|;
name|Qy
operator|=
name|Ly
operator|=
name|list
index|[
literal|0
index|]
operator|.
name|p_y
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|x
index|[
name|i
index|]
operator|=
name|list
index|[
name|i
index|]
operator|.
name|p_x
operator|-
name|Lx
expr_stmt|;
name|y
index|[
name|i
index|]
operator|=
name|list
index|[
name|i
index|]
operator|.
name|p_y
operator|-
name|Ly
expr_stmt|;
name|Lx
operator|=
name|list
index|[
name|i
index|]
operator|.
name|p_x
expr_stmt|;
name|Ly
operator|=
name|list
index|[
name|i
index|]
operator|.
name|p_y
expr_stmt|;
block|}
name|numpoints
operator|=
name|count
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This routine contructs paths of piecewise continuous Bezier cubics  * in PostScript based on the given set of control vertices.  * Given 2 points, a stringht line is drawn.  * Given 3 points V[1], V[2], and V[3], a Bezier cubic segment  * of (V[1], (V[1]+V[2])/2, (V[2]+V[3])/2, V[3]) is drawn.  * In the case when N (N>= 4) points are given, N-2 Bezier segments will  * be drawn, each of which (for i=1 to N-2) is translated to PostScript as  *	Q+O[i]/3  Q+(3*O[i]+O[i+1])/6  K+O[i+1]/2  curveto,  * where  *	Q is the current point,  *	K is the continuation offset = Qinitial + Sigma(1, i)(O[i])  * Note that when i is 1, the initial point  *	Q = V[1].  * and when i is N-2, the terminating point  *	K+O[i+1]/2 = V[N].  */
end_comment

begin_macro
name|BZ_Convert
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|i1
expr_stmt|;
name|double
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|x3
decl_stmt|,
name|y3
decl_stmt|,
name|Kx
decl_stmt|,
name|Ky
decl_stmt|;
if|if
condition|(
name|numpoints
operator|==
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|" %lg %lg rlineto\n"
argument_list|,
name|x
index|[
literal|1
index|]
argument_list|,
name|y
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|numpoints
operator|==
literal|3
condition|)
block|{
name|x1
operator|=
name|Qx
operator|+
name|x
index|[
literal|1
index|]
expr_stmt|;
name|y1
operator|=
name|Qy
operator|+
name|y
index|[
literal|1
index|]
expr_stmt|;
name|x2
operator|=
name|x1
operator|+
name|x
index|[
literal|2
index|]
expr_stmt|;
name|y2
operator|=
name|y1
operator|+
name|y
index|[
literal|2
index|]
expr_stmt|;
name|printf
argument_list|(
literal|" %lg %lg %lg %lg %lg %lg curveto\n"
argument_list|,
operator|(
name|Qx
operator|+
name|x1
operator|)
operator|/
literal|2.0
argument_list|,
operator|(
name|Qy
operator|+
name|y1
operator|)
operator|/
literal|2.0
argument_list|,
operator|(
name|x1
operator|+
name|x2
operator|)
operator|/
literal|2.0
argument_list|,
operator|(
name|y1
operator|+
name|y2
operator|)
operator|/
literal|2.0
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* numpoints>= 4 */
name|Kx
operator|=
name|Qx
operator|+
name|x
index|[
literal|1
index|]
expr_stmt|;
name|Ky
operator|=
name|Qy
operator|+
name|y
index|[
literal|1
index|]
expr_stmt|;
name|x
index|[
literal|1
index|]
operator|=
literal|2
operator|*
name|x
index|[
literal|1
index|]
expr_stmt|;
name|y
index|[
literal|1
index|]
operator|=
literal|2
operator|*
name|y
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|=
name|numpoints
operator|-
literal|1
expr_stmt|;
name|x
index|[
name|i
index|]
operator|=
literal|2
operator|*
name|x
index|[
name|i
index|]
expr_stmt|;
name|y
index|[
name|i
index|]
operator|=
literal|2
operator|*
name|y
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|i1
operator|=
literal|2
init|;
name|i
operator|<=
name|numpoints
operator|-
literal|2
condition|;
name|i
operator|++
operator|,
name|i1
operator|++
control|)
block|{
name|x1
operator|=
name|Qx
operator|+
name|x
index|[
name|i
index|]
operator|/
literal|3
expr_stmt|;
name|y1
operator|=
name|Qy
operator|+
name|y
index|[
name|i
index|]
operator|/
literal|3
expr_stmt|;
name|x2
operator|=
name|Qx
operator|+
operator|(
literal|3
operator|*
name|x
index|[
name|i
index|]
operator|+
name|x
index|[
name|i1
index|]
operator|)
operator|/
literal|6
expr_stmt|;
name|y2
operator|=
name|Qy
operator|+
operator|(
literal|3
operator|*
name|y
index|[
name|i
index|]
operator|+
name|y
index|[
name|i1
index|]
operator|)
operator|/
literal|6
expr_stmt|;
name|x3
operator|=
name|Kx
operator|+
name|x
index|[
name|i1
index|]
operator|/
literal|2
expr_stmt|;
name|y3
operator|=
name|Ky
operator|+
name|y
index|[
name|i1
index|]
operator|/
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|" %lg %lg %lg %lg %lg %lg curveto\n"
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|x3
argument_list|,
name|y3
argument_list|)
expr_stmt|;
name|Qx
operator|=
name|x3
expr_stmt|;
name|Qy
operator|=
name|y3
expr_stmt|;
name|Kx
operator|=
name|Kx
operator|+
name|x
index|[
name|i1
index|]
expr_stmt|;
name|Ky
operator|=
name|Ky
operator|+
name|y
index|[
name|i1
index|]
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end BZ_Convert */
end_comment

begin_comment
comment|/*  * This routine draws piecewise continuous Bezier cubics based on  * the given list of control vertices.  */
end_comment

begin_macro
name|makebezier
argument_list|(
argument|count
argument_list|,
argument|list
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|point
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BZ_Offsets
argument_list|(
name|count
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|BZ_Convert
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Dstroke\n"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

