begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|Notice
index|[]
init|=
literal|"Copyright (c) 1984, 1985 Adobe Systems Incorporated"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSID
init|=
literal|"$Header: psdit.c,v 2.1 85/11/24 11:50:41 shore Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|XMOD
end_define

begin_comment
comment|/* psdit.c  *  * Copyright (c) 1984, 1985 Adobe Systems Incorporated  *  * ditroff intermediate file to PostScript translator  *  * Original Version: Barry Hayes spring/summer 1984  * Edit History:  * Andrew Shore: Sat Nov 23 20:05:26 1985  * End Edit History.  *  * RCSLOG:  * $Log:	psdit.c,v $  * Revision 2.1  85/11/24  11:50:41  shore  * Product Release 2.0  *   * Revision 1.8  85/11/23  20:09:44  shore  * test for termination of included PostScript was bad  *   * Revision 1.7  85/11/21  14:23:56  shore  * added envget check for PSLIBDIR  *   * Revision 1.6  85/11/20  00:43:43  shore  * support for included PostScript  * big rework on FlushShow, word "breaks"  * removed FlushFont and made them instant  * Still no Gremlin support yet  *   * Revision 1.5  85/10/03  10:48:09  shore  * added FlushShow to xf fix !  *   * Revision 1.4  85/10/02  16:20:32  shore  * fixed xf bug   * mounting a font causes a font switch!  *   * Revision 1.3  85/07/09  13:10:20  shore  * added fclose on map file  *   * Revision 1.2  85/05/14  11:24:23  shore  * added flush to trailer  * fixed read bug when mounting fonts  *   *   */
end_comment

begin_comment
comment|/*  output language from troff: all numbers are character strings  sn	size in points fn	font as number from 1-n cx	ascii character x Cxyz	funny char xyz. terminated by white space Hn	go to absolute horizontal position n Vn	go to absolute vertical position n (down is positive) hn	go n units horizontally (relative) vn	ditto vertically nnc	move right nn, then print c (exactly 2 digits!) 		(this wart is an optimization that shrinks output file size 		 about 35% and run-time about 15% while preserving ascii-ness) Dt ...\n	draw operation 't': 	Dl x y		line from here by x,y 	Dc d		circle of diameter d with left side here 	De x y		ellipse of axes x,y with left side here 	Da x y r	arc counter-clockwise by x,y of radius r 	D~ x y x y ...	wiggly line by x,y then x,y ... nb a	end of line (information only -- no action needed) 	a = space before line, a = after w	paddable word space -- no action needed pn	new page begins -- set v to 0 {	push current environment (font info& location) }	pop a saved environment txxxx	print string xxxx using natural widths #...\n	comment x ...\n	device control functions: 	x i[nit]	init 	x T s		name of device is s 	x r[es] n h v	resolution is n/inch 			h = min horizontal motion, v = min vert 	x p[ause]	pause (can restart) 	x s[top]	stop -- done for ever 	x t[railer]	generate trailer 	x f[font] n s	font position n contains font s 	x H[eight] n	set character height to n 	x S[slant] n	set slant to N  Adobe Extension for included PostScript: % (raw postscript...) .\n  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_function_decl
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"transcript.h"
end_include

begin_include
include|#
directive|include
file|"dev.h"
end_include

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NFONT
value|10
end_define

begin_comment
comment|/* DIT state consists of: */
end_comment

begin_decl_stmt
name|private
name|int
name|hpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current horizontal position */
end_comment

begin_decl_stmt
name|private
name|int
name|vpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current vertical position */
end_comment

begin_decl_stmt
name|private
name|int
name|fontsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current font size */
end_comment

begin_decl_stmt
name|private
name|int
name|fontheight
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current character height */
end_comment

begin_decl_stmt
name|private
name|int
name|fontslant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current font slant */
end_comment

begin_decl_stmt
name|private
name|int
name|font
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current font */
end_comment

begin_decl_stmt
name|private
name|int
name|resolution
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device resolution */
end_comment

begin_decl_stmt
name|private
name|int
name|minhoriz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* minimum horizontal motion */
end_comment

begin_decl_stmt
name|private
name|int
name|minvert
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* minimum vertical motion */
end_comment

begin_decl_stmt
name|private
name|int
name|onspecial
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|specfont
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|prevfont
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|pfont
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* {} push/pop stack */
end_comment

begin_define
define|#
directive|define
name|DSTACK
value|10
end_define

begin_macro
name|private
end_macro

begin_struct
struct|struct
name|ditstack
block|{
name|int
name|hpos
decl_stmt|,
name|vpos
decl_stmt|,
name|fontsize
decl_stmt|,
name|fontheight
decl_stmt|,
name|fontslant
decl_stmt|,
name|font
decl_stmt|;
block|}
name|ditstack
index|[
name|DSTACK
index|]
struct|;
end_struct

begin_decl_stmt
name|private
name|int
name|dlevel
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ErrorTolerance
value|48
end_define

begin_define
define|#
directive|define
name|PSWID
value|0x00000FFF
end_define

begin_define
define|#
directive|define
name|ISPSPROC
value|0x000FF000
end_define

begin_comment
comment|/* PSscale is equivalent to (x * PSmag / 72000) + 0.5 */
end_comment

begin_define
define|#
directive|define
name|PSmag
value|16
end_define

begin_define
define|#
directive|define
name|PSscale
parameter_list|(
name|x
parameter_list|)
value|(((x)+2250)/4500)
end_define

begin_comment
comment|/* we maintain PS coords with PSmag times the precision */
end_comment

begin_comment
comment|/* current PS state is: */
end_comment

begin_decl_stmt
name|private
name|int
name|PSx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current horizontal position */
end_comment

begin_decl_stmt
name|private
name|int
name|PSy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current vertical position */
end_comment

begin_decl_stmt
name|private
name|int
name|savex
decl_stmt|,
name|savey
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* position of start of current show string */
end_comment

begin_comment
comment|/* ps move types -- note that XMOVE|YMOVE == XYMOVE ! */
end_comment

begin_define
define|#
directive|define
name|NONE
value|0
end_define

begin_define
define|#
directive|define
name|XMOVE
value|1
end_define

begin_define
define|#
directive|define
name|YMOVE
value|2
end_define

begin_define
define|#
directive|define
name|XYMOVE
value|3
end_define

begin_decl_stmt
name|private
name|int
name|movepending
init|=
name|NONE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer string for show -- save up adjacent chars */
end_comment

begin_define
define|#
directive|define
name|SHOWSIZE
value|400
end_define

begin_decl_stmt
name|private
name|char
name|showbuf
index|[
name|SHOWSIZE
operator|+
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* extras are for quoting */
end_comment

begin_decl_stmt
name|private
name|int
name|showind
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index into string of next available byte */
end_comment

begin_decl_stmt
name|private
name|int
name|PSshowlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size in big units of buffered string */
end_comment

begin_decl_stmt
name|private
name|int
name|nshow
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* actual number of show chars in showbuf */
end_comment

begin_decl_stmt
name|private
name|int
name|startx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* troff starting pos of current string */
end_comment

begin_decl_stmt
name|private
name|int
name|thisw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #define NONE 0 */
end_comment

begin_define
define|#
directive|define
name|HMOT
value|1
end_define

begin_define
define|#
directive|define
name|VMOT
value|2
end_define

begin_define
define|#
directive|define
name|CPUT
value|4
end_define

begin_define
define|#
directive|define
name|BRK
value|8
end_define

begin_define
define|#
directive|define
name|FNT
value|16
end_define

begin_decl_stmt
name|private
name|int
name|lastcmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|output
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* do we do output at all? */
end_comment

begin_decl_stmt
name|private
name|int
name|nolist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output page list if> 0 */
end_comment

begin_decl_stmt
name|private
name|int
name|olist
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pairs of page numbers */
end_comment

begin_decl_stmt
name|private
name|int
name|spage
init|=
literal|9999
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stop every spage pages */
end_comment

begin_decl_stmt
name|private
name|int
name|scount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|stopped
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|pageno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|firstpage
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|struct
name|dev
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|struct
name|font
modifier|*
name|fontbase
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|short
modifier|*
name|pstab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|dres
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* resolution from DESC */
end_comment

begin_decl_stmt
name|private
name|int
name|nsizes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of point sizes from DESC */
end_comment

begin_decl_stmt
name|private
name|int
name|nfonts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of fonts from DESC */
end_comment

begin_decl_stmt
name|private
name|int
name|smnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of first special font */
end_comment

begin_decl_stmt
name|private
name|int
name|nchtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|chname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|short
modifier|*
name|chtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|fitab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|widthtab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* widtab would be a better name */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|codetab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device codes */
end_comment

begin_decl_stmt
name|private
name|int
modifier|*
name|pswidths
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ps width tables */
end_comment

begin_decl_stmt
name|private
name|int
name|fontdelta
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nonzero if xf overwrites font i */
end_comment

begin_comment
comment|/* font position info: */
end_comment

begin_macro
name|private
end_macro

begin_struct
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
name|fontname
index|[
name|NFONT
operator|+
literal|1
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|FATAL
value|1
end_define

begin_define
define|#
directive|define
name|BMASK
value|0377
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|dbg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fdbg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|debugp
parameter_list|(
name|xxx
parameter_list|)
value|{if(dbg != 0){dbg--; printf xxx ; VOIDC fflush(stdout);}}
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debugp
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|private
name|FILE
modifier|*
name|tf
init|=
name|stdout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output file */
end_comment

begin_decl_stmt
name|private
name|char
name|devname
index|[
literal|20
index|]
init|=
literal|"psc"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|infilename
init|=
literal|"stdin"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file name */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|prologfile
init|=
name|PSDITPRO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|ditdir
init|=
name|DitDir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* argv[0] - program name */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|VOID
name|done
parameter_list|()
function_decl|;
name|prog
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
condition|)
name|ditdir
operator|=
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
else|else
block|{
name|ditdir
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
condition|)
name|prologfile
operator|=
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|outlist
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|dbg
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
operator|==
literal|0
condition|)
name|dbg
operator|=
literal|1
expr_stmt|;
name|tf
operator|=
name|stdout
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
break|break;
case|case
literal|'b'
case|:
comment|/* ignore busy */
break|break;
case|case
literal|'w'
case|:
comment|/* ignore wait */
break|break;
case|case
literal|'s'
case|:
name|spage
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|spage
operator|<=
literal|0
condition|)
name|spage
operator|=
literal|9999
expr_stmt|;
break|break;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|done
argument_list|)
operator|==
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|done
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|done
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|done
argument_list|)
expr_stmt|;
name|preface
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|conv
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
operator|++
name|argv
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|fp
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open %s\n"
argument_list|,
name|prog
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|prog
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|infilename
operator|=
operator|*
name|argv
expr_stmt|;
name|conv
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|VOIDC
name|fclose
argument_list|(
name|fp
argument_list|)
decl_stmt|;
block|}
name|done
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|private
name|outlist
parameter_list|(
name|s
parameter_list|)
comment|/* process list of page numbers to be printed */
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|,
name|i
decl_stmt|;
name|nolist
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|n1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
do|do
block|{
name|n1
operator|=
literal|10
operator|*
name|n1
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
block|}
else|else
block|{
name|n1
operator|=
operator|-
literal|9999
expr_stmt|;
block|}
name|n2
operator|=
name|n1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|n2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
do|do
block|{
name|n2
operator|=
literal|10
operator|*
name|n2
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
block|}
else|else
block|{
name|n2
operator|=
literal|9999
expr_stmt|;
block|}
block|}
name|olist
index|[
name|nolist
operator|++
index|]
operator|=
name|n1
expr_stmt|;
name|olist
index|[
name|nolist
operator|++
index|]
operator|=
name|n2
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|s
operator|++
expr_stmt|;
block|}
block|}
name|olist
index|[
name|nolist
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|dbg
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nolist
condition|;
name|i
operator|+=
literal|2
control|)
name|printf
argument_list|(
literal|"%3d %3d\n"
argument_list|,
name|olist
index|[
name|i
index|]
argument_list|,
name|olist
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|private
name|conv
parameter_list|(
name|fp
parameter_list|)
comment|/* convert a file */
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|k
decl_stmt|;
name|int
name|m
decl_stmt|,
name|n
decl_stmt|,
name|n1
decl_stmt|,
name|m1
decl_stmt|;
name|char
name|str
index|[
literal|100
index|]
decl_stmt|,
name|buf
index|[
literal|300
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
case|case
literal|' '
case|:
case|case
literal|'\0'
case|:
break|break;
case|case
literal|'{'
case|:
comment|/* push down current environment */
name|t_push
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|t_pop
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* two motion digits plus a character */
name|hmot
argument_list|(
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|getc
argument_list|(
name|fp
argument_list|)
operator|-
literal|'0'
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|HMOT
expr_stmt|;
name|put1
argument_list|(
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|CPUT
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* single ascii character */
name|put1
argument_list|(
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|CPUT
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|put1s
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|CPUT
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* straight text */
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|t_text
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|CPUT
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* draw function */
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'l'
case|:
comment|/* draw a line */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|drawline
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* circle */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawcirc
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* ellipse */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawellip
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* arc */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d %d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n1
argument_list|,
operator|&
name|m1
argument_list|)
expr_stmt|;
name|drawarc
argument_list|(
name|n
argument_list|,
name|m
argument_list|,
name|n1
argument_list|,
name|m1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
comment|/* wiggly line */
name|drawwig
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown drawing function %s\n"
argument_list|,
name|prog
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'s'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_size
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|FNT
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|setfont
argument_list|(
name|t_font
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|FNT
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* absolute horizontal motion */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|hgoto
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|HMOT
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* relative horizontal motion */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|HMOT
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|BRK
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|vgoto
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|VMOT
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|VMOT
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* new page */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_page
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|NONE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* end of line -- ignore */
while|while
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|BRK
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* comment */
comment|/* maybe should pass through as a PS comment */
while|while
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* device control */
name|devcntrl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
comment|/* imbedded PostScript */
comment|/* copy everything up to but NOT including a line */
comment|/* with at single "." */
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\n%% included PostScript\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|".\n"
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad input char \\%03o (%c)\n"
argument_list|,
name|prog
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* put in PostScript prolog */
end_comment

begin_function
name|private
name|preface
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|prolog
decl_stmt|;
name|char
name|hostname
index|[
literal|256
index|]
decl_stmt|;
name|char
name|tempfile
index|[
literal|512
index|]
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pswd
decl_stmt|;
name|long
name|clock
decl_stmt|;
name|char
modifier|*
name|libdir
decl_stmt|;
name|fprintf
argument_list|(
name|tf
argument_list|,
literal|"%%!%s\n"
argument_list|,
name|COMMENTVERSION
argument_list|)
expr_stmt|;
name|pswd
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|VOIDC
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
name|hostname
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|tf
argument_list|,
literal|"%%%%Creator: %s:%s (%s)\n"
argument_list|,
name|hostname
argument_list|,
name|pswd
operator|->
name|pw_name
argument_list|,
name|pswd
operator|->
name|pw_gecos
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tf
argument_list|,
literal|"%%%%Title: %s (ditroff)\n"
argument_list|,
name|infilename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tf
argument_list|,
literal|"%%%%CreationDate: %s"
argument_list|,
operator|(
name|time
argument_list|(
operator|&
name|clock
argument_list|)
operator|,
name|ctime
argument_list|(
operator|&
name|clock
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tf
argument_list|,
literal|"%%%%EndComments\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|libdir
operator|=
name|envget
argument_list|(
literal|"PSLIBDIR"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|libdir
operator|=
name|LibDir
expr_stmt|;
name|mstrcat
argument_list|(
name|tempfile
argument_list|,
name|libdir
argument_list|,
name|prologfile
argument_list|,
sizeof|sizeof
name|tempfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|copyfile
argument_list|(
name|tempfile
argument_list|,
name|stdout
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't copy prolog file %s\n"
argument_list|,
name|prog
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ditstart\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|devcntrl
parameter_list|(
name|fp
parameter_list|)
comment|/* interpret device control functions */
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|char
name|str
index|[
literal|20
index|]
decl_stmt|,
name|str1
index|[
literal|50
index|]
decl_stmt|,
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|int
name|c
decl_stmt|,
name|n
decl_stmt|,
name|res
decl_stmt|,
name|minh
decl_stmt|,
name|minv
decl_stmt|;
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|str
index|[
literal|0
index|]
condition|)
block|{
comment|/* crude for now */
case|case
literal|'i'
case|:
comment|/* initialize */
name|fileinit
argument_list|()
expr_stmt|;
name|t_init
argument_list|()
expr_stmt|;
name|lastcmd
operator|=
name|NONE
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* device name */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|devname
argument_list|,
literal|"psc"
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: device not psc\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"(%s)xT\n"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|NONE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* trailer */
name|t_trailer
argument_list|()
expr_stmt|;
name|lastcmd
operator|=
name|NONE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* pause -- can restart */
name|t_reset
argument_list|(
literal|'p'
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|NONE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* stop */
name|t_reset
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|NONE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* resolution assumed when prepared */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d %d %d"
argument_list|,
operator|&
name|res
argument_list|,
operator|&
name|minh
argument_list|,
operator|&
name|minv
argument_list|)
expr_stmt|;
name|t_res
argument_list|(
name|res
argument_list|,
name|minh
argument_list|,
name|minv
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|NONE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* font used */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d %s"
argument_list|,
operator|&
name|n
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* in case theres a filename */
name|ungetc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* fgets goes too far */
name|str1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* in case there is nothing to come in */
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
name|str1
argument_list|)
expr_stmt|;
name|loadfont
argument_list|(
name|n
argument_list|,
name|str
argument_list|,
name|str1
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|FNT
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* char height */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_charht
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|FNT
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* slant */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_slant
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|lastcmd
operator|=
name|FNT
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|XMOD
case|case
literal|'X'
case|:
block|{
comment|/* \X command from ditroff */
name|int
name|last
decl_stmt|;
name|char
name|largebuf
index|[
literal|128
index|]
decl_stmt|;
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%1s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|str
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'p'
case|:
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
name|fgets
argument_list|(
name|largebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|largebuf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|last
operator|=
name|strlen
argument_list|(
name|largebuf
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|last
operator|>=
literal|0
operator|&&
name|largebuf
index|[
name|last
index|]
operator|==
literal|'\n'
condition|)
block|{
name|ungetc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|largebuf
index|[
name|last
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|fputs
argument_list|(
name|largebuf
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|tf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
if|if
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|largebuf
argument_list|)
operator|==
literal|1
condition|)
block|{
name|char
modifier|*
name|nl
init|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|largebuf
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
name|nl
condition|)
operator|*
name|nl
operator|=
literal|'\0'
expr_stmt|;
name|includefile
argument_list|(
name|largebuf
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning - include cmd w/o path.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
endif|#
directive|endif
block|}
comment|/* skip rest of input line */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
block|}
empty_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XMOD
end_ifdef

begin_macro
name|includefile
argument_list|(
argument|filenm
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filenm
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|inf
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|firstch
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|inf
operator|=
name|fopen
argument_list|(
name|filenm
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"psdit: fopen(%s): "
argument_list|,
name|filenm
argument_list|)
expr_stmt|;
name|perror
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|c1
operator|=
name|fgetc
argument_list|(
name|inf
argument_list|)
expr_stmt|;
name|c2
operator|=
name|fgetc
argument_list|(
name|inf
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
literal|'%'
operator|||
name|c2
operator|!=
literal|'!'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"psdit: %s not a postscript file.\n"
argument_list|,
name|filenm
argument_list|)
operator|,
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"%!"
argument_list|,
name|tf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|fgetc
argument_list|(
name|inf
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|fputc
argument_list|(
name|ch
argument_list|,
name|tf
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstch
operator|&&
name|ch
operator|==
literal|'%'
condition|)
block|{
comment|/* we have to double leading '%'s */
name|fputc
argument_list|(
literal|'%'
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
name|firstch
operator|=
operator|(
name|ch
operator|==
literal|'\n'
operator|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|private
name|fileinit
parameter_list|()
comment|/* read in font and code files, etc. */
block|{
name|int
name|i
decl_stmt|,
name|fin
decl_stmt|,
name|nw
decl_stmt|;
name|char
modifier|*
name|filebase
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|temp
index|[
literal|60
index|]
decl_stmt|;
name|unsigned
name|msize
decl_stmt|;
comment|/* open table for device,      * read in resolution, size info, font info,   etc. and set params */
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/dev%s/DESC.out"
argument_list|,
name|ditdir
argument_list|,
name|devname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|open
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open %s - %s\n"
argument_list|,
name|prog
argument_list|,
name|devname
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|prog
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fin
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dev
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|dev
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|dev
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't read %s\n"
argument_list|,
name|prog
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|prog
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|dres
operator|=
name|dev
operator|.
name|res
expr_stmt|;
name|nfonts
operator|=
name|dev
operator|.
name|nfonts
expr_stmt|;
name|nsizes
operator|=
name|dev
operator|.
name|nsizes
expr_stmt|;
name|nchtab
operator|=
name|dev
operator|.
name|nchtab
expr_stmt|;
comment|/* enough room for whole file */
name|filebase
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|dev
operator|.
name|filesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fin
argument_list|,
name|filebase
argument_list|,
name|dev
operator|.
name|filesize
argument_list|)
operator|!=
name|dev
operator|.
name|filesize
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: trouble reading %s\n"
argument_list|,
name|prog
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|prog
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|pstab
operator|=
operator|(
name|short
operator|*
operator|)
name|filebase
expr_stmt|;
comment|/* point size table */
name|chtab
operator|=
name|pstab
operator|+
name|nsizes
operator|+
literal|1
expr_stmt|;
comment|/* char index table */
name|chname
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|chtab
operator|+
name|dev
operator|.
name|nchtab
operator|)
expr_stmt|;
comment|/* char name table */
name|p
operator|=
name|chname
operator|+
name|dev
operator|.
name|lchname
expr_stmt|;
comment|/* end of char name table */
comment|/* parse the preloaded font tables */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nfonts
condition|;
name|i
operator|++
control|)
block|{
name|fontdelta
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fontbase
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|font
operator|*
operator|)
name|p
expr_stmt|;
name|nw
operator|=
operator|*
name|p
operator|&
name|BMASK
expr_stmt|;
comment|/* number of width entries */
if|if
condition|(
operator|(
name|smnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fontbase
index|[
name|i
index|]
operator|->
name|specfont
operator|==
literal|1
operator|)
condition|)
name|smnt
operator|=
name|i
expr_stmt|;
comment|/* first special font */
name|p
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
expr_stmt|;
comment|/* skip header */
name|widthtab
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
comment|/* width table */
comment|/* kern table is next */
name|codetab
index|[
name|i
index|]
operator|=
name|p
operator|+
literal|2
operator|*
name|nw
expr_stmt|;
comment|/* device codes */
name|fitab
index|[
name|i
index|]
operator|=
name|p
operator|+
literal|3
operator|*
name|nw
expr_stmt|;
comment|/* font index table */
name|p
operator|+=
literal|3
operator|*
name|nw
operator|+
name|dev
operator|.
name|nchtab
operator|+
operator|(
literal|128
operator|-
literal|32
operator|)
expr_stmt|;
comment|/* next font */
name|t_fp
argument_list|(
name|i
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|namefont
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|intname
argument_list|)
expr_stmt|;
name|loadpswidths
argument_list|(
name|i
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|namefont
argument_list|)
expr_stmt|;
name|sayload
argument_list|(
name|i
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|namefont
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|fdbg
operator|>
literal|1
condition|)
name|fontprint
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|fontdelta
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|msize
operator|=
literal|3
operator|*
literal|255
operator|+
name|dev
operator|.
name|nchtab
operator|+
operator|(
literal|128
operator|-
literal|32
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
expr_stmt|;
name|fontbase
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|font
operator|*
operator|)
name|malloc
argument_list|(
name|msize
argument_list|)
expr_stmt|;
name|widthtab
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
literal|0
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
expr_stmt|;
name|fontbase
index|[
literal|0
index|]
operator|->
name|nwfont
operator|=
literal|255
expr_stmt|;
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|loadpswidths
parameter_list|(
name|i
parameter_list|,
name|name
parameter_list|)
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
name|temp
index|[
literal|60
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|auxin
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|wid
decl_stmt|,
name|funny
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/dev%s/%s.aux"
argument_list|,
name|ditdir
argument_list|,
name|devname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|auxin
operator|=
name|fopen
argument_list|(
name|temp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* allocate table */
if|if
condition|(
name|pswidths
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|pswidths
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
literal|256
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* initialize to not-there */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|255
condition|;
name|pswidths
index|[
name|i
index|]
index|[
name|j
operator|++
index|]
operator|=
operator|-
literal|1
control|)
empty_stmt|;
comment|/* read them in */
while|while
condition|(
name|fscanf
argument_list|(
name|auxin
argument_list|,
literal|"%d %d %d"
argument_list|,
operator|&
name|cc
argument_list|,
operator|&
name|wid
argument_list|,
operator|&
name|funny
argument_list|)
operator|!=
name|EOF
condition|)
block|{
name|pswidths
index|[
name|i
index|]
index|[
name|cc
index|]
operator|=
name|wid
operator||
operator|(
name|funny
operator|<<
literal|12
operator|)
expr_stmt|;
block|}
name|VOIDC
name|fclose
argument_list|(
name|auxin
argument_list|)
decl_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|private
name|fontprint
parameter_list|(
name|i
parameter_list|)
comment|/* debugging print of font i (0,...) */
name|int
name|i
decl_stmt|;
block|{
name|int
name|j
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"font %d:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
name|i
index|]
expr_stmt|;
name|n
operator|=
name|fontbase
index|[
name|i
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
name|printf
argument_list|(
literal|"base=0%o, nchars=%d, spec=%d, name=%s, widtab=0%o, fitab=0%o\n"
argument_list|,
name|p
argument_list|,
name|n
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|specfont
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|namefont
argument_list|,
name|widthtab
index|[
name|i
index|]
argument_list|,
name|fitab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"widths:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2d"
argument_list|,
name|widthtab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\ncodetab:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2d"
argument_list|,
name|codetab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nfitab:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|dev
operator|.
name|nchtab
operator|+
literal|128
operator|-
literal|32
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2d"
argument_list|,
name|fitab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|private
name|loadfont
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|,
name|s1
parameter_list|)
comment|/* load font info for font s on position n */
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|s1
decl_stmt|;
end_function

begin_block
block|{
name|char
name|temp
index|[
literal|60
index|]
decl_stmt|;
name|int
name|fin
decl_stmt|,
name|nw
decl_stmt|,
name|norig
decl_stmt|;
name|int
name|bcount
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|NFONT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: illegal fp command %d %s\n"
argument_list|,
name|prog
argument_list|,
name|n
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|namefont
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|fontbase
index|[
name|n
index|]
operator|->
name|namefont
operator|!=
literal|0
condition|)
block|{
name|fontdelta
index|[
name|n
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|s1
operator|==
name|NULL
operator|||
name|s1
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/dev%s/%s.out"
argument_list|,
name|ditdir
argument_list|,
name|devname
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/%s.out"
argument_list|,
name|s1
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fin
operator|=
name|open
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open font table %s\n"
argument_list|,
name|prog
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|prog
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|norig
operator|=
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
name|bcount
operator|=
literal|3
operator|*
name|norig
operator|+
name|nchtab
operator|+
literal|128
operator|-
literal|32
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
expr_stmt|;
name|VOIDC
name|read
argument_list|(
name|fin
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
name|n
index|]
argument_list|,
name|bcount
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|&
name|BMASK
operator|)
operator|>
name|norig
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Font %s too big for position %d\n"
argument_list|,
name|prog
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|nw
operator|=
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
name|widthtab
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
name|n
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
expr_stmt|;
name|codetab
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|widthtab
index|[
name|n
index|]
operator|+
literal|2
operator|*
name|nw
expr_stmt|;
name|fitab
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|widthtab
index|[
name|n
index|]
operator|+
literal|3
operator|*
name|nw
expr_stmt|;
name|t_fp
argument_list|(
name|n
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|namefont
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|intname
argument_list|)
expr_stmt|;
name|loadpswidths
argument_list|(
name|n
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|namefont
argument_list|)
expr_stmt|;
name|sayload
argument_list|(
name|n
argument_list|,
name|s
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|=
name|norig
expr_stmt|;
comment|/* so can later use full original size */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|fdbg
operator|>
literal|1
condition|)
name|fontprint
argument_list|(
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_function
name|private
name|sayload
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|,
name|s1
parameter_list|)
comment|/* position n contains font s (internal s1) */
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|s1
decl_stmt|;
end_function

begin_block
block|{
name|char
name|pass
index|[
literal|60
index|]
decl_stmt|;
name|FILE
modifier|*
name|ptrfile
decl_stmt|;
name|char
name|Adobefont
index|[
literal|60
index|]
decl_stmt|;
if|if
condition|(
name|s1
operator|==
name|NULL
operator|||
name|s1
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|sprintf
argument_list|(
name|pass
argument_list|,
literal|"%s/dev%s/%s.map"
argument_list|,
name|ditdir
argument_list|,
name|devname
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|pass
argument_list|,
literal|"%s/%s.map"
argument_list|,
name|s1
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ptrfile
operator|=
name|fopen
argument_list|(
name|pass
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open font map file %s\n"
argument_list|,
name|prog
argument_list|,
name|pass
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|prog
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|fscanf
argument_list|(
name|ptrfile
argument_list|,
literal|"%s"
argument_list|,
name|Adobefont
argument_list|)
expr_stmt|;
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d(%s)xf %d f\n"
argument_list|,
name|n
argument_list|,
name|Adobefont
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|font
operator|=
name|n
expr_stmt|;
name|VOIDC
name|fclose
parameter_list|(
name|ptrfile
parameter_list|)
function_decl|;
block|}
end_block

begin_function
name|private
name|VOID
name|done
parameter_list|()
block|{
if|if
condition|(
name|tf
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|t_reset
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|t_init
parameter_list|()
comment|/* "x i" - initialize device */
block|{
name|movepending
operator|=
name|NONE
expr_stmt|;
name|savex
operator|=
name|savey
operator|=
literal|0
expr_stmt|;
name|t_size
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* start somewhere */
name|t_slant
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setfont
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* set font */
name|printf
argument_list|(
literal|"xi\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%%%%EndProlog\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|t_push
parameter_list|()
comment|/* begin a new block */
block|{
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
if|if
condition|(
name|dlevel
operator|==
name|DSTACK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: ditroff push/pop overflow!\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|hpos
operator|=
name|hpos
expr_stmt|;
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|vpos
operator|=
name|vpos
expr_stmt|;
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|fontsize
operator|=
name|fontsize
expr_stmt|;
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|fontheight
operator|=
name|fontheight
expr_stmt|;
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|fontslant
operator|=
name|fontslant
expr_stmt|;
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|font
operator|=
name|font
expr_stmt|;
name|dlevel
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"\nditpush\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|t_pop
parameter_list|()
comment|/* pop to previous state */
block|{
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
if|if
condition|(
name|dlevel
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: ditroff push/pop underflow!\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|dlevel
operator|--
expr_stmt|;
name|hpos
operator|=
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|hpos
expr_stmt|;
name|vpos
operator|=
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|vpos
expr_stmt|;
name|fontsize
operator|=
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|fontsize
expr_stmt|;
name|fontheight
operator|=
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|fontheight
expr_stmt|;
name|fontslant
operator|=
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|fontslant
expr_stmt|;
name|font
operator|=
name|ditstack
index|[
name|dlevel
index|]
operator|.
name|font
expr_stmt|;
name|printf
argument_list|(
literal|"%d s %d xH %d xS %d f\n"
argument_list|,
name|fontsize
argument_list|,
name|fontheight
argument_list|,
name|fontslant
argument_list|,
name|font
argument_list|)
expr_stmt|;
name|startx
operator|=
name|savex
operator|=
name|hpos
expr_stmt|;
name|savey
operator|=
name|vpos
expr_stmt|;
name|PSx
operator|=
name|hpos
operator|*
name|PSmag
expr_stmt|;
name|PSy
operator|=
name|vpos
operator|*
name|PSmag
expr_stmt|;
name|printf
argument_list|(
literal|"%d %d MXY\n"
argument_list|,
name|savex
argument_list|,
name|savey
argument_list|)
expr_stmt|;
name|movepending
operator|=
name|NONE
expr_stmt|;
name|printf
argument_list|(
literal|"\nditpop\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|t_page
parameter_list|(
name|n
parameter_list|)
comment|/* do whatever new page functions */
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|output
condition|)
block|{
if|if
condition|(
operator|++
name|scount
operator|>=
name|spage
condition|)
block|{
name|t_reset
argument_list|(
literal|'p'
argument_list|)
expr_stmt|;
name|scount
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|output
operator|=
literal|1
expr_stmt|;
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|firstpage
condition|)
block|{
name|printf
argument_list|(
literal|"\n%d p"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|firstpage
operator|=
name|FALSE
expr_stmt|;
name|printf
argument_list|(
literal|"\n%%%%Page: %d %d\n"
argument_list|,
name|n
argument_list|,
operator|++
name|pageno
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nfonts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fontdelta
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|sayload
argument_list|(
name|i
argument_list|,
name|fontname
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|vpos
operator|=
literal|0
expr_stmt|;
name|PSy
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%d s %d xH %d xS %d f\n"
argument_list|,
name|fontsize
argument_list|,
name|fontheight
argument_list|,
name|fontslant
argument_list|,
name|font
argument_list|)
expr_stmt|;
if|if
condition|(
name|nolist
operator|==
literal|0
condition|)
return|return;
name|output
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nolist
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
name|n
operator|>=
name|olist
index|[
name|i
index|]
operator|&&
name|n
operator|<=
name|olist
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|output
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|private
name|t_size
parameter_list|(
name|n
parameter_list|)
comment|/* convert integer to internal size number*/
name|int
name|n
decl_stmt|;
block|{
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontsize
operator|!=
name|n
condition|)
block|{
name|fontsize
operator|=
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|XMOD
name|fontheight
operator|=
name|n
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"%d s\n"
argument_list|,
name|fontsize
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|t_charht
parameter_list|(
name|n
parameter_list|)
comment|/* set character height to n */
name|int
name|n
decl_stmt|;
block|{
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontheight
operator|!=
name|n
condition|)
block|{
name|fontheight
operator|=
name|n
expr_stmt|;
name|printf
argument_list|(
literal|"%d xH\n"
argument_list|,
name|fontheight
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|t_slant
parameter_list|(
name|n
parameter_list|)
comment|/* set slant to n */
name|int
name|n
decl_stmt|;
block|{
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontslant
operator|!=
name|n
condition|)
block|{
name|fontslant
operator|=
name|n
expr_stmt|;
name|printf
argument_list|(
literal|"%d xS\n"
argument_list|,
name|fontslant
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|t_font
parameter_list|(
name|s
parameter_list|)
comment|/* convert string to internal font number */
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|nfonts
condition|)
name|n
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
name|private
name|t_text
parameter_list|(
name|s
parameter_list|)
comment|/* print string s as text??? */
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: ditroff t<%s> unimplemented!\n"
argument_list|,
name|prog
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|t_reset
parameter_list|(
name|c
parameter_list|)
block|{
name|output
operator|=
literal|1
expr_stmt|;
comment|/* by God */
if|if
condition|(
name|c
operator|==
literal|'p'
condition|)
block|{
name|printf
argument_list|(
literal|"\nxp\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|stopped
condition|)
name|printf
argument_list|(
literal|"\nxs\n"
argument_list|)
expr_stmt|;
name|stopped
operator|=
literal|1
expr_stmt|;
block|}
name|fflush
argument_list|(
name|tf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|t_res
parameter_list|(
name|res
parameter_list|,
name|minh
parameter_list|,
name|minv
parameter_list|)
name|int
name|res
decl_stmt|,
name|minh
decl_stmt|,
name|minv
decl_stmt|;
block|{
name|resolution
operator|=
name|res
expr_stmt|;
name|minhoriz
operator|=
name|minh
expr_stmt|;
name|minvert
operator|=
name|minv
expr_stmt|;
name|printf
argument_list|(
literal|"%d %d %d xr\n"
argument_list|,
name|res
argument_list|,
name|minh
argument_list|,
name|minv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|t_trailer
parameter_list|()
block|{
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%d p"
argument_list|,
name|pageno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%%%%Trailer\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xt\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|put1s
parameter_list|(
name|s
parameter_list|)
comment|/* s is a funny char name */
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
return|return;
name|debugp
argument_list|(
operator|(
literal|"%s "
operator|,
name|s
operator|)
argument_list|)
expr_stmt|;
comment|/* search for s in the funny char name table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchtab
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|chname
index|[
name|chtab
index|[
name|i
index|]
index|]
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|nchtab
condition|)
block|{
name|put1
argument_list|(
name|i
operator|+
literal|128
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|debugp
argument_list|(
operator|(
literal|"not found "
operator|)
argument_list|)
expr_stmt|;
name|putnf
argument_list|(
literal|0
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|needsescape
parameter_list|(
name|c
parameter_list|)
value|((c=='\\') || (c=='(') || (c==')'))
end_define

begin_function
name|private
name|put1
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
comment|/* output char c */
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|pw
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|int
name|cc
decl_stmt|;
name|int
name|ofont
decl_stmt|,
name|code
decl_stmt|;
name|int
name|psinfo
decl_stmt|,
name|pswid
decl_stmt|,
name|tw
decl_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
return|return;
if|if
condition|(
name|c
operator|==
literal|32
condition|)
block|{
name|thisw
operator|=
literal|0
expr_stmt|;
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
operator|<
literal|32
condition|)
block|{
name|debugp
argument_list|(
operator|(
literal|"non-exist 0%o\n"
operator|,
name|c
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|-=
literal|32
expr_stmt|;
comment|/* offset char code */
name|k
operator|=
name|ofont
operator|=
name|pfont
operator|=
name|font
expr_stmt|;
if|if
condition|(
name|onspecial
condition|)
name|pfont
operator|=
name|prevfont
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
operator|(
name|fitab
index|[
name|pfont
index|]
index|[
name|c
index|]
operator|&
name|BMASK
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* char on this font */
name|p
operator|=
name|codetab
index|[
name|pfont
index|]
expr_stmt|;
name|pw
operator|=
name|widthtab
index|[
name|pfont
index|]
expr_stmt|;
if|if
condition|(
name|onspecial
condition|)
block|{
name|setfont
argument_list|(
name|prevfont
argument_list|)
expr_stmt|;
name|thisw
operator|=
literal|0
expr_stmt|;
name|onspecial
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|smnt
operator|>
literal|0
condition|)
block|{
comment|/* on special (we hope) */
for|for
control|(
name|k
operator|=
name|smnt
init|;
name|k
operator|<=
name|nfonts
condition|;
name|k
operator|+=
literal|1
control|)
if|if
condition|(
operator|(
name|i
operator|=
operator|(
name|fitab
index|[
name|k
index|]
index|[
name|c
index|]
operator|&
name|BMASK
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|codetab
index|[
name|k
index|]
expr_stmt|;
name|pw
operator|=
name|widthtab
index|[
name|k
index|]
expr_stmt|;
name|prevfont
operator|=
name|pfont
expr_stmt|;
if|if
condition|(
name|onspecial
operator|&&
operator|(
name|k
operator|==
name|specfont
operator|)
condition|)
break|break;
name|setfont
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|thisw
operator|=
literal|0
expr_stmt|;
name|onspecial
operator|=
literal|1
expr_stmt|;
name|specfont
operator|=
name|k
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|||
operator|(
name|k
operator|>
name|nfonts
operator|)
operator|||
operator|(
operator|(
name|code
operator|=
name|p
index|[
name|i
index|]
operator|&
name|BMASK
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|debugp
argument_list|(
operator|(
literal|"not found 0%o\n"
operator|,
name|c
operator|+
literal|32
operator|)
argument_list|)
expr_stmt|;
name|putnf
argument_list|(
name|c
operator|+
literal|32
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* when we get here,      *  c == biased character code      *	k == font number      *  i == index into codetab and widthtab for this character      *  p == codetab for this font      *  pw == width tab for this font      *  code == character code for this char      */
name|cc
operator|=
name|c
operator|+
literal|32
expr_stmt|;
name|debugp
argument_list|(
operator|(
operator|(
name|isascii
argument_list|(
name|cc
argument_list|)
operator|&&
name|isprint
argument_list|(
name|cc
argument_list|)
operator|)
condition|?
literal|"%c %d\n"
else|:
literal|"%03o %d\n"
operator|,
name|cc
operator|,
name|code
operator|)
argument_list|)
expr_stmt|;
name|psinfo
operator|=
name|pswidths
index|[
name|font
index|]
index|[
name|code
index|]
expr_stmt|;
comment|/* PS specific char info */
name|pswid
operator|=
name|psinfo
operator|&
name|PSWID
expr_stmt|;
comment|/* PS character width */
name|thisw
operator|=
name|pw
index|[
name|i
index|]
operator|&
name|BMASK
expr_stmt|;
comment|/* troff char width */
name|tw
operator|=
name|thisw
operator|=
operator|(
name|thisw
operator|*
name|fontsize
operator|+
name|dev
operator|.
name|unitwidth
operator|/
literal|2
operator|)
operator|/
name|dev
operator|.
name|unitwidth
expr_stmt|;
if|if
condition|(
operator|(
name|psinfo
operator|&
name|ISPSPROC
operator|)
operator|&&
operator|(
name|psinfo
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* character is implemented by a PostScript proc */
name|showspecial
argument_list|(
name|s
argument_list|,
name|code
argument_list|,
name|pswid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pswid
operator|>
literal|0
condition|)
block|{
name|PSx
operator|+=
name|PSscale
argument_list|(
name|pswid
operator|*
name|fontsize
operator|*
name|dres
argument_list|)
expr_stmt|;
block|}
name|thisw
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|showchar
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|pswid
operator|>
literal|0
condition|)
block|{
name|PSshowlen
operator|+=
name|PSscale
argument_list|(
name|pswid
operator|*
name|fontsize
operator|*
name|dres
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*     if (font != ofont) { 	setfont(ofont); 	startx = hpos + tw; 	thisw = 0; 	lastcmd = FNT;     } */
name|debugp
argument_list|(
operator|(
literal|"...width (%d)\n"
operator|,
name|pw
index|[
name|i
index|]
operator|&
name|BMASK
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|putnf
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
comment|/* note that a character wasnt found */
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|thisw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'\0'
operator|)
condition|)
name|printf
argument_list|(
literal|"(\%3o)cb\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"\\|"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"\\^"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"\\&"
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return;
else|else
name|printf
argument_list|(
literal|"(%s)cb\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|t_fp
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|,
name|si
parameter_list|)
comment|/* font position n now contains font s, intname si */
name|int
name|n
decl_stmt|;
comment|/* position */
name|char
modifier|*
name|s
decl_stmt|;
comment|/* font (ditname) */
name|char
modifier|*
name|si
decl_stmt|;
comment|/* font (intname = number) */
block|{
name|fontname
index|[
name|n
index|]
operator|.
name|name
operator|=
name|s
expr_stmt|;
name|fontname
index|[
name|n
index|]
operator|.
name|number
operator|=
name|atoi
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|setfont
parameter_list|(
name|n
parameter_list|)
comment|/* set font to n */
name|int
name|n
decl_stmt|;
block|{
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|NFONT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: illegal font %d\n"
argument_list|,
name|prog
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|font
operator|!=
name|n
condition|)
block|{
name|font
operator|=
name|n
expr_stmt|;
name|printf
argument_list|(
literal|"%d f\n"
argument_list|,
name|font
argument_list|)
expr_stmt|;
block|}
name|onspecial
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|private
name|drawline
parameter_list|(
name|dx
parameter_list|,
name|dy
parameter_list|)
comment|/* draw line from here to dx, dy */
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
block|{
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%d %d Dl\n"
argument_list|,
name|dx
argument_list|,
name|dy
argument_list|)
expr_stmt|;
name|hpos
operator|+=
name|dx
expr_stmt|;
name|PSx
operator|=
name|hpos
operator|*
name|PSmag
expr_stmt|;
name|vpos
operator|+=
name|dy
expr_stmt|;
name|PSy
operator|=
name|vpos
operator|*
name|PSmag
expr_stmt|;
block|}
end_function

begin_function
name|private
name|drawwig
parameter_list|(
name|s
parameter_list|)
comment|/* draw wiggly line */
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"D~ %s D~~\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|drawcirc
parameter_list|(
name|d
parameter_list|)
name|int
name|d
decl_stmt|;
block|{
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%d Dc\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|drawarc
parameter_list|(
name|dx1
parameter_list|,
name|dy1
parameter_list|,
name|dx2
parameter_list|,
name|dy2
parameter_list|)
name|int
name|dx1
decl_stmt|,
name|dy1
decl_stmt|,
name|dx2
decl_stmt|,
name|dy2
decl_stmt|;
block|{
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%d %d %d %d Da\n"
argument_list|,
name|dx1
argument_list|,
name|dy1
argument_list|,
name|dx2
argument_list|,
name|dy2
argument_list|)
expr_stmt|;
name|hpos
operator|+=
name|dx1
operator|+
name|dx2
expr_stmt|;
name|PSx
operator|=
name|hpos
operator|*
name|PSmag
expr_stmt|;
name|vpos
operator|+=
name|dy1
operator|+
name|dy2
expr_stmt|;
name|PSy
operator|=
name|vpos
operator|*
name|PSmag
expr_stmt|;
block|}
end_function

begin_function
name|private
name|drawellip
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%d %d De\n"
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|hmot
parameter_list|(
name|a
parameter_list|)
comment|/* relative horizontal motion */
name|int
name|a
decl_stmt|;
block|{
specifier|register
name|int
name|aa
decl_stmt|;
name|aa
operator|=
name|abs
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|aa
operator|<
literal|8
operator|)
operator|||
operator|(
name|aa
operator|>
operator|(
literal|10
operator|*
name|thisw
operator|)
operator|)
operator|||
operator|(
name|a
operator|>=
literal|100
operator|)
operator|||
operator|(
operator|(
name|thisw
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|abs
argument_list|(
name|thisw
operator|-
name|a
argument_list|)
operator|>
literal|4
operator|)
operator|)
condition|)
block|{
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hpos
operator|+=
name|a
expr_stmt|;
if|if
condition|(
name|lastcmd
operator|!=
name|CPUT
condition|)
name|startx
operator|=
name|hpos
expr_stmt|;
block|}
end_function

begin_function
name|private
name|hgoto
parameter_list|(
name|a
parameter_list|)
comment|/* absolute horizontal motion */
name|int
name|a
decl_stmt|;
block|{
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|startx
operator|=
name|hpos
operator|=
name|a
expr_stmt|;
name|thisw
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|private
name|vmot
parameter_list|(
name|a
parameter_list|)
comment|/* relative vertical motion */
name|int
name|a
decl_stmt|;
block|{
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|vpos
operator|+=
name|a
expr_stmt|;
name|thisw
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|private
name|vgoto
parameter_list|(
name|a
parameter_list|)
comment|/* absolute vertical motion */
name|int
name|a
decl_stmt|;
block|{
name|FlushShow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|vpos
operator|=
name|a
expr_stmt|;
name|thisw
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|private
name|showspecial
parameter_list|(
name|s
parameter_list|,
name|cc
parameter_list|,
name|wid
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|int
name|wid
decl_stmt|;
block|{
name|char
modifier|*
name|sp
decl_stmt|;
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
name|DoMove
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|s
init|;
operator|*
name|sp
operator|!=
literal|'\0'
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|needsescape
argument_list|(
operator|*
name|sp
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
operator|*
name|sp
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")%d %d oc\n"
argument_list|,
name|cc
argument_list|,
name|wid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|showchar
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|showind
operator|==
literal|0
condition|)
block|{
name|MoveTo
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|vpos
operator|*
name|PSmag
operator|)
operator|!=
name|PSy
condition|)
block|{
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|MoveTo
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|showind
operator|>=
name|SHOWSIZE
condition|)
name|FlushShow
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
name|showbuf
index|[
name|showind
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
comment|/* fall through */
default|default:
name|showbuf
index|[
name|showind
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
block|{
name|showbuf
index|[
name|showind
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|showbuf
index|[
name|showind
operator|++
index|]
operator|=
operator|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator|&
literal|03
operator|)
operator|+
literal|'0'
expr_stmt|;
name|showbuf
index|[
name|showind
operator|++
index|]
operator|=
operator|(
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
literal|07
operator|)
operator|+
literal|'0'
expr_stmt|;
name|showbuf
index|[
name|showind
operator|++
index|]
operator|=
operator|(
name|c
operator|&
literal|07
operator|)
operator|+
literal|'0'
expr_stmt|;
block|}
name|showbuf
index|[
name|showind
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nshow
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|private
name|MoveTo
parameter_list|()
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|x
operator|=
name|hpos
operator|*
name|PSmag
expr_stmt|;
name|y
operator|=
name|vpos
operator|*
name|PSmag
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|PSx
condition|)
block|{
name|startx
operator|=
name|savex
operator|=
name|hpos
expr_stmt|;
name|PSx
operator|=
name|x
expr_stmt|;
name|movepending
operator||=
name|XMOVE
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|!=
name|PSy
condition|)
block|{
name|savey
operator|=
name|vpos
expr_stmt|;
name|PSy
operator|=
name|y
expr_stmt|;
name|movepending
operator||=
name|YMOVE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|FlushMove
parameter_list|()
block|{
switch|switch
condition|(
name|movepending
condition|)
block|{
case|case
name|NONE
case|:
break|break;
case|case
name|XMOVE
case|:
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|savex
argument_list|)
expr_stmt|;
break|break;
case|case
name|YMOVE
case|:
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|savey
argument_list|)
expr_stmt|;
break|break;
case|case
name|XYMOVE
case|:
name|printf
argument_list|(
literal|"%d %d"
argument_list|,
name|savex
argument_list|,
name|savey
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: invalid move code %d\n"
argument_list|,
name|prog
argument_list|,
name|movepending
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|private
name|char
modifier|*
name|movecmds
index|[]
init|=
block|{
literal|"MX"
block|,
literal|"MY"
block|,
literal|"MXY"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|DoMove
parameter_list|()
block|{
name|FlushMove
argument_list|()
expr_stmt|;
if|if
condition|(
name|movepending
operator|!=
name|NONE
condition|)
block|{
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|movecmds
index|[
name|movepending
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|movepending
operator|=
name|NONE
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|private
name|char
name|showops
index|[]
init|=
literal|"SXYN"
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|FlushShow
parameter_list|(
name|t
parameter_list|)
name|int
name|t
decl_stmt|;
block|{
name|long
name|err
decl_stmt|,
name|tlen
decl_stmt|;
name|float
name|cerror
decl_stmt|;
if|if
condition|(
name|showind
operator|==
literal|0
condition|)
block|{
name|thisw
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|movepending
operator|!=
name|NONE
condition|)
block|{
name|FlushMove
argument_list|()
expr_stmt|;
block|}
name|tlen
operator|=
name|hpos
operator|-
name|startx
expr_stmt|;
if|if
condition|(
name|lastcmd
operator|==
name|CPUT
condition|)
name|tlen
operator|+=
name|thisw
expr_stmt|;
name|err
operator|=
name|tlen
operator|*
name|PSmag
operator|-
name|PSshowlen
expr_stmt|;
if|if
condition|(
operator|(
name|nshow
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|abs
argument_list|(
name|err
argument_list|)
operator|>
name|ErrorTolerance
operator|)
condition|)
block|{
name|cerror
operator|=
operator|(
operator|(
name|float
operator|)
name|err
operator|)
operator|/
operator|(
operator|(
name|nshow
operator|-
literal|1
operator|)
operator|*
name|PSmag
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"F%d lc %d thisw %d "
argument_list|,
name|t
argument_list|,
name|lastcmd
argument_list|,
name|thisw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"x %ld h %ld tn %ld %ld "
argument_list|,
name|startx
argument_list|,
name|hpos
argument_list|,
name|tlen
operator|*
name|PSmag
argument_list|,
name|PSshowlen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error %d %.4f %s\n"
argument_list|,
name|nshow
argument_list|,
name|cerror
argument_list|,
name|showbuf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|" %.4f(%s)A%c\n"
argument_list|,
name|cerror
argument_list|,
name|showbuf
argument_list|,
name|showops
index|[
name|movepending
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"(%s)%c\n"
argument_list|,
name|showbuf
argument_list|,
name|showops
index|[
name|movepending
index|]
argument_list|)
expr_stmt|;
block|}
name|showind
operator|=
literal|0
expr_stmt|;
name|nshow
operator|=
literal|0
expr_stmt|;
name|showbuf
index|[
name|showind
index|]
operator|=
literal|'\0'
expr_stmt|;
name|PSx
operator|+=
name|PSshowlen
expr_stmt|;
name|PSshowlen
operator|=
literal|0
expr_stmt|;
name|startx
operator|=
name|hpos
expr_stmt|;
if|if
condition|(
name|lastcmd
operator|==
name|CPUT
condition|)
name|startx
operator|+=
name|thisw
expr_stmt|;
name|thisw
operator|=
literal|0
expr_stmt|;
name|movepending
operator|=
name|NONE
expr_stmt|;
block|}
end_function

end_unit

