begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $ */
end_comment

begin_comment
comment|/*****************************************************************************\  *                                                                           *  *                                Porting Note                               *  *                                                                           *  * Add the value of BOOTSTRAPCFLAGS to the cpp_argv table so that it will be *  * passed to the template file.                                              *  *                                                                           * \*****************************************************************************/
end_comment

begin_comment
comment|/*  *   * Copyright 1985, 1986, 1987 by the Massachusetts Institute of Technology  *   * Permission to use, copy, modify, and distribute this  * software and its documentation for any purpose and without  * fee is hereby granted, provided that the above copyright  * notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting  * documentation, and that the name of M.I.T. not be used in  * advertising or publicity pertaining to distribution of the  * software without specific, written prior permission.  * M.I.T. makes no representations about the suitability of  * this software for any purpose.  It is provided "as is"  * without express or implied warranty.  *   * Original Author:  *	Todd Brunhoff  *	Tektronix, inc.  *	While a guest engineer at Project Athena, MIT  *  * imake: the include-make program.  *  * Usage: imake [-Idir] [-Ddefine] [-T] [-f imakefile ] [-s] [-e] [-v] [make flags]  *  * Imake takes a template makefile (Imake.tmpl) and runs cpp on it  * producing a temporary makefile in /tmp.  It then runs make on  * this pre-processed makefile.  * Options:  *		-D	define.  Same as cpp -D argument.  *		-I	Include directory.  Same as cpp -I argument.  *		-T	template.  Designate a template other  * 			than Imake.tmpl  *		-s[F]	show.  Show the produced makefile on the standard  *			output.  Make is not run is this case.  If a file  *			argument is provided, the output is placed there.  *              -e[F]   execute instead of show; optionally name Makefile F  *		-v	verbose.  Show the make command line executed.  *  * Environment variables:  *		  *		IMAKEINCLUDE	Include directory to use in addition to "."  *		IMAKECPP	Cpp to use instead of /lib/cpp  *		IMAKEMAKE	make program to use other than what is  *				found by searching the $PATH variable.  * Other features:  *	imake reads the entire cpp output into memory and then scans it  *	for occurences of "@@".  If it encounters them, it replaces it with  *	a newline.  It also trims any trailing white space on output lines  *	(because make gets upset at them).  This helps when cpp expands  *	multi-line macros but you want them to appear on multiple lines.  *  *	The macros MAKEFILE and MAKE are provided as macros  *	to make.  MAKEFILE is set to imake's makefile (not the constructed,  *	preprocessed one) and MAKE is set to argv[0], i.e. the name of  *	the imake program.  *  * Theory of operation:  *   1. Determine the name of the imakefile from the command line (-f)  *	or from the content of the current directory (Imakefile or imakefile).  *	Call this<imakefile>.  This gets added to the arguments for  *	make as MAKEFILE=<imakefile>.  *   2. Determine the name of the template from the command line (-T)  *	or the default, Imake.tmpl.  Call this<template>  *   3. Start up cpp an provide it with three lines of input:  *		#define IMAKE_TEMPLATE		"<template> "  *		#define INCLUDE_IMAKEFILE<<imakefile>>  *		#include IMAKE_TEMPLATE  *	Note that the define for INCLUDE_IMAKEFILE is intended for  *	use in the template file.  This implies that the imake is  *	useless unless the template file contains at least the line  *		#include INCLUDE_IMAKEFILE  *   4. Gather the output from cpp, and clean it up, expanding @@ to  *	newlines, stripping trailing white space, cpp control lines,  *	and extra blank lines.  This cleaned output is placed in a  *	temporary file.  Call this<makefile>.  *   5. Start up make specifying<makefile> as its input.  *  * The design of the template makefile should therefore be:  *<set global macros like CFLAGS, etc.>  *<include machine dependent additions>  *	#include INCLUDE_IMAKEFILE  *<add any global targets like 'clean' and long dependencies>  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|SVR4
argument_list|)
operator|||
name|defined
argument_list|(
name|_IBMR2
argument_list|)
operator|||
name|defined
argument_list|(
name|SYSV386
argument_list|)
operator|)
operator|&&
name|__STDC__
end_if

begin_function_decl
name|FILE
modifier|*
name|fdopen
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"Xosdefs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|X_NOT_POSIX
end_ifndef

begin_define
define|#
directive|define
name|_POSIX_SOURCE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|X_NOT_POSIX
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|hp9000
end_ifdef

begin_undef
undef|#
directive|undef
name|_POSIX_SOURCE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|hp9000
end_ifdef

begin_define
define|#
directive|define
name|_POSIX_SOURCE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|X_NOT_POSIX
argument_list|)
operator|||
name|defined
argument_list|(
name|_POSIX_SOURCE
argument_list|)
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_POSIX_SOURCE
end_define

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_undef
undef|#
directive|undef
name|_POSIX_SOURCE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|X_NOT_POSIX
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|_POSIX_SOURCE
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_POSIX_SOURCE
end_define

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_undef
undef|#
directive|undef
name|_POSIX_SOURCE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|waitCode
parameter_list|(
name|w
parameter_list|)
value|WEXITSTATUS(w)
end_define

begin_define
define|#
directive|define
name|waitSig
parameter_list|(
name|w
parameter_list|)
value|WTERMSIG(w)
end_define

begin_typedef
typedef|typedef
name|int
name|waitType
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* X_NOT_POSIX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_define
define|#
directive|define
name|waitCode
parameter_list|(
name|w
parameter_list|)
value|(((w)>> 8)& 0x7f)
end_define

begin_define
define|#
directive|define
name|waitSig
parameter_list|(
name|w
parameter_list|)
value|((w)& 0xff)
end_define

begin_typedef
typedef|typedef
name|int
name|waitType
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SYSV */
end_comment

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_define
define|#
directive|define
name|waitCode
parameter_list|(
name|w
parameter_list|)
value|((w).w_T.w_Retcode)
end_define

begin_define
define|#
directive|define
name|waitSig
parameter_list|(
name|w
parameter_list|)
value|((w).w_T.w_Termsig)
end_define

begin_typedef
typedef|typedef
name|union
name|wait
name|waitType
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WIFSIGNALED
end_ifndef

begin_define
define|#
directive|define
name|WIFSIGNALED
parameter_list|(
name|w
parameter_list|)
value|waitSig(w)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WIFEXITED
end_ifndef

begin_define
define|#
directive|define
name|WIFEXITED
parameter_list|(
name|w
parameter_list|)
value|waitCode(w)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* X_NOT_POSIX */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|X_NOT_STDC_ENV
end_ifndef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|exit
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|macII
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_comment
comment|/* stdlib.h fails to define these */
end_comment

begin_decl_stmt
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* macII */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|X_NOT_STDC_ENV
end_ifdef

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"imakemdep.h"
end_include

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|FIXUP_CPP_WHITESPACE
end_ifdef

begin_decl_stmt
name|int
name|InRule
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Some versions of cpp reduce all tabs in macro expansion to a single  * space.  In addition, the escaped newline may be replaced with a  * space instead of being deleted.  Blech.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FIXUP_CPP_WHITESPACE
end_ifndef

begin_define
define|#
directive|define
name|KludgeOutputLine
parameter_list|(
name|arg
parameter_list|)
end_define

begin_define
define|#
directive|define
name|KludgeResetRule
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|unsigned
name|char
name|boolean
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_CPP
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|USE_CC_E
end_ifdef

begin_define
define|#
directive|define
name|DEFAULT_CPP
value|"/bin/cc"
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|CPP_PROGRAM
end_ifdef

begin_define
define|#
directive|define
name|DEFAULT_CPP
value|CPP_PROGRAM
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEFAULT_CPP
value|"/lib/cpp"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|cpp
init|=
name|DEFAULT_CPP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tmpMakefile
init|=
literal|"/tmp/Imf.XXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tmpImakefile
init|=
literal|"/tmp/IIf.XXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|make_argv
index|[
name|ARGUMENTS
index|]
init|=
block|{
literal|"make"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|make_argindex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cpp_argindex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|make
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Imakefile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Makefile
init|=
literal|"Makefile"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Template
init|=
literal|"Imake.tmpl"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|program
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|FindImakefile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|ReadLine
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|CleanCppInput
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|Strdup
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_function_decl
name|char
modifier|*
name|Emalloc
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|Emalloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|boolean
name|verbose
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|show
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|FILE
modifier|*
name|tmpfd
decl_stmt|;
name|char
name|makeMacro
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|makefileMacro
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|program
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
name|SetOpts
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_CC_E
name|AddCppArg
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Imakefile
operator|=
name|FindImakefile
argument_list|(
name|Imakefile
argument_list|)
expr_stmt|;
if|if
condition|(
name|Makefile
condition|)
name|tmpMakefile
operator|=
name|Makefile
expr_stmt|;
else|else
block|{
name|tmpMakefile
operator|=
name|Strdup
argument_list|(
name|tmpMakefile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|tmpMakefile
argument_list|)
expr_stmt|;
block|}
name|AddMakeArg
argument_list|(
literal|"-f"
argument_list|)
expr_stmt|;
name|AddMakeArg
argument_list|(
name|tmpMakefile
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|makeMacro
argument_list|,
literal|"MAKE=%s"
argument_list|,
name|program
argument_list|)
expr_stmt|;
name|AddMakeArg
argument_list|(
name|makeMacro
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|makefileMacro
argument_list|,
literal|"MAKEFILE=%s"
argument_list|,
name|Imakefile
argument_list|)
expr_stmt|;
name|AddMakeArg
argument_list|(
name|makefileMacro
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpfd
operator|=
name|fopen
argument_list|(
name|tmpMakefile
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|LogFatal
argument_list|(
literal|"Cannot create temporary file %s."
argument_list|,
name|tmpMakefile
argument_list|)
expr_stmt|;
name|cppit
argument_list|(
name|Imakefile
argument_list|,
name|Template
argument_list|,
name|tmpfd
argument_list|,
name|tmpMakefile
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
condition|)
block|{
if|if
condition|(
name|Makefile
operator|==
name|NULL
condition|)
name|showit
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
block|}
else|else
name|makeit
argument_list|()
expr_stmt|;
name|wrapup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|showit
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|red
decl_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|red
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|BUFSIZ
argument_list|,
name|fd
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|fwrite
argument_list|(
name|buf
argument_list|,
name|red
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|red
operator|<
literal|0
condition|)
name|LogFatal
argument_list|(
literal|"Cannot write stdout."
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|wrapup
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|tmpMakefile
operator|!=
name|Makefile
condition|)
name|unlink
argument_list|(
name|tmpMakefile
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpImakefile
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|SIGNALRETURNSINT
end_ifdef

begin_function
name|int
else|#
directive|else
name|void
endif|#
directive|endif
name|catch
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|LogFatalI
argument_list|(
literal|"Signal %d."
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize some variables.  */
end_comment

begin_macro
name|init
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|make_argindex
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|make_argv
index|[
name|make_argindex
index|]
operator|!=
name|NULL
condition|)
name|make_argindex
operator|++
expr_stmt|;
name|cpp_argindex
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cpp_argv
index|[
name|cpp_argindex
index|]
operator|!=
name|NULL
condition|)
name|cpp_argindex
operator|++
expr_stmt|;
comment|/* 	 * See if the standard include directory is different than 	 * the default.  Or if cpp is not the default.  Or if the make 	 * found by the PATH variable is not the default. 	 */
if|if
condition|(
name|p
operator|=
name|getenv
argument_list|(
literal|"IMAKEINCLUDE"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'-'
operator|||
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|!=
literal|'I'
condition|)
name|LogFatal
argument_list|(
literal|"Environment var IMAKEINCLUDE %s\n"
argument_list|,
literal|"must begin with -I"
argument_list|)
expr_stmt|;
name|AddCppArg
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|AddCppArg
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|=
name|getenv
argument_list|(
literal|"IMAKECPP"
argument_list|)
condition|)
name|cpp
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|getenv
argument_list|(
literal|"IMAKEMAKE"
argument_list|)
condition|)
name|make
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|catch
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|AddMakeArg
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|make_argindex
operator|>=
name|ARGUMENTS
operator|-
literal|1
condition|)
name|LogFatal
argument_list|(
literal|"Out of internal storage."
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|make_argv
index|[
name|make_argindex
operator|++
index|]
operator|=
name|arg
expr_stmt|;
name|make_argv
index|[
name|make_argindex
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_macro
name|AddCppArg
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cpp_argindex
operator|>=
name|ARGUMENTS
operator|-
literal|1
condition|)
name|LogFatal
argument_list|(
literal|"Out of internal storage."
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|cpp_argv
index|[
name|cpp_argindex
operator|++
index|]
operator|=
name|arg
expr_stmt|;
name|cpp_argv
index|[
name|cpp_argindex
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_macro
name|SetOpts
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Now gather the arguments for make 	 */
for|for
control|(
name|argc
operator|--
operator|,
name|argv
operator|++
init|;
name|argc
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
comment|/* 	     * We intercept these flags. 	     */
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'D'
condition|)
block|{
name|AddCppArg
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'I'
condition|)
block|{
name|AddCppArg
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'f'
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|)
name|Imakefile
operator|=
name|argv
index|[
literal|0
index|]
operator|+
literal|2
expr_stmt|;
else|else
block|{
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|argc
condition|)
name|LogFatal
argument_list|(
literal|"No description arg after -f flag\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|Imakefile
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|)
name|Makefile
operator|=
operator|(
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|==
literal|'-'
operator|)
operator|&&
operator|!
name|argv
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|)
condition|?
name|NULL
else|:
name|argv
index|[
literal|0
index|]
operator|+
literal|2
expr_stmt|;
else|else
block|{
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|argc
condition|)
name|LogFatal
argument_list|(
literal|"No description arg after -s flag\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|Makefile
operator|=
operator|(
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|&&
operator|!
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|)
condition|?
name|NULL
else|:
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
name|show
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'e'
condition|)
block|{
name|Makefile
operator|=
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|?
name|argv
index|[
literal|0
index|]
operator|+
literal|2
else|:
name|NULL
operator|)
expr_stmt|;
name|show
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'T'
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|)
name|Template
operator|=
name|argv
index|[
literal|0
index|]
operator|+
literal|2
expr_stmt|;
else|else
block|{
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|argc
condition|)
name|LogFatal
argument_list|(
literal|"No description arg after -T flag\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|Template
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'v'
condition|)
block|{
name|verbose
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|AddMakeArg
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|AddMakeArg
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|FindImakefile
parameter_list|(
name|Imakefile
parameter_list|)
name|char
modifier|*
name|Imakefile
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|Imakefile
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|Imakefile
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|LogFatal
argument_list|(
literal|"Cannot open %s."
argument_list|,
name|Imakefile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
literal|"Imakefile"
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
literal|"imakefile"
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|LogFatal
argument_list|(
literal|"No description file."
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|Imakefile
operator|=
literal|"imakefile"
expr_stmt|;
else|else
name|Imakefile
operator|=
literal|"Imakefile"
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|Imakefile
operator|)
return|;
block|}
end_function

begin_macro
name|LogFatalI
argument_list|(
argument|s
argument_list|,
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*NOSTRICT*/
name|LogFatal
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|LogFatal
argument_list|(
argument|x0
argument_list|,
argument|x1
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|x0
decl_stmt|,
modifier|*
name|x1
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
specifier|static
name|boolean
name|entered
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|entered
condition|)
return|return;
name|entered
operator|=
name|TRUE
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|x0
argument_list|,
name|x1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Stop.\n"
argument_list|)
expr_stmt|;
name|wrapup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|showargs
argument_list|(
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
for|for
control|(
init|;
operator|*
name|argv
condition|;
name|argv
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cppit
argument_list|(
argument|Imakefile
argument_list|,
argument|template
argument_list|,
argument|outfd
argument_list|,
argument|outfname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|Imakefile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|template
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|outfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|outfname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|pipeFile
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|pipefd
index|[
literal|2
index|]
decl_stmt|;
name|waitType
name|status
decl_stmt|;
name|char
modifier|*
name|cleanedImakefile
decl_stmt|;
comment|/* 	 * Get a pipe. 	 */
if|if
condition|(
name|pipe
argument_list|(
name|pipefd
argument_list|)
operator|<
literal|0
condition|)
name|LogFatal
argument_list|(
literal|"Cannot make a pipe."
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Fork and exec cpp 	 */
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|LogFatal
argument_list|(
literal|"Cannot fork."
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
condition|)
block|{
comment|/* parent */
name|close
argument_list|(
name|pipefd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cleanedImakefile
operator|=
name|CleanCppInput
argument_list|(
name|Imakefile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pipeFile
operator|=
name|fdopen
argument_list|(
name|pipefd
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|LogFatalI
argument_list|(
literal|"Cannot fdopen fd %d for output."
argument_list|,
name|pipefd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pipeFile
argument_list|,
literal|"#define IMAKE_TEMPLATE\t\"%s\"\n"
argument_list|,
name|template
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pipeFile
argument_list|,
literal|"#define INCLUDE_IMAKEFILE\t<%s>\n"
argument_list|,
name|cleanedImakefile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pipeFile
argument_list|,
literal|"#include IMAKE_TEMPLATE\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|pipeFile
argument_list|)
expr_stmt|;
while|while
condition|(
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|>
literal|0
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
name|LogFatalI
argument_list|(
literal|"Signal %d."
argument_list|,
name|waitSig
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|&&
name|waitCode
argument_list|(
name|status
argument_list|)
condition|)
name|LogFatalI
argument_list|(
literal|"Exit code %d."
argument_list|,
name|waitCode
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CleanCppOutput
argument_list|(
name|outfd
argument_list|,
name|outfname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* child... dup and exec cpp */
if|if
condition|(
name|verbose
condition|)
name|showargs
argument_list|(
name|cpp_argv
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|pipefd
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|fileno
argument_list|(
name|outfd
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipefd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|cpp
argument_list|,
name|cpp_argv
argument_list|)
expr_stmt|;
name|LogFatal
argument_list|(
literal|"Cannot exec %s."
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|makeit
argument_list|()
end_macro

begin_block
block|{
name|int
name|pid
decl_stmt|;
name|waitType
name|status
decl_stmt|;
comment|/* 	 * Fork and exec make 	 */
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|LogFatal
argument_list|(
literal|"Cannot fork."
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
condition|)
block|{
comment|/* parent... simply wait */
while|while
condition|(
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|>
literal|0
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
name|LogFatalI
argument_list|(
literal|"Signal %d."
argument_list|,
name|waitSig
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|&&
name|waitCode
argument_list|(
name|status
argument_list|)
condition|)
name|LogFatalI
argument_list|(
literal|"Exit code %d."
argument_list|,
name|waitCode
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* child... dup and exec cpp */
if|if
condition|(
name|verbose
condition|)
name|showargs
argument_list|(
name|make_argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|make
condition|)
name|execv
argument_list|(
name|make
argument_list|,
name|make_argv
argument_list|)
expr_stmt|;
else|else
name|execvp
argument_list|(
literal|"make"
argument_list|,
name|make_argv
argument_list|)
expr_stmt|;
name|LogFatal
argument_list|(
literal|"Cannot exec %s."
argument_list|,
name|make
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|CleanCppInput
parameter_list|(
name|Imakefile
parameter_list|)
name|char
modifier|*
name|Imakefile
decl_stmt|;
block|{
name|FILE
modifier|*
name|outFile
init|=
name|NULL
decl_stmt|;
name|int
name|infd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
comment|/* buffer for file content */
modifier|*
name|pbuf
decl_stmt|,
comment|/* walking pointer to buf */
modifier|*
name|punwritten
decl_stmt|,
comment|/* pointer to unwritten portion of buf */
modifier|*
name|cleanedImakefile
init|=
name|Imakefile
decl_stmt|,
comment|/* return value */
modifier|*
name|ptoken
decl_stmt|,
comment|/* pointer to # token */
modifier|*
name|pend
decl_stmt|,
comment|/* pointer to end of # token */
name|savec
decl_stmt|;
comment|/* temporary character holder */
name|struct
name|stat
name|st
decl_stmt|;
comment|/* 	 * grab the entire file. 	 */
if|if
condition|(
operator|(
name|infd
operator|=
name|open
argument_list|(
name|Imakefile
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|LogFatal
argument_list|(
literal|"Cannot open %s for input."
argument_list|,
name|Imakefile
argument_list|)
expr_stmt|;
name|fstat
argument_list|(
name|infd
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|buf
operator|=
name|Emalloc
argument_list|(
name|st
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|infd
argument_list|,
name|buf
argument_list|,
name|st
operator|.
name|st_size
argument_list|)
operator|!=
name|st
operator|.
name|st_size
condition|)
name|LogFatal
argument_list|(
literal|"Cannot read all of %s:"
argument_list|,
name|Imakefile
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|infd
argument_list|)
expr_stmt|;
name|buf
index|[
name|st
operator|.
name|st_size
index|]
operator|=
literal|'\0'
expr_stmt|;
name|punwritten
operator|=
name|pbuf
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|pbuf
condition|)
block|{
comment|/* pad make comments for cpp */
if|if
condition|(
operator|*
name|pbuf
operator|==
literal|'#'
operator|&&
operator|(
name|pbuf
operator|==
name|buf
operator|||
name|pbuf
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|ptoken
operator|=
name|pbuf
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|ptoken
operator|==
literal|' '
operator|||
operator|*
name|ptoken
operator|==
literal|'\t'
condition|)
name|ptoken
operator|++
expr_stmt|;
name|pend
operator|=
name|ptoken
expr_stmt|;
while|while
condition|(
operator|*
name|pend
operator|&&
operator|*
name|pend
operator|!=
literal|' '
operator|&&
operator|*
name|pend
operator|!=
literal|'\t'
operator|&&
operator|*
name|pend
operator|!=
literal|'\n'
condition|)
name|pend
operator|++
expr_stmt|;
name|savec
operator|=
operator|*
name|pend
expr_stmt|;
operator|*
name|pend
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ptoken
argument_list|,
literal|"include"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|ptoken
argument_list|,
literal|"define"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|ptoken
argument_list|,
literal|"undef"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|ptoken
argument_list|,
literal|"ifdef"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|ptoken
argument_list|,
literal|"ifndef"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|ptoken
argument_list|,
literal|"else"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|ptoken
argument_list|,
literal|"endif"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|ptoken
argument_list|,
literal|"if"
argument_list|)
condition|)
block|{
if|if
condition|(
name|outFile
operator|==
name|NULL
condition|)
block|{
name|tmpImakefile
operator|=
name|Strdup
argument_list|(
name|tmpImakefile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|tmpImakefile
argument_list|)
expr_stmt|;
name|cleanedImakefile
operator|=
name|tmpImakefile
expr_stmt|;
name|outFile
operator|=
name|fopen
argument_list|(
name|tmpImakefile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outFile
operator|==
name|NULL
condition|)
name|LogFatal
argument_list|(
literal|"Cannot open %s for write.\n"
argument_list|,
name|tmpImakefile
argument_list|)
expr_stmt|;
block|}
name|fwrite
argument_list|(
name|punwritten
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|pbuf
operator|-
name|punwritten
argument_list|,
name|outFile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"/**/"
argument_list|,
name|outFile
argument_list|)
expr_stmt|;
name|punwritten
operator|=
name|pbuf
expr_stmt|;
block|}
operator|*
name|pend
operator|=
name|savec
expr_stmt|;
block|}
name|pbuf
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|outFile
condition|)
block|{
name|fwrite
argument_list|(
name|punwritten
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|pbuf
operator|-
name|punwritten
argument_list|,
name|outFile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|outFile
argument_list|)
expr_stmt|;
comment|/* also closes the pipe */
block|}
return|return
operator|(
name|cleanedImakefile
operator|)
return|;
block|}
end_function

begin_macro
name|CleanCppOutput
argument_list|(
argument|tmpfd
argument_list|,
argument|tmpfname
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|tmpfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tmpfname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|input
decl_stmt|;
name|int
name|blankline
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|input
operator|=
name|ReadLine
argument_list|(
name|tmpfd
argument_list|,
name|tmpfname
argument_list|)
condition|)
block|{
if|if
condition|(
name|isempty
argument_list|(
name|input
argument_list|)
condition|)
block|{
if|if
condition|(
name|blankline
operator|++
condition|)
continue|continue;
name|KludgeResetRule
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|blankline
operator|=
literal|0
expr_stmt|;
name|KludgeOutputLine
argument_list|(
operator|&
name|input
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|input
argument_list|,
name|tmpfd
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|tmpfd
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NFS_STDOUT_BUG
comment|/* 	 * On some systems, NFS seems to leave a large number of nulls at 	 * the end of the file.  Ralph Swick says that this kludge makes the 	 * problem go away. 	 */
name|ftruncate
argument_list|(
name|fileno
argument_list|(
name|tmpfd
argument_list|)
argument_list|,
operator|(
name|off_t
operator|)
name|ftell
argument_list|(
name|tmpfd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Determine of a line has nothing in it.  As a side effect, we trim white  * space from the end of the line.  Cpp magic cookies are also thrown away.  */
end_comment

begin_macro
name|isempty
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|pend
decl_stmt|;
comment|/* 	 * Check for lines of the form 	 *	# n "... 	 * or 	 *	# line n "... 	 */
if|if
condition|(
operator|*
name|line
operator|==
literal|'#'
condition|)
block|{
name|pend
operator|=
name|line
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|pend
operator|==
literal|' '
condition|)
name|pend
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|pend
argument_list|,
literal|"line "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|pend
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|pend
argument_list|)
condition|)
block|{
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|pend
argument_list|)
condition|)
name|pend
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pend
operator|++
operator|==
literal|' '
operator|&&
operator|*
name|pend
operator|==
literal|'"'
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
comment|/* 	 * Find the end of the line and then walk back. 	 */
for|for
control|(
name|pend
operator|=
name|line
init|;
operator|*
name|pend
condition|;
name|pend
operator|++
control|)
empty_stmt|;
name|pend
operator|--
expr_stmt|;
while|while
condition|(
name|pend
operator|>=
name|line
operator|&&
operator|(
operator|*
name|pend
operator|==
literal|' '
operator|||
operator|*
name|pend
operator|==
literal|'\t'
operator|)
condition|)
name|pend
operator|--
expr_stmt|;
operator|*
operator|++
name|pend
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
operator|*
name|line
operator|==
literal|'\0'
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|char
modifier|*
name|ReadLine
parameter_list|(
name|tmpfd
parameter_list|,
name|tmpfname
parameter_list|)
name|FILE
modifier|*
name|tmpfd
decl_stmt|;
name|char
modifier|*
name|tmpfname
decl_stmt|;
block|{
specifier|static
name|boolean
name|initialized
init|=
name|FALSE
decl_stmt|;
specifier|static
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|pline
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|int
name|total_red
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
comment|/* 		 * Slurp it all up. 		 */
name|fseek
argument_list|(
name|tmpfd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fstat
argument_list|(
name|fileno
argument_list|(
name|tmpfd
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|pline
operator|=
name|buf
operator|=
name|Emalloc
argument_list|(
name|st
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|total_red
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|tmpfd
argument_list|)
argument_list|,
name|buf
argument_list|,
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_red
operator|!=
name|st
operator|.
name|st_size
condition|)
name|LogFatal
argument_list|(
literal|"cannot read %s\n"
argument_list|,
name|tmpMakefile
argument_list|)
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|st
operator|.
name|st_size
expr_stmt|;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
name|lseek
argument_list|(
name|fileno
argument_list|(
name|tmpfd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSV
name|freopen
argument_list|(
name|tmpfname
argument_list|,
literal|"w+"
argument_list|,
name|tmpfd
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !SYSV */
name|ftruncate
argument_list|(
name|fileno
argument_list|(
name|tmpfd
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SYSV */
name|initialized
operator|=
name|TRUE
expr_stmt|;
name|fprintf
argument_list|(
name|tmpfd
argument_list|,
literal|"# Makefile generated by imake - do not edit!\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tmpfd
argument_list|,
literal|"# %s\n"
argument_list|,
literal|"$XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FIXUP_CPP_WHITESPACE
block|{
specifier|static
name|char
modifier|*
name|cpp_warning
index|[]
init|=
block|{
literal|"#"
block|,
literal|"# The cpp used on this machine replaces all newlines and multiple tabs and"
block|,
literal|"# spaces in a macro expansion with a single space.  Imake tries to compensate"
block|,
literal|"# for this, but is not always successful."
block|,
literal|"#"
block|,
name|NULL
block|}
decl_stmt|;
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|;
for|for
control|(
name|cpp
operator|=
name|cpp_warning
init|;
operator|*
name|cpp
condition|;
name|cpp
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|tmpfd
argument_list|,
literal|"%s\n"
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* FIXUP_CPP_WHITESPACE */
block|}
for|for
control|(
name|p1
operator|=
name|pline
init|;
name|p1
operator|<
name|end
condition|;
name|p1
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p1
operator|==
literal|'@'
operator|&&
operator|*
operator|(
name|p1
operator|+
literal|1
operator|)
operator|==
literal|'@'
condition|)
block|{
comment|/* soft EOL */
operator|*
name|p1
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|p1
operator|++
expr_stmt|;
comment|/* skip over second @ */
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|p1
operator|==
literal|'\n'
condition|)
block|{
comment|/* real EOL */
operator|*
name|p1
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * return NULL at the end of the file. 	 */
name|p2
operator|=
operator|(
name|pline
operator|==
name|p1
condition|?
name|NULL
else|:
name|pline
operator|)
expr_stmt|;
name|pline
operator|=
name|p1
expr_stmt|;
return|return
operator|(
name|p2
operator|)
return|;
block|}
end_function

begin_macro
name|writetmpfile
argument_list|(
argument|fd
argument_list|,
argument|buf
argument_list|,
argument|cnt
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
name|cnt
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
operator|!=
literal|1
condition|)
name|LogFatal
argument_list|(
literal|"Cannot write to %s."
argument_list|,
name|tmpMakefile
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|Emalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|LogFatalI
argument_list|(
literal|"Cannot allocate %d bytes\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FIXUP_CPP_WHITESPACE
end_ifdef

begin_macro
name|KludgeOutputLine
argument_list|(
argument|pline
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|pline
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|pline
decl_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'#'
case|:
comment|/*Comment - ignore*/
break|break;
case|case
literal|'\t'
case|:
comment|/*Already tabbed - ignore it*/
break|break;
case|case
literal|' '
case|:
comment|/*May need a tab*/
default|default:
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|&&
name|p
operator|>
operator|*
name|pline
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|pline
operator|==
literal|' '
condition|)
operator|(
operator|*
name|pline
operator|)
operator|++
expr_stmt|;
name|InRule
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|InRule
operator|&&
operator|*
operator|*
name|pline
operator|==
literal|' '
condition|)
operator|*
operator|*
name|pline
operator|=
literal|'\t'
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_macro
name|KludgeResetRule
argument_list|()
end_macro

begin_block
block|{
name|InRule
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FIXUP_CPP_WHITESPACE */
end_comment

begin_function
name|char
modifier|*
name|Strdup
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|new
init|=
name|Emalloc
argument_list|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|new
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

end_unit

