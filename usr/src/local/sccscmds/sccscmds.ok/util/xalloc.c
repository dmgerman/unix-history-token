begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"../hdr/macros.h"
end_include

begin_expr_stmt
name|SCCSID
argument_list|(
argument|@
operator|(
operator|#
operator|)
name|xalloc
literal|2.1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	xalloc/xfree based on alloc/free in C library at one time. 	Also xfreeall() frees all memory allocated (calls brk(II)).   	Xfree always coalesces contiguous free blocks. 	Xalloc uses a first fit strategy. 	Xalloc always allocates words (rounds up). 	Xalloc actually allocates one more word than the 	amount requested.  The extra word (the first word of the 	allocated block) contains the size (in bytes) of the entire block. 	This size is used by xfree to identify contiguous blocks, 	and is used by xalloc to implement the first fit strategy.   	Bad things will happen if the size word is changed. 	Worse things happen if xfree is called with a 	garbage argument.   	Xalloc returns the address of the allocated area on success, 	fatal() on failure. 	Xfree and xfreeall don't return anything. */
end_comment

begin_struct
struct|struct
name|fb
block|{
name|unsigned
name|f_size
decl_stmt|;
name|char
modifier|*
name|f_next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|fb
name|Freelist
block|{
literal|0
operator|,
literal|0x3FFFFFFF
operator|,
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SLOP
value|(sizeof(int *))
end_define

begin_extern
extern|extern	end;
end_extern

begin_decl_stmt
name|unsigned
name|Lastbrk
modifier|&
name|end
decl_stmt|;
end_decl_stmt

begin_macro
name|xalloc
argument_list|(
argument|asize
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|asize
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|usize
decl_stmt|;
specifier|register
name|struct
name|fb
modifier|*
name|np
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|usize
operator|=
name|asize
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|usize
operator|=
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
operator|-
literal|1
expr_stmt|;
name|usize
operator|=
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cp
operator|=
operator|&
name|Freelist
expr_stmt|;
while|while
condition|(
operator|(
name|np
operator|=
name|cp
operator|->
name|f_next
operator|)
operator|!=
literal|0x3FFFFFFF
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|f_size
operator|>=
name|usize
condition|)
block|{
comment|/* 				Don't break the block up if it 				is not more than SLOP bigger than the 				amount needed. 			*/
if|if
condition|(
name|usize
operator|+
name|SLOP
operator|>=
name|np
operator|->
name|f_size
condition|)
name|cp
operator|->
name|f_next
operator|=
name|np
operator|->
name|f_next
expr_stmt|;
comment|/* 				Break the block into 2 pieces. 			*/
else|else
block|{
name|cp
operator|=
name|cp
operator|->
name|f_next
operator|=
operator|(
operator|(
name|int
operator|)
name|np
operator|)
operator|+
name|usize
expr_stmt|;
name|cp
operator|->
name|f_size
operator|=
name|np
operator|->
name|f_size
operator|-
name|usize
expr_stmt|;
name|cp
operator|->
name|f_next
operator|=
name|np
operator|->
name|f_next
expr_stmt|;
name|np
operator|->
name|f_size
operator|=
name|usize
expr_stmt|;
block|}
name|zero
argument_list|(
operator|&
name|np
operator|->
name|f_next
argument_list|,
name|usize
operator|-
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|np
operator|->
name|f_next
operator|)
return|;
block|}
name|cp
operator|=
name|np
expr_stmt|;
block|}
comment|/* 		Nothing on the free list is big enough; 		get more core from the operating system. 	*/
name|asize
operator|=
name|usize
operator|<
literal|1024
condition|?
literal|1024
else|:
name|usize
expr_stmt|;
name|asize
operator|=
operator|(
name|asize
operator|+
literal|511
operator|)
operator|&
operator|(
operator|~
literal|511
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|sbrk
argument_list|(
name|asize
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|fatal
argument_list|(
literal|"out of space (ut9)"
argument_list|)
operator|)
return|;
block|}
name|Lastbrk
operator|=
operator|(
operator|(
name|int
operator|)
name|cp
operator|)
operator|+
name|asize
expr_stmt|;
name|cp
operator|->
name|f_size
operator|=
name|asize
expr_stmt|;
comment|/* 		Add the new piece to the free list. 	*/
name|xfree
argument_list|(
operator|&
name|cp
operator|->
name|f_next
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|xfree
argument_list|(
argument|aptr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|aptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|fb
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
if|if
condition|(
name|aptr
operator|&&
name|aptr
operator|<
name|Lastbrk
condition|)
block|{
name|ptr
operator|=
name|aptr
operator|-
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|Freelist
expr_stmt|;
while|while
condition|(
operator|(
name|np
operator|=
name|cp
operator|->
name|f_next
operator|)
operator|<
name|ptr
condition|)
name|cp
operator|=
name|np
expr_stmt|;
comment|/* 		Try to coalesce with the following block. 	*/
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|ptr
operator|)
operator|+
name|ptr
operator|->
name|f_size
operator|==
operator|(
operator|(
name|int
operator|)
name|np
operator|)
condition|)
block|{
name|ptr
operator|->
name|f_size
operator|=
operator|+
name|np
operator|->
name|f_size
expr_stmt|;
name|ptr
operator|->
name|f_next
operator|=
name|np
operator|->
name|f_next
expr_stmt|;
name|np
operator|=
name|ptr
expr_stmt|;
block|}
else|else
name|ptr
operator|->
name|f_next
operator|=
name|np
expr_stmt|;
comment|/* 		Try to coalesce with the preceding block. 	*/
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|cp
operator|)
operator|+
name|cp
operator|->
name|f_size
operator|==
operator|(
operator|(
name|int
operator|)
name|ptr
operator|)
condition|)
block|{
name|cp
operator|->
name|f_size
operator|=
operator|+
name|ptr
operator|->
name|f_size
expr_stmt|;
name|cp
operator|->
name|f_next
operator|=
name|ptr
operator|->
name|f_next
expr_stmt|;
block|}
else|else
name|cp
operator|->
name|f_next
operator|=
name|ptr
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|xfreeall
argument_list|()
end_macro

begin_block
block|{
name|brk
argument_list|(
operator|&
name|end
argument_list|)
expr_stmt|;
name|Lastbrk
operator|=
operator|&
name|end
expr_stmt|;
name|Freelist
operator|.
name|f_size
operator|=
literal|0
expr_stmt|;
name|Freelist
operator|.
name|f_next
operator|=
literal|0x3FFFFFFF
expr_stmt|;
block|}
end_block

end_unit

