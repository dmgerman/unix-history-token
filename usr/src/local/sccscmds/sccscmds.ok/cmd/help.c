begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"../hdr/defines.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|Sccsid
index|[]
init|=
literal|"@(#)help.c	4.4	%G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	Program to locate helpful info in an ascii file. 	The program accepts a variable number of arguments.  	The file to be searched is determined from the argument. If the 	argument does not contain numerics, the search 	will be attempted on '/usr/local/lib/help/cmds', with the search key 	being the whole argument. 	If the argument begins with non-numerics but contains 	numerics (e.g, zz32) the search will be attempted on 	'/usr/local/lib/help/<non-numeric prefix>', (e.g,/usr/lib/help/zz), 	with the search key being<remainder of arg>, (e.g., 32). 	If the argument is all numeric, or if the file as 	determined above does not exist, the search will be attempted on 	_PATH_OLDHELP, which is the old help file, with the 	search key being the entire argument. 	In no case will more than one search per argument be performed.  	File is formatted as follows:  		* comment 		* comment 		-str1 		text 		-str2 		text 		* comment 		text 		-str3 		text  	The "str?" that matches the key is found and 	the following text lines are printed. 	Comments are ignored.  	If the argument is omitted, the program requests it. */
end_comment

begin_decl_stmt
name|char
name|hfile
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|iop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|line
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|int
name|Fcnt
decl_stmt|;
comment|/* 	Tell 'fatal' to issue messages, clean up, and return to its caller. 	*/
name|Fflags
operator|=
name|FTLMSG
operator||
name|FTLCLN
operator||
name|FTLJMP
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|findprt
argument_list|(
name|ask
argument_list|()
argument_list|)
expr_stmt|;
comment|/* ask user for argument */
else|else
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|findprt
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|Fcnt
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|findprt
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
name|key
index|[
literal|50
index|]
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Fjmp
argument_list|)
condition|)
comment|/* set up to return here from */
return|return;
comment|/* 'fatal' and return to 'main' */
if|if
condition|(
name|size
argument_list|(
name|p
argument_list|)
operator|>
literal|50
condition|)
name|fatal
argument_list|(
literal|"argument too long (he2)"
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|&&
operator|!
name|numeric
argument_list|(
operator|*
name|q
argument_list|)
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
block|{
comment|/* all alphabetics */
name|copy
argument_list|(
name|p
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|cat
argument_list|(
name|hfile
argument_list|,
name|_PATH_HELPDIR
argument_list|,
literal|"cmds"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exists
argument_list|(
name|hfile
argument_list|)
condition|)
name|copy
argument_list|(
name|_PATH_OLDHELP
argument_list|,
name|hfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|==
name|p
condition|)
block|{
comment|/* first char numeric */
name|copy
argument_list|(
name|p
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|_PATH_OLDHELP
argument_list|,
name|hfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* first char alpha, then numeric */
name|copy
argument_list|(
name|p
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/* key used as temporary */
operator|*
operator|(
name|key
operator|+
operator|(
name|q
operator|-
name|p
operator|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|cat
argument_list|(
name|hfile
argument_list|,
name|_PATH_HELPDIR
argument_list|,
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|q
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exists
argument_list|(
name|hfile
argument_list|)
condition|)
block|{
name|copy
argument_list|(
name|p
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|_PATH_OLDHELP
argument_list|,
name|hfile
argument_list|)
expr_stmt|;
block|}
block|}
name|iop
operator|=
name|xfopen
argument_list|(
name|hfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	Now read file, looking for key. 	*/
while|while
condition|(
operator|(
name|q
operator|=
name|fgets
argument_list|(
name|line
argument_list|,
literal|512
argument_list|,
name|iop
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|repl
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* replace newline char */
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|equal
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
name|key
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
comment|/* endfile? */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"%s not found (he1)"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|Error
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n%s:\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
literal|512
argument_list|,
name|iop
argument_list|)
operator|!=
name|NULL
operator|&&
name|line
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
empty_stmt|;
do|do
block|{
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'*'
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
literal|512
argument_list|,
name|iop
argument_list|)
operator|!=
name|NULL
operator|&&
name|line
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
do|;
name|fclose
argument_list|(
name|iop
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ask
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|char
name|resp
index|[
literal|51
index|]
decl_stmt|;
name|iop
operator|=
name|stdin
expr_stmt|;
name|printf
argument_list|(
literal|"msg number or comd name? "
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|resp
argument_list|,
literal|51
argument_list|,
name|iop
argument_list|)
expr_stmt|;
return|return
operator|(
name|repl
argument_list|(
name|resp
argument_list|,
literal|'\n'
argument_list|,
literal|'\0'
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|clean_up
argument_list|()
end_macro

begin_block
block|{
name|fclose
argument_list|(
name|iop
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

