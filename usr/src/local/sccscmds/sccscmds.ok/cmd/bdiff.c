begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"../hdr/defines.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|Sccsid
index|[]
init|=
literal|"@(#)bdiff.c	4.3	%G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	This program segments two files into pieces of<= seglim lines 	(which is passed as a third argument or defaulted to some number) 	and then executes diff upon the pieces. The output of 	'diff' is then processed to make it look as if 'diff' had 	processed the files whole. The reason for all this is that seglim 	is a reasonable upper limit on the size of files that diff can 	process. 	NOTE -- by segmenting the files in this manner, it cannot be 	guaranteed that the 'diffing' of the segments will generate 	a minimal set of differences. 	This process is most definitely not equivalent to 'diffing' 	the files whole, assuming 'diff' could handle such large files.  	'diff' is executed by a child process, generated by forking, 	and communicates with this program through pipes. */
end_comment

begin_decl_stmt
name|int
name|seglim
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* limit of size of file segment to be generated */
end_comment

begin_decl_stmt
name|char
name|diff
index|[]
init|=
literal|"/bin/diff"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|tempskel
index|[]
init|=
literal|"/tmp/bdXXXXX"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to generate temp file names */
end_comment

begin_decl_stmt
name|char
name|tempfile
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|otmp
index|[
literal|32
index|]
decl_stmt|,
name|ntmp
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linenum
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|poldfile
decl_stmt|,
modifier|*
name|pnewfile
decl_stmt|,
modifier|*
name|tptr
decl_stmt|;
name|char
name|oline
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|nline
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|diffline
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|olp
decl_stmt|,
modifier|*
name|nlp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|otcnt
decl_stmt|,
name|ntcnt
decl_stmt|;
name|int
name|pfd
index|[
literal|2
index|]
decl_stmt|;
name|FILE
modifier|*
name|poldtemp
decl_stmt|,
modifier|*
name|pnewtemp
decl_stmt|,
modifier|*
name|pipeinp
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* 	Set flags for 'fatal' so that it will clean up, 	produce a message, and terminate. 	*/
name|Fflags
operator|=
name|FTLMSG
operator||
name|FTLCLN
operator||
name|FTLEXIT
expr_stmt|;
name|setsig
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
operator|||
name|argc
operator|>
literal|5
condition|)
name|fatal
argument_list|(
literal|"arg count (bd1)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|equal
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-"
argument_list|)
operator|&&
name|equal
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"-"
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"both files standard input (bd2)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|equal
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-"
argument_list|)
condition|)
name|poldfile
operator|=
name|stdin
expr_stmt|;
else|else
name|poldfile
operator|=
name|xfopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|equal
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"-"
argument_list|)
condition|)
name|pnewfile
operator|=
name|stdin
expr_stmt|;
else|else
name|pnewfile
operator|=
name|xfopen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seglim
operator|=
literal|3500
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|3
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
literal|3
index|]
index|[
literal|1
index|]
operator|==
literal|'s'
condition|)
name|Fflags
operator|&=
operator|~
name|FTLMSG
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|seglim
operator|=
name|patoi
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"non-numeric limit (bd4)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|5
operator|&&
name|argv
index|[
literal|4
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
literal|4
index|]
index|[
literal|1
index|]
operator|==
literal|'s'
condition|)
name|Fflags
operator|&=
operator|~
name|FTLMSG
expr_stmt|;
block|}
block|}
name|linenum
operator|=
literal|0
expr_stmt|;
comment|/* 	The following while-loop will prevent any lines 	common to the beginning of both files from being 	sent to 'diff'. Since the running time of 'diff' is 	non-linear, this will help improve performance. 	If, during this process, both files reach EOF, then 	the files are equal and the program will terminate. 	If either file reaches EOF before the other, the 	program will generate the appropriate 'diff' output 	itself, since this can be easily determined and will 	avoid executing 'diff' completely. 	*/
while|while
condition|(
literal|1
condition|)
block|{
name|olp
operator|=
name|fgets
argument_list|(
name|oline
argument_list|,
name|BUFSIZ
argument_list|,
name|poldfile
argument_list|)
expr_stmt|;
name|nlp
operator|=
name|fgets
argument_list|(
name|nline
argument_list|,
name|BUFSIZ
argument_list|,
name|pnewfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|olp
operator|&&
operator|!
name|nlp
condition|)
comment|/* files are equal */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|olp
condition|)
block|{
comment|/* 			The entire old file is a prefix of the 			new file. Generate the appropriate "append" 			'diff'-like output, which is of the form: 					nan,n 			where 'n' represents a line-number. 			*/
name|addgen
argument_list|(
name|nline
argument_list|,
name|pnewfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nlp
condition|)
block|{
comment|/* 			The entire new file is a prefix of the 			old file. Generate the appropriate "delete" 			'diff'-like output, which is of the form: 					n,ndn 			where 'n' represents a line-number. 			*/
name|delgen
argument_list|(
name|oline
argument_list|,
name|poldfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|equal
argument_list|(
name|olp
argument_list|,
name|nlp
argument_list|)
condition|)
name|linenum
operator|++
expr_stmt|;
else|else
break|break;
block|}
comment|/* 	Here, first 'linenum' lines are equal. 	The following while-loop segments both files into 	seglim segments, forks and executes 'diff' on the 	segments, and processes the resulting output of 	'diff', which is read from a pipe. 	*/
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 		If both files are at EOF, everything is done. 		*/
if|if
condition|(
operator|!
name|olp
operator|&&
operator|!
name|nlp
condition|)
comment|/* finished */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|olp
condition|)
block|{
comment|/* 			Generate appropriate "append" 			output without executing 'diff'. 			*/
name|addgen
argument_list|(
name|nline
argument_list|,
name|pnewfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nlp
condition|)
block|{
comment|/* 			Generate appropriate "delete" 			output without executing 'diff'. 			*/
name|delgen
argument_list|(
name|oline
argument_list|,
name|poldfile
argument_list|)
expr_stmt|;
block|}
comment|/* 		Create a temporary file to hold a segment 		from the old file, and write it. 		*/
name|poldtemp
operator|=
name|maket
argument_list|(
name|otmp
argument_list|)
expr_stmt|;
name|otcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|olp
operator|&&
name|otcnt
operator|<
name|seglim
condition|)
block|{
name|fputs
argument_list|(
name|oline
argument_list|,
name|poldtemp
argument_list|)
expr_stmt|;
name|olp
operator|=
name|fgets
argument_list|(
name|oline
argument_list|,
name|BUFSIZ
argument_list|,
name|poldfile
argument_list|)
expr_stmt|;
name|otcnt
operator|++
expr_stmt|;
block|}
name|fclose
argument_list|(
name|poldtemp
argument_list|)
expr_stmt|;
comment|/* 		Create a temporary file to hold a segment 		from the new file, and write it. 		*/
name|pnewtemp
operator|=
name|maket
argument_list|(
name|ntmp
argument_list|)
expr_stmt|;
name|ntcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nlp
operator|&&
name|ntcnt
operator|<
name|seglim
condition|)
block|{
name|fputs
argument_list|(
name|nline
argument_list|,
name|pnewtemp
argument_list|)
expr_stmt|;
name|nlp
operator|=
name|fgets
argument_list|(
name|nline
argument_list|,
name|BUFSIZ
argument_list|,
name|pnewfile
argument_list|)
expr_stmt|;
name|ntcnt
operator|++
expr_stmt|;
block|}
name|fclose
argument_list|(
name|pnewtemp
argument_list|)
expr_stmt|;
comment|/* 		Create pipes and fork. 		*/
name|xpipe
argument_list|(
name|pfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|pfd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pfd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"cannot fork, try again (bd3)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* child process */
name|close
argument_list|(
name|pfd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|pfd
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfd
index|[
literal|1
index|]
operator|!=
literal|1
condition|)
name|close
argument_list|(
name|pfd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 			Execute 'diff' on the segment files. 			*/
name|execl
argument_list|(
name|diff
argument_list|,
name|diff
argument_list|,
name|otmp
argument_list|,
name|ntmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"cannot execute '%s' (bd5)"
argument_list|,
name|diff
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* parent process */
name|close
argument_list|(
name|pfd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pipeinp
operator|=
name|fdopen
argument_list|(
name|pfd
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* 			Process 'diff' output. 			*/
while|while
condition|(
operator|(
name|dp
operator|=
name|fgets
argument_list|(
name|diffline
argument_list|,
name|BUFSIZ
argument_list|,
name|pipeinp
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|numeric
argument_list|(
operator|*
name|dp
argument_list|)
condition|)
name|fixnum
argument_list|(
name|diffline
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|diffline
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|pipeinp
argument_list|)
expr_stmt|;
comment|/* 			EOF on pipe. 			*/
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|~
literal|0x100
condition|)
name|fatal
argument_list|(
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"'%s' failed (bd6)"
argument_list|,
name|diff
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|linenum
operator|+=
name|seglim
expr_stmt|;
comment|/* 		Remove temporary files. 		*/
name|unlink
argument_list|(
name|otmp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|ntmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* 	Routine to save remainder of a file. */
end_comment

begin_macro
name|saverest
argument_list|(
argument|line
argument_list|,
argument|iptr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|iptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
name|FILE
modifier|*
name|temptr
decl_stmt|;
name|temptr
operator|=
name|maket
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
name|lp
operator|=
name|line
expr_stmt|;
while|while
condition|(
name|lp
condition|)
block|{
name|fputs
argument_list|(
name|line
argument_list|,
name|temptr
argument_list|)
expr_stmt|;
name|linenum
operator|++
expr_stmt|;
name|lp
operator|=
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|iptr
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|temptr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	Routine to write out data saved by 	'saverest' routine and to remove the file. */
end_comment

begin_macro
name|putsave
argument_list|(
argument|line
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|temptr
decl_stmt|;
name|temptr
operator|=
name|xfopen
argument_list|(
name|tempfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|temptr
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%c %s"
argument_list|,
name|type
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|temptr
argument_list|)
expr_stmt|;
name|xunlink
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fixnum
argument_list|(
argument|lp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|num
decl_stmt|;
while|while
condition|(
operator|*
name|lp
condition|)
block|{
switch|switch
condition|(
operator|*
name|lp
condition|)
block|{
case|case
literal|'a'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|','
case|:
case|case
literal|'\n'
case|:
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|*
name|lp
argument_list|)
expr_stmt|;
name|lp
operator|++
expr_stmt|;
break|break;
default|default:
name|lp
operator|=
name|satoi
argument_list|(
name|lp
argument_list|,
operator|&
name|num
argument_list|)
expr_stmt|;
name|num
operator|+=
name|linenum
expr_stmt|;
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|addgen
argument_list|(
argument|lp
argument_list|,
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"%da%d,"
argument_list|,
name|linenum
argument_list|,
name|linenum
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 	Save lines of new file. 	*/
name|saverest
argument_list|(
name|lp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
comment|/* 	Output saved lines, as 'diff' would. 	*/
name|putsave
argument_list|(
name|lp
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|delgen
argument_list|(
argument|lp
argument_list|,
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|savenum
decl_stmt|;
name|printf
argument_list|(
literal|"%d,"
argument_list|,
name|linenum
operator|+
literal|1
argument_list|)
expr_stmt|;
name|savenum
operator|=
name|linenum
expr_stmt|;
comment|/* 	Save lines of old file. 	*/
name|saverest
argument_list|(
name|lp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%dd%d\n"
argument_list|,
name|linenum
argument_list|,
name|savenum
argument_list|)
expr_stmt|;
comment|/* 	Output saved lines, as 'diff' would. 	*/
name|putsave
argument_list|(
name|lp
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|clean_up
argument_list|()
end_macro

begin_block
block|{
name|unlink
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|otmp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|ntmp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|maket
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|iop
decl_stmt|;
name|copy
argument_list|(
name|tempskel
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|iop
operator|=
name|xfcreat
argument_list|(
name|mktemp
argument_list|(
name|file
argument_list|)
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
return|return
operator|(
name|iop
operator|)
return|;
block|}
end_block

end_unit

