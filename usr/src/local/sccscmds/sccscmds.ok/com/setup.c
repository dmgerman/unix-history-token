begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"../hdr/defines.h"
end_include

begin_expr_stmt
name|SCCSID
argument_list|(
argument|@
operator|(
operator|#
operator|)
name|setup
literal|2.2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setup
argument_list|(
name|pkt
argument_list|,
name|serial
argument_list|)
specifier|register
expr|struct
name|packet
operator|*
name|pkt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|serial
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|struct
name|apply
modifier|*
name|rap
decl_stmt|;
name|int
name|first_app
literal|1
expr_stmt|;
name|pkt
operator|->
name|p_apply
index|[
name|serial
index|]
operator|.
name|a_inline
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|n
operator|=
name|maxser
argument_list|(
name|pkt
argument_list|)
init|;
name|n
condition|;
name|n
operator|--
control|)
block|{
name|rap
operator|=
operator|&
name|pkt
operator|->
name|p_apply
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|rap
operator|->
name|a_inline
condition|)
block|{
if|if
condition|(
name|n
operator|!=
literal|1
operator|&&
name|pkt
operator|->
name|p_idel
index|[
name|n
index|]
operator|.
name|i_pred
operator|==
literal|0
condition|)
name|fmterr
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|->
name|p_apply
index|[
name|pkt
operator|->
name|p_idel
index|[
name|n
index|]
operator|.
name|i_pred
index|]
operator|.
name|a_inline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pkt
operator|->
name|p_idel
index|[
name|n
index|]
operator|.
name|i_datetime
operator|>
name|pkt
operator|->
name|p_cutoff
condition|)
name|condset
argument_list|(
name|rap
argument_list|,
name|NOAPPLY
argument_list|,
name|CUTOFF
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|first_app
condition|)
name|bcopy
argument_list|(
operator|&
name|pkt
operator|->
name|p_idel
index|[
name|n
index|]
operator|.
name|i_sid
argument_list|,
operator|&
name|pkt
operator|->
name|p_gotsid
argument_list|,
sizeof|sizeof
argument_list|(
name|pkt
operator|->
name|p_gotsid
argument_list|)
argument_list|)
expr_stmt|;
name|first_app
operator|=
literal|0
expr_stmt|;
name|condset
argument_list|(
name|rap
argument_list|,
name|APPLY
argument_list|,
name|EMPTY
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|condset
argument_list|(
name|rap
argument_list|,
name|NOAPPLY
argument_list|,
name|EMPTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|rap
operator|->
name|a_code
operator|==
name|APPLY
condition|)
name|ixgsetup
argument_list|(
name|pkt
operator|->
name|p_apply
argument_list|,
operator|&
operator|(
name|pkt
operator|->
name|p_idel
index|[
name|n
index|]
operator|.
name|i_ixg
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|ixgsetup
argument_list|(
argument|ap
argument_list|,
argument|ixgp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|apply
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ixg
modifier|*
name|ixgp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
name|int
name|code
decl_stmt|,
name|reason
decl_stmt|;
specifier|register
name|int
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|ixg
modifier|*
name|cur
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
for|for
control|(
name|cur
operator|=
name|ixgp
init|;
name|cur
operator|=
operator|(
name|prev
operator|=
name|cur
operator|)
operator|->
name|i_next
condition|;
control|)
block|{
switch|switch
condition|(
name|cur
operator|->
name|i_type
condition|)
block|{
case|case
name|INCLUDE
case|:
name|code
operator|=
name|APPLY
expr_stmt|;
name|reason
operator|=
name|INCL
expr_stmt|;
break|break;
case|case
name|EXCLUDE
case|:
name|code
operator|=
name|NOAPPLY
expr_stmt|;
name|reason
operator|=
name|EXCL
expr_stmt|;
break|break;
case|case
name|IGNORE
case|:
name|code
operator|=
name|EMPTY
expr_stmt|;
name|reason
operator|=
name|IGNR
expr_stmt|;
break|break;
block|}
name|ip
operator|=
name|cur
operator|->
name|i_ser
expr_stmt|;
for|for
control|(
name|n
operator|=
name|cur
operator|->
name|i_cnt
init|;
name|n
condition|;
name|n
operator|--
control|)
name|condset
argument_list|(
operator|&
name|ap
index|[
operator|*
name|ip
operator|++
index|]
argument_list|,
name|code
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|condset
argument_list|(
name|ap
argument_list|,
name|code
argument_list|,
name|reason
argument_list|)
specifier|register
expr|struct
name|apply
operator|*
name|ap
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|code
decl_stmt|,
name|reason
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|code
operator|==
name|EMPTY
condition|)
name|ap
operator|->
name|a_reason
operator|=
operator||
name|reason
expr_stmt|;
elseif|else
if|if
condition|(
name|ap
operator|->
name|a_code
operator|==
name|EMPTY
condition|)
block|{
name|ap
operator|->
name|a_code
operator|=
name|code
expr_stmt|;
name|ap
operator|->
name|a_reason
operator|=
operator||
name|reason
expr_stmt|;
block|}
block|}
end_block

end_unit

