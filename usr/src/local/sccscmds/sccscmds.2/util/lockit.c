begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"../hdr/macros.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_expr_stmt
name|SCCSID
argument_list|(
argument|@
operator|(
operator|#
operator|)
name|lockit
literal|2.1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	Process semaphore. 	Try repeatedly (`count' times) to create `lockfile' mode 444. 	Sleep 10 seconds between tries. 	If `lockfile' is successfully created, write the process ID 	`pid' in `lockfile' (in binary), and return 0. 	If `lockfile' exists and it hasn't been modified within the last 	minute, and either the file is empty or the process ID contained 	in the file is not the process ID of any existing process, 	`lockfile' is removed and it tries again to make `lockfile'. 	After `count' tries, or if the reason for the create failing 	is something other than EACCES, return xmsg().   	Unlockit will return 0 if the named lock exists, contains 	the given pid, and is successfully removed; -1 otherwise. */
end_comment

begin_expr_stmt
name|lockit
argument_list|(
name|lockfile
argument_list|,
name|count
argument_list|,
name|pid
argument_list|)
specifier|register
name|char
operator|*
name|lockfile
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|unsigned
name|count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|pid
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|fd
decl_stmt|;
name|unsigned
name|opid
decl_stmt|;
name|long
name|ltime
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
for|for
control|(
operator|++
name|count
init|;
operator|--
name|count
condition|;
name|sleep
argument_list|(
literal|10
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|lockfile
argument_list|,
literal|0444
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|pid
argument_list|,
sizeof|sizeof
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|errno
operator|==
name|ENFILE
condition|)
block|{
name|unlink
argument_list|(
name|lockfile
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|errno
operator|!=
name|EACCES
condition|)
return|return
operator|(
name|xmsg
argument_list|(
name|lockfile
argument_list|,
literal|"lockit"
argument_list|)
operator|)
return|;
if|if
condition|(
name|exists
argument_list|(
name|lockfile
argument_list|)
condition|)
block|{
name|time
argument_list|(
operator|&
name|ltime
argument_list|)
expr_stmt|;
name|ltime
operator|-=
name|Statbuf
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|lockfile
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ltime
operator|<
literal|60L
condition|)
name|sleep
argument_list|(
literal|60
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|opid
argument_list|,
sizeof|sizeof
argument_list|(
name|opid
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|opid
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|lockfile
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|kill
argument_list|(
name|opid
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ESRCH
condition|)
block|{
name|unlink
argument_list|(
name|lockfile
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|unlockit
argument_list|(
name|lockfile
argument_list|,
name|pid
argument_list|)
specifier|register
name|char
operator|*
name|lockfile
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|pid
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|fd
decl_stmt|,
name|n
decl_stmt|;
name|unsigned
name|opid
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|lockfile
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|opid
argument_list|,
sizeof|sizeof
argument_list|(
name|opid
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
sizeof|sizeof
argument_list|(
name|opid
argument_list|)
operator|&&
name|opid
operator|==
name|pid
condition|)
return|return
operator|(
name|unlink
argument_list|(
name|lockfile
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

end_unit

