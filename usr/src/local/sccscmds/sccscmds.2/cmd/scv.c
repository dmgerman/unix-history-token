begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/* 	Program to convert release 3 (or release 2 or even 1) SCCS files 	to release 4 SCCS files. 	Usage: 		scv arg ... 	arg is any argument acceptable as an SCCS file 	name argument to the get command. E.g.: 		scv mysccsdir 	will convert every release 3 (or 2 or 1 but NOT 4) SCCS file in the 	directory "mysccsdir". */
end_comment

begin_include
include|#
directive|include
file|"../hdr/defines.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_expr_stmt
name|SCCSID
argument_list|(
argument|@
operator|(
operator|#
operator|)
name|scv
operator|.
name|c
literal|4.5
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	Release 3 SCCS File Structures  (2.1  78/06/05 17:31:17) 	See osccsfile(V). */
end_comment

begin_struct
struct|struct
name|Header
block|{
name|short
name|Hmagicno
decl_stmt|;
name|char
name|Htype
index|[
literal|10
index|]
decl_stmt|;
name|char
name|Hpers
index|[
literal|14
index|]
decl_stmt|;
name|char
name|Hdesc
index|[
literal|100
index|]
decl_stmt|;
name|short
name|Hfloor
decl_stmt|;
name|short
name|Hceil
decl_stmt|;
name|short
name|Hsw
index|[
literal|5
index|]
decl_stmt|;
name|short
name|Hrdef
decl_stmt|;
name|char
name|Hulist
index|[
literal|32
index|]
decl_stmt|;
name|char
name|Hexpand
index|[
literal|50
index|]
decl_stmt|;
name|short
name|Hash
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAGICNO
value|(7)
end_define

begin_define
define|#
directive|define
name|HASHADDR
value|(226)
end_define

begin_struct
struct|struct
name|Reltab
block|{
name|short
name|Rrel
decl_stmt|;
name|short
name|Rlevs
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Deltab
block|{
name|short
name|Drel
decl_stmt|;
name|short
name|Dlev
decl_stmt|;
name|char
name|Dtype
decl_stmt|;
comment|/*'D': delta,'P','U': non-prop,'I': incl,'E': excl */
name|char
name|Dfill
decl_stmt|;
comment|/* Used to be option letter */
comment|/* compiler once forced unfortunate alignment here. /* also, fp-11c high/low long goof strikes again. /*	long  Ddatetime; */
name|short
name|Ddthi
decl_stmt|,
name|Ddtlo
decl_stmt|;
name|char
name|Dpgmr
index|[
name|SZLNAM
index|]
decl_stmt|;
name|char
name|Dhist
index|[
literal|200
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Control
block|{
name|short
name|Crel
decl_stmt|;
name|short
name|Clev
decl_stmt|;
name|char
name|Cctl
decl_stmt|;
comment|/* -11: ins, -12: del, -13: end */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SIZEOFCONTROL
value|(5)
end_define

begin_define
define|#
directive|define
name|OINS
value|(-11)
end_define

begin_define
define|#
directive|define
name|ODEL
value|(-12)
end_define

begin_define
define|#
directive|define
name|OEND
value|(-13)
end_define

begin_struct
struct|struct
name|Line
block|{
name|char
name|Lline
index|[
literal|256
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* 	Structure for use with buffered I/O routines opnl, opnr,  	getl and getr. */
end_comment

begin_struct
struct|struct
name|Ibufr
block|{
name|short
name|Ifildes
decl_stmt|;
name|char
modifier|*
name|Irecptr
decl_stmt|;
name|char
modifier|*
name|Iend
decl_stmt|;
name|char
name|Ibuff1
index|[
literal|256
index|]
decl_stmt|;
name|char
name|Ibuff2
index|[
literal|512
index|]
decl_stmt|;
name|char
name|Ibuff3
index|[
literal|2
index|]
decl_stmt|;
name|short
name|Ilen
decl_stmt|;
name|short
name|Ihflag
decl_stmt|;
name|short
name|Ihcnt
decl_stmt|;
name|short
name|Ihtot
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* 	Structure for use with buffered I/O routines crtr, crtl, putl, 	putr, flshr and buflsh. */
end_comment

begin_struct
struct|struct
name|Obufr
block|{
name|short
name|Ofildes
decl_stmt|;
name|char
modifier|*
name|Orecptr
decl_stmt|;
name|char
modifier|*
name|Oend
decl_stmt|;
name|char
name|Obuff1
index|[
literal|512
index|]
decl_stmt|;
name|short
name|Ohflag
decl_stmt|;
name|short
name|Ohcnt
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * structure to access an  * shorteger in bytes  */
end_comment

begin_struct
struct|struct
block|{
name|char
name|lobyte
decl_stmt|;
name|char
name|hibyte
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * structure to access an shorteger  */
end_comment

begin_struct
struct|struct
block|{
name|short
name|shorteg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * structure to access a long as shortegers  */
end_comment

begin_struct
struct|struct
block|{
name|short
name|hiword
decl_stmt|;
name|short
name|loword
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* 	Structure for referencing pieces of localtime(). */
end_comment

begin_struct
struct|struct
name|Time
block|{
name|short
name|Tseconds
decl_stmt|;
name|short
name|Tminutes
decl_stmt|;
name|short
name|Thours
decl_stmt|;
name|short
name|Tday_month
decl_stmt|;
name|short
name|Tmonth
decl_stmt|;
name|short
name|Tyear
decl_stmt|;
name|short
name|Tday_week
decl_stmt|;
name|short
name|Tday_year
decl_stmt|;
name|short
name|Tflag
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* 	SCCS Internal Structures (used by get and delta).     (2.1) */
end_comment

begin_struct
struct|struct
name|Apply
block|{
name|short
name|Adt
decl_stmt|;
comment|/* pseudo date-time */
name|short
name|Acode
decl_stmt|;
comment|/* APPLY, NOAPPLY or EMPTY */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|APPLY
value|(1)
end_define

begin_define
define|#
directive|define
name|NOAPPLY
value|(-1)
end_define

begin_define
define|#
directive|define
name|EMPTY
value|(0)
end_define

begin_struct
struct|struct
name|Queue
block|{
name|struct
name|Queue
modifier|*
name|Qnext
decl_stmt|;
name|short
name|Qrel
decl_stmt|;
comment|/* release */
name|short
name|Qlev
decl_stmt|;
comment|/* level */
name|short
name|Qdt
decl_stmt|;
comment|/* pseudo date-time */
name|short
name|Qkeep
decl_stmt|;
comment|/* keep switch setting */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|YES
value|(1)
end_define

begin_define
define|#
directive|define
name|NO
value|(-1)
end_define

begin_define
define|#
directive|define
name|SIZEOFPfile
value|(50)
end_define

begin_struct
struct|struct
name|Packet
block|{
name|char
name|Pfile
index|[
name|SIZEOFPfile
index|]
decl_stmt|;
comment|/* file name containing module */
comment|/* 			Note: the order of the next two words 				can not
comment|___ be changed! 			This is because the release and level together 			are treated as a long. */
name|short
name|Prel
decl_stmt|;
comment|/* specified release (-1 = not spec.) */
name|short
name|Plev
decl_stmt|;
comment|/* specified level (-1 = not spec.)*/
name|char
name|Pverbose
decl_stmt|;
comment|/* verbose flags (see #define's below) */
name|char
name|Pupd
decl_stmt|;
comment|/* update flag (!0 = update mode) */
name|long
name|Pcutoff
decl_stmt|;
comment|/* specified cutoff date-time */
name|struct
name|Header
name|Phdr
decl_stmt|;
comment|/* header from module */
name|short
name|Plnno
decl_stmt|;
comment|/* line number of current line */
name|short
name|Precno
decl_stmt|;
comment|/* record number of current rec */
name|char
name|Pwrttn
decl_stmt|;
comment|/* written flag (!0 = written) */
name|char
name|Pkeep
decl_stmt|;
comment|/* keep switch for readmod() */
name|struct
name|Apply
modifier|*
modifier|*
name|Papply
decl_stmt|;
comment|/* ptr to apply array */
name|struct
name|Queue
modifier|*
name|Pq
decl_stmt|;
comment|/* ptr to control queue */
name|struct
name|Ibufr
name|Pibuf
decl_stmt|;
comment|/* input buffer */
name|long
name|Pcdt
decl_stmt|;
comment|/* date/time of newest applied delta */
name|char
modifier|*
name|Plfile
decl_stmt|;
comment|/* 0 = no l-file; else ptr to l arg */
name|char
name|Punack
decl_stmt|;
comment|/* !0 if unacknowledged non-prop deltas */
name|char
name|Pnoprop
decl_stmt|;
comment|/* !0 if new delta is to be non-prop */
name|short
name|Pirel
decl_stmt|;
comment|/* rel which inserted current rec */
name|short
name|Pilev
decl_stmt|;
comment|/* lev which inserted current rec */
block|}
struct|;
end_struct

begin_comment
comment|/* 	Masks for Pverbose */
end_comment

begin_define
define|#
directive|define
name|RLACCESS
value|(1)
end_define

begin_define
define|#
directive|define
name|NLINES
value|(2)
end_define

begin_define
define|#
directive|define
name|DOLIST
value|(4)
end_define

begin_define
define|#
directive|define
name|UNACK
value|(8)
end_define

begin_define
define|#
directive|define
name|NEWRL
value|(16)
end_define

begin_define
define|#
directive|define
name|WARNING
value|(32)
end_define

begin_comment
comment|/* 	size of login name */
end_comment

begin_expr_stmt
name|USXALLOC
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|short
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
extern|extern conv(
block|)
function|;
end_function

begin_decl_stmt
specifier|extern
name|short
name|Fcnt
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|setsig
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Fflags
operator|=
name|FTLMSG
operator||
name|FTLCLN
operator||
name|FTLJMP
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
operator|=
name|argv
index|[
name|i
index|]
condition|)
name|odo_file
argument_list|(
name|p
argument_list|,
name|conv
argument_list|)
expr_stmt|;
end_for

begin_expr_stmt
name|exit
argument_list|(
name|Fcnt
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
unit|}   struct
name|packet
name|npkt
decl_stmt|;
end_decl_stmt

begin_macro
name|conv
argument_list|(
argument|ofile
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ofile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|Packet
name|opkt
decl_stmt|;
name|struct
name|deltab
modifier|*
name|dt
decl_stmt|;
name|char
modifier|*
modifier|*
name|hists
decl_stmt|;
name|short
modifier|*
modifier|*
name|rlp
decl_stmt|;
name|char
name|statstr
index|[
literal|32
index|]
decl_stmt|;
name|short
name|ndels
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|short
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Fjmp
argument_list|)
condition|)
return|return;
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|ofile
argument_list|)
expr_stmt|;
name|ckpfile
argument_list|(
name|auxf
argument_list|(
name|ofile
argument_list|,
literal|'p'
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|opkt
argument_list|,
sizeof|sizeof
argument_list|(
name|opkt
argument_list|)
argument_list|)
expr_stmt|;
name|opnr
argument_list|(
operator|&
name|opkt
operator|.
name|Pibuf
argument_list|,
name|ofile
argument_list|)
expr_stmt|;
name|dohead
argument_list|(
operator|&
name|opkt
argument_list|)
expr_stmt|;
name|rlp
operator|=
literal|0
expr_stmt|;
name|ndels
operator|=
name|doreltab
argument_list|(
operator|&
name|opkt
argument_list|,
operator|&
name|rlp
argument_list|)
expr_stmt|;
name|hists
operator|=
name|alloc
argument_list|(
operator|(
name|ndels
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|hists
argument_list|)
argument_list|)
expr_stmt|;
name|dt
operator|=
name|alloc
argument_list|(
operator|(
name|ndels
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dt
argument_list|)
argument_list|)
expr_stmt|;
name|dodelt
argument_list|(
operator|&
name|opkt
argument_list|,
name|dt
argument_list|,
name|hists
argument_list|,
name|ndels
argument_list|)
expr_stmt|;
name|fixup
argument_list|(
name|dt
argument_list|,
name|ndels
argument_list|,
name|rlp
argument_list|)
expr_stmt|;
name|sinit
argument_list|(
operator|&
name|npkt
argument_list|,
name|ofile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|npkt
operator|.
name|p_upd
operator|=
literal|1
expr_stmt|;
name|line
operator|=
name|npkt
operator|.
name|p_line
expr_stmt|;
name|putline
argument_list|(
operator|&
name|npkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c00000\n"
argument_list|,
name|CTLCHAR
argument_list|,
name|HEAD
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|statstr
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|ndels
init|;
name|n
condition|;
name|n
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|statstr
index|[
literal|0
index|]
condition|)
name|newstats
argument_list|(
operator|&
name|npkt
argument_list|,
name|statstr
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
else|else
name|putline
argument_list|(
operator|&
name|npkt
argument_list|,
name|statstr
argument_list|)
expr_stmt|;
name|putline
argument_list|(
operator|&
name|npkt
argument_list|,
name|del_ba
argument_list|(
operator|&
name|dt
index|[
name|n
index|]
argument_list|,
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|putline
argument_list|(
operator|&
name|npkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c %s\n"
argument_list|,
name|CTLCHAR
argument_list|,
name|COMMENTS
argument_list|,
name|hists
index|[
name|n
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|putline
argument_list|(
operator|&
name|npkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
name|CTLSTR
argument_list|,
name|CTLCHAR
argument_list|,
name|EDELTAB
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putline
argument_list|(
operator|&
name|npkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
name|CTLSTR
argument_list|,
name|CTLCHAR
argument_list|,
name|BUSERNAM
argument_list|)
argument_list|)
expr_stmt|;
name|dousers
argument_list|(
name|opkt
operator|.
name|Phdr
operator|.
name|Hulist
argument_list|,
operator|&
name|npkt
argument_list|)
expr_stmt|;
name|putline
argument_list|(
operator|&
name|npkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
name|CTLSTR
argument_list|,
name|CTLCHAR
argument_list|,
name|EUSERNAM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|p
operator|=
name|opkt
operator|.
name|Phdr
operator|.
name|Htype
operator|)
condition|)
name|putline
argument_list|(
operator|&
name|npkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c %c %s\n"
argument_list|,
name|CTLCHAR
argument_list|,
name|FLAG
argument_list|,
name|TYPEFLAG
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|=
name|opkt
operator|.
name|Phdr
operator|.
name|Hfloor
condition|)
name|putline
argument_list|(
operator|&
name|npkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c %c %d\n"
argument_list|,
name|CTLCHAR
argument_list|,
name|FLAG
argument_list|,
name|FLORFLAG
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|=
name|opkt
operator|.
name|Phdr
operator|.
name|Hceil
condition|)
name|putline
argument_list|(
operator|&
name|npkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c %c %d\n"
argument_list|,
name|CTLCHAR
argument_list|,
name|FLAG
argument_list|,
name|CEILFLAG
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|=
name|opkt
operator|.
name|Phdr
operator|.
name|Hrdef
condition|)
name|putline
argument_list|(
operator|&
name|npkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c %c %d\n"
argument_list|,
name|CTLCHAR
argument_list|,
name|FLAG
argument_list|,
name|DEFTFLAG
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|putline
argument_list|(
operator|&
name|npkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
name|CTLSTR
argument_list|,
name|CTLCHAR
argument_list|,
name|BUSERTXT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|p
operator|=
name|opkt
operator|.
name|Phdr
operator|.
name|Hpers
operator|)
condition|)
name|putline
argument_list|(
operator|&
name|npkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s\n"
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|p
operator|=
name|opkt
operator|.
name|Phdr
operator|.
name|Hdesc
operator|)
condition|)
name|putline
argument_list|(
operator|&
name|npkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s\n"
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|putline
argument_list|(
operator|&
name|npkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
name|CTLSTR
argument_list|,
name|CTLCHAR
argument_list|,
name|EUSERTXT
argument_list|)
argument_list|)
expr_stmt|;
name|dobod
argument_list|(
operator|&
name|opkt
argument_list|,
operator|&
name|npkt
argument_list|,
name|rlp
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|convflush
argument_list|(
operator|&
name|npkt
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|opkt
operator|.
name|Pibuf
operator|.
name|Ifildes
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|ndels
init|;
name|n
condition|;
name|n
operator|--
control|)
name|free
argument_list|(
name|hists
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hists
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dt
argument_list|)
expr_stmt|;
comment|/* [compiler bug, ignore this for now ] 	if (rlp) { 		for (n = (short) (*rlp); n; n--) 			if (rlp[n]) 				free(rlp[n]); 		free(rlp); 	} */
name|rename
argument_list|(
name|auxf
argument_list|(
name|npkt
operator|.
name|p_file
argument_list|,
literal|'x'
argument_list|)
argument_list|,
name|npkt
operator|.
name|p_file
argument_list|)
expr_stmt|;
name|xrm
argument_list|(
operator|&
name|npkt
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|getline
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_macro
name|clean_up
argument_list|()
end_macro

begin_block
block|{
name|xrm
argument_list|(
operator|&
name|npkt
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fixup
argument_list|(
argument|dt
argument_list|,
argument|ndels
argument_list|,
argument|rlp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|deltab
modifier|*
name|dt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|ndels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
modifier|*
name|rlp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|m
decl_stmt|,
name|n
decl_stmt|;
name|short
name|maxr
decl_stmt|;
name|short
name|seqcnt
decl_stmt|;
name|short
name|pred
decl_stmt|;
specifier|register
name|struct
name|deltab
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|short
modifier|*
name|brp
decl_stmt|;
for|for
control|(
name|m
operator|=
name|ndels
init|;
name|m
condition|;
name|m
operator|--
control|)
block|{
name|p1
operator|=
operator|&
name|dt
index|[
name|m
index|]
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|d_sid
operator|.
name|s_lev
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|n
operator|=
name|m
operator|-
literal|1
init|;
name|n
condition|;
name|n
operator|--
control|)
block|{
if|if
condition|(
name|p1
operator|->
name|d_sid
operator|.
name|s_rel
operator|==
name|dt
index|[
name|n
index|]
operator|.
name|d_sid
operator|.
name|s_rel
condition|)
break|break;
block|}
name|pred
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|maxr
operator|=
name|pred
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|m
operator|-
literal|1
init|;
name|n
condition|;
name|n
operator|--
control|)
block|{
name|p2
operator|=
operator|&
name|dt
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|d_sid
operator|.
name|s_rel
operator|>
name|p2
operator|->
name|d_sid
operator|.
name|s_rel
operator|&&
name|p2
operator|->
name|d_type
operator|==
literal|'D'
operator|&&
name|p2
operator|->
name|d_sid
operator|.
name|s_rel
operator|>
name|maxr
condition|)
block|{
name|maxr
operator|=
name|p2
operator|->
name|d_sid
operator|.
name|s_rel
expr_stmt|;
name|pred
operator|=
name|n
expr_stmt|;
block|}
block|}
block|}
name|p1
operator|->
name|d_pred
operator|=
name|pred
expr_stmt|;
name|rlp
index|[
name|p1
operator|->
name|d_sid
operator|.
name|s_rel
index|]
index|[
name|p1
operator|->
name|d_sid
operator|.
name|s_lev
index|]
operator|=
name|m
expr_stmt|;
block|}
name|brp
operator|=
name|alloca
argument_list|(
name|n
operator|=
operator|(
name|ndels
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|brp
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|brp
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|1
init|;
name|m
operator|<=
name|ndels
condition|;
name|m
operator|++
control|)
block|{
name|p1
operator|=
operator|&
name|dt
index|[
name|m
index|]
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|d_type
operator|!=
literal|'D'
condition|)
block|{
name|seqcnt
operator|=
literal|0
expr_stmt|;
name|p2
operator|=
operator|&
name|dt
index|[
name|p1
operator|->
name|d_pred
index|]
expr_stmt|;
name|p1
operator|->
name|d_type
operator|=
literal|'D'
expr_stmt|;
name|p1
operator|->
name|d_sid
operator|.
name|s_rel
operator|=
name|p2
operator|->
name|d_sid
operator|.
name|s_rel
expr_stmt|;
name|p1
operator|->
name|d_sid
operator|.
name|s_lev
operator|=
name|p2
operator|->
name|d_sid
operator|.
name|s_lev
expr_stmt|;
name|p1
operator|->
name|d_sid
operator|.
name|s_br
operator|=
operator|++
name|brp
index|[
name|p1
operator|->
name|d_pred
index|]
expr_stmt|;
name|p1
operator|->
name|d_sid
operator|.
name|s_seq
operator|=
operator|++
name|seqcnt
expr_stmt|;
name|pred
operator|=
name|m
expr_stmt|;
for|for
control|(
name|n
operator|=
name|m
operator|+
literal|1
init|;
name|n
operator|<=
name|ndels
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|dt
index|[
name|n
index|]
operator|.
name|d_pred
operator|==
name|pred
condition|)
block|{
name|p2
operator|=
operator|&
name|dt
index|[
name|n
index|]
expr_stmt|;
name|p2
operator|->
name|d_type
operator|=
literal|'D'
expr_stmt|;
name|p2
operator|->
name|d_sid
operator|.
name|s_rel
operator|=
name|p1
operator|->
name|d_sid
operator|.
name|s_rel
expr_stmt|;
name|p2
operator|->
name|d_sid
operator|.
name|s_lev
operator|=
name|p1
operator|->
name|d_sid
operator|.
name|s_lev
expr_stmt|;
name|p2
operator|->
name|d_sid
operator|.
name|s_br
operator|=
name|p1
operator|->
name|d_sid
operator|.
name|s_br
expr_stmt|;
name|p2
operator|->
name|d_sid
operator|.
name|s_seq
operator|=
operator|++
name|seqcnt
expr_stmt|;
name|pred
operator|=
name|n
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_block

begin_struct
struct|struct
name|names
block|{
name|struct
name|names
modifier|*
name|n_next
decl_stmt|;
name|char
name|n_name
index|[
name|SZLNAM
index|]
decl_stmt|;
name|short
name|n_uid
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|names
modifier|*
name|names
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|dousers
argument_list|(
name|up
argument_list|,
name|pkt
argument_list|)
specifier|register
name|char
operator|*
name|up
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|packet
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
name|mask
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|str
index|[
literal|16
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|c
operator|=
operator|*
name|up
operator|++
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mask
operator|=
literal|1
init|;
name|mask
condition|;
name|mask
operator|=
operator|<<
literal|1
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|&
name|mask
operator|)
operator|&&
operator|(
name|p
operator|=
name|getlnam
argument_list|(
name|i
operator|*
name|SZLNAM
operator|+
name|j
argument_list|)
operator|)
condition|)
name|putline
argument_list|(
name|pkt
argument_list|,
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%s\n"
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|getlnam
argument_list|(
argument|uid
argument_list|)
end_macro

begin_decl_stmt
name|short
name|uid
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|str
index|[
literal|128
index|]
decl_stmt|;
specifier|register
name|struct
name|names
modifier|*
name|cur
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|cur
operator|=
operator|&
name|names
init|;
name|cur
operator|=
operator|(
name|prev
operator|=
name|cur
operator|)
operator|->
name|n_next
condition|;
control|)
if|if
condition|(
name|cur
operator|->
name|n_uid
operator|==
name|uid
condition|)
return|return
operator|(
name|cur
operator|->
name|n_name
operator|)
return|;
if|if
condition|(
name|getpw
argument_list|(
name|uid
argument_list|,
name|str
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|prev
operator|->
name|n_next
operator|=
name|cur
operator|=
name|alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cur
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|->
name|n_next
operator|=
literal|0
expr_stmt|;
name|cur
operator|->
name|n_uid
operator|=
name|uid
expr_stmt|;
for|for
control|(
name|p
operator|=
name|str
init|;
operator|*
name|p
operator|++
operator|!=
literal|':'
condition|;
control|)
empty_stmt|;
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
name|str
index|[
name|SZLNAM
index|]
operator|=
literal|0
expr_stmt|;
name|copy
argument_list|(
name|str
argument_list|,
name|cur
operator|->
name|n_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|cur
operator|->
name|n_name
operator|)
return|;
block|}
end_block

begin_comment
comment|/* 	Routine to process the module header. All that's necessary is 	to slide it shorto the packet. */
end_comment

begin_expr_stmt
name|dohead
argument_list|(
name|pkt
argument_list|)
specifier|register
expr|struct
name|Packet
operator|*
name|pkt
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|Header
modifier|*
name|hdr
decl_stmt|;
if|if
condition|(
name|rdrec
argument_list|(
name|pkt
argument_list|)
operator|==
literal|1
condition|)
name|fatal
argument_list|(
literal|"premature eof (58)"
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|pkt
operator|->
name|Pibuf
operator|.
name|Irecptr
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|Hmagicno
operator|!=
name|MAGICNO
condition|)
name|fatal
argument_list|(
literal|"not an SCCS file (53)"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hdr
argument_list|,
operator|&
name|pkt
operator|->
name|Phdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|doreltab
argument_list|(
name|pkt
argument_list|,
name|rlp
argument_list|)
specifier|register
expr|struct
name|Packet
operator|*
name|pkt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|short
modifier|*
modifier|*
modifier|*
name|rlp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|n
decl_stmt|;
name|short
name|sz
decl_stmt|;
specifier|register
name|struct
name|Reltab
modifier|*
name|rt
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|rdrec
argument_list|(
name|pkt
argument_list|)
operator|!=
literal|1
operator|&&
operator|(
name|rt
operator|=
name|pkt
operator|->
name|Pibuf
operator|.
name|Irecptr
operator|)
operator|->
name|Rrel
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
operator|*
name|rlp
operator|=
name|alloc
argument_list|(
name|sz
operator|=
operator|(
name|rt
operator|->
name|Rrel
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|rlp
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|*
name|rlp
argument_list|,
name|sz
argument_list|)
expr_stmt|;
operator|*
operator|*
name|rlp
operator|=
name|rt
operator|->
name|Rrel
expr_stmt|;
block|}
operator|(
operator|*
name|rlp
operator|)
index|[
name|rt
operator|->
name|Rrel
index|]
operator|=
name|alloc
argument_list|(
operator|(
name|rt
operator|->
name|Rlevs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|*
operator|*
name|rlp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rlp
operator|)
index|[
name|rt
operator|->
name|Rrel
index|]
index|[
literal|0
index|]
operator|=
name|rt
operator|->
name|Rlevs
expr_stmt|;
name|n
operator|=
operator|+
name|rt
operator|->
name|Rlevs
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|dodelt
argument_list|(
argument|pkt
argument_list|,
argument|dt
argument_list|,
argument|hists
argument_list|,
argument|ndels
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|Packet
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|deltab
modifier|*
name|dt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|hists
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|ndels
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|n
decl_stmt|;
specifier|register
name|struct
name|deltab
modifier|*
name|ndt
decl_stmt|;
specifier|register
name|struct
name|Deltab
modifier|*
name|odt
decl_stmt|;
for|for
control|(
init|;
name|rdrec
argument_list|(
name|pkt
argument_list|)
operator|!=
literal|1
operator|&&
operator|(
name|odt
operator|=
name|pkt
operator|->
name|Pibuf
operator|.
name|Irecptr
operator|)
operator|->
name|Drel
condition|;
operator|--
name|ndels
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|odt
operator|->
name|Dtype
operator|==
literal|'D'
operator|||
name|odt
operator|->
name|Dtype
operator|==
literal|'P'
operator|||
name|odt
operator|->
name|Dtype
operator|==
literal|'U'
operator|)
condition|)
block|{
operator|++
name|ndels
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|ndels
condition|)
return|return
operator|(
name|fatal
argument_list|(
literal|"internal error in dodeltab"
argument_list|)
operator|)
return|;
name|ndt
operator|=
operator|&
name|dt
index|[
name|ndels
index|]
expr_stmt|;
name|ndt
operator|->
name|d_type
operator|=
name|odt
operator|->
name|Dtype
expr_stmt|;
name|bcopy
argument_list|(
name|odt
operator|->
name|Dpgmr
argument_list|,
name|ndt
operator|->
name|d_pgmr
argument_list|,
sizeof|sizeof
argument_list|(
name|ndt
operator|->
name|d_pgmr
argument_list|)
argument_list|)
expr_stmt|;
name|ndt
operator|->
name|d_datetime
operator|=
operator|(
name|odt
operator|->
name|Ddthi
operator|<<
literal|16
operator|)
operator|+
operator|(
name|unsigned
operator|)
name|odt
operator|->
name|Ddtlo
expr_stmt|;
name|ndt
operator|->
name|d_sid
operator|.
name|s_rel
operator|=
name|odt
operator|->
name|Drel
expr_stmt|;
name|ndt
operator|->
name|d_sid
operator|.
name|s_lev
operator|=
name|odt
operator|->
name|Dlev
expr_stmt|;
name|ndt
operator|->
name|d_sid
operator|.
name|s_br
operator|=
literal|0
expr_stmt|;
name|ndt
operator|->
name|d_sid
operator|.
name|s_seq
operator|=
literal|0
expr_stmt|;
name|ndt
operator|->
name|d_serial
operator|=
name|ndels
expr_stmt|;
name|ndt
operator|->
name|d_pred
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|size
argument_list|(
name|odt
operator|->
name|Dhist
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
name|n
operator|=
operator|&
operator|~
literal|1
expr_stmt|;
if|if
condition|(
name|odt
operator|->
name|Dtype
operator|==
literal|'P'
operator|||
name|odt
operator|->
name|Dtype
operator|==
literal|'U'
condition|)
block|{
name|hists
index|[
name|ndels
index|]
operator|=
name|alloc
argument_list|(
name|n
operator|+
literal|16
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hists
index|[
name|ndels
index|]
argument_list|,
literal|"[was %d.%d] "
argument_list|,
name|odt
operator|->
name|Drel
argument_list|,
name|odt
operator|->
name|Dlev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hists
index|[
name|ndels
index|]
operator|=
name|alloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|hists
index|[
name|ndels
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|odt
operator|->
name|Dhist
argument_list|,
name|index
argument_list|(
name|hists
index|[
name|ndels
index|]
argument_list|,
literal|'\0'
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ndels
condition|)
block|{
name|fatal
argument_list|(
literal|"in dodelt"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|dobod
argument_list|(
argument|opkt
argument_list|,
argument|npkt
argument_list|,
argument|rlp
argument_list|,
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|Packet
modifier|*
name|opkt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|packet
modifier|*
name|npkt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
modifier|*
name|rlp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|Control
modifier|*
name|octl
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
name|c
decl_stmt|;
while|while
condition|(
name|rdrec
argument_list|(
name|opkt
argument_list|)
operator|!=
literal|1
operator|&&
operator|(
name|octl
operator|=
name|opkt
operator|->
name|Pibuf
operator|.
name|Irecptr
operator|)
operator|->
name|Crel
condition|)
block|{
if|if
condition|(
name|octlrec
argument_list|(
name|octl
argument_list|,
name|opkt
operator|->
name|Pibuf
operator|.
name|Ilen
argument_list|)
condition|)
name|putline
argument_list|(
name|npkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%c%c %u\n"
argument_list|,
name|CTLCHAR
argument_list|,
literal|"EDI"
index|[
name|octl
operator|->
name|Cctl
operator|-
name|OEND
index|]
argument_list|,
name|rlp
index|[
name|octl
operator|->
name|Crel
index|]
index|[
name|octl
operator|->
name|Clev
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|c
operator|=
operator|(
name|p
operator|=
name|octl
operator|)
index|[
name|opkt
operator|->
name|Pibuf
operator|.
name|Ilen
index|]
expr_stmt|;
name|p
index|[
name|opkt
operator|->
name|Pibuf
operator|.
name|Ilen
index|]
operator|=
literal|0
expr_stmt|;
name|putline
argument_list|(
name|npkt
argument_list|,
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s\n"
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
index|[
name|opkt
operator|->
name|Pibuf
operator|.
name|Ilen
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|octlrec
argument_list|(
name|ctl
argument_list|,
name|len
argument_list|)
specifier|register
expr|struct
name|Control
operator|*
name|ctl
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|short
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|short
name|ch
decl_stmt|;
if|if
condition|(
name|len
operator|==
name|SIZEOFCONTROL
operator|&&
operator|(
operator|(
name|ch
operator|=
name|ctl
operator|->
name|Cctl
operator|)
operator|==
name|OINS
operator|||
name|ch
operator|==
name|ODEL
operator|||
name|ch
operator|==
name|OEND
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|rdrec
argument_list|(
name|pkt
argument_list|)
specifier|register
expr|struct
name|Packet
operator|*
name|pkt
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|getr
argument_list|(
operator|&
name|pkt
operator|->
name|Pibuf
argument_list|)
operator|)
operator|!=
literal|1
condition|)
name|pkt
operator|->
name|Precno
operator|++
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|xwrite
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
name|write
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|CALL
parameter_list|(
name|p
parameter_list|,
name|func
parameter_list|,
name|cnt
parameter_list|)
value|Ffile=p; (*func)(p); cnt++;
end_define

begin_decl_stmt
name|short
name|nfiles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|had_dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|had_standinp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|odo_file
argument_list|(
name|p
argument_list|,
name|func
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_function_decl
name|short
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|extern
name|char
modifier|*
name|Ffile
decl_stmt|;
name|char
name|str
index|[
name|FILESIZE
index|]
decl_stmt|;
name|char
name|ibuf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|FILE
modifier|*
name|iop
decl_stmt|;
name|struct
name|dir
name|dir
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|short
name|fd
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|had_standinp
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|gets
argument_list|(
name|ibuf
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|osccsfile
argument_list|(
name|ibuf
argument_list|)
condition|)
block|{
name|CALL
argument_list|(
name|ibuf
argument_list|,
name|func
argument_list|,
name|nfiles
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|exists
argument_list|(
name|p
argument_list|)
operator|&&
operator|(
name|Statbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
name|had_dir
operator|=
literal|1
expr_stmt|;
name|Ffile
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|iop
operator|=
name|fopen
argument_list|(
name|p
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|dir
index|[
literal|1
index|]
operator|.
name|d_ino
operator|=
literal|0
expr_stmt|;
name|fread
argument_list|(
name|dir
argument_list|,
sizeof|sizeof
argument_list|(
name|dir
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|iop
argument_list|)
expr_stmt|;
comment|/* skip "."  */
name|fread
argument_list|(
name|dir
argument_list|,
sizeof|sizeof
argument_list|(
name|dir
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|iop
argument_list|)
expr_stmt|;
comment|/* skip ".."  */
while|while
condition|(
name|fread
argument_list|(
name|dir
argument_list|,
sizeof|sizeof
argument_list|(
name|dir
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|iop
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|.
name|d_ino
operator|==
literal|0
condition|)
continue|continue;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%s/%s"
argument_list|,
name|p
argument_list|,
name|dir
index|[
literal|0
index|]
operator|.
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|osccsfile
argument_list|(
name|str
argument_list|)
condition|)
block|{
name|CALL
argument_list|(
name|str
argument_list|,
name|func
argument_list|,
name|nfiles
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|iop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CALL
argument_list|(
name|p
argument_list|,
name|func
argument_list|,
name|nfiles
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|osccsfile
argument_list|(
name|file
argument_list|)
specifier|register
name|char
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|short
name|ff
decl_stmt|,
name|result
decl_stmt|;
name|short
name|magic
index|[
literal|2
index|]
decl_stmt|;
name|result
operator|=
operator|(
name|ff
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|read
argument_list|(
name|ff
argument_list|,
name|magic
argument_list|,
literal|4
argument_list|)
operator|==
literal|4
operator|&&
name|magic
index|[
literal|1
index|]
operator|==
name|MAGICNO
expr_stmt|;
name|close
argument_list|(
name|ff
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/* 	Routine to write out either the current line in the packet 	(if newline is zero) or the line specified by newline. 	A line is actually written (and the x-file is only 	opened) if pkt->p_upd is non-zero.  When the current line from  	the packet is written, pkt->p_wrttn is set non-zero, and 	further attempts to write it are ignored.  When a line is 	read shorto the packet, pkt->p_wrttn must be turned off. */
end_comment

begin_decl_stmt
name|short
name|Xcreate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|Xiop
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|putline
argument_list|(
name|pkt
argument_list|,
name|newline
argument_list|)
specifier|register
expr|struct
name|packet
operator|*
name|pkt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|newline
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|obf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|xf
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|pkt
operator|->
name|p_upd
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|Xcreate
condition|)
block|{
name|stat
argument_list|(
name|pkt
operator|->
name|p_file
argument_list|,
operator|&
name|Statbuf
argument_list|)
expr_stmt|;
name|xf
operator|=
name|auxf
argument_list|(
name|pkt
operator|->
name|p_file
argument_list|,
literal|'x'
argument_list|)
expr_stmt|;
name|Xiop
operator|=
name|xfcreat
argument_list|(
name|xf
argument_list|,
name|Statbuf
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|Xiop
argument_list|,
name|obf
argument_list|)
expr_stmt|;
name|chown
argument_list|(
name|xf
argument_list|,
operator|(
name|Statbuf
operator|.
name|st_gid
operator|<<
literal|8
operator|)
operator||
name|Statbuf
operator|.
name|st_uid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newline
condition|)
name|p
operator|=
name|newline
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|pkt
operator|->
name|p_wrttn
operator|++
condition|)
name|p
operator|=
name|pkt
operator|->
name|p_line
expr_stmt|;
else|else
name|p
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
condition|)
block|{
name|fputs
argument_list|(
name|p
argument_list|,
name|Xiop
argument_list|)
expr_stmt|;
if|if
condition|(
name|Xcreate
condition|)
while|while
condition|(
operator|*
name|p
condition|)
name|pkt
operator|->
name|p_nhash
operator|=
operator|+
operator|*
name|p
operator|++
expr_stmt|;
block|}
name|Xcreate
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|convflush
argument_list|(
name|pkt
argument_list|)
specifier|register
expr|struct
name|packet
operator|*
name|pkt
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|hash
index|[
literal|6
index|]
decl_stmt|;
if|if
condition|(
name|pkt
operator|->
name|p_upd
operator|==
literal|0
condition|)
return|return;
name|putline
argument_list|(
name|pkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|Xiop
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hash
argument_list|,
literal|"%5u"
argument_list|,
name|pkt
operator|->
name|p_nhash
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
name|zeropad
argument_list|(
name|hash
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|Xiop
argument_list|,
literal|"%c%c%s\n"
argument_list|,
name|CTLCHAR
argument_list|,
name|HEAD
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|Xiop
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|xrm
argument_list|(
argument|pkt
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|packet
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Xiop
condition|)
name|fclose
argument_list|(
name|Xiop
argument_list|)
expr_stmt|;
if|if
condition|(
name|Xcreate
condition|)
name|unlink
argument_list|(
name|auxf
argument_list|(
name|pkt
argument_list|,
literal|'x'
argument_list|)
argument_list|)
expr_stmt|;
name|Xiop
operator|=
name|Xcreate
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|char
name|bpf
index|[]
literal|"bad p-file (216)"
expr_stmt|;
end_expr_stmt

begin_macro
name|rdpfile
argument_list|(
argument|f
argument_list|,
argument|rp
argument_list|,
argument|un
argument_list|)
end_macro

begin_decl_stmt
name|char
name|f
index|[]
decl_stmt|,
name|un
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|rp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|short
name|fd
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|s
index|[
literal|65
index|]
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|fd
operator|=
name|xopen
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|s
argument_list|,
literal|64
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
name|bpf
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|p
operator|=
name|s
expr_stmt|;
name|p
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|' '
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|fatal
argument_list|(
name|bpf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rp
operator|=
name|patoi
argument_list|(
name|s
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
name|bpf
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|==
literal|' '
condition|)
empty_stmt|;
name|name
operator|=
operator|--
name|p
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\n'
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|fatal
argument_list|(
name|bpf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|-
name|name
operator|)
operator|>
name|SZLNAM
condition|)
name|fatal
argument_list|(
name|bpf
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|name
argument_list|,
name|un
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ckpfile
argument_list|(
name|file
argument_list|)
specifier|register
name|char
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|short
name|r
decl_stmt|;
name|char
name|un
index|[
name|SZLNAM
index|]
decl_stmt|;
if|if
condition|(
name|exists
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|rdpfile
argument_list|(
name|file
argument_list|,
operator|&
name|r
argument_list|,
name|un
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"being edited at release %d by `%s' (scv1)"
argument_list|,
name|r
argument_list|,
name|un
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* 	Bottom level read routines for release 3 SCCS files.  	Usage: 		struct Ibufr ib; 		... 		opnr(&ib,"filename"); 		... 		if(getr(&ib) == 1) [end-of-file]; 		[ib.Irecptr is addr of record (always on word boundary)] 		[ib.Ilen is length]  	Address HASHADDR of the file must contain a 1-word stored hash count. 	If this count is non-zero, then on end-of-file a computed hash count 	is compared with it and a fatal error is issued if they aren't equal. */
end_comment

begin_expr_stmt
name|opnr
argument_list|(
name|buf
argument_list|,
name|file
argument_list|)
specifier|register
expr|struct
name|Ibufr
operator|*
name|buf
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|file
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|buf
operator|->
name|Ifildes
operator|=
name|xopen
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|->
name|Irecptr
operator|=
name|buf
operator|->
name|Ibuff2
operator|+
literal|2
expr_stmt|;
name|buf
operator|->
name|Iend
operator|=
name|buf
operator|->
name|Irecptr
operator|+
literal|510
expr_stmt|;
name|buf
operator|->
name|Ilen
operator|=
literal|510
expr_stmt|;
name|buf
operator|->
name|Ibuff3
index|[
literal|1
index|]
operator|=
operator|-
literal|128
expr_stmt|;
name|buf
operator|->
name|Ihcnt
operator|=
name|buf
operator|->
name|Ihtot
operator|=
name|buf
operator|->
name|Ihflag
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|getr
argument_list|(
name|buf
argument_list|)
specifier|register
expr|struct
name|Ibufr
operator|*
name|buf
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|short
modifier|*
name|w
decl_stmt|;
name|short
name|i
decl_stmt|,
name|n
decl_stmt|;
name|buf
operator|->
name|Irecptr
operator|=
operator|+
name|buf
operator|->
name|Ilen
operator|+
operator|!
operator|(
name|buf
operator|->
name|Ilen
operator|&
literal|1
operator|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|buf
operator|->
name|Ilen
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|Ilen
operator|=
operator|*
name|buf
operator|->
name|Irecptr
operator|+
literal|128
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|Irecptr
operator|<=
name|buf
operator|->
name|Iend
operator|-
operator|(
name|buf
operator|->
name|Ilen
operator|+
operator|!
operator|(
name|buf
operator|->
name|Ilen
operator|&
literal|1
operator|)
operator|)
condition|)
return|return
operator|(
operator|++
name|buf
operator|->
name|Irecptr
operator|)
return|;
if|if
condition|(
name|i
operator|++
operator|==
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|q
operator|=
name|buf
operator|->
name|Irecptr
expr_stmt|;
name|p
operator|=
name|buf
operator|->
name|Irecptr
operator|=
operator|-
literal|512
expr_stmt|;
while|while
condition|(
name|q
operator|<=
name|buf
operator|->
name|Iend
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|buf
operator|->
name|Ifildes
argument_list|,
name|buf
operator|->
name|Ibuff2
argument_list|,
literal|512
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|buf
operator|->
name|Iend
operator|=
name|buf
operator|->
name|Ibuff2
operator|+
name|n
operator|-
literal|1
expr_stmt|;
operator|*
operator|(
name|buf
operator|->
name|Iend
operator|+
literal|1
operator|)
operator|=
operator|-
literal|128
expr_stmt|;
name|w
operator|=
name|buf
operator|->
name|Ibuff2
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|Ihflag
operator|==
literal|0
condition|)
block|{
name|buf
operator|->
name|Ihflag
operator|=
literal|1
expr_stmt|;
name|buf
operator|->
name|Ihtot
operator|=
name|w
index|[
name|HASHADDR
operator|>>
literal|1
index|]
expr_stmt|;
name|w
index|[
name|HASHADDR
operator|>>
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
literal|512
condition|)
name|buf
operator|->
name|Ibuff2
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|Ihcnt
operator|=
operator|+
name|sumr
argument_list|(
name|w
argument_list|,
operator|&
name|w
index|[
operator|(
name|n
operator|&
literal|1
condition|?
name|n
operator|-
literal|1
else|:
name|n
operator|-
literal|2
operator|)
operator|>>
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|512
operator|&&
name|buf
operator|->
name|Ihtot
operator|&&
name|buf
operator|->
name|Ihcnt
operator|!=
name|buf
operator|->
name|Ihtot
condition|)
name|fatal
argument_list|(
literal|"corrupted file (201)"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|sumr
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
specifier|register
name|short
operator|*
name|from
operator|,
operator|*
name|to
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|short
name|sum
decl_stmt|;
for|for
control|(
name|sum
operator|=
literal|0
init|;
name|from
operator|<=
name|to
condition|;
control|)
name|sum
operator|=
operator|+
operator|*
name|from
operator|++
expr_stmt|;
return|return
operator|(
name|sum
operator|)
return|;
block|}
end_block

end_unit

