begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"stdio.h"
end_include

begin_include
include|#
directive|include
file|"seven/types.h"
end_include

begin_include
include|#
directive|include
file|"seven/macros.h"
end_include

begin_include
include|#
directive|include
file|"fatal.h"
end_include

begin_expr_stmt
name|SCCSID
argument_list|(
argument|@
operator|(
operator|#
operator|)
name|vc
operator|.
name|c
literal|4.3
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|USXALLOC
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The symbol table size is set to a limit of forty keywords per input  * file.  Should this limit be changed it should also be changed in the  * Help file.  */
end_comment

begin_define
define|#
directive|define
name|SYMSIZE
value|40
end_define

begin_define
define|#
directive|define
name|PARMSIZE
value|10
end_define

begin_define
define|#
directive|define
name|NSLOTS
value|32
end_define

begin_define
define|#
directive|define
name|USD
value|1
end_define

begin_define
define|#
directive|define
name|DCL
value|2
end_define

begin_define
define|#
directive|define
name|ASG
value|4
end_define

begin_define
define|#
directive|define
name|EQ
value|'='
end_define

begin_define
define|#
directive|define
name|NEQ
value|'!'
end_define

begin_define
define|#
directive|define
name|GT
value|'>'
end_define

begin_define
define|#
directive|define
name|LT
value|'<'
end_define

begin_define
define|#
directive|define
name|DELIM
value|" \t"
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_expr_stmt
name|char
name|Ctlchar
literal|':'
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|symtab
block|{
name|int
name|usage
decl_stmt|;
name|char
name|name
index|[
name|PARMSIZE
index|]
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|lenval
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|symtab
name|Sym
index|[
name|SYMSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
block|{
name|char
name|chr
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|Skiptabs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Repall
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Delflag is used to indicate when text is to be skipped.  It is decre-  * mented whenever an if condition is false, or when an if occurs  * within a false if/end statement.  It is decremented whenever an end is  * encountered and the Delflag is greater than zero.  Whenever Delflag  * is greater than zero text is skipped.  */
end_comment

begin_decl_stmt
name|int
name|Delflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Ifcount keeps track of the number of ifs and ends.  Each time  * an if is encountered Ifcount is incremented and each time an end is  * encountered it is decremented.  */
end_comment

begin_decl_stmt
name|int
name|Ifcount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Lineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Repflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Linend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Silent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The main program reads a line of text and sends it to be processed  * if it is a version control statement. If it is a line of text and  * the Delflag is equal to zero, it is written to the standard output.  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|lineptr
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|line
index|[
literal|512
index|]
decl_stmt|;
specifier|extern
name|int
name|Fflags
decl_stmt|;
name|Fflags
operator|=
name|FTLCLN
operator||
name|FTLMSG
operator||
name|FTLEXIT
expr_stmt|;
name|setsig
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'s'
case|:
name|Silent
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|Skiptabs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|Repall
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|Ctlchar
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
break|break;
block|}
else|else
block|{
name|p
index|[
name|size
argument_list|(
name|p
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
name|asgfunc
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|lineptr
operator|=
name|line
expr_stmt|;
name|Lineno
operator|++
expr_stmt|;
if|if
condition|(
name|Repflag
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|Repflag
argument_list|)
expr_stmt|;
name|Repflag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|Skiptabs
condition|)
block|{
for|for
control|(
name|p
operator|=
name|lineptr
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\t'
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\t'
condition|)
name|lineptr
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|lineptr
index|[
literal|0
index|]
operator|!=
name|Ctlchar
condition|)
block|{
if|if
condition|(
name|lineptr
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|lineptr
index|[
literal|1
index|]
operator|==
name|Ctlchar
condition|)
for|for
control|(
name|p
operator|=
operator|&
name|lineptr
index|[
literal|1
index|]
init|;
operator|*
name|lineptr
operator|++
operator|=
operator|*
name|p
operator|++
condition|;
control|)
empty_stmt|;
if|if
condition|(
name|Delflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|Repall
condition|)
name|repfunc
argument_list|(
name|line
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|line
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|lineptr
operator|++
expr_stmt|;
if|if
condition|(
name|imatch
argument_list|(
literal|"if "
argument_list|,
name|lineptr
argument_list|)
condition|)
name|iffunc
argument_list|(
operator|&
name|lineptr
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|imatch
argument_list|(
literal|"end"
argument_list|,
name|lineptr
argument_list|)
condition|)
name|endfunc
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|Delflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|imatch
argument_list|(
literal|"asg "
argument_list|,
name|lineptr
argument_list|)
condition|)
name|asgfunc
argument_list|(
operator|&
name|lineptr
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|imatch
argument_list|(
literal|"dcl "
argument_list|,
name|lineptr
argument_list|)
condition|)
name|dclfunc
argument_list|(
operator|&
name|lineptr
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|imatch
argument_list|(
literal|"err"
argument_list|,
name|lineptr
argument_list|)
condition|)
name|errfunc
argument_list|(
operator|&
name|lineptr
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|imatch
argument_list|(
literal|"msg"
argument_list|,
name|lineptr
argument_list|)
condition|)
name|msgfunc
argument_list|(
operator|&
name|lineptr
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lineptr
index|[
literal|0
index|]
operator|==
name|Ctlchar
condition|)
name|repfunc
argument_list|(
operator|&
name|lineptr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|imatch
argument_list|(
literal|"on"
argument_list|,
name|lineptr
argument_list|)
condition|)
name|Repall
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|imatch
argument_list|(
literal|"off"
argument_list|,
name|lineptr
argument_list|)
condition|)
name|Repall
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|imatch
argument_list|(
literal|"ctl "
argument_list|,
name|lineptr
argument_list|)
condition|)
name|Ctlchar
operator|=
name|lineptr
index|[
literal|4
index|]
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unknown command on line %d (901)"
argument_list|,
name|Lineno
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|Sym
index|[
name|i
index|]
operator|.
name|usage
operator|!=
literal|0
operator|&&
name|i
operator|<
name|SYMSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|Sym
index|[
name|i
index|]
operator|.
name|usage
operator|&
name|USD
operator|)
operator|==
literal|0
condition|)
name|warn
argument_list|(
literal|"`%s' never used (902)\n"
argument_list|,
name|Sym
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Sym
index|[
name|i
index|]
operator|.
name|usage
operator|&
name|DCL
operator|)
operator|==
literal|0
condition|)
name|warn
argument_list|(
literal|"`%s' never declared (903)\n"
argument_list|,
name|Sym
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Sym
index|[
name|i
index|]
operator|.
name|usage
operator|&
name|ASG
operator|)
operator|==
literal|0
condition|)
name|warn
argument_list|(
literal|"`%s' never assigned a value (920)\n"
argument_list|,
name|Sym
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Ifcount
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|"`if' with no matching `end' (904)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Asgfunc accepts a pointer to a line picks up a keyword name, an  * equal sign and a value and calls putin to place it in the symbol table.  */
end_comment

begin_expr_stmt
name|asgfunc
argument_list|(
name|aptr
argument_list|)
specifier|register
name|char
operator|*
name|aptr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|end
decl_stmt|,
modifier|*
name|aname
decl_stmt|;
name|char
modifier|*
name|avalue
decl_stmt|;
name|aptr
operator|=
name|replace
argument_list|(
name|aptr
argument_list|)
expr_stmt|;
name|NONBLANK
argument_list|(
name|aptr
argument_list|)
expr_stmt|;
name|aname
operator|=
name|aptr
expr_stmt|;
name|end
operator|=
name|Linend
expr_stmt|;
name|aptr
operator|=
name|findstr
argument_list|(
name|aptr
argument_list|,
literal|"= \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|aptr
operator|==
literal|' '
operator|||
operator|*
name|aptr
operator|==
literal|'\t'
condition|)
block|{
operator|*
name|aptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|aptr
operator|=
name|findch
argument_list|(
name|aptr
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aptr
operator|==
name|end
condition|)
name|error
argument_list|(
literal|"syntax on line %d (917)"
argument_list|,
name|Lineno
argument_list|)
expr_stmt|;
operator|*
name|aptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|avalue
operator|=
name|getid
argument_list|(
name|aptr
argument_list|)
expr_stmt|;
name|chksize
argument_list|(
name|aname
argument_list|)
expr_stmt|;
name|putin
argument_list|(
name|aname
argument_list|,
name|avalue
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Dclfunc accepts a pointer to a line and picks up keywords  * separated by commas.  It calls putin to put each keyword in the  * symbol table.  It returns when it sees a newline.  */
end_comment

begin_expr_stmt
name|dclfunc
argument_list|(
name|dptr
argument_list|)
specifier|register
name|char
operator|*
name|dptr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|end
decl_stmt|,
modifier|*
name|dname
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dptr
operator|=
name|replace
argument_list|(
name|dptr
argument_list|)
expr_stmt|;
name|end
operator|=
name|Linend
expr_stmt|;
name|NONBLANK
argument_list|(
name|dptr
argument_list|)
expr_stmt|;
while|while
condition|(
name|dptr
operator|<
name|end
condition|)
block|{
name|dname
operator|=
name|dptr
expr_stmt|;
name|dptr
operator|=
name|findch
argument_list|(
name|dptr
argument_list|,
literal|','
argument_list|)
expr_stmt|;
operator|*
name|dptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|chksize
argument_list|(
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|Sym
index|[
name|i
operator|=
name|lookup
argument_list|(
name|dname
argument_list|)
index|]
operator|.
name|usage
operator|&
name|DCL
condition|)
name|error
argument_list|(
literal|"`%s' declared twice on line %d (905)"
argument_list|,
name|dname
argument_list|,
name|Lineno
argument_list|)
expr_stmt|;
else|else
name|Sym
index|[
name|i
index|]
operator|.
name|usage
operator||=
name|DCL
expr_stmt|;
name|NONBLANK
argument_list|(
name|dptr
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Errfunc calls fatal which stops the process.  */
end_comment

begin_macro
name|errfunc
argument_list|(
argument|eptr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|eptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|warn
argument_list|(
literal|"ERROR:%s\n"
argument_list|,
name|replace
argument_list|(
name|eptr
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"err statement on line %d (915)"
argument_list|,
name|Lineno
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Endfunc indicates an end has been found by decrementing the if count  * flag.  If because of a previous if statement, text was being skipped,  * Delflag is also decremented.  */
end_comment

begin_macro
name|endfunc
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|--
name|Ifcount
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"`end' without matching `if' on line %d (910)"
argument_list|,
name|Lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|Delflag
operator|>
literal|0
condition|)
name|Delflag
operator|--
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * Msgfunc accepts a pointer to a line and prints that line on the   * diagnostic output.  */
end_comment

begin_macro
name|msgfunc
argument_list|(
argument|mptr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|warn
argument_list|(
literal|"Message(%d):%s\n"
argument_list|,
name|Lineno
argument_list|,
name|replace
argument_list|(
name|mptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|repfunc
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|replace
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Iffunc and the three functions following it, door, doand, and exp  * are responsible for parsing and interperting the condition in the  * if statement.  The BNF used is as follows:  *<iffunc> ::=   [ "not" ]<door> EOL  *<door> ::=<doand> |<doand> "|"<door>  *<doand>::=<exp> |<exp> "&"<doand>  *<exp>::=       "("<door> ")" |<value><operator><value>  *<operator>::=  "=" | "!=" | "<" | ">"  * And has precedence over or.  If the condition is false the Delflag  * is bumped to indicate that lines are to be skipped.  * An external variable, sptr is used for processing the line in  * iffunc, door, doand, exp, getid.  * Iffunc accepts a pointer to a line and sets sptr to that line.  The  * rest of iffunc, door, and doand follow the BNF exactly.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sptr
decl_stmt|;
end_decl_stmt

begin_macro
name|iffunc
argument_list|(
argument|iptr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|iptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|value
decl_stmt|,
name|not
decl_stmt|;
name|Ifcount
operator|++
expr_stmt|;
if|if
condition|(
name|Delflag
operator|>
literal|0
condition|)
name|Delflag
operator|++
expr_stmt|;
else|else
block|{
name|sptr
operator|=
name|replace
argument_list|(
name|iptr
argument_list|)
expr_stmt|;
name|NONBLANK
argument_list|(
name|sptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|imatch
argument_list|(
literal|"not "
argument_list|,
name|sptr
argument_list|)
condition|)
block|{
name|not
operator|=
name|FALSE
expr_stmt|;
name|sptr
operator|+=
literal|4
expr_stmt|;
block|}
else|else
name|not
operator|=
name|TRUE
expr_stmt|;
name|value
operator|=
name|door
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|sptr
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"syntax on line %d (918)"
argument_list|,
name|Lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|not
condition|)
name|Delflag
operator|++
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_macro
name|door
argument_list|()
end_macro

begin_block
block|{
name|int
name|value
decl_stmt|;
name|value
operator|=
name|doand
argument_list|()
expr_stmt|;
name|NONBLANK
argument_list|(
name|sptr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|sptr
operator|==
literal|'|'
condition|)
block|{
name|sptr
operator|++
expr_stmt|;
name|value
operator||=
name|doand
argument_list|()
expr_stmt|;
name|NONBLANK
argument_list|(
name|sptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_block

begin_macro
name|doand
argument_list|()
end_macro

begin_block
block|{
name|int
name|value
decl_stmt|;
name|value
operator|=
name|exp
argument_list|()
expr_stmt|;
name|NONBLANK
argument_list|(
name|sptr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|sptr
operator|==
literal|'&'
condition|)
block|{
name|sptr
operator|++
expr_stmt|;
name|value
operator|&=
name|exp
argument_list|()
expr_stmt|;
name|NONBLANK
argument_list|(
name|sptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * After exp checks for parentheses, it picks up a value by calling getid,  * picks up an operator and calls getid to pick up the second value.  * Then based on the operator it calls either numcomp or equal to see  * if the exp is true or false and returns the correct value.  */
end_comment

begin_macro
name|exp
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
name|op
decl_stmt|,
name|save
decl_stmt|;
specifier|register
name|int
name|value
decl_stmt|;
name|char
modifier|*
name|id1
decl_stmt|,
modifier|*
name|id2
decl_stmt|,
name|next
decl_stmt|;
name|NONBLANK
argument_list|(
name|sptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sptr
operator|==
literal|'('
condition|)
block|{
name|sptr
operator|++
expr_stmt|;
name|value
operator|=
name|door
argument_list|()
expr_stmt|;
name|NONBLANK
argument_list|(
name|sptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sptr
operator|==
literal|')'
condition|)
block|{
name|sptr
operator|++
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
else|else
name|error
argument_list|(
literal|"parenthesis error on line %d (911)"
argument_list|,
name|Lineno
argument_list|)
expr_stmt|;
block|}
name|id1
operator|=
name|getid
argument_list|(
name|sptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|=
operator|*
name|sptr
condition|)
operator|*
name|sptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|NEQ
operator|&&
operator|(
name|next
operator|=
operator|*
name|sptr
operator|++
operator|)
operator|==
literal|'\0'
condition|)
operator|--
name|sptr
expr_stmt|;
name|id2
operator|=
name|getid
argument_list|(
name|sptr
argument_list|)
expr_stmt|;
name|save
operator|=
operator|*
name|sptr
expr_stmt|;
operator|*
name|sptr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|LT
operator|||
name|op
operator|==
name|GT
condition|)
block|{
name|value
operator|=
name|numcomp
argument_list|(
name|id1
argument_list|,
name|id2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|==
name|GT
operator|&&
name|value
operator|==
literal|1
operator|)
operator|||
operator|(
name|op
operator|==
name|LT
operator|&&
name|value
operator|==
operator|-
literal|1
operator|)
condition|)
name|value
operator|=
name|TRUE
expr_stmt|;
else|else
name|value
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|EQ
operator|||
operator|(
name|op
operator|==
name|NEQ
operator|&&
name|next
operator|==
name|EQ
operator|)
condition|)
block|{
name|value
operator|=
name|equal
argument_list|(
name|id1
argument_list|,
name|id2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|NEQ
condition|)
name|value
operator|=
operator|!
name|value
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"invalid operator on line %d (912)"
argument_list|,
name|Lineno
argument_list|)
expr_stmt|;
operator|*
name|sptr
operator|=
name|save
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Getid picks up a value off a line and returns a pointer to the value.  */
end_comment

begin_expr_stmt
name|getid
argument_list|(
name|gptr
argument_list|)
specifier|register
name|char
operator|*
name|gptr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|,
modifier|*
name|id
decl_stmt|;
name|NONBLANK
argument_list|(
name|gptr
argument_list|)
expr_stmt|;
name|id
operator|=
name|gptr
expr_stmt|;
name|gptr
operator|=
name|findstr
argument_list|(
name|gptr
argument_list|,
name|DELIM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|gptr
condition|)
operator|*
name|gptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|NONBLANK
argument_list|(
name|gptr
argument_list|)
expr_stmt|;
name|sptr
operator|=
name|gptr
expr_stmt|;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Numcomp accepts two pointers to strings of digits and calls numck  * to see if the strings contain only digits.  It returns -1 if  * the first is less than the second, 1 if the first is greater than the  * second and 0 if the two are equal.  */
end_comment

begin_expr_stmt
name|numcomp
argument_list|(
name|id1
argument_list|,
name|id2
argument_list|)
specifier|register
name|char
operator|*
name|id1
operator|,
operator|*
name|id2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|k1
decl_stmt|,
name|k2
decl_stmt|;
name|numck
argument_list|(
name|id1
argument_list|)
expr_stmt|;
name|numck
argument_list|(
name|id2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|id1
operator|==
literal|'0'
condition|)
name|id1
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|id2
operator|==
literal|'0'
condition|)
name|id2
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|k1
operator|=
name|size
argument_list|(
name|id1
argument_list|)
operator|)
operator|>
operator|(
name|k2
operator|=
name|size
argument_list|(
name|id2
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|k1
operator|<
name|k2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
while|while
condition|(
operator|*
name|id1
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|id1
operator|>
operator|*
name|id2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
operator|*
name|id1
operator|<
operator|*
name|id2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|id1
operator|++
expr_stmt|;
name|id2
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Numck accepts a pointer to a string and checks to see if they are  * all digits.  If they're not it calls fatal, otherwise it returns.  */
end_comment

begin_expr_stmt
name|numck
argument_list|(
name|nptr
argument_list|)
specifier|register
name|char
operator|*
name|nptr
expr_stmt|;
end_expr_stmt

begin_block
block|{
for|for
control|(
init|;
operator|*
name|nptr
operator|!=
literal|'\0'
condition|;
name|nptr
operator|++
control|)
if|if
condition|(
operator|!
name|numeric
argument_list|(
operator|*
name|nptr
argument_list|)
condition|)
name|error
argument_list|(
literal|"non-numerical value on line %d (914)"
argument_list|,
name|Lineno
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * Replace accepts a pointer to a line and scans the line for a keyword  * enclosed in control characters.  If it doesn't find one it returns  * a pointer to the begining of the line.  Otherwise, it calls  * lookup to find the keyword.  * It rewrites the line substituting the value for the  * keyword enclosed in control characters.  It then continues scanning  * the line until no control characters are found and returns a pointer to  * the begining of the new line.  */
end_comment

begin_define
define|#
directive|define
name|INCR
parameter_list|(
name|int
parameter_list|)
value|if (++int==NSLOTS) error(subrng,Lineno)
end_define

begin_expr_stmt
name|char
operator|*
name|subrng
literal|"out of space [line %d] (916)"
expr_stmt|;
end_expr_stmt

begin_macro
name|replace
argument_list|(
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|slots
index|[
name|NSLOTS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|newlen
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|s
operator|=
name|ptr
init|;
operator|*
name|s
operator|++
operator|!=
literal|'\n'
condition|;
control|)
empty_stmt|;
operator|*
operator|(
operator|--
name|s
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|Linend
operator|=
name|s
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ptr
init|;
operator|*
operator|(
name|s
operator|=
name|findch
argument_list|(
name|p
argument_list|,
name|Ctlchar
argument_list|)
operator|)
condition|;
name|p
operator|=
name|t
control|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|INCR
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|slots
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|t
operator|=
name|findch
argument_list|(
name|s
argument_list|,
name|Ctlchar
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"unmatched `%c' on line %d (907)"
argument_list|,
name|Ctlchar
argument_list|,
name|Lineno
argument_list|)
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|INCR
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|slots
index|[
name|i
index|]
operator|=
name|Sym
index|[
name|j
operator|=
name|lookup
argument_list|(
name|s
argument_list|)
index|]
operator|.
name|value
expr_stmt|;
name|Sym
index|[
name|j
index|]
operator|.
name|usage
operator||=
name|USD
expr_stmt|;
block|}
name|INCR
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|slots
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
name|newlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|i
condition|;
name|j
operator|++
control|)
name|newlen
operator|+=
operator|(
name|size
argument_list|(
name|slots
index|[
name|j
index|]
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|t
operator|=
name|Repflag
operator|=
name|alloc
argument_list|(
operator|++
name|newlen
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|i
condition|;
name|j
operator|++
control|)
name|t
operator|=
name|ecopy
argument_list|(
name|slots
index|[
name|j
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|Linend
operator|=
name|t
expr_stmt|;
return|return
operator|(
name|Repflag
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Lookup accepts a pointer to a keyword name and searches the symbol  * table for the keyword.  It returns its index in the table if its there,  * otherwise it puts the keyword in the table.  */
end_comment

begin_macro
name|lookup
argument_list|(
argument|lname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|lname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|t
operator|=
name|lname
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|.
name|chr
operator|=
operator|*
name|t
operator|++
operator|)
operator|&&
operator|(
operator|(
name|i
operator|.
name|chr
operator|>=
literal|'A'
operator|&&
name|i
operator|.
name|chr
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|i
operator|.
name|chr
operator|>=
literal|'a'
operator|&&
name|i
operator|.
name|chr
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|i
operator|.
name|chr
operator|!=
operator|*
name|lname
operator|&&
name|i
operator|.
name|chr
operator|>=
literal|'0'
operator|&&
name|i
operator|.
name|chr
operator|<=
literal|'9'
operator|)
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|i
operator|.
name|chr
condition|)
name|error
argument_list|(
literal|"invalid keyword name on line %d (909)"
argument_list|,
name|Lineno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|Sym
index|[
name|i
index|]
operator|.
name|usage
operator|!=
literal|0
operator|&&
name|i
operator|<
name|SYMSIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|equal
argument_list|(
name|lname
argument_list|,
name|Sym
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
return|return
operator|(
name|i
operator|)
return|;
name|s
operator|=
operator|&
name|Sym
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|usage
operator|==
literal|0
condition|)
block|{
name|copy
argument_list|(
name|lname
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|copy
argument_list|(
literal|""
argument_list|,
operator|(
name|s
operator|->
name|value
operator|=
name|alloc
argument_list|(
name|s
operator|->
name|lenval
operator|=
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
name|error
argument_list|(
literal|"out of space (906)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Putin accepts a pointer to a keyword name, and a pointer to a value.  * It puts this information in the symbol table by calling lookup.  * It returns the index of the name in the table.  */
end_comment

begin_macro
name|putin
argument_list|(
argument|pname
argument_list|,
argument|pvalue
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|pname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pvalue
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|s
operator|=
operator|&
name|Sym
index|[
name|i
operator|=
name|lookup
argument_list|(
name|pname
argument_list|)
index|]
expr_stmt|;
name|free
argument_list|(
name|s
operator|->
name|value
argument_list|)
expr_stmt|;
name|s
operator|->
name|lenval
operator|=
name|size
argument_list|(
name|pvalue
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|pvalue
argument_list|,
operator|(
name|s
operator|->
name|value
operator|=
name|alloc
argument_list|(
name|s
operator|->
name|lenval
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|usage
operator||=
name|ASG
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|chksize
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|size
argument_list|(
name|s
argument_list|)
operator|>
name|PARMSIZE
condition|)
name|error
argument_list|(
literal|"keyword name too long on line %d (908)"
argument_list|,
name|Lineno
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|findch
argument_list|(
argument|astr
argument_list|,
argument|match
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|astr
decl_stmt|,
name|match
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|s
operator|=
name|astr
init|;
operator|(
name|c
operator|=
operator|*
name|s
operator|)
operator|&&
name|c
operator|!=
name|match
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"syntax on line %d (919)"
argument_list|,
name|Lineno
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|t
operator|=
operator|(
name|temp
operator|=
name|s
operator|)
operator|+
literal|1
init|;
operator|*
name|s
operator|++
operator|=
operator|*
name|t
operator|++
condition|;
control|)
empty_stmt|;
name|s
operator|=
name|temp
expr_stmt|;
block|}
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_block

begin_macro
name|ecopy
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|r1
decl_stmt|,
modifier|*
name|r2
decl_stmt|;
name|r1
operator|=
name|s1
expr_stmt|;
name|r2
operator|=
name|s2
expr_stmt|;
while|while
condition|(
operator|*
name|r2
operator|++
operator|=
operator|*
name|r1
operator|++
condition|)
empty_stmt|;
return|return
operator|(
operator|--
name|r2
operator|)
return|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|arg
argument_list|)
end_macro

begin_block
block|{
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"%r"
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
name|Error
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|findstr
argument_list|(
argument|astr
argument_list|,
argument|pat
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|astr
decl_stmt|,
modifier|*
name|pat
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|s
operator|=
name|astr
init|;
operator|(
name|c
operator|=
operator|*
name|s
operator|)
operator|&&
name|any
argument_list|(
name|c
argument_list|,
name|pat
argument_list|)
operator|==
literal|0
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"syntax on line %d (919)"
argument_list|,
name|Lineno
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|t
operator|=
operator|(
name|temp
operator|=
name|s
operator|)
operator|+
literal|1
init|;
operator|*
name|s
operator|++
operator|=
operator|*
name|t
operator|++
condition|;
control|)
empty_stmt|;
name|s
operator|=
name|temp
expr_stmt|;
block|}
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_block

begin_macro
name|warn
argument_list|(
argument|arg
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|Silent
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%r"
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

