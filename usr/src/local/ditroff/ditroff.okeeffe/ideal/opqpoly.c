begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"opqpoly.c	(CWI)	1.1	85/03/01"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ideal.h"
end_include

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_decl_stmt
specifier|extern
name|float
name|interalpha
index|[
name|INTERSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|internum
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|opqpoly
parameter_list|(
name|edgelist
parameter_list|,
name|linelist
parameter_list|,
name|inlines
parameter_list|,
name|outlines
parameter_list|,
name|both
parameter_list|)
name|EDGEPTR
name|edgelist
decl_stmt|;
name|LINEPTR
name|linelist
decl_stmt|;
name|LINEPTR
modifier|*
name|inlines
decl_stmt|,
decl|*
name|outlines
decl_stmt|,
modifier|*
name|both
decl_stmt|;
end_function

begin_block
block|{
name|LINEPTR
name|linewalk
decl_stmt|,
name|circlearc
decl_stmt|;
name|LINENODE
name|nuin
decl_stmt|,
name|nuout
decl_stmt|,
name|nuboth
decl_stmt|;
name|LINEPTR
name|inwalk
decl_stmt|,
name|outwalk
decl_stmt|,
name|bothwalk
decl_stmt|;
name|LINEPTR
name|forfreeing
decl_stmt|;
name|inwalk
operator|=
operator|&
name|nuin
expr_stmt|;
name|inwalk
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|outwalk
operator|=
operator|&
name|nuout
expr_stmt|;
name|outwalk
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|bothwalk
operator|=
operator|&
name|nuboth
expr_stmt|;
name|bothwalk
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|linewalk
operator|=
name|linelist
expr_stmt|;
while|while
condition|(
name|linewalk
condition|)
block|{
while|while
condition|(
name|inwalk
operator|->
name|next
condition|)
name|inwalk
operator|=
name|inwalk
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|outwalk
operator|->
name|next
condition|)
name|outwalk
operator|=
name|outwalk
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|bothwalk
operator|->
name|next
condition|)
name|bothwalk
operator|=
name|bothwalk
operator|->
name|next
expr_stmt|;
switch|switch
condition|(
name|linewalk
operator|->
name|kind
condition|)
block|{
case|case
name|LINE
case|:
name|polyline
argument_list|(
name|edgelist
argument_list|,
name|linewalk
operator|->
name|x0
argument_list|,
name|linewalk
operator|->
name|y0
argument_list|,
name|linewalk
operator|->
name|x1
argument_list|,
name|linewalk
operator|->
name|y1
argument_list|,
operator|&
name|inwalk
operator|->
name|next
argument_list|,
operator|&
name|outwalk
operator|->
name|next
argument_list|,
operator|&
name|bothwalk
operator|->
name|next
argument_list|)
expr_stmt|;
name|forfreeing
operator|=
name|linewalk
expr_stmt|;
name|linewalk
operator|=
name|linewalk
operator|->
name|next
expr_stmt|;
name|tryfree
argument_list|(
name|forfreeing
argument_list|)
expr_stmt|;
break|break;
case|case
name|CIRCLE
case|:
name|circlearc
operator|=
name|angularc
argument_list|(
operator|(
operator|(
name|CIRCPTR
operator|)
name|linewalk
operator|)
operator|->
name|x0
argument_list|,
operator|(
operator|(
name|CIRCPTR
operator|)
name|linewalk
operator|)
operator|->
name|y0
argument_list|,
operator|(
operator|(
name|CIRCPTR
operator|)
name|linewalk
operator|)
operator|->
name|r
argument_list|,
literal|0.0
argument_list|,
literal|2.0
operator|*
name|PI
argument_list|)
expr_stmt|;
name|circlearc
operator|->
name|next
operator|=
name|linewalk
operator|->
name|next
expr_stmt|;
name|tryfree
argument_list|(
name|linewalk
argument_list|)
expr_stmt|;
name|linewalk
operator|=
name|circlearc
expr_stmt|;
comment|/* FALL THROUGH TO case arc */
case|case
name|ARC
case|:
name|polyarc
argument_list|(
name|edgelist
argument_list|,
operator|(
operator|(
name|ARCPTR
operator|)
name|linewalk
operator|)
operator|->
name|x0
argument_list|,
operator|(
operator|(
name|ARCPTR
operator|)
name|linewalk
operator|)
operator|->
name|y0
argument_list|,
operator|(
operator|(
name|ARCPTR
operator|)
name|linewalk
operator|)
operator|->
name|radius
argument_list|,
operator|(
operator|(
name|ARCPTR
operator|)
name|linewalk
operator|)
operator|->
name|theta1
argument_list|,
operator|(
operator|(
name|ARCPTR
operator|)
name|linewalk
operator|)
operator|->
name|theta2
argument_list|,
operator|&
name|inwalk
operator|->
name|next
argument_list|,
operator|&
name|outwalk
operator|->
name|next
argument_list|,
operator|&
name|bothwalk
operator|->
name|next
argument_list|)
expr_stmt|;
name|forfreeing
operator|=
name|linewalk
expr_stmt|;
name|linewalk
operator|=
name|linewalk
operator|->
name|next
expr_stmt|;
name|tryfree
argument_list|(
name|forfreeing
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
comment|/* 			fprintf (stderr, "ideal: can't opaque over strings\n"); */
name|bothwalk
operator|->
name|next
operator|=
name|linewalk
expr_stmt|;
name|linewalk
operator|=
name|linewalk
operator|->
name|next
expr_stmt|;
name|bothwalk
operator|->
name|next
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|SPLINE
case|:
comment|/* 			fprintf (stderr, "ideal: can't opaque over splines\n"); */
name|bothwalk
operator|->
name|next
operator|=
name|linewalk
expr_stmt|;
name|linewalk
operator|=
name|linewalk
operator|->
name|next
expr_stmt|;
name|bothwalk
operator|->
name|next
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|impossible
argument_list|(
literal|"opqpoly"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
comment|/* while */
operator|*
name|inlines
operator|=
name|nuin
operator|.
name|next
expr_stmt|;
operator|*
name|outlines
operator|=
name|nuout
operator|.
name|next
expr_stmt|;
operator|*
name|both
operator|=
name|nuboth
operator|.
name|next
expr_stmt|;
block|}
end_block

begin_comment
comment|/* opqpoly */
end_comment

begin_function
name|void
name|polyline
parameter_list|(
name|edgelist
parameter_list|,
name|candx0
parameter_list|,
name|candy0
parameter_list|,
name|candx1
parameter_list|,
name|candy1
parameter_list|,
name|inlines
parameter_list|,
name|outlines
parameter_list|,
name|both
parameter_list|)
name|EDGEPTR
name|edgelist
decl_stmt|;
name|float
name|candx0
decl_stmt|,
name|candy0
decl_stmt|,
name|candx1
decl_stmt|,
name|candy1
decl_stmt|;
name|LINEPTR
modifier|*
name|inlines
decl_stmt|,
decl|*
name|outlines
decl_stmt|,
modifier|*
name|both
decl_stmt|;
end_function

begin_block
block|{
name|OPQPTR
name|interwalk
decl_stmt|;
name|boolean
name|inside
decl_stmt|,
name|onedge
decl_stmt|;
name|LINENODE
name|nuin
decl_stmt|,
name|nuout
decl_stmt|;
name|LINEPTR
name|inwalk
decl_stmt|,
name|outwalk
decl_stmt|;
name|LINEPTR
name|linewalk
decl_stmt|;
name|EDGEPTR
name|prevedge
decl_stmt|,
name|curedge
decl_stmt|;
name|OPQPTR
name|alphalist
decl_stmt|;
name|float
name|alpha
decl_stmt|,
name|beta
decl_stmt|;
name|float
name|gamma
index|[
literal|2
index|]
decl_stmt|,
name|theta
index|[
literal|2
index|]
decl_stmt|;
name|boolean
name|collinear
decl_stmt|;
name|boolean
name|X
decl_stmt|,
name|Y
decl_stmt|,
name|Z
decl_stmt|,
name|W
decl_stmt|;
name|int
name|i
decl_stmt|;
name|double
name|dummy
decl_stmt|,
name|rem
decl_stmt|;
name|alphalist
operator|=
operator|(
name|OPQPTR
operator|)
name|NULL
expr_stmt|;
name|inwalk
operator|=
operator|&
name|nuin
expr_stmt|;
name|inwalk
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|outwalk
operator|=
operator|&
name|nuout
expr_stmt|;
name|outwalk
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|curedge
operator|=
name|edgelist
expr_stmt|;
do|do
block|{
if|if
condition|(
name|curedge
operator|->
name|fax
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|llinter
argument_list|(
name|candx0
argument_list|,
name|candy0
argument_list|,
name|candx1
argument_list|,
name|candy1
argument_list|,
name|curedge
operator|->
name|sx
argument_list|,
name|curedge
operator|->
name|sy
argument_list|,
name|curedge
operator|->
name|ex
argument_list|,
name|curedge
operator|->
name|ey
argument_list|,
operator|&
name|alpha
argument_list|,
operator|&
name|beta
argument_list|,
operator|&
name|collinear
argument_list|)
condition|)
block|{
if|if
condition|(
name|EPSILON
operator|<
name|beta
operator|&&
name|beta
operator|<
literal|1.0
operator|-
name|EPSILON
condition|)
name|curedge
operator|->
name|code
index|[
literal|0
index|]
operator|=
name|SIMPLE
expr_stmt|;
elseif|else
if|if
condition|(
name|fabs
argument_list|(
name|beta
argument_list|)
operator|<
name|EPSILON
condition|)
name|curedge
operator|->
name|code
index|[
literal|0
index|]
operator|=
name|AT0
expr_stmt|;
elseif|else
if|if
condition|(
name|fabs
argument_list|(
literal|1.0
operator|-
name|beta
argument_list|)
operator|<
name|EPSILON
condition|)
name|curedge
operator|->
name|code
index|[
literal|0
index|]
operator|=
name|AT1
expr_stmt|;
else|else
name|curedge
operator|->
name|code
index|[
literal|0
index|]
operator|=
name|UNUSED
expr_stmt|;
name|curedge
operator|->
name|alpha
index|[
literal|0
index|]
operator|=
name|alpha
expr_stmt|;
name|curedge
operator|->
name|code
index|[
literal|1
index|]
operator|=
name|UNUSED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|collinear
condition|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|candx1
operator|-
name|candx0
argument_list|)
operator|<
name|EPSILON
condition|)
block|{
name|curedge
operator|->
name|alpha
index|[
literal|0
index|]
operator|=
operator|(
name|curedge
operator|->
name|sy
operator|-
name|candy0
operator|)
operator|/
operator|(
name|candy1
operator|-
name|candy0
operator|)
expr_stmt|;
name|curedge
operator|->
name|alpha
index|[
literal|1
index|]
operator|=
operator|(
name|curedge
operator|->
name|ey
operator|-
name|candy0
operator|)
operator|/
operator|(
name|candy1
operator|-
name|candy0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|curedge
operator|->
name|alpha
index|[
literal|0
index|]
operator|=
operator|(
name|curedge
operator|->
name|sx
operator|-
name|candx0
operator|)
operator|/
operator|(
name|candx1
operator|-
name|candx0
operator|)
expr_stmt|;
name|curedge
operator|->
name|alpha
index|[
literal|1
index|]
operator|=
operator|(
name|curedge
operator|->
name|ex
operator|-
name|candx0
operator|)
operator|/
operator|(
name|candx1
operator|-
name|candx0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|curedge
operator|->
name|alpha
index|[
literal|0
index|]
operator|<
name|curedge
operator|->
name|alpha
index|[
literal|1
index|]
condition|)
block|{
name|curedge
operator|->
name|code
index|[
literal|0
index|]
operator|=
name|ON0
expr_stmt|;
name|curedge
operator|->
name|code
index|[
literal|1
index|]
operator|=
name|ON1
expr_stmt|;
block|}
else|else
block|{
name|curedge
operator|->
name|code
index|[
literal|0
index|]
operator|=
name|ON1
expr_stmt|;
name|curedge
operator|->
name|code
index|[
literal|1
index|]
operator|=
name|ON0
expr_stmt|;
block|}
block|}
else|else
name|curedge
operator|->
name|code
index|[
literal|0
index|]
operator|=
name|curedge
operator|->
name|code
index|[
literal|1
index|]
operator|=
name|UNUSED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curedge
operator|->
name|fax
operator|->
name|kind
operator|==
name|ARC
condition|)
block|{
if|if
condition|(
operator|!
name|lcinter
argument_list|(
name|candx0
argument_list|,
name|candy0
argument_list|,
name|candx1
argument_list|,
name|candy1
argument_list|,
name|curedge
operator|->
name|fax
operator|->
name|x0
argument_list|,
name|curedge
operator|->
name|fax
operator|->
name|y0
argument_list|,
name|fabs
argument_list|(
name|curedge
operator|->
name|fax
operator|->
name|radius
argument_list|)
argument_list|,
operator|&
name|gamma
index|[
literal|0
index|]
argument_list|,
operator|&
name|theta
index|[
literal|0
index|]
argument_list|,
operator|&
name|gamma
index|[
literal|1
index|]
argument_list|,
operator|&
name|theta
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|curedge
operator|->
name|code
index|[
literal|0
index|]
operator|=
name|curedge
operator|->
name|code
index|[
literal|1
index|]
operator|=
name|UNUSED
expr_stmt|;
name|dprintf
literal|"line outside circle\n"
block|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|fabs
argument_list|(
name|theta
index|[
literal|0
index|]
operator|-
name|theta
index|[
literal|1
index|]
argument_list|)
operator|<
name|EPSILON
condition|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|theta
index|[
literal|0
index|]
operator|-
name|curedge
operator|->
name|fax
operator|->
name|theta1
argument_list|)
operator|<
name|EPSILON
condition|)
block|{
name|curedge
operator|->
name|alpha
index|[
literal|0
index|]
operator|=
name|gamma
index|[
literal|0
index|]
expr_stmt|;
name|curedge
operator|->
name|code
index|[
literal|0
index|]
operator|=
name|curedge
operator|->
name|flipped
condition|?
name|AT1
else|:
name|AT0
expr_stmt|;
name|dprintf
literal|"%d\n"
operator|,
name|curedge
operator|->
name|code
index|[
literal|0
index|]
block|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|fabs
argument_list|(
name|theta
index|[
literal|0
index|]
operator|-
name|curedge
operator|->
name|fax
operator|->
name|theta2
argument_list|)
operator|<
name|EPSILON
condition|)
block|{
name|curedge
operator|->
name|alpha
index|[
literal|0
index|]
operator|=
name|gamma
index|[
literal|0
index|]
expr_stmt|;
name|curedge
operator|->
name|code
index|[
literal|0
index|]
operator|=
name|curedge
operator|->
name|flipped
condition|?
name|AT0
else|:
name|AT1
expr_stmt|;
name|dprintf
literal|"%d\n"
operator|,
name|curedge
operator|->
name|code
index|[
literal|0
index|]
block|)
empty_stmt|;
block|}
do|else
block|{
name|curedge
operator|->
name|code
index|[
literal|0
index|]
operator|=
name|UNUSED
expr_stmt|;
name|dprintf
literal|"line tangent\n"
block|)
do|; 				}
name|curedge
operator|->
name|code
index|[
literal|1
index|]
operator|=
name|UNUSED
expr_stmt|;
block|}
end_block

begin_else
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|dprintf
literal|"disposition of %f\n"
operator|,
name|theta
index|[
name|i
index|]
block|)
empty_stmt|;
if|if
condition|(
name|curedge
operator|->
name|fax
operator|->
name|theta2
operator|<
literal|2.0
operator|*
name|PI
condition|)
block|{
if|if
condition|(
name|theta
index|[
name|i
index|]
operator|-
name|curedge
operator|->
name|fax
operator|->
name|theta1
operator|<
operator|-
name|EPSILON
operator|||
name|curedge
operator|->
name|fax
operator|->
name|theta2
operator|-
name|theta
index|[
name|i
index|]
operator|<
operator|-
name|EPSILON
condition|)
block|{
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|=
name|UNUSED
expr_stmt|;
name|dprintf
literal|"intersection off arc\n"
block|)
empty_stmt|;
continue|continue;
block|}
block|}
end_else

begin_if
if|if
condition|(
name|curedge
operator|->
name|fax
operator|->
name|theta2
operator|>=
literal|2.0
operator|*
name|PI
condition|)
block|{
if|if
condition|(
name|theta
index|[
name|i
index|]
operator|-
name|curedge
operator|->
name|fax
operator|->
name|theta1
operator|<
operator|-
name|EPSILON
operator|&&
name|curedge
operator|->
name|fax
operator|->
name|theta2
operator|-
name|theta
index|[
name|i
index|]
operator|<
literal|2.0
operator|*
name|PI
operator|-
name|EPSILON
condition|)
block|{
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|=
name|UNUSED
expr_stmt|;
name|dprintf
literal|"intersection off arc\n"
block|)
empty_stmt|;
continue|continue;
block|}
end_if

begin_expr_stmt
unit|} 					rem
operator|=
name|modf
argument_list|(
name|fabs
argument_list|(
name|theta
index|[
name|i
index|]
operator|-
name|curedge
operator|->
name|fax
operator|->
name|theta1
argument_list|)
operator|/
operator|(
literal|2
operator|*
name|PI
operator|)
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dprintf
literal|"rem1 = %f\n"
operator|,
name|rem
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
name|rem
operator|<
name|EPSILON
operator|||
name|fabs
argument_list|(
literal|1.0
operator|-
name|rem
argument_list|)
operator|<
name|EPSILON
condition|)
block|{
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
operator|=
name|gamma
index|[
name|i
index|]
expr_stmt|;
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|=
name|curedge
operator|->
name|flipped
condition|?
name|AT1
else|:
name|AT0
expr_stmt|;
name|dprintf
literal|"%d\n"
operator|,
name|curedge
operator|->
name|code
index|[
name|i
index|]
block|)
empty_stmt|;
end_if

begin_continue
continue|continue;
end_continue

begin_expr_stmt
unit|} 					rem
operator|=
name|modf
argument_list|(
name|fabs
argument_list|(
name|theta
index|[
name|i
index|]
operator|-
name|curedge
operator|->
name|fax
operator|->
name|theta2
argument_list|)
operator|/
operator|(
literal|2
operator|*
name|PI
operator|)
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dprintf
literal|"rem2 = %f\n"
operator|,
name|rem
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
name|rem
operator|<
name|EPSILON
operator|||
name|fabs
argument_list|(
literal|1.0
operator|-
name|rem
argument_list|)
operator|<
name|EPSILON
condition|)
block|{
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
operator|=
name|gamma
index|[
name|i
index|]
expr_stmt|;
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|=
name|curedge
operator|->
name|flipped
condition|?
name|AT0
else|:
name|AT1
expr_stmt|;
name|dprintf
literal|"%d\n"
operator|,
name|curedge
operator|->
name|code
index|[
name|i
index|]
block|)
empty_stmt|;
end_if

begin_continue
continue|continue;
end_continue

begin_expr_stmt
unit|} 					dprintf
literal|"simple\n"
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|=
name|SIMPLE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
operator|=
name|gamma
index|[
name|i
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} 			} 		} else
name|impossible
argument_list|(
literal|"polyline(A)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|curedge
operator|=
name|curedge
operator|->
name|next
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} while
operator|(
name|curedge
operator|!=
name|edgelist
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|dbg
condition|)
block|{
name|curedge
operator|=
name|edgelist
expr_stmt|;
do|do
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s (%f,%f); e (%f,%f)\n"
argument_list|,
name|curedge
operator|->
name|sx
argument_list|,
name|curedge
operator|->
name|sy
argument_list|,
name|curedge
operator|->
name|ex
argument_list|,
name|curedge
operator|->
name|ey
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"st (%f,%f); et (%f,%f)\n"
argument_list|,
name|curedge
operator|->
name|stx
argument_list|,
name|curedge
operator|->
name|sty
argument_list|,
name|curedge
operator|->
name|etx
argument_list|,
name|curedge
operator|->
name|ety
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|POSSINTER
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d %f\n"
argument_list|,
name|curedge
operator|->
name|code
index|[
name|i
index|]
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|curedge
operator|=
name|curedge
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|curedge
operator|!=
name|edgelist
condition|)
do|;
block|}
end_if

begin_expr_stmt
name|prevedge
operator|=
name|edgelist
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|curedge
operator|=
name|edgelist
operator|->
name|next
expr_stmt|;
end_expr_stmt

begin_do
do|do
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|POSSINTER
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|curedge
operator|->
name|code
index|[
name|i
index|]
condition|)
block|{
case|case
name|UNUSED
case|:
break|break;
case|case
name|SIMPLE
case|:
name|opqinsert
argument_list|(
name|SIMPLE
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|,
operator|&
name|alphalist
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT0
case|:
name|dprintf
literal|"vertex intersection at (%f,%f)\n"
operator|,
name|curedge
operator|->
name|sx
operator|,
name|curedge
operator|->
name|sy
block|)
empty_stmt|;
name|X
operator|=
name|arecollinear
argument_list|(
name|curedge
operator|->
name|sx
argument_list|,
name|curedge
operator|->
name|sy
argument_list|,
name|curedge
operator|->
name|stx
argument_list|,
name|curedge
operator|->
name|sty
argument_list|,
name|prevedge
operator|->
name|etx
argument_list|,
name|prevedge
operator|->
name|ety
argument_list|)
expr_stmt|;
name|Y
operator|=
name|between
argument_list|(
name|curedge
operator|->
name|stx
argument_list|,
name|curedge
operator|->
name|sty
argument_list|,
name|curedge
operator|->
name|sx
argument_list|,
name|curedge
operator|->
name|sy
argument_list|,
name|prevedge
operator|->
name|etx
argument_list|,
name|prevedge
operator|->
name|ety
argument_list|)
expr_stmt|;
name|Z
operator|=
name|arecollinear
argument_list|(
name|candx0
argument_list|,
name|candy0
argument_list|,
name|candx1
argument_list|,
name|candy1
argument_list|,
name|curedge
operator|->
name|stx
argument_list|,
name|curedge
operator|->
name|sty
argument_list|)
expr_stmt|;
name|dprintf
literal|"X=%d Y=%d Z=%d\n"
operator|,
name|X
operator|,
name|Y
operator|,
name|Z
block|)
empty_stmt|;
do|if (X&& !Z
end_do

begin_block
unit|)
block|{
if|if
condition|(
name|Y
condition|)
name|opqinsert
argument_list|(
name|SIMPLE
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|,
operator|&
name|alphalist
argument_list|)
expr_stmt|;
break|break;
block|}
end_block

begin_if
if|if
condition|(
name|X
operator|&&
name|Z
condition|)
block|{
if|if
condition|(
name|llinter
argument_list|(
name|prevedge
operator|->
name|sx
argument_list|,
name|prevedge
operator|->
name|sy
argument_list|,
name|curedge
operator|->
name|ex
argument_list|,
name|curedge
operator|->
name|ey
argument_list|,
name|candx0
argument_list|,
name|candy0
argument_list|,
name|candx1
argument_list|,
name|candy1
argument_list|,
operator|&
name|alpha
argument_list|,
operator|&
name|beta
argument_list|,
operator|&
name|collinear
argument_list|)
operator|&&
operator|(
literal|0.0
operator|<
name|alpha
operator|)
operator|&&
operator|(
name|alpha
operator|<
literal|1.0
operator|)
condition|)
name|opqinsert
argument_list|(
name|SIMPLE
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|,
operator|&
name|alphalist
argument_list|)
expr_stmt|;
break|break;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|X
condition|)
block|{
if|if
condition|(
name|llinter
argument_list|(
name|prevedge
operator|->
name|etx
argument_list|,
name|prevedge
operator|->
name|ety
argument_list|,
name|curedge
operator|->
name|stx
argument_list|,
name|curedge
operator|->
name|sty
argument_list|,
name|candx0
argument_list|,
name|candy0
argument_list|,
name|candx1
argument_list|,
name|candy1
argument_list|,
operator|&
name|alpha
argument_list|,
operator|&
name|beta
argument_list|,
operator|&
name|collinear
argument_list|)
operator|&&
operator|(
name|alpha
operator|>
literal|0.0
operator|)
operator|&&
operator|(
name|alpha
operator|<
literal|1.0
operator|)
condition|)
name|opqinsert
argument_list|(
name|SIMPLE
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|,
operator|&
name|alphalist
argument_list|)
expr_stmt|;
break|break;
block|}
end_if

begin_expr_stmt
name|impossible
argument_list|(
literal|"polyline(II:AT0)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
name|AT1
case|:
end_case

begin_comment
comment|/* should be taken care of by next AT0 */
end_comment

begin_break
break|break;
end_break

begin_case
case|case
name|ON0
case|:
end_case

begin_case
case|case
name|ON1
case|:
end_case

begin_expr_stmt
name|X
operator|=
name|arecollinear
argument_list|(
name|prevedge
operator|->
name|etx
argument_list|,
name|prevedge
operator|->
name|ety
argument_list|,
name|curedge
operator|->
name|sx
argument_list|,
name|curedge
operator|->
name|sy
argument_list|,
name|curedge
operator|->
name|next
operator|->
name|stx
argument_list|,
name|curedge
operator|->
name|next
operator|->
name|sty
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Y
operator|=
name|llinter
argument_list|(
name|prevedge
operator|->
name|etx
argument_list|,
name|prevedge
operator|->
name|ety
argument_list|,
name|curedge
operator|->
name|next
operator|->
name|stx
argument_list|,
name|curedge
operator|->
name|sty
argument_list|,
name|candx0
argument_list|,
name|candy0
argument_list|,
name|candx1
argument_list|,
name|candy1
argument_list|,
operator|&
name|alpha
argument_list|,
operator|&
name|beta
argument_list|,
operator|&
name|collinear
argument_list|)
operator|&&
operator|(
name|alpha
operator|>
literal|0.0
operator|)
operator|&&
operator|(
name|alpha
operator|<
literal|1.0
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Z
operator|=
name|llinter
argument_list|(
name|prevedge
operator|->
name|sx
argument_list|,
name|prevedge
operator|->
name|sy
argument_list|,
name|curedge
operator|->
name|next
operator|->
name|ex
argument_list|,
name|curedge
operator|->
name|next
operator|->
name|ey
argument_list|,
name|candx0
argument_list|,
name|candy0
argument_list|,
name|candx1
argument_list|,
name|candy1
argument_list|,
operator|&
name|alpha
argument_list|,
operator|&
name|beta
argument_list|,
operator|&
name|collinear
argument_list|)
operator|&&
operator|(
name|alpha
operator|>
literal|0.0
operator|)
operator|&&
operator|(
name|alpha
operator|<
literal|1.0
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|W
operator|=
name|prevedge
operator|==
name|curedge
operator|->
name|next
operator|->
name|next
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dprintf
literal|"X=%d Y=%d, Z=%d, W=%d\n"
operator|,
name|X
operator|,
name|Y
operator|,
name|Z
operator|,
name|W
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
operator|!
name|Y
operator|&&
name|W
condition|)
name|opqinsert
argument_list|(
operator|(
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|==
name|ON0
operator|)
condition|?
name|EXT0
else|:
name|EXT1
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|,
operator|&
name|alphalist
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|X
operator|&&
name|Y
condition|)
name|opqinsert
argument_list|(
operator|(
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|==
name|ON0
operator|)
condition|?
name|INFL0
else|:
name|INFL1
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|,
operator|&
name|alphalist
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|X
operator|&&
name|Z
condition|)
name|opqinsert
argument_list|(
operator|(
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|==
name|ON0
operator|)
condition|?
name|INFL0
else|:
name|INFL1
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|,
operator|&
name|alphalist
argument_list|)
expr_stmt|;
else|else
name|opqinsert
argument_list|(
operator|(
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|==
name|ON0
operator|)
condition|?
name|EXT0
else|:
name|EXT1
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|,
operator|&
name|alphalist
argument_list|)
expr_stmt|;
end_if

begin_break
break|break;
end_break

begin_case
case|case
name|TANGENT
case|:
end_case

begin_default
default|default:
end_default

begin_expr_stmt
name|impossible
argument_list|(
literal|"polyline(B)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_expr_stmt
unit|} 		prevedge
operator|=
name|curedge
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|curedge
operator|=
name|curedge
operator|->
name|next
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} while
operator|(
name|prevedge
operator|!=
name|edgelist
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|opqinsert
argument_list|(
name|INHERIT
argument_list|,
literal|0.0
argument_list|,
operator|&
name|alphalist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|opqinsert
argument_list|(
name|INHERIT
argument_list|,
literal|1.0
argument_list|,
operator|&
name|alphalist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|dbg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"interalpha:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|interwalk
operator|=
name|alphalist
init|;
name|interwalk
condition|;
name|interwalk
operator|=
name|interwalk
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d %f, "
argument_list|,
name|interwalk
operator|->
name|code
argument_list|,
name|interwalk
operator|->
name|alpha
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|inside
operator|=
name|onedge
operator|=
name|FALSE
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|interwalk
operator|=
name|alphalist
init|;
name|interwalk
condition|;
name|interwalk
operator|=
name|interwalk
operator|->
name|next
control|)
switch|switch
condition|(
name|interwalk
operator|->
name|code
condition|)
block|{
case|case
name|SIMPLE
case|:
name|interwalk
operator|->
name|code
operator|=
operator|(
operator|!
name|inside
operator|)
condition|?
name|INBEGIN
else|:
name|OUTBEGIN
expr_stmt|;
name|inside
operator|=
operator|!
name|inside
expr_stmt|;
break|break;
case|case
name|EXT1
case|:
name|interwalk
operator|->
name|code
operator|=
name|inside
condition|?
name|INBEGIN
else|:
name|OUTBEGIN
expr_stmt|;
name|onedge
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|EXT0
case|:
name|interwalk
operator|->
name|code
operator|=
name|ONBEGIN
expr_stmt|;
name|onedge
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|INFL1
case|:
name|interwalk
operator|->
name|code
operator|=
operator|(
operator|!
name|inside
operator|)
condition|?
name|INBEGIN
else|:
name|OUTBEGIN
expr_stmt|;
name|onedge
operator|=
name|FALSE
expr_stmt|;
name|inside
operator|=
operator|!
name|inside
expr_stmt|;
break|break;
case|case
name|INFL0
case|:
name|interwalk
operator|->
name|code
operator|=
name|ONBEGIN
expr_stmt|;
name|onedge
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|INHERIT
case|:
case|case
name|IGNORE
case|:
name|interwalk
operator|->
name|code
operator|=
name|onedge
condition|?
name|ONBEGIN
else|:
operator|(
name|inside
condition|?
name|INBEGIN
else|:
name|OUTBEGIN
operator|)
expr_stmt|;
break|break;
break|break;
default|default:
name|impossible
argument_list|(
literal|"polyline(C)"
argument_list|)
expr_stmt|;
break|break;
block|}
end_for

begin_if
if|if
condition|(
name|dbg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"interalpha:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|interwalk
operator|=
name|alphalist
init|;
name|interwalk
condition|;
name|interwalk
operator|=
name|interwalk
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d %f, "
argument_list|,
name|interwalk
operator|->
name|code
argument_list|,
name|interwalk
operator|->
name|alpha
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_if

begin_for
for|for
control|(
name|interwalk
operator|=
name|alphalist
init|;
name|interwalk
condition|;
name|interwalk
operator|=
name|interwalk
operator|->
name|next
control|)
block|{
name|linewalk
operator|=
name|linegen
argument_list|(
name|candx0
operator|+
name|interwalk
operator|->
name|alpha
operator|*
operator|(
name|candx1
operator|-
name|candx0
operator|)
argument_list|,
name|candy0
operator|+
name|interwalk
operator|->
name|alpha
operator|*
operator|(
name|candy1
operator|-
name|candy0
operator|)
argument_list|,
name|candx0
operator|+
name|interwalk
operator|->
name|next
operator|->
name|alpha
operator|*
operator|(
name|candx1
operator|-
name|candx0
operator|)
argument_list|,
name|candy0
operator|+
name|interwalk
operator|->
name|next
operator|->
name|alpha
operator|*
operator|(
name|candy1
operator|-
name|candy0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|interwalk
operator|->
name|alpha
operator|>
operator|-
name|EPSILON
operator|&&
name|interwalk
operator|->
name|next
operator|&&
name|interwalk
operator|->
name|next
operator|->
name|alpha
operator|<
literal|1.0
operator|+
name|EPSILON
condition|)
switch|switch
condition|(
name|interwalk
operator|->
name|code
condition|)
block|{
case|case
name|INBEGIN
case|:
name|inwalk
operator|->
name|next
operator|=
name|linewalk
expr_stmt|;
name|inwalk
operator|=
name|inwalk
operator|->
name|next
expr_stmt|;
break|break;
case|case
name|OUTBEGIN
case|:
name|outwalk
operator|->
name|next
operator|=
name|linewalk
expr_stmt|;
name|outwalk
operator|=
name|outwalk
operator|->
name|next
expr_stmt|;
break|break;
case|case
name|ONBEGIN
case|:
name|tryfree
argument_list|(
name|linewalk
argument_list|)
expr_stmt|;
break|break;
default|default:
name|impossible
argument_list|(
literal|"polyline(D)"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_for

begin_expr_stmt
operator|*
name|inlines
operator|=
name|nuin
operator|.
name|next
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|outlines
operator|=
name|nuout
operator|.
name|next
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|both
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_define
unit|}
define|#
directive|define
name|xtanp
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|r
parameter_list|,
name|t
parameter_list|)
value|x+r*cos(t)+sin(t)
end_define

begin_define
define|#
directive|define
name|ytanp
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|r
parameter_list|,
name|t
parameter_list|)
value|y+r*sin(t)-cos(t)
end_define

begin_define
define|#
directive|define
name|xtane
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|r
parameter_list|,
name|t
parameter_list|)
value|x+r*cos(t)-sin(t)
end_define

begin_define
define|#
directive|define
name|ytane
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|r
parameter_list|,
name|t
parameter_list|)
value|y+r*sin(t)+cos(t)
end_define

begin_macro
unit|boolean
name|ptinpoly
argument_list|(
argument|edgelist
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|EDGEPTR
name|edgelist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|LINEPTR
name|inlines
decl_stmt|,
name|outlines
decl_stmt|,
name|both
decl_stmt|;
name|polyline
argument_list|(
name|edgelist
argument_list|,
name|x
operator|-
literal|100
operator|*
name|EPSILON
argument_list|,
name|y
operator|-
literal|100
operator|*
name|EPSILON
argument_list|,
name|x
operator|+
literal|100
operator|*
name|EPSILON
argument_list|,
name|y
operator|+
literal|100
operator|*
name|EPSILON
argument_list|,
operator|&
name|inlines
argument_list|,
operator|&
name|outlines
argument_list|,
operator|&
name|both
argument_list|)
expr_stmt|;
if|if
condition|(
name|inlines
condition|)
block|{
if|if
condition|(
name|outlines
operator|||
name|both
condition|)
name|impossible
argument_list|(
literal|"ptinpoly(A)"
argument_list|)
expr_stmt|;
else|else
block|{
name|linefree
argument_list|(
name|inlines
argument_list|)
expr_stmt|;
name|dprintf
literal|"ptinpoly: TRUE\n"
block|)
empty_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
end_block

begin_elseif
elseif|else
if|if
condition|(
name|outlines
condition|)
block|{
if|if
condition|(
name|inlines
operator|||
name|both
condition|)
name|impossible
argument_list|(
literal|"ptinpoly(B)"
argument_list|)
expr_stmt|;
else|else
block|{
name|linefree
argument_list|(
name|outlines
argument_list|)
expr_stmt|;
name|dprintf
literal|"ptinpoly: FALSE\n"
block|)
empty_stmt|;
return|return
name|FALSE
return|;
block|}
end_elseif

begin_expr_stmt
unit|} else
name|impossible
argument_list|(
literal|"ptinpoly(C)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
unit|}  void
name|polyarc
argument_list|(
argument|edgelist
argument_list|,
argument|x0
argument_list|,
argument|y0
argument_list|,
argument|radius
argument_list|,
argument|startang
argument_list|,
argument|endang
argument_list|,
argument|inlines
argument_list|,
argument|outlines
argument_list|,
argument|both
argument_list|)
end_macro

begin_decl_stmt
name|EDGEPTR
name|edgelist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|radius
decl_stmt|,
name|startang
decl_stmt|,
name|endang
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LINEPTR
modifier|*
name|inlines
decl_stmt|,
modifier|*
name|outlines
decl_stmt|,
modifier|*
name|both
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|OPQPTR
name|interwalk
decl_stmt|;
name|boolean
name|inside
decl_stmt|,
name|onedge
decl_stmt|;
name|LINENODE
name|nuin
decl_stmt|,
name|nuout
decl_stmt|;
name|LINEPTR
name|inwalk
decl_stmt|,
name|outwalk
decl_stmt|;
name|LINEPTR
name|linewalk
decl_stmt|;
name|EDGEPTR
name|prevedge
decl_stmt|,
name|curedge
decl_stmt|;
name|OPQPTR
name|alphalist
decl_stmt|;
name|float
name|alpha
index|[
literal|2
index|]
decl_stmt|,
name|beta
index|[
literal|2
index|]
decl_stmt|,
name|gamma
index|[
literal|2
index|]
decl_stmt|,
name|theta
index|[
literal|2
index|]
decl_stmt|;
name|boolean
name|collinear
decl_stmt|;
name|boolean
name|X
decl_stmt|,
name|Y
decl_stmt|,
name|Z
decl_stmt|,
name|W
decl_stmt|;
name|float
name|stx
decl_stmt|,
name|sty
decl_stmt|,
name|etx
decl_stmt|,
name|ety
decl_stmt|;
name|int
name|i
decl_stmt|;
name|double
name|dummy
decl_stmt|,
name|rem
decl_stmt|;
name|alphalist
operator|=
operator|(
name|OPQPTR
operator|)
name|NULL
expr_stmt|;
name|inwalk
operator|=
operator|&
name|nuin
expr_stmt|;
name|inwalk
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|outwalk
operator|=
operator|&
name|nuout
expr_stmt|;
name|outwalk
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|curedge
operator|=
name|edgelist
expr_stmt|;
do|do
block|{
if|if
condition|(
name|curedge
operator|->
name|fax
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|lcinter
argument_list|(
name|curedge
operator|->
name|sx
argument_list|,
name|curedge
operator|->
name|sy
argument_list|,
name|curedge
operator|->
name|ex
argument_list|,
name|curedge
operator|->
name|ey
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|radius
argument_list|,
operator|&
name|alpha
index|[
literal|0
index|]
argument_list|,
operator|&
name|theta
index|[
literal|0
index|]
argument_list|,
operator|&
name|alpha
index|[
literal|1
index|]
argument_list|,
operator|&
name|theta
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|theta
index|[
literal|0
index|]
operator|-
name|theta
index|[
literal|1
index|]
argument_list|)
operator|<
name|EPSILON
condition|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|alpha
index|[
literal|0
index|]
argument_list|)
operator|<
name|EPSILON
condition|)
name|curedge
operator|->
name|code
index|[
literal|0
index|]
operator|=
name|AT0
expr_stmt|;
elseif|else
if|if
condition|(
name|fabs
argument_list|(
literal|1.0
operator|-
name|alpha
index|[
literal|0
index|]
argument_list|)
operator|<
name|EPSILON
condition|)
name|curedge
operator|->
name|code
index|[
literal|0
index|]
operator|=
name|AT1
expr_stmt|;
else|else
name|curedge
operator|->
name|code
index|[
literal|0
index|]
operator|=
name|TANGENT
expr_stmt|;
name|curedge
operator|->
name|alpha
index|[
literal|0
index|]
operator|=
name|rprin
argument_list|(
name|theta
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|curedge
operator|->
name|code
index|[
literal|1
index|]
operator|=
name|UNUSED
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|EPSILON
operator|<
name|alpha
index|[
name|i
index|]
operator|&&
name|alpha
index|[
name|i
index|]
operator|<
literal|1.0
operator|-
name|EPSILON
condition|)
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|=
name|SIMPLE
expr_stmt|;
elseif|else
if|if
condition|(
name|fabs
argument_list|(
name|alpha
index|[
name|i
index|]
argument_list|)
operator|<
name|EPSILON
condition|)
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|=
name|AT0
expr_stmt|;
elseif|else
if|if
condition|(
name|fabs
argument_list|(
name|alpha
index|[
name|i
index|]
operator|-
literal|1.0
argument_list|)
operator|<
name|EPSILON
condition|)
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|=
name|AT1
expr_stmt|;
else|else
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|=
name|UNUSED
expr_stmt|;
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
operator|=
name|rprin
argument_list|(
name|theta
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|curedge
operator|->
name|fax
operator|->
name|kind
operator|==
name|ARC
condition|)
block|{
if|if
condition|(
operator|!
name|ccinter
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|radius
argument_list|,
name|curedge
operator|->
name|fax
operator|->
name|x0
argument_list|,
name|curedge
operator|->
name|fax
operator|->
name|y0
argument_list|,
name|curedge
operator|->
name|fax
operator|->
name|radius
argument_list|,
operator|&
name|gamma
index|[
literal|0
index|]
argument_list|,
operator|&
name|theta
index|[
literal|0
index|]
argument_list|,
operator|&
name|gamma
index|[
literal|1
index|]
argument_list|,
operator|&
name|theta
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|x0
operator|-
name|curedge
operator|->
name|fax
operator|->
name|x0
argument_list|)
operator|<
name|EPSILON
operator|&&
name|fabs
argument_list|(
name|y0
operator|-
name|curedge
operator|->
name|fax
operator|->
name|y0
argument_list|)
operator|<
name|EPSILON
operator|&&
name|fabs
argument_list|(
name|fabs
argument_list|(
name|radius
argument_list|)
operator|-
name|fabs
argument_list|(
name|curedge
operator|->
name|fax
operator|->
name|radius
argument_list|)
argument_list|)
operator|<
name|EPSILON
condition|)
block|{
name|curedge
operator|->
name|alpha
index|[
literal|0
index|]
operator|=
name|rprin
argument_list|(
name|curedge
operator|->
name|fax
operator|->
name|theta1
argument_list|)
expr_stmt|;
name|curedge
operator|->
name|alpha
index|[
literal|1
index|]
operator|=
name|rprin
argument_list|(
name|curedge
operator|->
name|fax
operator|->
name|theta2
argument_list|)
expr_stmt|;
name|curedge
operator|->
name|code
index|[
literal|0
index|]
operator|=
name|ON0
expr_stmt|;
name|curedge
operator|->
name|code
index|[
literal|1
index|]
operator|=
name|ON1
expr_stmt|;
block|}
else|else
block|{
name|curedge
operator|->
name|code
index|[
literal|0
index|]
operator|=
name|curedge
operator|->
name|code
index|[
literal|1
index|]
operator|=
name|UNUSED
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fabs
argument_list|(
name|theta
index|[
literal|0
index|]
operator|-
name|theta
index|[
literal|1
index|]
argument_list|)
operator|<
name|EPSILON
condition|)
block|{
if|if
condition|(
name|fabs
argument_list|(
name|theta
index|[
literal|0
index|]
operator|-
name|curedge
operator|->
name|fax
operator|->
name|theta1
argument_list|)
operator|<
name|EPSILON
condition|)
name|curedge
operator|->
name|code
index|[
literal|0
index|]
operator|=
name|curedge
operator|->
name|flipped
condition|?
name|AT1
else|:
name|AT0
expr_stmt|;
elseif|else
if|if
condition|(
name|fabs
argument_list|(
name|theta
index|[
literal|0
index|]
operator|-
name|curedge
operator|->
name|fax
operator|->
name|theta2
argument_list|)
operator|<
name|EPSILON
condition|)
name|curedge
operator|->
name|code
index|[
literal|0
index|]
operator|=
name|curedge
operator|->
name|flipped
condition|?
name|AT0
else|:
name|AT1
expr_stmt|;
else|else
name|curedge
operator|->
name|code
index|[
literal|0
index|]
operator|=
name|TANGENT
expr_stmt|;
name|curedge
operator|->
name|alpha
index|[
literal|0
index|]
operator|=
name|rprin
argument_list|(
name|gamma
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|curedge
operator|->
name|code
index|[
literal|1
index|]
operator|=
name|UNUSED
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|dprintf
literal|"disposition of %f\n"
operator|,
name|theta
index|[
name|i
index|]
block|)
empty_stmt|;
if|if
condition|(
name|curedge
operator|->
name|fax
operator|->
name|theta2
operator|<
literal|2.0
operator|*
name|PI
condition|)
block|{
if|if
condition|(
name|theta
index|[
name|i
index|]
operator|-
name|curedge
operator|->
name|fax
operator|->
name|theta1
operator|<
operator|-
name|EPSILON
operator|||
name|curedge
operator|->
name|fax
operator|->
name|theta2
operator|-
name|theta
index|[
name|i
index|]
operator|<
operator|-
name|EPSILON
condition|)
block|{
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|=
name|UNUSED
expr_stmt|;
name|dprintf
literal|"intersection off arc\n"
block|)
empty_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|curedge
operator|->
name|fax
operator|->
name|theta2
operator|>
literal|2.0
operator|*
name|PI
condition|)
block|{
if|if
condition|(
name|theta
index|[
name|i
index|]
operator|-
name|curedge
operator|->
name|fax
operator|->
name|theta1
operator|<
operator|-
name|EPSILON
operator|&&
name|curedge
operator|->
name|fax
operator|->
name|theta2
operator|-
name|theta
index|[
name|i
index|]
operator|<
literal|2.0
operator|*
name|PI
operator|-
name|EPSILON
condition|)
block|{
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|=
name|UNUSED
expr_stmt|;
name|dprintf
literal|"intersection off arc\n"
block|)
empty_stmt|;
continue|continue;
block|}
block|}
name|rem
operator|=
name|modf
argument_list|(
name|fabs
argument_list|(
name|theta
index|[
name|i
index|]
operator|-
name|curedge
operator|->
name|fax
operator|->
name|theta1
argument_list|)
operator|/
operator|(
literal|2.0
operator|*
name|PI
operator|)
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|dprintf
literal|"rem1 = %f\n"
operator|,
name|rem
block|)
empty_stmt|;
do|if (rem< EPSILON || fabs(1.0 - rem
block|)
end_block

begin_expr_stmt
operator|<
name|EPSILON
end_expr_stmt

begin_block
unit|)
block|{
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
operator|=
name|rprin
argument_list|(
name|gamma
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|=
name|curedge
operator|->
name|flipped
condition|?
name|AT1
else|:
name|AT0
expr_stmt|;
continue|continue;
block|}
end_block

begin_expr_stmt
name|rem
operator|=
name|modf
argument_list|(
name|fabs
argument_list|(
name|theta
index|[
name|i
index|]
operator|-
name|curedge
operator|->
name|fax
operator|->
name|theta2
argument_list|)
operator|/
operator|(
literal|2.0
operator|*
name|PI
operator|)
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dprintf
literal|"rem2 = %f\n"
operator|,
name|rem
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
name|rem
operator|<
name|EPSILON
operator|||
name|fabs
argument_list|(
literal|1.0
operator|-
name|rem
argument_list|)
operator|<
name|EPSILON
condition|)
block|{
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
operator|=
name|rprin
argument_list|(
name|gamma
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|=
name|curedge
operator|->
name|flipped
condition|?
name|AT0
else|:
name|AT1
expr_stmt|;
continue|continue;
block|}
end_if

begin_expr_stmt
name|dprintf
literal|"simple\n"
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|=
name|SIMPLE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
operator|=
name|rprin
argument_list|(
name|gamma
index|[
name|i
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
unit|} 			} 		} else
block|{
name|impossible
argument_list|(
literal|"polyarc(D)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|curedge
operator|=
name|curedge
operator|->
name|next
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} while
operator|(
name|curedge
operator|!=
name|edgelist
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|dbg
condition|)
block|{
name|curedge
operator|=
name|edgelist
expr_stmt|;
do|do
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s (%f,%f); e (%f,%f)\n"
argument_list|,
name|curedge
operator|->
name|sx
argument_list|,
name|curedge
operator|->
name|sy
argument_list|,
name|curedge
operator|->
name|ex
argument_list|,
name|curedge
operator|->
name|ey
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"st (%f,%f); et (%f,%f)\n"
argument_list|,
name|curedge
operator|->
name|stx
argument_list|,
name|curedge
operator|->
name|sty
argument_list|,
name|curedge
operator|->
name|etx
argument_list|,
name|curedge
operator|->
name|ety
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|POSSINTER
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d %f\n"
argument_list|,
name|curedge
operator|->
name|code
index|[
name|i
index|]
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|curedge
operator|=
name|curedge
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|curedge
operator|!=
name|edgelist
condition|)
do|;
block|}
end_if

begin_expr_stmt
name|prevedge
operator|=
name|edgelist
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|curedge
operator|=
name|edgelist
operator|->
name|next
expr_stmt|;
end_expr_stmt

begin_do
do|do
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|POSSINTER
condition|;
name|i
operator|++
control|)
block|{
name|stx
operator|=
name|xtanp
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|radius
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sty
operator|=
name|ytanp
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|radius
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|etx
operator|=
name|xtane
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|radius
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ety
operator|=
name|ytane
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|radius
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|curedge
operator|->
name|code
index|[
name|i
index|]
condition|)
block|{
case|case
name|UNUSED
case|:
break|break;
case|case
name|SIMPLE
case|:
name|opqinsert
argument_list|(
name|SIMPLE
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|,
operator|&
name|alphalist
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT0
case|:
name|dprintf
literal|"vertex intersection at (%f,%f)\n"
operator|,
name|curedge
operator|->
name|sx
operator|,
name|curedge
operator|->
name|sy
block|)
empty_stmt|;
name|X
operator|=
name|arecollinear
argument_list|(
name|curedge
operator|->
name|sx
argument_list|,
name|curedge
operator|->
name|sy
argument_list|,
name|curedge
operator|->
name|stx
argument_list|,
name|curedge
operator|->
name|sty
argument_list|,
name|prevedge
operator|->
name|etx
argument_list|,
name|prevedge
operator|->
name|ety
argument_list|)
expr_stmt|;
name|Y
operator|=
name|between
argument_list|(
name|curedge
operator|->
name|stx
argument_list|,
name|curedge
operator|->
name|sty
argument_list|,
name|curedge
operator|->
name|sx
argument_list|,
name|curedge
operator|->
name|sy
argument_list|,
name|prevedge
operator|->
name|etx
argument_list|,
name|prevedge
operator|->
name|ety
argument_list|)
expr_stmt|;
name|Z
operator|=
name|arecollinear
argument_list|(
name|stx
argument_list|,
name|sty
argument_list|,
name|etx
argument_list|,
name|ety
argument_list|,
name|curedge
operator|->
name|stx
argument_list|,
name|curedge
operator|->
name|sty
argument_list|)
expr_stmt|;
name|dprintf
literal|"X=%d Y=%d Z=%d\n"
operator|,
name|X
operator|,
name|Y
operator|,
name|Z
block|)
empty_stmt|;
if|if
condition|(
name|X
operator|&&
operator|!
name|Z
condition|)
block|{
if|if
condition|(
name|Y
condition|)
name|opqinsert
argument_list|(
name|SIMPLE
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|,
operator|&
name|alphalist
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|X
operator|&&
name|Z
condition|)
block|{
if|if
condition|(
name|llinter
argument_list|(
name|prevedge
operator|->
name|sx
argument_list|,
name|prevedge
operator|->
name|sy
argument_list|,
name|curedge
operator|->
name|ex
argument_list|,
name|curedge
operator|->
name|ey
argument_list|,
name|stx
argument_list|,
name|sty
argument_list|,
name|etx
argument_list|,
name|ety
argument_list|,
operator|&
name|alpha
index|[
literal|0
index|]
argument_list|,
operator|&
name|alpha
index|[
literal|1
index|]
argument_list|,
operator|&
name|collinear
argument_list|)
operator|&&
operator|(
literal|0.0
operator|<
name|alpha
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|alpha
index|[
literal|0
index|]
operator|<
literal|1.0
operator|)
condition|)
name|opqinsert
argument_list|(
name|SIMPLE
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|,
operator|&
name|alphalist
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|X
condition|)
block|{
if|if
condition|(
name|llinter
argument_list|(
name|prevedge
operator|->
name|etx
argument_list|,
name|prevedge
operator|->
name|ety
argument_list|,
name|curedge
operator|->
name|stx
argument_list|,
name|curedge
operator|->
name|sty
argument_list|,
name|stx
argument_list|,
name|sty
argument_list|,
name|etx
argument_list|,
name|ety
argument_list|,
operator|&
name|alpha
index|[
literal|0
index|]
argument_list|,
operator|&
name|alpha
index|[
literal|1
index|]
argument_list|,
operator|&
name|collinear
argument_list|)
operator|&&
operator|(
name|alpha
index|[
literal|0
index|]
operator|>
literal|0.0
operator|)
operator|&&
operator|(
name|alpha
index|[
literal|0
index|]
operator|<
literal|1.0
operator|)
condition|)
name|opqinsert
argument_list|(
name|SIMPLE
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|,
operator|&
name|alphalist
argument_list|)
expr_stmt|;
break|break;
block|}
name|impossible
argument_list|(
literal|"polyline(II:AT0)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT1
case|:
comment|/* should be taken care of by next AT0 */
break|break;
case|case
name|ON0
case|:
case|case
name|ON1
case|:
name|X
operator|=
name|hypot
argument_list|(
name|prevedge
operator|->
name|etx
operator|-
name|x0
argument_list|,
name|prevedge
operator|->
name|ety
operator|-
name|y0
argument_list|)
operator|>
name|fabs
argument_list|(
name|radius
argument_list|)
expr_stmt|;
name|Y
operator|=
name|hypot
argument_list|(
name|curedge
operator|->
name|next
operator|->
name|stx
operator|-
name|x0
argument_list|,
name|curedge
operator|->
name|next
operator|->
name|sty
operator|-
name|y0
argument_list|)
operator|>
name|fabs
argument_list|(
name|radius
argument_list|)
expr_stmt|;
name|dprintf
literal|"X=%d Y=%d\n"
operator|,
name|X
operator|,
name|Y
block|)
empty_stmt|;
do|Z = X&& Y; 				W = !X&& !Y; 				if (Z || W
end_do

begin_expr_stmt
unit|)
name|opqinsert
argument_list|(
operator|(
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|==
name|ON0
operator|)
condition|?
name|EXT0
else|:
name|EXT1
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|,
operator|&
name|alphalist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|else
name|opqinsert
argument_list|(
operator|(
name|curedge
operator|->
name|code
index|[
name|i
index|]
operator|==
name|ON0
operator|)
condition|?
name|INFL0
else|:
name|INFL1
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|,
operator|&
name|alphalist
argument_list|)
expr_stmt|;
end_else

begin_break
break|break;
end_break

begin_case
case|case
name|TANGENT
case|:
end_case

begin_expr_stmt
name|opqinsert
argument_list|(
name|IGNORE
argument_list|,
name|curedge
operator|->
name|alpha
index|[
name|i
index|]
argument_list|,
operator|&
name|alphalist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_default
default|default:
end_default

begin_expr_stmt
name|impossible
argument_list|(
literal|"polyline(B)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_expr_stmt
unit|} 		}
name|prevedge
operator|=
name|curedge
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|curedge
operator|=
name|curedge
operator|->
name|next
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} while
operator|(
name|prevedge
operator|!=
name|edgelist
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|opqinsert
argument_list|(
name|INHERIT
argument_list|,
name|rprin
argument_list|(
name|startang
argument_list|)
argument_list|,
operator|&
name|alphalist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|opqinsert
argument_list|(
name|INHERIT
argument_list|,
name|rprin
argument_list|(
name|endang
argument_list|)
argument_list|,
operator|&
name|alphalist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|dbg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"interalpha:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|interwalk
operator|=
name|alphalist
init|;
name|interwalk
condition|;
name|interwalk
operator|=
name|interwalk
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d %f, "
argument_list|,
name|interwalk
operator|->
name|code
argument_list|,
name|interwalk
operator|->
name|alpha
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
operator|(
operator|(
name|OPQPTR
operator|)
name|tail
argument_list|(
operator|(
name|NAMEPTR
operator|)
name|alphalist
argument_list|)
operator|)
operator|->
name|next
operator|=
name|alphalist
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|interwalk
operator|=
name|alphalist
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|onedge
operator|=
name|FALSE
expr_stmt|;
end_expr_stmt

begin_do
do|do
block|{
switch|switch
condition|(
name|interwalk
operator|->
name|code
condition|)
block|{
case|case
name|EXT0
case|:
name|alpha
index|[
literal|0
index|]
operator|=
name|interwalk
operator|->
name|alpha
expr_stmt|;
name|onedge
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|EXT1
case|:
name|alpha
index|[
literal|1
index|]
operator|=
name|interwalk
operator|->
name|alpha
expr_stmt|;
name|onedge
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|INFL0
case|:
name|alpha
index|[
literal|0
index|]
operator|=
name|interwalk
operator|->
name|alpha
expr_stmt|;
name|onedge
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|INFL1
case|:
name|alpha
index|[
literal|1
index|]
operator|=
name|interwalk
operator|->
name|alpha
expr_stmt|;
name|onedge
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|interwalk
operator|=
name|interwalk
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|interwalk
operator|!=
name|alphalist
condition|)
do|;
end_do

begin_if
if|if
condition|(
name|onedge
condition|)
block|{
name|rem
operator|=
name|modf
argument_list|(
name|fabs
argument_list|(
name|alpha
index|[
literal|0
index|]
operator|-
name|alpha
index|[
literal|1
index|]
argument_list|)
operator|/
operator|(
literal|2.0
operator|*
name|PI
operator|)
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem
operator|<
name|EPSILON
operator|||
name|fabs
argument_list|(
literal|1.0
operator|-
name|rem
argument_list|)
operator|<
name|EPSILON
condition|)
return|return;
block|}
end_if

begin_expr_stmt
name|interwalk
operator|=
name|alphalist
expr_stmt|;
end_expr_stmt

begin_do
do|do
block|{
if|if
condition|(
name|interwalk
operator|->
name|code
operator|==
name|EXT0
operator|||
name|interwalk
operator|->
name|code
operator|==
name|INFL0
operator|||
name|interwalk
operator|->
name|code
operator|==
name|INHERIT
condition|)
name|interwalk
operator|=
name|interwalk
operator|->
name|next
expr_stmt|;
else|else
break|break;
block|}
do|while
condition|(
name|interwalk
operator|!=
name|alphalist
condition|)
do|;
end_do

begin_expr_stmt
name|inside
operator|=
name|ptinpoly
argument_list|(
name|edgelist
argument_list|,
name|x0
operator|+
name|fabs
argument_list|(
name|radius
argument_list|)
operator|*
name|cos
argument_list|(
operator|(
name|interwalk
operator|->
name|alpha
operator|+
name|interwalk
operator|->
name|next
operator|->
name|alpha
operator|)
operator|/
literal|2.0
argument_list|)
argument_list|,
name|y0
operator|+
name|fabs
argument_list|(
name|radius
argument_list|)
operator|*
name|sin
argument_list|(
operator|(
name|interwalk
operator|->
name|alpha
operator|+
name|interwalk
operator|->
name|next
operator|->
name|alpha
operator|)
operator|/
literal|2.0
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dprintf
literal|"inside: %d\n"
operator|,
name|inside
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|alphalist
operator|=
name|interwalk
operator|->
name|next
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|interwalk
operator|=
name|alphalist
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|onedge
operator|=
name|FALSE
expr_stmt|;
end_expr_stmt

begin_do
do|do
block|{
switch|switch
condition|(
name|interwalk
operator|->
name|code
condition|)
block|{
case|case
name|SIMPLE
case|:
name|interwalk
operator|->
name|code
operator|=
operator|(
operator|!
name|inside
operator|)
condition|?
name|INBEGIN
else|:
name|OUTBEGIN
expr_stmt|;
name|inside
operator|=
operator|!
name|inside
expr_stmt|;
break|break;
case|case
name|EXT1
case|:
name|interwalk
operator|->
name|code
operator|=
name|inside
condition|?
name|INBEGIN
else|:
name|OUTBEGIN
expr_stmt|;
name|onedge
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|EXT0
case|:
name|interwalk
operator|->
name|code
operator|=
name|ONBEGIN
expr_stmt|;
name|onedge
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|INFL1
case|:
name|interwalk
operator|->
name|code
operator|=
operator|(
operator|!
name|inside
operator|)
condition|?
name|INBEGIN
else|:
name|OUTBEGIN
expr_stmt|;
name|inside
operator|=
operator|!
name|inside
expr_stmt|;
name|onedge
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|INFL0
case|:
name|interwalk
operator|->
name|code
operator|=
name|ONBEGIN
expr_stmt|;
name|onedge
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|INHERIT
case|:
case|case
name|IGNORE
case|:
name|interwalk
operator|->
name|code
operator|=
name|onedge
condition|?
name|ONBEGIN
else|:
operator|(
name|inside
condition|?
name|INBEGIN
else|:
name|OUTBEGIN
operator|)
expr_stmt|;
break|break;
default|default:
name|impossible
argument_list|(
literal|"polyline(C)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|interwalk
operator|=
name|interwalk
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|interwalk
operator|!=
name|alphalist
condition|)
do|;
end_do

begin_while
while|while
condition|(
name|alphalist
operator|->
name|alpha
operator|<
name|alphalist
operator|->
name|next
operator|->
name|alpha
condition|)
name|alphalist
operator|=
name|alphalist
operator|->
name|next
expr_stmt|;
end_while

begin_expr_stmt
name|alphalist
operator|=
name|alphalist
operator|->
name|next
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|dbg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"interalpha:\n"
argument_list|)
expr_stmt|;
name|interwalk
operator|=
name|alphalist
expr_stmt|;
do|do
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d %f, "
argument_list|,
name|interwalk
operator|->
name|code
argument_list|,
name|interwalk
operator|->
name|alpha
argument_list|)
expr_stmt|;
name|interwalk
operator|=
name|interwalk
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|interwalk
operator|!=
name|alphalist
condition|)
do|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|interwalk
operator|=
name|alphalist
expr_stmt|;
end_expr_stmt

begin_do
do|do
block|{
if|if
condition|(
name|interwalk
operator|->
name|alpha
operator|>
name|interwalk
operator|->
name|next
operator|->
name|alpha
condition|)
break|break;
if|if
condition|(
name|endang
operator|<
literal|2.0
operator|*
name|PI
operator|+
name|EPSILON
condition|)
block|{
if|if
condition|(
name|interwalk
operator|->
name|alpha
operator|<
name|startang
operator|-
name|EPSILON
operator|||
name|interwalk
operator|->
name|alpha
operator|>
name|endang
operator|+
name|EPSILON
condition|)
block|{
name|dprintf
literal|"arc rejected (A)\n"
block|)
empty_stmt|;
name|interwalk
operator|=
name|interwalk
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|interwalk
operator|->
name|next
operator|->
name|alpha
operator|<
name|startang
operator|-
name|EPSILON
operator|||
name|interwalk
operator|->
name|next
operator|->
name|alpha
operator|>
name|endang
operator|+
name|EPSILON
condition|)
block|{
name|dprintf
literal|"arc rejected (B)\n"
block|)
empty_stmt|;
name|interwalk
operator|=
name|interwalk
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
do|}
end_do

begin_else
else|else
block|{
if|if
condition|(
name|interwalk
operator|->
name|alpha
operator|<
name|startang
operator|-
name|EPSILON
operator|&&
name|interwalk
operator|->
name|alpha
operator|>
name|endang
operator|+
name|EPSILON
operator|-
literal|2.0
operator|*
name|PI
condition|)
block|{
name|dprintf
literal|"arc rejected (C)\n"
block|)
empty_stmt|;
name|interwalk
operator|=
name|interwalk
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
end_else

begin_if
if|if
condition|(
name|interwalk
operator|->
name|next
operator|->
name|alpha
operator|<
name|startang
operator|-
name|EPSILON
operator|&&
name|interwalk
operator|->
name|next
operator|->
name|alpha
operator|>
name|endang
operator|+
name|EPSILON
operator|-
literal|2.0
operator|*
name|PI
condition|)
block|{
name|dprintf
literal|"arc rejected (D)\n"
block|)
empty_stmt|;
end_if

begin_expr_stmt
name|interwalk
operator|=
name|interwalk
operator|->
name|next
expr_stmt|;
end_expr_stmt

begin_continue
continue|continue;
end_continue

begin_expr_stmt
unit|} 		}
name|linewalk
operator|=
name|angularc
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|radius
argument_list|,
name|interwalk
operator|->
name|alpha
argument_list|,
name|interwalk
operator|->
name|next
operator|->
name|alpha
argument_list|)
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|interwalk
operator|->
name|code
condition|)
block|{
case|case
name|INBEGIN
case|:
name|inwalk
operator|->
name|next
operator|=
name|linewalk
expr_stmt|;
name|inwalk
operator|=
name|inwalk
operator|->
name|next
expr_stmt|;
break|break;
case|case
name|OUTBEGIN
case|:
name|outwalk
operator|->
name|next
operator|=
name|linewalk
expr_stmt|;
name|outwalk
operator|=
name|outwalk
operator|->
name|next
expr_stmt|;
break|break;
case|case
name|ONBEGIN
case|:
name|tryfree
argument_list|(
name|linewalk
argument_list|)
expr_stmt|;
break|break;
default|default:
name|impossible
argument_list|(
literal|"polyline(D)"
argument_list|)
expr_stmt|;
break|break;
block|}
end_switch

begin_expr_stmt
name|interwalk
operator|=
name|interwalk
operator|->
name|next
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} while
operator|(
name|interwalk
operator|!=
name|alphalist
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|inlines
operator|=
name|nuin
operator|.
name|next
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|outlines
operator|=
name|nuout
operator|.
name|next
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|both
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

unit|}
end_unit

