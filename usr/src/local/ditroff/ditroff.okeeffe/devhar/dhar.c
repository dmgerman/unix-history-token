begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)dhar.c	1.2	CWI 1.2	%G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Drive the Harris 7500 tyepsetter  *		    75XX  * Other machines of that harris serie will probably run as well with this  *  * Author: jaap akkerhuis, O
comment|c 1982, Mathematisch Cetrum.  *  */
end_comment

begin_comment
comment|/* output language from troff: all numbers are character strings  sn	size in points fn	font as number from 1-n cx	ascii character x Cxyz	funny char xyz. terminated by white space Hn	go to absolute horizontal position n Vn	go to absolute vertical position n (down is positive) hn	go n units horizontally (relative) vn	ditto vertically nnc	move right nn, then print c (exactly 2 digits!) 		(this wart is an optimization that shrinks output file size 		 about 35% and run-time about 15% while preserving ascii-ness) Dt ...\n	draw operation 't': 	Dl x y		line from here by x,y 	Dc d		circle of diameter d with left side here 	De x y		ellipse of axes x,y with left side here 	Da x y r	arc counter-clockwise by x,y of radius r 	D~ x y x y ...	wiggly line by x,y then x,y ... w	paddable words space -- no action needed nb a	end of line (information only -- no action needed) 	b = space before line, a = after p	new page begins -- set v to 0 tstring print string as plain text #...\n	comment x ...\n	device control functions: 	x i	init 	x T s	name of device is s 	x r n h v	resolution is n/inch 		h = min horizontal motion, v = min vert 	x p	pause (can restart) 	x s	stop -- done for ever 	x t	generate trailer 	x f n s	font position n contains font s 	x H n	set character height to n 	x S n	set slant to N  	Subcommands like "i" are often spelled out like "init". */
end_comment

begin_comment
comment|/*  * MC:jna  * The output language signs { and } are not described  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"../dev.h"
end_include

begin_define
define|#
directive|define
name|NFONT
value|10
end_define

begin_decl_stmt
name|int
name|output
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* do we do output at all? */
end_comment

begin_decl_stmt
name|int
name|nolist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output page list if> 0 */
end_comment

begin_decl_stmt
name|int
name|olist
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pairs of page numbers */
end_comment

begin_decl_stmt
name|int
name|spage
init|=
literal|9999
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stop every spage pages */
end_comment

begin_decl_stmt
name|int
name|scount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dev
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Font
modifier|*
name|fontbase
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|pstab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nsizes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfonts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|smnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of first special font */
end_comment

begin_decl_stmt
name|int
name|nchtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|chname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|chtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fitab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|widthtab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* widtab would be a better name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|codetab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device codes */
end_comment

begin_decl_stmt
name|short
modifier|*
name|fonttab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*MC:jna optional fontcodes */
end_comment

begin_define
define|#
directive|define
name|FATAL
value|1
end_define

begin_define
define|#
directive|define
name|BMASK
value|0377
end_define

begin_define
define|#
directive|define
name|BYTE
value|8
end_define

begin_decl_stmt
name|int
name|dbg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|eflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|res
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input assumed computed according to this resolution */
end_comment

begin_decl_stmt
name|int
name|tf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output file will be har.in or standout */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fontdir
init|=
literal|"/usr/local/lib/ditroff/font"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|devname
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|abs
parameter_list|(
name|n
parameter_list|)
value|((n)>= 0 ? (n) : -(n))
end_define

begin_decl_stmt
name|int
name|font
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current font */
end_comment

begin_decl_stmt
name|int
name|hpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* horizontal position where we are supposed to be next (left = 0) */
end_comment

begin_decl_stmt
name|int
name|lastw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  width of last printed char, (for t_text()) */
end_comment

begin_decl_stmt
name|int
name|vpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current vertical position (down positive) */
end_comment

begin_decl_stmt
name|int
name|horig
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* h origin of current block; hpos rel to this */
end_comment

begin_decl_stmt
name|int
name|vorig
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|htrue
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vtrue
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|DX
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* step size in x for drawing */
end_comment

begin_decl_stmt
name|int
name|DY
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* step size in y for drawing */
end_comment

begin_decl_stmt
name|int
name|drawdot
init|=
literal|'.'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* draw with this character */
end_comment

begin_decl_stmt
name|int
name|drawsize
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* shrink by this factor when drawing */
end_comment

begin_comment
comment|/* drawsize will be set in t_init as well! */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|done
parameter_list|()
function_decl|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|fontdir
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tf
operator|=
literal|1
expr_stmt|;
comment|/* stdout */
break|break;
case|case
literal|'o'
case|:
name|outlist
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dbg
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
operator|==
literal|0
condition|)
name|dbg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|spage
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|spage
operator|<=
literal|0
condition|)
name|spage
operator|=
literal|9999
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|eflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|cflag
operator|++
expr_stmt|;
break|break;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
comment|/* 				 * Stop every 4 pages to prevent the 				 * Harris to Cut the paper every 6 feet, 				 * wat will likely to be in the middle of 				 * a page. Every for page is proved to be 				 * reasonable. 				 */
if|if
condition|(
name|spage
operator|==
literal|0
operator|||
literal|9999
condition|)
name|spage
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|done
argument_list|)
operator|==
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|done
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|done
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|done
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|conv
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
operator|++
name|argv
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|fp
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|conv
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|account
argument_list|()
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|outlist
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* process list of page numbers to be printed */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|,
name|i
decl_stmt|;
name|nolist
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|n1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|do
name|n1
operator|=
literal|10
operator|*
name|n1
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
else|else
name|n1
operator|=
operator|-
literal|9999
expr_stmt|;
name|n2
operator|=
name|n1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|n2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|do
name|n2
operator|=
literal|10
operator|*
name|n2
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
else|else
name|n2
operator|=
literal|9999
expr_stmt|;
block|}
name|olist
index|[
name|nolist
operator|++
index|]
operator|=
name|n1
expr_stmt|;
name|olist
index|[
name|nolist
operator|++
index|]
operator|=
name|n2
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|olist
index|[
name|nolist
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nolist
condition|;
name|i
operator|+=
literal|2
control|)
name|printf
argument_list|(
literal|"%3d %3d\n"
argument_list|,
name|olist
index|[
name|i
index|]
argument_list|,
name|olist
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|conv
argument_list|(
name|fp
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|k
decl_stmt|;
name|int
name|m
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|n1
decl_stmt|,
name|m1
decl_stmt|;
name|char
name|str
index|[
literal|100
index|]
decl_stmt|,
name|buf
index|[
literal|300
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* when input is text */
case|case
literal|' '
case|:
case|case
literal|0
case|:
comment|/* occasional noise creeps in */
break|break;
case|case
literal|'{'
case|:
comment|/* push down current environment */
name|t_push
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|t_pop
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* two motion digits plus a character */
name|hmot
argument_list|(
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|getc
argument_list|(
name|fp
argument_list|)
operator|-
literal|'0'
argument_list|)
expr_stmt|;
name|put1
argument_list|(
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* single ascii character */
name|put1
argument_list|(
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|put1s
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* straight text */
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|t_text
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* draw function */
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'l'
case|:
comment|/* draw a line */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|drawline
argument_list|(
name|n
argument_list|,
name|m
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* circle */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawcirc
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* ellipse */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawellip
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* arc */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d %d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n1
argument_list|,
operator|&
name|m1
argument_list|)
expr_stmt|;
name|drawarc
argument_list|(
name|n
argument_list|,
name|m
argument_list|,
name|n1
argument_list|,
name|m1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
comment|/* wiggly line */
name|drawwig
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unknown drawing function %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'s'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
comment|/* ignore fractional sizes */
name|setsize
argument_list|(
name|t_size
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|setfont
argument_list|(
name|t_font
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* absolute horizontal motion */
comment|/* fscanf(fp, "%d",&n); */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|hgoto
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* relative horizontal motion */
comment|/* fscanf(fp, "%d",&n); */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* word space */
break|break;
case|case
literal|'V'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|vgoto
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* new page */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_page
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* end of line */
while|while
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|t_newline
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* comment */
while|while
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* device control */
name|devcntrl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"unknown input character %o %c\n"
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|devcntrl
argument_list|(
argument|fp
argument_list|)
end_macro

begin_comment
comment|/* interpret device control functions */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|str
index|[
literal|20
index|]
decl_stmt|,
name|str1
index|[
literal|50
index|]
decl_stmt|,
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|str
index|[
literal|0
index|]
condition|)
block|{
comment|/* crude for now */
case|case
literal|'i'
case|:
comment|/* initialize */
name|fileinit
argument_list|()
expr_stmt|;
name|t_init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* device name */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* trailer */
name|t_trailer
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* pause -- can restart */
name|t_reset
argument_list|(
literal|'p'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* stop */
name|t_reset
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* resolution assumed when prepared */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* font used */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d %s"
argument_list|,
operator|&
name|n
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* in case there's a filename */
name|ungetc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* fgets goes too far */
name|str1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* in case there's nothing to come in */
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
name|str1
argument_list|)
expr_stmt|;
name|loadfont
argument_list|(
name|n
argument_list|,
name|str
argument_list|,
name|str1
argument_list|)
expr_stmt|;
break|break;
comment|/* these don't belong here... */
case|case
literal|'H'
case|:
comment|/* char height */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_charht
argument_list|(
name|t_size
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* slant */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_slant
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
comment|/* skip rest of input line */
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
block|}
end_block

begin_macro
name|fileinit
argument_list|()
end_macro

begin_comment
comment|/* read in font and code files, etc. */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|,
name|fin
decl_stmt|,
name|nw
decl_stmt|;
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|filebase
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|temp
index|[
literal|60
index|]
decl_stmt|;
comment|/* open table for device, 	/* read in resolution, size info, font info, etc. 	/* and set params 	*/
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/dev%s/DESC.out"
argument_list|,
name|fontdir
argument_list|,
name|devname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|open
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open tables for %s\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fin
argument_list|,
operator|&
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|nfonts
operator|=
name|dev
operator|.
name|nfonts
expr_stmt|;
name|nsizes
operator|=
name|dev
operator|.
name|nsizes
expr_stmt|;
name|nchtab
operator|=
name|dev
operator|.
name|nchtab
expr_stmt|;
name|filebase
operator|=
name|malloc
argument_list|(
name|dev
operator|.
name|filesize
argument_list|)
expr_stmt|;
comment|/* enough room for whole file */
name|read
argument_list|(
name|fin
argument_list|,
name|filebase
argument_list|,
name|dev
operator|.
name|filesize
argument_list|)
expr_stmt|;
comment|/* all at once */
name|pstab
operator|=
operator|(
name|short
operator|*
operator|)
name|filebase
expr_stmt|;
name|chtab
operator|=
name|pstab
operator|+
name|nsizes
operator|+
literal|1
expr_stmt|;
name|chname
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|chtab
operator|+
name|dev
operator|.
name|nchtab
operator|)
expr_stmt|;
name|p
operator|=
name|chname
operator|+
name|dev
operator|.
name|lchname
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nfonts
condition|;
name|i
operator|++
control|)
block|{
name|fontbase
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|Font
operator|*
operator|)
name|p
expr_stmt|;
name|nw
operator|=
operator|*
name|p
operator|&
name|BMASK
expr_stmt|;
comment|/* 1st thing is width count */
if|if
condition|(
name|smnt
operator|==
literal|0
operator|&&
name|fontbase
index|[
name|i
index|]
operator|->
name|specfont
operator|==
literal|1
condition|)
name|smnt
operator|=
name|i
expr_stmt|;
comment|/* first special font */
name|p
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|Font
argument_list|)
expr_stmt|;
comment|/* that's what's on the beginning */
name|widthtab
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
name|codetab
index|[
name|i
index|]
operator|=
name|p
operator|+
literal|2
operator|*
name|nw
expr_stmt|;
name|fitab
index|[
name|i
index|]
operator|=
name|p
operator|+
literal|3
operator|*
name|nw
expr_stmt|;
name|p
operator|+=
literal|3
operator|*
name|nw
operator|+
name|dev
operator|.
name|nchtab
operator|+
literal|128
operator|-
literal|32
expr_stmt|;
if|if
condition|(
name|fontbase
index|[
name|i
index|]
operator|->
name|fonttab
operator|==
literal|1
condition|)
block|{
comment|/*MC:jna There is a fonttable */
name|fonttab
index|[
name|i
index|]
operator|=
operator|(
name|short
operator|*
operator|)
name|p
expr_stmt|;
comment|/*MC:jna get it */
name|p
operator|+=
name|nw
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
comment|/* and skip it */
block|}
name|t_fp
argument_list|(
name|i
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|namefont
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|intname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
operator|>
literal|2
condition|)
name|fontprint
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/*MC:jna 	 * 	 * Make space for the font cache for NCH characters 	 * also reserve space for fonttable, if any is to come          * 	 */
name|fontbase
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|Font
operator|*
operator|)
name|malloc
argument_list|(
literal|3
operator|*
literal|255
operator|+
name|dev
operator|.
name|nchtab
operator|+
operator|(
literal|128
operator|-
literal|32
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|Font
argument_list|)
operator|+
literal|255
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|widthtab
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
literal|0
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|Font
argument_list|)
expr_stmt|;
name|fontbase
index|[
literal|0
index|]
operator|->
name|nwfont
operator|=
literal|255
expr_stmt|;
name|fontbase
index|[
literal|0
index|]
operator|->
name|fonttab
operator|=
literal|2
expr_stmt|;
comment|/* there is room for a fonttable! */
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fontprint
argument_list|(
argument|i
argument_list|)
end_macro

begin_comment
comment|/* debugging print of font i (0,...) */
end_comment

begin_block
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"font %d:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
name|i
index|]
expr_stmt|;
name|n
operator|=
name|fontbase
index|[
name|i
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
name|printf
argument_list|(
literal|"base=0%o, nchars=%d, spec=%d, name=%s, widtab=0%o, fitab=0%o\n"
argument_list|,
name|p
argument_list|,
name|n
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|specfont
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|namefont
argument_list|,
name|widthtab
index|[
name|i
index|]
argument_list|,
name|fitab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontbase
index|[
name|i
index|]
operator|->
name|fonttab
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"base fonttab=0%o\n"
argument_list|,
name|fonttab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"widths:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2d"
argument_list|,
name|widthtab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\ncodetab:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2d"
argument_list|,
name|codetab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nfitab:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|dev
operator|.
name|nchtab
operator|+
literal|128
operator|-
literal|32
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2d"
argument_list|,
name|fitab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fontbase
index|[
name|i
index|]
operator|->
name|fonttab
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\nfonttab:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|fonttab
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|loadfont
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|,
argument|s1
argument_list|)
end_macro

begin_comment
comment|/* load font info for font s on position n (0...) */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|temp
index|[
literal|60
index|]
decl_stmt|;
name|int
name|fin
decl_stmt|,
name|nw
decl_stmt|,
name|norig
decl_stmt|,
name|forig
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|NFONT
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"illegal fp command %d %s"
argument_list|,
name|n
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|namefont
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|s1
operator|==
name|NULL
operator|||
name|s1
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/dev%s/%s.out"
argument_list|,
name|fontdir
argument_list|,
name|devname
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/%s.out"
argument_list|,
name|s1
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|open
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open font table %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|norig
operator|=
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
name|forig
operator|=
name|fontbase
index|[
name|n
index|]
operator|->
name|fonttab
expr_stmt|;
if|if
condition|(
name|dbg
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"nworig, %d, fonttaborig %d\n"
argument_list|,
name|norig
argument_list|,
name|forig
argument_list|)
expr_stmt|;
comment|/* 	 *MC:jna norig is the original amount of chars in 	 * the (premounted) font) 	 * 	 * first geuss there is no fonttab 	 */
name|read
argument_list|(
name|fin
argument_list|,
name|fontbase
index|[
name|n
index|]
argument_list|,
literal|3
operator|*
name|norig
operator|+
name|nchtab
operator|+
literal|128
operator|-
literal|32
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|Font
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|&
name|BMASK
operator|)
operator|>
name|norig
operator|||
operator|(
name|forig
operator|==
literal|0
operator|&&
name|fontbase
index|[
name|n
index|]
operator|->
name|fonttab
operator|==
literal|1
operator|)
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"Font %s too big for position %d\n"
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* 		 *MC:jna This means it is wise to make the default mounted 		 * fonts larger then any other mounttable fonts. 		 * And because of the kludge with the fonttable, 		 * Make sure that they all contain fonttables! 		 * It will make your life easier. 		 */
name|nw
operator|=
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
if|if
condition|(
name|dbg
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"nw %d\n"
argument_list|,
name|nw
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontbase
index|[
name|n
index|]
operator|->
name|fonttab
operator|==
literal|1
condition|)
block|{
name|lseek
argument_list|(
name|fin
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fin
argument_list|,
name|fontbase
index|[
name|n
index|]
argument_list|,
literal|3
operator|*
name|norig
operator|+
name|nchtab
operator|+
literal|128
operator|-
literal|32
operator|+
name|nw
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|Font
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * There turned out to be a fonttab, so we have to read it in 		 *MC:jna a bit stupid, but the laziest way (for me) 		 */
block|}
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|widthtab
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
name|n
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|Font
argument_list|)
expr_stmt|;
name|codetab
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|widthtab
index|[
name|n
index|]
operator|+
literal|2
operator|*
name|nw
expr_stmt|;
name|fitab
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|widthtab
index|[
name|n
index|]
operator|+
literal|3
operator|*
name|nw
expr_stmt|;
if|if
condition|(
name|fontbase
index|[
name|n
index|]
operator|->
name|fonttab
operator|==
literal|1
condition|)
name|fonttab
index|[
name|n
index|]
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
name|widthtab
index|[
name|n
index|]
operator|+
literal|3
operator|*
name|nw
operator|+
name|nchtab
operator|+
literal|128
operator|-
literal|32
operator|)
expr_stmt|;
name|t_fp
argument_list|(
name|n
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|namefont
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|intname
argument_list|)
expr_stmt|;
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|=
name|norig
expr_stmt|;
comment|/* so can later use full original size */
if|if
condition|(
name|fontbase
index|[
name|n
index|]
operator|->
name|fonttab
operator|==
literal|0
operator|&&
name|forig
operator|!=
literal|0
condition|)
name|fontbase
index|[
name|n
index|]
operator|->
name|fonttab
operator|=
literal|2
expr_stmt|;
comment|/* so we signal that there is place 					 * for a fonttab! */
if|if
condition|(
name|dbg
operator|>
literal|2
condition|)
name|fontprint
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|done
argument_list|()
end_macro

begin_block
block|{
name|t_reset
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_function_decl
specifier|extern
name|int
name|ex
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*VARARGS*/
end_comment

begin_macro
name|error
argument_list|(
argument|f
argument_list|,
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|,
argument|a6
argument_list|,
argument|a7
argument_list|)
end_macro

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dhar: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|ex
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/******************************************************************************  ******************************************************************************  *  * Here begins the stuff that really depends on the harris  *  * For the time being, no use is made of the ruling functions of the Harris  *  ******************************************************************************  ******************************************************************************  */
end_comment

begin_comment
comment|/*  * The basic idea is to delay the output as long as possible  * until you really have to.  * Until that time we just keep a machine status.  *  */
end_comment

begin_include
include|#
directive|include
file|"hcodes.h"
end_include

begin_decl_stmt
name|char
name|devname
index|[
literal|20
index|]
init|=
literal|"har"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fcut
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nocutting
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|papuse
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|harcode
decl_stmt|;
end_decl_stmt

begin_macro
name|t_init
argument_list|(
argument|reinit
argument_list|)
end_macro

begin_comment
comment|/* initialize device */
end_comment

begin_decl_stmt
name|int
name|reinit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|int
name|size
decl_stmt|;
name|hpos
operator|=
name|vpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|devname
argument_list|,
literal|"har"
argument_list|)
operator|!=
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"This input is not for the harris"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tf
condition|)
if|if
condition|(
operator|(
name|tf
operator|=
name|creat
argument_list|(
literal|"@har.in"
argument_list|,
literal|0664
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"Cannot create outputfile"
argument_list|)
expr_stmt|;
comment|/* if there is a drawing character, use it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchtab
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|chname
index|[
name|chtab
index|[
name|i
index|]
index|]
argument_list|,
literal|"l."
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|nchtab
condition|)
block|{
name|drawdot
operator|=
name|i
operator|+
literal|128
expr_stmt|;
name|drawsize
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|drawdot
operator|=
literal|'.'
expr_stmt|;
name|drawsize
operator|=
literal|3
expr_stmt|;
comment|/* 1/3 size */
block|}
name|output
operator|=
literal|1
expr_stmt|;
name|oput
argument_list|(
name|VMV
argument_list|)
expr_stmt|;
name|oput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|oput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* See Harris Manual appendix D */
name|oput
argument_list|(
name|HPO
argument_list|)
expr_stmt|;
name|oput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|oput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* some initial size */
name|size
operator|=
literal|10
expr_stmt|;
name|putsize
argument_list|()
expr_stmt|;
name|putfont
argument_list|(
literal|999
argument_list|)
expr_stmt|;
name|oput
argument_list|(
name|STA
argument_list|)
expr_stmt|;
name|oput
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|oput
argument_list|(
literal|0360
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflag
condition|)
block|{
name|operator
argument_list|(
literal|"Translating"
argument_list|)
expr_stmt|;
name|oput
argument_list|(
name|EST
argument_list|)
expr_stmt|;
comment|/* enable slave Translator */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Slave code translator enabled\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|operator
argument_list|(
literal|"dhar started"
argument_list|)
expr_stmt|;
name|oput
argument_list|(
name|OB0
argument_list|)
expr_stmt|;
comment|/* reset oblique */
name|oput
argument_list|(
name|NAD
argument_list|)
expr_stmt|;
comment|/* No automatic displacement */
name|output
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The reason of struct state is never explained by bwk  * but it looks like an stack of environments being pushed and popped  *  */
end_comment

begin_define
define|#
directive|define
name|MAXSTATE
value|5
end_define

begin_struct
struct|struct
name|state
block|{
name|int
name|ssize
decl_stmt|;
name|int
name|sfont
decl_stmt|;
name|int
name|shpos
decl_stmt|;
name|int
name|svpos
decl_stmt|;
name|int
name|shorig
decl_stmt|;
name|int
name|svorig
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|state
name|state
index|[
name|MAXSTATE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|state
modifier|*
name|statep
init|=
name|state
decl_stmt|;
end_decl_stmt

begin_macro
name|t_push
argument_list|()
end_macro

begin_comment
comment|/* begin a new block */
end_comment

begin_block
block|{
extern|extern size;
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"Different environment entered!"
argument_list|)
expr_stmt|;
name|hflush
argument_list|()
expr_stmt|;
name|statep
operator|->
name|ssize
operator|=
name|size
expr_stmt|;
name|statep
operator|->
name|sfont
operator|=
name|font
expr_stmt|;
name|statep
operator|->
name|shorig
operator|=
name|horig
expr_stmt|;
name|statep
operator|->
name|svorig
operator|=
name|vorig
expr_stmt|;
name|statep
operator|->
name|shpos
operator|=
name|hpos
expr_stmt|;
name|statep
operator|->
name|svpos
operator|=
name|vpos
expr_stmt|;
name|horig
operator|=
name|hpos
expr_stmt|;
name|vorig
operator|=
name|vpos
expr_stmt|;
name|hpos
operator|=
name|vpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|statep
operator|++
operator|>=
name|state
operator|+
name|MAXSTATE
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"{ nested too deep"
argument_list|)
expr_stmt|;
name|hpos
operator|=
name|vpos
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|t_pop
argument_list|()
end_macro

begin_comment
comment|/* pop to previous state */
end_comment

begin_block
block|{
extern|extern size;
if|if
condition|(
operator|--
name|statep
operator|<
name|state
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"extra }"
argument_list|)
expr_stmt|;
name|size
operator|=
name|statep
operator|->
name|ssize
expr_stmt|;
name|font
operator|=
name|statep
operator|->
name|sfont
expr_stmt|;
name|hpos
operator|=
name|statep
operator|->
name|shpos
expr_stmt|;
name|vpos
operator|=
name|statep
operator|->
name|svpos
expr_stmt|;
name|horig
operator|=
name|statep
operator|->
name|shorig
expr_stmt|;
name|vorig
operator|=
name|statep
operator|->
name|svorig
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|pageno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|t_page
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* do whatever new page functions */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|output
condition|)
block|{
name|papuse
operator|++
expr_stmt|;
comment|/* 		 * accounting in pages, for the time being. 		 * New harprot should do the real accounting 		 */
if|if
condition|(
operator|++
name|scount
operator|>=
name|spage
condition|)
block|{
name|t_reset
argument_list|(
literal|'p'
argument_list|)
expr_stmt|;
name|scount
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|vpos
operator|=
literal|0
expr_stmt|;
name|output
operator|=
literal|1
expr_stmt|;
operator|++
name|pageno
expr_stmt|;
if|if
condition|(
name|nolist
operator|==
literal|0
condition|)
return|return;
comment|/* no -o specified */
name|output
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nolist
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
name|n
operator|>=
name|olist
index|[
name|i
index|]
operator|&&
name|n
operator|<=
name|olist
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|output
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_macro
name|t_newline
argument_list|()
end_macro

begin_comment
comment|/* do whatever for the end of a line */
end_comment

begin_block
block|{
name|hpos
operator|=
literal|0
expr_stmt|;
comment|/* because we're now back at the left margin */
block|}
end_block

begin_comment
comment|/*  * A PSZ command on the Harris will change the horizontal& vertical size  * A HPZ command will change just the Horizontal size.  *  * so size will contain horizontal size, and versize the vertical  */
end_comment

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current sizenumber (a legal index in pstab) */
end_comment

begin_decl_stmt
name|int
name|horsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current horizontal size */
end_comment

begin_decl_stmt
name|int
name|versize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current vertcal size */
end_comment

begin_decl_stmt
name|int
name|vsizeflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, versize differs from size */
end_comment

begin_macro
name|t_size
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* convert integer to internal size number*/
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|n
operator|<=
name|pstab
index|[
literal|0
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|n
operator|>=
name|pstab
index|[
name|nsizes
operator|-
literal|1
index|]
condition|)
return|return
operator|(
name|nsizes
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|n
operator|>
name|pstab
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|i
operator|+
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|t_charht
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set character height to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|versize
operator|=
name|pstab
index|[
name|n
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|versize
operator|!=
name|horsize
condition|)
name|vsizeflag
operator|=
literal|1
expr_stmt|;
name|putsize
argument_list|()
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|sltab
index|[]
init|=
block|{
literal|0
block|,
literal|9
block|,
literal|12
block|,
literal|15
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* possible slanting factors */
end_comment

begin_decl_stmt
name|int
name|slctab
index|[]
init|=
block|{
name|OB0
block|,
name|OB1
block|,
name|OB2
block|,
name|OB3
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* slanting codes */
end_comment

begin_decl_stmt
name|int
name|slant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current general slanting factor (of slant cmd) */
end_comment

begin_decl_stmt
name|int
name|fslant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* slanting factor of current font */
end_comment

begin_comment
comment|/*  * current font has to be slanted, the slant will be set to fslant.  * if the has been a slant command, the slant will be set to "slant",  * overiding the fslant.  * if slant is reset to 0, and there fslant != 0, slant will be set to "fslant"  *  * fslant will be manupulated by setfont (slanting can be an attribute  * to a (Harris-)font.  *  * There are to many slants in this comment  */
end_comment

begin_macro
name|t_slant
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* do slant cmd */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|slant
operator|=
name|n
expr_stmt|;
name|setslant
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|setslant
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set slant to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|j
decl_stmt|;
specifier|static
name|int
name|aslant
decl_stmt|;
comment|/* the actual slanting factor */
if|if
condition|(
name|n
operator|==
name|aslant
condition|)
return|return;
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
name|fslant
condition|)
block|{
comment|/* back to slant of font */
name|setslant
argument_list|(
name|fslant
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|n
operator|>
operator|(
name|aslant
operator|=
name|sltab
index|[
name|j
index|]
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|aslant
operator|==
operator|-
literal|1
condition|)
block|{
name|aslant
operator|=
name|sltab
index|[
operator|--
name|j
index|]
expr_stmt|;
break|break;
block|}
name|hflush
argument_list|()
expr_stmt|;
name|oput
argument_list|(
name|slctab
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"slant to %d\n"
argument_list|,
name|aslant
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|slantfont
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set fontslant */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fslant
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|slant
condition|)
return|return;
comment|/* slant of slanting command 				 * overrides fslant */
name|setslant
argument_list|(
name|fslant
argument_list|)
expr_stmt|;
comment|/* set slanting */
block|}
end_block

begin_macro
name|t_font
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* convert string to internal font number */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|nfonts
condition|)
name|n
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|t_text
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* print string s as text, the real \! implemantation */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|,
name|w
decl_stmt|;
name|char
name|str
index|[
literal|100
index|]
decl_stmt|;
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"t_text not well implented (yet)!"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
return|return;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
switch|switch
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'\\'
case|:
case|case
literal|'e'
case|:
name|put1
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|str
index|[
literal|0
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|str
index|[
literal|1
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|str
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|put1s
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|put1
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|hmot
argument_list|(
name|lastw
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"width = %d\n"
argument_list|,
name|lastw
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|t_reset
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|output
condition|)
comment|/* 		 papuse++ 		 */
empty_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'p'
case|:
name|cut
argument_list|()
expr_stmt|;
comment|/* 			 * interpret pauses as comment for cutting 			 * the paper 			 */
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"reset p\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|cut
argument_list|()
expr_stmt|;
name|nocutting
operator|++
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"reset s\n"
argument_list|)
expr_stmt|;
name|ex
argument_list|()
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"Unknown reset function"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_macro
name|cut
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|cflag
operator|||
name|nocutting
condition|)
return|return;
name|hflush
argument_list|()
expr_stmt|;
name|oput
argument_list|(
name|CUT
argument_list|)
expr_stmt|;
name|hpos
operator|=
literal|0
expr_stmt|;
name|fcut
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"Cut\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|account
argument_list|()
end_macro

begin_comment
comment|/* record paper use */
end_comment

begin_block
block|{
comment|/* Don somewhere els */
block|}
end_block

begin_macro
name|t_trailer
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_macro
name|hflush
argument_list|()
end_macro

begin_comment
comment|/* do the actual motion */
end_comment

begin_block
block|{
if|if
condition|(
operator|!
name|output
condition|)
return|return;
name|hor_move
argument_list|(
name|hpos
operator|-
name|htrue
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hor_move
argument_list|(
argument|amount
argument_list|)
end_macro

begin_decl_stmt
name|int
name|amount
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|high
decl_stmt|,
name|low
decl_stmt|;
ifdef|#
directive|ifdef
name|VAX
if|if
condition|(
name|abs
argument_list|(
name|amount
argument_list|)
operator|>
literal|0177777
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"Impossible escape"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|amount
operator|==
literal|0
operator|&&
name|harcode
operator|==
literal|0
condition|)
return|return;
comment|/* really nothing to do */
if|if
condition|(
name|dbg
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"h_move %d\n"
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|low
operator|=
name|amount
operator|&
name|BMASK
expr_stmt|;
name|high
operator|=
operator|(
name|amount
operator|>>
name|BYTE
operator|)
operator|&
name|BMASK
expr_stmt|;
comment|/* 	 * if there is a code wating for output, 	 * send that one to be output, plus the movement, 	 * else send the MAB 	 * and the movement 	 */
name|oput
argument_list|(
name|harcode
condition|?
name|harcode
else|:
name|MAB
argument_list|)
expr_stmt|;
name|harcode
operator|=
literal|0
expr_stmt|;
name|oput
argument_list|(
name|high
argument_list|)
expr_stmt|;
name|oput
argument_list|(
name|low
argument_list|)
expr_stmt|;
name|htrue
operator|=
name|hpos
expr_stmt|;
block|}
end_block

begin_macro
name|hmot
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
name|hpos
operator|+=
name|n
expr_stmt|;
block|}
end_block

begin_macro
name|hgoto
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
name|hpos
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_macro
name|vgoto
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
name|vmot
argument_list|(
name|n
operator|-
name|vpos
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|vmot
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* generate n units of vertical motion */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|output
condition|)
return|return;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|ver_move
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|vpos
operator|+=
name|n
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|ver_move
argument_list|(
argument|amount
argument_list|)
end_macro

begin_decl_stmt
name|int
name|amount
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|high
decl_stmt|,
name|low
decl_stmt|;
ifdef|#
directive|ifdef
name|VAX
if|if
condition|(
name|abs
argument_list|(
name|amount
argument_list|)
operator|>
literal|0177777
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"Impossible leading"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dbg
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"v_move %d\n"
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|low
operator|=
name|amount
operator|&
name|BMASK
expr_stmt|;
name|high
operator|=
operator|(
name|amount
operator|>>
name|BYTE
operator|)
operator|&
name|BMASK
expr_stmt|;
name|hflush
argument_list|()
expr_stmt|;
name|oput
argument_list|(
name|VMV
argument_list|)
expr_stmt|;
name|oput
argument_list|(
name|high
argument_list|)
expr_stmt|;
name|oput
argument_list|(
name|low
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|put1s
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* s is a funny char name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
return|return;
comment|/* 	if(strcmp("ul", s) == 0) { 		set_ul(); 		return; 	} 	if(strcmp("ru", s) == 0) { 		set_ru(); 		return; 	} */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchtab
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|chname
index|[
name|chtab
index|[
name|i
index|]
index|]
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* printf("i+128: %d,s: %s, chname: %s\n", i+128, s,&chname[chtab[i]]); */
if|if
condition|(
name|i
operator|<
name|nchtab
condition|)
name|put1
argument_list|(
name|i
operator|+
literal|128
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"Special char %s doesn't exist\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The Harris doesn'nt have a proper underrule or rule  *  * Try to generate one with the RULE command.  *  */
end_comment

begin_define
define|#
directive|define
name|UL_DOWN
value|7
end_define

begin_comment
comment|/* 7 half decipoints at pointsize 10 */
end_comment

begin_macro
name|set_ul
argument_list|()
end_macro

begin_block
block|{
name|int
name|move
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|hflush
argument_list|()
expr_stmt|;
name|move
operator|=
name|UL_DOWN
operator|*
name|versize
expr_stmt|;
name|ver_move
argument_list|(
name|move
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|get_width
argument_list|(
literal|"ul"
argument_list|)
operator|/
literal|2
expr_stmt|;
comment|/* 		 * we assume that dev.unitwidth is 10, so getwidth 		 * will return the value in half decipoints! 		 */
name|set_line
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|ver_move
argument_list|(
operator|-
name|move
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|RU_DOWN
value|1
end_define

begin_comment
comment|/* 2 half decipoints at pointsize 10 */
end_comment

begin_macro
name|set_ru
argument_list|()
end_macro

begin_block
block|{
name|int
name|tmp
decl_stmt|,
name|move
decl_stmt|;
name|hflush
argument_list|()
expr_stmt|;
name|move
operator|=
name|RU_DOWN
operator|*
name|versize
expr_stmt|;
name|ver_move
argument_list|(
name|move
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|get_width
argument_list|(
literal|"ul"
argument_list|)
operator|/
literal|2
expr_stmt|;
name|set_line
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|ver_move
argument_list|(
operator|-
name|move
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|HEIGHT
value|6
end_define

begin_comment
comment|/* thickness (decipoints) at pointsize 10 */
end_comment

begin_define
define|#
directive|define
name|MIN_VAL
value|2
end_define

begin_comment
comment|/* Minimum value for rule height& length */
end_comment

begin_define
define|#
directive|define
name|MAX_H
value|720
end_define

begin_comment
comment|/* Maximum for height */
end_comment

begin_define
define|#
directive|define
name|MAX_L
value|8160
end_define

begin_comment
comment|/* Maximum length of the SMC 68 Pica machine */
end_comment

begin_comment
comment|/*  * set line of length decipoints.  */
end_comment

begin_macro
name|set_line
argument_list|(
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|height
decl_stmt|;
name|char
name|one
decl_stmt|,
name|two
decl_stmt|,
name|three
decl_stmt|,
name|four
decl_stmt|;
comment|/* 	printf("Line %d decipoints\n", i); 	*/
name|height
operator|=
operator|(
name|HEIGHT
operator|*
name|versize
operator|+
name|dev
operator|.
name|unitwidth
operator|/
literal|2
operator|)
operator|/
name|dev
operator|.
name|unitwidth
expr_stmt|;
if|if
condition|(
name|height
operator|<
name|MIN_VAL
condition|)
name|height
operator|=
name|MIN_VAL
expr_stmt|;
if|if
condition|(
name|height
operator|>
name|MAX_H
condition|)
name|height
operator|=
name|MAX_H
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|MAX_L
condition|)
name|length
operator|=
name|MAX_L
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"Line: length %d height %d\n"
argument_list|,
name|length
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|one
operator|=
operator|(
name|height
operator|>>
name|BYTE
operator|)
operator||
name|RUL
expr_stmt|;
name|two
operator|=
name|height
operator|&
name|BMASK
expr_stmt|;
name|three
operator|=
name|length
operator|>>
name|BYTE
expr_stmt|;
name|four
operator|=
name|length
operator|&
name|BMASK
expr_stmt|;
name|oput
argument_list|(
name|one
argument_list|)
expr_stmt|;
name|oput
argument_list|(
name|two
argument_list|)
expr_stmt|;
name|oput
argument_list|(
name|three
argument_list|)
expr_stmt|;
name|oput
argument_list|(
name|four
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * get the width of a char, to be used only by set_ul() and set-ru()  */
end_comment

begin_function
name|int
name|get_width
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|j
decl_stmt|,
name|i
decl_stmt|,
name|k
decl_stmt|,
name|ofont
decl_stmt|;
name|char
modifier|*
name|pw
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|nchtab
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|chname
index|[
name|chtab
index|[
name|c
index|]
index|]
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|c
operator|<
name|nchtab
condition|)
name|c
operator|+=
literal|128
operator|-
literal|32
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
operator|||
name|c
operator|>=
name|nchtab
operator|+
literal|128
operator|-
literal|32
condition|)
block|{
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"non-exist 0%o\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|)
expr_stmt|;
return|return;
block|}
name|k
operator|=
name|ofont
operator|=
name|font
expr_stmt|;
name|i
operator|=
name|fitab
index|[
name|font
index|]
index|[
name|c
index|]
operator|&
name|BMASK
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* it's on this font */
name|pw
operator|=
name|widthtab
index|[
name|font
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|smnt
operator|>
literal|0
condition|)
block|{
comment|/* on special (we hope) */
for|for
control|(
name|k
operator|=
name|smnt
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|nfonts
condition|;
name|j
operator|++
operator|,
name|k
operator|=
operator|(
name|k
operator|+
literal|1
operator|)
operator|%
operator|(
name|nfonts
operator|+
literal|1
operator|)
control|)
comment|/* 			 * Look for the character, start at the special font 			 * and search further in a wrap around manner  			 */
if|if
condition|(
operator|(
name|i
operator|=
name|fitab
index|[
name|k
index|]
index|[
name|c
index|]
operator|&
name|BMASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|pw
operator|=
name|widthtab
index|[
name|k
index|]
expr_stmt|;
name|setfont
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|||
operator|(
name|width
operator|=
name|pw
index|[
name|i
index|]
operator|&
name|BMASK
operator|)
operator|==
literal|0
operator|||
name|k
operator|>
name|nfonts
condition|)
block|{
comment|/* device drivers do width& 077, not really necessary */
if|if
condition|(
name|dbg
condition|)
block|{
name|printf
argument_list|(
literal|"Width not found \\(%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|width
operator|=
operator|(
name|width
operator|*
name|horsize
operator|+
name|dev
operator|.
name|unitwidth
operator|/
literal|2
operator|)
operator|/
name|dev
operator|.
name|unitwidth
expr_stmt|;
if|if
condition|(
name|font
operator|!=
name|ofont
condition|)
name|setfont
argument_list|(
name|ofont
argument_list|)
expr_stmt|;
return|return
operator|(
name|width
operator|)
return|;
block|}
end_function

begin_comment
comment|/* font position info: */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
name|fontname
index|[
name|NFONT
operator|+
literal|1
index|]
struct|;
end_struct

begin_macro
name|put1
argument_list|(
argument|c
argument_list|)
end_macro

begin_comment
comment|/* output char c */
end_comment

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|pw
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|int
name|j
decl_stmt|,
name|ofont
decl_stmt|,
name|code
decl_stmt|;
name|short
name|f
decl_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
return|return;
name|c
operator|-=
literal|32
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"non-exist 0%o\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|)
expr_stmt|;
name|lastw
operator|=
name|widthtab
index|[
name|font
index|]
index|[
literal|0
index|]
operator|*
name|pstab
index|[
name|size
operator|-
literal|1
index|]
operator|/
name|dev
operator|.
name|unitwidth
expr_stmt|;
return|return;
block|}
name|k
operator|=
name|ofont
operator|=
name|font
expr_stmt|;
name|i
operator|=
name|fitab
index|[
name|font
index|]
index|[
name|c
index|]
operator|&
name|BMASK
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* it's on this font */
name|p
operator|=
name|codetab
index|[
name|font
index|]
expr_stmt|;
name|pw
operator|=
name|widthtab
index|[
name|font
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|smnt
operator|>
literal|0
condition|)
block|{
comment|/* on special (we hope) */
for|for
control|(
name|k
operator|=
name|smnt
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|nfonts
condition|;
name|j
operator|++
operator|,
name|k
operator|=
operator|(
name|k
operator|+
literal|1
operator|)
operator|%
operator|(
name|nfonts
operator|+
literal|1
operator|)
control|)
comment|/* 			 * Look for the character, start at the special font 			 * and search further in a wrap around manner  			 */
if|if
condition|(
operator|(
name|i
operator|=
name|fitab
index|[
name|k
index|]
index|[
name|c
index|]
operator|&
name|BMASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|codetab
index|[
name|k
index|]
expr_stmt|;
name|pw
operator|=
name|widthtab
index|[
name|k
index|]
expr_stmt|;
name|setfont
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|||
operator|(
name|code
operator|=
name|p
index|[
name|i
index|]
operator|&
name|BMASK
operator|)
operator|==
literal|0
operator|||
name|k
operator|>
name|nfonts
condition|)
block|{
if|if
condition|(
name|dbg
condition|)
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
operator|+
literal|32
argument_list|)
operator|&&
name|isascii
argument_list|(
name|c
operator|+
literal|32
argument_list|)
condition|)
name|printf
argument_list|(
literal|"not found %c\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"not found \\(%s\n"
argument_list|,
operator|&
name|chname
index|[
name|chtab
index|[
name|c
operator|-
literal|128
operator|+
literal|32
index|]
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|fontbase
index|[
name|k
index|]
operator|->
name|fonttab
operator|==
literal|1
condition|)
name|f
operator|=
name|fonttab
index|[
name|k
index|]
index|[
name|i
index|]
expr_stmt|;
else|else
name|f
operator|=
name|fontname
index|[
name|k
index|]
operator|.
name|number
expr_stmt|;
name|hflush
argument_list|()
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
operator|+
literal|32
argument_list|)
operator|&&
name|isascii
argument_list|(
name|c
operator|+
literal|32
argument_list|)
condition|)
block|{
comment|/* My God! */
name|printf
argument_list|(
literal|"%c %d %d\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|,
name|code
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\\(%s %d %d\n"
argument_list|,
operator|&
name|chname
index|[
name|chtab
index|[
name|c
operator|-
literal|128
operator|+
literal|32
index|]
index|]
argument_list|,
name|code
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
literal|0
operator|||
name|code
operator|>
literal|0200
condition|)
block|{
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"Illegal code 0%o found for char %03o\n"
argument_list|,
name|code
argument_list|,
name|c
operator|+
literal|32
argument_list|)
expr_stmt|;
block|}
name|putcode
argument_list|(
name|code
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* character is< 254 */
if|if
condition|(
name|font
operator|!=
name|ofont
condition|)
comment|/* char on special font, reset	*/
name|setfont
argument_list|(
name|ofont
argument_list|)
expr_stmt|;
name|lastw
operator|=
name|pw
index|[
name|i
index|]
operator|&
name|BMASK
expr_stmt|;
comment|/*HIRO*/
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"lastw %d pw[i] %d\n"
argument_list|,
name|lastw
argument_list|,
name|pw
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|lastw
operator|=
operator|(
name|lastw
operator|*
name|pstab
index|[
name|size
operator|-
literal|1
index|]
operator|+
name|dev
operator|.
name|unitwidth
operator|/
literal|2
operator|)
operator|/
name|dev
operator|.
name|unitwidth
expr_stmt|;
block|}
end_block

begin_macro
name|putcode
argument_list|(
argument|code
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|char
name|code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|short
name|phfont
decl_stmt|;
ifdef|#
directive|ifdef
name|VAX
if|if
condition|(
name|f
operator|>
literal|0177777
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"Impossible font selected"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|harcode
condition|)
block|{
comment|/* if character pending */
name|hflush
argument_list|()
expr_stmt|;
comment|/* update position and flush pending char */
block|}
if|if
condition|(
name|f
operator|!=
name|phfont
condition|)
block|{
if|if
condition|(
name|dbg
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"font to %d\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|putfont
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|harcode
operator|=
name|code
expr_stmt|;
name|phfont
operator|=
name|f
expr_stmt|;
block|}
end_block

begin_macro
name|putfont
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|high
decl_stmt|,
name|low
decl_stmt|;
name|low
operator|=
name|f
operator|&
name|BMASK
expr_stmt|;
name|high
operator|=
operator|(
name|f
operator|>>
name|BYTE
operator|)
operator|&
name|BMASK
expr_stmt|;
name|oput
argument_list|(
name|FNT
argument_list|)
expr_stmt|;
name|oput
argument_list|(
name|high
argument_list|)
expr_stmt|;
name|oput
argument_list|(
name|low
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|setsize
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set point size to a true pointsize */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|output
condition|)
return|return;
name|horsize
operator|=
name|pstab
index|[
name|n
operator|-
literal|1
index|]
expr_stmt|;
name|vsizeflag
operator|=
literal|0
expr_stmt|;
name|size
operator|=
name|n
expr_stmt|;
name|putsize
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Do the actual sizechange(s).  */
end_comment

begin_macro
name|putsize
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|vsizeflag
condition|)
block|{
name|flushchar
argument_list|()
expr_stmt|;
name|sizecmd
argument_list|(
name|PSZ
argument_list|,
name|horsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flushchar
argument_list|()
expr_stmt|;
name|sizecmd
argument_list|(
name|PSZ
argument_list|,
name|versize
argument_list|)
expr_stmt|;
name|sizecmd
argument_list|(
name|HPZ
argument_list|,
name|horsize
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|sizecmd
argument_list|(
argument|cmd
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cmd
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|low
decl_stmt|,
name|high
decl_stmt|;
name|i
operator|=
literal|10
operator|*
name|n
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"size to %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|01777
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"Impossible pointsize requested"
argument_list|)
expr_stmt|;
name|low
operator|=
name|i
operator|&
name|BMASK
expr_stmt|;
name|high
operator|=
operator|(
name|i
operator|>>
name|BYTE
operator|)
operator|&
name|BMASK
expr_stmt|;
if|if
condition|(
name|high
operator|>
literal|03
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"system error in point size cmd"
argument_list|)
expr_stmt|;
name|oput
argument_list|(
name|cmd
operator||
name|high
argument_list|)
expr_stmt|;
name|oput
argument_list|(
name|low
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|t_fp
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|,
argument|si
argument_list|)
end_macro

begin_comment
comment|/* font position n now contains font s, intname si */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|si
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fontname
index|[
name|n
index|]
operator|.
name|name
operator|=
name|s
expr_stmt|;
name|fontname
index|[
name|n
index|]
operator|.
name|number
operator|=
name|atoi
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|setfont
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set font to n (internal)*/
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|output
condition|)
return|return;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|NFONT
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"illegal font %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|font
operator|=
name|n
expr_stmt|;
name|slantfont
argument_list|(
name|fontbase
index|[
name|n
index|]
operator|->
name|slant
operator|&
name|BMASK
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* putint(n) { 	if (dbg) { 		printf("%02d\n", n); 		return; 	} 	putc(n>>8, tf); 	putc(n, tf); } */
end_comment

end_unit

