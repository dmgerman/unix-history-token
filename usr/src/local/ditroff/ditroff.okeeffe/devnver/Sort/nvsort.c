begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)nvsort.c	1.2 (CWI) 86/11/26"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * from (Berkeley):  *    vsort.c	1.11	84/05/29  *  *	Sorts and shuffles ditroff output for versatec wide printer.  It  *	puts pages side-by-side on the output, and fits as many as it can  *	on one horizontal span.  The versatec driver sees only pages of  *	full width, not the individual pages.  Output is sorted vertically  *	and bands are created NLINES pixels high.  Any object that has  *	ANY part of it in a band is put on that band.  *  *	Jaap Akkerhuis  *	de-Berkletized by #ifdef BERK  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_comment
comment|/* #define DEBUGABLE	/* compile-time flag for debugging */
end_comment

begin_define
define|#
directive|define
name|FATAL
value|1
end_define

begin_define
define|#
directive|define
name|NVLIST
value|3000
end_define

begin_comment
comment|/* size of list of vertical spans */
end_comment

begin_define
define|#
directive|define
name|OBUFSIZ
value|250000
end_define

begin_comment
comment|/* size of character buffer before sorting */
end_comment

begin_define
define|#
directive|define
name|SLOP
value|1000
end_define

begin_comment
comment|/* extra bit of buffer to allow for passing OBUFSIZ */
end_comment

begin_define
define|#
directive|define
name|MAXVECT
value|200
end_define

begin_comment
comment|/* maximum number of points (vectors) in a polygon */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FONTDIR
end_ifndef

begin_define
define|#
directive|define
name|FONTDIR
value|"/usr/lib/font"
end_define

begin_endif
endif|#
directive|endif
endif|FONTDIR
end_endif

begin_define
define|#
directive|define
name|POINT
value|72
end_define

begin_comment
comment|/* number of points per inch */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|VER80
end_ifndef

begin_define
define|#
directive|define
name|WIDTH
value|7040
end_define

begin_comment
comment|/* number of pixels across the page */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WIDTH
value|2112
end_define

begin_comment
comment|/* number of pixels across the page */
end_comment

begin_comment
comment|/* 	 * Note that this does not work unless the input really is 	 * designed for the versatec, i.e., res = 200.  But that's 	 * OK, because it is only used for side-by-side pages, which 	 * we don't do anyway. 	 * DD 	 */
end_comment

begin_endif
endif|#
directive|endif
endif|VER80
end_endif

begin_define
define|#
directive|define
name|BAND
value|2.2
end_define

begin_comment
comment|/* length of each band in inches */
end_comment

begin_define
define|#
directive|define
name|NLINES
value|(int)(BAND * inch)
end_define

begin_comment
comment|/* number of pixels in each band */
end_comment

begin_define
define|#
directive|define
name|HALF
value|(inch/2)
end_define

begin_define
define|#
directive|define
name|hgoto
parameter_list|(
name|n
parameter_list|)
value|if((hpos = leftmarg + n)> maxh) maxh = hpos
end_define

begin_define
define|#
directive|define
name|hmot
parameter_list|(
name|n
parameter_list|)
value|if((hpos += n)> maxh) maxh = hpos
end_define

begin_define
define|#
directive|define
name|vmot
parameter_list|(
name|n
parameter_list|)
value|vpos += (n)
end_define

begin_define
define|#
directive|define
name|vgoto
parameter_list|(
name|n
parameter_list|)
value|vpos = (n)
end_define

begin_decl_stmt
name|int
name|dbg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug flag != 0 means do debug output */
end_comment

begin_decl_stmt
name|int
name|size
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current size (points) */
end_comment

begin_decl_stmt
name|int
name|up
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pixels that the current size pushes up */
end_comment

begin_decl_stmt
name|int
name|down
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of pixels that the current size will hang down */
end_comment

begin_decl_stmt
name|int
name|font
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current font */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fontdir
init|=
name|FONTDIR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place to find DESC.out file	*/
end_comment

begin_decl_stmt
name|int
name|inch
init|=
literal|200
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* resolution of the device, in inches	*/
end_comment

begin_comment
comment|/* #ifdef BERK		/* leave this one in for now */
end_comment

begin_decl_stmt
name|int
name|thick
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line thickness */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BERK
end_ifdef

begin_decl_stmt
name|int
name|stip
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current stipple */
end_comment

begin_decl_stmt
name|int
name|style
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line style bit-mask */
end_comment

begin_endif
endif|#
directive|endif
endif|BERK
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BERK
end_ifndef

begin_decl_stmt
name|int
name|started
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* see or we started */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|hpos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* horizontal position to be at next (left = 0) */
end_comment

begin_decl_stmt
name|int
name|vpos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current vertical position (down positive) */
end_comment

begin_decl_stmt
name|int
name|maxh
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* farthest right we've gone on the current span */
end_comment

begin_decl_stmt
name|int
name|leftmarg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current page offset */
end_comment

begin_decl_stmt
name|int
name|spanno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current span number for driver in 'p#' commands */
end_comment

begin_decl_stmt
name|int
name|pageno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pages spread across a physical page */
end_comment

begin_struct
struct|struct
name|vlist
block|{
name|unsigned
name|short
name|v
decl_stmt|;
comment|/* vertical position of this spread */
name|unsigned
name|short
name|h
decl_stmt|;
comment|/* horizontal position */
name|unsigned
name|short
name|t
decl_stmt|;
comment|/* line thickness */
ifdef|#
directive|ifdef
name|BERK
name|short
name|st
decl_stmt|;
comment|/* style mask */
name|unsigned
name|char
name|l
decl_stmt|;
comment|/* stipple number */
endif|#
directive|endif
endif|BERK
name|unsigned
name|short
name|u
decl_stmt|;
comment|/* upper extent of height */
name|unsigned
name|short
name|d
decl_stmt|;
comment|/* depth of height */
name|unsigned
name|short
name|s
decl_stmt|;
comment|/* point size */
name|unsigned
name|char
name|f
decl_stmt|;
comment|/* font number */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* text pointer to this spread */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|vlist
name|vlist
index|[
name|NVLIST
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vlist
modifier|*
name|vlp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current spread being added to */
end_comment

begin_decl_stmt
name|int
name|nvlist
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of spreads in list */
end_comment

begin_decl_stmt
name|int
name|obufsiz
init|=
name|OBUFSIZ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|obuf
index|[
name|OBUFSIZ
operator|+
name|SLOP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|op
init|=
name|obuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to current spot in buffer */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|double
name|atof
parameter_list|()
function_decl|;
name|vlp
operator|=
operator|&
name|vlist
index|[
literal|0
index|]
expr_stmt|;
comment|/* initialize spread pointer */
name|vlp
operator|->
name|p
operator|=
name|op
expr_stmt|;
name|vlp
operator|->
name|v
operator|=
name|vlp
operator|->
name|d
operator|=
name|vlp
operator|->
name|u
operator|=
name|vlp
operator|->
name|h
operator|=
literal|0
expr_stmt|;
name|vlp
operator|->
name|s
operator|=
name|size
expr_stmt|;
name|vlp
operator|->
name|f
operator|=
name|font
expr_stmt|;
ifdef|#
directive|ifdef
name|BERK
name|vlp
operator|->
name|l
operator|=
name|stip
expr_stmt|;
name|vlp
operator|->
name|st
operator|=
name|style
expr_stmt|;
endif|#
directive|endif
endif|BERK
name|vlp
operator|->
name|t
operator|=
name|thick
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
operator|*
operator|*
operator|++
name|argv
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'f'
case|:
name|fontdir
operator|=
operator|&
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUGABLE
case|case
literal|'d'
case|:
name|dbg
operator|=
name|atoi
argument_list|(
operator|&
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbg
condition|)
name|dbg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|(
name|obufsiz
operator|=
name|atoi
argument_list|(
operator|&
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
argument_list|)
operator|)
operator|>
name|OBUFSIZ
condition|)
name|obufsiz
operator|=
name|OBUFSIZ
expr_stmt|;
break|break;
endif|#
directive|endif
endif|DEBUGABLE
block|}
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|conv
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|conv
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|done
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* read number from input:  copy to output */
end_comment

begin_function
name|int
name|getnumber
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
ifndef|#
directive|ifndef
name|BERK
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
comment|/* should be output as well!!! */
endif|#
directive|endif
endif|BERK
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|-
operator|(
operator|(
operator|*
name|op
operator|++
operator|=
name|c
operator|)
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|+
operator|(
operator|*
name|op
operator|++
operator|=
name|c
operator|)
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_function

begin_comment
comment|/* read number from input:  do _
comment|N_
comment|O_
comment|T copy to output */
end_comment

begin_function
name|int
name|ngetnumber
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|-
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|conv
argument_list|(
name|fp
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|m
decl_stmt|,
name|n
decl_stmt|,
name|m1
decl_stmt|,
name|n1
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"conv: got:<%c>, op-obuf=%d V=%d\n"
argument_list|,
name|c
argument_list|,
name|op
operator|-
name|obuf
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUGABLE
if|if
condition|(
name|op
operator|>
name|obuf
operator|+
name|obufsiz
condition|)
block|{
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"buffer overflow %d."
argument_list|,
name|op
operator|-
operator|(
name|obuf
operator|+
name|obufsiz
operator|)
argument_list|)
expr_stmt|;
name|oflush
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
comment|/* filter out noise */
break|break;
case|case
literal|'\n'
case|:
comment|/* let text input through */
case|case
literal|'\t'
case|:
case|case
literal|' '
case|:
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
comment|/* push down current environment */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|t_push
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
comment|/* pop up last environment */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|t_pop
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* two motion digits plus a character */
name|setlimit
argument_list|(
name|vpos
operator|-
name|up
argument_list|,
name|vpos
operator|+
name|down
argument_list|)
expr_stmt|;
comment|/* 			*op++ = c; 			hmot((c-'0') * 10 + (*op++ = getc(fp)) - '0'); 			*op++ = getc(fp); 			 */
name|n
operator|=
operator|(
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|m
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|-
literal|'0'
operator|)
expr_stmt|;
name|hmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%02d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* single ascii character */
name|setlimit
argument_list|(
name|vpos
operator|-
name|up
argument_list|,
name|vpos
operator|+
name|down
argument_list|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* white-space terminated funny character */
name|setlimit
argument_list|(
name|vpos
operator|-
name|up
argument_list|,
name|vpos
operator|+
name|down
argument_list|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
do|do
operator|*
name|op
operator|++
operator|=
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
do|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
do|;
break|break;
case|case
literal|'t'
case|:
comment|/* straight text */
name|setlimit
argument_list|(
name|vpos
operator|-
name|up
argument_list|,
name|vpos
operator|+
name|down
argument_list|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|fgets
argument_list|(
name|op
argument_list|,
name|SLOP
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* draw function */
switch|switch
condition|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|int
name|skip
decl_stmt|;
ifdef|#
directive|ifdef
name|BERK
case|case
literal|'s'
case|:
comment|/* "style" */
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"Ds "
argument_list|)
expr_stmt|;
name|op
operator|+=
literal|3
expr_stmt|;
name|style
operator|=
name|getnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* thickness */
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"Dt "
argument_list|)
expr_stmt|;
name|op
operator|+=
literal|3
expr_stmt|;
name|thick
operator|=
name|getnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|BERK
case|case
literal|'l'
case|:
comment|/* draw a line */
name|n1
operator|=
name|ngetnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|m1
operator|=
name|ngetnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|n
operator|=
name|n1
expr_stmt|;
name|m
operator|=
name|m1
expr_stmt|;
if|if
condition|(
name|m
operator|<
literal|0
condition|)
block|{
name|setlimit
argument_list|(
name|vpos
operator|+
name|m
operator|-
name|thick
operator|/
literal|2
argument_list|,
name|vpos
operator|+
name|thick
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setlimit
argument_list|(
name|vpos
operator|-
operator|(
literal|1
operator|+
name|thick
operator|/
literal|2
operator|)
argument_list|,
name|vpos
operator|+
literal|1
operator|+
name|m
operator|+
name|thick
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"Dl %d %d"
argument_list|,
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|n1
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|m1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|BERK
comment|/* 				 * note that this function is actually 				 * Dl n m . 				 * so we have to skip over the ".". 				 * 				 * Rhetoric question: Why doensn't Berkeley 				 * maintain compatability? 				 */
do|do
block|{
name|skip
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|==
name|EOF
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"Cannot find . in Dl\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|skip
operator|!=
literal|'.'
condition|)
do|;
endif|#
directive|endif
endif|BERK
break|break;
case|case
literal|'e'
case|:
comment|/* ellipse */
name|n
operator|=
name|ngetnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|m
operator|=
name|ngetnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|setlimit
argument_list|(
name|vpos
operator|-
operator|(
name|m
operator|+
name|thick
operator|)
operator|/
literal|2
argument_list|,
name|vpos
operator|+
operator|(
name|m
operator|+
name|thick
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"De %d %d"
argument_list|,
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* circle */
name|n
operator|=
name|ngetnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|setlimit
argument_list|(
name|vpos
operator|-
operator|(
name|n
operator|+
name|thick
operator|)
operator|/
literal|2
argument_list|,
name|vpos
operator|+
operator|(
name|n
operator|+
name|thick
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"Dc %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* arc */
ifdef|#
directive|ifdef
name|BERK
name|n
operator|=
name|getnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|m
operator|=
name|getnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|n1
operator|=
name|getnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|m1
operator|=
name|getnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
else|#
directive|else
name|n
operator|=
name|ngetnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|m
operator|=
name|ngetnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|n1
operator|=
name|ngetnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|m1
operator|=
name|ngetnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BERK
name|arcbounds
argument_list|(
name|n
argument_list|,
name|m
argument_list|,
name|n1
argument_list|,
name|m1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"Da %d %d %d %d"
argument_list|,
name|n
argument_list|,
name|m
argument_list|,
name|n1
argument_list|,
name|m1
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|n
operator|+
name|n1
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|m
operator|+
name|m1
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BERK
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
block|{
specifier|register
name|int
name|nvect
decl_stmt|;
name|int
name|member
decl_stmt|;
name|int
name|border
decl_stmt|;
name|int
name|x
index|[
name|MAXVECT
index|]
decl_stmt|;
name|int
name|y
index|[
name|MAXVECT
index|]
decl_stmt|;
name|border
operator|=
operator|(
name|c
operator|==
literal|'p'
operator|)
expr_stmt|;
comment|/* type of polygon */
name|member
operator|=
name|ngetnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* and member number */
name|nvect
operator|=
literal|1
expr_stmt|;
comment|/* starting point for */
name|x
index|[
literal|1
index|]
operator|=
name|hpos
expr_stmt|;
comment|/* points on polygon */
name|y
index|[
literal|1
index|]
operator|=
name|vpos
expr_stmt|;
name|m
operator|=
name|n
operator|=
name|vpos
expr_stmt|;
comment|/* = max/min vertical */
comment|/* position for curve */
block|{
specifier|register
name|int
name|h
decl_stmt|;
specifier|register
name|int
name|v
decl_stmt|;
name|h
operator|=
name|hpos
expr_stmt|;
comment|/* calculate max and minimum */
name|v
operator|=
name|vpos
expr_stmt|;
comment|/* vertical position */
comment|/*    and get points */
do|do
block|{
name|h
operator|+=
name|ngetnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|v
operator|+=
name|ngetnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|<
name|n
condition|)
name|n
operator|=
name|v
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|>
name|m
condition|)
name|m
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|nvect
operator|<
operator|(
name|MAXVECT
operator|-
literal|1
operator|)
condition|)
comment|/* keep the */
name|nvect
operator|++
expr_stmt|;
comment|/* points in */
name|x
index|[
name|nvect
index|]
operator|=
name|h
expr_stmt|;
comment|/* bounds */
name|y
index|[
name|nvect
index|]
operator|=
name|v
expr_stmt|;
comment|/* of arrays */
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
do|;
block|}
if|if
condition|(
name|border
condition|)
block|{
comment|/* output border as a */
specifier|register
name|int
modifier|*
name|x1
decl_stmt|;
comment|/*  bunch of lines */
specifier|register
name|int
modifier|*
name|x2
decl_stmt|;
comment|/*  instead of having */
specifier|register
name|int
modifier|*
name|y1
decl_stmt|;
comment|/*  the filter do it */
specifier|register
name|int
modifier|*
name|y2
decl_stmt|;
specifier|register
name|int
name|extra
init|=
name|thick
operator|/
literal|2
decl_stmt|;
name|x1
operator|=
operator|&
operator|(
name|x
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/* x1, y1, x2, y2 are */
name|x2
operator|=
operator|&
operator|(
name|x
index|[
literal|1
index|]
operator|)
expr_stmt|;
comment|/* for indexing along */
name|y1
operator|=
operator|&
operator|(
name|y
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/* coordinate arrays */
name|y2
operator|=
operator|&
operator|(
name|y
index|[
literal|1
index|]
operator|)
expr_stmt|;
for|for
control|(
name|border
operator|=
literal|0
init|;
operator|++
name|border
operator|<
name|nvect
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|++
name|y1
operator|>
operator|*
operator|++
name|y2
condition|)
block|{
name|setlimit
argument_list|(
operator|*
name|y2
operator|-
name|extra
argument_list|,
name|vpos
operator|+
name|extra
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setlimit
argument_list|(
name|vpos
operator|-
operator|(
literal|1
operator|+
name|extra
operator|)
argument_list|,
operator|*
name|y2
operator|+
literal|1
operator|+
name|extra
argument_list|)
expr_stmt|;
comment|/* the extra 1's are to force */
comment|/* setlimit to know this is a */
comment|/* real entry (making sure it */
comment|/* doesn't get vpos as limit */
block|}
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"Dl %d %d\n"
argument_list|,
name|c
operator|=
operator|*
operator|++
name|x2
operator|-
operator|*
operator|++
name|x1
argument_list|,
operator|*
name|y2
operator|-
operator|*
name|y1
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* update vpos for */
name|vgoto
argument_list|(
operator|*
name|y2
argument_list|)
expr_stmt|;
comment|/* the setlimit call */
block|}
block|}
else|else
block|{
specifier|register
name|int
modifier|*
name|x1
decl_stmt|;
comment|/* x1, x2, are for */
specifier|register
name|int
modifier|*
name|x2
decl_stmt|;
comment|/* indexing points */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* random int */
name|x1
operator|=
operator|&
operator|(
name|x
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|x2
operator|=
operator|&
operator|(
name|x
index|[
literal|1
index|]
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|++
name|i
operator|<
name|nvect
condition|;
control|)
block|{
name|hmot
argument_list|(
operator|*
operator|++
name|x2
operator|-
operator|*
operator|++
name|x1
argument_list|)
expr_stmt|;
block|}
name|vgoto
argument_list|(
name|y
index|[
name|nvect
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"H%dV%d"
argument_list|,
name|hpos
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|member
condition|)
block|{
name|polygon
argument_list|(
name|member
argument_list|,
name|nvect
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
endif|BERK
case|case
literal|'~'
case|:
comment|/* wiggly line */
ifdef|#
directive|ifdef
name|BERK
case|case
literal|'g'
case|:
comment|/* gremlin curve */
endif|#
directive|endif
endif|BERK
name|startspan
argument_list|(
name|vpos
argument_list|)
expr_stmt|;
comment|/* always put curve */
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"D%c "
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* on its own span */
name|op
operator|+=
literal|3
expr_stmt|;
name|m
operator|=
name|n
operator|=
name|vpos
expr_stmt|;
comment|/* = max/min vertical */
do|do
block|{
comment|/* position for curve */
comment|/* 				hpos += getnumber(fp); 				*op++ = ' '; 				vpos += getnumber(fp); 				*op++ = ' '; 				 */
name|n1
operator|=
name|ngetnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|m1
operator|=
name|ngetnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|n1
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|m1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%d %d "
argument_list|,
name|n1
argument_list|,
name|m1
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|vpos
operator|<
name|n
condition|)
name|n
operator|=
name|vpos
expr_stmt|;
elseif|else
if|if
condition|(
name|vpos
operator|>
name|m
condition|)
name|m
operator|=
name|vpos
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
do|;
name|vlp
operator|->
name|u
operator|=
name|n
operator|<
literal|0
condition|?
literal|0
else|:
name|n
expr_stmt|;
name|vlp
operator|->
name|d
operator|=
name|m
expr_stmt|;
operator|*
name|op
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|startspan
argument_list|(
name|vpos
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unknown drawing command %c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'s'
case|:
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|size
operator|=
name|getnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|up
operator|=
operator|(
operator|(
name|size
operator|+
literal|1
operator|)
operator|*
name|inch
operator|)
operator|/
name|POINT
expr_stmt|;
comment|/* ROUGH estimate */
name|down
operator|=
name|up
operator|/
literal|3
expr_stmt|;
comment|/* of max up/down */
break|break;
case|case
literal|'f'
case|:
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|font
operator|=
name|getnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BERK
case|case
literal|'i'
case|:
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|stip
operator|=
name|getnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|BERK
case|case
literal|'H'
case|:
comment|/* absolute horizontal motion */
name|hgoto
argument_list|(
name|ngetnumber
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"H%d"
argument_list|,
name|hpos
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* reposition by page offset */
break|break;
case|case
literal|'h'
case|:
comment|/* relative horizontal motion */
comment|/* 			*op++ = c; 			hmot(getnumber(fp)); 			 */
name|n
operator|=
name|ngetnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"h%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* useless */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
comment|/* But put it out anyway */
break|break;
case|case
literal|'V'
case|:
comment|/* absolute vertical motion */
comment|/* 			*op++ = c; 			vgoto(getnumber(fp)); 			 */
name|vgoto
argument_list|(
name|ngetnumber
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"V%d"
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* 			*op++ = c; 			vmot(getnumber(fp)); 			 */
name|n
operator|=
name|ngetnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"v%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* new page */
name|startspan
argument_list|(
name|vpos
argument_list|)
expr_stmt|;
name|t_page
argument_list|(
name|ngetnumber
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|vpos
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|BERK
if|if
condition|(
operator|!
name|started
condition|)
name|started
operator|++
expr_stmt|;
endif|#
directive|endif
endif|BERK
break|break;
case|case
literal|'n'
case|:
comment|/* end of line */
name|hpos
operator|=
name|leftmarg
expr_stmt|;
comment|/* 			*op++ = c; 			do 			    *op++ = c = getc(fp); 			while (c != '\n'&& c != EOF); 			 */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|n
operator|=
name|ngetnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|m
operator|=
name|ngetnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%d %d"
argument_list|,
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* comment */
do|do
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
do|;
break|break;
case|case
literal|'x'
case|:
comment|/* device control */
name|devcntrl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"unknown input character %o %c"
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|devcntrl
argument_list|(
argument|fp
argument_list|)
end_macro

begin_comment
comment|/* interpret device control functions */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* returns -1 apon recieving "stop" command */
end_comment

begin_block
block|{
name|char
name|str
index|[
literal|20
index|]
decl_stmt|,
name|str1
index|[
literal|50
index|]
decl_stmt|,
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|c
decl_stmt|,
name|n
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|str
index|[
literal|0
index|]
condition|)
block|{
comment|/* crude for now */
case|case
literal|'r'
case|:
comment|/* resolution assumed when prepared */
comment|/* 		fscanf(fp, "%d",&inRES); 		if (n!=RES) error(FATAL,"Input computed for wrong printer"); 		 */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d %d %d"
argument_list|,
operator|&
name|inch
argument_list|,
operator|&
name|t1
argument_list|,
operator|&
name|t2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|str1
argument_list|,
literal|"x res %d %d %d"
argument_list|,
name|inch
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* reconstruct the string */
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|str1
argument_list|,
literal|"x %s%s"
argument_list|,
name|str
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|startspan
argument_list|(
name|vpos
argument_list|)
expr_stmt|;
comment|/* 	*op++ = c; 	do 	    *op++ = c = getc(fp); 	while (c != '\n'&& c != EOF); 	 */
name|p
operator|=
name|str1
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
operator|*
name|op
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	setlimit  |  | Results:	using "newup" and "newdown" decide when to start a new span.  |		maximum rise and/or fall of a vertical extent are saved.  |  | Side Efct:	may start new span.  *----------------------------------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|diffspan
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)/NLINES != (y)/NLINES)
end_define

begin_expr_stmt
name|setlimit
argument_list|(
name|newup
argument_list|,
name|newdown
argument_list|)
specifier|register
name|int
name|newup
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|newdown
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|currup
init|=
name|vlp
operator|->
name|u
decl_stmt|;
specifier|register
name|int
name|currdown
init|=
name|vlp
operator|->
name|d
decl_stmt|;
if|if
condition|(
name|newup
operator|<
literal|0
condition|)
name|newup
operator|=
literal|0
expr_stmt|;
comment|/* don't go back beyond start of page */
if|if
condition|(
name|newdown
operator|<
literal|0
condition|)
name|newdown
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|diffspan
argument_list|(
name|currup
argument_list|,
name|currdown
argument_list|)
condition|)
block|{
comment|/* now spans> one band */
if|if
condition|(
name|diffspan
argument_list|(
name|newup
argument_list|,
name|currup
argument_list|)
operator|||
name|diffspan
argument_list|(
name|newdown
argument_list|,
name|currdown
argument_list|)
condition|)
block|{
name|startspan
argument_list|(
name|vpos
argument_list|)
expr_stmt|;
name|vlp
operator|->
name|u
operator|=
name|newup
expr_stmt|;
name|vlp
operator|->
name|d
operator|=
name|newdown
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|newup
operator|<
name|currup
condition|)
name|vlp
operator|->
name|u
operator|=
name|newup
expr_stmt|;
if|if
condition|(
name|newdown
operator|>
name|currdown
condition|)
name|vlp
operator|->
name|d
operator|=
name|newdown
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|newup
operator|<
name|currup
condition|)
block|{
comment|/* goes farther up than before */
if|if
condition|(
name|currup
operator|==
name|vlp
operator|->
name|v
condition|)
block|{
comment|/* is new span, just set "up" */
name|vlp
operator|->
name|u
operator|=
name|newup
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|diffspan
argument_list|(
name|newup
argument_list|,
name|currup
argument_list|)
condition|)
block|{
comment|/* goes up farther */
name|startspan
argument_list|(
name|vpos
argument_list|)
expr_stmt|;
comment|/* than previously */
name|vlp
operator|->
name|u
operator|=
name|newup
expr_stmt|;
comment|/* AND to a higher */
name|vlp
operator|->
name|d
operator|=
name|newdown
expr_stmt|;
comment|/* band.  */
return|return;
block|}
else|else
block|{
name|vlp
operator|->
name|u
operator|=
name|newup
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|newdown
operator|>
name|currdown
condition|)
block|{
if|if
condition|(
name|currdown
operator|==
name|vlp
operator|->
name|v
condition|)
block|{
name|vlp
operator|->
name|d
operator|=
name|newdown
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|diffspan
argument_list|(
name|newdown
argument_list|,
name|currdown
argument_list|)
condition|)
block|{
name|startspan
argument_list|(
name|vpos
argument_list|)
expr_stmt|;
name|vlp
operator|->
name|u
operator|=
name|newup
expr_stmt|;
name|vlp
operator|->
name|d
operator|=
name|newdown
expr_stmt|;
return|return;
block|}
else|else
block|{
name|vlp
operator|->
name|d
operator|=
name|newdown
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	arcbounds (h, v, h1, v1)  |  | Results:	using the horizontal positions of the starting and ending  |		points relative to the center and vertically relative to  |		each other, arcbounds calculates the upper and lower extent  |		of the arc which is one of:  starting point, ending point  |		or center + rad for bottom, and center - rad for top.  |  | Side Efct:	calls setlimit(up, down) to save the extent information.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|arcbounds
argument_list|(
argument|h
argument_list|,
argument|v
argument_list|,
argument|h1
argument_list|,
argument|v1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|h
decl_stmt|,
name|v
decl_stmt|,
name|h1
decl_stmt|,
name|v1
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|rad
init|=
call|(
name|int
call|)
argument_list|(
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|h
operator|*
name|h
operator|+
name|v
operator|*
name|v
argument_list|)
argument_list|)
operator|+
literal|0.5
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
init|=
operator|(
operator|(
name|h
operator|>=
literal|0
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|h1
operator|<
literal|0
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|v
operator|+
name|v1
operator|)
operator|<
literal|0
operator|)
decl_stmt|;
comment|/* i is a set of flags for the points being on the */
comment|/* left of the center point, and which is higher */
name|v1
operator|+=
name|vpos
operator|+
name|v
expr_stmt|;
comment|/* v1 is vertical position of ending point */
comment|/* test relative positions for maximums */
name|setlimit
argument_list|(
comment|/* and set the up/down of the arc */
operator|(
operator|(
operator|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|1
operator|)
condition|?
name|v1
else|:
operator|(
operator|(
operator|(
name|i
operator|&
literal|5
operator|)
operator|==
literal|4
operator|)
condition|?
name|vpos
else|:
name|vpos
operator|+
name|v
operator|-
name|rad
operator|)
operator|)
operator|-
name|thick
operator|/
literal|2
operator|)
argument_list|,
operator|(
operator|(
operator|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|2
operator|)
condition|?
name|v1
else|:
operator|(
operator|(
operator|(
name|i
operator|&
literal|5
operator|)
operator|==
literal|1
operator|)
condition|?
name|vpos
else|:
name|vpos
operator|+
name|v
operator|+
name|rad
operator|)
operator|)
operator|+
name|thick
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|oflush
argument_list|()
end_macro

begin_comment
comment|/* sort, then dump out contents of obuf */
end_comment

begin_block
block|{
specifier|register
name|struct
name|vlist
modifier|*
name|vp
decl_stmt|;
specifier|register
name|int
name|notdone
decl_stmt|;
specifier|register
name|int
name|topv
decl_stmt|;
specifier|register
name|int
name|botv
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GAG me with an into oflush, V=%d\n"
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUGABLE
if|if
condition|(
name|op
operator|==
name|obuf
condition|)
return|return;
operator|*
name|op
operator|=
literal|0
expr_stmt|;
name|topv
operator|=
literal|0
expr_stmt|;
name|botv
operator|=
name|NLINES
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|notdone
operator|=
literal|0
expr_stmt|;
name|vp
operator|=
name|vlist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvlist
condition|;
name|i
operator|++
operator|,
name|vp
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"oflush: u=%d, d=%d,%.60s\n"
argument_list|,
name|vp
operator|->
name|u
argument_list|,
name|vp
operator|->
name|d
argument_list|,
name|vp
operator|->
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUGABLE
if|if
condition|(
name|vp
operator|->
name|u
operator|<=
name|botv
operator|&&
name|vp
operator|->
name|d
operator|>=
name|topv
condition|)
block|{
ifdef|#
directive|ifdef
name|BERK
name|printf
argument_list|(
literal|"H%dV%ds%df%d\ni%d\nDs%d\nDt%d\n%s"
argument_list|,
name|vp
operator|->
name|h
argument_list|,
name|vp
operator|->
name|v
argument_list|,
name|vp
operator|->
name|s
argument_list|,
name|vp
operator|->
name|f
argument_list|,
name|vp
operator|->
name|l
argument_list|,
name|vp
operator|->
name|st
argument_list|,
name|vp
operator|->
name|t
argument_list|,
name|vp
operator|->
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|started
condition|)
name|printf
argument_list|(
literal|"H%dV%ds%df%d\n%s"
argument_list|,
name|vp
operator|->
name|h
argument_list|,
name|vp
operator|->
name|v
argument_list|,
name|vp
operator|->
name|s
argument_list|,
name|vp
operator|->
name|f
argument_list|,
name|vp
operator|->
name|p
argument_list|)
expr_stmt|;
else|else
comment|/* 		     * only the real string to put out, else dver 		     * complains since it didn't got an "x init 		     * command", so it doen't know about any font yet 		     */
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|vp
operator|->
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BERK
block|}
name|notdone
operator||=
name|vp
operator|->
name|d
operator|>
name|botv
expr_stmt|;
comment|/* not done if there's still */
block|}
comment|/* something to put lower */
if|if
condition|(
name|notdone
condition|)
name|putchar
argument_list|(
literal|'P'
argument_list|)
expr_stmt|;
comment|/* mark the end of the spread */
name|topv
operator|+=
name|NLINES
expr_stmt|;
comment|/* unless it's the last one */
name|botv
operator|+=
name|NLINES
expr_stmt|;
block|}
do|while
condition|(
name|notdone
condition|)
do|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|vlp
operator|=
name|vlist
expr_stmt|;
name|vlp
operator|->
name|p
operator|=
name|op
operator|=
name|obuf
expr_stmt|;
name|vlp
operator|->
name|h
operator|=
name|hpos
expr_stmt|;
name|vlp
operator|->
name|v
operator|=
name|vpos
expr_stmt|;
name|vlp
operator|->
name|u
operator|=
name|vpos
expr_stmt|;
name|vlp
operator|->
name|d
operator|=
name|vpos
expr_stmt|;
name|vlp
operator|->
name|s
operator|=
name|size
expr_stmt|;
name|vlp
operator|->
name|f
operator|=
name|font
expr_stmt|;
ifdef|#
directive|ifdef
name|BERK
name|vlp
operator|->
name|l
operator|=
name|stip
expr_stmt|;
name|vlp
operator|->
name|st
operator|=
name|style
expr_stmt|;
endif|#
directive|endif
endif|BERK
name|vlp
operator|->
name|t
operator|=
name|thick
expr_stmt|;
operator|*
name|op
operator|=
literal|0
expr_stmt|;
name|nvlist
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|done
argument_list|()
end_macro

begin_block
block|{
name|oflush
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|f
argument_list|,
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|,
argument|a6
argument_list|,
argument|a7
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vsort: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
name|done
argument_list|()
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|MAXSTATE
value|5
end_define

begin_struct
struct|struct
name|state
block|{
name|int
name|ssize
decl_stmt|;
name|int
name|sfont
decl_stmt|;
name|int
name|shpos
decl_stmt|;
name|int
name|svpos
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|state
name|state
index|[
name|MAXSTATE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|state
modifier|*
name|statep
init|=
name|state
decl_stmt|;
end_decl_stmt

begin_macro
name|t_push
argument_list|()
end_macro

begin_comment
comment|/* begin a new block */
end_comment

begin_block
block|{
name|statep
operator|->
name|ssize
operator|=
name|size
expr_stmt|;
name|statep
operator|->
name|sfont
operator|=
name|font
expr_stmt|;
name|statep
operator|->
name|shpos
operator|=
name|hpos
expr_stmt|;
name|statep
operator|->
name|svpos
operator|=
name|vpos
expr_stmt|;
name|hpos
operator|=
name|vpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|statep
operator|++
operator|>=
name|state
operator|+
name|MAXSTATE
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"{ nested too deep"
argument_list|)
expr_stmt|;
name|hpos
operator|=
name|vpos
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|t_pop
argument_list|()
end_macro

begin_comment
comment|/* pop to previous state */
end_comment

begin_block
block|{
if|if
condition|(
operator|--
name|statep
operator|<
name|state
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"extra }"
argument_list|)
expr_stmt|;
name|size
operator|=
name|statep
operator|->
name|ssize
expr_stmt|;
name|font
operator|=
name|statep
operator|->
name|sfont
expr_stmt|;
name|hpos
operator|=
name|statep
operator|->
name|shpos
expr_stmt|;
name|vpos
operator|=
name|statep
operator|->
name|svpos
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	t_page  |  | Results:	new Margins are calculated for putting pages side-by-side.  |		If no more pages can fit across the paper (WIDTH wide)  |		a real page end is done and the currrent page is output.  |  | Side Efct:	oflush is called on a REAL page boundary.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|t_page
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|VER80
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* flag to catch the 1st time through */
comment|/*  	 * if we're near the edge,  or this is the first page 	 * we'll go over on this page.  	 */
if|if
condition|(
name|leftmarg
operator|+
literal|2
operator|*
operator|(
name|pageno
condition|?
name|leftmarg
operator|/
name|pageno
else|:
literal|0
operator|)
operator|>
name|WIDTH
operator|||
name|maxh
operator|>
name|WIDTH
operator|-
name|inch
operator|||
name|first
condition|)
block|{
name|oflush
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"p%d\n"
argument_list|,
name|spanno
operator|++
argument_list|)
expr_stmt|;
comment|/* make it a REAL page-break */
name|first
operator|=
name|pageno
operator|=
name|leftmarg
operator|=
name|maxh
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* x = last page's width (in half-inches) */
specifier|register
name|int
name|x
init|=
operator|(
name|maxh
operator|-
name|leftmarg
operator|+
operator|(
name|HALF
operator|-
literal|1
operator|)
operator|)
operator|/
name|HALF
decl_stmt|;
if|if
condition|(
name|x
operator|>
literal|11
operator|&&
name|x
operator|<=
literal|17
condition|)
name|leftmarg
operator|+=
operator|(
literal|8
operator|*
name|inch
operator|)
operator|+
name|HALF
expr_stmt|;
comment|/* if close to 8.5"  */
else|else
comment|/* then make it so   */
name|leftmarg
operator|=
operator|(
operator|(
name|maxh
operator|+
name|HALF
operator|)
operator|/
name|HALF
operator|)
operator|*
name|HALF
expr_stmt|;
comment|/* else set it to the */
name|pageno
operator|++
expr_stmt|;
comment|/* nearest half-inch */
block|}
else|#
directive|else
name|oflush
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"p%d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|pageno
operator|=
name|leftmarg
operator|=
name|maxh
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|VER80
block|}
end_block

begin_expr_stmt
name|startspan
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|*
name|op
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nvlist
operator|>=
name|NVLIST
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"(startspan) ran out of vlist"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUGABLE
name|oflush
argument_list|()
expr_stmt|;
block|}
name|vlp
operator|++
expr_stmt|;
name|vlp
operator|->
name|p
operator|=
name|op
expr_stmt|;
name|vlp
operator|->
name|v
operator|=
name|n
expr_stmt|;
name|vlp
operator|->
name|d
operator|=
name|n
expr_stmt|;
name|vlp
operator|->
name|u
operator|=
name|n
expr_stmt|;
name|vlp
operator|->
name|h
operator|=
name|hpos
expr_stmt|;
name|vlp
operator|->
name|s
operator|=
name|size
expr_stmt|;
name|vlp
operator|->
name|f
operator|=
name|font
expr_stmt|;
ifdef|#
directive|ifdef
name|BERK
name|vlp
operator|->
name|l
operator|=
name|stip
expr_stmt|;
name|vlp
operator|->
name|st
operator|=
name|style
expr_stmt|;
endif|#
directive|endif
endif|BERK
name|vlp
operator|->
name|t
operator|=
name|thick
expr_stmt|;
name|nvlist
operator|++
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|BERK
end_ifdef

begin_define
define|#
directive|define
name|MAXX
value|0x7fff
end_define

begin_define
define|#
directive|define
name|MINX
value|0x8000
end_define

begin_typedef
typedef|typedef
struct|struct
name|poly
block|{
name|struct
name|poly
modifier|*
name|next
decl_stmt|;
comment|/* doublely-linked lists of vectors */
name|struct
name|poly
modifier|*
name|prev
decl_stmt|;
name|int
name|param
decl_stmt|;
comment|/* bressenham line algorithm parameter */
name|short
name|dx
decl_stmt|;
comment|/* delta-x for calculating line */
name|short
name|dy
decl_stmt|;
comment|/* delta-y for calculating line */
name|short
name|currx
decl_stmt|;
comment|/* current x in this vector */
name|short
name|endy
decl_stmt|;
comment|/* where vector ends */
block|}
name|polyvector
typedef|;
end_typedef

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	polygon ( member, num_vectors, x_coor, y_coor, maxy, miny )  |  | Results:	outputs commands to draw a polygon starting at (x[1], y[1])  |		going through each of (x_coordinates, y_coordinates), and  |		filled with "member" stipple pattern.  |  |		A scan-line algorithm is simulated and pieces of the  |		polygon are put out that fit on bands of the versatec  |		output filter.  |  |		The format of the polygons put out are:  |			'Dp member num miny maxy [p dx dy curx endy]'  |		where "num" is the number of [..] entries in that  |		section of the polygon.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|polygon
argument_list|(
argument|member
argument_list|,
argument|nvect
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|,
argument|maxy
argument_list|,
argument|miny
argument_list|)
end_macro

begin_decl_stmt
name|int
name|member
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nvect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|x
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|y
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|miny
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|nexty
decl_stmt|;
comment|/* at what x value the next vector starts */
specifier|register
name|int
name|active
decl_stmt|;
comment|/* number of vectors in active list */
name|int
name|firsttime
decl_stmt|;
comment|/* force out a polgon the first time through */
name|polyvector
modifier|*
name|activehead
decl_stmt|;
comment|/* doing fill, is active edge list */
name|polyvector
modifier|*
name|waitinghead
decl_stmt|;
comment|/* edges waiting to be active */
specifier|register
name|polyvector
modifier|*
name|vectptr
decl_stmt|;
comment|/* random vector */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* random register */
comment|/* allocate space for raster-fill algorithm*/
name|vectptr
operator|=
operator|(
name|polyvector
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|polyvector
argument_list|)
operator|*
operator|(
name|nvect
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectptr
operator|==
operator|(
name|polyvector
operator|*
operator|)
name|NULL
condition|)
block|{
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"unable to allocate space for polygon"
argument_list|)
expr_stmt|;
return|return;
block|}
name|waitinghead
operator|=
name|vectptr
expr_stmt|;
name|vectptr
operator|->
name|param
operator|=
name|miny
operator|-
literal|1
expr_stmt|;
operator|(
name|vectptr
operator|++
operator|)
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
comment|/* put dummy entry at start */
name|waitinghead
operator|->
name|next
operator|=
name|vectptr
expr_stmt|;
name|vectptr
operator|->
name|prev
operator|=
name|waitinghead
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
comment|/* starting point of coords */
if|if
condition|(
name|y
index|[
literal|1
index|]
operator|!=
name|y
index|[
name|nvect
index|]
operator|||
name|x
index|[
literal|1
index|]
operator|!=
name|x
index|[
name|nvect
index|]
condition|)
block|{
name|y
index|[
literal|0
index|]
operator|=
name|y
index|[
name|nvect
index|]
expr_stmt|;
comment|/* close polygon if it's not */
name|x
index|[
literal|0
index|]
operator|=
name|x
index|[
name|nvect
index|]
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|active
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|nvect
condition|)
block|{
comment|/* set up the vectors */
specifier|register
name|int
name|j
decl_stmt|;
comment|/* indexes to work off of */
specifier|register
name|int
name|k
decl_stmt|;
name|j
operator|=
name|i
expr_stmt|;
comment|/* j "points" to the higher (lesser) point */
name|k
operator|=
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|y
index|[
name|j
index|]
operator|==
name|y
index|[
name|k
index|]
condition|)
comment|/* ignore horizontal lines */
continue|continue;
if|if
condition|(
name|y
index|[
name|j
index|]
operator|>
name|y
index|[
name|k
index|]
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|k
operator|--
expr_stmt|;
block|}
name|active
operator|++
expr_stmt|;
name|vectptr
operator|->
name|next
operator|=
name|vectptr
operator|+
literal|1
expr_stmt|;
name|vectptr
operator|->
name|param
operator|=
name|y
index|[
name|j
index|]
expr_stmt|;
comment|/* starting point of vector */
name|vectptr
operator|->
name|dx
operator|=
name|x
index|[
name|k
index|]
operator|-
name|x
index|[
name|j
index|]
expr_stmt|;
comment|/* line-calculating parameters */
name|vectptr
operator|->
name|dy
operator|=
name|y
index|[
name|k
index|]
operator|-
name|y
index|[
name|j
index|]
expr_stmt|;
name|vectptr
operator|->
name|currx
operator|=
name|x
index|[
name|j
index|]
expr_stmt|;
comment|/* starting point */
operator|(
name|vectptr
operator|++
operator|)
operator|->
name|endy
operator|=
name|y
index|[
name|k
index|]
expr_stmt|;
comment|/* ending point */
name|vectptr
operator|->
name|prev
operator|=
name|vectptr
operator|-
literal|1
expr_stmt|;
block|}
comment|/* if no useable vectors, quit */
if|if
condition|(
name|active
operator|<
literal|2
condition|)
goto|goto
name|leavepoly
goto|;
name|vectptr
operator|->
name|param
operator|=
name|maxy
operator|+
literal|1
expr_stmt|;
comment|/* dummy entry at end, too */
name|vectptr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|activehead
operator|=
operator|++
name|vectptr
expr_stmt|;
comment|/* two dummy entries for active list */
name|vectptr
operator|->
name|currx
operator|=
name|MINX
expr_stmt|;
comment|/* head */
name|vectptr
operator|->
name|endy
operator|=
name|maxy
operator|+
literal|1
expr_stmt|;
name|vectptr
operator|->
name|param
operator|=
name|vectptr
operator|->
name|dx
operator|=
name|vectptr
operator|->
name|dy
operator|=
literal|0
expr_stmt|;
name|activehead
operator|->
name|next
operator|=
operator|++
name|vectptr
expr_stmt|;
name|activehead
operator|->
name|prev
operator|=
name|vectptr
expr_stmt|;
name|vectptr
operator|->
name|prev
operator|=
name|activehead
expr_stmt|;
comment|/* tail */
name|vectptr
operator|->
name|next
operator|=
name|activehead
expr_stmt|;
name|vectptr
operator|->
name|currx
operator|=
name|MAXX
expr_stmt|;
name|vectptr
operator|->
name|endy
operator|=
name|maxy
operator|+
literal|1
expr_stmt|;
name|vectptr
operator|->
name|param
operator|=
name|vectptr
operator|->
name|dx
operator|=
name|vectptr
operator|->
name|dy
operator|=
literal|0
expr_stmt|;
comment|/* if there's no need to break the */
comment|/* polygon into pieces, don't bother */
if|if
condition|(
name|diffspan
argument_list|(
name|miny
argument_list|,
name|maxy
argument_list|)
condition|)
block|{
name|active
operator|=
literal|0
expr_stmt|;
comment|/* will keep track of # of vectors */
name|firsttime
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/*   in the active list */
name|startspan
argument_list|(
name|miny
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"Dq %d %d %d %d"
argument_list|,
name|member
argument_list|,
name|active
argument_list|,
name|miny
argument_list|,
name|maxy
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
for|for
control|(
name|vectptr
operator|=
name|waitinghead
operator|->
name|next
init|;
name|active
operator|--
condition|;
name|vectptr
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|op
argument_list|,
literal|" %d %d %d %d %d"
argument_list|,
name|vectptr
operator|->
name|param
argument_list|,
name|vectptr
operator|->
name|dx
argument_list|,
name|vectptr
operator|->
name|dy
argument_list|,
name|vectptr
operator|->
name|currx
argument_list|,
name|vectptr
operator|->
name|endy
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|op
operator|++
operator|)
operator|=
literal|'\n'
expr_stmt|;
goto|goto
name|leavepoly
goto|;
block|}
comment|/* main loop -- gets vectors off the waiting list, */
comment|/* then displays spans while updating the vectors in */
comment|/* the active list */
while|while
condition|(
name|miny
operator|<=
name|maxy
condition|)
block|{
name|i
operator|=
name|maxy
operator|+
literal|1
expr_stmt|;
comment|/* this is the NEXT time to get a new vector */
for|for
control|(
name|vectptr
operator|=
name|waitinghead
operator|->
name|next
init|;
name|vectptr
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|miny
operator|==
name|vectptr
operator|->
name|param
condition|)
block|{
comment|/* the entry in waiting list (vectptr) is */
comment|/*   ready to go into active list.  Need to */
comment|/*   convert some vector stuff and sort the */
comment|/*   entry into the list. */
specifier|register
name|polyvector
modifier|*
name|p
decl_stmt|;
comment|/* random vector pointers */
specifier|register
name|polyvector
modifier|*
name|v
decl_stmt|;
comment|/* convert this */
if|if
condition|(
name|vectptr
operator|->
name|dx
operator|<
literal|0
condition|)
comment|/* entry to active */
name|vectptr
operator|->
name|param
operator|=
operator|-
operator|(
operator|(
name|vectptr
operator|->
name|dx
operator|>>
literal|1
operator|)
operator|+
operator|(
name|vectptr
operator|->
name|dy
operator|>>
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|vectptr
operator|->
name|param
operator|=
operator|(
name|vectptr
operator|->
name|dx
operator|>>
literal|1
operator|)
operator|-
operator|(
name|vectptr
operator|->
name|dy
operator|>>
literal|1
operator|)
expr_stmt|;
name|p
operator|=
name|vectptr
expr_stmt|;
comment|/* remove from the */
name|vectptr
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
comment|/* waiting list */
name|vectptr
operator|->
name|prev
operator|=
name|p
operator|->
name|prev
expr_stmt|;
name|p
operator|->
name|prev
operator|->
name|next
operator|=
name|vectptr
expr_stmt|;
comment|/* find where it goes */
comment|/* in the active list */
comment|/* (sorted smallest first) */
for|for
control|(
name|v
operator|=
name|activehead
operator|->
name|next
init|;
name|v
operator|->
name|currx
operator|<
name|p
operator|->
name|currx
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
empty_stmt|;
name|p
operator|->
name|next
operator|=
name|v
expr_stmt|;
comment|/* insert into active list */
name|p
operator|->
name|prev
operator|=
name|v
operator|->
name|prev
expr_stmt|;
comment|/* before the one it stopped on */
name|v
operator|->
name|prev
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|prev
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|active
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|>
name|vectptr
operator|->
name|param
condition|)
block|{
name|i
operator|=
name|vectptr
operator|->
name|param
expr_stmt|;
block|}
name|vectptr
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
block|}
block|}
name|nexty
operator|=
name|i
expr_stmt|;
comment|/* print the polygon while there */
comment|/* are no more vectors to add */
while|while
condition|(
name|miny
operator|<
name|nexty
condition|)
block|{
comment|/* remove any finished vectors */
name|vectptr
operator|=
name|activehead
operator|->
name|next
expr_stmt|;
do|do
block|{
if|if
condition|(
name|vectptr
operator|->
name|endy
operator|<=
name|miny
condition|)
block|{
name|vectptr
operator|->
name|prev
operator|->
name|next
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
name|vectptr
operator|->
name|next
operator|->
name|prev
operator|=
name|vectptr
operator|->
name|prev
expr_stmt|;
name|active
operator|--
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|vectptr
operator|=
name|vectptr
operator|->
name|next
operator|)
operator|!=
name|activehead
condition|)
do|;
comment|/* output a polygon for this band */
if|if
condition|(
name|firsttime
operator|||
operator|!
operator|(
name|miny
operator|%
name|NLINES
operator|)
condition|)
block|{
specifier|register
name|int
name|numwait
decl_stmt|;
comment|/* number in the waiting list */
specifier|register
name|int
name|newmaxy
decl_stmt|;
comment|/* max for this band (bottom or maxy)*/
name|startspan
argument_list|(
name|miny
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newmaxy
operator|=
operator|(
name|miny
operator|/
name|NLINES
operator|)
operator|*
name|NLINES
operator|+
operator|(
name|NLINES
operator|-
literal|1
operator|)
operator|)
operator|>
name|maxy
condition|)
name|newmaxy
operator|=
name|maxy
expr_stmt|;
comment|/* count up those vectors that WILL */
comment|/* become active in this band */
for|for
control|(
name|numwait
operator|=
literal|0
operator|,
name|vectptr
operator|=
name|waitinghead
operator|->
name|next
init|;
name|vectptr
operator|!=
name|NULL
condition|;
name|vectptr
operator|=
name|vectptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|vectptr
operator|->
name|param
operator|<=
name|newmaxy
condition|)
name|numwait
operator|++
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"Dq %d %d %d %d"
argument_list|,
name|member
argument_list|,
name|active
operator|+
name|numwait
argument_list|,
name|miny
argument_list|,
name|newmaxy
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|active
operator|,
name|vectptr
operator|=
name|activehead
operator|->
name|next
init|;
name|i
operator|--
condition|;
name|vectptr
operator|=
name|vectptr
operator|->
name|next
control|)
block|{
name|sprintf
argument_list|(
name|op
argument_list|,
literal|" %d %d %d %d %d"
argument_list|,
name|vectptr
operator|->
name|param
argument_list|,
name|vectptr
operator|->
name|dx
argument_list|,
operator|-
name|vectptr
operator|->
name|dy
argument_list|,
name|vectptr
operator|->
name|currx
argument_list|,
name|vectptr
operator|->
name|endy
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|vectptr
operator|=
name|waitinghead
operator|->
name|next
init|;
name|vectptr
operator|!=
name|NULL
condition|;
name|vectptr
operator|=
name|vectptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|vectptr
operator|->
name|param
operator|<=
name|newmaxy
condition|)
block|{
name|sprintf
argument_list|(
name|op
argument_list|,
literal|" %d %d %d %d %d"
argument_list|,
name|vectptr
operator|->
name|param
argument_list|,
name|vectptr
operator|->
name|dx
argument_list|,
name|vectptr
operator|->
name|dy
argument_list|,
name|vectptr
operator|->
name|currx
argument_list|,
name|vectptr
operator|->
name|endy
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
operator|(
name|op
operator|++
operator|)
operator|=
literal|'\n'
expr_stmt|;
name|firsttime
operator|=
literal|0
expr_stmt|;
block|}
comment|/* update the vectors */
name|vectptr
operator|=
name|activehead
operator|->
name|next
expr_stmt|;
do|do
block|{
if|if
condition|(
name|vectptr
operator|->
name|dx
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|vectptr
operator|->
name|param
operator|>=
literal|0
condition|)
block|{
name|vectptr
operator|->
name|param
operator|-=
name|vectptr
operator|->
name|dy
expr_stmt|;
name|vectptr
operator|->
name|currx
operator|++
expr_stmt|;
block|}
name|vectptr
operator|->
name|param
operator|+=
name|vectptr
operator|->
name|dx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vectptr
operator|->
name|dx
operator|<
literal|0
condition|)
block|{
while|while
condition|(
name|vectptr
operator|->
name|param
operator|>=
literal|0
condition|)
block|{
name|vectptr
operator|->
name|param
operator|-=
name|vectptr
operator|->
name|dy
expr_stmt|;
name|vectptr
operator|->
name|currx
operator|--
expr_stmt|;
block|}
name|vectptr
operator|->
name|param
operator|-=
name|vectptr
operator|->
name|dx
expr_stmt|;
block|}
comment|/* must sort the vectors if updates */
comment|/* caused them to cross */
comment|/* also move to next vector here */
if|if
condition|(
name|vectptr
operator|->
name|currx
operator|<
name|vectptr
operator|->
name|prev
operator|->
name|currx
condition|)
block|{
specifier|register
name|polyvector
modifier|*
name|v
decl_stmt|;
comment|/* vector to move */
specifier|register
name|polyvector
modifier|*
name|p
decl_stmt|;
comment|/* vector to put it after */
name|v
operator|=
name|vectptr
expr_stmt|;
name|p
operator|=
name|v
operator|->
name|prev
expr_stmt|;
while|while
condition|(
name|v
operator|->
name|currx
operator|<
name|p
operator|->
name|currx
condition|)
comment|/* find the */
name|p
operator|=
name|p
operator|->
name|prev
expr_stmt|;
comment|/* right vector */
name|vectptr
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
comment|/* remove from spot */
name|vectptr
operator|->
name|prev
operator|=
name|v
operator|->
name|prev
expr_stmt|;
name|v
operator|->
name|prev
operator|->
name|next
operator|=
name|vectptr
expr_stmt|;
name|v
operator|->
name|prev
operator|=
name|p
expr_stmt|;
comment|/* put in new spot */
name|v
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|v
expr_stmt|;
name|v
operator|->
name|next
operator|->
name|prev
operator|=
name|v
expr_stmt|;
block|}
else|else
block|{
name|vectptr
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
block|}
block|}
do|while
condition|(
name|vectptr
operator|!=
name|activehead
condition|)
do|;
operator|++
name|miny
expr_stmt|;
block|}
comment|/* while (miny< nexty) */
block|}
comment|/* while (miny<= maxy) */
name|leavepoly
label|:
name|startspan
argument_list|(
name|vpos
argument_list|)
expr_stmt|;
comment|/* make sure stuff after polygon is at correct vpos */
name|free
argument_list|(
name|waitinghead
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* polygon function */
end_comment

begin_endif
endif|#
directive|endif
endif|BERK
end_endif

end_unit

