begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)maktab.c	1.3 (CWI) 86/11/13"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/*  * compute tab stops  */
end_comment

begin_define
define|#
directive|define
name|tx
parameter_list|(
name|a
parameter_list|)
value|(a>0&& a<128)
end_define

begin_define
define|#
directive|define
name|FN
parameter_list|(
name|i
parameter_list|,
name|c
parameter_list|)
value|font[stynum[i]][c]
end_define

begin_define
define|#
directive|define
name|SZ
parameter_list|(
name|i
parameter_list|,
name|c
parameter_list|)
value|csize[stynum[i]][c]
end_define

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"ext.h"
end_include

begin_comment
comment|/*  * define the tab stops of the table  */
end_comment

begin_macro
name|maktab
argument_list|()
end_macro

begin_block
block|{
name|int
name|icol
decl_stmt|,
name|ilin
decl_stmt|,
name|tsep
decl_stmt|,
name|k
decl_stmt|,
name|ik
decl_stmt|,
name|vforml
decl_stmt|,
name|il
decl_stmt|,
name|text
decl_stmt|;
name|int
name|doubled
index|[
name|MAXCOL
index|]
decl_stmt|,
name|acase
index|[
name|MAXCOL
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|icol
operator|=
literal|0
init|;
name|icol
operator|<
name|ncol
condition|;
name|icol
operator|++
control|)
block|{
name|doubled
index|[
name|icol
index|]
operator|=
name|acase
index|[
name|icol
index|]
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|".nr %2s 0\n"
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CRIGHT
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|text
operator|=
literal|0
init|;
name|text
operator|<
literal|2
condition|;
name|text
operator|++
control|)
block|{
if|if
condition|(
name|text
condition|)
name|printf
argument_list|(
literal|".%2s\n.rm %2s\n"
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CRIGHT
argument_list|)
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CRIGHT
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ilin
operator|=
literal|0
init|;
name|ilin
operator|<
name|nlin
condition|;
name|ilin
operator|++
control|)
block|{
if|if
condition|(
name|instead
index|[
name|ilin
index|]
operator|||
name|fullbot
index|[
name|ilin
index|]
condition|)
block|{
continue|continue;
block|}
name|vforml
operator|=
name|ilin
expr_stmt|;
for|for
control|(
name|il
operator|=
name|prev
argument_list|(
name|ilin
argument_list|)
init|;
name|il
operator|>=
literal|0
operator|&&
name|vspen
argument_list|(
name|table
index|[
name|il
index|]
index|[
name|icol
index|]
operator|.
name|col
argument_list|)
condition|;
name|il
operator|=
name|prev
argument_list|(
name|il
argument_list|)
control|)
name|vforml
operator|=
name|il
expr_stmt|;
if|if
condition|(
name|fspan
argument_list|(
name|vforml
argument_list|,
name|icol
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|filler
argument_list|(
name|table
index|[
name|ilin
index|]
index|[
name|icol
index|]
operator|.
name|col
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|ctop
index|[
name|stynum
index|[
name|ilin
index|]
index|]
index|[
name|icol
index|]
operator|&
name|ZEROW
operator|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
switch|switch
condition|(
name|ctype
argument_list|(
name|vforml
argument_list|,
name|icol
argument_list|)
condition|)
block|{
case|case
literal|'a'
case|:
name|acase
index|[
name|icol
index|]
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|table
index|[
name|ilin
index|]
index|[
name|icol
index|]
operator|.
name|col
expr_stmt|;
if|if
condition|(
name|s
operator|>
literal|0
operator|&&
name|s
operator|<
operator|(
name|char
operator|*
operator|)
literal|128
operator|&&
name|text
condition|)
block|{
if|if
condition|(
name|doubled
index|[
name|icol
index|]
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|".nr %d 0\n.nr %d 0\n"
argument_list|,
name|S1
argument_list|,
name|S2
argument_list|)
expr_stmt|;
name|doubled
index|[
name|icol
index|]
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|".if \\n(%c->\\n(%d .nr %d \\n(%c-\n"
argument_list|,
name|s
argument_list|,
name|S2
argument_list|,
name|S2
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
case|case
literal|'n'
case|:
if|if
condition|(
name|table
index|[
name|ilin
index|]
index|[
name|icol
index|]
operator|.
name|rcol
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|doubled
index|[
name|icol
index|]
operator|==
literal|0
operator|&&
name|text
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|".nr %d 0\n.nr %d 0\n"
argument_list|,
name|S1
argument_list|,
name|S2
argument_list|)
expr_stmt|;
name|doubled
index|[
name|icol
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|real
argument_list|(
name|s
operator|=
name|table
index|[
name|ilin
index|]
index|[
name|icol
index|]
operator|.
name|col
argument_list|)
operator|&&
operator|!
name|vspen
argument_list|(
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tx
argument_list|(
operator|(
name|int
operator|)
name|s
argument_list|)
operator|!=
name|text
condition|)
continue|continue;
name|printf
argument_list|(
literal|".nr %d "
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
name|wide
argument_list|(
name|s
argument_list|,
name|FN
argument_list|(
name|vforml
argument_list|,
name|icol
argument_list|)
argument_list|,
name|SZ
argument_list|(
name|vforml
argument_list|,
name|icol
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".if \\n(%d<\\n(%d .nr %d \\n(%d\n"
argument_list|,
name|S1
argument_list|,
name|TMP
argument_list|,
name|S1
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|text
operator|==
literal|0
operator|&&
name|real
argument_list|(
name|s
operator|=
name|table
index|[
name|ilin
index|]
index|[
name|icol
index|]
operator|.
name|rcol
argument_list|)
operator|&&
operator|!
name|vspen
argument_list|(
name|s
argument_list|)
operator|&&
operator|!
name|barent
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|".nr %d \\w%c%s%c\n"
argument_list|,
name|TMP
argument_list|,
name|F1
argument_list|,
name|s
argument_list|,
name|F1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".if \\n(%d<\\n(%d .nr %d \\n(%d\n"
argument_list|,
name|S2
argument_list|,
name|TMP
argument_list|,
name|S2
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
case|case
literal|'r'
case|:
case|case
literal|'c'
case|:
case|case
literal|'l'
case|:
if|if
condition|(
name|real
argument_list|(
name|s
operator|=
name|table
index|[
name|ilin
index|]
index|[
name|icol
index|]
operator|.
name|col
argument_list|)
operator|&&
operator|!
name|vspen
argument_list|(
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tx
argument_list|(
operator|(
name|int
operator|)
name|s
argument_list|)
operator|!=
name|text
condition|)
continue|continue;
name|printf
argument_list|(
literal|".nr %d "
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
name|wide
argument_list|(
name|s
argument_list|,
name|FN
argument_list|(
name|vforml
argument_list|,
name|icol
argument_list|)
argument_list|,
name|SZ
argument_list|(
name|vforml
argument_list|,
name|icol
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".if \\n(%2s<\\n(%d .nr %2s \\n(%d\n"
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CRIGHT
argument_list|)
argument_list|,
name|TMP
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CRIGHT
argument_list|)
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|acase
index|[
name|icol
index|]
condition|)
block|{
name|printf
argument_list|(
literal|".if \\n(%d>=\\n(%2s .nr %2s \\n(%du+2n\n"
argument_list|,
name|S2
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CRIGHT
argument_list|)
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CRIGHT
argument_list|)
argument_list|,
name|S2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doubled
index|[
name|icol
index|]
condition|)
block|{
name|printf
argument_list|(
literal|".nr %2s \\n(%d\n"
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CMID
argument_list|)
argument_list|,
name|S1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".nr %d \\n(%2s+\\n(%d\n"
argument_list|,
name|TMP
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CMID
argument_list|)
argument_list|,
name|S2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".if \\n(%d>\\n(%2s .nr %2s \\n(%d\n"
argument_list|,
name|TMP
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CRIGHT
argument_list|)
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CRIGHT
argument_list|)
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".if \\n(%d<\\n(%2s .nr %2s +(\\n(%2s-\\n(%d)/2\n"
argument_list|,
name|TMP
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CRIGHT
argument_list|)
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CMID
argument_list|)
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CRIGHT
argument_list|)
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cll
index|[
name|icol
index|]
index|[
literal|0
index|]
condition|)
block|{
name|printf
argument_list|(
literal|".nr %d %sn\n"
argument_list|,
name|TMP
argument_list|,
name|cll
index|[
name|icol
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".if \\n(%2s<\\n(%d .nr %2s \\n(%d\n"
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CRIGHT
argument_list|)
argument_list|,
name|TMP
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CRIGHT
argument_list|)
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ilin
operator|=
literal|0
init|;
name|ilin
operator|<
name|nlin
condition|;
name|ilin
operator|++
control|)
if|if
condition|(
name|k
operator|=
name|lspan
argument_list|(
name|ilin
argument_list|,
name|icol
argument_list|)
condition|)
block|{
name|s
operator|=
name|table
index|[
name|ilin
index|]
index|[
name|icol
operator|-
name|k
index|]
operator|.
name|col
expr_stmt|;
if|if
condition|(
operator|!
name|real
argument_list|(
name|s
argument_list|)
operator|||
name|barent
argument_list|(
name|s
argument_list|)
operator|||
name|vspen
argument_list|(
name|s
argument_list|)
condition|)
continue|continue;
name|printf
argument_list|(
literal|".nr %d "
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
name|wide
argument_list|(
name|table
index|[
name|ilin
index|]
index|[
name|icol
operator|-
name|k
index|]
operator|.
name|col
argument_list|,
name|FN
argument_list|(
name|ilin
argument_list|,
name|icol
operator|-
name|k
argument_list|)
argument_list|,
name|SZ
argument_list|(
name|ilin
argument_list|,
name|icol
operator|-
name|k
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ik
operator|=
name|k
init|;
name|ik
operator|>=
literal|0
condition|;
name|ik
operator|--
control|)
block|{
name|printf
argument_list|(
literal|"-\\n(%2s"
argument_list|,
name|reg
argument_list|(
name|icol
operator|-
name|ik
argument_list|,
name|CRIGHT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expflg
operator|&&
name|ik
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"-%dn"
argument_list|,
name|sep
index|[
name|icol
operator|-
name|ik
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".if \\n(%d>0 .nr %d \\n(%d/%d\n"
argument_list|,
name|TMP
argument_list|,
name|TMP
argument_list|,
name|TMP
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".if \\n(%d<0 .nr %d 0\n"
argument_list|,
name|TMP
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
for|for
control|(
name|ik
operator|=
literal|1
init|;
name|ik
operator|<=
name|k
condition|;
name|ik
operator|++
control|)
block|{
if|if
condition|(
name|doubled
index|[
name|icol
operator|-
name|k
operator|+
name|ik
index|]
condition|)
block|{
name|printf
argument_list|(
literal|".nr %2s +\\n(%d/2\n"
argument_list|,
name|reg
argument_list|(
name|icol
operator|-
name|k
operator|+
name|ik
argument_list|,
name|CMID
argument_list|)
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|".nr %2s +\\n(%d\n"
argument_list|,
name|reg
argument_list|(
name|icol
operator|-
name|k
operator|+
name|ik
argument_list|,
name|CRIGHT
argument_list|)
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|textflg
condition|)
name|untext
argument_list|()
expr_stmt|;
comment|/* 	 * if even requested, make all columns widest width 	 */
define|#
directive|define
name|TMP1
value|S1
define|#
directive|define
name|TMP2
value|S2
if|if
condition|(
name|evenflg
condition|)
block|{
name|printf
argument_list|(
literal|".nr %d 0\n"
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
for|for
control|(
name|icol
operator|=
literal|0
init|;
name|icol
operator|<
name|ncol
condition|;
name|icol
operator|++
control|)
block|{
if|if
condition|(
name|evenup
index|[
name|icol
index|]
operator|==
literal|0
condition|)
continue|continue;
name|printf
argument_list|(
literal|".if \\n(%2s>\\n(%d .nr %d \\n(%2s\n"
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CRIGHT
argument_list|)
argument_list|,
name|TMP
argument_list|,
name|TMP
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CRIGHT
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|icol
operator|=
literal|0
init|;
name|icol
operator|<
name|ncol
condition|;
name|icol
operator|++
control|)
block|{
comment|/* 			 * if column not evened just retain old interval 			 */
if|if
condition|(
name|evenup
index|[
name|icol
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|doubled
index|[
name|icol
index|]
condition|)
name|printf
argument_list|(
literal|".nr %2s (100*\\n(%2s/\\n(%2s)*\\n(%d/100\n"
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CMID
argument_list|)
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CMID
argument_list|)
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CRIGHT
argument_list|)
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
comment|/* 		 	* that nonsense with the 100's and parens tries to avoid 		 	* overflow while proportionally shifting the middle of 		 	* the number 		 	*/
name|printf
argument_list|(
literal|".nr %2s \\n(%d\n"
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CRIGHT
argument_list|)
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * now adjust for total table width 	 */
for|for
control|(
name|tsep
operator|=
name|icol
operator|=
literal|0
init|;
name|icol
operator|<
name|ncol
condition|;
name|icol
operator|++
control|)
name|tsep
operator|+=
name|sep
index|[
name|icol
index|]
expr_stmt|;
if|if
condition|(
name|expflg
condition|)
block|{
name|printf
argument_list|(
literal|".nr %d 0"
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
for|for
control|(
name|icol
operator|=
literal|0
init|;
name|icol
operator|<
name|ncol
condition|;
name|icol
operator|++
control|)
name|printf
argument_list|(
literal|"+\\n(%2s"
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CRIGHT
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Bug fix: Most users expect the expand to take place 		 * over the line length minus the current indentation 		 * (I do as well, a bit ugly to see the table creeping 		 * in the right margin (jna)) 		 */
name|printf
argument_list|(
literal|".nr %d \\n(.l-\\n(.i-\\n(%d\n"
argument_list|,
name|TMP
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|boxflg
operator|||
name|dboxflg
operator|||
name|allflg
condition|)
name|tsep
operator|+=
literal|1
expr_stmt|;
else|else
name|tsep
operator|-=
name|sep
index|[
name|ncol
operator|-
literal|1
index|]
expr_stmt|;
name|printf
argument_list|(
literal|".nr %d \\n(%d/%d\n"
argument_list|,
name|TMP
argument_list|,
name|TMP
argument_list|,
name|tsep
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".if \\n(%d<0 .nr %d 0\n"
argument_list|,
name|TMP
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|".nr %d 1n\n"
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".nr %2s 0\n"
argument_list|,
name|reg
argument_list|(
operator|-
literal|1
argument_list|,
name|CRIGHT
argument_list|)
argument_list|)
expr_stmt|;
name|tsep
operator|=
operator|(
name|boxflg
operator|||
name|allflg
operator|||
name|dboxflg
operator|||
name|left1flg
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|icol
operator|=
literal|0
init|;
name|icol
operator|<
name|ncol
condition|;
name|icol
operator|++
control|)
block|{
name|printf
argument_list|(
literal|".nr %2s \\n(%2s+(%d*\\n(%d)\n"
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CLEFT
argument_list|)
argument_list|,
name|reg
argument_list|(
name|icol
operator|-
literal|1
argument_list|,
name|CRIGHT
argument_list|)
argument_list|,
name|tsep
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".nr %2s +\\n(%2s\n"
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CRIGHT
argument_list|)
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CLEFT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|doubled
index|[
name|icol
index|]
condition|)
block|{
comment|/* 			 * the next line is last-ditch effort to avoid 			 * zero field width 			 */
comment|/* 			printf(".if \\n(%2s=0 .nr %2s 1\n", reg(icol,CMID), 		   				reg(icol,CMID)); 			 */
name|printf
argument_list|(
literal|".nr %2s +\\n(%2s\n"
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CMID
argument_list|)
argument_list|,
name|reg
argument_list|(
name|icol
argument_list|,
name|CLEFT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			printf(".if n .if \\n(%2s%%24>0 .nr %2s +12u\n", 					reg(icol, CMID), reg(icol, CMID)); 			 */
block|}
name|tsep
operator|=
name|sep
index|[
name|icol
index|]
expr_stmt|;
block|}
if|if
condition|(
name|rightl
condition|)
name|printf
argument_list|(
literal|".nr %2s (\\n(%2s+\\n(%2s)/2\n"
argument_list|,
name|reg
argument_list|(
name|ncol
operator|-
literal|1
argument_list|,
name|CRIGHT
argument_list|)
argument_list|,
name|reg
argument_list|(
name|ncol
operator|-
literal|1
argument_list|,
name|CLEFT
argument_list|)
argument_list|,
name|reg
argument_list|(
name|ncol
operator|-
literal|2
argument_list|,
name|CRIGHT
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".nr TW \\n(%2s\n"
argument_list|,
name|reg
argument_list|(
name|ncol
operator|-
literal|1
argument_list|,
name|CRIGHT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|boxflg
operator|||
name|allflg
operator|||
name|dboxflg
condition|)
name|printf
argument_list|(
literal|".nr TW +%d*\\n(%d\n"
argument_list|,
name|sep
index|[
name|ncol
operator|-
literal|1
index|]
argument_list|,
name|TMP
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".if t .if(\\n(TW+\\n(.o)>\\n(Tw .tm Table at line %d file %s is too wide - \\n(TW units\n"
argument_list|,
name|iline
operator|-
literal|1
argument_list|,
name|strlen
argument_list|(
name|oldname
argument_list|)
condition|?
name|oldname
else|:
name|ifile
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * tell troff to calculate width of an entry  */
end_comment

begin_macro
name|wide
argument_list|(
argument|s
argument_list|,
argument|fn
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|size
decl_stmt|,
modifier|*
name|fn
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * if s is a pointer to a string, calculate the with of that string 	 */
if|if
condition|(
name|point
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\\w%c"
argument_list|,
name|F1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|fn
operator|>
literal|0
condition|)
name|putfont
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|size
condition|)
name|putsize
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|fn
operator|>
literal|0
condition|)
name|putfont
argument_list|(
literal|"P"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|size
condition|)
name|putsize
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|F1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* 		 * it is the name of a diversion, so we know the witdh 		 * is in<diversionname>- 		 */
name|printf
argument_list|(
literal|"\\n(%c-"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|filler
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|point
argument_list|(
name|s
argument_list|)
operator|&&
name|s
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'R'
operator|)
return|;
block|}
end_block

end_unit

