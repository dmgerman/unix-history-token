begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)main.c	2.1 (CWI) 85/07/23"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"pic.h"
end_include

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_decl_stmt
name|obj
modifier|*
modifier|*
name|objlist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* store the elements here */
end_comment

begin_decl_stmt
name|int
name|nobjlist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of objlist array */
end_comment

begin_decl_stmt
name|int
name|nobj
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Attr
modifier|*
name|attr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* attributes stored here as collected */
end_comment

begin_decl_stmt
name|int
name|nattrlist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nattr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of entries in attr_list */
end_comment

begin_decl_stmt
name|Text
modifier|*
name|text
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* text strings stored here as collected */
end_comment

begin_decl_stmt
name|int
name|ntextlist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of text[] array */
end_comment

begin_decl_stmt
name|int
name|ntext
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ntext1
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* record ntext here on entry to each figure */
end_comment

begin_decl_stmt
name|float
name|curx
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|cury
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hvmode
init|=
name|R_DIR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* R => join left to right, D => top to bottom, etc. */
end_comment

begin_decl_stmt
name|int
name|codegen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1=>output for this picture; 0=>no output */
end_comment

begin_decl_stmt
name|float
name|deltx
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max x value in output, for scaling */
end_comment

begin_decl_stmt
name|float
name|delty
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max y value in output, for scaling */
end_comment

begin_decl_stmt
name|int
name|dbg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lineno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|filename
init|=
literal|"-"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|synerr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cmdname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|xmin
init|=
literal|30000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* min values found in actual data */
end_comment

begin_decl_stmt
name|float
name|ymin
init|=
literal|30000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|xmax
init|=
operator|-
literal|30000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max */
end_comment

begin_decl_stmt
name|float
name|ymax
init|=
operator|-
literal|30000
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
specifier|extern
name|int
name|fpecatch
parameter_list|()
function_decl|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|fpecatch
argument_list|)
expr_stmt|;
name|cmdname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
operator|*
name|argv
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'d'
case|:
name|dbg
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
operator|==
literal|0
condition|)
name|dbg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|setdefaults
argument_list|()
expr_stmt|;
name|objlist
operator|=
operator|(
name|obj
operator|*
operator|*
operator|)
name|grow
argument_list|(
name|objlist
argument_list|,
literal|"objlist"
argument_list|,
name|nobjlist
operator|+=
literal|1000
argument_list|,
sizeof|sizeof
argument_list|(
name|obj
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|text
operator|=
operator|(
name|Text
operator|*
operator|)
name|grow
argument_list|(
name|text
argument_list|,
literal|"text"
argument_list|,
name|ntextlist
operator|+=
literal|1000
argument_list|,
sizeof|sizeof
argument_list|(
name|Text
argument_list|)
argument_list|)
expr_stmt|;
name|attr
operator|=
operator|(
name|Attr
operator|*
operator|)
name|grow
argument_list|(
name|attr
argument_list|,
literal|"attr"
argument_list|,
name|nattrlist
operator|+=
literal|100
argument_list|,
sizeof|sizeof
argument_list|(
name|Attr
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"/%d/"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|pushsrc
argument_list|(
name|String
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|definition
argument_list|(
literal|"pid"
argument_list|)
expr_stmt|;
name|pushsrc
argument_list|(
name|File
argument_list|,
name|curfile
operator|=
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
block|{
name|curfile
operator|->
name|fin
operator|=
name|stdin
expr_stmt|;
name|curfile
operator|->
name|fname
operator|=
name|tostring
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|getdata
argument_list|(
name|curfile
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
name|argc
operator|--
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|curfile
operator|->
name|fin
operator|=
name|fopen
argument_list|(
operator|*
operator|++
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open %s\n"
argument_list|,
name|cmdname
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|curfile
operator|->
name|fname
operator|=
name|tostring
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
name|getdata
argument_list|(
name|curfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|curfile
operator|->
name|fin
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curfile
operator|->
name|fname
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|fpecatch
argument_list|()
end_macro

begin_block
block|{
name|fatal
argument_list|(
literal|"floating point exception"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|grow
parameter_list|(
name|ptr
parameter_list|,
name|name
parameter_list|,
name|num
parameter_list|,
name|size
parameter_list|)
comment|/* make array bigger */
name|char
modifier|*
name|ptr
decl_stmt|,
decl|*
name|name
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|num
decl_stmt|,
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|p
operator|=
name|malloc
argument_list|(
name|num
operator|*
name|size
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|num
operator|*
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"can't grow %s to %d"
argument_list|,
name|name
argument_list|,
name|num
operator|*
name|size
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_block

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|float
name|val
decl_stmt|;
name|short
name|scalable
decl_stmt|;
comment|/* 1 => adjust when "scale" changes */
block|}
name|defaults
index|[]
init|=
block|{
literal|"scale"
block|,
name|SCALE
block|,
literal|1
block|,
literal|"lineht"
block|,
name|HT
block|,
literal|1
block|,
literal|"linewid"
block|,
name|HT
block|,
literal|1
block|,
literal|"moveht"
block|,
name|HT
block|,
literal|1
block|,
literal|"movewid"
block|,
name|HT
block|,
literal|1
block|,
literal|"dashwid"
block|,
name|HT10
block|,
literal|1
block|,
literal|"boxht"
block|,
name|HT
block|,
literal|1
block|,
literal|"boxwid"
block|,
name|WID
block|,
literal|1
block|,
literal|"circlerad"
block|,
name|HT2
block|,
literal|1
block|,
literal|"arcrad"
block|,
name|HT2
block|,
literal|1
block|,
literal|"ellipseht"
block|,
name|HT
block|,
literal|1
block|,
literal|"ellipsewid"
block|,
name|WID
block|,
literal|1
block|,
literal|"arrowht"
block|,
name|HT5
block|,
literal|1
block|,
literal|"arrowwid"
block|,
name|HT10
block|,
literal|1
block|,
literal|"arrowhead"
block|,
literal|2
block|,
literal|0
block|,
comment|/* arrowhead style */
literal|"textht"
block|,
literal|0.0
block|,
literal|1
block|,
comment|/* 6 lines/inch is also a useful value */
literal|"textwid"
block|,
literal|0.0
block|,
literal|1
block|,
name|NULL
block|,
literal|0
block|}
struct|;
end_struct

begin_macro
name|setdefaults
argument_list|()
end_macro

begin_comment
comment|/* set default sizes for variables like boxht */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|;
name|YYSTYPE
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|defaults
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|.
name|f
operator|=
name|defaults
index|[
name|i
index|]
operator|.
name|val
expr_stmt|;
name|makevar
argument_list|(
name|tostring
argument_list|(
name|defaults
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|,
name|VARNAME
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|resetvar
argument_list|()
end_macro

begin_comment
comment|/* reset variables listed */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|nattr
operator|==
literal|0
condition|)
block|{
comment|/* none listed, so do all */
name|setdefaults
argument_list|()
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nattr
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|defaults
index|[
name|j
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|defaults
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|attr
index|[
name|i
index|]
operator|.
name|a_val
operator|.
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
name|setfval
argument_list|(
name|defaults
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|defaults
index|[
name|j
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|attr
index|[
name|i
index|]
operator|.
name|a_val
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_macro
name|checkscale
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* if s is "scale", adjust default variables */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|float
name|scale
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"scale"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|scale
operator|=
name|getfval
argument_list|(
literal|"scale"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|defaults
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|defaults
index|[
name|i
index|]
operator|.
name|scalable
condition|)
name|setfval
argument_list|(
name|defaults
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|defaults
index|[
name|i
index|]
operator|.
name|val
operator|*
name|scale
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|getdata
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|,
name|buf
index|[
literal|1000
index|]
decl_stmt|,
name|buf1
index|[
literal|100
index|]
decl_stmt|;
name|int
name|ln
decl_stmt|;
name|curfile
operator|->
name|lineno
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|".lf 1 %s\n"
argument_list|,
name|curfile
operator|->
name|fname
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|curfile
operator|->
name|fin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|curfile
operator|->
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'.'
operator|&&
operator|*
operator|(
name|buf
operator|+
literal|1
operator|)
operator|==
literal|'P'
operator|&&
operator|*
operator|(
name|buf
operator|+
literal|2
operator|)
operator|==
literal|'S'
condition|)
block|{
for|for
control|(
name|p
operator|=
operator|&
name|buf
index|[
literal|3
index|]
init|;
operator|*
name|p
operator|==
literal|' '
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'<'
condition|)
block|{
name|Infile
name|svfile
decl_stmt|;
name|svfile
operator|=
operator|*
name|curfile
expr_stmt|;
name|sscanf
argument_list|(
name|p
argument_list|,
literal|"%s"
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|curfile
operator|->
name|fin
operator|=
name|fopen
argument_list|(
name|buf1
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"can't open %s"
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|curfile
operator|->
name|fname
operator|=
name|tostring
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|getdata
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|curfile
operator|->
name|fin
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curfile
operator|->
name|fname
argument_list|)
expr_stmt|;
operator|*
name|curfile
operator|=
name|svfile
expr_stmt|;
name|printf
argument_list|(
literal|".lf %d %s\n"
argument_list|,
name|curfile
operator|->
name|lineno
argument_list|,
name|curfile
operator|->
name|fname
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|reset
argument_list|()
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
comment|/* yylval.i now contains 'E' or 'F' from .PE or .PF */
name|deltx
operator|=
operator|(
name|xmax
operator|-
name|xmin
operator|)
operator|/
name|getfval
argument_list|(
literal|"scale"
argument_list|)
expr_stmt|;
name|delty
operator|=
operator|(
name|ymax
operator|-
name|ymin
operator|)
operator|/
name|getfval
argument_list|(
literal|"scale"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|3
index|]
operator|==
literal|' '
condition|)
block|{
comment|/* next things are wid& ht */
if|if
condition|(
name|sscanf
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|,
literal|"%f%f"
argument_list|,
operator|&
name|deltx
argument_list|,
operator|&
name|delty
argument_list|)
operator|<
literal|2
condition|)
name|delty
operator|=
name|deltx
operator|*
operator|(
name|ymax
operator|-
name|ymin
operator|)
operator|/
operator|(
name|xmax
operator|-
name|xmin
operator|)
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|"deltx = %g, delty = %g\n"
argument_list|,
name|deltx
argument_list|,
name|delty
argument_list|)
expr_stmt|;
if|if
condition|(
name|codegen
operator|&&
operator|!
name|synerr
condition|)
block|{
name|openpl
argument_list|(
operator|&
name|buf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* puts out .PS, with ht& wid stuck in */
name|printf
argument_list|(
literal|".lf %d\n"
argument_list|,
name|curfile
operator|->
name|lineno
operator|+
literal|1
argument_list|)
expr_stmt|;
name|print
argument_list|()
expr_stmt|;
comment|/* assumes \n at end */
name|closepl
argument_list|(
name|yylval
operator|.
name|i
argument_list|)
expr_stmt|;
comment|/* does the .PE/F */
block|}
name|printf
argument_list|(
literal|".lf %d\n"
argument_list|,
name|curfile
operator|->
name|lineno
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'l'
operator|&&
name|buf
index|[
literal|2
index|]
operator|==
literal|'f'
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|buf
operator|+
literal|3
argument_list|,
literal|"%d %s"
argument_list|,
operator|&
name|ln
argument_list|,
name|buf1
argument_list|)
operator|==
literal|2
condition|)
block|{
name|free
argument_list|(
name|curfile
operator|->
name|fname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".lf %d %s\n"
argument_list|,
name|curfile
operator|->
name|lineno
operator|=
name|ln
argument_list|,
name|curfile
operator|->
name|fname
operator|=
name|tostring
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|".lf %d\n"
argument_list|,
name|curfile
operator|->
name|lineno
operator|=
name|ln
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|reset
argument_list|()
end_macro

begin_block
block|{
name|obj
modifier|*
name|op
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
specifier|extern
name|int
name|nstack
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nobj
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|objlist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|o_type
operator|==
name|BLOCK
condition|)
name|freesymtab
argument_list|(
name|op
operator|->
name|o_symtab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|objlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|nobj
operator|=
literal|0
expr_stmt|;
name|nattr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntext
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|text
index|[
name|i
index|]
operator|.
name|t_val
condition|)
name|free
argument_list|(
name|text
index|[
name|i
index|]
operator|.
name|t_val
argument_list|)
expr_stmt|;
name|ntext
operator|=
name|ntext1
operator|=
literal|0
expr_stmt|;
name|codegen
operator|=
name|synerr
operator|=
literal|0
expr_stmt|;
name|nstack
operator|=
literal|0
expr_stmt|;
name|curx
operator|=
name|cury
operator|=
literal|0
expr_stmt|;
name|hvmode
operator|=
name|R_DIR
expr_stmt|;
name|xmin
operator|=
name|ymin
operator|=
literal|30000
expr_stmt|;
name|xmax
operator|=
name|ymax
operator|=
operator|-
literal|30000
expr_stmt|;
block|}
end_block

end_unit

