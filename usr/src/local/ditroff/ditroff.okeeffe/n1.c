begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)n1.c	1.1 (CWI) 85/07/17"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"tdef.h"
end_include

begin_decl_stmt
specifier|extern
include|#
directive|include
file|"d.h"
specifier|extern
include|#
directive|include
file|"v.h"
ifdef|#
directive|ifdef
name|NROFF
specifier|extern
include|#
directive|include
file|"tw.h"
endif|#
directive|endif
include|#
directive|include
file|"s.h"
include|#
directive|include
file|<setjmp.h>
name|jmp_buf
name|sjbuf
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_comment
comment|/* troff1.c  consume options, initialization, main loop, input routines, escape function calling */
end_comment

begin_include
include|#
directive|include
file|"ext.h"
end_include

begin_function_decl
name|char
modifier|*
name|sprintf
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|tchar
name|inchar
index|[
name|LNSIZE
index|]
decl_stmt|,
modifier|*
name|pinchar
init|=
name|inchar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|filep
name|ipl
index|[
name|NSO
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|offl
index|[
name|NSO
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|ioff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ttyp
decl_stmt|;
end_decl_stmt

begin_struct
specifier|extern
struct|struct
name|contab
block|{
name|int
name|rq
decl_stmt|;
union|union
block|{
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
function_decl|;
name|unsigned
name|mx
decl_stmt|;
block|}
name|x
union|;
block|}
name|contab
index|[
name|NM
index|]
struct|;
end_struct

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|j
expr_stmt|;
name|tchar
name|i
decl_stmt|;
extern|extern catch(
block|)
operator|,
function|kcatch
parameter_list|()
function|;
end_function

begin_decl_stmt
name|int
name|oargc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|oargv
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|catch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|catch
argument_list|)
operator|==
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|catch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|kcatch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|oargc
operator|=
name|argc
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|oargv
operator|=
name|argv
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|init0
argument_list|()
expr_stmt|;
end_expr_stmt

begin_label
name|options
label|:
end_label

begin_while
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|(
operator|++
name|argv
operator|)
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'F'
case|:
comment|/* switch font tables from default */
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|strcpy
argument_list|(
name|termtab
argument_list|,
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fontfile
argument_list|,
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|strcpy
argument_list|(
name|termtab
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fontfile
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
literal|0
case|:
goto|goto
name|start
goto|;
case|case
literal|'i'
case|:
name|stdi
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'q'
case|:
name|quiet
operator|++
expr_stmt|;
if|if
condition|(
name|gtty
argument_list|(
literal|0
argument_list|,
operator|&
name|ttys
argument_list|)
operator|>=
literal|0
condition|)
name|ttysave
operator|=
name|ttys
operator|.
name|sg_flags
expr_stmt|;
continue|continue;
case|case
literal|'n'
case|:
name|npn
operator|=
name|ctoi
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
comment|/* set emboldening amount */
name|bdtab
index|[
literal|3
index|]
operator|=
name|ctoi
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdtab
index|[
literal|3
index|]
operator|<
literal|0
operator|||
name|bdtab
index|[
literal|3
index|]
operator|>
literal|50
condition|)
name|bdtab
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
if|if
condition|(
operator|!
operator|(
name|stop
operator|=
name|ctoi
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
name|stop
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|eibuf
operator|=
name|sprintf
argument_list|(
name|ibuf
operator|+
name|strlen
argument_list|(
name|ibuf
argument_list|)
argument_list|,
literal|".nr %c %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|,
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'m'
case|:
name|p
operator|=
operator|&
name|nextf
index|[
name|nfi
index|]
expr_stmt|;
name|q
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
name|mflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'o'
case|:
name|getpn
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'D'
case|:
comment|/* select ``DUTCH'' as default dialect jna  */
name|hyalg1
operator|=
name|hyalg
operator|=
name|DUTCH
expr_stmt|;
name|thresh
operator|=
name|DUTCH_THRESH
expr_stmt|;
continue|continue;
ifdef|#
directive|ifdef
name|NROFF
case|case
literal|'h'
case|:
name|hflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'z'
case|:
name|no_out
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'e'
case|:
name|eqflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
name|strcat
argument_list|(
name|termtab
argument_list|,
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|dotT
operator|++
expr_stmt|;
continue|continue;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NROFF
case|case
literal|'T'
case|:
name|strcpy
argument_list|(
name|devname
argument_list|,
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|dotT
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'z'
case|:
name|no_out
operator|++
expr_stmt|;
case|case
literal|'a'
case|:
name|ascii
operator|=
literal|1
expr_stmt|;
name|nofeed
operator|++
expr_stmt|;
case|case
literal|'t'
case|:
name|ptid
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'f'
case|:
name|nofeed
operator|++
expr_stmt|;
continue|continue;
endif|#
directive|endif
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"troff: unknown option %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|02
argument_list|)
expr_stmt|;
block|}
end_while

begin_label
name|start
label|:
end_label

begin_expr_stmt
name|init1
argument_list|(
name|oargv
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|argp
operator|=
name|argv
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rargc
operator|=
name|argc
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|init2
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setjmp
argument_list|(
name|sjbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|loop
label|:
end_label

begin_expr_stmt
name|copyf
operator|=
name|lgf
operator|=
name|nb
operator|=
name|nflush
operator|=
name|nlflg
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ip
operator|&&
name|rbf0
argument_list|(
name|ip
argument_list|)
operator|==
literal|0
operator|&&
name|ejf
operator|&&
name|frame
operator|->
name|pframe
operator|<=
name|ejl
condition|)
block|{
name|nflush
operator|++
expr_stmt|;
name|trap
operator|=
literal|0
expr_stmt|;
name|eject
argument_list|(
operator|(
expr|struct
name|s
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_if

begin_expr_stmt
name|i
operator|=
name|getch
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|pendt
condition|)
goto|goto
name|lt
goto|;
end_if

begin_if
if|if
condition|(
operator|(
name|j
operator|=
name|cbits
argument_list|(
name|i
argument_list|)
operator|)
operator|==
name|XPAR
condition|)
block|{
name|copyf
operator|++
expr_stmt|;
name|tflg
operator|++
expr_stmt|;
while|while
condition|(
name|cbits
argument_list|(
name|i
argument_list|)
operator|!=
literal|'\n'
condition|)
name|pchar
argument_list|(
name|i
operator|=
name|getch
argument_list|()
argument_list|)
expr_stmt|;
name|tflg
operator|=
literal|0
expr_stmt|;
name|copyf
operator|--
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_if

begin_if
if|if
condition|(
name|j
operator|==
name|cc
operator|||
name|j
operator|==
name|c2
condition|)
block|{
if|if
condition|(
name|j
operator|==
name|c2
condition|)
name|nb
operator|++
expr_stmt|;
name|copyf
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|cbits
argument_list|(
name|i
operator|=
name|getch
argument_list|()
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|j
operator|==
literal|'\t'
condition|)
empty_stmt|;
name|ch
operator|=
name|i
expr_stmt|;
name|copyf
operator|--
expr_stmt|;
name|control
argument_list|(
name|getrq
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|flushi
argument_list|()
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_if

begin_label
name|lt
label|:
end_label

begin_expr_stmt
name|ch
operator|=
name|i
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|text
argument_list|()
expr_stmt|;
end_expr_stmt

begin_goto
goto|goto
name|loop
goto|;
end_goto

begin_expr_stmt
unit|}   catch
operator|(
operator|)
block|{
name|done3
argument_list|(
literal|01
argument_list|)
block|; }
name|kcatch
argument_list|()
block|{
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
block|;
name|done3
argument_list|(
literal|01
argument_list|)
block|; }
name|init0
argument_list|()
block|{
name|eibuf
operator|=
name|ibufp
operator|=
name|ibuf
block|;
name|ibuf
index|[
literal|0
index|]
operator|=
literal|0
block|;
name|v
operator|.
name|nl
operator|=
operator|-
literal|1
block|; }
name|init1
argument_list|(
argument|a
argument_list|)
name|char
name|a
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
specifier|register
name|i
expr_stmt|;
name|p
operator|=
name|mktemp
argument_list|(
literal|"/usr/tmp/trtmpXXXXX"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
literal|'a'
condition|)
name|p
operator|=
operator|&
name|p
index|[
literal|9
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|close
argument_list|(
name|creat
argument_list|(
name|p
argument_list|,
literal|0600
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"troff: cannot create temp file.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|ibf
operator|=
name|open
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|unlkp
operator|=
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NTRTAB
init|;
operator|--
name|i
condition|;
control|)
name|trtab
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|trtab
index|[
name|UNPAD
index|]
operator|=
literal|' '
expr_stmt|;
block|}
end_block

begin_macro
name|init2
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|tchar
modifier|*
name|t
decl_stmt|;
specifier|extern
name|int
name|block
decl_stmt|;
specifier|extern
name|char
modifier|*
name|setbrk
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|ttyname
parameter_list|()
function_decl|;
name|ttyod
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|ttyp
operator|=
name|ttyname
argument_list|(
name|j
operator|=
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ttyp
operator|=
name|ttyname
argument_list|(
name|j
operator|=
literal|1
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ttyp
operator|=
name|ttyname
argument_list|(
name|j
operator|=
literal|2
argument_list|)
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
else|else
name|ttyp
operator|=
literal|"notty"
expr_stmt|;
name|iflg
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|ascii
condition|)
name|mesg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|obufp
operator|=
name|obuf
expr_stmt|;
name|ptinit
argument_list|()
expr_stmt|;
name|mchbits
argument_list|()
expr_stmt|;
name|cvtime
argument_list|()
expr_stmt|;
name|v
operator|.
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|olinep
operator|=
name|oline
expr_stmt|;
name|ioff
operator|=
literal|0
expr_stmt|;
name|v
operator|.
name|hp
operator|=
name|init
operator|=
literal|0
expr_stmt|;
name|pinchar
operator|=
name|inchar
expr_stmt|;
comment|/* XXX */
name|v
operator|.
name|nl
operator|=
operator|-
literal|1
expr_stmt|;
name|nfo
operator|=
literal|0
expr_stmt|;
name|ifile
operator|=
literal|0
expr_stmt|;
name|copyf
operator|=
name|raw
operator|=
literal|0
expr_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
name|eibuf
operator|=
name|sprintf
argument_list|(
name|ibuf
operator|+
name|strlen
argument_list|(
name|ibuf
argument_list|)
argument_list|,
literal|".ds .T %s\n"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ibuf
operator|,
name|t
operator|=
name|cbuf
init|;
operator|*
name|t
operator|++
operator|=
operator|*
name|p
operator|++
condition|;
control|)
empty_stmt|;
name|cp
operator|=
name|cbuf
expr_stmt|;
name|eibuf
operator|=
name|ibuf
expr_stmt|;
name|ibufp
operator|=
name|ibuf
expr_stmt|;
name|nx
operator|=
name|mflg
expr_stmt|;
name|frame
operator|=
name|stk
operator|=
operator|(
expr|struct
name|s
operator|*
operator|)
name|setbrk
argument_list|(
name|DELTA
argument_list|)
expr_stmt|;
name|dip
operator|=
operator|&
name|d
index|[
literal|0
index|]
expr_stmt|;
name|nxf
operator|=
name|frame
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NEV
init|;
name|i
operator|--
condition|;
control|)
name|write
argument_list|(
name|ibf
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|block
argument_list|,
name|EVS
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 				 * bug fix jna 				 * This replaces the old cvtime, so on well 				 * maintained systems, you don't need to change 				 * the (quite unknown) ZONE constant in 				 * tdef.h 				 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
endif|BSD42
end_endif

begin_macro
name|cvtime
argument_list|()
end_macro

begin_block
block|{
name|long
name|tt
decl_stmt|;
specifier|register
name|struct
name|tm
modifier|*
name|tym
decl_stmt|;
specifier|extern
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
name|time
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|tym
operator|=
name|localtime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|v
operator|.
name|dy
operator|=
name|tym
operator|->
name|tm_mday
expr_stmt|;
name|v
operator|.
name|dw
operator|=
name|tym
operator|->
name|tm_wday
operator|+
literal|1
expr_stmt|;
name|v
operator|.
name|yr
operator|=
name|tym
operator|->
name|tm_year
expr_stmt|;
name|v
operator|.
name|mo
operator|=
name|tym
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|ctoi
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|n
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|n
operator|=
literal|10
operator|*
name|n
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
return|return
name|n
return|;
block|}
end_block

begin_macro
name|mesg
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|stat
argument_list|(
name|ttyp
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
name|mode
operator|=
operator|(
operator|(
expr|struct
name|stat
operator|*
operator|)
operator|(
name|cbuf
operator|)
operator|)
operator|->
name|st_mode
expr_stmt|;
name|chmod
argument_list|(
name|ttyp
argument_list|,
name|mode
operator|&
operator|~
literal|0122
argument_list|)
expr_stmt|;
comment|/* turn off writing for others */
block|}
else|else
block|{
if|if
condition|(
operator|!
name|init
condition|)
name|chmod
argument_list|(
name|ttyp
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Scaled down version of C Library printf.  * Only %s %u %d (==%u) %o %c %x %D are recognized.  */
end_comment

begin_define
define|#
directive|define
name|putchar
parameter_list|(
name|n
parameter_list|)
value|(*pfbp++ = (n))
end_define

begin_comment
comment|/* NO CHECKING! */
end_comment

begin_decl_stmt
specifier|static
name|char
name|pfbuf
index|[
name|NTM
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pfbp
init|=
name|pfbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stderr
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NOT stdio value */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
name|fprintf
argument_list|(
argument|fd
argument_list|,
argument|fmt
argument_list|,
argument|x1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|x1
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|c
expr_stmt|;
specifier|register
name|unsigned
name|int
modifier|*
name|adx
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|pfbp
operator|=
name|pfbuf
expr_stmt|;
name|adx
operator|=
operator|&
name|x1
expr_stmt|;
name|loop
label|:
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|!=
literal|'%'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|fd
operator|==
name|stderr
condition|)
name|write
argument_list|(
name|stderr
argument_list|,
name|pfbuf
argument_list|,
name|pfbp
operator|-
name|pfbuf
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|pfbp
operator|=
literal|0
expr_stmt|;
name|pfbp
operator|=
name|pfbuf
expr_stmt|;
while|while
condition|(
operator|*
name|pfbp
condition|)
block|{
operator|*
name|obufp
operator|++
operator|=
operator|*
name|pfbp
operator|++
expr_stmt|;
if|if
condition|(
name|obufp
operator|>=
operator|&
name|obuf
index|[
name|OBUFSZ
index|]
condition|)
name|flusho
argument_list|()
expr_stmt|;
block|}
block|}
return|return;
block|}
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
block|{
name|i
operator|=
operator|*
name|adx
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
name|i
expr_stmt|;
block|}
name|printn
argument_list|(
operator|(
name|long
operator|)
name|i
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'u'
operator|||
name|c
operator|==
literal|'o'
operator|||
name|c
operator|==
literal|'x'
condition|)
name|printn
argument_list|(
operator|(
name|long
operator|)
operator|*
name|adx
argument_list|,
name|c
operator|==
literal|'o'
condition|?
literal|8
else|:
operator|(
name|c
operator|==
literal|'x'
condition|?
literal|16
else|:
literal|10
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
name|c
operator|>
literal|0177
operator|||
name|c
operator|<
literal|040
condition|)
name|putchar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|adx
operator|&
literal|0177
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'s'
condition|)
block|{
name|s
operator|=
operator|(
name|char
operator|*
operator|)
operator|*
name|adx
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'D'
condition|)
block|{
name|printn
argument_list|(
operator|*
operator|(
name|long
operator|*
operator|)
name|adx
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|adx
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'O'
condition|)
block|{
name|printn
argument_list|(
operator|*
operator|(
name|long
operator|*
operator|)
name|adx
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|adx
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|adx
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_block

begin_comment
comment|/*  * Print an unsigned integer in base b.  */
end_comment

begin_expr_stmt
specifier|static
name|printn
argument_list|(
argument|n
argument_list|,
argument|b
argument_list|)
name|long
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|long
name|a
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
comment|/* shouldn't happen */
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|n
operator|=
operator|-
name|n
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|=
name|n
operator|/
name|b
condition|)
name|printn
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|"0123456789ABCDEF"
index|[
call|(
name|int
call|)
argument_list|(
name|n
operator|%
name|b
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* scaled down version of library sprintf */
end_comment

begin_comment
comment|/* same limits as fprintf */
end_comment

begin_comment
comment|/* returns pointer to \0 that ends the string */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|char
modifier|*
name|sprintf
parameter_list|(
name|str
parameter_list|,
name|fmt
parameter_list|,
name|x1
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|unsigned
name|x1
decl_stmt|;
block|{
specifier|register
name|c
expr_stmt|;
name|char
modifier|*
name|sprintn
parameter_list|()
function_decl|;
specifier|register
name|unsigned
name|int
modifier|*
name|adx
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|adx
operator|=
operator|&
name|x1
expr_stmt|;
name|loop
label|:
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|!=
literal|'%'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|str
operator|=
literal|0
expr_stmt|;
return|return
name|str
return|;
block|}
operator|*
name|str
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
block|{
name|i
operator|=
operator|*
name|adx
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
operator|*
name|str
operator|++
operator|=
literal|'-'
expr_stmt|;
name|i
operator|=
operator|-
name|i
expr_stmt|;
block|}
name|str
operator|=
name|sprintn
argument_list|(
name|str
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'u'
operator|||
name|c
operator|==
literal|'o'
operator|||
name|c
operator|==
literal|'x'
condition|)
name|str
operator|=
name|sprintn
argument_list|(
name|str
argument_list|,
operator|(
name|long
operator|)
operator|*
name|adx
argument_list|,
name|c
operator|==
literal|'o'
condition|?
literal|8
else|:
operator|(
name|c
operator|==
literal|'x'
condition|?
literal|16
else|:
literal|10
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
name|c
operator|>
literal|0177
operator|||
name|c
operator|<
literal|040
condition|)
operator|*
name|str
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|str
operator|++
operator|=
operator|*
name|adx
operator|&
literal|0177
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'s'
condition|)
block|{
name|s
operator|=
operator|(
name|char
operator|*
operator|)
operator|*
name|adx
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
operator|*
name|str
operator|++
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'D'
condition|)
block|{
name|str
operator|=
name|sprintn
argument_list|(
name|str
argument_list|,
operator|*
operator|(
name|long
operator|*
operator|)
name|adx
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|adx
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'O'
condition|)
block|{
name|str
operator|=
name|sprintn
argument_list|(
name|str
argument_list|,
operator|*
operator|(
name|long
operator|*
operator|)
name|adx
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|adx
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|adx
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_function

begin_comment
comment|/*  * Print an unsigned integer in base b.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|sprintn
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|,
name|b
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|long
name|n
decl_stmt|;
block|{
specifier|register
name|long
name|a
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
comment|/* shouldn't happen */
operator|*
name|s
operator|++
operator|=
literal|'-'
expr_stmt|;
name|n
operator|=
operator|-
name|n
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|=
name|n
operator|/
name|b
condition|)
name|s
operator|=
name|sprintn
argument_list|(
name|s
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|"0123456789ABCDEF"
index|[
call|(
name|int
call|)
argument_list|(
name|n
operator|%
name|b
argument_list|)
index|]
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_expr_stmt
name|control
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
specifier|register
name|int
name|a
operator|,
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
operator|||
operator|(
name|j
operator|=
name|findmn
argument_list|(
name|a
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|contab
index|[
name|j
index|]
operator|.
name|rq
operator|&
name|MMASK
condition|)
block|{
name|nxf
operator|->
name|nargs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b
condition|)
name|collect
argument_list|()
expr_stmt|;
name|flushi
argument_list|()
expr_stmt|;
return|return
operator|(
name|pushi
argument_list|(
operator|(
name|filep
operator|)
name|contab
index|[
name|j
index|]
operator|.
name|x
operator|.
name|mx
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|b
condition|)
return|return
operator|(
operator|(
operator|*
name|contab
index|[
name|j
index|]
operator|.
name|x
operator|.
name|f
operator|)
operator|(
literal|0
operator|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|getrq
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|i
operator|=
name|getach
argument_list|()
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|j
operator|=
name|getach
argument_list|()
operator|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|rtn
goto|;
name|i
operator|=
name|PAIR
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|rtn
label|:
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_function
name|tchar
name|getch
parameter_list|()
block|{
specifier|register
name|int
name|k
decl_stmt|;
name|tchar
name|i
decl_stmt|,
name|j
decl_stmt|;
name|tchar
name|setht
argument_list|()
decl_stmt|,
name|setslant
argument_list|()
decl_stmt|;
name|level
operator|++
expr_stmt|;
name|g0
label|:
if|if
condition|(
name|ch
condition|)
block|{
if|if
condition|(
name|cbits
argument_list|(
name|i
operator|=
name|ch
argument_list|)
operator|==
literal|'\n'
condition|)
name|nlflg
operator|++
expr_stmt|;
name|ch
operator|=
literal|0
expr_stmt|;
name|level
operator|--
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
if|if
condition|(
name|nlflg
condition|)
block|{
name|level
operator|--
expr_stmt|;
return|return
operator|(
literal|'\n'
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|k
operator|=
name|cbits
argument_list|(
name|i
operator|=
name|getch0
argument_list|()
argument_list|)
operator|)
operator|!=
name|ESC
condition|)
block|{
if|if
condition|(
name|ismot
argument_list|(
name|i
argument_list|)
condition|)
goto|goto
name|g2
goto|;
if|if
condition|(
name|k
operator|==
name|FLSS
condition|)
block|{
name|copyf
operator|++
expr_stmt|;
name|raw
operator|++
expr_stmt|;
name|i
operator|=
name|getch0
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fi
condition|)
name|flss
operator|=
name|i
expr_stmt|;
name|copyf
operator|--
expr_stmt|;
name|raw
operator|--
expr_stmt|;
goto|goto
name|g0
goto|;
block|}
if|if
condition|(
name|k
operator|==
name|RPT
condition|)
block|{
name|setrpt
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
block|}
if|if
condition|(
operator|!
name|copyf
condition|)
block|{
if|if
condition|(
name|k
operator|==
literal|'f'
operator|&&
name|lg
operator|&&
operator|!
name|lgf
condition|)
block|{
name|i
operator|=
name|getlg
argument_list|(
name|i
argument_list|)
expr_stmt|;
goto|goto
name|g2
goto|;
block|}
if|if
condition|(
name|k
operator|==
name|fc
operator|||
name|k
operator|==
name|tabch
operator|||
name|k
operator|==
name|ldrch
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|setfield
argument_list|(
name|k
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|g0
goto|;
else|else
goto|goto
name|g2
goto|;
block|}
if|if
condition|(
name|k
operator|==
literal|'\b'
condition|)
block|{
name|i
operator|=
name|makem
argument_list|(
operator|-
name|width
argument_list|(
literal|' '
operator||
name|chbits
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|g2
goto|;
block|}
block|}
goto|goto
name|g2
goto|;
block|}
name|k
operator|=
name|cbits
argument_list|(
name|j
operator|=
name|getch0
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ismot
argument_list|(
name|j
argument_list|)
condition|)
block|{
name|i
operator|=
name|j
expr_stmt|;
goto|goto
name|g2
goto|;
block|}
switch|switch
condition|(
name|k
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* concealed newline */
goto|goto
name|g0
goto|;
case|case
literal|'n'
case|:
comment|/* number register */
name|setn
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'*'
case|:
comment|/* string indicator */
name|setstr
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'$'
case|:
comment|/* argument indicator */
name|seta
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'{'
case|:
comment|/* LEFT */
name|i
operator|=
name|LEFT
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'}'
case|:
comment|/* RIGHT */
name|i
operator|=
name|RIGHT
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'"'
case|:
comment|/* comment */
while|while
condition|(
name|cbits
argument_list|(
name|i
operator|=
name|getch0
argument_list|()
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
goto|goto
name|g2
goto|;
case|case
name|ESC
case|:
comment|/* double backslash */
name|i
operator|=
name|eschar
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'e'
case|:
comment|/* printable version of current eschar */
name|i
operator|=
name|PRESC
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|' '
case|:
comment|/* unpaddable space */
name|i
operator|=
name|UNPAD
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'|'
case|:
comment|/* narrow space */
name|i
operator|=
name|NARSP
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'^'
case|:
comment|/* half of narrow space */
name|i
operator|=
name|HNARSP
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'\''
case|:
comment|/* \(aa */
name|i
operator|=
name|ACUTE
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'`'
case|:
comment|/* \(ga */
name|i
operator|=
name|GRAVE
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'_'
case|:
comment|/* \(ul */
name|i
operator|=
name|UNDERLINE
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'-'
case|:
comment|/* current font minus */
name|i
operator|=
name|MINUS
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'&'
case|:
comment|/* filler */
name|i
operator|=
name|FILLER
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'c'
case|:
comment|/* to be continued */
name|i
operator|=
name|CONT
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'!'
case|:
comment|/* transparent indicator */
name|i
operator|=
name|XPAR
expr_stmt|;
goto|goto
name|gx
goto|;
case|case
literal|'t'
case|:
comment|/* tab */
name|i
operator|=
literal|'\t'
expr_stmt|;
goto|goto
name|g2
goto|;
case|case
literal|'a'
case|:
comment|/* leader (SOH) */
name|i
operator|=
name|LEADER
expr_stmt|;
goto|goto
name|g2
goto|;
case|case
literal|'%'
case|:
comment|/* ohc */
name|i
operator|=
name|OHC
expr_stmt|;
goto|goto
name|g2
goto|;
case|case
literal|'g'
case|:
comment|/* return format of a number register */
name|setaf
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'.'
case|:
comment|/* . */
name|i
operator|=
literal|'.'
expr_stmt|;
name|gx
label|:
name|setsfbits
argument_list|(
name|i
argument_list|,
name|sfbits
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|g2
goto|;
block|}
if|if
condition|(
operator|!
name|copyf
condition|)
switch|switch
condition|(
name|k
condition|)
block|{
case|case
literal|'p'
case|:
comment|/* spread */
name|spread
operator|++
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'('
case|:
comment|/* special char name */
if|if
condition|(
operator|(
name|i
operator|=
name|setch
argument_list|()
operator|)
operator|==
literal|0
condition|)
goto|goto
name|g0
goto|;
break|break;
case|case
literal|'s'
case|:
comment|/* size indicator */
name|setps
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'H'
case|:
comment|/* character height */
name|i
operator|=
name|setht
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* slant */
name|i
operator|=
name|setslant
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* font indicator */
name|setfont
argument_list|(
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'w'
case|:
comment|/* width function */
name|setwd
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'v'
case|:
comment|/* vert mot */
if|if
condition|(
name|i
operator|=
name|vmot
argument_list|()
condition|)
break|break;
goto|goto
name|g0
goto|;
case|case
literal|'h'
case|:
comment|/* horiz mot */
if|if
condition|(
name|i
operator|=
name|hmot
argument_list|()
condition|)
break|break;
goto|goto
name|g0
goto|;
case|case
literal|'z'
case|:
comment|/* zero with char */
name|i
operator|=
name|setz
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* hor line */
name|setline
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'L'
case|:
comment|/* vert line */
name|setvline
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'D'
case|:
comment|/* drawing function */
name|setdraw
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'b'
case|:
comment|/* bracket */
name|setbra
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'o'
case|:
comment|/* overstrike */
name|setov
argument_list|()
expr_stmt|;
goto|goto
name|g0
goto|;
case|case
literal|'k'
case|:
comment|/* mark hor place */
if|if
condition|(
operator|(
name|k
operator|=
name|findr
argument_list|(
name|getsn
argument_list|()
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|vlist
index|[
name|k
index|]
operator|=
name|v
operator|.
name|hp
operator|=
name|sumhp
argument_list|()
expr_stmt|;
block|}
goto|goto
name|g0
goto|;
case|case
literal|'0'
case|:
comment|/* number space */
name|i
operator|=
name|makem
argument_list|(
name|width
argument_list|(
literal|'0'
operator||
name|chbits
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* extra line space */
if|if
condition|(
name|i
operator|=
name|xlss
argument_list|()
condition|)
break|break;
goto|goto
name|g0
goto|;
case|case
literal|'u'
case|:
comment|/* half em up */
case|case
literal|'r'
case|:
comment|/* full em up */
case|case
literal|'d'
case|:
comment|/* half em down */
name|i
operator|=
name|sethl
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
default|default:
name|i
operator|=
name|j
expr_stmt|;
block|}
else|else
block|{
name|ch0
operator|=
name|j
expr_stmt|;
name|i
operator|=
name|eschar
expr_stmt|;
block|}
name|g2
label|:
if|if
condition|(
name|cbits
argument_list|(
name|i
argument_list|)
operator|==
literal|'\n'
condition|)
block|{
name|nlflg
operator|++
expr_stmt|;
name|v
operator|.
name|hp
operator|=
literal|0
expr_stmt|;
name|pinchar
operator|=
name|inchar
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|ip
operator|==
literal|0
condition|)
name|v
operator|.
name|cd
operator|++
expr_stmt|;
comment|/* current input line number in this file */
block|}
if|if
condition|(
operator|!
operator|--
name|level
condition|)
block|{
if|if
condition|(
name|pinchar
operator|>=
name|inchar
operator|+
name|LNSIZE
condition|)
block|{
comment|/* XXX */
name|inchar
index|[
literal|0
index|]
operator|=
name|makem
argument_list|(
name|sumhp
argument_list|()
argument_list|)
expr_stmt|;
name|pinchar
operator|=
operator|&
name|inchar
index|[
literal|1
index|]
expr_stmt|;
block|}
operator|*
name|pinchar
operator|++
operator|=
name|i
expr_stmt|;
comment|/* XXX */
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|char
name|ifilt
index|[
literal|32
index|]
init|=
block|{
literal|0
block|,
literal|001
block|,
literal|002
block|,
literal|003
block|,
literal|0
block|,
literal|005
block|,
literal|006
block|,
literal|007
block|,
literal|010
block|,
literal|011
block|,
literal|012
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|sumhp
argument_list|()
end_macro

begin_comment
comment|/* XXX - add up values in inchar */
end_comment

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|tchar
modifier|*
name|p
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|inchar
init|;
name|p
operator|<
name|pinchar
condition|;
name|p
operator|++
control|)
name|n
operator|+=
name|width
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_function
name|tchar
name|getch0
parameter_list|()
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|tchar
name|i
decl_stmt|;
if|if
condition|(
name|ch0
condition|)
block|{
name|i
operator|=
name|ch0
expr_stmt|;
name|ch0
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
if|if
condition|(
name|nchar
condition|)
block|{
name|nchar
operator|--
expr_stmt|;
return|return
operator|(
name|rchar
operator|)
return|;
block|}
name|again
label|:
if|if
condition|(
name|cp
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
operator|*
name|cp
operator|++
operator|)
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|ap
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
operator|*
name|ap
operator|++
operator|)
operator|==
literal|0
condition|)
block|{
name|ap
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|ip
condition|)
block|{
if|if
condition|(
name|ip
operator|==
operator|-
literal|1
condition|)
name|i
operator|=
name|rdtty
argument_list|()
expr_stmt|;
else|else
name|i
operator|=
name|rbf
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|donef
condition|)
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nx
operator|||
name|ibufp
operator|>=
name|eibuf
condition|)
block|{
if|if
condition|(
name|nfo
condition|)
goto|goto
name|g1
goto|;
name|g0
label|:
if|if
condition|(
name|nextfile
argument_list|()
condition|)
block|{
if|if
condition|(
name|ip
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
name|ibufp
operator|<
name|eibuf
condition|)
goto|goto
name|g2
goto|;
block|}
name|g1
label|:
name|nx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|read
argument_list|(
name|ifile
argument_list|,
name|ibuf
argument_list|,
name|IBUFSZ
argument_list|)
operator|)
operator|<=
literal|0
condition|)
goto|goto
name|g0
goto|;
name|ibufp
operator|=
name|ibuf
expr_stmt|;
name|eibuf
operator|=
name|ibuf
operator|+
name|j
expr_stmt|;
if|if
condition|(
name|ip
condition|)
goto|goto
name|again
goto|;
block|}
name|g2
label|:
name|i
operator|=
operator|*
name|ibufp
operator|++
operator|&
literal|0177
expr_stmt|;
name|ioff
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|040
condition|)
goto|goto
name|g4
goto|;
else|else
name|i
operator|=
name|ifilt
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|raw
condition|)
return|return
operator|(
name|i
operator|)
return|;
if|if
condition|(
operator|(
name|j
operator|=
name|cbits
argument_list|(
name|i
argument_list|)
operator|)
operator|==
name|IMP
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
operator|!
name|init
condition|)
goto|goto
name|again
goto|;
name|g4
label|:
if|if
condition|(
name|copyf
operator|==
literal|0
operator|&&
operator|(
name|i
operator|&
operator|~
name|BMASK
operator|)
operator|==
literal|0
operator|&&
operator|!
name|iscontrol
argument_list|(
name|cbits
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
name|i
operator||=
name|chbits
expr_stmt|;
if|if
condition|(
name|cbits
argument_list|(
name|i
argument_list|)
operator|==
name|eschar
condition|)
name|setcbits
argument_list|(
name|i
argument_list|,
name|ESC
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_macro
name|nextfile
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|n0
label|:
if|if
condition|(
name|ifile
condition|)
name|close
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
if|if
condition|(
name|nx
condition|)
block|{
name|p
operator|=
name|nextf
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
goto|goto
name|n1
goto|;
block|}
if|if
condition|(
name|ifi
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|popf
argument_list|()
condition|)
goto|goto
name|n0
goto|;
comment|/* popf error */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* popf ok */
block|}
if|if
condition|(
name|rargc
operator|--
operator|<=
literal|0
condition|)
block|{
goto|goto
name|n2
goto|;
block|}
name|p
operator|=
operator|(
name|argp
operator|++
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|n1
label|:
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|ifile
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifile
operator|=
name|open
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"troff: cannot open %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|nfo
operator|-=
name|mflg
expr_stmt|;
name|done
argument_list|(
literal|02
argument_list|)
expr_stmt|;
block|}
name|nfo
operator|++
expr_stmt|;
name|v
operator|.
name|cd
operator|=
literal|0
expr_stmt|;
name|ioff
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|n2
label|:
if|if
condition|(
operator|(
name|nfo
operator|-=
name|mflg
operator|)
operator|&&
operator|!
name|stdi
condition|)
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nfo
operator|++
expr_stmt|;
name|v
operator|.
name|cd
operator|=
name|ifile
operator|=
name|stdi
operator|=
name|mflg
operator|=
literal|0
expr_stmt|;
name|ioff
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|popf
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ttyname
parameter_list|()
function_decl|;
name|ioff
operator|=
name|offl
index|[
operator|--
name|ifi
index|]
expr_stmt|;
name|ip
operator|=
name|ipl
index|[
name|ifi
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ifile
operator|=
name|ifl
index|[
name|ifi
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|xbuf
expr_stmt|;
name|q
operator|=
name|ibuf
expr_stmt|;
name|ibufp
operator|=
name|xbufp
expr_stmt|;
name|eibuf
operator|=
name|xeibuf
expr_stmt|;
while|while
condition|(
name|q
operator|<
name|eibuf
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|lseek
argument_list|(
name|ifile
argument_list|,
call|(
name|long
call|)
argument_list|(
name|ioff
operator|&
operator|~
operator|(
name|IBUFSZ
operator|-
literal|1
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|ifile
argument_list|,
name|ibuf
argument_list|,
name|IBUFSZ
argument_list|)
operator|)
operator|<
literal|0
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|eibuf
operator|=
name|ibuf
operator|+
name|i
expr_stmt|;
name|ibufp
operator|=
name|ibuf
expr_stmt|;
if|if
condition|(
name|ttyname
argument_list|(
name|ifile
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|ibufp
operator|=
name|ibuf
operator|+
call|(
name|int
call|)
argument_list|(
name|ioff
operator|&
operator|(
name|IBUFSZ
operator|-
literal|1
operator|)
argument_list|)
operator|)
operator|>=
name|eibuf
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|flushi
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|nflush
condition|)
return|return;
name|ch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cbits
argument_list|(
name|ch0
argument_list|)
operator|==
literal|'\n'
condition|)
name|nlflg
operator|++
expr_stmt|;
name|ch0
operator|=
literal|0
expr_stmt|;
name|copyf
operator|++
expr_stmt|;
while|while
condition|(
operator|!
name|nlflg
condition|)
block|{
if|if
condition|(
name|donef
operator|&&
operator|(
name|frame
operator|==
name|stk
operator|)
condition|)
break|break;
name|getch
argument_list|()
expr_stmt|;
block|}
name|copyf
operator|--
expr_stmt|;
name|v
operator|.
name|hp
operator|=
literal|0
expr_stmt|;
name|pinchar
operator|=
name|inchar
expr_stmt|;
comment|/* XXX */
block|}
end_block

begin_macro
name|getach
argument_list|()
end_macro

begin_block
block|{
name|tchar
name|i
decl_stmt|;
specifier|register
name|j
expr_stmt|;
name|lgf
operator|++
expr_stmt|;
name|j
operator|=
name|cbits
argument_list|(
name|i
operator|=
name|getch
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ismot
argument_list|(
name|i
argument_list|)
operator|||
name|j
operator|==
literal|' '
operator|||
name|j
operator|==
literal|'\n'
operator|||
name|j
operator|&
literal|0200
condition|)
block|{
name|ch
operator|=
name|i
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
name|lgf
operator|--
expr_stmt|;
return|return
operator|(
name|j
operator|&
literal|0177
operator|)
return|;
block|}
end_block

begin_macro
name|casenx
argument_list|()
end_macro

begin_block
block|{
name|lgf
operator|++
expr_stmt|;
name|skip
argument_list|()
expr_stmt|;
name|getname
argument_list|()
expr_stmt|;
name|nx
operator|++
expr_stmt|;
name|nextfile
argument_list|()
expr_stmt|;
name|nlflg
operator|++
expr_stmt|;
name|ip
operator|=
literal|0
expr_stmt|;
name|ap
operator|=
literal|0
expr_stmt|;
name|nchar
operator|=
name|pendt
operator|=
literal|0
expr_stmt|;
name|frame
operator|=
name|stk
expr_stmt|;
name|nxf
operator|=
name|frame
operator|+
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|getname
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|tchar
name|i
decl_stmt|;
name|lgf
operator|++
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|(
name|NS
operator|-
literal|1
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|j
operator|=
name|cbits
argument_list|(
name|i
operator|=
name|getch
argument_list|()
argument_list|)
operator|)
operator|<=
literal|' '
operator|)
operator|||
operator|(
name|j
operator|>
literal|0176
operator|)
condition|)
break|break;
name|nextf
index|[
name|k
index|]
operator|=
name|j
expr_stmt|;
block|}
name|nextf
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|i
expr_stmt|;
name|lgf
operator|--
expr_stmt|;
return|return
operator|(
name|nextf
index|[
literal|0
index|]
operator|)
return|;
block|}
end_block

begin_macro
name|caseso
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|lgf
operator|++
expr_stmt|;
name|nextf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|skip
argument_list|()
operator|||
operator|!
name|getname
argument_list|()
operator|||
operator|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|nextf
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|ifi
operator|>=
name|NSO
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"troff: can't open file %s\n"
argument_list|,
name|nextf
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|02
argument_list|)
expr_stmt|;
block|}
name|flushi
argument_list|()
expr_stmt|;
name|ifl
index|[
name|ifi
index|]
operator|=
name|ifile
expr_stmt|;
name|ifile
operator|=
name|i
expr_stmt|;
name|offl
index|[
name|ifi
index|]
operator|=
name|ioff
expr_stmt|;
name|ioff
operator|=
literal|0
expr_stmt|;
name|ipl
index|[
name|ifi
index|]
operator|=
name|ip
expr_stmt|;
name|ip
operator|=
literal|0
expr_stmt|;
name|nx
operator|++
expr_stmt|;
name|nflush
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ifl
index|[
name|ifi
operator|++
index|]
condition|)
block|{
name|p
operator|=
name|ibuf
expr_stmt|;
name|q
operator|=
name|xbuf
expr_stmt|;
name|xbufp
operator|=
name|ibufp
expr_stmt|;
name|xeibuf
operator|=
name|eibuf
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|eibuf
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|casecf
argument_list|()
end_macro

begin_block
block|{
comment|/* copy file without change */
ifndef|#
directive|ifndef
name|NROFF
name|int
name|fd
decl_stmt|,
name|n
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
specifier|extern
name|int
name|un
decl_stmt|,
name|hpos
decl_stmt|,
name|esc
decl_stmt|,
name|po
decl_stmt|;
name|nextf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|skip
argument_list|()
operator|||
operator|!
name|getname
argument_list|()
operator|||
operator|(
name|fd
operator|=
name|open
argument_list|(
name|nextf
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"troff: can't open file %s\n"
argument_list|,
name|nextf
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|02
argument_list|)
expr_stmt|;
block|}
name|tbreak
argument_list|()
expr_stmt|;
comment|/* make it into a clean state, be sure that everything is out */
name|hpos
operator|=
name|po
expr_stmt|;
name|esc
operator|=
name|un
expr_stmt|;
name|ptesc
argument_list|()
expr_stmt|;
name|ptlead
argument_list|()
expr_stmt|;
name|ptps
argument_list|()
expr_stmt|;
name|ptfont
argument_list|()
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
literal|512
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|write
argument_list|(
name|ptid
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|casesy
argument_list|()
end_macro

begin_block
block|{
comment|/* call system */
name|char
name|sybuf
index|[
name|NTM
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lgf
operator|++
expr_stmt|;
name|copyf
operator|++
expr_stmt|;
name|skip
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTM
operator|-
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|sybuf
index|[
name|i
index|]
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
break|break;
name|sybuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|system
argument_list|(
name|sybuf
argument_list|)
expr_stmt|;
name|copyf
operator|--
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|getpn
argument_list|(
name|a
argument_list|)
specifier|register
name|char
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|,
name|neg
decl_stmt|;
if|if
condition|(
operator|*
name|a
operator|==
literal|0
condition|)
return|return;
name|neg
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|a
condition|;
name|a
operator|++
control|)
switch|switch
condition|(
operator|*
name|a
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|','
case|:
continue|continue;
case|case
literal|'-'
case|:
name|neg
operator|=
literal|1
expr_stmt|;
continue|continue;
default|default:
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|a
argument_list|)
condition|)
block|{
do|do
name|n
operator|=
literal|10
operator|*
name|n
operator|+
operator|*
name|a
operator|++
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|a
argument_list|)
condition|)
do|;
name|a
operator|--
expr_stmt|;
block|}
else|else
name|n
operator|=
literal|9999
expr_stmt|;
operator|*
name|pnp
operator|++
operator|=
name|neg
condition|?
operator|-
name|n
else|:
name|n
expr_stmt|;
name|neg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pnp
operator|>=
operator|&
name|pnlist
index|[
name|NPN
operator|-
literal|2
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"troff: too many page numbers\n"
argument_list|)
expr_stmt|;
name|done3
argument_list|(
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|neg
condition|)
operator|*
name|pnp
operator|++
operator|=
operator|-
literal|9999
expr_stmt|;
operator|*
name|pnp
operator|=
operator|-
literal|32767
expr_stmt|;
name|print
operator|=
literal|0
expr_stmt|;
name|pnp
operator|=
name|pnlist
expr_stmt|;
if|if
condition|(
operator|*
name|pnp
operator|!=
operator|-
literal|32767
condition|)
name|chkpn
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|setrpt
argument_list|()
end_macro

begin_block
block|{
name|tchar
name|i
decl_stmt|,
name|j
decl_stmt|;
name|copyf
operator|++
expr_stmt|;
name|raw
operator|++
expr_stmt|;
name|i
operator|=
name|getch0
argument_list|()
expr_stmt|;
name|copyf
operator|--
expr_stmt|;
name|raw
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|cbits
argument_list|(
name|j
operator|=
name|getch0
argument_list|()
argument_list|)
operator|==
name|RPT
condition|)
return|return;
name|rchar
operator|=
name|j
expr_stmt|;
name|nchar
operator|=
name|i
operator|&
name|BMASK
expr_stmt|;
block|}
end_block

end_unit

