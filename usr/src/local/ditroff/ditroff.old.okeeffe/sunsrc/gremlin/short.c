begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * @(#)short.c	1.2	%G%  *  * Routines for the "short" commands of the SUN Gremlin picture editor.  *  * Mark Opperman (opcode@monet.BERKELEY)  *  */
end_comment

begin_include
include|#
directive|include
file|<suntool/tool_hs.h>
end_include

begin_include
include|#
directive|include
file|"icondata.h"
end_include

begin_include
include|#
directive|include
file|"gremlin.h"
end_include

begin_comment
comment|/* imports from graphics files */
end_comment

begin_extern
extern|extern GRClear(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern GRCurrentSet(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern GRCurrentSetOn(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern GRCurrentSetOff(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern GRDisplayPoint(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern GRSetCurve(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern GRSetTextPos(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from undodb.c */
end_comment

begin_extern
extern|extern UNForget(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from display.c */
end_comment

begin_extern
extern|extern DISClearSetDisplay(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern DISScreenAdd(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern DISScreenErase(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from database files */
end_comment

begin_function_decl
specifier|extern
name|ELT
modifier|*
name|DBCopy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|ELT
modifier|*
name|DBCreateElt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|POINT
modifier|*
name|PTMakePoint
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|POINT
modifier|*
name|PTMakeTextPoints
parameter_list|()
function_decl|;
end_function_decl

begin_extern
extern|extern DBDelete(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern DBClearElt(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern DBXform(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern DBBounded(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern DBAddSet(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern DBClearSet(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from long.c */
end_comment

begin_extern
extern|extern LGIncludeSet(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern CP(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* clear points */
end_comment

begin_extern
extern|extern CSP(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* clear show points */
end_comment

begin_comment
comment|/* imports from menu.c  */
end_comment

begin_extern
extern|extern MNHighLt(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern MNUnHighLt(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern HiBrush[];
end_extern

begin_extern
extern|extern HiBuffer[];
end_extern

begin_extern
extern|extern HiFont[];
end_extern

begin_extern
extern|extern HiMode[];
end_extern

begin_extern
extern|extern HiSize[];
end_extern

begin_decl_stmt
name|int
name|adj
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* imports from help.c */
end_comment

begin_extern
extern|extern help(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from text.c */
end_comment

begin_extern
extern|extern TxMsgOK(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern TxPutMsg(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern text_putvalue(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern text_restorebuf(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from C */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* imports from main.c */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|PICTURE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current PICTURE database      */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|cset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current set database          */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|MEN
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers for user symbols     */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
name|arhead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* arrow head template           */
end_comment

begin_decl_stmt
specifier|extern
name|POINT
name|MENPOINT
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers used fo user symbols */
end_comment

begin_decl_stmt
specifier|extern
name|POINT
modifier|*
name|POINTLIST
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* accumulated point list        */
end_comment

begin_extern
extern|extern CBRUSH;
end_extern

begin_comment
comment|/* current brush                 */
end_comment

begin_extern
extern|extern Gridon;
end_extern

begin_comment
comment|/* grid mode flag                */
end_comment

begin_extern
extern|extern SEQ;
end_extern

begin_comment
comment|/* point sequence number         */
end_comment

begin_extern
extern|extern Adjustment;
end_extern

begin_comment
comment|/* point adjustment mode         */
end_comment

begin_extern
extern|extern GravityOn;
end_extern

begin_comment
comment|/* gravity mode flag             */
end_comment

begin_extern
extern|extern CHANGED;
end_extern

begin_comment
comment|/* PICTURE changed flag          */
end_comment

begin_extern
extern|extern CsetOn;
end_extern

begin_comment
comment|/* current set displayed on	     */
end_comment

begin_function_decl
specifier|extern
function_decl|(
modifier|*
name|lastcommand
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* previous command */
end_comment

begin_extern
extern|extern lasttext;
end_extern

begin_comment
comment|/* TRUE if previous command wants text */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|pixwin
modifier|*
name|pix_pw
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern SHUpdate(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|SHAgain
argument_list|()
operator|,
name|SHDrawArc
argument_list|()
operator|,
name|SHDrawCurve
argument_list|()
operator|,
name|SHCopy
argument_list|()
operator|,
name|SHDefineSet
argument_list|()
operator|,
name|SHErase
argument_list|()
operator|,
name|SHSetArea
argument_list|()
operator|,
name|SHGravity
argument_list|()
operator|,
name|SHGrid
argument_list|()
operator|,
name|SHRotate
argument_list|()
operator|,
name|SHScale
argument_list|()
operator|,
name|SHTranslate
argument_list|()
operator|,
name|SHDrawVector
argument_list|()
operator|,
name|SHMAdjust
argument_list|()
operator|,
name|SHBox
argument_list|()
operator|,
name|SHArrow
argument_list|()
operator|,
name|SHSave1
argument_list|()
operator|,
name|SHSave2
argument_list|()
operator|,
name|SHSave3
argument_list|()
operator|,
name|SHSave4
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern LGUndo(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|twoPi
value|6.2832
end_define

begin_decl_stmt
specifier|static
name|char
name|nopnt
index|[
literal|18
index|]
init|=
literal|"not enough points"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|noset
index|[
literal|15
index|]
init|=
literal|"no current set"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * The following two arrays define the short commands and the routines  * that process them.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|shcmds
index|[]
init|=
block|{
literal|'\14'
block|,
literal|'.'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'?'
block|,
literal|'a'
block|,
literal|'b'
block|,
literal|'c'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|'f'
block|,
literal|'g'
block|,
literal|'q'
block|,
literal|'r'
block|,
literal|'s'
block|,
literal|'t'
block|,
literal|'u'
block|,
literal|'v'
block|,
literal|'w'
block|,
literal|'x'
block|,
literal|'z'
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
operator|(
operator|*
operator|(
name|shrtns
index|[]
operator|)
operator|)
operator|(
operator|)
operator|=
block|{
name|SHUpdate
block|,
comment|/* redraw screen */
name|SHAgain
block|,
comment|/* repeat last command */
name|SHSave1
block|,
comment|/* save user symbol */
name|SHSave2
block|,
comment|/* save user symbol */
name|SHSave3
block|,
comment|/* save user symbol */
name|SHSave4
block|,
comment|/* save user symbol */
name|help
block|,
comment|/* help screen */
name|SHDrawArc
block|,
comment|/* draw arc */
name|SHDrawCurve
block|,
comment|/* draw curve */
name|SHCopy
block|,
comment|/* copy current set */
name|SHDefineSet
block|,
comment|/* define current set */
name|SHErase
block|,
comment|/* erase elements */
name|SHSetArea
block|,
comment|/* select area for current set */
name|SHGravity
block|,
comment|/* gravity */
name|SHGrid
block|,
comment|/* toggle grid display */
name|SHRotate
block|,
comment|/* rotate current set */
name|SHScale
block|,
comment|/* scale current set */
name|SHTranslate
block|,
comment|/* translate current set */
name|LGUndo
block|,
comment|/* undo last command */
name|SHDrawVector
block|,
comment|/* draw vectors */
name|SHArrow
block|,
comment|/* arrowhead */
name|SHBox
block|,
comment|/* rectangle from two points */
name|SHMAdjust
comment|/* manhattan adjust */
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * SHLookup searches a table of characters to find one that matches a  * the given character.  * If c is a valid command character, its index is returned;  * if c is the null command, -2 is returned, else -1 is returned.  */
end_comment

begin_macro
name|SHLookup
argument_list|(
argument|c
argument_list|,
argument|table
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* char to be looked up */
end_comment

begin_decl_stmt
specifier|register
name|char
name|table
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to the valid commands */
end_comment

begin_block
block|{
specifier|register
name|index
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|' '
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\0'
operator|)
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|table
index|[
name|index
index|]
operator|!=
literal|'\0'
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|table
index|[
name|index
index|]
operator|==
name|c
condition|)
return|return
operator|(
name|index
operator|)
return|;
if|if
condition|(
name|table
index|[
name|index
index|]
operator|>
name|c
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* end SHLookup */
end_comment

begin_comment
comment|/*  * This routine reads in, looks up, and executes a short command.  */
end_comment

begin_expr_stmt
name|SHCommand
argument_list|(
name|command
argument_list|)
specifier|register
name|char
operator|*
name|command
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|index
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|=
name|SHLookup
argument_list|(
operator|*
name|command
argument_list|,
name|shcmds
argument_list|)
operator|)
operator|==
operator|-
literal|2
condition|)
return|return;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|GRCurrentSetOn
argument_list|()
expr_stmt|;
name|TxMsgOK
argument_list|()
expr_stmt|;
operator|(
operator|*
operator|(
name|shrtns
index|[
name|index
index|]
operator|)
operator|)
operator|(
operator|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"no such command"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHCommand */
end_comment

begin_comment
comment|/*  * Repeat previous command.  */
end_comment

begin_macro
name|SHAgain
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|lasttext
condition|)
name|text_restorebuf
argument_list|()
expr_stmt|;
call|(
modifier|*
name|lastcommand
call|)
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This routine creates and displays a VECTOR element from the  * points previously specified.  */
end_comment

begin_macro
name|SHDrawVector
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|POINT
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|ELT
modifier|*
name|e1
decl_stmt|;
name|POINT
modifier|*
name|plist
decl_stmt|;
name|char
modifier|*
name|txt
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|2
condition|)
block|{
comment|/* not enough points */
name|error
argument_list|(
name|nopnt
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNForget
argument_list|()
expr_stmt|;
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
name|DBClearSet
argument_list|()
expr_stmt|;
name|plist
operator|=
name|PTInit
argument_list|()
expr_stmt|;
name|p1
operator|=
name|POINTLIST
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|p2
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p2
operator|->
name|x
argument_list|,
name|p2
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p2
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
name|txt
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|txt
operator|=
literal|'\0'
expr_stmt|;
name|e1
operator|=
name|DBCreateElt
argument_list|(
name|VECTOR
argument_list|,
name|plist
argument_list|,
name|CBRUSH
argument_list|,
literal|0
argument_list|,
name|txt
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|CP
argument_list|()
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHDrawVector */
end_comment

begin_comment
comment|/*  * This routine creates and displays an ARC element based on the   * points previously defined.  If 3 or more points are defined, the  * extent of the arc is calculated as the angle formed by the   * respective lines through the second and third points and the first  * point.  If only 2 points are specified, a full circle is drawn.  */
end_comment

begin_macro
name|SHDrawArc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|POINT
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|ELT
modifier|*
name|e1
decl_stmt|;
name|POINT
modifier|*
name|plist
decl_stmt|;
name|char
modifier|*
name|txt
decl_stmt|;
name|float
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|angle
decl_stmt|,
name|radius
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|2
condition|)
block|{
comment|/* not enough points */
name|error
argument_list|(
name|nopnt
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNForget
argument_list|()
expr_stmt|;
name|plist
operator|=
name|PTInit
argument_list|()
expr_stmt|;
name|p1
operator|=
name|POINTLIST
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|radius
operator|=
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
operator|(
name|p2
operator|->
name|x
operator|-
name|p1
operator|->
name|x
operator|)
operator|*
operator|(
name|p2
operator|->
name|x
operator|-
name|p1
operator|->
name|x
operator|)
operator|+
operator|(
name|p2
operator|->
name|y
operator|-
name|p1
operator|->
name|y
operator|)
operator|*
operator|(
name|p2
operator|->
name|y
operator|-
name|p1
operator|->
name|y
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|radius
operator|==
literal|0.0
condition|)
block|{
name|error
argument_list|(
literal|"zero radius"
argument_list|)
expr_stmt|;
return|return;
block|}
name|CSP
argument_list|()
expr_stmt|;
if|if
condition|(
name|SEQ
operator|==
literal|2
condition|)
block|{
comment|/* draw full circle */
name|angle
operator|=
literal|0
expr_stmt|;
comment|/* Add extra positioning points  */
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p2
operator|->
name|x
argument_list|,
name|p2
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
operator|+
name|radius
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
operator|-
name|radius
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
operator|+
name|radius
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
operator|-
name|radius
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|POINTLIST
operator|->
name|x
argument_list|,
name|POINTLIST
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|POINTLIST
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|a1
operator|=
name|atan2
argument_list|(
operator|(
name|p1
operator|->
name|x
operator|-
name|POINTLIST
operator|->
name|x
operator|)
argument_list|,
operator|(
name|p1
operator|->
name|y
operator|-
name|POINTLIST
operator|->
name|y
operator|)
argument_list|)
expr_stmt|;
name|a2
operator|=
name|atan2
argument_list|(
operator|(
name|p2
operator|->
name|x
operator|-
name|POINTLIST
operator|->
name|x
operator|)
argument_list|,
operator|(
name|p2
operator|->
name|y
operator|-
name|POINTLIST
operator|->
name|y
operator|)
argument_list|)
expr_stmt|;
name|angle
operator|=
name|a1
operator|-
name|a2
expr_stmt|;
if|if
condition|(
name|angle
operator|<
literal|0.0
condition|)
name|angle
operator|+=
name|twoPi
expr_stmt|;
comment|/* Set second point to lie on arc */
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
operator|(
name|radius
operator|*
name|sin
argument_list|(
name|a2
argument_list|)
operator|+
name|POINTLIST
operator|->
name|x
operator|)
argument_list|,
operator|(
name|radius
operator|*
name|cos
argument_list|(
name|a2
argument_list|)
operator|+
name|POINTLIST
operator|->
name|y
operator|)
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
name|angle
operator|*=
literal|360.0
operator|/
name|twoPi
expr_stmt|;
comment|/* convert to degrees */
block|}
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
name|DBClearSet
argument_list|()
expr_stmt|;
name|txt
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|txt
operator|=
literal|'\0'
expr_stmt|;
name|e1
operator|=
name|DBCreateElt
argument_list|(
name|ARC
argument_list|,
name|plist
argument_list|,
name|CBRUSH
argument_list|,
call|(
name|int
call|)
argument_list|(
name|angle
operator|+
literal|0.5
argument_list|)
argument_list|,
name|txt
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|CP
argument_list|()
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHDrawARc */
end_comment

begin_comment
comment|/*  * Draw curve object.  */
end_comment

begin_macro
name|SHDrawCurve
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|POINT
modifier|*
name|p1
decl_stmt|;
specifier|register
name|ELT
modifier|*
name|e1
decl_stmt|;
name|POINT
modifier|*
name|plist
decl_stmt|;
name|char
modifier|*
name|txt
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"need at least 2 points"
argument_list|)
expr_stmt|;
return|return;
block|}
name|plist
operator|=
name|PTInit
argument_list|()
expr_stmt|;
name|p1
operator|=
name|POINTLIST
expr_stmt|;
do|do
block|{
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|p1
argument_list|)
condition|)
do|;
if|if
condition|(
name|GRSetCurve
argument_list|(
name|plist
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"too many consecutive knots at same place"
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNForget
argument_list|()
expr_stmt|;
name|txt
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|txt
operator|=
literal|'\0'
expr_stmt|;
name|e1
operator|=
name|DBCreateElt
argument_list|(
name|CURVE
argument_list|,
name|plist
argument_list|,
name|CBRUSH
argument_list|,
literal|0
argument_list|,
name|txt
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
name|DBClearSet
argument_list|()
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|CP
argument_list|()
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHDrawCurve */
end_comment

begin_comment
comment|/*  * This routine erases selected elements from the screen and deletes  * them from the picture database.    */
end_comment

begin_macro
name|SHErase
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|ELT
modifier|*
name|e1
decl_stmt|;
if|if
condition|(
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|noset
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNForget
argument_list|()
expr_stmt|;
name|fasterase
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
comment|/* delete elements in current set */
comment|/* 	DISScreenErase(cset, pixmask | csetmask); */
name|e1
operator|=
name|DBNextofSet
argument_list|(
name|cset
argument_list|)
expr_stmt|;
name|DBDelete
argument_list|(
name|cset
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|cset
operator|=
name|e1
expr_stmt|;
block|}
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHErase */
end_comment

begin_comment
comment|/*  * This routine toggles the gravity mode.  */
end_comment

begin_macro
name|SHGravity
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|GravityOn
operator|=
operator|!
name|GravityOn
condition|)
name|MNHighLt
argument_list|(
name|HiMode
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
else|else
name|MNUnHighLt
argument_list|(
name|HiMode
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* End GravityOn */
end_comment

begin_comment
comment|/*  * This routine toggles the display of the grid.  */
end_comment

begin_macro
name|SHGrid
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|Gridon
operator|=
operator|!
name|Gridon
condition|)
name|GRDisplayGrid
argument_list|()
expr_stmt|;
else|else
name|GRBlankGrid
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHGrid */
end_comment

begin_comment
comment|/*  * Manhattan Adjust -  * This routine toggles the adjustment mode.  */
end_comment

begin_macro
name|SHMAdjust
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|Adjustment
operator|==
name|MAN
condition|)
block|{
name|MNUnHighLt
argument_list|(
name|HiMode
index|[
name|adj
index|[
name|MAN
index|]
index|]
argument_list|)
expr_stmt|;
name|Adjustment
operator|=
name|NOADJ
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Adjustment
operator|!=
name|NOADJ
condition|)
name|MNUnHighLt
argument_list|(
name|HiMode
index|[
name|adj
index|[
name|Adjustment
index|]
index|]
argument_list|)
expr_stmt|;
name|MNHighLt
argument_list|(
name|HiMode
index|[
name|adj
index|[
name|MAN
index|]
index|]
argument_list|)
expr_stmt|;
name|Adjustment
operator|=
name|MAN
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end SHMAdjust */
end_comment

begin_comment
comment|/*  * This routine defines the current set based upon previously  * defined points to select elements.  If no points are specified  * the entire picture becomes the current set.  In this case, the  * old current set is not erased (optimization) and any elements  * not in it are added.  Otherwise, the new current set can not be  * guaranteed to contain the old current set, and so it is erased  * and set to empty before adding the new elements.  */
end_comment

begin_macro
name|SHDefineSet
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|SEQ
operator|>
literal|0
condition|)
block|{
comment|/* redefine current set */
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
name|DBClearSet
argument_list|()
expr_stmt|;
block|}
name|CSP
argument_list|()
expr_stmt|;
name|LGIncludeSet
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHDefineSet */
end_comment

begin_comment
comment|/*  * This routine defines the current set by selecting all elements  * bounded by a rectangle whose diagonal is defined by specifed points.  */
end_comment

begin_macro
name|SHSetArea
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|SEQ
operator|<
literal|2
condition|)
block|{
name|error
argument_list|(
name|nopnt
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DBNullelt
argument_list|(
name|PICTURE
argument_list|)
condition|)
return|return;
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
name|DBClearSet
argument_list|()
expr_stmt|;
name|SHMSetArea
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHSetArea */
end_comment

begin_comment
comment|/*  * This routine ADDS to the current set all elements bounded by a   * rectangle whose diagonal is defined by two specifed points.  */
end_comment

begin_macro
name|SHMSetArea
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|ELT
modifier|*
name|e1
decl_stmt|;
name|float
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|2
condition|)
block|{
name|error
argument_list|(
name|nopnt
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DBNullelt
argument_list|(
name|PICTURE
argument_list|)
condition|)
return|return;
name|x1
operator|=
name|POINTLIST
operator|->
name|x
expr_stmt|;
name|y1
operator|=
name|POINTLIST
operator|->
name|y
expr_stmt|;
name|x2
operator|=
name|PTNextPoint
argument_list|(
name|POINTLIST
argument_list|)
operator|->
name|x
expr_stmt|;
name|y2
operator|=
name|PTNextPoint
argument_list|(
name|POINTLIST
argument_list|)
operator|->
name|y
expr_stmt|;
name|e1
operator|=
name|PICTURE
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e1
argument_list|)
condition|)
block|{
if|if
condition|(
name|DBBounded
argument_list|(
name|e1
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|)
condition|)
block|{
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
name|csetmask
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
name|e1
operator|=
name|DBNextElt
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
name|CP
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHMSetArea */
end_comment

begin_comment
comment|/*  * This routine translates the elements in the current set as defined  * by points.  The translation is accomplished by defining a transformation  * matrix and calling DBXform.  */
end_comment

begin_macro
name|SHTranslate
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|ELT
modifier|*
name|e1
decl_stmt|;
specifier|register
name|POINT
modifier|*
name|p1
decl_stmt|;
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|noset
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|SEQ
operator|<
literal|2
condition|)
block|{
comment|/* not enough points */
name|error
argument_list|(
name|nopnt
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNForget
argument_list|()
expr_stmt|;
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|POINTLIST
argument_list|)
expr_stmt|;
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* set up translation matrix */
name|xmat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|p1
operator|->
name|x
operator|-
name|POINTLIST
operator|->
name|x
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|p1
operator|->
name|y
operator|-
name|POINTLIST
operator|->
name|y
expr_stmt|;
name|e1
operator|=
name|cset
expr_stmt|;
name|fasterase
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e1
argument_list|)
condition|)
block|{
comment|/* 	DISScreenErase(e1, pixmask | csetmask); 	*/
name|TxMsgOK
argument_list|()
expr_stmt|;
name|DBXform
argument_list|(
name|e1
argument_list|,
name|xmat
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
name|e1
operator|=
name|DBNextofSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
name|CP
argument_list|()
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHTranslate */
end_comment

begin_comment
comment|/*  * This routine copies the elements in the current set as defined  * by points.  To copy, the current set pointer is cleared so that new  * elements as added by DBCopy can be used to comprise the new current  * set.  A pointer is maintained to the old current set which is traversed  * to determine the elements to be copied.  This process continues for all  * points specified.  *  * NOTE:  This assumes that the DBClearSet routine does not alter the  *        pointers between elements in the set (which is currently true),  *        and must be changed it this does not hold.  */
end_comment

begin_macro
name|SHCopy
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|ELT
modifier|*
name|e1
decl_stmt|,
modifier|*
name|e2
decl_stmt|;
specifier|register
name|POINT
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|noset
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|SEQ
operator|<
literal|2
condition|)
block|{
comment|/* not enough points */
name|error
argument_list|(
name|nopnt
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNForget
argument_list|()
expr_stmt|;
name|p1
operator|=
name|POINTLIST
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|POINTLIST
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* set up translation matrix */
name|xmat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|p2
operator|->
name|x
operator|-
name|p1
operator|->
name|x
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|p2
operator|->
name|y
operator|-
name|p1
operator|->
name|y
expr_stmt|;
name|e1
operator|=
name|cset
expr_stmt|;
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
name|DBClearSet
argument_list|()
expr_stmt|;
comment|/* Dependent on Clearset preserving pointers */
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e1
argument_list|)
condition|)
block|{
name|e2
operator|=
name|DBCopy
argument_list|(
name|e1
argument_list|,
name|xmat
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|e2
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e2
argument_list|)
expr_stmt|;
name|e1
operator|=
name|DBNextofSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
name|p1
operator|=
name|p2
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p2
argument_list|)
expr_stmt|;
block|}
name|CP
argument_list|()
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHCopy */
end_comment

begin_comment
comment|/*  * This routine rotates the elements in the current set as defined  * by points.  The rotation is accomplished by defining a transformation  * matrix and calling DBXform.  */
end_comment

begin_macro
name|SHRotate
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|ELT
modifier|*
name|elt
decl_stmt|;
specifier|register
name|POINT
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|POINT
name|pos
decl_stmt|;
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|,
name|angle
decl_stmt|,
name|s
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|noset
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|SEQ
operator|<
literal|3
condition|)
block|{
comment|/* not enough points */
name|error
argument_list|(
name|nopnt
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNForget
argument_list|()
expr_stmt|;
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|POINTLIST
argument_list|)
expr_stmt|;
comment|/* calculate rotation angle */
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|angle
operator|=
operator|(
name|float
operator|)
name|atan2
argument_list|(
operator|(
name|p2
operator|->
name|x
operator|-
name|POINTLIST
operator|->
name|x
operator|)
argument_list|,
operator|(
name|p2
operator|->
name|y
operator|-
name|POINTLIST
operator|->
name|y
operator|)
argument_list|)
operator|-
operator|(
name|float
operator|)
name|atan2
argument_list|(
operator|(
name|p1
operator|->
name|x
operator|-
name|POINTLIST
operator|->
name|x
operator|)
argument_list|,
operator|(
name|p1
operator|->
name|y
operator|-
name|POINTLIST
operator|->
name|y
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|float
operator|)
name|sin
argument_list|(
name|angle
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|float
operator|)
name|cos
argument_list|(
name|angle
argument_list|)
expr_stmt|;
comment|/* Define transformation matrix to translate set to origin, rotate,       and translate back. */
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|xmat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
operator|-
name|s
expr_stmt|;
name|xmat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
operator|(
operator|-
name|c
operator|)
operator|*
name|POINTLIST
operator|->
name|x
operator|-
name|s
operator|*
name|POINTLIST
operator|->
name|y
operator|+
name|POINTLIST
operator|->
name|x
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
operator|(
operator|-
name|c
operator|)
operator|*
name|POINTLIST
operator|->
name|y
operator|+
name|s
operator|*
name|POINTLIST
operator|->
name|x
operator|+
name|POINTLIST
operator|->
name|y
expr_stmt|;
name|elt
operator|=
name|cset
expr_stmt|;
comment|/* DISClearSetDisplay(); */
name|fasterase
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elt
argument_list|)
condition|)
block|{
comment|/* DISScreenErase(elt, pixmask); */
name|TxMsgOK
argument_list|()
expr_stmt|;
name|DBXform
argument_list|(
name|elt
argument_list|,
name|xmat
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEXT
argument_list|(
name|elt
operator|->
name|type
argument_list|)
condition|)
block|{
name|GRSetTextPos
argument_list|(
name|elt
operator|->
name|textpt
argument_list|,
name|elt
operator|->
name|type
argument_list|,
name|elt
operator|->
name|brushf
argument_list|,
name|elt
operator|->
name|size
argument_list|,
name|elt
operator|->
name|ptlist
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|elt
operator|->
name|ptlist
operator|=
name|PTMakeTextPoints
argument_list|(
name|elt
operator|->
name|textpt
argument_list|,
name|elt
operator|->
name|brushf
argument_list|,
name|elt
operator|->
name|size
argument_list|,
name|elt
operator|->
name|ptlist
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
block|}
name|DISScreenAdd
argument_list|(
name|elt
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
name|elt
operator|=
name|DBNextofSet
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
name|CP
argument_list|()
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHRotate */
end_comment

begin_comment
comment|/*  * This routine scales the elements in the current set as defined  * by points.  The scaling is accomplished by defining a transformation  * matrix and calling DBXform.  */
end_comment

begin_macro
name|SHScale
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|ELT
modifier|*
name|elt
decl_stmt|;
specifier|register
name|POINT
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|POINT
name|pos
decl_stmt|;
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|scalex
decl_stmt|,
name|scaley
decl_stmt|;
if|if
condition|(
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|noset
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|SEQ
operator|<
literal|3
condition|)
block|{
comment|/* not enough points */
name|error
argument_list|(
name|nopnt
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNForget
argument_list|()
expr_stmt|;
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|POINTLIST
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|d1
operator|=
name|sqrt
argument_list|(
name|pow
argument_list|(
operator|(
name|p1
operator|->
name|x
operator|-
name|POINTLIST
operator|->
name|x
operator|)
argument_list|,
literal|2.0
argument_list|)
operator|+
name|pow
argument_list|(
operator|(
name|p1
operator|->
name|y
operator|-
name|POINTLIST
operator|->
name|y
operator|)
argument_list|,
literal|2.0
argument_list|)
argument_list|)
expr_stmt|;
name|d2
operator|=
name|sqrt
argument_list|(
name|pow
argument_list|(
operator|(
name|p2
operator|->
name|x
operator|-
name|POINTLIST
operator|->
name|x
operator|)
argument_list|,
literal|2.0
argument_list|)
operator|+
name|pow
argument_list|(
operator|(
name|p2
operator|->
name|y
operator|-
name|POINTLIST
operator|->
name|y
operator|)
argument_list|,
literal|2.0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d1
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"infinite scale"
argument_list|)
expr_stmt|;
return|return;
block|}
name|scalex
operator|=
name|scaley
operator|=
name|d2
operator|/
name|d1
expr_stmt|;
comment|/* create transformation matrix to translate set to origin,         performaing the scaling and translating back */
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|scalex
expr_stmt|;
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|scaley
expr_stmt|;
name|xmat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
operator|-
name|POINTLIST
operator|->
name|x
operator|*
operator|(
name|scalex
operator|-
literal|1.0
operator|)
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
operator|-
name|POINTLIST
operator|->
name|y
operator|*
operator|(
name|scaley
operator|-
literal|1.0
operator|)
expr_stmt|;
name|elt
operator|=
name|cset
expr_stmt|;
name|fasterase
argument_list|()
expr_stmt|;
comment|/* DISClearSetDisplay(); */
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elt
argument_list|)
condition|)
block|{
comment|/* DISScreenErase(elt, pixmask); */
name|TxMsgOK
argument_list|()
expr_stmt|;
name|DBXform
argument_list|(
name|elt
argument_list|,
name|xmat
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEXT
argument_list|(
name|elt
operator|->
name|type
argument_list|)
condition|)
block|{
name|GRSetTextPos
argument_list|(
name|elt
operator|->
name|textpt
argument_list|,
name|elt
operator|->
name|type
argument_list|,
name|elt
operator|->
name|brushf
argument_list|,
name|elt
operator|->
name|size
argument_list|,
name|elt
operator|->
name|ptlist
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|elt
operator|->
name|ptlist
operator|=
name|PTMakeTextPoints
argument_list|(
name|elt
operator|->
name|textpt
argument_list|,
name|elt
operator|->
name|brushf
argument_list|,
name|elt
operator|->
name|size
argument_list|,
name|elt
operator|->
name|ptlist
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
block|}
name|DISScreenAdd
argument_list|(
name|elt
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
name|elt
operator|=
name|DBNextofSet
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
name|CP
argument_list|()
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHScale */
end_comment

begin_comment
comment|/*  * This routine redraws the graphics screen by clearing the screen ,  * redisplaying the menu and adding each element back to the display.  */
end_comment

begin_macro
name|SHUpdate
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|ELT
modifier|*
name|e1
decl_stmt|;
specifier|register
name|POINT
modifier|*
name|plist
decl_stmt|;
name|POINT
name|pos
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|GRClear
argument_list|(
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|Gridon
condition|)
name|GRDisplayGrid
argument_list|()
expr_stmt|;
name|e1
operator|=
name|PICTURE
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e1
argument_list|)
condition|)
block|{
if|if
condition|(
name|DBInCset
argument_list|(
name|e1
argument_list|)
condition|)
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
else|else
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
name|pixmask
argument_list|)
expr_stmt|;
name|e1
operator|=
name|DBNextElt
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
name|CsetOn
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|plist
operator|=
name|POINTLIST
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|plist
argument_list|)
condition|)
block|{
name|GRDisplayPoint
argument_list|(
name|plist
operator|->
name|x
argument_list|,
name|plist
operator|->
name|y
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|plist
operator|=
name|PTNextPoint
argument_list|(
name|plist
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end SHUpdate */
end_comment

begin_comment
comment|/*  * This local routine stores the current set in the specified  * user symbol.  */
end_comment

begin_expr_stmt
specifier|static
name|savemen
argument_list|(
name|sym
argument_list|)
specifier|register
name|sym
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|ELT
modifier|*
name|elt
decl_stmt|;
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|;
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* set up copy transformation */
name|xmat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|xmat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* matrix for no transformation */
name|xmat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|MEN
index|[
name|sym
index|]
argument_list|)
condition|)
block|{
comment|/* clear out existing symbols */
name|elt
operator|=
name|DBNextElt
argument_list|(
name|MEN
index|[
name|sym
index|]
argument_list|)
expr_stmt|;
name|DBClearElt
argument_list|(
name|MEN
index|[
name|sym
index|]
argument_list|)
expr_stmt|;
name|MEN
index|[
name|sym
index|]
operator|=
name|elt
expr_stmt|;
block|}
name|elt
operator|=
name|cset
expr_stmt|;
comment|/* copy current set to symbol */
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elt
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|DBCopy
argument_list|(
name|elt
argument_list|,
name|xmat
argument_list|,
operator|&
operator|(
name|MEN
index|[
name|sym
index|]
operator|)
argument_list|)
expr_stmt|;
name|elt
operator|=
name|DBNextofSet
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SEQ
operator|==
literal|0
condition|)
block|{
comment|/* no positioning points */
name|MENPOINT
index|[
name|sym
index|]
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|MENPOINT
index|[
name|sym
index|]
operator|.
name|y
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|MENPOINT
index|[
name|sym
index|]
operator|.
name|x
operator|=
name|POINTLIST
operator|->
name|x
expr_stmt|;
name|MENPOINT
index|[
name|sym
index|]
operator|.
name|y
operator|=
name|POINTLIST
operator|->
name|y
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DBNullelt
argument_list|(
name|MEN
index|[
name|sym
index|]
argument_list|)
condition|)
name|MNHighLt
argument_list|(
name|HiBuffer
index|[
name|sym
index|]
argument_list|)
expr_stmt|;
else|else
name|MNUnHighLt
argument_list|(
name|HiBuffer
index|[
name|sym
index|]
argument_list|)
expr_stmt|;
name|CP
argument_list|()
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end savemen */
end_comment

begin_comment
comment|/*  * This routine saves the current set in user symbol 1 by  * calling savemen.  */
end_comment

begin_macro
name|SHSave1
argument_list|()
end_macro

begin_block
block|{
name|savemen
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This routine saves the current set in user symbol 2 by  * calling savemen.  */
end_comment

begin_macro
name|SHSave2
argument_list|()
end_macro

begin_block
block|{
name|savemen
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This routine saves the current set in user symbol 3 by  * calling savemen.  */
end_comment

begin_macro
name|SHSave3
argument_list|()
end_macro

begin_block
block|{
name|savemen
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This routine saves the current set in user symbol 4 by  * calling savemen.  */
end_comment

begin_macro
name|SHSave4
argument_list|()
end_macro

begin_block
block|{
name|savemen
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This routine creates and displays a rectangle whose diagonal is  * defined by two points.  The routine uses the coordinates of these  * points to define a VECTOR element with the appropriate vertices.  */
end_comment

begin_macro
name|SHBox
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|POINT
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|ELT
modifier|*
name|e1
decl_stmt|;
name|POINT
modifier|*
name|plist
decl_stmt|;
name|char
modifier|*
name|txt
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"not enough points"
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNForget
argument_list|()
expr_stmt|;
name|p1
operator|=
name|POINTLIST
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|plist
operator|=
name|PTInit
argument_list|()
expr_stmt|;
comment|/* create points for vector elements which define  			   the rectangle */
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p2
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p2
operator|->
name|x
argument_list|,
name|p2
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p2
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
comment|/* close rectangle */
name|txt
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|txt
operator|=
literal|'\0'
expr_stmt|;
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
name|DBClearSet
argument_list|()
expr_stmt|;
name|e1
operator|=
name|DBCreateElt
argument_list|(
name|VECTOR
argument_list|,
name|plist
argument_list|,
name|CBRUSH
argument_list|,
literal|0
argument_list|,
name|txt
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|CP
argument_list|()
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHBox */
end_comment

begin_comment
comment|/*  * This routine draws arrow heads by 'copying' the arrow head template  * into the picture appropriately transformed.  */
end_comment

begin_macro
name|SHArrow
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|ELT
modifier|*
name|e1
decl_stmt|;
name|POINT
name|p1
decl_stmt|;
specifier|register
name|POINT
modifier|*
name|p2
decl_stmt|;
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|,
name|angle
decl_stmt|,
name|s
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|2
condition|)
block|{
comment|/* not enough points */
name|error
argument_list|(
name|nopnt
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNForget
argument_list|()
expr_stmt|;
name|p1
operator|.
name|x
operator|=
name|POINTLIST
operator|->
name|x
operator|-
literal|1
expr_stmt|;
name|p1
operator|.
name|y
operator|=
name|POINTLIST
operator|->
name|y
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|POINTLIST
argument_list|)
expr_stmt|;
name|angle
operator|=
operator|(
name|float
operator|)
name|atan2
argument_list|(
operator|(
name|p2
operator|->
name|x
operator|-
name|POINTLIST
operator|->
name|x
operator|)
argument_list|,
operator|(
name|p2
operator|->
name|y
operator|-
name|POINTLIST
operator|->
name|y
operator|)
argument_list|)
operator|-
operator|(
name|float
operator|)
name|atan2
argument_list|(
operator|(
name|p1
operator|.
name|x
operator|-
name|POINTLIST
operator|->
name|x
operator|)
argument_list|,
operator|(
name|p1
operator|.
name|y
operator|-
name|POINTLIST
operator|->
name|y
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|float
operator|)
name|sin
argument_list|(
name|angle
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|float
operator|)
name|cos
argument_list|(
name|angle
argument_list|)
expr_stmt|;
comment|/* Define transformation matrix to translate element from origin       and rotate. */
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|xmat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
operator|-
name|s
expr_stmt|;
name|xmat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|POINTLIST
operator|->
name|x
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|POINTLIST
operator|->
name|y
expr_stmt|;
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
comment|/* the new current set */
name|DBClearSet
argument_list|()
expr_stmt|;
comment|/* clear old set in preparation to make */
name|arhead
operator|.
name|brushf
operator|=
name|CBRUSH
expr_stmt|;
name|e1
operator|=
name|DBCopy
argument_list|(
operator|&
name|arhead
argument_list|,
name|xmat
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
name|pixmask
operator||
name|csetmask
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|CP
argument_list|()
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SHArrow */
end_comment

begin_comment
comment|/*  * Turn off any "showpoints" and erase the current set by XORing  * the cset pixrect with the picture.  ONLY to be used when the  * current set will be redrawn immediately afterwards.  */
end_comment

begin_macro
name|fasterase
argument_list|()
end_macro

begin_block
block|{
name|CSP
argument_list|()
expr_stmt|;
comment|/* clear show points */
name|GRCurrentSetOff
argument_list|()
expr_stmt|;
comment|/* erase current set */
name|CsetOn
operator|=
literal|1
expr_stmt|;
comment|/* ON, the current must be redrawn */
name|GRClear
argument_list|(
name|csetmask
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

