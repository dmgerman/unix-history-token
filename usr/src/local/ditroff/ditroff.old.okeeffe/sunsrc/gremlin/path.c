begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * @(#)path.c	1.1	%G%  *  * These routines implement a path mechanism for the SUN Gremlin  * picture editor.  It provides facilities whereby several directories  * may be searched for files and a defaulting mechanism for file name  * extensions.  *  * Mark Opperman (opcode@monet.BERKELEY)  *  */
end_comment

begin_include
include|#
directive|include
file|"gremlin.h"
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* imports from main.c */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|GLibrary
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* imports from C */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strncpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|sprintf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*   * The following string holds the current path, consisting of a bunch  * of directory names separated by spaces.  */
end_comment

begin_define
define|#
directive|define
name|PATHSIZE
value|400
end_define

begin_decl_stmt
specifier|static
name|char
name|path
index|[
name|PATHSIZE
index|]
init|=
literal|"."
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * The following string pointers constitute a cache of recently  * referenced tilde names.  */
end_comment

begin_define
define|#
directive|define
name|NTILDE
value|10
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tildename
index|[
name|NTILDE
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|realname
index|[
name|NTILDE
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|discard
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This routine converts tilde notation into standard directory names.  *  * If the conversion was done successfully, then TRUE is returned.  * If a user name couldn't be found in the password file, then  * FALSE is returned.  *  * If the first character of the string indicated by psource is a  * tilde ("~") then the subsequent user name is converted to a login  * directory name and stored in the string indicated by pdest.  Then  * remaining characters in the file name at psource are copied to  * pdest and both pointers are updated.  Upon return, psource points  * to the terminating character in the source file name and pdest  * points to the next character after the last character in the file  * name at that location.  If a tilde cannot be converted because the  * user name cannot be found, psource is still advanced past the current  * entry, but pdest is unaffected.  At most size characters will be  * stored at pdest, and the size is decremented by the number of  * characters we actually stored.  *  * mro 7/28/84   * fixed NULL pointer bugs  */
end_comment

begin_macro
name|PConvertTilde
argument_list|(
argument|psource
argument_list|,
argument|pdest
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|psource
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to a pointer to the source string */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|pdest
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to a pointer to the dest. string */
end_comment

begin_decl_stmt
name|int
modifier|*
name|size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to no. bytes available at pdest */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|ps
decl_stmt|,
modifier|*
name|pd
decl_stmt|;
name|struct
name|passwd
modifier|*
name|passwd
decl_stmt|,
modifier|*
name|getpwnam
argument_list|()
decl_stmt|;
name|char
name|username
index|[
literal|17
index|]
decl_stmt|,
modifier|*
name|string
decl_stmt|;
name|int
name|i
decl_stmt|,
name|length
decl_stmt|;
name|ps
operator|=
operator|*
name|psource
expr_stmt|;
name|string
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|ps
operator|==
literal|'~'
condition|)
block|{
comment|/* Copy the user name into a string (at most 16 characters).  If we  	   don't have a cached entry for this name, then read the password  	   file entry for the user and grab out the login directory. */
name|pd
operator|=
name|username
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|pd
operator|=
operator|*
operator|++
name|ps
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|pd
argument_list|)
operator|||
operator|(
operator|*
name|pd
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|pd
operator|==
literal|'/'
operator|)
operator|||
operator|(
operator|*
name|pd
operator|==
literal|':'
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|16
condition|)
name|pd
operator|++
expr_stmt|;
block|}
operator|*
name|pd
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTILDE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tildename
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tildename
index|[
name|i
index|]
argument_list|,
name|username
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string
operator|=
name|realname
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
block|{
comment|/* didn't find cached entry */
name|passwd
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
comment|/* check password file */
if|if
condition|(
name|passwd
operator|!=
name|NULL
condition|)
block|{
comment|/* got it! */
name|string
operator|=
name|passwd
operator|->
name|pw_dir
expr_stmt|;
if|if
condition|(
operator|++
name|discard
operator|>=
name|NTILDE
condition|)
name|discard
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tildename
index|[
name|discard
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tildename
index|[
name|discard
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|realname
index|[
name|discard
index|]
argument_list|)
expr_stmt|;
block|}
name|tildename
index|[
name|discard
index|]
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|username
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tildename
index|[
name|discard
index|]
argument_list|,
name|username
argument_list|)
expr_stmt|;
name|realname
index|[
name|discard
index|]
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|realname
index|[
name|discard
index|]
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* illegal user name */
comment|/* skip the source entry and return */
while|while
condition|(
operator|(
operator|*
name|ps
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|ps
argument_list|)
operator|&&
operator|(
operator|*
name|ps
operator|!=
literal|':'
operator|)
condition|)
name|ps
operator|++
expr_stmt|;
operator|*
name|psource
operator|=
name|ps
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
name|length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
operator|*
name|size
condition|)
name|length
operator|=
operator|*
name|size
expr_stmt|;
name|strncpy
argument_list|(
operator|*
name|pdest
argument_list|,
name|string
argument_list|,
name|length
argument_list|)
expr_stmt|;
operator|*
name|size
operator|-=
name|length
expr_stmt|;
name|pd
operator|=
operator|*
name|pdest
operator|+
name|length
expr_stmt|;
block|}
else|else
name|pd
operator|=
operator|*
name|pdest
expr_stmt|;
comment|/* Copy the rest of the directory name from the source to the dest. */
while|while
condition|(
operator|(
operator|*
name|ps
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|ps
argument_list|)
operator|&&
operator|(
operator|*
name|ps
operator|!=
literal|':'
operator|)
condition|)
if|if
condition|(
operator|*
name|size
operator|>
literal|0
condition|)
block|{
operator|*
name|pd
operator|++
operator|=
operator|*
name|ps
operator|++
expr_stmt|;
operator|(
operator|*
name|size
operator|)
operator|--
expr_stmt|;
block|}
else|else
name|ps
operator|++
expr_stmt|;
operator|*
name|psource
operator|=
name|ps
expr_stmt|;
operator|*
name|pdest
operator|=
name|pd
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * PSetPath sets up the current search path.  *  * (-1) is returned if one or more of the paths contained a tilde  * notation that couldn't be converted.  (-2) is returned if the  * path space was exhausted.  Otherwise, a value>= 0 is returned.  *  * The string is stored as the current path, and all entries with  * tilde notation are converted to non-tilde notation.  Tilde entries  * that cannot be converted are ignored.  Note:  only PATHSIZE total  * bytes of path are stored, after tilde conversion.  Excess bytes  * are truncated.  */
end_comment

begin_macro
name|PSetPath
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to a string that is to become the new file  		   search path.  Must consist of one or more directory  		   names separated by white space or colons.  Two adjacent  		   colons are the same as ":.:".  Tilde notation is ok.  */
end_comment

begin_block
block|{
name|int
name|result
decl_stmt|,
name|spaceleft
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|spaceleft
operator|=
name|PATHSIZE
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|path
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'\0'
condition|)
block|{
name|strcpy
argument_list|(
name|path
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
operator|*
name|string
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|string
operator|==
literal|':'
condition|)
if|if
condition|(
operator|(
operator|*
operator|++
name|string
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|spaceleft
operator|>=
literal|2
operator|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|spaceleft
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|spaceleft
operator|<=
literal|0
condition|)
break|break;
while|while
condition|(
operator|(
operator|*
name|string
operator|==
literal|':'
operator|)
operator|||
name|isspace
argument_list|(
operator|*
name|string
argument_list|)
condition|)
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|PConvertTilde
argument_list|(
operator|&
name|string
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|spaceleft
argument_list|)
condition|)
name|result
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|spaceleft
operator|--
operator|>
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|spaceleft
operator|<
literal|2
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  This routine merely returns a poiner to the current path.  */
end_comment

begin_function
name|char
modifier|*
name|PGetPath
parameter_list|()
block|{
return|return
operator|(
name|path
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  This routine does a file lookup using the current path and  *  supplying a default extension.  *  *  Returns a pointer to a FILE, or NULL if the file couldn't be found.  *  *  If the first character of the  *  file name is "~" or "/" or if search is FALSE, then we try  *  to look up the file with the original name, doing tilde  *  expansion of course and returning that result.  If none of   *  these conditions is met, we go through the current path  *  trying to look up the file once for each path  *  entry by prepending the path entry to the original file name.  *  This concatenated name is stored in a static string and made  *  available to the caller through prealname if the open succeeds.  *  Note: the static string will be trashed on the next call to this  *  routine.  Also, note that no individual file name is allowed to  *  be more than NAMESIZE characters long.  Excess characters are lost.  */
end_comment

begin_function
name|FILE
modifier|*
name|POpen
parameter_list|(
name|file
parameter_list|,
name|prealname
parameter_list|,
name|search
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
comment|/* Name of the file to be opened. */
name|char
modifier|*
modifier|*
name|prealname
decl_stmt|;
comment|/* Pointer to a location that will be filled 				   in with the address of the real name of 				   the file that was successfully opened. 				   If NULL, then nothing is stored.  */
name|int
name|search
decl_stmt|;
comment|/* If FALSE, then the search path business 				   doesn't happen.  A default extension 				   will still be added.  */
block|{
define|#
directive|define
name|NAMESIZE
value|128
specifier|static
name|char
name|realname
index|[
name|NAMESIZE
index|]
decl_stmt|;
name|char
name|extendedname
index|[
name|NAMESIZE
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|int
name|length
decl_stmt|,
name|spaceleft
decl_stmt|,
name|size
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
operator|(
name|file
operator|==
name|NULL
operator|)
operator|||
operator|(
name|file
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
operator|(
operator|(
name|FILE
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
name|prealname
operator|!=
name|NULL
condition|)
operator|*
name|prealname
operator|=
name|realname
expr_stmt|;
comment|/* Now try the original name.  If it starts with a ~ or / look         it up directly.  */
if|if
condition|(
name|file
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
block|{
name|p
operator|=
name|realname
expr_stmt|;
name|length
operator|=
name|NAMESIZE
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|PConvertTilde
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|length
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|fopen
argument_list|(
name|realname
argument_list|,
literal|"r"
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|file
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
operator|||
operator|(
name|search
operator|==
name|FALSE
operator|)
condition|)
block|{
name|strncpy
argument_list|(
name|realname
argument_list|,
name|file
argument_list|,
name|NAMESIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|realname
index|[
name|NAMESIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|fopen
argument_list|(
name|realname
argument_list|,
literal|"r"
argument_list|)
operator|)
return|;
block|}
comment|/* Now try going through the path. */
name|p
operator|=
name|path
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|spaceleft
operator|=
name|NAMESIZE
operator|-
literal|1
expr_stmt|;
name|p2
operator|=
name|realname
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|spaceleft
operator|--
operator|>
literal|0
condition|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|spaceleft
operator|--
operator|>
literal|0
condition|)
operator|*
name|p2
operator|++
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|spaceleft
operator|>
literal|0
condition|)
name|strncpy
argument_list|(
name|p2
argument_list|,
name|file
argument_list|,
name|spaceleft
argument_list|)
expr_stmt|;
name|realname
index|[
name|NAMESIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|realname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
comment|/* if file in current directory fix up prealname */
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|realname
argument_list|,
literal|"./"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|prealname
operator|!=
name|NULL
operator|)
condition|)
operator|(
operator|*
name|prealname
operator|)
operator|+=
literal|2
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
block|}
comment|/* We've tried the path and that didn't work.  As a last shot,        try the library area.  Only use the library for reads.  */
name|p
operator|=
name|GLibrary
expr_stmt|;
name|p2
operator|=
name|realname
expr_stmt|;
name|size
operator|=
name|NAMESIZE
expr_stmt|;
if|if
condition|(
operator|!
name|PConvertTilde
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|p2
argument_list|,
operator|&
name|size
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|p2
argument_list|,
name|file
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|realname
index|[
name|NAMESIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|fopen
argument_list|(
name|realname
argument_list|,
literal|"r"
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

