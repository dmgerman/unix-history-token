begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * @(#)text.c	1.2	%G%  *  * Text subwindow routines for the SUN Gremlin picture editor.  *  * Mark Opperman (opcode@monet.BERKELEY)  *  */
end_comment

begin_include
include|#
directive|include
file|<suntool/tool_hs.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|"gremlin.h"
end_include

begin_include
include|#
directive|include
file|"icondata.h"
end_include

begin_comment
comment|/* imports from main.c */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|pixwin
modifier|*
name|text_pw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|rect
name|text_size
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern TOOLINSTALLED;
end_extern

begin_function_decl
specifier|extern
function_decl|(
modifier|*
name|lastcommand
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_extern
extern|extern lasttext;
end_extern

begin_comment
comment|/* imports from long.c */
end_comment

begin_extern
extern|extern LGTextSW(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from graphics.c */
end_comment

begin_extern
extern|extern GRCurrentSetOn(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from help.c */
end_comment

begin_extern
extern|extern textsw_help(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern get_any_button(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* locals */
end_comment

begin_decl_stmt
name|struct
name|pixfont
modifier|*
name|text_pf
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TEXT_LEFT
value|96
end_define

begin_comment
comment|/* start of text input */
end_comment

begin_define
define|#
directive|define
name|TEXT_FIRST
value|' '
end_define

begin_define
define|#
directive|define
name|TEXT_LAST
value|'~'
end_define

begin_define
define|#
directive|define
name|CTRL_W
value|'\027'
end_define

begin_define
define|#
directive|define
name|RETURN
value|'\r'
end_define

begin_define
define|#
directive|define
name|MSGLINE
value|17
end_define

begin_define
define|#
directive|define
name|text_width
value|(text_pf->pf_defaultsize.x)
end_define

begin_define
define|#
directive|define
name|text_height
value|(text_pf->pf_defaultsize.y)
end_define

begin_decl_stmt
specifier|static
name|char
name|text_buf
index|[
name|TEXT_BUFMAX
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|mesg_buf
index|[
name|TEXT_BUFMAX
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|save_buf
index|[
name|TEXT_BUFMAX
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|text_erase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|text_kill
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|text_erase_word
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|text_length
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|mesg_length
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* length of last message displayed */
end_comment

begin_expr_stmt
specifier|static
name|putmsg
operator|=
name|FALSE
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* TRUE if TxPutMsg called since last button input. */
end_comment

begin_function
name|void
name|text_cursor
parameter_list|(
name|op
parameter_list|)
name|int
name|op
decl_stmt|;
block|{
name|pw_write
argument_list|(
name|text_pw
argument_list|,
name|TEXT_LEFT
operator|+
name|text_length
operator|*
name|text_width
argument_list|,
literal|0
argument_list|,
name|text_width
argument_list|,
name|text_height
argument_list|,
name|op
argument_list|,
operator|&
name|bigblack_pr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|text_output
argument_list|(
name|c
argument_list|)
decl|register
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|count
expr_stmt|;
name|TxMsgOK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
name|TEXT_FIRST
operator|)
operator|&&
operator|(
name|c
operator|<=
name|TEXT_LAST
operator|)
operator|&&
operator|(
name|text_length
operator|<
name|TEXT_BUFMAX
operator|-
literal|1
operator|)
condition|)
block|{
name|text_buf
index|[
name|text_length
index|]
operator|=
name|c
expr_stmt|;
name|text_buf
index|[
name|text_length
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pw_char
argument_list|(
name|text_pw
argument_list|,
name|TEXT_LEFT
operator|+
name|text_length
operator|*
name|text_width
argument_list|,
name|TEXT_BASELINE
argument_list|,
name|PIX_SRC
argument_list|,
name|text_pf
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|text_length
operator|++
expr_stmt|;
name|text_cursor
argument_list|(
name|PIX_SRC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
name|text_erase
operator|)
operator|&&
operator|(
name|text_length
operator|>
literal|0
operator|)
condition|)
block|{
name|text_cursor
argument_list|(
name|PIX_NOT
argument_list|(
name|PIX_SRC
argument_list|)
argument_list|)
expr_stmt|;
name|text_length
operator|--
expr_stmt|;
name|pw_char
argument_list|(
name|text_pw
argument_list|,
name|TEXT_LEFT
operator|+
name|text_length
operator|*
name|text_width
argument_list|,
name|TEXT_BASELINE
argument_list|,
name|PIX_SRC
operator|^
name|PIX_DST
argument_list|,
name|text_pf
argument_list|,
name|text_buf
index|[
name|text_length
index|]
argument_list|)
expr_stmt|;
name|text_buf
index|[
name|text_length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|text_cursor
argument_list|(
name|PIX_SRC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|text_kill
condition|)
block|{
name|TxKillLine
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
name|text_erase_word
operator|)
operator|&&
operator|(
name|text_length
operator|>
literal|0
operator|)
condition|)
block|{
name|text_cursor
argument_list|(
name|PIX_NOT
argument_list|(
name|PIX_SRC
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|text_length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|text_buf
index|[
name|text_length
operator|-
literal|1
index|]
operator|==
literal|' '
operator|)
condition|)
block|{
name|text_length
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|text_length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|text_buf
index|[
name|text_length
operator|-
literal|1
index|]
operator|!=
literal|' '
operator|)
condition|)
block|{
name|text_length
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|text_buf
index|[
name|text_length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pw_replrop
argument_list|(
name|text_pw
argument_list|,
name|TEXT_LEFT
operator|+
name|text_length
operator|*
name|text_width
argument_list|,
literal|0
argument_list|,
name|count
operator|*
name|text_width
argument_list|,
name|text_height
argument_list|,
name|PIX_NOT
argument_list|(
name|PIX_SRC
argument_list|)
argument_list|,
operator|&
name|bigblack_pr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|text_cursor
argument_list|(
name|PIX_SRC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|RETURN
condition|)
block|{
comment|/* new text entry method */
name|lastcommand
operator|=
name|LGTextSW
expr_stmt|;
name|lasttext
operator|=
name|TRUE
expr_stmt|;
name|LGTextSW
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|text_getvalue
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|text_buf
index|[
name|i
index|]
operator|==
literal|' '
condition|)
name|i
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|save_buf
argument_list|,
operator|&
name|text_buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|s
argument_list|,
operator|&
name|text_buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|text_putvalue
argument_list|()
end_macro

begin_block
block|{
name|pw_text
argument_list|(
name|text_pw
argument_list|,
literal|2
argument_list|,
name|TEXT_BASELINE
argument_list|,
name|PIX_SRC
argument_list|,
name|text_pf
argument_list|,
literal|"text input:"
argument_list|)
expr_stmt|;
name|pw_text
argument_list|(
name|text_pw
argument_list|,
name|TEXT_LEFT
argument_list|,
name|TEXT_BASELINE
argument_list|,
name|PIX_SRC
argument_list|,
name|text_pf
argument_list|,
name|text_buf
argument_list|)
expr_stmt|;
name|text_cursor
argument_list|(
name|PIX_SRC
argument_list|)
expr_stmt|;
name|pw_text
argument_list|(
name|text_pw
argument_list|,
literal|0
argument_list|,
name|MSGLINE
operator|+
name|TEXT_BASELINE
argument_list|,
name|PIX_NOT
argument_list|(
name|PIX_SRC
argument_list|)
argument_list|,
name|text_pf
argument_list|,
name|mesg_buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|text_restorebuf
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|TxKillLine
argument_list|()
expr_stmt|;
name|s
operator|=
name|save_buf
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|text_output
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|text_left
argument_list|(
name|ie
argument_list|)
specifier|register
expr|struct
name|inputevent
operator|*
name|ie
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|TxMsgOK
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|text_middle
argument_list|(
name|ie
argument_list|)
specifier|register
expr|struct
name|inputevent
operator|*
name|ie
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|TxMsgOK
argument_list|()
expr_stmt|;
name|text_restorebuf
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|text_right
argument_list|(
name|ie
argument_list|)
specifier|register
expr|struct
name|inputevent
operator|*
name|ie
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|TxMsgOK
argument_list|()
expr_stmt|;
name|textsw_help
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|text_winexit
argument_list|(
name|ie
argument_list|)
specifier|register
expr|struct
name|inputevent
operator|*
name|ie
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* check for leaving tool */
if|if
condition|(
operator|(
name|ie
operator|->
name|ie_locy
operator|<
literal|0
operator|)
operator|||
operator|(
name|ie
operator|->
name|ie_locx
operator|<
literal|0
operator|)
operator|||
operator|(
name|ie
operator|->
name|ie_locx
operator|>=
name|text_size
operator|.
name|r_width
operator|)
condition|)
name|GRCurrentSetOn
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|TxInit
argument_list|()
end_macro

begin_block
block|{
name|struct
name|sgttyb
name|sgtty_buf
decl_stmt|;
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|sgtty_buf
argument_list|)
expr_stmt|;
name|text_erase
operator|=
name|sgtty_buf
operator|.
name|sg_erase
expr_stmt|;
name|text_kill
operator|=
name|sgtty_buf
operator|.
name|sg_kill
expr_stmt|;
name|text_erase_word
operator|=
name|CTRL_W
expr_stmt|;
name|text_length
operator|=
name|mesg_length
operator|=
literal|0
expr_stmt|;
name|text_buf
index|[
literal|0
index|]
operator|=
name|mesg_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|text_pf
operator|=
name|pf_open
argument_list|(
literal|"/usr/suntool/fixedwidthfonts/gacha.r.7"
argument_list|)
expr_stmt|;
if|if
condition|(
name|text_pf
operator|==
operator|(
expr|struct
name|pixfont
operator|*
operator|)
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"TxInit: error opening text_pf font file\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end TxInit */
end_comment

begin_comment
comment|/*  * This routine marks it OK to output messages again  * just as if a button had been pressed.  */
end_comment

begin_macro
name|TxMsgOK
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|putmsg
condition|)
block|{
comment|/* message on the screen to be blanked */
name|TxClearMsg
argument_list|()
expr_stmt|;
block|}
name|putmsg
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end TxMsgOK */
end_comment

begin_comment
comment|/*  * Output a one line message into the text subwindow.  * If the message follows another without intervening user input,  * the prompt "More" is output and we wait for a button input event  * before displaying the new message.  */
end_comment

begin_expr_stmt
name|TxPutMsg
argument_list|(
name|msg
argument_list|)
specifier|register
name|char
operator|*
name|msg
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|TOOLINSTALLED
condition|)
block|{
comment|/* tool not displayed yet */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|putmsg
condition|)
block|{
name|pw_text
argument_list|(
name|text_pw
argument_list|,
name|mesg_length
operator|*
name|text_width
argument_list|,
name|MSGLINE
operator|+
name|TEXT_BASELINE
argument_list|,
name|PIX_SRC
argument_list|,
name|text_pf
argument_list|,
literal|" --More--"
argument_list|)
expr_stmt|;
name|get_any_button
argument_list|()
expr_stmt|;
name|TxClearMsg
argument_list|()
expr_stmt|;
block|}
name|pw_text
argument_list|(
name|text_pw
argument_list|,
literal|0
argument_list|,
name|MSGLINE
operator|+
name|TEXT_BASELINE
argument_list|,
name|PIX_NOT
argument_list|(
name|PIX_SRC
argument_list|)
argument_list|,
name|text_pf
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|putmsg
operator|=
name|TRUE
expr_stmt|;
name|mesg_length
operator|=
name|strlen
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|mesg_buf
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end TxPutMsg */
end_comment

begin_comment
comment|/*  * Clear current message.  */
end_comment

begin_macro
name|TxClearMsg
argument_list|()
end_macro

begin_block
block|{
name|pw_replrop
argument_list|(
name|text_pw
argument_list|,
literal|0
argument_list|,
name|MSGLINE
argument_list|,
literal|2000
argument_list|,
name|text_height
argument_list|,
name|PIX_NOT
argument_list|(
name|PIX_SRC
argument_list|)
argument_list|,
operator|&
name|bigblack_pr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mesg_length
operator|=
literal|0
expr_stmt|;
name|mesg_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Consume user text parameter - don't touch message area.  */
end_comment

begin_macro
name|TxKillLine
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|text_length
operator|>
literal|0
condition|)
block|{
name|pw_replrop
argument_list|(
name|text_pw
argument_list|,
name|TEXT_LEFT
argument_list|,
literal|0
argument_list|,
literal|2000
argument_list|,
name|text_height
argument_list|,
name|PIX_NOT
argument_list|(
name|PIX_SRC
argument_list|)
argument_list|,
operator|&
name|bigblack_pr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|text_length
operator|=
literal|0
expr_stmt|;
name|text_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|text_cursor
argument_list|(
name|PIX_SRC
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

