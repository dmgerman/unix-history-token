begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dver.c	1.5	83/07/08  *  * Versatec driver for the new troff  *  * Authors:	BWK(BELL)  *		VCAT(berkley)  *		Richard L. Hyde, Perdue University  *		and David Slattengren, Berkeley  */
end_comment

begin_comment
comment|/*******************************************************************************      output language from troff:     all numbers are character strings  #..\n	comment sn	size in points fn	font as number from 1 to n cx	ascii character x Cxyz	funny char \(xyz. terminated by white space Hn	go to absolute horizontal position n Vn	go to absolute vertical position n (down is positive) hn	go n units horizontally (relative) vn	ditto vertically nnc	move right nn, then print c (exactly 2 digits!) 		(this wart is an optimization that shrinks output file size 		 about 35% and run-time about 15% while preserving ascii-ness) p	new page begins -- set v to 0 nb a	end of line (information only -- no action needed) 	b = space before line, a = after w	paddable word space -- no action needed  Dt ..\n	draw operation 't': 	Dl x y		line from here by x,y 	Dc d		circle of diameter d with left side here 	De x y		ellipse of axes x,y with left side here 	Da x y r	arc counter-clockwise by x,y of radius r 	D~ x y x y ...	B-spline curve by x,y then x,y ...  x ..\n	device control functions:      x i	init      x T s	name of device is s      x r n h v	resolution is n/inch h = min horizontal motion, v = min vert      x p	pause (can restart)      x s	stop -- done for ever      x t	generate trailer      x f n s	font position n contains font s      x H n	set character height to n      x S n	set slant to N  	Subcommands like "i" are often spelled out like "init".  *******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/vcmd.h>
end_include

begin_include
include|#
directive|include
file|"dev.h"
end_include

begin_define
define|#
directive|define
name|DEBUGABLE
end_define

begin_comment
comment|/* Yes, debugable... */
end_comment

begin_define
define|#
directive|define
name|NFONTS
value|25
end_define

begin_comment
comment|/* total number of fonts useable */
end_comment

begin_define
define|#
directive|define
name|MAXSTATE
value|6
end_define

begin_comment
comment|/* number of environments rememberable */
end_comment

begin_define
define|#
directive|define
name|OPENREAD
value|0
end_define

begin_comment
comment|/* mode for openning files */
end_comment

begin_define
define|#
directive|define
name|RESTART
value|1
end_define

begin_comment
comment|/* upon exit, return either RESTART */
end_comment

begin_define
define|#
directive|define
name|ABORT
value|2
end_define

begin_comment
comment|/*     or ABORT */
end_comment

begin_define
define|#
directive|define
name|FATAL
value|1
end_define

begin_comment
comment|/* type of error */
end_comment

begin_define
define|#
directive|define
name|BMASK
value|0377
end_define

begin_comment
comment|/* byte grabber */
end_comment

begin_define
define|#
directive|define
name|FONTDIR
value|"/usr/lib/font"
end_define

begin_comment
comment|/* default place to look for fonts */
end_comment

begin_define
define|#
directive|define
name|MAXWRIT
value|4096
end_define

begin_comment
comment|/* max characters allowed to write at once */
end_comment

begin_define
define|#
directive|define
name|hmot
parameter_list|(
name|n
parameter_list|)
value|hpos += n
end_define

begin_define
define|#
directive|define
name|hgoto
parameter_list|(
name|n
parameter_list|)
value|hpos = n
end_define

begin_define
define|#
directive|define
name|vmot
parameter_list|(
name|n
parameter_list|)
value|vgoto(vpos + n)
end_define

begin_decl_stmt
name|char
name|SccsId
index|[]
init|=
literal|"dver.c	1.5	83/07/08"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|output
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* do we do output at all? */
end_comment

begin_decl_stmt
name|int
name|nolist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output page list if> 0 */
end_comment

begin_decl_stmt
name|int
name|olist
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pairs of page numbers */
end_comment

begin_decl_stmt
name|int
name|spage
init|=
literal|9999
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stop every spage pages */
end_comment

begin_decl_stmt
name|int
name|scount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dev
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|font
modifier|*
name|fontbase
index|[
name|NFONTS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|pstab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* point size table pointer */
end_comment

begin_decl_stmt
name|int
name|res
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input was computed according to this resolution */
end_comment

begin_decl_stmt
name|int
name|nsizes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of sizes device is capable of printing */
end_comment

begin_decl_stmt
name|int
name|nfonts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of fonts device is capable of printing */
end_comment

begin_decl_stmt
name|int
name|smnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of first special font */
end_comment

begin_decl_stmt
name|int
name|nchtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|chname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|chtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fitab
index|[
name|NFONTS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|widtab
index|[
name|NFONTS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|codetab
index|[
name|NFONTS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device codes */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fontdir
init|=
name|FONTDIR
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
block|{
comment|/* table of what font */
name|char
modifier|*
name|name
decl_stmt|;
comment|/*   name is on what */
name|int
name|number
decl_stmt|;
comment|/*   position in font tables */
block|}
name|fontname
index|[
name|NFONTS
operator|+
literal|1
index|]
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGABLE
end_ifdef

begin_decl_stmt
name|int
name|dbg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|maxH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* farthest down we've been on the current page */
end_comment

begin_decl_stmt
name|int
name|size
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current point size being use */
end_comment

begin_decl_stmt
name|int
name|font
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current font - not using any to start with */
end_comment

begin_decl_stmt
name|int
name|hpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* horizontal position we are to be at next; left = 0 */
end_comment

begin_decl_stmt
name|int
name|vpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current vertical position (down positive) */
end_comment

begin_decl_stmt
name|int
name|horig
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* h origin of current block (just a marker) */
end_comment

begin_decl_stmt
name|int
name|vorig
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* v origin of current block (just a marker) */
end_comment

begin_decl_stmt
name|int
name|lastw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* width of last character printed */
end_comment

begin_define
define|#
directive|define
name|DISPATCHSIZE
value|256
end_define

begin_comment
comment|/* must be a power of two */
end_comment

begin_define
define|#
directive|define
name|CHARMASK
value|(DISPATCHSIZE-1)
end_define

begin_define
define|#
directive|define
name|DSIZ
value|((sizeof *dispatch)*DISPATCHSIZE)
end_define

begin_define
define|#
directive|define
name|OUTFILE
value|fileno (stdout)
end_define

begin_define
define|#
directive|define
name|RES
value|200
end_define

begin_comment
comment|/* resolution of the device */
end_comment

begin_define
define|#
directive|define
name|TRAILER
value|(10 * RES)
end_define

begin_comment
comment|/* position of trailer */
end_comment

begin_define
define|#
directive|define
name|RASTER_LENGTH
value|2048
end_define

begin_comment
comment|/* device line length */
end_comment

begin_define
define|#
directive|define
name|BYTES_PER_LINE
value|(RASTER_LENGTH/8)
end_define

begin_define
define|#
directive|define
name|NLINES
value|(11 * RES)
end_define

begin_comment
comment|/* 11" long paper */
end_comment

begin_define
define|#
directive|define
name|BUFFER_SIZE
value|(NLINES*BYTES_PER_LINE)
end_define

begin_comment
comment|/* number of chars in picture */
end_comment

begin_decl_stmt
name|int
name|pltmode
index|[]
init|=
block|{
name|VPLOT
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prtmode
index|[]
init|=
block|{
name|VPRINT
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|buffer
index|[
name|BUFFER_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Big line buffers  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|buf0p
init|=
operator|&
name|buffer
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Zero origin in circular buffer  */
end_comment

begin_function_decl
name|char
modifier|*
name|calloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|nalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|allpanic
parameter_list|()
function_decl|;
end_function_decl

begin_struct
struct|struct
name|header
block|{
name|short
name|magic
decl_stmt|;
name|unsigned
name|short
name|size
decl_stmt|;
name|short
name|maxx
decl_stmt|;
name|short
name|maxy
decl_stmt|;
name|short
name|xtnd
decl_stmt|;
block|}
name|header
struct|;
end_struct

begin_struct
struct|struct
name|dispatch
block|{
name|unsigned
name|short
name|addr
decl_stmt|;
name|short
name|nbytes
decl_stmt|;
name|char
name|up
decl_stmt|;
name|char
name|down
decl_stmt|;
name|char
name|left
decl_stmt|;
name|char
name|right
decl_stmt|;
name|short
name|width
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|fontdes
block|{
name|int
name|fnum
decl_stmt|;
name|int
name|psize
decl_stmt|;
name|struct
name|dispatch
modifier|*
name|disp
decl_stmt|;
name|char
modifier|*
name|bits
decl_stmt|;
block|}
name|fontdes
index|[
name|NFONTS
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|dispatch
modifier|*
name|dispatch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cfnum
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cpsize
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cfont
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fontwanted
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag:  "has a new font been requested?" */
end_comment

begin_decl_stmt
name|int
name|nfontnum
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|npsize
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|done
parameter_list|()
function_decl|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|fontdir
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|outlist
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUGABLE
case|case
literal|'d'
case|:
name|dbg
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
operator|==
literal|0
condition|)
name|dbg
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'s'
case|:
name|spage
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|spage
operator|<=
literal|0
condition|)
name|spage
operator|=
literal|9999
expr_stmt|;
break|break;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
comment|/* noversatec 	ioctl(OUTFILE, VSETSTATE, pltmode); noversatec */
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|conv
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
operator|++
name|argv
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|fp
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|conv
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|done
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|outlist
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* process list of page numbers to be printed */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|,
name|i
decl_stmt|;
name|nolist
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|n1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|do
name|n1
operator|=
literal|10
operator|*
name|n1
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
else|else
name|n1
operator|=
operator|-
literal|9999
expr_stmt|;
name|n2
operator|=
name|n1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|n2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|do
name|n2
operator|=
literal|10
operator|*
name|n2
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
else|else
name|n2
operator|=
literal|9999
expr_stmt|;
block|}
name|olist
index|[
name|nolist
operator|++
index|]
operator|=
name|n1
expr_stmt|;
name|olist
index|[
name|nolist
operator|++
index|]
operator|=
name|n2
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|olist
index|[
name|nolist
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nolist
condition|;
name|i
operator|+=
literal|2
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%3d %3d\n"
argument_list|,
name|olist
index|[
name|i
index|]
argument_list|,
name|olist
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|conv
argument_list|(
name|fp
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|k
decl_stmt|;
name|int
name|m
decl_stmt|,
name|n
decl_stmt|,
name|n1
decl_stmt|,
name|m1
decl_stmt|;
name|char
name|str
index|[
literal|100
index|]
decl_stmt|,
name|buf
index|[
literal|300
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* when input is text */
case|case
literal|' '
case|:
case|case
literal|0
case|:
comment|/* occasional noise creeps in */
break|break;
case|case
literal|'{'
case|:
comment|/* push down current environment */
name|t_push
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|t_pop
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* two motion digits plus a character */
name|hmot
argument_list|(
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|getc
argument_list|(
name|fp
argument_list|)
operator|-
literal|'0'
argument_list|)
expr_stmt|;
name|put1
argument_list|(
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* single ascii character */
name|put1
argument_list|(
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|put1s
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* straight text */
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|t_text
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* draw function */
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'l'
case|:
comment|/* draw a line */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|drawline
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* circle */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawcirc
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* ellipse */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawellip
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* arc */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d %d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n1
argument_list|,
operator|&
name|m1
argument_list|)
expr_stmt|;
name|drawarc
argument_list|(
name|n
argument_list|,
name|m
argument_list|,
name|n1
argument_list|,
name|m1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
comment|/* wiggly line */
name|drawwig
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unknown drawing function %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'s'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
comment|/* ignore fractional sizes */
name|setsize
argument_list|(
name|t_size
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|setfont
argument_list|(
name|t_font
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* absolute horizontal motion */
comment|/* fscanf(fp, "%d",&n); */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|hgoto
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* relative horizontal motion */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* word space */
break|break;
case|case
literal|'V'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|vgoto
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* new page */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_page
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* end of line */
while|while
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|t_newline
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* comment */
while|while
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* device control */
name|devcntrl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"unknown input character %o %c\n"
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|devcntrl
argument_list|(
argument|fp
argument_list|)
end_macro

begin_comment
comment|/* interpret device control functions */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|str
index|[
literal|20
index|]
decl_stmt|,
name|str1
index|[
literal|50
index|]
decl_stmt|,
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|str
index|[
literal|0
index|]
condition|)
block|{
comment|/* crude for now */
case|case
literal|'i'
case|:
comment|/* initialize */
name|fileinit
argument_list|()
expr_stmt|;
name|t_init
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* trailer */
name|t_trailer
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* pause -- can restart */
name|t_reset
argument_list|(
literal|'p'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* stop */
name|t_reset
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* resolution assumed when prepared */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* font used */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d %s"
argument_list|,
operator|&
name|n
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* in case there's a filename */
name|ungetc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* fgets goes too far */
name|str1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* in case nothing comes in */
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
name|str1
argument_list|)
expr_stmt|;
name|loadfont
argument_list|(
name|n
argument_list|,
name|str
argument_list|,
name|str1
argument_list|)
expr_stmt|;
break|break;
comment|/* these don't belong here... */
case|case
literal|'H'
case|:
comment|/* char height */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_charht
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* slant */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_slant
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
comment|/* skip rest of input line */
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
block|}
end_block

begin_comment
comment|/* fileinit:	read in font and code files, etc. 		Must open table for device, read in resolution, 		size info, font info, etc. and set params */
end_comment

begin_macro
name|fileinit
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|fin
decl_stmt|,
name|nw
decl_stmt|;
name|char
modifier|*
name|filebase
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|temp
index|[
literal|60
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/devver/DESC.out"
argument_list|,
name|fontdir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|open
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open tables for %s\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fin
argument_list|,
operator|&
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|nfonts
operator|=
name|dev
operator|.
name|nfonts
expr_stmt|;
name|nsizes
operator|=
name|dev
operator|.
name|nsizes
expr_stmt|;
name|nchtab
operator|=
name|dev
operator|.
name|nchtab
expr_stmt|;
name|filebase
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|dev
operator|.
name|filesize
argument_list|)
expr_stmt|;
comment|/* enough room for whole file */
name|read
argument_list|(
name|fin
argument_list|,
name|filebase
argument_list|,
name|dev
operator|.
name|filesize
argument_list|)
expr_stmt|;
comment|/* all at once */
name|pstab
operator|=
operator|(
name|short
operator|*
operator|)
name|filebase
expr_stmt|;
name|chtab
operator|=
name|pstab
operator|+
name|nsizes
operator|+
literal|1
expr_stmt|;
name|chname
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|chtab
operator|+
name|dev
operator|.
name|nchtab
operator|)
expr_stmt|;
name|p
operator|=
name|chname
operator|+
name|dev
operator|.
name|lchname
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nfonts
condition|;
name|i
operator|++
control|)
block|{
name|fontbase
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|font
operator|*
operator|)
name|p
expr_stmt|;
name|nw
operator|=
operator|*
name|p
operator|&
name|BMASK
expr_stmt|;
comment|/* 1st thing is width count */
if|if
condition|(
name|smnt
operator|==
literal|0
operator|&&
name|fontbase
index|[
name|i
index|]
operator|->
name|specfont
operator|==
literal|1
condition|)
name|smnt
operator|=
name|i
expr_stmt|;
comment|/* first special font */
name|p
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
expr_stmt|;
comment|/* that is on the beginning */
name|widtab
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
name|codetab
index|[
name|i
index|]
operator|=
name|p
operator|+
literal|2
operator|*
name|nw
expr_stmt|;
name|fitab
index|[
name|i
index|]
operator|=
name|p
operator|+
literal|3
operator|*
name|nw
expr_stmt|;
name|p
operator|+=
literal|3
operator|*
name|nw
operator|+
name|dev
operator|.
name|nchtab
operator|+
literal|128
operator|-
literal|32
expr_stmt|;
name|t_fp
argument_list|(
name|i
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|namefont
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|intname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
operator|>
literal|1
condition|)
name|fontprint
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|fontbase
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|font
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
literal|3
operator|*
literal|255
operator|+
name|dev
operator|.
name|nchtab
operator|+
operator|(
literal|128
operator|-
literal|32
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
argument_list|)
expr_stmt|;
name|widtab
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
literal|0
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
expr_stmt|;
name|fontbase
index|[
literal|0
index|]
operator|->
name|nwfont
operator|=
literal|255
expr_stmt|;
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fontprint
argument_list|(
argument|i
argument_list|)
end_macro

begin_comment
comment|/* debugging print of font i (0,...) */
end_comment

begin_block
block|{
name|int
name|j
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"font %d:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
name|i
index|]
expr_stmt|;
name|n
operator|=
name|fontbase
index|[
name|i
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"base=0%o, nchars=%d, spec=%d, name=%s, widtab=0%o, fitab=0%o\n"
argument_list|,
name|p
argument_list|,
name|n
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|specfont
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|namefont
argument_list|,
name|widtab
index|[
name|i
index|]
argument_list|,
name|fitab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"widths:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %2d"
argument_list|,
name|widtab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ncodetab:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %2d"
argument_list|,
name|codetab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nfitab:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|dev
operator|.
name|nchtab
operator|+
literal|128
operator|-
literal|32
condition|;
name|j
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %2d"
argument_list|,
name|fitab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|loadfont
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|,
argument|s1
argument_list|)
end_macro

begin_comment
comment|/* load font info for font s on position n (0...) */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|temp
index|[
literal|60
index|]
decl_stmt|;
name|int
name|fin
decl_stmt|,
name|nw
decl_stmt|,
name|norig
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|NFONTS
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"illegal fp command %d %s"
argument_list|,
name|n
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|namefont
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|s1
operator|==
name|NULL
operator|||
name|s1
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/devver/%s.out"
argument_list|,
name|fontdir
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/%s.out"
argument_list|,
name|s1
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|open
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open font table %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|norig
operator|=
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
name|read
argument_list|(
name|fin
argument_list|,
name|fontbase
index|[
name|n
index|]
argument_list|,
literal|3
operator|*
name|norig
operator|+
name|nchtab
operator|+
literal|128
operator|-
literal|32
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|&
name|BMASK
operator|)
operator|>
name|norig
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"Font %s too big for position %d\n"
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|nw
operator|=
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
name|widtab
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
name|n
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
expr_stmt|;
name|codetab
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|widtab
index|[
name|n
index|]
operator|+
literal|2
operator|*
name|nw
expr_stmt|;
name|fitab
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|widtab
index|[
name|n
index|]
operator|+
literal|3
operator|*
name|nw
expr_stmt|;
name|t_fp
argument_list|(
name|n
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|namefont
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|intname
argument_list|)
expr_stmt|;
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|=
name|norig
expr_stmt|;
comment|/* to later use full original size */
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
operator|>
literal|1
condition|)
name|fontprint
argument_list|(
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|done
argument_list|()
end_macro

begin_block
block|{
name|t_reset
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|error
argument_list|(
argument|f
argument_list|,
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|,
argument|a6
argument_list|,
argument|a7
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dver: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
name|done
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*******************************************************************************  * Routine:	  * Results:	  * Side Efct:	  ******************************************************************************/
end_comment

begin_macro
name|t_init
argument_list|()
end_macro

begin_comment
comment|/* initialize device */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|;
name|hpos
operator|=
name|vpos
operator|=
literal|0
expr_stmt|;
name|setsize
argument_list|(
name|t_size
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
comment|/* start somewhere */
name|setfont
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_struct
struct|struct
name|state
block|{
name|int
name|ssize
decl_stmt|;
name|int
name|sfont
decl_stmt|;
name|int
name|shpos
decl_stmt|;
name|int
name|svpos
decl_stmt|;
name|int
name|shorig
decl_stmt|;
name|int
name|svorig
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|state
name|state
index|[
name|MAXSTATE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|state
modifier|*
name|statep
init|=
name|state
decl_stmt|;
end_decl_stmt

begin_macro
name|t_push
argument_list|()
end_macro

begin_comment
comment|/* begin a new block */
end_comment

begin_block
block|{
name|statep
operator|->
name|ssize
operator|=
name|size
expr_stmt|;
name|statep
operator|->
name|sfont
operator|=
name|font
expr_stmt|;
name|statep
operator|->
name|shorig
operator|=
name|horig
expr_stmt|;
name|statep
operator|->
name|svorig
operator|=
name|vorig
expr_stmt|;
name|statep
operator|->
name|shpos
operator|=
name|hpos
expr_stmt|;
name|statep
operator|->
name|svpos
operator|=
name|vpos
expr_stmt|;
name|horig
operator|=
name|hpos
expr_stmt|;
name|vorig
operator|=
name|vpos
expr_stmt|;
name|hpos
operator|=
name|vpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|statep
operator|++
operator|>=
name|state
operator|+
name|MAXSTATE
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"{ nested too deep"
argument_list|)
expr_stmt|;
name|hpos
operator|=
name|vpos
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|t_pop
argument_list|()
end_macro

begin_comment
comment|/* pop to previous state */
end_comment

begin_block
block|{
if|if
condition|(
operator|--
name|statep
operator|<
name|state
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"extra }"
argument_list|)
expr_stmt|;
name|size
operator|=
name|statep
operator|->
name|ssize
expr_stmt|;
name|font
operator|=
name|statep
operator|->
name|sfont
expr_stmt|;
name|hpos
operator|=
name|statep
operator|->
name|shpos
expr_stmt|;
name|vpos
operator|=
name|statep
operator|->
name|svpos
expr_stmt|;
name|horig
operator|=
name|statep
operator|->
name|shorig
expr_stmt|;
name|vorig
operator|=
name|statep
operator|->
name|svorig
expr_stmt|;
block|}
end_block

begin_macro
name|t_page
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* do whatever new page functions */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|output
condition|)
block|{
if|if
condition|(
operator|++
name|scount
operator|>=
name|spage
condition|)
block|{
name|t_reset
argument_list|(
literal|'p'
argument_list|)
expr_stmt|;
name|scount
operator|=
literal|0
expr_stmt|;
block|}
name|slop_lines
argument_list|(
name|maxH
argument_list|)
expr_stmt|;
comment|/* noversatec 		ioctl(OUTFILE, VSETSTATE, prtmode); 		if (write(OUTFILE, "\f", 2) != 2) 			exit(RESTART); 		ioctl(OUTFILE, VSETSTATE, pltmode); noversatec */
name|size
operator|=
name|BYTES_PER_LINE
operator|*
name|maxH
expr_stmt|;
name|vclear
argument_list|(
name|buf0p
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|buf0p
operator|=
name|buffer
expr_stmt|;
block|}
name|maxH
operator|=
literal|0
expr_stmt|;
name|vpos
operator|=
literal|0
expr_stmt|;
name|output
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nolist
operator|==
literal|0
condition|)
return|return;
comment|/* no -o specified */
name|output
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nolist
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
name|n
operator|>=
name|olist
index|[
name|i
index|]
operator|&&
name|n
operator|<=
name|olist
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|output
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_macro
name|t_newline
argument_list|()
end_macro

begin_comment
comment|/* do whatever for the end of a line */
end_comment

begin_block
block|{
name|hpos
operator|=
literal|0
expr_stmt|;
comment|/* because we're now back at the left margin */
block|}
end_block

begin_macro
name|t_size
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* convert integer to internal size number*/
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|n
operator|<=
name|pstab
index|[
literal|0
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|n
operator|>=
name|pstab
index|[
name|nsizes
operator|-
literal|1
index|]
condition|)
return|return
operator|(
name|nsizes
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|n
operator|>
name|pstab
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|i
operator|+
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|t_charht
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set character height to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't set height on versatec yet\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|t_slant
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set slant to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't set slant on versatec yet\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|t_font
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* convert string to internal font number */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|nfonts
condition|)
name|n
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|t_text
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* print string s as text */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
name|char
name|str
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
return|return;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
switch|switch
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'\\'
case|:
case|case
literal|'e'
case|:
name|put1
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|str
index|[
literal|0
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|str
index|[
literal|1
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|str
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|put1s
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|put1
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|hmot
argument_list|(
name|lastw
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"width = %d\n"
argument_list|,
name|lastw
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_macro
name|t_reset
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
name|output
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'p'
case|:
name|slop_lines
argument_list|(
name|maxH
argument_list|)
expr_stmt|;
name|maxH
operator|=
literal|0
expr_stmt|;
name|buf0p
operator|=
name|buffer
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|slop_lines
argument_list|(
name|maxH
argument_list|)
expr_stmt|;
name|t_done
argument_list|()
expr_stmt|;
break|break;
comment|/* no Return */
block|}
block|}
end_block

begin_macro
name|t_done
argument_list|()
end_macro

begin_comment
comment|/* clean up and get ready to die */
end_comment

begin_block
block|{
comment|/* noversatec 	ioctl(OUTFILE, VSETSTATE, prtmode); 	if (write(OUTFILE, "\f", 2) != 2) 		exit(RESTART); noversatec */
block|}
end_block

begin_macro
name|t_trailer
argument_list|()
end_macro

begin_block
block|{
name|vpos
operator|=
literal|0
expr_stmt|;
name|vgoto
argument_list|(
name|TRAILER
argument_list|)
expr_stmt|;
name|vpos
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|vgoto
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
comment|/* check to see if n would move use past buf0p */
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR vgoto past the beginning"
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
comment|/* check for end of page */
if|if
condition|(
name|n
operator|>
name|RES
operator|*
literal|11
condition|)
name|n
operator|-=
name|RES
operator|*
literal|11
expr_stmt|;
comment|/* wrap around on to the top */
name|vpos
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_macro
name|put1s
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* s is a funny char name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchtab
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|chname
index|[
name|chtab
index|[
name|i
index|]
index|]
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|nchtab
condition|)
name|put1
argument_list|(
name|i
operator|+
literal|128
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|put1
argument_list|(
argument|c
argument_list|)
end_macro

begin_comment
comment|/* output char c */
end_comment

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|pw
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|int
name|j
decl_stmt|,
name|ofont
decl_stmt|,
name|code
decl_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
return|return;
name|c
operator|-=
literal|32
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"non-exist 0%o\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lastw
operator|=
operator|(
name|widtab
index|[
name|font
index|]
index|[
literal|0
index|]
operator|*
name|pstab
index|[
name|size
operator|-
literal|1
index|]
operator|+
name|dev
operator|.
name|unitwidth
operator|/
literal|2
operator|)
operator|/
name|dev
operator|.
name|unitwidth
expr_stmt|;
return|return;
block|}
name|k
operator|=
name|ofont
operator|=
name|font
expr_stmt|;
name|i
operator|=
name|fitab
index|[
name|font
index|]
index|[
name|c
index|]
operator|&
name|BMASK
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* it's on this font */
name|p
operator|=
name|codetab
index|[
name|font
index|]
expr_stmt|;
comment|/* get the printing value of ch */
name|pw
operator|=
name|widtab
index|[
name|font
index|]
expr_stmt|;
comment|/* get the width */
block|}
elseif|else
if|if
condition|(
name|smnt
operator|>
literal|0
condition|)
block|{
comment|/* on special (we hope) */
for|for
control|(
name|k
operator|=
name|smnt
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|nfonts
condition|;
name|j
operator|++
operator|,
name|k
operator|=
operator|(
name|k
operator|+
literal|1
operator|)
operator|%
operator|(
name|nfonts
operator|+
literal|1
operator|)
control|)
block|{
if|if
condition|(
name|fitab
index|[
name|k
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|i
operator|=
name|fitab
index|[
name|k
index|]
index|[
name|c
index|]
operator|&
name|BMASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|codetab
index|[
name|k
index|]
expr_stmt|;
name|pw
operator|=
name|widtab
index|[
name|k
index|]
expr_stmt|;
name|setfont
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|||
operator|(
name|code
operator|=
name|p
index|[
name|i
index|]
operator|&
name|BMASK
operator|)
operator|==
literal|0
operator|||
name|k
operator|>
name|nfonts
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not found 0%o\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
operator|+
literal|32
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c %d\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%03o %d\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|outc
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* character is< 254 */
if|if
condition|(
name|font
operator|!=
name|ofont
condition|)
name|setfont
argument_list|(
name|ofont
argument_list|)
expr_stmt|;
name|lastw
operator|=
operator|(
operator|(
name|pw
index|[
name|i
index|]
operator|&
literal|077
operator|)
operator|*
name|pstab
index|[
name|size
operator|-
literal|1
index|]
operator|+
name|dev
operator|.
name|unitwidth
operator|/
literal|2
operator|)
operator|/
name|dev
operator|.
name|unitwidth
expr_stmt|;
block|}
end_block

begin_macro
name|setsize
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set point size to n (internal) */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|==
name|size
condition|)
return|return;
comment|/* already there */
if|if
condition|(
name|vloadfont
argument_list|(
name|font
argument_list|,
name|pstab
index|[
name|n
operator|-
literal|1
index|]
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|size
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_macro
name|t_fp
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|,
argument|si
argument_list|)
end_macro

begin_comment
comment|/* font position n now contains font s, intname si */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|si
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|fontname
index|[
name|n
index|]
operator|.
name|name
operator|=
name|s
expr_stmt|;
name|fontname
index|[
name|n
index|]
operator|.
name|number
operator|=
name|atoi
argument_list|(
name|si
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFONTS
condition|;
name|i
operator|++
control|)
comment|/* free the bits of that font */
if|if
condition|(
name|fontdes
index|[
name|i
index|]
operator|.
name|fnum
operator|==
name|n
condition|)
block|{
name|nfree
argument_list|(
name|fontdes
index|[
name|i
index|]
operator|.
name|bits
argument_list|)
expr_stmt|;
name|fontdes
index|[
name|i
index|]
operator|.
name|bits
operator|=
literal|0
expr_stmt|;
name|fontdes
index|[
name|i
index|]
operator|.
name|fnum
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|setfont
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set font to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|NFONTS
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"illegal font %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|vloadfont
argument_list|(
name|n
argument_list|,
name|pstab
index|[
name|size
operator|-
literal|1
index|]
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|font
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|vloadfont
argument_list|(
name|fnum
argument_list|,
name|fsize
argument_list|)
specifier|register
name|int
name|fnum
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|fsize
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|fontwanted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fnum
operator|==
name|cfnum
operator|&&
name|fsize
operator|==
name|cpsize
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFONTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fontdes
index|[
name|i
index|]
operator|.
name|fnum
operator|==
name|fnum
operator|&&
name|fontdes
index|[
name|i
index|]
operator|.
name|psize
operator|==
name|fsize
condition|)
block|{
name|cfnum
operator|=
name|fontdes
index|[
name|i
index|]
operator|.
name|fnum
expr_stmt|;
name|cpsize
operator|=
name|fontdes
index|[
name|i
index|]
operator|.
name|psize
expr_stmt|;
name|dispatch
operator|=
operator|&
name|fontdes
index|[
name|i
index|]
operator|.
name|disp
index|[
literal|0
index|]
expr_stmt|;
name|bits
operator|=
name|fontdes
index|[
name|i
index|]
operator|.
name|bits
expr_stmt|;
name|cfont
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* this is a new font */
if|if
condition|(
name|fnum
operator|<
literal|0
operator|||
name|fnum
operator|>
name|NFONTS
operator|||
name|fontname
index|[
name|fnum
index|]
operator|.
name|name
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Internal error: illegal font %d name %s size\n"
argument_list|,
name|fontname
index|[
name|fnum
index|]
operator|.
name|name
argument_list|,
name|fnum
argument_list|,
name|fsize
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Need to verify the existance of that font/size here*/
name|nfontnum
operator|=
name|fnum
expr_stmt|;
name|npsize
operator|=
name|fsize
expr_stmt|;
name|fontwanted
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|getfont
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|fnum
decl_stmt|,
name|fsize
decl_stmt|,
name|fontd
decl_stmt|;
name|int
name|d
decl_stmt|;
name|char
name|cbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|fnum
operator|=
name|nfontnum
expr_stmt|;
name|fsize
operator|=
name|npsize
expr_stmt|;
name|sprintf
argument_list|(
name|cbuf
argument_list|,
literal|"/usr/lib/vfont/%s.%d"
argument_list|,
name|fontname
index|[
name|fnum
index|]
operator|.
name|name
argument_list|,
name|fsize
argument_list|)
expr_stmt|;
name|fontd
operator|=
name|open
argument_list|(
name|cbuf
argument_list|,
name|OPENREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontd
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|"fnum = %d size = %d name = %s\n"
argument_list|,
name|fnum
argument_list|,
name|fsize
argument_list|,
name|fontname
index|[
name|fnum
index|]
argument_list|)
expr_stmt|;
name|fontwanted
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fontd
argument_list|,
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|header
argument_list|)
operator|||
name|header
operator|.
name|magic
operator|!=
literal|0436
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Bad font file"
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
else|else
block|{
name|cfont
operator|=
name|relfont
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|bits
operator|=
name|nalloc
argument_list|(
name|header
operator|.
name|size
operator|+
name|DSIZ
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|bits
operator|=
name|allpanic
argument_list|(
name|header
operator|.
name|size
operator|+
name|DSIZ
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: ran out of memory\n"
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ABORT
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * have allocated one chunk of mem for font, dispatch. 			 * get the dispatch addr, align to word boundary. 			 */
name|d
operator|=
operator|(
name|int
operator|)
name|bits
operator|+
name|header
operator|.
name|size
expr_stmt|;
name|d
operator|+=
literal|1
expr_stmt|;
name|d
operator|&=
operator|~
literal|1
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fontd
argument_list|,
name|d
argument_list|,
name|DSIZ
argument_list|)
operator|!=
name|DSIZ
operator|||
name|read
argument_list|(
name|fontd
argument_list|,
name|bits
argument_list|,
name|header
operator|.
name|size
argument_list|)
operator|!=
name|header
operator|.
name|size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad font header"
argument_list|)
expr_stmt|;
else|else
block|{
name|close
argument_list|(
name|fontd
argument_list|)
expr_stmt|;
name|cfnum
operator|=
name|fontdes
index|[
name|cfont
index|]
operator|.
name|fnum
operator|=
name|fnum
expr_stmt|;
name|cpsize
operator|=
name|fontdes
index|[
name|cfont
index|]
operator|.
name|psize
operator|=
name|fsize
expr_stmt|;
name|fontdes
index|[
name|cfont
index|]
operator|.
name|bits
operator|=
name|bits
expr_stmt|;
name|fontdes
index|[
name|cfont
index|]
operator|.
name|disp
operator|=
operator|(
expr|struct
name|dispatch
operator|*
operator|)
name|d
expr_stmt|;
name|dispatch
operator|=
operator|&
name|fontdes
index|[
name|cfont
index|]
operator|.
name|disp
index|[
literal|0
index|]
expr_stmt|;
name|fontwanted
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|close
argument_list|(
name|fontd
argument_list|)
expr_stmt|;
name|fontwanted
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * "release" a font position - find an empty one, if possible  */
end_comment

begin_macro
name|relfont
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|newfont
decl_stmt|;
for|for
control|(
name|newfont
operator|=
literal|0
init|;
name|newfont
operator|<
name|NFONTS
condition|;
name|newfont
operator|++
control|)
if|if
condition|(
name|fontdes
index|[
name|newfont
index|]
operator|.
name|bits
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
operator|||
operator|!
name|fontdes
index|[
name|newfont
index|]
operator|.
name|bits
condition|)
break|break;
if|if
condition|(
name|fontdes
index|[
name|newfont
index|]
operator|.
name|bits
operator|!=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
operator|&&
name|fontdes
index|[
name|newfont
index|]
operator|.
name|bits
condition|)
block|{
name|nfree
argument_list|(
name|fontdes
index|[
name|newfont
index|]
operator|.
name|bits
argument_list|)
expr_stmt|;
name|fontdes
index|[
name|newfont
index|]
operator|.
name|bits
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"freeing position %d\n"
argument_list|,
name|newfont
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"taking, not freeing, position %d\n"
argument_list|,
name|newfont
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|fontdes
index|[
name|newfont
index|]
operator|.
name|bits
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|newfont
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|allpanic
parameter_list|(
name|nbytes
parameter_list|)
name|int
name|nbytes
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NFONTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fontdes
index|[
name|i
index|]
operator|.
name|bits
operator|!=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
operator|&&
name|fontdes
index|[
name|i
index|]
operator|.
name|bits
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|nfree
argument_list|(
name|fontdes
index|[
name|i
index|]
operator|.
name|bits
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NFONTS
condition|;
name|i
operator|++
control|)
block|{
name|fontdes
index|[
name|i
index|]
operator|.
name|fnum
operator|=
name|fontdes
index|[
name|i
index|]
operator|.
name|psize
operator|=
operator|-
literal|1
expr_stmt|;
name|fontdes
index|[
name|i
index|]
operator|.
name|bits
operator|=
literal|0
expr_stmt|;
name|cfnum
operator|=
name|cpsize
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|nalloc
argument_list|(
name|nbytes
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|M
index|[]
init|=
block|{
literal|0xffffffff
block|,
literal|0xfefefefe
block|,
literal|0xfcfcfcfc
block|,
literal|0xf8f8f8f8
block|,
literal|0xf0f0f0f0
block|,
literal|0xe0e0e0e0
block|,
literal|0xc0c0c0c0
block|,
literal|0x80808080
block|,
literal|0x0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|N
index|[]
init|=
block|{
literal|0x00000000
block|,
literal|0x01010101
block|,
literal|0x03030303
block|,
literal|0x07070707
block|,
literal|0x0f0f0f0f
block|,
literal|0x1f1f1f1f
block|,
literal|0x3f3f3f3f
block|,
literal|0x7f7f7f7f
block|,
literal|0xffffffff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strim
index|[]
init|=
block|{
literal|0xffffffff
block|,
literal|0xffffff00
block|,
literal|0xffff0000
block|,
literal|0xff000000
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|outc
argument_list|(
argument|code
argument_list|)
end_macro

begin_decl_stmt
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* character to print */
end_comment

begin_block
block|{
specifier|register
name|struct
name|dispatch
modifier|*
name|dis
decl_stmt|;
comment|/* ptr to character font record */
specifier|register
name|char
modifier|*
name|addr
decl_stmt|;
comment|/* addr of font data */
name|int
name|llen
decl_stmt|;
comment|/* length of each font line */
name|int
name|nlines
decl_stmt|;
comment|/* number of font lines */
specifier|register
name|char
modifier|*
name|scanp
decl_stmt|;
comment|/* ptr to output buffer */
name|int
name|scanp_inc
decl_stmt|;
comment|/* increment to start of next buffer */
name|int
name|offset
decl_stmt|;
comment|/* bit offset to start of font data */
name|int
name|i
decl_stmt|;
comment|/* loop counter */
specifier|register
name|int
name|count
decl_stmt|;
comment|/* font data ptr */
specifier|register
name|unsigned
name|fontdata
decl_stmt|;
comment|/* font data temporary */
specifier|register
name|int
name|off8
decl_stmt|;
comment|/* offset + 8 */
if|if
condition|(
name|fontwanted
condition|)
name|getfont
argument_list|()
expr_stmt|;
name|dis
operator|=
name|dispatch
operator|+
name|code
expr_stmt|;
if|if
condition|(
name|dis
operator|->
name|nbytes
condition|)
block|{
name|addr
operator|=
name|bits
operator|+
name|dis
operator|->
name|addr
expr_stmt|;
name|llen
operator|=
operator|(
name|dis
operator|->
name|left
operator|+
name|dis
operator|->
name|right
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|nlines
operator|=
name|dis
operator|->
name|up
operator|+
name|dis
operator|->
name|down
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|vpos
operator|+
name|dis
operator|->
name|down
operator|)
operator|>
name|maxH
condition|)
name|maxH
operator|=
name|i
expr_stmt|;
comment|/* remember page len */
name|scanp
operator|=
name|buf0p
operator|+
operator|(
operator|(
operator|(
name|vpos
operator|-
name|dis
operator|->
name|up
operator|)
operator|-
literal|1
operator|)
operator|*
name|BYTES_PER_LINE
operator|+
operator|(
name|hpos
operator|-
name|dis
operator|->
name|left
operator|)
operator|/
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|scanp
operator|<
operator|&
name|buffer
index|[
literal|0
index|]
condition|)
name|scanp
operator|+=
sizeof|sizeof
name|buffer
expr_stmt|;
name|scanp_inc
operator|=
name|BYTES_PER_LINE
operator|-
name|llen
expr_stmt|;
name|offset
operator|=
operator|-
operator|(
operator|(
name|hpos
operator|-
name|dis
operator|->
name|left
operator|)
operator|&
literal|07
operator|)
expr_stmt|;
name|off8
operator|=
name|offset
operator|+
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlines
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|scanp
operator|>=
operator|&
name|buffer
index|[
name|BUFFER_SIZE
index|]
condition|)
name|scanp
operator|-=
sizeof|sizeof
name|buffer
expr_stmt|;
name|count
operator|=
name|llen
expr_stmt|;
if|if
condition|(
name|scanp
operator|+
name|count
operator|<=
operator|&
name|buffer
index|[
name|BUFFER_SIZE
index|]
condition|)
block|{
do|do
block|{
name|fontdata
operator|=
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|addr
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|4
condition|)
name|fontdata
operator|&=
operator|~
name|strim
index|[
name|count
index|]
expr_stmt|;
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|scanp
operator||=
operator|(
name|fontdata
operator|<<
name|offset
operator|)
operator|&
operator|~
name|M
index|[
name|off8
index|]
expr_stmt|;
name|scanp
operator|++
expr_stmt|;
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|scanp
operator||=
operator|(
name|fontdata
operator|<<
name|off8
operator|)
operator|&
operator|~
name|N
index|[
name|off8
index|]
expr_stmt|;
name|scanp
operator|+=
literal|3
expr_stmt|;
name|count
operator|-=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|count
operator|>
literal|0
condition|)
do|;
block|}
name|scanp
operator|+=
name|scanp_inc
operator|+
name|count
expr_stmt|;
name|addr
operator|+=
name|count
expr_stmt|;
block|}
return|return;
block|}
return|return;
block|}
end_block

begin_macro
name|slop_lines
argument_list|(
argument|nlines
argument_list|)
end_macro

begin_decl_stmt
name|int
name|nlines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output "nlines" lines from the buffer, and clear that section of the  */
end_comment

begin_comment
comment|/* buffer.	*/
end_comment

begin_block
block|{
name|unsigned
name|usize
decl_stmt|;
name|usize
operator|=
name|BYTES_PER_LINE
operator|*
name|nlines
expr_stmt|;
name|writev
argument_list|(
name|buf0p
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|vclear
argument_list|(
name|buf0p
argument_list|,
name|usize
argument_list|)
expr_stmt|;
comment|/* noversatec 	ioctl(OUTFILE, VSETSTATE, pltmode); noversatec */
block|}
end_block

begin_macro
name|writev
argument_list|(
argument|buf
argument_list|,
argument|usize
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|usize
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|tsize
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|usize
condition|)
block|{
name|buf
operator|+=
name|tsize
expr_stmt|;
name|tsize
operator|=
name|usize
operator|>
name|MAXWRIT
condition|?
name|MAXWRIT
else|:
name|usize
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buf = %d size = %d\n"
argument_list|,
name|buf
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|tsize
operator|=
name|write
argument_list|(
name|OUTFILE
argument_list|,
name|buf
argument_list|,
name|tsize
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"dver: write failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|RESTART
argument_list|)
expr_stmt|;
block|}
name|usize
operator|-=
name|tsize
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|vclear
argument_list|(
argument|ptr
argument_list|,
argument|nbytes
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|nbytes
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|tsize
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nbytes
condition|)
block|{
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
literal|16
operator|*
literal|1024
argument_list|)
operator|<
name|nbytes
condition|)
block|{
name|tsize
operator|=
literal|16
operator|*
literal|1024
expr_stmt|;
block|}
else|else
name|tsize
operator|=
name|nbytes
expr_stmt|;
name|nbytes
operator|-=
name|tsize
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"clearing ptr = %d size = %d\n"
argument_list|,
name|ptr
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|clear
argument_list|(
name|ptr
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|tsize
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|clear
argument_list|(
argument|lp
argument_list|,
argument|nbytes
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nbytes
decl_stmt|;
end_decl_stmt

begin_block
block|{
asm|asm("movc5 $0,(sp),$0,8(ap),*4(ap)");
block|}
end_block

begin_function
name|char
modifier|*
name|nalloc
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|calloc
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"allocated %d bytes at %x\n"
argument_list|,
name|i
operator|*
name|j
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_macro
name|nfree
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"freeing at %x\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Points should be in the range 0<= x< RASTER_LENGTH, 0<= y< NLINES.  * The origin is the top left-hand corner with increasing x towards the  * right and increasing y going down.  * The output array is NLINES x BYTES_PER_LINE pixels.  */
end_comment

begin_expr_stmt
name|point
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
specifier|register
name|int
name|x
operator|,
name|y
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|unsigned
operator|)
name|x
operator|<
name|RASTER_LENGTH
operator|&&
operator|(
name|unsigned
operator|)
name|y
operator|<
name|NLINES
condition|)
block|{
name|buffer
index|[
name|y
operator|*
name|BYTES_PER_LINE
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
index|]
operator||=
literal|1
operator|<<
operator|(
literal|7
operator|-
operator|(
name|x
operator|&
literal|07
operator|)
operator|)
expr_stmt|;
block|}
block|}
end_block

end_unit

