begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	dver.c	1.16	85/04/29  *  * VAX Versatec driver for the new troff  *  * Authors:	BWK(BELL)  *		VCAT(berkley)  *		Richard L. Hyde, Perdue University  *		and David Slattengren, U.C. Berkeley  */
end_comment

begin_comment
comment|/*******************************************************************************      output language from troff:     all numbers are character strings  #..\n	comment sn	size in points fn	font as number from 1 to n in	stipple as number from 1 to n cx	ascii character x Cxyz	funny char \(xyz. terminated by white space Hn	go to absolute horizontal position n Vn	go to absolute vertical position n (down is positive) hn	go n units horizontally (relative) vn	ditto vertically nnc	move right nn, then print c (exactly 2 digits!) 		(this wart is an optimization that shrinks output file size 		 about 35% and run-time about 15% while preserving ascii-ness) pn	new page begins (number n) -- set v to 0 P	spread ends -- output it. nb a	end of line (information only -- no action needed) 	b = space before line, a = after w	paddable word space -- no action needed  Dt ..\n	draw operation 't': 	Dt d		set line thickness to d pixels 	Ds d		set line style mask to d 	Dl x y		line from here by x,y 	Dc d		circle of diameter d with left side here 	De x y		ellipse of axes x,y with left side here 	Da x y r	arc counter-clockwise by x,y of radius r 	D~ x y x y ...	B-spline curve by x,y then x,y ... 	Dg x y x y ...	gremlin spline curve by x,y then x,y ... 	Dq d n miny maxy [p dx dy curx endy]	polygon filled with d, has n 			vectors, with extents from miny to maxy (no border)  x ..\n	device control functions:      x i	init      x T s	name of device is s      x r n h v	resolution is n/inch h = min horizontal motion, v = min vert      x p	pause (can restart)      x s	stop -- done for ever      x t	generate trailer      x f n s	font position n contains font s      x H n	set character height to n      x S n	set slant to N  	Subcommands like "i" are often spelled out like "init".  *******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/vcmd.h>
end_include

begin_include
include|#
directive|include
file|"dev.h"
end_include

begin_comment
comment|/* #define DEBUGABLE		/* No, not debugable... */
end_comment

begin_define
define|#
directive|define
name|DRIVER
end_define

begin_comment
comment|/* Yes, we're driving directly */
end_comment

begin_define
define|#
directive|define
name|NFONTS
value|65
end_define

begin_comment
comment|/* total number of fonts useable */
end_comment

begin_define
define|#
directive|define
name|MAXSTATE
value|6
end_define

begin_comment
comment|/* number of environments rememberable */
end_comment

begin_define
define|#
directive|define
name|OPENREAD
value|0
end_define

begin_comment
comment|/* mode for openning files */
end_comment

begin_define
define|#
directive|define
name|RESTART
value|1
end_define

begin_comment
comment|/* upon exit, return either RESTART */
end_comment

begin_define
define|#
directive|define
name|ABORT
value|2
end_define

begin_comment
comment|/*     or ABORT */
end_comment

begin_define
define|#
directive|define
name|FATAL
value|1
end_define

begin_comment
comment|/* type of error */
end_comment

begin_define
define|#
directive|define
name|BMASK
value|0377
end_define

begin_comment
comment|/* byte grabber */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FONTDIR
end_ifndef

begin_define
define|#
directive|define
name|FONTDIR
value|"/usr/lib/font"
end_define

begin_comment
comment|/* default place to find font descriptions */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BITDIR
end_ifndef

begin_define
define|#
directive|define
name|BITDIR
value|"/usr/lib/vfont"
end_define

begin_comment
comment|/* default place to look for font rasters */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAXWRIT
value|4096
end_define

begin_comment
comment|/* max characters allowed to write at once */
end_comment

begin_define
define|#
directive|define
name|hmot
parameter_list|(
name|n
parameter_list|)
value|hpos += n
end_define

begin_define
define|#
directive|define
name|hgoto
parameter_list|(
name|n
parameter_list|)
value|hpos = n
end_define

begin_define
define|#
directive|define
name|vmot
parameter_list|(
name|n
parameter_list|)
value|vgoto(vpos + (n))
end_define

begin_decl_stmt
name|char
name|SccsId
index|[]
init|=
literal|"dver.c	1.16	85/04/29"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|output
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* do we do output at all? */
end_comment

begin_decl_stmt
name|int
name|nolist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output page list if> 0 */
end_comment

begin_decl_stmt
name|int
name|olist
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pairs of page numbers */
end_comment

begin_decl_stmt
name|struct
name|dev
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|font
modifier|*
name|fontbase
index|[
name|NFONTS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|pstab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* point size table pointer */
end_comment

begin_decl_stmt
name|int
name|nsizes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of sizes device is capable of printing */
end_comment

begin_decl_stmt
name|int
name|nfonts
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of fonts device is capable of printing */
end_comment

begin_decl_stmt
name|int
name|nstips
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of stipple fonts device can print */
end_comment

begin_decl_stmt
name|int
name|nchtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|chname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|chtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fitab
index|[
name|NFONTS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* font inclusion table - maps ascii to ch # */
end_comment

begin_decl_stmt
name|char
modifier|*
name|widtab
index|[
name|NFONTS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* width table for each font */
end_comment

begin_decl_stmt
name|char
modifier|*
name|codetab
index|[
name|NFONTS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device codes */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fontdir
init|=
name|FONTDIR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place to find devxxx directories */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bitdir
init|=
name|BITDIR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place to find raster fonts and fontmap */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fontname
index|[
name|NFONTS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of what font is on what position */
end_comment

begin_struct
struct|struct
block|{
comment|/* table of what font */
name|char
name|fname
index|[
literal|3
index|]
decl_stmt|;
comment|/*   name maps to what */
name|char
modifier|*
name|ffile
decl_stmt|;
comment|/*   filename in bitdirectory */
block|}
name|fontmap
index|[
name|NFONTS
operator|+
literal|1
index|]
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGABLE
end_ifdef

begin_decl_stmt
name|int
name|dbg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|size
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current point size (internal pstable index) */
end_comment

begin_decl_stmt
name|int
name|font
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current font - assume reasonable starting font */
end_comment

begin_decl_stmt
name|int
name|stip
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current stipple font - none to start with */
end_comment

begin_decl_stmt
name|int
name|stipmem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current member from stipple font to use */
end_comment

begin_decl_stmt
name|int
name|hpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* horizontal position we are to be at next; left = 0 */
end_comment

begin_decl_stmt
name|int
name|vpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current vertical position (down positive) */
end_comment

begin_decl_stmt
name|int
name|maxv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* farthest down the page we've been */
end_comment

begin_extern
extern|extern	linethickness;
end_extern

begin_comment
comment|/* thickness (in pixels) of any drawn object */
end_comment

begin_extern
extern|extern	linmod;
end_extern

begin_comment
comment|/* line style (a bit mask - dotted, etc.) of objects */
end_comment

begin_decl_stmt
name|int
name|lastw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* width of last character printed */
end_comment

begin_define
define|#
directive|define
name|DISPATCHSIZE
value|256
end_define

begin_comment
comment|/* must be a power of two */
end_comment

begin_define
define|#
directive|define
name|CHARMASK
value|(DISPATCHSIZE-1)
end_define

begin_define
define|#
directive|define
name|DSIZ
value|((sizeof *dispatch)*DISPATCHSIZE)
end_define

begin_define
define|#
directive|define
name|OUTFILE
value|fileno (stdout)
end_define

begin_define
define|#
directive|define
name|RES
value|200
end_define

begin_comment
comment|/* resolution of the device (dots/in) */
end_comment

begin_define
define|#
directive|define
name|RASTER_LENGTH
value|7040
end_define

begin_comment
comment|/* device line length */
end_comment

begin_define
define|#
directive|define
name|BYTES_PER_LINE
value|(RASTER_LENGTH/8)
end_define

begin_define
define|#
directive|define
name|BAND
value|1
end_define

begin_comment
comment|/* length of a band in inches */
end_comment

begin_define
define|#
directive|define
name|NLINES
value|(int)(BAND * RES)
end_define

begin_comment
comment|/* BAND" long bands */
end_comment

begin_define
define|#
directive|define
name|BUFFER_SIZE
value|(NLINES*BYTES_PER_LINE)
end_define

begin_comment
comment|/* number of chars in picture */
end_comment

begin_define
define|#
directive|define
name|BUFTOP
value|(&buffer[0])
end_define

begin_define
define|#
directive|define
name|BUFBOTTOM
value|(&buffer[BUFFER_SIZE] - 1)
end_define

begin_define
define|#
directive|define
name|buf0p
value|BUFTOP
end_define

begin_comment
comment|/* vorigin in circular buffer */
end_comment

begin_define
define|#
directive|define
name|PAGEEND
value|1
end_define

begin_comment
comment|/* flags to "outband" to tell */
end_comment

begin_define
define|#
directive|define
name|OVERBAND
value|0
end_define

begin_comment
comment|/* whether to fill out a page */
end_comment

begin_decl_stmt
name|int
name|pltmode
index|[]
init|=
block|{
name|VPLOT
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prtmode
index|[]
init|=
block|{
name|VPRINT
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|buffer
index|[
name|BUFFER_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* versatec-wide NLINES buffer */
end_comment

begin_decl_stmt
name|int
name|vorigin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where on the page startbuf maps to */
end_comment

begin_decl_stmt
name|int
name|pagelen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how long the current "page" has printed */
end_comment

begin_function_decl
name|char
modifier|*
name|calloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|nalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|allpanic
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|operand
parameter_list|()
function_decl|;
end_function_decl

begin_struct
struct|struct
name|header
block|{
name|short
name|magic
decl_stmt|;
name|unsigned
name|short
name|size
decl_stmt|;
name|short
name|maxx
decl_stmt|;
name|short
name|maxy
decl_stmt|;
name|short
name|xtnd
decl_stmt|;
block|}
name|header
struct|;
end_struct

begin_struct
struct|struct
name|dispatch
block|{
name|unsigned
name|short
name|addr
decl_stmt|;
name|short
name|nbytes
decl_stmt|;
name|char
name|up
decl_stmt|;
name|char
name|down
decl_stmt|;
name|char
name|left
decl_stmt|;
name|char
name|right
decl_stmt|;
name|short
name|width
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|fontdes
block|{
name|int
name|fnum
decl_stmt|;
comment|/* if == -1, this position unused */
name|int
name|psize
decl_stmt|;
name|struct
name|dispatch
modifier|*
name|disp
decl_stmt|;
name|char
modifier|*
name|bits
decl_stmt|;
block|}
name|fontdes
index|[
name|NFONTS
operator|+
literal|1
index|]
struct|;
end_struct

begin_comment
comment|/* is initialized at start of main */
end_comment

begin_decl_stmt
name|struct
name|dispatch
modifier|*
name|dispatch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dispatch
modifier|*
name|stip_disp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cfnum
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cpsize
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cfont
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|stip_bits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fontwanted
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag:  "has a new font been requested?" */
end_comment

begin_decl_stmt
name|int
name|nfontnum
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|npsize
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NFONTS
condition|;
name|fontdes
index|[
name|i
operator|++
index|]
operator|.
name|fnum
operator|=
operator|-
literal|1
control|)
empty_stmt|;
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|*
operator|*
operator|++
name|argv
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'F'
case|:
name|bitdir
operator|=
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fontdir
operator|=
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|outlist
argument_list|(
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUGABLE
case|case
literal|'d'
case|:
name|dbg
operator|=
name|atoi
argument_list|(
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
operator|==
literal|0
condition|)
name|dbg
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|DRIVER
name|ioctl
argument_list|(
name|OUTFILE
argument_list|,
name|VSETSTATE
argument_list|,
name|pltmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|conv
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|fp
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|conv
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	char  * operand (& argc,& argv)  |  | Results:	returns address of the operand given with a command-line  |		option.  It uses either "-Xoperand" or "-X operand", whichever  |		is present.  The program is terminated if no option is present.  |  | Side Efct:	argc and argv are updated as necessary.  *----------------------------------------------------------------------------*/
end_comment

begin_function
name|char
modifier|*
name|operand
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
operator|*
name|argvp
operator|)
index|[
literal|2
index|]
condition|)
return|return
operator|(
operator|*
operator|*
name|argvp
operator|+
literal|2
operator|)
return|;
comment|/* operand immediately follows */
if|if
condition|(
operator|(
operator|--
operator|*
name|argcp
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* no operand */
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"command-line option operand missing."
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|*
operator|(
operator|++
operator|(
operator|*
name|argvp
operator|)
operator|)
operator|)
return|;
comment|/* operand next word */
block|}
end_function

begin_macro
name|outlist
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* process list of page numbers to be printed */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|nolist
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|n1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|do
name|n1
operator|=
literal|10
operator|*
name|n1
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
else|else
name|n1
operator|=
operator|-
literal|9999
expr_stmt|;
name|n2
operator|=
name|n1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|n2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|do
name|n2
operator|=
literal|10
operator|*
name|n2
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
else|else
name|n2
operator|=
literal|9999
expr_stmt|;
block|}
name|olist
index|[
name|nolist
operator|++
index|]
operator|=
name|n1
expr_stmt|;
name|olist
index|[
name|nolist
operator|++
index|]
operator|=
name|n2
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|olist
index|[
name|nolist
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nolist
condition|;
name|i
operator|+=
literal|2
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%3d %3d\n"
argument_list|,
name|olist
index|[
name|i
index|]
argument_list|,
name|olist
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|conv
argument_list|(
name|fp
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|k
decl_stmt|;
name|int
name|m
decl_stmt|,
name|n
decl_stmt|,
name|n1
decl_stmt|,
name|m1
decl_stmt|;
name|char
name|str
index|[
literal|100
index|]
decl_stmt|,
name|buf
index|[
literal|300
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* when input is text */
case|case
literal|0
case|:
comment|/* occasional noise creeps in */
case|case
literal|'\t'
case|:
case|case
literal|' '
case|:
break|break;
case|case
literal|'{'
case|:
comment|/* push down current environment */
name|t_push
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|t_pop
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* two motion digits plus a character */
name|hmot
argument_list|(
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|getc
argument_list|(
name|fp
argument_list|)
operator|-
literal|'0'
argument_list|)
expr_stmt|;
name|put1
argument_list|(
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* single ascii character */
name|put1
argument_list|(
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|put1s
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* straight text */
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unexpected end of input"
argument_list|)
expr_stmt|;
name|t_text
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* draw function */
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unexpected end of input"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'l'
case|:
comment|/* draw a line */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|drawline
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* circle */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawcirc
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* ellipse */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawellip
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* arc */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d %d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n1
argument_list|,
operator|&
name|m1
argument_list|)
expr_stmt|;
name|drawarc
argument_list|(
name|n
argument_list|,
name|m
argument_list|,
name|n1
argument_list|,
name|m1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* polygon */
name|n
operator|=
literal|1
expr_stmt|;
comment|/* get stipple */
while|while
condition|(
name|isspace
argument_list|(
name|buf
index|[
operator|++
name|n
index|]
argument_list|)
condition|)
empty_stmt|;
comment|/* number first */
name|setfill
argument_list|(
name|atoi
argument_list|(
operator|&
operator|(
name|buf
index|[
name|n
index|]
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set up stipple */
while|while
condition|(
name|isdigit
argument_list|(
name|buf
index|[
operator|++
name|n
index|]
argument_list|)
condition|)
empty_stmt|;
name|polygon
argument_list|(
operator|&
operator|(
name|buf
index|[
name|n
index|]
operator|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* draw polygon */
break|break;
case|case
literal|'~'
case|:
comment|/* wiggly line */
case|case
literal|'g'
case|:
comment|/* gremlin spline */
name|drawwig
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|fp
argument_list|,
name|buf
index|[
literal|0
index|]
operator|==
literal|'~'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* line thickness */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawthick
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* line style */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawstyle
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unknown drawing function %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'s'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|setsize
argument_list|(
name|t_size
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|setstip
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|setfont
argument_list|(
name|t_font
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* absolute horizontal motion */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|hgoto
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* relative horizontal motion */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* word space */
break|break;
case|case
literal|'V'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|vgoto
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* new spread */
if|if
condition|(
name|output
condition|)
name|outband
argument_list|(
name|OVERBAND
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* new page */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_page
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* end of line */
name|t_newline
argument_list|()
expr_stmt|;
case|case
literal|'#'
case|:
comment|/* comment */
do|do
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
do|;
break|break;
case|case
literal|'x'
case|:
comment|/* device control */
if|if
condition|(
name|devcntrl
argument_list|(
name|fp
argument_list|)
condition|)
return|return;
break|break;
default|default:
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unknown input character %o %c"
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function
name|int
name|devcntrl
parameter_list|(
name|fp
parameter_list|)
comment|/* interpret device control functions */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* returns -1 apon recieving "stop" command */
block|{
name|char
name|str
index|[
literal|20
index|]
decl_stmt|,
name|str1
index|[
literal|50
index|]
decl_stmt|,
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|str
index|[
literal|0
index|]
condition|)
block|{
comment|/* crude for now */
case|case
literal|'i'
case|:
comment|/* initialize */
name|fileinit
argument_list|()
expr_stmt|;
name|t_init
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* trailer */
break|break;
case|case
literal|'p'
case|:
comment|/* pause -- can restart */
name|t_reset
argument_list|(
literal|'p'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* stop */
name|t_reset
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
literal|'r'
case|:
comment|/* resolution assumed when prepared */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|RES
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"Input computed for wrong printer"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* font used */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d %s"
argument_list|,
operator|&
name|n
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* in case of filename */
name|ungetc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* fgets goes too far */
name|str1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* in case nothing comes in */
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
name|str1
argument_list|)
expr_stmt|;
name|loadfont
argument_list|(
name|n
argument_list|,
name|str
argument_list|,
name|str1
argument_list|)
expr_stmt|;
break|break;
comment|/* these don't belong here... */
case|case
literal|'H'
case|:
comment|/* char height */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_charht
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* slant */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_slant
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
comment|/* skip rest of input line */
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* fileinit:	read in font and code files, etc. 		Must open table for device, read in resolution, 		size info, font info, etc. and set params. 		Also read in font name mapping. */
end_comment

begin_macro
name|fileinit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|fin
decl_stmt|;
specifier|register
name|int
name|nw
decl_stmt|;
specifier|register
name|char
modifier|*
name|filebase
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|temp
index|[
literal|100
index|]
decl_stmt|;
comment|/* first, read in font map file.  The file must be of Format: 			XX  FILENAME  (XX = troff font name) 			with one entry per text line of the file. 		   Extra stuff after FILENAME is ignored */
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/fontmap"
argument_list|,
name|bitdir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|temp
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"Can't open %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NFONTS
operator|&&
name|fgets
argument_list|(
name|temp
argument_list|,
literal|100
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|sscanf
argument_list|(
name|temp
argument_list|,
literal|"%2s"
argument_list|,
name|fontmap
index|[
name|i
index|]
operator|.
name|fname
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|temp
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'	'
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'	'
condition|)
name|p
operator|++
expr_stmt|;
name|filebase
operator|=
name|p
expr_stmt|;
for|for
control|(
name|nw
operator|=
literal|1
init|;
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
condition|;
name|p
operator|++
control|)
name|nw
operator|++
expr_stmt|;
name|fontmap
index|[
name|i
index|]
operator|.
name|ffile
operator|=
name|nalloc
argument_list|(
literal|1
argument_list|,
name|nw
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|filebase
argument_list|,
literal|"%s"
argument_list|,
name|fontmap
index|[
name|i
index|]
operator|.
name|ffile
argument_list|)
expr_stmt|;
block|}
name|fontmap
index|[
operator|++
name|i
index|]
operator|.
name|fname
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
comment|/* finish off with zeros */
name|fontmap
index|[
name|i
index|]
operator|.
name|ffile
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"font map:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fontmap
index|[
name|i
index|]
operator|.
name|ffile
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s = %s\n"
argument_list|,
name|fontmap
index|[
name|i
index|]
operator|.
name|fname
argument_list|,
name|fontmap
index|[
name|i
index|]
operator|.
name|ffile
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/devvp/DESC.out"
argument_list|,
name|fontdir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|open
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open tables for %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fin
argument_list|,
operator|&
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dev
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|dev
argument_list|)
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't read header for %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|nfonts
operator|=
name|dev
operator|.
name|nfonts
expr_stmt|;
name|nsizes
operator|=
name|dev
operator|.
name|nsizes
expr_stmt|;
name|nstips
operator|=
name|dev
operator|.
name|nstips
expr_stmt|;
name|nchtab
operator|=
name|dev
operator|.
name|nchtab
expr_stmt|;
name|filebase
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|dev
operator|.
name|filesize
argument_list|)
expr_stmt|;
comment|/* enough room for whole file */
if|if
condition|(
name|read
argument_list|(
name|fin
argument_list|,
name|filebase
argument_list|,
name|dev
operator|.
name|filesize
argument_list|)
operator|!=
name|dev
operator|.
name|filesize
condition|)
comment|/* at once */
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't read width table for %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|pstab
operator|=
operator|(
name|short
operator|*
operator|)
name|filebase
expr_stmt|;
name|chtab
operator|=
name|pstab
operator|+
name|nsizes
operator|+
literal|1
expr_stmt|;
name|chname
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|chtab
operator|+
name|dev
operator|.
name|nchtab
operator|)
expr_stmt|;
name|p
operator|=
name|chname
operator|+
name|dev
operator|.
name|lchname
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nfonts
condition|;
name|i
operator|++
control|)
block|{
name|fontbase
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|font
operator|*
operator|)
name|p
expr_stmt|;
name|nw
operator|=
operator|*
name|p
operator|&
name|BMASK
expr_stmt|;
comment|/* 1st thing is width count */
name|p
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
expr_stmt|;
name|widtab
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
name|codetab
index|[
name|i
index|]
operator|=
name|p
operator|+
literal|2
operator|*
name|nw
expr_stmt|;
name|fitab
index|[
name|i
index|]
operator|=
name|p
operator|+
literal|3
operator|*
name|nw
expr_stmt|;
name|p
operator|+=
literal|3
operator|*
name|nw
operator|+
name|dev
operator|.
name|nchtab
operator|+
literal|128
operator|-
literal|32
expr_stmt|;
name|t_fp
argument_list|(
name|i
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|namefont
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|intname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
operator|>
literal|1
condition|)
name|fontprint
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nstips
condition|;
name|i
operator|++
control|)
block|{
comment|/* add in stipple "filenames" */
if|if
condition|(
name|nfonts
operator|+
name|i
operator|<=
name|NFONTS
condition|)
name|t_fp
argument_list|(
name|nfonts
operator|+
name|i
argument_list|,
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|fontbase
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|font
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
literal|3
operator|*
literal|255
operator|+
name|dev
operator|.
name|nchtab
operator|+
operator|(
literal|128
operator|-
literal|32
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
argument_list|)
expr_stmt|;
name|widtab
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
literal|0
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
expr_stmt|;
name|fontbase
index|[
literal|0
index|]
operator|->
name|nwfont
operator|=
literal|255
expr_stmt|;
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGABLE
end_ifdef

begin_macro
name|fontprint
argument_list|(
argument|i
argument_list|)
end_macro

begin_comment
comment|/* debugging print of font i (0,...) */
end_comment

begin_block
block|{
name|int
name|j
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"font %d:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
name|i
index|]
expr_stmt|;
name|n
operator|=
name|fontbase
index|[
name|i
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"base=0%o, nchars=%d, spec=%d, name=%s, widtab=0%o, fitab=0%o\n"
argument_list|,
name|p
argument_list|,
name|n
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|specfont
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|namefont
argument_list|,
name|widtab
index|[
name|i
index|]
argument_list|,
name|fitab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"widths:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %2d"
argument_list|,
name|widtab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ncodetab:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %2d"
argument_list|,
name|codetab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nfitab:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|dev
operator|.
name|nchtab
operator|+
literal|128
operator|-
literal|32
condition|;
name|j
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %2d"
argument_list|,
name|fitab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|loadfont
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|,
argument|s1
argument_list|)
end_macro

begin_comment
comment|/* load font info for font s on position n (0...) */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|temp
index|[
literal|60
index|]
decl_stmt|;
specifier|register
name|int
name|fin
decl_stmt|;
specifier|register
name|int
name|nw
decl_stmt|;
specifier|register
name|int
name|norig
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|NFONTS
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"illegal fp command %d %s"
argument_list|,
name|n
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|namefont
argument_list|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|fin
operator|=
literal|1
init|;
name|fin
operator|<=
name|NFONTS
condition|;
name|fin
operator|++
control|)
comment|/* first check to see if the */
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|fontbase
index|[
name|fin
index|]
operator|->
name|namefont
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* font is loaded */
specifier|register
name|char
modifier|*
name|c
decl_stmt|;
comment|/* somewhere else */
define|#
directive|define
name|ptrswap
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|{ c = (char*) (x); x = y; y = c; }
define|#
directive|define
name|ptrfswap
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|{ c = (char*) (x); x = y; y = (struct font *)c; }
name|ptrfswap
argument_list|(
name|fontbase
index|[
name|n
index|]
argument_list|,
name|fontbase
index|[
name|fin
index|]
argument_list|)
expr_stmt|;
name|ptrswap
argument_list|(
name|codetab
index|[
name|n
index|]
argument_list|,
name|codetab
index|[
name|fin
index|]
argument_list|)
expr_stmt|;
name|ptrswap
argument_list|(
name|widtab
index|[
name|n
index|]
argument_list|,
name|widtab
index|[
name|fin
index|]
argument_list|)
expr_stmt|;
name|ptrswap
argument_list|(
name|fitab
index|[
name|n
index|]
argument_list|,
name|fitab
index|[
name|fin
index|]
argument_list|)
expr_stmt|;
name|t_fp
argument_list|(
name|n
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|namefont
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|intname
argument_list|)
expr_stmt|;
name|t_fp
argument_list|(
name|fin
argument_list|,
name|fontbase
index|[
name|fin
index|]
operator|->
name|namefont
argument_list|,
name|fontbase
index|[
name|fin
index|]
operator|->
name|intname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|s1
operator|==
name|NULL
operator|||
name|s1
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/devvp/%s.out"
argument_list|,
name|fontdir
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/%s.out"
argument_list|,
name|s1
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|open
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open font table %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|norig
operator|=
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fin
argument_list|,
name|fontbase
index|[
name|n
index|]
argument_list|,
literal|3
operator|*
name|norig
operator|+
name|nchtab
operator|+
literal|128
operator|-
literal|32
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"Can't read in font %s on position %d"
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|&
name|BMASK
operator|)
operator|>
name|norig
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"Font %s too big for position %d"
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|nw
operator|=
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
name|widtab
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
name|n
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
expr_stmt|;
name|codetab
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|widtab
index|[
name|n
index|]
operator|+
literal|2
operator|*
name|nw
expr_stmt|;
name|fitab
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|widtab
index|[
name|n
index|]
operator|+
literal|3
operator|*
name|nw
expr_stmt|;
name|t_fp
argument_list|(
name|n
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|namefont
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|intname
argument_list|)
expr_stmt|;
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|=
name|norig
expr_stmt|;
comment|/* to later use full original size */
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
operator|>
literal|1
condition|)
name|fontprint
argument_list|(
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|error
argument_list|(
argument|f
argument_list|,
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|,
argument|a6
argument_list|,
argument|a7
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dver: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
name|exit
argument_list|(
name|ABORT
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|t_init
argument_list|()
end_macro

begin_comment
comment|/* initialize device */
end_comment

begin_block
block|{
name|vorigin
operator|=
name|pagelen
operator|=
name|maxv
operator|=
name|hpos
operator|=
name|vpos
operator|=
literal|0
expr_stmt|;
name|output
operator|=
literal|0
expr_stmt|;
comment|/* don't output anything yet */
name|setsize
argument_list|(
name|t_size
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
comment|/* start somewhere */
name|setfont
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_struct
struct|struct
name|state
block|{
name|int
name|ssize
decl_stmt|;
name|int
name|sfont
decl_stmt|;
name|int
name|shpos
decl_stmt|;
name|int
name|svpos
decl_stmt|;
name|int
name|sstyle
decl_stmt|;
name|int
name|sthick
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|state
name|state
index|[
name|MAXSTATE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|state
modifier|*
name|statep
init|=
name|state
decl_stmt|;
end_decl_stmt

begin_macro
name|t_push
argument_list|()
end_macro

begin_comment
comment|/* begin a new block */
end_comment

begin_block
block|{
name|statep
operator|->
name|ssize
operator|=
name|size
expr_stmt|;
name|statep
operator|->
name|sfont
operator|=
name|font
expr_stmt|;
name|statep
operator|->
name|sstyle
operator|=
name|linmod
expr_stmt|;
name|statep
operator|->
name|sthick
operator|=
name|linethickness
expr_stmt|;
name|statep
operator|->
name|shpos
operator|=
name|hpos
expr_stmt|;
name|statep
operator|->
name|svpos
operator|=
name|vpos
expr_stmt|;
if|if
condition|(
name|statep
operator|++
operator|>=
name|state
operator|+
name|MAXSTATE
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"{ nested too deep"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|t_pop
argument_list|()
end_macro

begin_comment
comment|/* pop to previous state */
end_comment

begin_block
block|{
if|if
condition|(
operator|--
name|statep
operator|<
name|state
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"extra }"
argument_list|)
expr_stmt|;
name|size
operator|=
name|statep
operator|->
name|ssize
expr_stmt|;
name|font
operator|=
name|statep
operator|->
name|sfont
expr_stmt|;
name|hpos
operator|=
name|statep
operator|->
name|shpos
expr_stmt|;
name|vpos
operator|=
name|statep
operator|->
name|svpos
expr_stmt|;
name|linmod
operator|=
name|statep
operator|->
name|sstyle
expr_stmt|;
name|linethickness
operator|=
name|statep
operator|->
name|sthick
expr_stmt|;
block|}
end_block

begin_macro
name|t_page
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* do whatever new page functions */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|output
condition|)
name|outband
argument_list|(
name|PAGEEND
argument_list|)
expr_stmt|;
name|maxv
operator|=
name|vpos
operator|=
literal|0
expr_stmt|;
name|output
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nolist
operator|==
literal|0
condition|)
return|return;
comment|/* no -o specified */
name|output
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nolist
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
name|n
operator|>=
name|olist
index|[
name|i
index|]
operator|&&
name|n
operator|<=
name|olist
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|output
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_macro
name|outband
argument_list|(
argument|page
argument_list|)
end_macro

begin_decl_stmt
name|int
name|page
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|outsize
decl_stmt|;
if|if
condition|(
name|page
operator|==
name|PAGEEND
condition|)
block|{
comment|/* set outsize to inch boundary */
name|outsize
operator|=
operator|(
name|maxv
operator|+
operator|(
name|RES
operator|-
literal|2
operator|)
operator|-
name|pagelen
operator|)
operator|/
name|RES
expr_stmt|;
name|vorigin
operator|=
name|pagelen
operator|=
literal|0
expr_stmt|;
comment|/* reset for new page */
if|if
condition|(
name|outsize
operator|<
literal|1
condition|)
return|return;
comment|/* if outsize<= zero, forget it */
name|outsize
operator|*=
name|RES
operator|*
name|BYTES_PER_LINE
expr_stmt|;
name|vwrite
argument_list|(
name|buf0p
argument_list|,
name|outsize
operator|>
name|BUFFER_SIZE
condition|?
name|BUFFER_SIZE
else|:
name|outsize
argument_list|)
expr_stmt|;
name|vclear
argument_list|(
name|buf0p
argument_list|,
name|BUFFER_SIZE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|outsize
operator|-=
name|BUFFER_SIZE
operator|)
operator|>
literal|0
condition|)
name|vwrite
argument_list|(
name|buf0p
argument_list|,
name|outsize
operator|>
name|BUFFER_SIZE
condition|?
name|BUFFER_SIZE
else|:
name|outsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vorigin
operator|+=
name|NLINES
expr_stmt|;
name|pagelen
operator|+=
name|NLINES
expr_stmt|;
name|vwrite
argument_list|(
name|buf0p
argument_list|,
name|BUFFER_SIZE
argument_list|)
expr_stmt|;
name|vclear
argument_list|(
name|buf0p
argument_list|,
name|BUFFER_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|t_newline
argument_list|()
end_macro

begin_comment
comment|/* do whatever for the end of a line */
end_comment

begin_block
block|{
name|hpos
operator|=
literal|0
expr_stmt|;
comment|/* because we're now back at the left margin */
block|}
end_block

begin_macro
name|t_size
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* convert integer to internal size number*/
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|n
operator|<=
name|pstab
index|[
literal|0
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|n
operator|>=
name|pstab
index|[
name|nsizes
operator|-
literal|1
index|]
condition|)
return|return
operator|(
name|nsizes
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|n
operator|>
name|pstab
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|t_charht
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set character height to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"can't set height on versatec"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|t_slant
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set slant to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"can't set slant on versatec"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|t_font
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* convert string to internal font number */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|nfonts
condition|)
name|n
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|t_text
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* print string s as text */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
name|char
name|str
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
return|return;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
switch|switch
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'\\'
case|:
case|case
literal|'e'
case|:
name|put1
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|str
index|[
literal|0
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|str
index|[
literal|1
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|str
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|put1s
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|put1
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|hmot
argument_list|(
name|lastw
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"width = %d\n"
argument_list|,
name|lastw
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_macro
name|t_reset
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'s'
case|:
name|t_page
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DRIVER
name|ioctl
argument_list|(
name|OUTFILE
argument_list|,
name|VSETSTATE
argument_list|,
name|prtmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
end_block

begin_macro
name|vgoto
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|vpos
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_macro
name|put1s
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* s is a funny char name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s "
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchtab
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|chname
index|[
name|chtab
index|[
name|i
index|]
index|]
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|nchtab
condition|)
name|put1
argument_list|(
name|i
operator|+
literal|128
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|put1
argument_list|(
argument|c
argument_list|)
end_macro

begin_comment
comment|/* output char c */
end_comment

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|pw
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|int
name|j
decl_stmt|,
name|ofont
decl_stmt|,
name|code
decl_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
return|return;
name|c
operator|-=
literal|32
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"non-exist 0%o\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lastw
operator|=
operator|(
name|widtab
index|[
name|font
index|]
index|[
literal|0
index|]
operator|*
name|pstab
index|[
name|size
index|]
operator|+
name|dev
operator|.
name|unitwidth
operator|/
literal|2
operator|)
operator|/
name|dev
operator|.
name|unitwidth
expr_stmt|;
return|return;
block|}
name|k
operator|=
name|ofont
operator|=
name|font
expr_stmt|;
name|i
operator|=
name|fitab
index|[
name|font
index|]
index|[
name|c
index|]
operator|&
name|BMASK
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* it's on this font */
name|p
operator|=
name|codetab
index|[
name|font
index|]
expr_stmt|;
comment|/* get the printing value of ch */
name|pw
operator|=
name|widtab
index|[
name|font
index|]
expr_stmt|;
comment|/* get the width */
block|}
else|else
comment|/* on another font (we hope) */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|nfonts
condition|;
name|j
operator|++
operator|,
name|k
operator|=
operator|(
name|k
operator|+
literal|1
operator|)
operator|%
operator|(
name|nfonts
operator|+
literal|1
operator|)
control|)
block|{
if|if
condition|(
name|fitab
index|[
name|k
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|i
operator|=
name|fitab
index|[
name|k
index|]
index|[
name|c
index|]
operator|&
name|BMASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|codetab
index|[
name|k
index|]
expr_stmt|;
name|pw
operator|=
name|widtab
index|[
name|k
index|]
expr_stmt|;
name|setfont
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not found 0%o\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|code
operator|=
name|p
index|[
name|i
index|]
operator|&
name|BMASK
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
operator|+
literal|32
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c %d\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%03o %d\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|outc
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* character is< 254 */
if|if
condition|(
name|font
operator|!=
name|ofont
condition|)
name|setfont
argument_list|(
name|ofont
argument_list|)
expr_stmt|;
name|lastw
operator|=
operator|(
operator|(
name|pw
index|[
name|i
index|]
operator|&
literal|077
operator|)
operator|*
name|pstab
index|[
name|size
index|]
operator|+
name|dev
operator|.
name|unitwidth
operator|/
literal|2
operator|)
operator|/
name|dev
operator|.
name|unitwidth
expr_stmt|;
block|}
end_block

begin_macro
name|setsize
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set point size to n (internal) */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|==
name|size
condition|)
return|return;
comment|/* already there */
if|if
condition|(
name|vloadfont
argument_list|(
name|font
argument_list|,
name|pstab
index|[
name|n
index|]
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|size
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|t_fp
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|,
argument|si
argument_list|)
end_macro

begin_comment
comment|/* font position n now contains font s, intname si */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* internal name is ignored */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|si
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* first convert s to filename if possible */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fontmap
index|[
name|i
index|]
operator|.
name|ffile
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"testing :%s:%s:\n"
argument_list|,
name|s
argument_list|,
name|fontmap
index|[
name|i
index|]
operator|.
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|fontmap
index|[
name|i
index|]
operator|.
name|fname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|fontmap
index|[
name|i
index|]
operator|.
name|ffile
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"found :%s:\n"
argument_list|,
name|fontmap
index|[
name|i
index|]
operator|.
name|ffile
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
name|fontname
index|[
name|n
index|]
operator|=
name|s
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NFONTS
condition|;
name|i
operator|++
control|)
comment|/* free the bits of that font */
if|if
condition|(
name|fontdes
index|[
name|i
index|]
operator|.
name|fnum
operator|==
name|n
condition|)
block|{
name|nfree
argument_list|(
name|fontdes
index|[
name|i
index|]
operator|.
name|bits
argument_list|)
expr_stmt|;
name|fontdes
index|[
name|i
index|]
operator|.
name|fnum
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|setfont
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set font to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|nfonts
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"illegal font %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|vloadfont
argument_list|(
name|n
argument_list|,
name|pstab
index|[
name|size
index|]
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|font
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_macro
name|setstip
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set stipple font to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|<
literal|1
operator|||
name|n
operator|>
name|nstips
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"illegal stipple %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|stip
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	setfill(stipple_number)  |  | Results:	sets the fill-pattern pointers (stip_disp and  |		stip_bits) for a particular stipple.  Takes stipple  |		font from current "stip" number.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|setfill
argument_list|(
argument|number
argument_list|)
end_macro

begin_decl_stmt
name|int
name|number
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|curfont
decl_stmt|;
comment|/* places to save current text font */
name|int
name|cursize
decl_stmt|;
comment|/* set global stipmem for polygon */
if|if
condition|(
name|number
operator|<
literal|0
operator|||
name|number
operator|>=
name|DISPATCHSIZE
condition|)
name|stipmem
operator|=
literal|0
expr_stmt|;
else|else
name|stipmem
operator|=
name|number
expr_stmt|;
name|curfont
operator|=
name|cfnum
expr_stmt|;
comment|/* get pointers to */
name|cursize
operator|=
name|cpsize
expr_stmt|;
comment|/* the inuse font */
if|if
condition|(
name|vloadfont
argument_list|(
name|nfonts
operator|+
name|stip
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|stip_disp
operator|=
operator|(
expr|struct
name|dispatch
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* stipple not here */
block|}
else|else
block|{
if|if
condition|(
name|fontwanted
condition|)
block|{
if|if
condition|(
name|getfont
argument_list|()
condition|)
block|{
name|stip_disp
operator|=
operator|(
expr|struct
name|dispatch
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|stip_disp
operator|=
name|dispatch
expr_stmt|;
comment|/* save for polygon routine */
name|stip_bits
operator|=
name|bits
expr_stmt|;
block|}
block|}
else|else
block|{
name|stip_disp
operator|=
name|dispatch
expr_stmt|;
comment|/* save for polygon routine */
name|stip_bits
operator|=
name|bits
expr_stmt|;
block|}
block|}
name|vloadfont
argument_list|(
name|curfont
argument_list|,
name|cursize
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|vloadfont
argument_list|(
name|fnum
argument_list|,
name|fsize
argument_list|)
specifier|register
name|int
name|fnum
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|fsize
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|fontwanted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fnum
operator|==
name|cfnum
operator|&&
name|fsize
operator|==
name|cpsize
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NFONTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fontdes
index|[
name|i
index|]
operator|.
name|fnum
operator|==
name|fnum
operator|&&
name|fontdes
index|[
name|i
index|]
operator|.
name|psize
operator|==
name|fsize
condition|)
block|{
name|cfnum
operator|=
name|fontdes
index|[
name|i
index|]
operator|.
name|fnum
expr_stmt|;
name|cpsize
operator|=
name|fontdes
index|[
name|i
index|]
operator|.
name|psize
expr_stmt|;
name|dispatch
operator|=
operator|&
name|fontdes
index|[
name|i
index|]
operator|.
name|disp
index|[
literal|0
index|]
expr_stmt|;
name|bits
operator|=
name|fontdes
index|[
name|i
index|]
operator|.
name|bits
expr_stmt|;
name|cfont
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* this is a new font */
if|if
condition|(
name|fnum
operator|<
literal|0
operator|||
name|fnum
operator|>
name|NFONTS
operator|||
name|fontname
index|[
name|fnum
index|]
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"illegal font %d size %d"
argument_list|,
name|fnum
argument_list|,
name|fsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Need to verify the existance of that font/size here*/
name|nfontnum
operator|=
name|fnum
expr_stmt|;
name|npsize
operator|=
name|fsize
expr_stmt|;
name|fontwanted
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|getfont
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|fnum
decl_stmt|;
specifier|register
name|int
name|fsize
decl_stmt|;
specifier|register
name|int
name|fontd
decl_stmt|;
specifier|register
name|int
name|d
decl_stmt|;
specifier|register
name|int
name|sizehunt
init|=
name|size
decl_stmt|;
name|char
name|cbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|fnum
operator|=
name|nfontnum
expr_stmt|;
name|fsize
operator|=
name|npsize
expr_stmt|;
comment|/* try to open font file - if unsuccessful, hunt for */
comment|/* a file of same style, different size to substitute */
name|d
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* direction to look in pstab (smaller first) */
do|do
block|{
name|sprintf
argument_list|(
name|cbuf
argument_list|,
literal|"%s/%s.%d"
argument_list|,
name|bitdir
argument_list|,
name|fontname
index|[
name|fnum
index|]
argument_list|,
name|fsize
argument_list|)
expr_stmt|;
name|fontd
operator|=
name|open
argument_list|(
name|cbuf
argument_list|,
name|OPENREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontd
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* File wasn't found. Try another ps */
name|sizehunt
operator|+=
name|d
expr_stmt|;
if|if
condition|(
name|sizehunt
operator|<
literal|0
condition|)
block|{
comment|/* past beginning - look higher */
name|d
operator|=
literal|1
expr_stmt|;
name|sizehunt
operator|=
name|size
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sizehunt
operator|>
name|nsizes
condition|)
block|{
comment|/* past top - forget it */
name|d
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fsize
operator|=
name|pstab
index|[
name|sizehunt
index|]
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|fontd
operator|==
operator|-
literal|1
operator|&&
name|d
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|fontd
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* completely unsuccessful */
name|perror
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"fnum = %d, psize = %d, name = %s"
argument_list|,
name|fnum
argument_list|,
name|npsize
argument_list|,
name|fontname
index|[
name|fnum
index|]
argument_list|)
expr_stmt|;
name|fontwanted
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fontd
argument_list|,
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|header
argument_list|)
operator|||
name|header
operator|.
name|magic
operator|!=
literal|0436
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Bad font file"
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
else|else
block|{
name|cfont
operator|=
name|relfont
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|bits
operator|=
name|nalloc
argument_list|(
name|header
operator|.
name|size
operator|+
name|DSIZ
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|bits
operator|=
name|allpanic
argument_list|(
name|header
operator|.
name|size
operator|+
name|DSIZ
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"%s: ran out of memory"
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * have allocated one chunk of mem for font, dispatch. 			 * get the dispatch addr, align to word boundary. 			 */
name|d
operator|=
operator|(
name|int
operator|)
name|bits
operator|+
name|header
operator|.
name|size
expr_stmt|;
name|d
operator|+=
literal|1
expr_stmt|;
name|d
operator|&=
operator|~
literal|1
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fontd
argument_list|,
name|d
argument_list|,
name|DSIZ
argument_list|)
operator|!=
name|DSIZ
operator|||
name|read
argument_list|(
name|fontd
argument_list|,
name|bits
argument_list|,
name|header
operator|.
name|size
argument_list|)
operator|!=
name|header
operator|.
name|size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad font header"
argument_list|)
expr_stmt|;
else|else
block|{
name|close
argument_list|(
name|fontd
argument_list|)
expr_stmt|;
name|cfnum
operator|=
name|fontdes
index|[
name|cfont
index|]
operator|.
name|fnum
operator|=
name|fnum
expr_stmt|;
name|cpsize
operator|=
name|fontdes
index|[
name|cfont
index|]
operator|.
name|psize
operator|=
name|fsize
expr_stmt|;
name|fontdes
index|[
name|cfont
index|]
operator|.
name|bits
operator|=
name|bits
expr_stmt|;
name|fontdes
index|[
name|cfont
index|]
operator|.
name|disp
operator|=
operator|(
expr|struct
name|dispatch
operator|*
operator|)
name|d
expr_stmt|;
name|dispatch
operator|=
operator|&
name|fontdes
index|[
name|cfont
index|]
operator|.
name|disp
index|[
literal|0
index|]
expr_stmt|;
name|fontwanted
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|close
argument_list|(
name|fontd
argument_list|)
expr_stmt|;
name|fontwanted
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * "release" a font position - find an empty one, if possible  */
end_comment

begin_macro
name|relfont
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|newfont
decl_stmt|;
for|for
control|(
name|newfont
operator|=
literal|0
init|;
name|newfont
operator|<
name|NFONTS
condition|;
name|newfont
operator|++
control|)
if|if
condition|(
name|fontdes
index|[
name|newfont
index|]
operator|.
name|fnum
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|fontdes
index|[
name|newfont
index|]
operator|.
name|fnum
operator|!=
operator|-
literal|1
condition|)
block|{
name|nfree
argument_list|(
name|fontdes
index|[
name|newfont
index|]
operator|.
name|bits
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"freeing position %d\n"
argument_list|,
name|newfont
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"taking, not freeing, position %d\n"
argument_list|,
name|newfont
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|fontdes
index|[
name|newfont
index|]
operator|.
name|fnum
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|newfont
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|allpanic
parameter_list|(
name|nbytes
parameter_list|)
name|int
name|nbytes
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NFONTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fontdes
index|[
name|i
index|]
operator|.
name|fnum
operator|!=
operator|-
literal|1
condition|)
name|nfree
argument_list|(
name|fontdes
index|[
name|i
index|]
operator|.
name|bits
argument_list|)
expr_stmt|;
name|fontdes
index|[
name|i
index|]
operator|.
name|fnum
operator|=
name|fontdes
index|[
name|i
index|]
operator|.
name|psize
operator|=
operator|-
literal|1
expr_stmt|;
name|cfnum
operator|=
name|cpsize
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|nalloc
argument_list|(
name|nbytes
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|M
index|[]
init|=
block|{
literal|0xffffffff
block|,
literal|0xfefefefe
block|,
literal|0xfcfcfcfc
block|,
literal|0xf8f8f8f8
block|,
literal|0xf0f0f0f0
block|,
literal|0xe0e0e0e0
block|,
literal|0xc0c0c0c0
block|,
literal|0x80808080
block|,
literal|0x0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|N
index|[]
init|=
block|{
literal|0x00000000
block|,
literal|0x01010101
block|,
literal|0x03030303
block|,
literal|0x07070707
block|,
literal|0x0f0f0f0f
block|,
literal|0x1f1f1f1f
block|,
literal|0x3f3f3f3f
block|,
literal|0x7f7f7f7f
block|,
literal|0xffffffff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strim
index|[]
init|=
block|{
literal|0xffffffff
block|,
literal|0xffffff00
block|,
literal|0xffff0000
block|,
literal|0xff000000
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|outc
argument_list|(
argument|code
argument_list|)
end_macro

begin_decl_stmt
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* character to print */
end_comment

begin_block
block|{
specifier|register
name|struct
name|dispatch
modifier|*
name|dis
decl_stmt|;
comment|/* ptr to character font record */
specifier|register
name|char
modifier|*
name|addr
decl_stmt|;
comment|/* addr of font data */
name|int
name|llen
decl_stmt|;
comment|/* length of each font line */
name|int
name|nlines
decl_stmt|;
comment|/* number of font lines */
specifier|register
name|char
modifier|*
name|scanp
decl_stmt|;
comment|/* ptr to output buffer */
name|int
name|scanp_inc
decl_stmt|;
comment|/* increment to start of next buffer */
name|int
name|offset
decl_stmt|;
comment|/* bit offset to start of font data */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* loop counter */
specifier|register
name|int
name|count
decl_stmt|;
comment|/* font data ptr */
specifier|register
name|unsigned
name|fontdata
decl_stmt|;
comment|/* font data temporary */
specifier|register
name|int
name|off8
decl_stmt|;
comment|/* reverse of offset */
if|if
condition|(
name|fontwanted
condition|)
if|if
condition|(
name|getfont
argument_list|()
condition|)
return|return;
name|dis
operator|=
name|dispatch
operator|+
name|code
expr_stmt|;
if|if
condition|(
name|dis
operator|->
name|nbytes
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"char %d at (%d,%d)"
argument_list|,
name|code
argument_list|,
name|hpos
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|addr
operator|=
name|bits
operator|+
name|dis
operator|->
name|addr
expr_stmt|;
name|llen
operator|=
operator|(
name|dis
operator|->
name|left
operator|+
name|dis
operator|->
name|right
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|nlines
operator|=
name|dis
operator|->
name|up
operator|+
name|dis
operator|->
name|down
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|vpos
operator|+
name|dis
operator|->
name|down
operator|)
operator|>
name|maxv
condition|)
name|maxv
operator|=
name|i
expr_stmt|;
name|scanp
operator|=
name|buf0p
operator|+
operator|(
name|vpos
operator|-
operator|(
name|vorigin
operator|+
name|dis
operator|->
name|up
operator|)
operator|)
operator|*
name|BYTES_PER_LINE
operator|+
operator|(
name|hpos
operator|-
name|dis
operator|->
name|left
operator|)
operator|/
literal|8
expr_stmt|;
name|scanp_inc
operator|=
name|BYTES_PER_LINE
operator|-
name|llen
expr_stmt|;
name|offset
operator|=
operator|(
name|hpos
operator|-
name|dis
operator|->
name|left
operator|)
operator|&
literal|07
expr_stmt|;
name|off8
operator|=
literal|8
operator|-
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlines
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|scanp
operator|+
operator|(
name|count
operator|=
name|llen
operator|)
operator|>
name|BUFBOTTOM
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" scrapped\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scanp
operator|>=
name|BUFTOP
condition|)
block|{
do|do
block|{
name|fontdata
operator|=
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|addr
expr_stmt|;
name|addr
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|4
condition|)
name|fontdata
operator|&=
operator|~
name|strim
index|[
name|count
index|]
expr_stmt|;
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|scanp
operator||=
operator|(
name|fontdata
operator|>>
name|offset
operator|)
operator|&
operator|~
name|M
index|[
name|off8
index|]
expr_stmt|;
name|scanp
operator|++
expr_stmt|;
operator|*
operator|(
name|unsigned
operator|*
operator|)
name|scanp
operator||=
operator|(
name|fontdata
operator|<<
name|off8
operator|)
operator|&
operator|~
name|N
index|[
name|off8
index|]
expr_stmt|;
name|scanp
operator|+=
literal|3
expr_stmt|;
name|count
operator|-=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|count
operator|>
literal|0
condition|)
do|;
block|}
name|scanp
operator|+=
name|scanp_inc
operator|+
name|count
expr_stmt|;
name|addr
operator|+=
name|count
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_macro
name|vwrite
argument_list|(
argument|buf
argument_list|,
argument|usize
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|usize
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|tsize
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|usize
condition|)
block|{
name|buf
operator|+=
name|tsize
expr_stmt|;
name|tsize
operator|=
name|usize
operator|>
name|MAXWRIT
condition|?
name|MAXWRIT
else|:
name|usize
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buf = %d size = %d\n"
argument_list|,
name|buf
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbg
condition|)
endif|#
directive|endif
if|if
condition|(
operator|(
name|tsize
operator|=
name|write
argument_list|(
name|OUTFILE
argument_list|,
name|buf
argument_list|,
name|tsize
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"dver: write failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|RESTART
argument_list|)
expr_stmt|;
block|}
name|usize
operator|-=
name|tsize
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|vclear
argument_list|(
argument|ptr
argument_list|,
argument|nbytes
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nbytes
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|tsize
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nbytes
condition|)
block|{
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
literal|16
operator|*
literal|1024
argument_list|)
operator|<
name|nbytes
condition|)
block|{
name|tsize
operator|=
literal|16
operator|*
literal|1024
expr_stmt|;
block|}
else|else
name|tsize
operator|=
name|nbytes
expr_stmt|;
name|nbytes
operator|-=
name|tsize
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"clearing ptr = %d size = %d\n"
argument_list|,
name|ptr
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|clear
argument_list|(
name|ptr
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|tsize
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|clear
argument_list|(
argument|lp
argument_list|,
argument|nbytes
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nbytes
decl_stmt|;
end_decl_stmt

begin_block
block|{
asm|asm("movc5 $0,(sp),$0,8(ap),*4(ap)");
block|}
end_block

begin_function
name|char
modifier|*
name|nalloc
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|calloc
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"allocated %d bytes at %x\n"
argument_list|,
name|i
operator|*
name|j
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_macro
name|nfree
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"freeing at %x\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Plot a dot at (x, y).  Points should be in the range 0<= x< RASTER_LENGTH,  * vorigin<= y< vorigin + NLINES.  If the point will not fit on the buffer,  * it is left out.  Things outside the x boundary are wrapped around the end.  */
end_comment

begin_expr_stmt
name|point
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
specifier|register
name|int
name|x
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ptr
init|=
name|buf0p
operator|+
operator|(
name|y
operator|-
name|vorigin
operator|)
operator|*
name|BYTES_PER_LINE
operator|+
operator|(
name|x
operator|>>
literal|3
operator|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|>
name|BUFBOTTOM
operator|||
name|ptr
operator|<
name|BUFTOP
condition|)
comment|/* ignore if it's off buffer */
return|return;
operator|*
name|ptr
operator||=
literal|1
operator|<<
operator|(
literal|7
operator|-
operator|(
name|x
operator|&
literal|07
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|y
operator|>
name|maxv
condition|)
name|maxv
operator|=
name|y
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|MAXX
value|0x7fff
end_define

begin_comment
comment|/* largest positive int */
end_comment

begin_define
define|#
directive|define
name|MINX
value|0x8000
end_define

begin_comment
comment|/* smallest negative int */
end_comment

begin_define
define|#
directive|define
name|MAXVECT
value|75
end_define

begin_typedef
typedef|typedef
struct|struct
name|poly
block|{
name|struct
name|poly
modifier|*
name|next
decl_stmt|;
comment|/* doublely-linked lists of vectors */
name|struct
name|poly
modifier|*
name|prev
decl_stmt|;
name|int
name|param
decl_stmt|;
comment|/* bressenham line algorithm parameter */
name|short
name|dy
decl_stmt|;
comment|/* delta-y for calculating line */
name|short
name|dx
decl_stmt|;
comment|/* delta-x for calculating line */
name|short
name|currx
decl_stmt|;
comment|/* current x in this vector */
name|short
name|endy
decl_stmt|;
comment|/* where vector ends */
block|}
name|polyvector
typedef|;
end_typedef

begin_decl_stmt
name|int
name|rp_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of the string in "buf" */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rp_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "walking" pointer into buf */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	read_poly (input_buffer, file_pointer)  |  | Results:	gets an integer from buffer pointed to by rp_ptr,  |		and advances in the file.  If there is nothing left,  |		more can be read in from the file.  rp_ptr and rp_len  |		are set in "polygon".  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|read_poly
argument_list|(
argument|buf
argument_list|,
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|rp_ptr
operator|==
literal|'\n'
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|++
name|rp_ptr
argument_list|)
condition|)
empty_stmt|;
comment|/* skip any leading spaces */
name|i
operator|=
name|atoi
argument_list|(
name|rp_ptr
argument_list|)
expr_stmt|;
comment|/* convert motion to curve points */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|rp_ptr
argument_list|)
condition|)
empty_stmt|;
comment|/* skip number*/
comment|/* if the amount we read wasn't the */
comment|/*    whole thing, read some more in */
if|if
condition|(
name|rp_len
operator|-
operator|(
name|rp_ptr
operator|-
name|buf
operator|)
operator|<
literal|10
operator|&&
operator|*
operator|(
name|buf
operator|+
name|rp_len
operator|-
literal|1
operator|)
operator|!=
literal|'\n'
condition|)
block|{
specifier|register
name|char
modifier|*
name|cop
init|=
name|buf
decl_stmt|;
while|while
condition|(
operator|*
operator|(
name|cop
operator|++
operator|)
operator|=
operator|*
operator|(
name|rp_ptr
operator|++
operator|)
condition|)
empty_stmt|;
comment|/* what's left to beginning */
if|if
condition|(
name|fgets
argument_list|(
operator|(
name|cop
operator|-
literal|1
operator|)
argument_list|,
name|rp_len
operator|-
operator|(
name|cop
operator|-
name|buf
operator|)
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unexpected end of input"
argument_list|)
expr_stmt|;
name|rp_ptr
operator|=
name|buf
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	polygon ( string, file )  |  | Results:	draws a polygon specified by the parameters encoded into the  |		string (and from the file, if necessary).  The parameters are  |		broken up into separate vectors.  The vectors are encoded as  |		follows:  (p dx dy curx endy); endy is the bottom of vector,  |		curx is where x starts;  dx, dy are the deltas for the line;  |		if dy is negative, p is the Bresenham line algorithm parameter,  |		otherwise p is the starting y.  All the active vectors must be  |		put first.  |  |		The polygon is filled with a stipple pattern from stip_disp  |		and stip_bits, which point to the stipple font.  The pattern  |		is defined by "stip" and "stipmem".  |  |		The scan-line algorithm implemented scans from top to  |		bottom (low y to high y).  It also scans, within a line,  |		from left to right (low x to high x).  |  | Bugs:	stipple pattern MUST be a power of two bytes "wide" and  |		square.  The square restriction comes from the fact that  |		the varian and versatec are respectively rotated.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|polygon
argument_list|(
argument|buf
argument_list|,
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|nexty
decl_stmt|;
comment|/* at what y value the next vector starts */
name|int
name|maxy
decl_stmt|,
name|miny
decl_stmt|;
comment|/* finds bounds of polygon */
name|polyvector
modifier|*
name|activehead
decl_stmt|;
comment|/* doing fill, is active edge list */
name|polyvector
modifier|*
name|waitinghead
decl_stmt|;
comment|/* edges waiting to be active */
specifier|register
name|polyvector
modifier|*
name|vectptr
decl_stmt|;
comment|/* random vector */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* random register */
name|char
modifier|*
name|topstipple
decl_stmt|;
comment|/* points to beginning of stipple glyph */
name|char
modifier|*
name|leftstipple
decl_stmt|;
comment|/* points to beginning of line of stipple */
name|char
modifier|*
name|leftpage
decl_stmt|;
comment|/* points to the edge of a raster line */
name|int
name|bytewidth
decl_stmt|;
comment|/* glyph width in bytes */
name|int
name|mask
decl_stmt|;
comment|/* mask to pick off pixel index into stipple */
name|int
name|bytemask
decl_stmt|;
comment|/* mask to pick off byte index into stipple */
name|rp_len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* length of the string in "buf" */
name|rp_ptr
operator|=
name|buf
expr_stmt|;
comment|/* "walking" pointer into buf */
comment|/* if no stipple, don't fill */
if|if
condition|(
name|stip_disp
operator|==
operator|(
expr|struct
name|dispatch
operator|*
operator|)
name|NULL
operator|||
name|stip_bits
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|leavepoly
goto|;
name|stip_disp
operator|+=
name|stipmem
expr_stmt|;
comment|/* set up parameters for */
if|if
condition|(
operator|!
name|stip_disp
operator|->
name|nbytes
condition|)
block|{
comment|/* tiling with the stipple */
ifdef|#
directive|ifdef
name|DEBUGABLE
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"member not found: member %d, stipple %d"
argument_list|,
name|stipmem
argument_list|,
name|stip
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|leavepoly
goto|;
block|}
name|topstipple
operator|=
name|stip_bits
operator|+
name|stip_disp
operator|->
name|addr
expr_stmt|;
name|bytewidth
operator|=
name|stip_disp
operator|->
name|up
operator|+
name|stip_disp
operator|->
name|down
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|<<
literal|30
init|;
name|i
operator|&&
name|i
operator|!=
name|bytewidth
condition|;
name|i
operator|=
name|i
operator|>>
literal|1
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|bytewidth
operator|<
literal|8
operator|||
name|bytewidth
operator|!=
name|stip_disp
operator|->
name|right
operator|+
name|stip_disp
operator|->
name|left
condition|)
block|{
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"invalid stipple: number %d, member %d"
argument_list|,
name|stip
argument_list|,
name|stipmem
argument_list|)
expr_stmt|;
goto|goto
name|leavepoly
goto|;
block|}
name|mask
operator|=
name|bytewidth
operator|-
literal|1
expr_stmt|;
name|bytewidth
operator|=
name|bytewidth
operator|>>
literal|3
expr_stmt|;
name|bytemask
operator|=
name|bytewidth
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|read_poly
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|)
operator|)
operator|<
literal|2
condition|)
comment|/* # of vects command holds */
goto|goto
name|leavepoly
goto|;
name|miny
operator|=
name|read_poly
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* get limits from command */
name|maxy
operator|=
name|read_poly
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|leftstipple
operator|=
name|topstipple
operator|+
operator|(
name|miny
operator|&
name|mask
operator|)
operator|*
name|bytewidth
expr_stmt|;
name|leftpage
operator|=
name|buf0p
operator|+
operator|(
name|miny
operator|-
name|vorigin
operator|)
operator|*
name|BYTES_PER_LINE
expr_stmt|;
comment|/* allocate space for raster-fill algorithm*/
name|vectptr
operator|=
operator|(
name|polyvector
operator|*
operator|)
name|nalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|polyvector
argument_list|)
argument_list|,
name|i
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectptr
operator|==
operator|(
name|polyvector
operator|*
operator|)
name|NULL
condition|)
block|{
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"unable to allocate space for polygon"
argument_list|)
expr_stmt|;
return|return;
block|}
name|waitinghead
operator|=
name|vectptr
expr_stmt|;
name|vectptr
operator|->
name|param
operator|=
name|miny
operator|-
literal|1
expr_stmt|;
comment|/* put dummy entry at start */
operator|(
name|vectptr
operator|++
operator|)
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|waitinghead
operator|->
name|next
operator|=
name|vectptr
expr_stmt|;
name|vectptr
operator|->
name|prev
operator|=
name|waitinghead
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|vectptr
operator|->
name|next
operator|=
name|vectptr
operator|+
literal|1
expr_stmt|;
name|vectptr
operator|->
name|param
operator|=
name|read_poly
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|vectptr
operator|->
name|dx
operator|=
name|read_poly
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|vectptr
operator|->
name|dy
operator|=
name|read_poly
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|vectptr
operator|->
name|currx
operator|=
name|read_poly
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|vectptr
operator|++
operator|)
operator|->
name|endy
operator|=
name|read_poly
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|vectptr
operator|->
name|prev
operator|=
name|vectptr
operator|-
literal|1
expr_stmt|;
block|}
name|vectptr
operator|->
name|param
operator|=
name|maxy
operator|+
literal|1
expr_stmt|;
comment|/* dummy entry at end, too */
name|vectptr
operator|->
name|currx
operator|=
name|vectptr
operator|->
name|dx
operator|=
name|vectptr
operator|->
name|dy
operator|=
literal|0
expr_stmt|;
name|vectptr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|activehead
operator|=
operator|++
name|vectptr
expr_stmt|;
comment|/* two dummy entries for active list */
name|vectptr
operator|->
name|currx
operator|=
name|MINX
expr_stmt|;
comment|/* head */
name|vectptr
operator|->
name|endy
operator|=
name|maxy
operator|+
literal|1
expr_stmt|;
name|vectptr
operator|->
name|param
operator|=
name|vectptr
operator|->
name|dx
operator|=
name|vectptr
operator|->
name|dy
operator|=
literal|0
expr_stmt|;
name|activehead
operator|->
name|next
operator|=
operator|++
name|vectptr
expr_stmt|;
name|activehead
operator|->
name|prev
operator|=
name|vectptr
expr_stmt|;
name|vectptr
operator|->
name|prev
operator|=
name|activehead
expr_stmt|;
comment|/* tail */
name|vectptr
operator|->
name|next
operator|=
name|activehead
expr_stmt|;
name|vectptr
operator|->
name|currx
operator|=
name|MAXX
expr_stmt|;
name|vectptr
operator|->
name|endy
operator|=
name|maxy
operator|+
literal|1
expr_stmt|;
name|vectptr
operator|->
name|param
operator|=
name|vectptr
operator|->
name|dx
operator|=
name|vectptr
operator|->
name|dy
operator|=
literal|0
expr_stmt|;
name|vectptr
operator|=
name|waitinghead
operator|->
name|next
expr_stmt|;
comment|/* if anything is active already */
if|if
condition|(
name|vectptr
operator|->
name|dy
operator|<
literal|0
condition|)
block|{
comment|/*   put them into the active list */
specifier|register
name|polyvector
modifier|*
name|p
decl_stmt|;
comment|/* random useful register pointer */
name|p
operator|=
name|vectptr
expr_stmt|;
do|do
block|{
name|vectptr
operator|->
name|dy
operator|=
operator|-
name|vectptr
operator|->
name|dy
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|++
name|vectptr
operator|)
operator|->
name|dy
operator|<
literal|0
condition|)
do|;
name|waitinghead
operator|->
name|next
operator|=
name|vectptr
expr_stmt|;
comment|/* first, remove list from waiting */
operator|(
name|vectptr
operator|--
operator|)
operator|->
name|prev
operator|=
name|waitinghead
expr_stmt|;
name|activehead
operator|->
name|next
operator|->
name|prev
operator|=
name|vectptr
expr_stmt|;
comment|/* link in end */
name|vectptr
operator|->
name|next
operator|=
name|activehead
operator|->
name|next
expr_stmt|;
name|activehead
operator|->
name|next
operator|=
name|p
expr_stmt|;
comment|/* link in start */
name|p
operator|->
name|prev
operator|=
name|activehead
expr_stmt|;
block|}
comment|/* main loop -- gets vectors off the waiting list, */
comment|/* then displays spans while updating the vectors in */
comment|/* the active list */
while|while
condition|(
name|miny
operator|<=
name|maxy
condition|)
block|{
name|i
operator|=
name|maxy
operator|+
literal|1
expr_stmt|;
comment|/* this is the NEXT time to get a new vector */
for|for
control|(
name|vectptr
operator|=
name|waitinghead
operator|->
name|next
init|;
name|vectptr
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|miny
operator|==
name|vectptr
operator|->
name|param
condition|)
block|{
comment|/* the entry in waiting list (vectptr) is */
comment|/*   ready to go into active list.  Need to */
comment|/*   convert some vector stuff and sort the */
comment|/*   entry into the list. */
specifier|register
name|polyvector
modifier|*
name|p
decl_stmt|;
comment|/* random vector pointers */
specifier|register
name|polyvector
modifier|*
name|v
decl_stmt|;
comment|/* convert this */
if|if
condition|(
name|vectptr
operator|->
name|dx
operator|<
literal|0
condition|)
comment|/* entry to active */
name|vectptr
operator|->
name|param
operator|=
operator|-
operator|(
operator|(
name|vectptr
operator|->
name|dx
operator|>>
literal|1
operator|)
operator|+
operator|(
name|vectptr
operator|->
name|dy
operator|>>
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|vectptr
operator|->
name|param
operator|=
operator|(
name|vectptr
operator|->
name|dx
operator|>>
literal|1
operator|)
operator|-
operator|(
name|vectptr
operator|->
name|dy
operator|>>
literal|1
operator|)
expr_stmt|;
name|p
operator|=
name|vectptr
expr_stmt|;
comment|/* remove from the */
name|vectptr
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
comment|/* waiting list */
name|vectptr
operator|->
name|prev
operator|=
name|p
operator|->
name|prev
expr_stmt|;
name|p
operator|->
name|prev
operator|->
name|next
operator|=
name|vectptr
expr_stmt|;
comment|/* find where it goes */
comment|/* in the active list */
comment|/* (sorted smallest first) */
for|for
control|(
name|v
operator|=
name|activehead
operator|->
name|next
init|;
name|v
operator|->
name|currx
operator|<
name|p
operator|->
name|currx
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
empty_stmt|;
name|p
operator|->
name|next
operator|=
name|v
expr_stmt|;
comment|/* insert into active list */
name|p
operator|->
name|prev
operator|=
name|v
operator|->
name|prev
expr_stmt|;
comment|/* before the one it stopped on */
name|v
operator|->
name|prev
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|prev
operator|->
name|next
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|>
name|vectptr
operator|->
name|param
condition|)
block|{
name|i
operator|=
name|vectptr
operator|->
name|param
expr_stmt|;
block|}
name|vectptr
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
block|}
block|}
name|nexty
operator|=
name|i
expr_stmt|;
comment|/* print the polygon while there */
comment|/* are no more vectors to add */
while|while
condition|(
name|miny
operator|<
name|nexty
condition|)
block|{
comment|/* remove any finished vectors */
name|vectptr
operator|=
name|activehead
operator|->
name|next
expr_stmt|;
do|do
block|{
if|if
condition|(
name|vectptr
operator|->
name|endy
operator|<=
name|miny
condition|)
block|{
name|vectptr
operator|->
name|prev
operator|->
name|next
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
name|vectptr
operator|->
name|next
operator|->
name|prev
operator|=
name|vectptr
operator|->
name|prev
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|vectptr
operator|=
name|vectptr
operator|->
name|next
operator|)
operator|!=
name|activehead
condition|)
do|;
comment|/* draw the span */
name|vectptr
operator|=
name|activehead
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|vectptr
operator|->
name|next
operator|!=
name|activehead
condition|)
block|{
specifier|register
name|int
name|start
decl_stmt|;
comment|/* get the beginning */
specifier|register
name|int
name|length
decl_stmt|;
comment|/*   and the end of span */
specifier|register
name|char
modifier|*
name|glyph
decl_stmt|;
specifier|register
name|char
modifier|*
name|raster
decl_stmt|;
name|start
operator|=
name|vectptr
operator|->
name|currx
expr_stmt|;
name|vectptr
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
name|length
operator|=
name|vectptr
operator|->
name|currx
operator|+
literal|1
expr_stmt|;
name|vectptr
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
comment|/* bound the polygon to the page */
if|if
condition|(
name|start
operator|>=
name|RASTER_LENGTH
condition|)
break|break;
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|RASTER_LENGTH
condition|)
name|length
operator|=
name|RASTER_LENGTH
expr_stmt|;
name|length
operator|-=
name|start
expr_stmt|;
comment|/* length is in pixels */
name|i
operator|=
name|start
operator|&
literal|7
expr_stmt|;
name|start
operator|=
name|start
operator|>>
literal|3
expr_stmt|;
comment|/* start is in bytes */
name|raster
operator|=
name|leftpage
operator|+
name|start
expr_stmt|;
name|glyph
operator|=
name|leftstipple
operator|+
operator|(
name|start
operator|&
name|bytemask
operator|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
comment|/* do any piece of byte */
specifier|register
name|char
name|data
decl_stmt|;
comment|/* that hangs on the front */
name|data
operator|=
operator|(
operator|*
operator|(
name|glyph
operator|++
operator|)
operator|)
operator|&
operator|(
literal|0x7f
operator|>>
operator|--
name|i
operator|)
expr_stmt|;
name|length
operator|-=
literal|7
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
comment|/* less than one byte wide? */
name|data
operator|&=
literal|0xff
operator|<<
operator|-
name|length
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
comment|/* force clean stoppage */
block|}
operator|*
operator|(
name|raster
operator|++
operator|)
operator||=
name|data
expr_stmt|;
comment|/* update glyph ptr after first byte */
if|if
condition|(
operator|!
operator|(
operator|++
name|start
operator|&
name|bytemask
operator|)
condition|)
name|glyph
operator|=
name|leftstipple
expr_stmt|;
block|}
comment|/* fill the line of raster */
while|while
condition|(
operator|(
name|length
operator|-=
literal|8
operator|)
operator|>=
literal|0
condition|)
block|{
operator|*
operator|(
name|raster
operator|++
operator|)
operator||=
operator|*
operator|(
name|glyph
operator|++
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|++
name|start
operator|&
name|bytemask
operator|)
condition|)
name|glyph
operator|=
name|leftstipple
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|&
literal|7
condition|)
block|{
comment|/* add any part hanging off the end */
operator|*
name|raster
operator||=
operator|(
operator|*
name|glyph
operator|)
operator|&
operator|(
literal|0xff
operator|<<
operator|-
name|length
operator|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
block|{
name|vectptr
operator|=
name|activehead
expr_stmt|;
do|do
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d "
argument_list|,
name|vectptr
operator|->
name|currx
argument_list|)
expr_stmt|;
name|vectptr
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|vectptr
operator|!=
name|activehead
condition|)
do|;
block|}
endif|#
directive|endif
comment|/* update the vectors */
name|vectptr
operator|=
name|activehead
operator|->
name|next
expr_stmt|;
do|do
block|{
if|if
condition|(
name|vectptr
operator|->
name|dx
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|vectptr
operator|->
name|param
operator|>=
literal|0
condition|)
block|{
name|vectptr
operator|->
name|param
operator|-=
name|vectptr
operator|->
name|dy
expr_stmt|;
name|vectptr
operator|->
name|currx
operator|++
expr_stmt|;
block|}
name|vectptr
operator|->
name|param
operator|+=
name|vectptr
operator|->
name|dx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vectptr
operator|->
name|dx
operator|<
literal|0
condition|)
block|{
while|while
condition|(
name|vectptr
operator|->
name|param
operator|>=
literal|0
condition|)
block|{
name|vectptr
operator|->
name|param
operator|-=
name|vectptr
operator|->
name|dy
expr_stmt|;
name|vectptr
operator|->
name|currx
operator|--
expr_stmt|;
block|}
name|vectptr
operator|->
name|param
operator|-=
name|vectptr
operator|->
name|dx
expr_stmt|;
block|}
comment|/* must sort the vectors if updates */
comment|/* caused them to cross */
comment|/* also move to next vector here */
if|if
condition|(
name|vectptr
operator|->
name|currx
operator|<
name|vectptr
operator|->
name|prev
operator|->
name|currx
condition|)
block|{
specifier|register
name|polyvector
modifier|*
name|v
decl_stmt|;
comment|/* vector to move */
specifier|register
name|polyvector
modifier|*
name|p
decl_stmt|;
comment|/* vector to put it after */
name|v
operator|=
name|vectptr
expr_stmt|;
name|p
operator|=
name|v
operator|->
name|prev
expr_stmt|;
while|while
condition|(
name|v
operator|->
name|currx
operator|<
name|p
operator|->
name|currx
condition|)
comment|/* find the */
name|p
operator|=
name|p
operator|->
name|prev
expr_stmt|;
comment|/* right vector */
name|vectptr
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
comment|/* remove from spot */
name|vectptr
operator|->
name|prev
operator|=
name|v
operator|->
name|prev
expr_stmt|;
name|v
operator|->
name|prev
operator|->
name|next
operator|=
name|vectptr
expr_stmt|;
name|v
operator|->
name|prev
operator|=
name|p
expr_stmt|;
comment|/* put in new spot */
name|v
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|v
expr_stmt|;
name|v
operator|->
name|next
operator|->
name|prev
operator|=
name|v
expr_stmt|;
block|}
else|else
block|{
name|vectptr
operator|=
name|vectptr
operator|->
name|next
expr_stmt|;
block|}
block|}
do|while
condition|(
name|vectptr
operator|!=
name|activehead
condition|)
do|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"line done\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|++
name|miny
operator|&
name|mask
condition|)
block|{
name|leftstipple
operator|+=
name|bytewidth
expr_stmt|;
block|}
else|else
block|{
name|leftstipple
operator|=
name|topstipple
expr_stmt|;
block|}
name|leftpage
operator|+=
name|BYTES_PER_LINE
expr_stmt|;
block|}
comment|/* while (miny< nexty) */
block|}
comment|/* while (miny<= maxy) */
name|nfree
argument_list|(
name|waitinghead
argument_list|)
expr_stmt|;
comment|/* dump the space allocated for polygon */
name|leavepoly
label|:
while|while
condition|(
operator|*
name|rp_ptr
operator|!=
literal|'\n'
condition|)
name|i
operator|=
name|read_poly
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* polygon function */
end_comment

end_unit

