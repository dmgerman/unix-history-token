begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	draw.c	1.7	84/04/13  *  *	This file contains the functions for producing the graphics  *   images in the canon/imagen driver for ditroff.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"canon.h"
end_include

begin_comment
comment|/* imports from dip.c */
end_comment

begin_define
define|#
directive|define
name|FATAL
value|1
end_define

begin_define
define|#
directive|define
name|hmot
parameter_list|(
name|n
parameter_list|)
value|hpos += n;
end_define

begin_define
define|#
directive|define
name|hgoto
parameter_list|(
name|n
parameter_list|)
value|hpos = n;
end_define

begin_define
define|#
directive|define
name|vmot
parameter_list|(
name|n
parameter_list|)
value|vpos += n;
end_define

begin_define
define|#
directive|define
name|vgoto
parameter_list|(
name|n
parameter_list|)
value|vpos = n;
end_define

begin_decl_stmt
specifier|extern
name|int
name|output
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|hpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|vpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|MAXX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|MAXY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|tf
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern putint(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|word
parameter_list|(
name|x
parameter_list|)
value|putint(x,tf)
end_define

begin_define
define|#
directive|define
name|byte
parameter_list|(
name|x
parameter_list|)
value|putc(x,tf)
end_define

begin_define
define|#
directive|define
name|MAXPOINTS
value|200
end_define

begin_comment
comment|/* number of points legal for a curve */
end_comment

begin_define
define|#
directive|define
name|SOLID
value|-1
end_define

begin_comment
comment|/* line styles:  these are used as bit masks to */
end_comment

begin_define
define|#
directive|define
name|DOTTED
value|004
end_define

begin_comment
comment|/* create the right style lines. */
end_comment

begin_define
define|#
directive|define
name|DASHED
value|020
end_define

begin_define
define|#
directive|define
name|DOTDASHED
value|024
end_define

begin_define
define|#
directive|define
name|LONGDASHED
value|074
end_define

begin_comment
comment|/* constants... */
end_comment

begin_define
define|#
directive|define
name|pi
value|3.14159265358979324
end_define

begin_define
define|#
directive|define
name|START
value|1
end_define

begin_define
define|#
directive|define
name|POINT
value|0
end_define

begin_comment
comment|/* the imagen complains if a path is drawn at< 1, or> limit, so truncate. */
end_comment

begin_define
define|#
directive|define
name|xbound
parameter_list|(
name|x
parameter_list|)
value|((x)< 1 ? 1 : (x)> MAXX ? MAXX : (x))
end_define

begin_define
define|#
directive|define
name|ybound
parameter_list|(
name|y
parameter_list|)
value|((y)< 1 ? 1 : (y)> MAXY ? MAXY : (y))
end_define

begin_decl_stmt
name|int
name|linethickness
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pixels wide to make lines */
end_comment

begin_decl_stmt
name|int
name|linmod
init|=
name|SOLID
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type of line (SOLID, DOTTED, DASHED...) */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	drawline (horizontal_motion, vertical_motion)  |  | Results:	Draws a line of "linethickness" width and "linmod" style  |		from current (hpos, vpos) to (hpos + dh, vpos + dv).  |  | Side Efct:	Resulting position is at end of line (hpos + dh, vpos + dv)  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
name|drawline
argument_list|(
name|dh
argument_list|,
name|dv
argument_list|)
specifier|register
name|int
name|dh
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|dv
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|output
condition|)
name|HGtline
argument_list|(
name|hpos
argument_list|,
name|vpos
argument_list|,
name|hpos
operator|+
name|dh
argument_list|,
name|vpos
operator|+
name|dv
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|dh
argument_list|)
expr_stmt|;
comment|/* new position is at */
name|vmot
argument_list|(
name|dv
argument_list|)
expr_stmt|;
comment|/* the end of the line */
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	drawcirc (diameter)  |  | Results:	Draws a circle with leftmost point at current (hpos, vpos)  |		with the given diameter d.  |  | Side Efct:	Resulting position is at (hpos + diameter, vpos)  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
name|drawcirc
argument_list|(
name|d
argument_list|)
specifier|register
name|int
name|d
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* 0.0 is the angle to sweep the arc: = full circle */
if|if
condition|(
name|output
condition|)
name|HGArc
argument_list|(
name|hpos
operator|+
name|d
operator|/
literal|2
argument_list|,
name|vpos
argument_list|,
name|hpos
argument_list|,
name|vpos
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* new postion is the right of the circle */
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	drawellip (horizontal_diameter, vertical_diameter)  |  | Results:	Draws regular ellipses given the major "diameters."  It does  |		so by drawing many small lines along the ellipses perimeter.  |		The algorithm is a modified (bresenham-like) circle algorithm  |  | Side Efct:	Resulting position is at (hpos + hd, vpos).  |  | Bugs:	Odd numbered horizontal axes are rounded up to even numbers.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|drawellip
argument_list|(
argument|hd
argument_list|,
argument|vd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|hd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|xs
decl_stmt|,
name|ys
decl_stmt|,
name|xepsilon
decl_stmt|,
name|yepsilon
decl_stmt|;
comment|/* ellipse-calculation vairables */
specifier|register
name|int
name|basex
decl_stmt|;
comment|/* center of the ellipse */
specifier|register
name|int
name|basey
decl_stmt|;
specifier|register
name|int
name|mask
decl_stmt|;
comment|/* used to skip points on the ellipse */
specifier|register
name|int
name|extent
decl_stmt|;
comment|/* number of points to produce */
name|basex
operator|=
name|hpos
operator|+
operator|(
name|hd
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* set the center of the ellipse */
name|basey
operator|=
name|vpos
expr_stmt|;
name|hmot
argument_list|(
name|hd
argument_list|)
expr_stmt|;
comment|/* troff motion done here, once. */
if|if
condition|(
operator|(
name|hd
operator|=
name|hd
operator|>>
literal|1
operator|)
operator|<
literal|1
condition|)
name|hd
operator|=
literal|1
expr_stmt|;
comment|/* hd and vd are like radii */
if|if
condition|(
operator|(
name|vd
operator|=
name|vd
operator|>>
literal|1
operator|)
operator|<
literal|1
condition|)
name|vd
operator|=
literal|1
expr_stmt|;
name|ys
operator|=
operator|(
name|double
operator|)
name|vd
expr_stmt|;
comment|/* initial distances from center to perimeter */
name|xs
operator|=
literal|0.0
expr_stmt|;
comment|/* calculate drawing parameters */
if|if
condition|(
name|vd
operator|>
name|hd
condition|)
block|{
name|xepsilon
operator|=
operator|(
name|double
operator|)
name|hd
operator|/
call|(
name|double
call|)
argument_list|(
name|vd
operator|*
name|vd
argument_list|)
expr_stmt|;
name|yepsilon
operator|=
literal|1.0
operator|/
operator|(
name|double
operator|)
name|hd
expr_stmt|;
name|extent
operator|=
literal|6
operator|*
name|vd
operator|+
operator|(
name|vd
operator|>>
literal|1
operator|)
expr_stmt|;
name|mask
operator|=
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|log10
argument_list|(
literal|5.0
operator|/
name|xepsilon
operator|+
literal|1.0
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|xepsilon
operator|=
literal|1.0
operator|/
operator|(
name|double
operator|)
name|vd
expr_stmt|;
name|yepsilon
operator|=
operator|(
name|double
operator|)
name|vd
operator|/
call|(
name|double
call|)
argument_list|(
name|hd
operator|*
name|hd
argument_list|)
expr_stmt|;
name|extent
operator|=
literal|6
operator|*
name|hd
operator|+
operator|(
name|hd
operator|>>
literal|1
operator|)
expr_stmt|;
name|mask
operator|=
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|log10
argument_list|(
literal|5.0
operator|/
name|yepsilon
operator|+
literal|1.0
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|byte
argument_list|(
name|ASPATH
argument_list|)
expr_stmt|;
comment|/* start path definition */
name|word
argument_list|(
literal|2
operator|+
operator|(
name|extent
operator|-
literal|1
operator|)
operator|/
operator|(
name|mask
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* number of points */
name|word
argument_list|(
name|xbound
argument_list|(
name|basex
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|ybound
argument_list|(
name|basey
operator|+
name|vd
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|extent
operator|>=
literal|0
condition|)
block|{
name|xs
operator|+=
name|xepsilon
operator|*
name|ys
expr_stmt|;
name|ys
operator|-=
name|yepsilon
operator|*
name|xs
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|extent
operator|&
name|mask
operator|)
condition|)
block|{
comment|/* put out a point on ellipse */
name|word
argument_list|(
name|xbound
argument_list|(
name|basex
operator|+
call|(
name|int
call|)
argument_list|(
literal|0.5
operator|+
name|xs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|ybound
argument_list|(
name|basey
operator|+
call|(
name|int
call|)
argument_list|(
literal|0.5
operator|+
name|ys
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|byte
argument_list|(
name|ADRAW
argument_list|)
expr_stmt|;
comment|/* now draw the arc */
name|byte
argument_list|(
literal|15
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	drawarc (xcenter, ycenter, xpoint, ypoint)  |  | Results:	Draws an arc starting at current (hpos, vpos).  Center is  |		at (hpos + cdh, vpos + cdv) and the terminating point is  |		at<center> + (pdh, pdv).  The angle between the lines  |		formed by the starting, ending, and center points is figured  |		first, then the points and angle are sent to HGArc for the  |		drawing.  |  | Side Efct:	Resulting position is at the last point of the arc.  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
name|drawarc
argument_list|(
name|cdh
argument_list|,
name|cdv
argument_list|,
name|pdh
argument_list|,
name|pdv
argument_list|)
specifier|register
name|int
name|cdh
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|cdv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|pdh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|pdv
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|double
name|angle
decl_stmt|;
comment|/* figure angle from the three points...*/
comment|/* and convert (and round) to degrees */
name|angle
operator|=
operator|(
name|atan2
argument_list|(
operator|(
name|double
operator|)
name|pdh
argument_list|,
operator|(
name|double
operator|)
name|pdv
argument_list|)
operator|-
name|atan2
argument_list|(
operator|(
name|double
operator|)
operator|-
name|cdh
argument_list|,
operator|(
name|double
operator|)
operator|-
name|cdv
argument_list|)
operator|)
operator|*
literal|180.0
operator|/
name|pi
expr_stmt|;
comment|/* "normalize" and round */
name|angle
operator|+=
operator|(
name|angle
operator|<
literal|0.0
operator|)
condition|?
literal|360.5
else|:
literal|0.5
expr_stmt|;
if|if
condition|(
name|output
condition|)
name|HGArc
argument_list|(
name|hpos
operator|+
name|cdh
argument_list|,
name|vpos
operator|+
name|cdv
argument_list|,
name|hpos
argument_list|,
name|vpos
argument_list|,
operator|(
name|int
operator|)
name|angle
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|cdh
operator|+
name|pdh
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|cdv
operator|+
name|pdv
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	drawwig (character_buffer, file_pointer, type_flag)  |  | Results:	Given the starting position, the motion list in buf, and any  |		extra characters from fp (terminated by a \n), drawwig sets  |		up a point list to make a spline from.  If "pic" is set picurve  |		is called to draw the curve in pic style; else it calls HGCurve  |		for the gremlin-style curve.  |  | Side Efct:	Resulting position is reached from adding successive motions  |		to the current position.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|drawwig
argument_list|(
argument|buf
argument_list|,
argument|fp
argument_list|,
argument|pic
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pic
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
comment|/* length of the string in "buf" */
specifier|register
name|int
name|npts
init|=
literal|2
decl_stmt|;
comment|/* point list index */
specifier|register
name|char
modifier|*
name|ptr
init|=
name|buf
decl_stmt|;
comment|/* "walking" pointer into buf */
name|int
name|x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
comment|/* point list */
while|while
condition|(
operator|*
name|ptr
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/* skip any leading spaces */
name|x
index|[
literal|1
index|]
operator|=
name|hpos
expr_stmt|;
comment|/* the curve starts at the */
name|y
index|[
literal|1
index|]
operator|=
name|vpos
expr_stmt|;
comment|/* current position */
while|while
condition|(
operator|*
name|ptr
operator|!=
literal|'\n'
condition|)
block|{
comment|/* curve commands end with a '\n' */
name|hmot
argument_list|(
name|atoi
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* convert motion to curve points */
name|x
index|[
name|npts
index|]
operator|=
name|hpos
expr_stmt|;
comment|/* and remember them */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|ptr
argument_list|)
condition|)
empty_stmt|;
comment|/* skip number*/
while|while
condition|(
operator|*
operator|++
name|ptr
operator|==
literal|' '
condition|)
empty_stmt|;
comment|/* skip spaces 'tween numbers */
name|vmot
argument_list|(
name|atoi
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|y
index|[
name|npts
index|]
operator|=
name|vpos
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|ptr
argument_list|)
condition|)
empty_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/* if the amount we read wasn't the */
comment|/*    whole thing, read some more in */
if|if
condition|(
name|len
operator|-
operator|(
name|ptr
operator|-
name|buf
operator|)
operator|<
literal|15
operator|&&
operator|*
operator|(
name|buf
operator|+
name|len
operator|-
literal|1
operator|)
operator|!=
literal|'\n'
condition|)
block|{
name|char
modifier|*
name|cop
init|=
name|buf
decl_stmt|;
while|while
condition|(
operator|*
name|cop
operator|++
operator|=
operator|*
name|ptr
operator|++
condition|)
empty_stmt|;
comment|/* copy what's left to the beginning */
if|if
condition|(
name|fgets
argument_list|(
operator|(
name|cop
operator|-
literal|1
operator|)
argument_list|,
name|len
operator|-
operator|(
name|cop
operator|-
name|buf
operator|)
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unexpected end of input"
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|npts
operator|<
name|MAXPOINTS
operator|-
literal|1
condition|)
comment|/* if too many points, forget some */
name|npts
operator|++
expr_stmt|;
block|}
name|npts
operator|--
expr_stmt|;
comment|/* npts must point to the last coordinate in x and y */
comment|/* now, actually DO the curve */
if|if
condition|(
name|output
condition|)
block|{
if|if
condition|(
name|pic
operator|>
literal|0
condition|)
name|picurve
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|npts
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pic
operator|<
literal|0
condition|)
name|polygon
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|npts
argument_list|)
expr_stmt|;
else|else
name|HGCurve
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|npts
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	drawthick (thickness)  |  | Results:	sets the variable "linethickness" to the given size.  If this  |		is different than previous thiknesses, informs Imagen of the  |		change.  NO motion is involved.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|drawthick
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|linethickness
operator|!=
name|s
condition|)
block|{
name|byte
argument_list|(
name|ASPEN
argument_list|)
expr_stmt|;
name|byte
argument_list|(
operator|(
name|linethickness
operator|=
name|s
operator|)
operator|<
literal|1
condition|?
literal|1
else|:
name|linethickness
operator|>
name|MAXPENW
condition|?
name|MAXPENW
else|:
name|linethickness
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	drawstyle (style_bit_map)  |  | Results:	sets the variable "linmod" to the given bit map.  |		NO motion is involved.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|drawstyle
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|linmod
operator|=
name|s
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	polygon (xpoints, ypoints, num_of_points)  |  | Results:	draws a polygon through the points (xpoints, ypoints).  |		The polygon has a raster fill associated with it.  The  |		fill is already set up from conv(), but if the stipple  |		pattern "laststipmem" is zero, polygon draws a "clear"  |		polygon.  |  | Bugs:	If the path is not closed, polygon will NOT close it.  |		(or is that a feature?)  |		polygons are affected by line thickness, but NOT line style.  |		if the path is "counterclockwise", it'll slow down the  |		Imagen's rendering.  This is not checked for here.  *----------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|extern
name|int
name|laststipmem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* this is set, before this routine, to the */
end_comment

begin_comment
comment|/* stipple member number to be printed.  If */
end_comment

begin_comment
comment|/* it's zero, the path should not be filled */
end_comment

begin_macro
name|polygon
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|npts
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|npts
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|byte
argument_list|(
name|ASPATH
argument_list|)
expr_stmt|;
comment|/* set up to send the path */
name|word
argument_list|(
name|npts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|npts
condition|;
name|i
operator|++
control|)
block|{
comment|/* send the path */
name|word
argument_list|(
name|xbound
argument_list|(
name|x
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|ybound
argument_list|(
name|y
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|byte
argument_list|(
name|ADRAW
argument_list|)
expr_stmt|;
name|byte
argument_list|(
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
name|laststipmem
condition|)
block|{
comment|/* draw a filled path, if requested */
name|byte
argument_list|(
name|AFPATH
argument_list|)
expr_stmt|;
name|byte
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	picurve (xpoints, ypoints, num_of_points)  |  | Results:	Draws a curve delimited by (not through) the line segments  |		traced by (xpoints, ypoints) point list.  This is the "Pic"  |		style curve.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|picurve
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|npts
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|npts
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* line segment traverser */
specifier|register
name|float
name|w
decl_stmt|;
comment|/* position factor */
specifier|register
name|int
name|xp
decl_stmt|;
comment|/* current point (and intermediary) */
specifier|register
name|int
name|yp
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
comment|/* inner curve segment traverser */
specifier|register
name|int
name|nseg
decl_stmt|;
comment|/* effective resolution for each curve */
specifier|register
name|int
name|pxp
decl_stmt|,
name|pyp
decl_stmt|;
comment|/* "previous" line segments' end */
name|float
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
comment|/* calculation temps */
if|if
condition|(
name|x
index|[
literal|1
index|]
operator|==
name|x
index|[
name|npts
index|]
operator|&&
name|y
index|[
literal|1
index|]
operator|==
name|y
index|[
name|npts
index|]
condition|)
block|{
name|x
index|[
literal|0
index|]
operator|=
name|x
index|[
name|npts
operator|-
literal|1
index|]
expr_stmt|;
comment|/* if the lines' ends meet, make */
name|y
index|[
literal|0
index|]
operator|=
name|y
index|[
name|npts
operator|-
literal|1
index|]
expr_stmt|;
comment|/* sure the curve meets */
name|x
index|[
name|npts
operator|+
literal|1
index|]
operator|=
name|x
index|[
literal|2
index|]
expr_stmt|;
name|y
index|[
name|npts
operator|+
literal|1
index|]
operator|=
name|y
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* otherwise, make the ends of the */
name|x
index|[
literal|0
index|]
operator|=
name|x
index|[
literal|1
index|]
expr_stmt|;
comment|/* curve touch the ending points of */
name|y
index|[
literal|0
index|]
operator|=
name|y
index|[
literal|1
index|]
expr_stmt|;
comment|/* the line segments */
name|x
index|[
name|npts
operator|+
literal|1
index|]
operator|=
name|x
index|[
name|npts
index|]
expr_stmt|;
name|y
index|[
name|npts
operator|+
literal|1
index|]
operator|=
name|y
index|[
name|npts
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npts
condition|;
name|i
operator|++
control|)
block|{
comment|/* traverse the line segments */
name|xp
operator|=
name|x
index|[
name|i
index|]
operator|-
name|x
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|yp
operator|=
name|y
index|[
name|i
index|]
operator|-
name|y
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|nseg
operator|=
operator|(
name|int
operator|)
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|xp
operator|*
name|xp
operator|+
name|yp
operator|*
name|yp
argument_list|)
argument_list|)
expr_stmt|;
name|xp
operator|=
name|x
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|x
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|yp
operator|=
name|y
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|y
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
comment|/* "nseg" is the number of line */
comment|/* segments that will be drawn for */
comment|/* each curve segment.  ">> 3" is */
comment|/* dropping the resolution ( == / 8) */
name|nseg
operator|=
operator|(
name|nseg
operator|+
operator|(
name|int
operator|)
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|xp
operator|*
name|xp
operator|+
name|yp
operator|*
name|yp
argument_list|)
argument_list|)
operator|)
operator|>>
literal|3
expr_stmt|;
name|pxp
operator|=
operator|(
name|x
index|[
name|i
index|]
operator|+
name|x
index|[
name|i
operator|+
literal|1
index|]
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
comment|/* the start of the first line seg */
name|pyp
operator|=
operator|(
name|y
index|[
name|i
index|]
operator|+
name|y
index|[
name|i
operator|+
literal|1
index|]
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|nseg
condition|;
name|j
operator|++
control|)
block|{
name|w
operator|=
operator|(
name|float
operator|)
name|j
operator|/
operator|(
name|float
operator|)
name|nseg
expr_stmt|;
name|t1
operator|=
literal|0.5
operator|*
name|w
operator|*
name|w
expr_stmt|;
name|w
operator|-=
literal|0.5
expr_stmt|;
name|t2
operator|=
literal|0.75
operator|-
name|w
operator|*
name|w
expr_stmt|;
name|w
operator|-=
literal|0.5
expr_stmt|;
name|t3
operator|=
literal|0.5
operator|*
name|w
operator|*
name|w
expr_stmt|;
name|xp
operator|=
name|t1
operator|*
name|x
index|[
name|i
operator|+
literal|2
index|]
operator|+
name|t2
operator|*
name|x
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|t3
operator|*
name|x
index|[
name|i
index|]
operator|+
literal|0.5
expr_stmt|;
name|yp
operator|=
name|t1
operator|*
name|y
index|[
name|i
operator|+
literal|2
index|]
operator|+
name|t2
operator|*
name|y
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|t3
operator|*
name|y
index|[
name|i
index|]
operator|+
literal|0.5
expr_stmt|;
name|HGtline
argument_list|(
name|pxp
argument_list|,
name|pyp
argument_list|,
name|xp
argument_list|,
name|yp
argument_list|)
expr_stmt|;
name|pxp
operator|=
name|xp
expr_stmt|;
name|pyp
operator|=
name|yp
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	HGArc (xcenter, ycenter, xstart, ystart, angle)  |  | Results:	This routine plots an arc centered about (cx, cy) counter  |		clockwise starting from the point (px, py) through 'angle'  |		degrees.  If angle is 0, a full circle is drawn. It does so  |		by creating a draw-path around the arc whose density of  |		points depends on the size of the arc.  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
name|HGArc
argument_list|(
name|cx
argument_list|,
name|cy
argument_list|,
name|px
argument_list|,
name|py
argument_list|,
name|angle
argument_list|)
specifier|register
name|int
name|cx
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|cy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|px
decl_stmt|,
name|py
decl_stmt|,
name|angle
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|xs
decl_stmt|,
name|ys
decl_stmt|,
name|resolution
decl_stmt|,
name|fullcircle
decl_stmt|;
specifier|register
name|int
name|mask
decl_stmt|;
specifier|register
name|int
name|extent
decl_stmt|;
specifier|register
name|int
name|nx
decl_stmt|;
specifier|register
name|int
name|ny
decl_stmt|;
specifier|register
name|double
name|epsilon
decl_stmt|;
name|xs
operator|=
name|px
operator|-
name|cx
expr_stmt|;
name|ys
operator|=
name|py
operator|-
name|cy
expr_stmt|;
comment|/* calculate how fine to make the lines that build 		   the circle.  Resolution cannot be dropped, but 		   mask is used to skip some points for larger 		   arcs due to Imagen's path length limitations */
name|resolution
operator|=
name|sqrt
argument_list|(
name|xs
operator|*
name|xs
operator|+
name|ys
operator|*
name|ys
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|log10
argument_list|(
name|resolution
operator|+
literal|1.0
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
name|epsilon
operator|=
literal|1.0
operator|/
name|resolution
expr_stmt|;
name|fullcircle
operator|=
operator|(
literal|2.0
operator|*
name|pi
operator|)
operator|*
name|resolution
expr_stmt|;
if|if
condition|(
name|angle
operator|==
literal|0
condition|)
name|extent
operator|=
name|fullcircle
expr_stmt|;
else|else
name|extent
operator|=
name|angle
operator|*
name|fullcircle
operator|/
literal|360.0
expr_stmt|;
name|byte
argument_list|(
name|ASPATH
argument_list|)
expr_stmt|;
comment|/* start path definition */
if|if
condition|(
name|extent
operator|>
literal|1
condition|)
block|{
name|word
argument_list|(
literal|2
operator|+
operator|(
name|extent
operator|-
literal|1
operator|)
operator|/
operator|(
name|mask
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* number of points */
name|word
argument_list|(
name|xbound
argument_list|(
name|px
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|ybound
argument_list|(
name|py
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|extent
operator|>=
literal|0
condition|)
block|{
name|xs
operator|+=
name|epsilon
operator|*
name|ys
expr_stmt|;
name|nx
operator|=
name|cx
operator|+
call|(
name|int
call|)
argument_list|(
name|xs
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|ys
operator|-=
name|epsilon
operator|*
name|xs
expr_stmt|;
name|ny
operator|=
name|cy
operator|+
call|(
name|int
call|)
argument_list|(
name|ys
operator|+
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|extent
operator|&
name|mask
operator|)
condition|)
block|{
name|word
argument_list|(
name|xbound
argument_list|(
name|nx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* put out a point on circle */
name|word
argument_list|(
name|ybound
argument_list|(
name|ny
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end for */
block|}
else|else
block|{
comment|/* arc is too small: put out point */
name|word
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|xbound
argument_list|(
name|px
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|ybound
argument_list|(
name|py
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|xbound
argument_list|(
name|px
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|ybound
argument_list|(
name|py
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|byte
argument_list|(
name|ADRAW
argument_list|)
expr_stmt|;
comment|/* now draw the arc */
name|byte
argument_list|(
literal|15
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end HGArc */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	Paramaterize (xpoints, ypoints, hparams, num_points)  |  | Results:	This routine calculates parameteric values for use in  |		calculating curves.  The parametric values are returned  |		in the array h.  The values are an approximation of  |		cumulative arc lengths of the curve (uses cord length).  |		For additional information, see paper cited below.  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
specifier|static
name|Paramaterize
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|h
argument_list|,
argument|n
argument_list|)
name|int
name|x
index|[
name|MAXPOINTS
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|h
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|dx
decl_stmt|;
specifier|register
name|int
name|dy
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|float
name|u
index|[
name|MAXPOINTS
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
operator|++
name|i
control|)
block|{
name|u
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|dx
operator|=
name|x
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|x
index|[
name|j
index|]
expr_stmt|;
name|dy
operator|=
name|y
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|y
index|[
name|j
index|]
expr_stmt|;
name|u
index|[
name|i
index|]
operator|+=
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|dx
operator|*
name|dx
operator|+
name|dy
operator|*
name|dy
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|h
index|[
name|i
index|]
operator|=
name|u
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|u
index|[
name|i
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end Paramaterize */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	PeriodicSpline (h, z, dz, d2z, d3z, npoints)  |  | Results:	This routine solves for the cubic polynomial to fit a  |		spline curve to the the points  specified by the list  |		of values.  The Curve generated is periodic.  The algorithms  |		for this curve are from the "Spline Curve Techniques" paper  |		cited below.  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
specifier|static
name|PeriodicSpline
argument_list|(
argument|h
argument_list|,
argument|z
argument_list|,
argument|dz
argument_list|,
argument|d2z
argument_list|,
argument|d3z
argument_list|,
argument|npoints
argument_list|)
name|float
name|h
index|[
name|MAXPOINTS
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* paramaterization  */
end_comment

begin_decl_stmt
name|int
name|z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* point list */
end_comment

begin_decl_stmt
name|float
name|dz
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to return the 1st derivative */
end_comment

begin_decl_stmt
name|float
name|d2z
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2nd and 3rd derivatives */
end_comment

begin_decl_stmt
name|int
name|npoints
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of valid points */
end_comment

begin_block
block|{
name|float
name|d
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|deltaz
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|a
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|b
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|c
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|r
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|s
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* step 1 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
name|deltaz
index|[
name|i
index|]
operator|=
name|h
index|[
name|i
index|]
condition|?
operator|(
call|(
name|double
call|)
argument_list|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|z
index|[
name|i
index|]
argument_list|)
operator|)
operator|/
name|h
index|[
name|i
index|]
else|:
literal|0
expr_stmt|;
block|}
name|h
index|[
literal|0
index|]
operator|=
name|h
index|[
name|npoints
operator|-
literal|1
index|]
expr_stmt|;
name|deltaz
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
name|npoints
operator|-
literal|1
index|]
expr_stmt|;
comment|/* step 2 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|deltaz
index|[
name|i
index|]
expr_stmt|;
block|}
name|d
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
literal|1
index|]
operator|-
name|deltaz
index|[
literal|0
index|]
expr_stmt|;
comment|/* step 3a */
name|a
index|[
literal|1
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
literal|0
index|]
operator|+
name|h
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
name|d
index|[
literal|0
index|]
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
name|h
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|a
index|[
name|i
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|h
index|[
name|i
index|]
operator|)
operator|-
name|pow
argument_list|(
operator|(
name|double
operator|)
name|h
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
operator|(
name|double
operator|)
literal|2.0
argument_list|)
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|b
index|[
name|i
index|]
operator|=
name|d
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|h
index|[
name|i
operator|-
literal|1
index|]
operator|*
name|b
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|c
index|[
name|i
index|]
operator|=
operator|-
name|h
index|[
name|i
operator|-
literal|1
index|]
operator|*
name|c
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* step 3b */
name|r
index|[
name|npoints
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|s
index|[
name|npoints
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|npoints
operator|-
literal|2
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|r
index|[
name|i
index|]
operator|=
operator|-
operator|(
name|h
index|[
name|i
index|]
operator|*
name|r
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|c
index|[
name|i
index|]
operator|)
operator|/
name|a
index|[
name|i
index|]
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
operator|(
literal|6
operator|*
name|b
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
name|s
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
name|a
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* step 4 */
name|d2z
index|[
name|npoints
operator|-
literal|1
index|]
operator|=
operator|(
literal|6
operator|*
name|d
index|[
name|npoints
operator|-
literal|2
index|]
operator|-
name|h
index|[
literal|0
index|]
operator|*
name|s
index|[
literal|1
index|]
operator|-
name|h
index|[
name|npoints
operator|-
literal|1
index|]
operator|*
name|s
index|[
name|npoints
operator|-
literal|2
index|]
operator|)
operator|/
operator|(
name|h
index|[
literal|0
index|]
operator|*
name|r
index|[
literal|1
index|]
operator|+
name|h
index|[
name|npoints
operator|-
literal|1
index|]
operator|*
name|r
index|[
name|npoints
operator|-
literal|2
index|]
operator|+
literal|2
operator|*
operator|(
name|h
index|[
name|npoints
operator|-
literal|2
index|]
operator|+
name|h
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d2z
index|[
name|i
index|]
operator|=
name|r
index|[
name|i
index|]
operator|*
name|d2z
index|[
name|npoints
operator|-
literal|1
index|]
operator|+
name|s
index|[
name|i
index|]
expr_stmt|;
block|}
name|d2z
index|[
name|npoints
index|]
operator|=
name|d2z
index|[
literal|1
index|]
expr_stmt|;
comment|/* step 5 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
name|dz
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
operator|(
literal|2
operator|*
name|d2z
index|[
name|i
index|]
operator|+
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
literal|6
expr_stmt|;
name|d3z
index|[
name|i
index|]
operator|=
name|h
index|[
name|i
index|]
condition|?
operator|(
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|d2z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
else|:
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end PeriodicSpline */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	NaturalEndSpline (h, z, dz, d2z, d3z, npoints)  |  | Results:	This routine solves for the cubic polynomial to fit a  |		spline curve the the points  specified by the list of  |		values.  The alogrithms for this curve are from the  |		"Spline Curve Techniques" paper cited below.  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
specifier|static
name|NaturalEndSpline
argument_list|(
argument|h
argument_list|,
argument|z
argument_list|,
argument|dz
argument_list|,
argument|d2z
argument_list|,
argument|d3z
argument_list|,
argument|npoints
argument_list|)
name|float
name|h
index|[
name|MAXPOINTS
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* parameterization */
end_comment

begin_decl_stmt
name|int
name|z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Point list */
end_comment

begin_decl_stmt
name|float
name|dz
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to return the 1st derivative */
end_comment

begin_decl_stmt
name|float
name|d2z
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2nd and 3rd derivatives */
end_comment

begin_decl_stmt
name|int
name|npoints
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of valid points */
end_comment

begin_block
block|{
name|float
name|d
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|deltaz
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|a
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|b
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* step 1 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
name|deltaz
index|[
name|i
index|]
operator|=
name|h
index|[
name|i
index|]
condition|?
operator|(
call|(
name|double
call|)
argument_list|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|z
index|[
name|i
index|]
argument_list|)
operator|)
operator|/
name|h
index|[
name|i
index|]
else|:
literal|0
expr_stmt|;
block|}
name|deltaz
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
name|npoints
operator|-
literal|1
index|]
expr_stmt|;
comment|/* step 2 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|deltaz
index|[
name|i
index|]
expr_stmt|;
block|}
name|d
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
literal|1
index|]
operator|-
name|deltaz
index|[
literal|0
index|]
expr_stmt|;
comment|/* step 3 */
name|a
index|[
literal|0
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
literal|2
index|]
operator|+
name|h
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|d
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|a
index|[
name|i
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|h
index|[
name|i
operator|+
literal|2
index|]
operator|)
operator|-
name|pow
argument_list|(
operator|(
name|double
operator|)
name|h
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|(
name|double
operator|)
literal|2.0
argument_list|)
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|b
index|[
name|i
index|]
operator|=
name|d
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|h
index|[
name|i
operator|+
literal|1
index|]
operator|*
name|b
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* step 4 */
name|d2z
index|[
name|npoints
index|]
operator|=
name|d2z
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|npoints
operator|-
literal|1
init|;
name|i
operator|>
literal|1
condition|;
operator|--
name|i
control|)
block|{
name|d2z
index|[
name|i
index|]
operator|=
operator|(
literal|6
operator|*
name|b
index|[
name|i
operator|-
literal|2
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
name|a
index|[
name|i
operator|-
literal|2
index|]
expr_stmt|;
block|}
comment|/* step 5 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
name|dz
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
operator|(
literal|2
operator|*
name|d2z
index|[
name|i
index|]
operator|+
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
literal|6
expr_stmt|;
name|d3z
index|[
name|i
index|]
operator|=
name|h
index|[
name|i
index|]
condition|?
operator|(
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|d2z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
else|:
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end NaturalEndSpline */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	HGCurve(xpoints, ypoints, num_points)  |  | Results:	This routine generates a smooth curve through a set of points.  |		The method used is the parametric spline curve on unit knot  |		mesh described in "Spline Curve Techniques" by Patrick  |		Baudelaire, Robert Flegal, and Robert Sproull -- Xerox Parc.  *----------------------------------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|PointsPerInterval
value|32
end_define

begin_macro
name|HGCurve
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|numpoints
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numpoints
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|float
name|h
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|dx
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|dy
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|d2x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d2y
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|t
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|nx
decl_stmt|;
specifier|register
name|int
name|ny
decl_stmt|;
name|int
name|lx
decl_stmt|,
name|ly
decl_stmt|;
name|lx
operator|=
name|x
index|[
literal|1
index|]
expr_stmt|;
name|ly
operator|=
name|y
index|[
literal|1
index|]
expr_stmt|;
comment|/* Solve for derivatives of the curve at each point                * separately for x and y (parametric). 	      */
name|Paramaterize
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|h
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
comment|/* closed curve */
if|if
condition|(
operator|(
name|x
index|[
literal|1
index|]
operator|==
name|x
index|[
name|numpoints
index|]
operator|)
operator|&&
operator|(
name|y
index|[
literal|1
index|]
operator|==
name|y
index|[
name|numpoints
index|]
operator|)
condition|)
block|{
name|PeriodicSpline
argument_list|(
name|h
argument_list|,
name|x
argument_list|,
name|dx
argument_list|,
name|d2x
argument_list|,
name|d3x
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
name|PeriodicSpline
argument_list|(
name|h
argument_list|,
name|y
argument_list|,
name|dy
argument_list|,
name|d2y
argument_list|,
name|d3y
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NaturalEndSpline
argument_list|(
name|h
argument_list|,
name|x
argument_list|,
name|dx
argument_list|,
name|d2x
argument_list|,
name|d3x
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
name|NaturalEndSpline
argument_list|(
name|h
argument_list|,
name|y
argument_list|,
name|dy
argument_list|,
name|d2y
argument_list|,
name|d3y
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
block|}
comment|/* generate the curve using the above information and  	       * PointsPerInterval vectors between each specified knot. 	       */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|numpoints
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|(
name|x
index|[
name|j
index|]
operator|==
name|x
index|[
name|j
operator|+
literal|1
index|]
operator|)
operator|&&
operator|(
name|y
index|[
name|j
index|]
operator|==
name|y
index|[
name|j
operator|+
literal|1
index|]
operator|)
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|PointsPerInterval
condition|;
operator|++
name|k
control|)
block|{
name|t
operator|=
operator|(
name|float
operator|)
name|k
operator|*
name|h
index|[
name|j
index|]
operator|/
operator|(
name|float
operator|)
name|PointsPerInterval
expr_stmt|;
name|t2
operator|=
name|t
operator|*
name|t
expr_stmt|;
name|t3
operator|=
name|t
operator|*
name|t
operator|*
name|t
expr_stmt|;
name|nx
operator|=
name|x
index|[
name|j
index|]
operator|+
call|(
name|int
call|)
argument_list|(
name|t
operator|*
name|dx
index|[
name|j
index|]
operator|+
name|t2
operator|*
name|d2x
index|[
name|j
index|]
operator|/
literal|2
operator|+
name|t3
operator|*
name|d3x
index|[
name|j
index|]
operator|/
literal|6
argument_list|)
expr_stmt|;
name|ny
operator|=
name|y
index|[
name|j
index|]
operator|+
call|(
name|int
call|)
argument_list|(
name|t
operator|*
name|dy
index|[
name|j
index|]
operator|+
name|t2
operator|*
name|d2y
index|[
name|j
index|]
operator|/
literal|2
operator|+
name|t3
operator|*
name|d3y
index|[
name|j
index|]
operator|/
literal|6
argument_list|)
expr_stmt|;
name|HGtline
argument_list|(
name|lx
argument_list|,
name|ly
argument_list|,
name|nx
argument_list|,
name|ny
argument_list|)
expr_stmt|;
name|lx
operator|=
name|nx
expr_stmt|;
name|ly
operator|=
name|ny
expr_stmt|;
block|}
comment|/* end for k */
block|}
comment|/* end for j */
block|}
end_block

begin_comment
comment|/* end HGCurve */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	line(xstart, ystart, xend, yend)  |  | Results:	Creates a drawing path and draws the line.  If the line falls  |		off the end of the page, a crude clipping is done:  truncating  |		the offending ordinate.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|line
argument_list|(
argument|x0
argument_list|,
argument|y0
argument_list|,
argument|x1
argument_list|,
argument|y1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|byte
argument_list|(
name|ASPATH
argument_list|)
expr_stmt|;
comment|/* send the coordinates first */
name|word
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* only two */
name|word
argument_list|(
name|xbound
argument_list|(
name|x0
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|ybound
argument_list|(
name|y0
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|xbound
argument_list|(
name|x1
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|ybound
argument_list|(
name|y1
argument_list|)
argument_list|)
expr_stmt|;
name|byte
argument_list|(
name|ADRAW
argument_list|)
expr_stmt|;
comment|/* now draw it */
name|byte
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|/* black */
block|}
end_block

begin_comment
comment|/* end line */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	change (x_position, y_position, visible_flag)  |  | Results:	As HGtline passes from the invisible to visible (or vice  |		versa) portion of a line, change is called to either draw  |		the line, or initialize the beginning of the next one.  |		Change calls line to draw segments if visible_flag is set  |		(which means we're leaving a visible area).  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
name|change
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|vis
argument_list|)
specifier|register
name|int
name|x
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|y
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|vis
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|xorg
decl_stmt|;
specifier|static
name|int
name|yorg
decl_stmt|;
if|if
condition|(
name|vis
condition|)
comment|/* leaving a visible area, draw it. */
name|line
argument_list|(
name|xorg
argument_list|,
name|yorg
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* otherwise, we're entering one, remember beginning */
name|xorg
operator|=
name|x
expr_stmt|;
name|yorg
operator|=
name|y
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	HGtline (xstart, ystart, xend, yend)  |  | Results:	Draws a line from (x0,y0) to (x1,y1) using line(x0,y0,x1,y1)  |		to place individual segments of dotted or dashed lines.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|HGtline
argument_list|(
argument|x0
argument_list|,
argument|y0
argument_list|,
argument|x1
argument_list|,
argument|y1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|dx
decl_stmt|;
specifier|register
name|int
name|dy
decl_stmt|;
specifier|register
name|int
name|oldcoord
decl_stmt|;
specifier|register
name|int
name|res1
decl_stmt|;
specifier|register
name|int
name|visible
decl_stmt|;
specifier|register
name|int
name|res2
decl_stmt|;
specifier|register
name|int
name|xinc
decl_stmt|;
specifier|register
name|int
name|yinc
decl_stmt|;
if|if
condition|(
name|linmod
operator|==
operator|-
literal|1
condition|)
block|{
name|line
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
return|return;
block|}
name|xinc
operator|=
literal|1
expr_stmt|;
name|yinc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|dx
operator|=
name|x1
operator|-
name|x0
operator|)
operator|<
literal|0
condition|)
block|{
name|xinc
operator|=
operator|-
literal|1
expr_stmt|;
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dy
operator|=
name|y1
operator|-
name|y0
operator|)
operator|<
literal|0
condition|)
block|{
name|yinc
operator|=
operator|-
literal|1
expr_stmt|;
name|dy
operator|=
operator|-
name|dy
expr_stmt|;
block|}
name|res1
operator|=
literal|0
expr_stmt|;
name|res2
operator|=
literal|0
expr_stmt|;
name|visible
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dx
operator|>=
name|dy
condition|)
block|{
name|oldcoord
operator|=
name|y0
expr_stmt|;
while|while
condition|(
name|x0
operator|!=
name|x1
condition|)
block|{
if|if
condition|(
operator|(
name|x0
operator|&
name|linmod
operator|)
operator|&&
operator|!
name|visible
condition|)
block|{
name|change
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|visible
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visible
operator|&&
operator|!
operator|(
name|x0
operator|&
name|linmod
operator|)
condition|)
block|{
name|change
argument_list|(
name|x0
operator|-
name|xinc
argument_list|,
name|oldcoord
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|visible
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|res1
operator|>
name|res2
condition|)
block|{
name|oldcoord
operator|=
name|y0
expr_stmt|;
name|res2
operator|+=
name|dx
operator|-
name|res1
expr_stmt|;
name|res1
operator|=
literal|0
expr_stmt|;
name|y0
operator|+=
name|yinc
expr_stmt|;
block|}
name|res1
operator|+=
name|dy
expr_stmt|;
name|x0
operator|+=
name|xinc
expr_stmt|;
block|}
block|}
else|else
block|{
name|oldcoord
operator|=
name|x0
expr_stmt|;
while|while
condition|(
name|y0
operator|!=
name|y1
condition|)
block|{
if|if
condition|(
operator|(
name|y0
operator|&
name|linmod
operator|)
operator|&&
operator|!
name|visible
condition|)
block|{
name|change
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|visible
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|visible
operator|&&
operator|!
operator|(
name|y0
operator|&
name|linmod
operator|)
condition|)
block|{
name|change
argument_list|(
name|oldcoord
argument_list|,
name|y0
operator|-
name|yinc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|visible
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|res1
operator|>
name|res2
condition|)
block|{
name|oldcoord
operator|=
name|x0
expr_stmt|;
name|res2
operator|+=
name|dy
operator|-
name|res1
expr_stmt|;
name|res1
operator|=
literal|0
expr_stmt|;
name|x0
operator|+=
name|xinc
expr_stmt|;
block|}
name|res1
operator|+=
name|dx
expr_stmt|;
name|y0
operator|+=
name|yinc
expr_stmt|;
block|}
block|}
if|if
condition|(
name|visible
condition|)
name|change
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

