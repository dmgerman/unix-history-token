begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	draw.c	1.2	83/09/14  *  *	This file contains the functions for producing the graphics  *   images in the varian/versatec drivers for ditroff.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"canon.h"
end_include

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_comment
comment|/* imports from dip.c */
end_comment

begin_define
define|#
directive|define
name|hmot
parameter_list|(
name|n
parameter_list|)
value|hpos += n;
end_define

begin_define
define|#
directive|define
name|hgoto
parameter_list|(
name|n
parameter_list|)
value|hpos = n;
end_define

begin_define
define|#
directive|define
name|vmot
parameter_list|(
name|n
parameter_list|)
value|vpos += n;
end_define

begin_define
define|#
directive|define
name|vgoto
parameter_list|(
name|n
parameter_list|)
value|vpos = n;
end_define

begin_decl_stmt
specifier|extern
name|int
name|hpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|vpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|MAXX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|MAXY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|tf
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern putint(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|word
parameter_list|(
name|x
parameter_list|)
value|putint(x,tf)
end_define

begin_define
define|#
directive|define
name|byte
parameter_list|(
name|x
parameter_list|)
value|putc(x,tf)
end_define

begin_define
define|#
directive|define
name|MAXPOINTS
value|200
end_define

begin_comment
comment|/* number of points legal for a curve */
end_comment

begin_define
define|#
directive|define
name|SOLID
value|-1
end_define

begin_comment
comment|/* line styles:  these are used as bit masks to */
end_comment

begin_define
define|#
directive|define
name|DOTTED
value|004
end_define

begin_comment
comment|/* create the right style lines. */
end_comment

begin_define
define|#
directive|define
name|DASHED
value|020
end_define

begin_define
define|#
directive|define
name|DOTDASHED
value|024
end_define

begin_define
define|#
directive|define
name|LONGDASHED
value|074
end_define

begin_comment
comment|/* constants... */
end_comment

begin_define
define|#
directive|define
name|pi
value|3.14159265358979324
end_define

begin_define
define|#
directive|define
name|log2_10
value|3.3219280948873623
end_define

begin_define
define|#
directive|define
name|START
value|1
end_define

begin_define
define|#
directive|define
name|POINT
value|0
end_define

begin_define
define|#
directive|define
name|xbound
parameter_list|(
name|x
parameter_list|)
value|(x< 0 ? 0 : x> MAXX ? MAXX : x)
end_define

begin_define
define|#
directive|define
name|ybound
parameter_list|(
name|y
parameter_list|)
value|(y< 0 ? 0 : y> MAXY ? MAXY : y)
end_define

begin_decl_stmt
name|int
name|linethickness
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pixels wide to make lines */
end_comment

begin_decl_stmt
name|int
name|linmod
init|=
name|SOLID
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type of line (SOLID, DOTTED, DASHED...) */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	drawline (horizontal_motion, vertical_motion)  |  | Results:	Draws a line of "linethickness" width and "linmod" style  |		from current (hpos, vpos) to (hpos + dh, vpos + dv).  |  | Side Efct:	Resulting position is at end of line (hpos + dh, vpos + dv)  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
name|drawline
argument_list|(
name|dh
argument_list|,
name|dv
argument_list|)
specifier|register
name|int
name|dh
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|dv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HGtline
argument_list|(
name|hpos
argument_list|,
name|vpos
argument_list|,
name|hpos
operator|+
name|dh
argument_list|,
name|vpos
operator|+
name|dv
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|dh
argument_list|)
expr_stmt|;
comment|/* new position is at */
name|vmot
argument_list|(
name|dv
argument_list|)
expr_stmt|;
comment|/* the end of the line */
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	drawcirc (diameter)  |  | Results:	Draws a circle with leftmost point at current (hpos, vpos)  |		with the given diameter d.  |  | Side Efct:	Resulting position is at (hpos + diameter, vpos)  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
name|drawcirc
argument_list|(
name|d
argument_list|)
specifier|register
name|int
name|d
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* 0.0 is the angle to sweep the arc: = full circle */
name|HGArc
argument_list|(
name|hpos
operator|+
name|d
operator|/
literal|2
argument_list|,
name|vpos
argument_list|,
name|hpos
argument_list|,
name|vpos
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* new postion is the right of the circle */
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	drawellip (horizontal_diameter, vertical_diameter)  |  | Results:	Draws regular ellipses given the major "diameters."  It does  |		so by drawing many small lines, every other pixel.  The ellipse  |		formula:  ((x-x0)/hrad)**2 + ((y-y0)/vrad)**2 = 1 is used,  |		converting to:  y = y0 +- vrad * sqrt(1 - ((x-x0)/hrad)**2).  |		The line segments are duplicated (mirrored) on either side of  |		the horizontal "diameter".  |  | Side Efct:	Resulting position is at (hpos + hd, vpos).  |  | Bugs:	Odd numbered horizontal axes are rounded up to even numbers.  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
name|drawellip
argument_list|(
name|hd
argument_list|,
name|vd
argument_list|)
specifier|register
name|int
name|hd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|vd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|bx
decl_stmt|;
comment|/* multiplicative x factor */
specifier|register
name|int
name|x
decl_stmt|;
comment|/* x position drawing to */
specifier|register
name|int
name|k2
decl_stmt|;
comment|/* the square-root term */
specifier|register
name|int
name|y
decl_stmt|;
comment|/* y position drawing to */
name|double
name|k1
decl_stmt|;
comment|/* k? are constants depending on parameters */
name|int
name|bxsave
decl_stmt|,
name|xsave
decl_stmt|,
name|hdsave
decl_stmt|;
comment|/* places to save things to be used over */
name|hd
operator|=
literal|2
operator|*
operator|(
operator|(
name|hd
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
comment|/* don't accept odd diameters */
if|if
condition|(
name|hd
operator|<
literal|2
condition|)
name|hd
operator|=
literal|2
expr_stmt|;
comment|/* or dinky ones */
name|bx
operator|=
literal|4
operator|*
operator|(
name|hpos
operator|+
name|hd
operator|)
expr_stmt|;
name|x
operator|=
name|hpos
expr_stmt|;
name|k1
operator|=
name|vd
operator|/
operator|(
literal|2.0
operator|*
name|hd
operator|)
expr_stmt|;
name|k2
operator|=
name|hd
operator|*
name|hd
operator|-
literal|4
operator|*
operator|(
name|hpos
operator|+
name|hd
operator|/
literal|2
operator|)
operator|*
operator|(
name|hpos
operator|+
name|hd
operator|/
literal|2
operator|)
expr_stmt|;
name|bxsave
operator|=
name|bx
expr_stmt|;
comment|/* remember the parameters that will change through */
name|xsave
operator|=
name|x
expr_stmt|;
comment|/*    the top half of the elipse, so the bottom half */
name|hdsave
operator|=
name|hd
expr_stmt|;
comment|/*    can be drawn later. */
name|byte
argument_list|(
name|ASPATH
argument_list|)
expr_stmt|;
comment|/* define drawing path */
name|word
argument_list|(
name|hd
operator|/
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|xbound
argument_list|(
name|hpos
argument_list|)
argument_list|)
expr_stmt|;
comment|/* start out at current position */
name|word
argument_list|(
name|ybound
argument_list|(
name|vpos
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|x
operator|+=
literal|2
expr_stmt|;
name|word
argument_list|(
name|xbound
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|y
operator|=
name|vpos
operator|+
call|(
name|int
call|)
argument_list|(
name|k1
operator|*
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|k2
operator|+
operator|(
name|bx
operator|-=
literal|8
operator|)
operator|*
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|ybound
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|hd
operator|-=
literal|2
condition|)
do|;
name|byte
argument_list|(
name|ADRAW
argument_list|)
expr_stmt|;
comment|/* now draw the top half */
name|byte
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|bx
operator|=
name|bxsave
expr_stmt|;
comment|/* get back the parameters for bottom half */
name|x
operator|=
name|xsave
expr_stmt|;
name|hd
operator|=
name|hdsave
expr_stmt|;
name|byte
argument_list|(
name|ASPATH
argument_list|)
expr_stmt|;
comment|/* define drawing path */
name|word
argument_list|(
name|hd
operator|/
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|xbound
argument_list|(
name|hpos
argument_list|)
argument_list|)
expr_stmt|;
comment|/* start out at current position */
name|word
argument_list|(
name|ybound
argument_list|(
name|vpos
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|x
operator|+=
literal|2
expr_stmt|;
name|word
argument_list|(
name|xbound
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|y
operator|=
name|vpos
operator|-
call|(
name|int
call|)
argument_list|(
name|k1
operator|*
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|k2
operator|+
operator|(
name|bx
operator|-=
literal|8
operator|)
operator|*
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|ybound
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|hd
operator|-=
literal|2
condition|)
do|;
name|byte
argument_list|(
name|ADRAW
argument_list|)
expr_stmt|;
comment|/* now draw the bottom half */
name|byte
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|hdsave
argument_list|)
expr_stmt|;
comment|/* end position is the right-hand side of the ellipse */
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	drawarc (xcenter, ycenter, xpoint, ypoint)  |  | Results:	Draws an arc starting at current (hpos, vpos).  Center is  |		at (hpos + cdh, vpos + cdv) and the terminating point is  |		at<center> + (pdh, pdv).  The angle between the lines  |		formed by the starting, ending, and center points is figured  |		first, then the points and angle are sent to HGArc for the  |		drawing.  |  | Side Efct:	Resulting position is at the last point of the arc.  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
name|drawarc
argument_list|(
name|cdh
argument_list|,
name|cdv
argument_list|,
name|pdh
argument_list|,
name|pdv
argument_list|)
specifier|register
name|int
name|cdh
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|cdv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|pdh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|pdv
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|double
name|angle
decl_stmt|;
comment|/* figure angle from the three points...*/
comment|/* and convert (and round) to degrees */
name|angle
operator|=
operator|(
name|atan2
argument_list|(
operator|(
name|double
operator|)
name|pdh
argument_list|,
operator|(
name|double
operator|)
name|pdv
argument_list|)
operator|-
name|atan2
argument_list|(
operator|(
name|double
operator|)
operator|-
name|cdh
argument_list|,
operator|(
name|double
operator|)
operator|-
name|cdv
argument_list|)
operator|)
operator|*
literal|180.0
operator|/
name|pi
expr_stmt|;
comment|/* "normalize" and round */
name|angle
operator|+=
operator|(
name|angle
operator|<
literal|0.0
operator|)
condition|?
literal|360.5
else|:
literal|0.5
expr_stmt|;
name|HGArc
argument_list|(
name|hpos
operator|+
name|cdh
argument_list|,
name|vpos
operator|+
name|cdv
argument_list|,
name|hpos
argument_list|,
name|vpos
argument_list|,
operator|(
name|int
operator|)
name|angle
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|cdh
operator|+
name|pdh
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|cdv
operator|+
name|pdv
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	drawwig (character_buffer, file_pointer, type_flag)  |  | Results:	Given the starting position, the motion list in buf, and any  |		extra characters from fp (terminated by a \n), drawwig sets  |		up a point list to make a spline from.  If "pic" is set picurve  |		is called to draw the curve in pic style; else it calls HGCurve  |		for the gremlin-style curve.  |  | Side Efct:	Resulting position is reached from adding successive motions  |		to the current position.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|drawwig
argument_list|(
argument|buf
argument_list|,
argument|fp
argument_list|,
argument|pic
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pic
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
comment|/* length of the string in "buf" */
specifier|register
name|int
name|npts
init|=
literal|2
decl_stmt|;
comment|/* point list index */
specifier|register
name|char
modifier|*
name|ptr
init|=
name|buf
decl_stmt|;
comment|/* "walking" pointer into buf */
name|int
name|x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
comment|/* point list */
while|while
condition|(
operator|*
name|ptr
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/* skip any leading spaces */
name|x
index|[
literal|1
index|]
operator|=
name|hpos
expr_stmt|;
comment|/* the curve starts at the */
name|y
index|[
literal|1
index|]
operator|=
name|vpos
expr_stmt|;
comment|/* current position */
while|while
condition|(
operator|*
name|ptr
operator|!=
literal|'\n'
condition|)
block|{
comment|/* curve commands end with a '\n' */
name|hmot
argument_list|(
name|atoi
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* convert motion to curve points */
name|x
index|[
name|npts
index|]
operator|=
name|hpos
expr_stmt|;
comment|/* and remember them */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|ptr
argument_list|)
condition|)
empty_stmt|;
comment|/* skip number*/
while|while
condition|(
operator|*
operator|++
name|ptr
operator|==
literal|' '
condition|)
empty_stmt|;
comment|/* skip spaces 'tween numbers */
name|vmot
argument_list|(
name|atoi
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|y
index|[
name|npts
index|]
operator|=
name|vpos
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|ptr
argument_list|)
condition|)
empty_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/* if the amount we read wasn't the */
comment|/*    whole thing, read some more in */
if|if
condition|(
name|len
operator|-
operator|(
name|ptr
operator|-
name|buf
operator|)
operator|<
literal|15
operator|&&
operator|*
operator|(
name|buf
operator|+
name|len
operator|-
literal|1
operator|)
operator|!=
literal|'\n'
condition|)
block|{
name|char
modifier|*
name|cop
init|=
name|buf
decl_stmt|;
while|while
condition|(
operator|*
name|cop
operator|++
operator|=
operator|*
name|ptr
operator|++
condition|)
empty_stmt|;
comment|/* copy what's left to the beginning */
name|fgets
argument_list|(
operator|(
name|cop
operator|-
literal|1
operator|)
argument_list|,
name|len
operator|-
operator|(
name|cop
operator|-
name|buf
operator|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|npts
operator|<
name|MAXPOINTS
operator|-
literal|1
condition|)
comment|/* if too many points, forget some */
name|npts
operator|++
expr_stmt|;
block|}
name|npts
operator|--
expr_stmt|;
comment|/* npts must point to the last coordinate in x and y */
comment|/* now, actually DO the curve */
if|if
condition|(
name|pic
condition|)
name|picurve
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|npts
argument_list|)
expr_stmt|;
else|else
name|HGCurve
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|npts
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	drawthick (thickness)  |  | Results:	sets the variable "linethickness" to the given size.  If this  |		is different than previous thiknesses, informs Imagen of the  |		change.  NO motion is involved.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|drawthick
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|linethickness
operator|!=
name|s
condition|)
block|{
name|byte
argument_list|(
name|ASPEN
argument_list|)
expr_stmt|;
name|byte
argument_list|(
operator|(
name|linethickness
operator|=
name|s
operator|)
operator|<
literal|1
condition|?
literal|1
else|:
name|linethickness
operator|>
name|MAXPENW
condition|?
name|MAXPENW
else|:
name|linethickness
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	drawstyle (style_bit_map)  |  | Results:	sets the variable "linmod" to the given bit map.  |		NO motion is involved.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|drawstyle
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|linmod
operator|=
name|s
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	picurve (xpoints, ypoints, num_of_points)  |  | Results:	Draws a curve delimited by (not through) the line segments  |		traced by (xpoints, ypoints) point list.  This is the "Pic"  |		style curve.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|picurve
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|npts
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|npts
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* line segment traverser */
specifier|register
name|float
name|w
decl_stmt|;
comment|/* position factor */
specifier|register
name|int
name|xp
decl_stmt|;
comment|/* current point (and intermediary) */
specifier|register
name|int
name|yp
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
comment|/* inner curve segment traverser */
specifier|register
name|int
name|nseg
decl_stmt|;
comment|/* effective resolution for each curve */
name|float
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
comment|/* calculation temps */
if|if
condition|(
name|x
index|[
literal|1
index|]
operator|==
name|x
index|[
name|npts
index|]
operator|&&
name|y
index|[
literal|1
index|]
operator|==
name|y
index|[
name|npts
index|]
condition|)
block|{
name|x
index|[
literal|0
index|]
operator|=
name|x
index|[
name|npts
operator|-
literal|1
index|]
expr_stmt|;
comment|/* if the lines' ends meet, make */
name|y
index|[
literal|0
index|]
operator|=
name|y
index|[
name|npts
operator|-
literal|1
index|]
expr_stmt|;
comment|/* sure the curve meets */
name|x
index|[
name|npts
operator|+
literal|1
index|]
operator|=
name|x
index|[
literal|2
index|]
expr_stmt|;
name|y
index|[
name|npts
operator|+
literal|1
index|]
operator|=
name|y
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* otherwise, make the ends of the */
name|x
index|[
literal|0
index|]
operator|=
name|x
index|[
literal|1
index|]
expr_stmt|;
comment|/* curve touch the ending points of */
name|y
index|[
literal|0
index|]
operator|=
name|y
index|[
literal|1
index|]
expr_stmt|;
comment|/* the line segments */
name|x
index|[
name|npts
operator|+
literal|1
index|]
operator|=
name|x
index|[
name|npts
index|]
expr_stmt|;
name|y
index|[
name|npts
operator|+
literal|1
index|]
operator|=
name|y
index|[
name|npts
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npts
condition|;
name|i
operator|++
control|)
block|{
comment|/* traverse the line segments */
name|xp
operator|=
name|x
index|[
name|i
index|]
operator|-
name|x
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|yp
operator|=
name|y
index|[
name|i
index|]
operator|-
name|y
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|nseg
operator|=
operator|(
name|int
operator|)
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|xp
operator|*
name|xp
operator|+
name|yp
operator|*
name|yp
argument_list|)
argument_list|)
expr_stmt|;
name|xp
operator|=
name|x
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|x
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|yp
operator|=
name|y
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|y
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
comment|/* "nseg" is the number of line */
comment|/* segments that will be drawn for */
comment|/* each curve segment.  ">> 3" is */
comment|/* dropping the resolution ( == / 8) */
name|nseg
operator|=
operator|(
name|nseg
operator|+
operator|(
name|int
operator|)
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|xp
operator|*
name|xp
operator|+
name|yp
operator|*
name|yp
argument_list|)
argument_list|)
operator|)
operator|>>
literal|3
expr_stmt|;
name|byte
argument_list|(
name|ASPATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|nseg
condition|)
name|word
argument_list|(
name|nseg
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|word
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|nseg
condition|;
name|j
operator|++
control|)
block|{
name|w
operator|=
operator|(
name|float
operator|)
name|j
operator|/
operator|(
name|float
operator|)
name|nseg
expr_stmt|;
name|t1
operator|=
literal|0.5
operator|*
name|w
operator|*
name|w
expr_stmt|;
name|w
operator|-=
literal|0.5
expr_stmt|;
name|t2
operator|=
literal|0.75
operator|-
name|w
operator|*
name|w
expr_stmt|;
name|w
operator|-=
literal|0.5
expr_stmt|;
name|t3
operator|=
literal|0.5
operator|*
name|w
operator|*
name|w
expr_stmt|;
name|xp
operator|=
name|t1
operator|*
name|x
index|[
name|i
operator|+
literal|2
index|]
operator|+
name|t2
operator|*
name|x
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|t3
operator|*
name|x
index|[
name|i
index|]
operator|+
literal|0.5
expr_stmt|;
name|yp
operator|=
name|t1
operator|*
name|y
index|[
name|i
operator|+
literal|2
index|]
operator|+
name|t2
operator|*
name|y
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|t3
operator|*
name|y
index|[
name|i
index|]
operator|+
literal|0.5
expr_stmt|;
name|word
argument_list|(
name|xbound
argument_list|(
name|xp
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|ybound
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nseg
operator|==
literal|0
condition|)
block|{
name|word
argument_list|(
name|xbound
argument_list|(
name|xp
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|ybound
argument_list|(
name|yp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|byte
argument_list|(
name|ADRAW
argument_list|)
expr_stmt|;
name|byte
argument_list|(
literal|15
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	HGArc (xcenter, ycenter, xstart, ystart, angle)  |  | Results:	This routine plots an arc centered about (cx, cy) counter  |		clockwise starting from the point (px, py) through 'angle'  |		degrees.  If angle is 0, a full circle is drawn. It does so  |		by creating a draw-path around the arc whose density of  |		points depends on the size of the arc.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|HGArc
argument_list|(
argument|cx
argument_list|,
argument|cy
argument_list|,
argument|px
argument_list|,
argument|py
argument_list|,
argument|angle
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cx
decl_stmt|,
name|cy
decl_stmt|,
name|px
decl_stmt|,
name|py
decl_stmt|,
name|angle
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|xs
decl_stmt|,
name|ys
decl_stmt|,
name|resolution
decl_stmt|,
name|fullcircle
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|extent
decl_stmt|;
specifier|register
name|int
name|nx
decl_stmt|;
specifier|register
name|int
name|ny
decl_stmt|;
specifier|register
name|double
name|epsilon
decl_stmt|;
name|xs
operator|=
name|px
operator|-
name|cx
expr_stmt|;
name|ys
operator|=
name|py
operator|-
name|cy
expr_stmt|;
comment|/* calculate drawing parameters */
name|resolution
operator|=
name|pow
argument_list|(
literal|2.0
argument_list|,
name|floor
argument_list|(
name|log10
argument_list|(
name|sqrt
argument_list|(
name|xs
operator|*
name|xs
operator|+
name|ys
operator|*
name|ys
argument_list|)
argument_list|)
operator|*
name|log2_10
argument_list|)
argument_list|)
expr_stmt|;
name|epsilon
operator|=
literal|1.0
operator|/
name|resolution
expr_stmt|;
name|fullcircle
operator|=
name|ceil
argument_list|(
literal|2
operator|*
name|pi
operator|*
name|resolution
argument_list|)
expr_stmt|;
if|if
condition|(
name|angle
operator|==
literal|0
condition|)
name|extent
operator|=
name|fullcircle
expr_stmt|;
else|else
name|extent
operator|=
name|angle
operator|*
name|fullcircle
operator|/
literal|360.0
expr_stmt|;
name|byte
argument_list|(
name|ASPATH
argument_list|)
expr_stmt|;
comment|/* start path definition */
if|if
condition|(
name|extent
operator|>
literal|1
condition|)
block|{
name|word
argument_list|(
name|extent
argument_list|)
expr_stmt|;
comment|/* number of points */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extent
condition|;
operator|++
name|i
control|)
block|{
name|xs
operator|+=
name|epsilon
operator|*
name|ys
expr_stmt|;
name|nx
operator|=
call|(
name|int
call|)
argument_list|(
name|xs
operator|+
name|cx
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|ys
operator|-=
name|epsilon
operator|*
name|xs
expr_stmt|;
name|ny
operator|=
call|(
name|int
call|)
argument_list|(
name|ys
operator|+
name|cy
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|xbound
argument_list|(
name|nx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* put out a point on circle */
name|word
argument_list|(
name|ybound
argument_list|(
name|ny
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* end for */
block|}
else|else
block|{
comment|/* arc is too small: put out point */
name|word
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|xbound
argument_list|(
name|cx
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|ybound
argument_list|(
name|cy
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|xbound
argument_list|(
name|cx
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|ybound
argument_list|(
name|cy
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|byte
argument_list|(
name|ADRAW
argument_list|)
expr_stmt|;
comment|/* now draw the arc */
name|byte
argument_list|(
literal|15
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end HGArc */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	Paramaterize (xpoints, ypoints, hparams, num_points)  |  | Results:	This routine calculates parameteric values for use in  |		calculating curves.  The parametric values are returned  |		in the array h.  The values are an approximation of  |		cumulative arc lengths of the curve (uses cord length).  |		For additional information, see paper cited below.  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
specifier|static
name|Paramaterize
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|h
argument_list|,
argument|n
argument_list|)
name|int
name|x
index|[
name|MAXPOINTS
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|h
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|dx
decl_stmt|;
specifier|register
name|int
name|dy
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|float
name|u
index|[
name|MAXPOINTS
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
operator|++
name|i
control|)
block|{
name|u
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|dx
operator|=
name|x
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|x
index|[
name|j
index|]
expr_stmt|;
name|dy
operator|=
name|y
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|y
index|[
name|j
index|]
expr_stmt|;
name|u
index|[
name|i
index|]
operator|+=
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|dx
operator|*
name|dx
operator|+
name|dy
operator|*
name|dy
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|h
index|[
name|i
index|]
operator|=
name|u
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|u
index|[
name|i
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end Paramaterize */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	PeriodicSpline (h, z, dz, d2z, d3z, npoints)  |  | Results:	This routine solves for the cubic polynomial to fit a  |		spline curve to the the points  specified by the list  |		of values.  The Curve generated is periodic.  The algorithms  |		for this curve are from the "Spline Curve Techniques" paper  |		cited below.  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
specifier|static
name|PeriodicSpline
argument_list|(
argument|h
argument_list|,
argument|z
argument_list|,
argument|dz
argument_list|,
argument|d2z
argument_list|,
argument|d3z
argument_list|,
argument|npoints
argument_list|)
name|float
name|h
index|[
name|MAXPOINTS
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* paramaterization  */
end_comment

begin_decl_stmt
name|int
name|z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* point list */
end_comment

begin_decl_stmt
name|float
name|dz
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to return the 1st derivative */
end_comment

begin_decl_stmt
name|float
name|d2z
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2nd and 3rd derivatives */
end_comment

begin_decl_stmt
name|int
name|npoints
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of valid points */
end_comment

begin_block
block|{
name|float
name|d
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|deltaz
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|a
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|b
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|c
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|r
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|s
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* step 1 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
name|deltaz
index|[
name|i
index|]
operator|=
name|h
index|[
name|i
index|]
condition|?
operator|(
call|(
name|double
call|)
argument_list|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|z
index|[
name|i
index|]
argument_list|)
operator|)
operator|/
name|h
index|[
name|i
index|]
else|:
literal|0
expr_stmt|;
block|}
name|h
index|[
literal|0
index|]
operator|=
name|h
index|[
name|npoints
operator|-
literal|1
index|]
expr_stmt|;
name|deltaz
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
name|npoints
operator|-
literal|1
index|]
expr_stmt|;
comment|/* step 2 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|deltaz
index|[
name|i
index|]
expr_stmt|;
block|}
name|d
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
literal|1
index|]
operator|-
name|deltaz
index|[
literal|0
index|]
expr_stmt|;
comment|/* step 3a */
name|a
index|[
literal|1
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
literal|0
index|]
operator|+
name|h
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
name|d
index|[
literal|0
index|]
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
name|h
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|a
index|[
name|i
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|h
index|[
name|i
index|]
operator|)
operator|-
name|pow
argument_list|(
operator|(
name|double
operator|)
name|h
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
operator|(
name|double
operator|)
literal|2.0
argument_list|)
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|b
index|[
name|i
index|]
operator|=
name|d
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|h
index|[
name|i
operator|-
literal|1
index|]
operator|*
name|b
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|c
index|[
name|i
index|]
operator|=
operator|-
name|h
index|[
name|i
operator|-
literal|1
index|]
operator|*
name|c
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* step 3b */
name|r
index|[
name|npoints
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|s
index|[
name|npoints
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|npoints
operator|-
literal|2
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|r
index|[
name|i
index|]
operator|=
operator|-
operator|(
name|h
index|[
name|i
index|]
operator|*
name|r
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|c
index|[
name|i
index|]
operator|)
operator|/
name|a
index|[
name|i
index|]
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
operator|(
literal|6
operator|*
name|b
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
name|s
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
name|a
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* step 4 */
name|d2z
index|[
name|npoints
operator|-
literal|1
index|]
operator|=
operator|(
literal|6
operator|*
name|d
index|[
name|npoints
operator|-
literal|2
index|]
operator|-
name|h
index|[
literal|0
index|]
operator|*
name|s
index|[
literal|1
index|]
operator|-
name|h
index|[
name|npoints
operator|-
literal|1
index|]
operator|*
name|s
index|[
name|npoints
operator|-
literal|2
index|]
operator|)
operator|/
operator|(
name|h
index|[
literal|0
index|]
operator|*
name|r
index|[
literal|1
index|]
operator|+
name|h
index|[
name|npoints
operator|-
literal|1
index|]
operator|*
name|r
index|[
name|npoints
operator|-
literal|2
index|]
operator|+
literal|2
operator|*
operator|(
name|h
index|[
name|npoints
operator|-
literal|2
index|]
operator|+
name|h
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d2z
index|[
name|i
index|]
operator|=
name|r
index|[
name|i
index|]
operator|*
name|d2z
index|[
name|npoints
operator|-
literal|1
index|]
operator|+
name|s
index|[
name|i
index|]
expr_stmt|;
block|}
name|d2z
index|[
name|npoints
index|]
operator|=
name|d2z
index|[
literal|1
index|]
expr_stmt|;
comment|/* step 5 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
name|dz
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
operator|(
literal|2
operator|*
name|d2z
index|[
name|i
index|]
operator|+
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
literal|6
expr_stmt|;
name|d3z
index|[
name|i
index|]
operator|=
name|h
index|[
name|i
index|]
condition|?
operator|(
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|d2z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
else|:
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end PeriodicSpline */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	NaturalEndSpline (h, z, dz, d2z, d3z, npoints)  |  | Results:	This routine solves for the cubic polynomial to fit a  |		spline curve the the points  specified by the list of  |		values.  The alogrithms for this curve are from the  |		"Spline Curve Techniques" paper cited below.  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
specifier|static
name|NaturalEndSpline
argument_list|(
argument|h
argument_list|,
argument|z
argument_list|,
argument|dz
argument_list|,
argument|d2z
argument_list|,
argument|d3z
argument_list|,
argument|npoints
argument_list|)
name|float
name|h
index|[
name|MAXPOINTS
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* parameterization */
end_comment

begin_decl_stmt
name|int
name|z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Point list */
end_comment

begin_decl_stmt
name|float
name|dz
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to return the 1st derivative */
end_comment

begin_decl_stmt
name|float
name|d2z
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2nd and 3rd derivatives */
end_comment

begin_decl_stmt
name|int
name|npoints
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of valid points */
end_comment

begin_block
block|{
name|float
name|d
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|deltaz
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|a
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|b
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* step 1 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
name|deltaz
index|[
name|i
index|]
operator|=
name|h
index|[
name|i
index|]
condition|?
operator|(
call|(
name|double
call|)
argument_list|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|z
index|[
name|i
index|]
argument_list|)
operator|)
operator|/
name|h
index|[
name|i
index|]
else|:
literal|0
expr_stmt|;
block|}
name|deltaz
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
name|npoints
operator|-
literal|1
index|]
expr_stmt|;
comment|/* step 2 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|deltaz
index|[
name|i
index|]
expr_stmt|;
block|}
name|d
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
literal|1
index|]
operator|-
name|deltaz
index|[
literal|0
index|]
expr_stmt|;
comment|/* step 3 */
name|a
index|[
literal|0
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
literal|2
index|]
operator|+
name|h
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|d
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|a
index|[
name|i
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|h
index|[
name|i
operator|+
literal|2
index|]
operator|)
operator|-
name|pow
argument_list|(
operator|(
name|double
operator|)
name|h
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|(
name|double
operator|)
literal|2.0
argument_list|)
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|b
index|[
name|i
index|]
operator|=
name|d
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|h
index|[
name|i
operator|+
literal|1
index|]
operator|*
name|b
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* step 4 */
name|d2z
index|[
name|npoints
index|]
operator|=
name|d2z
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|npoints
operator|-
literal|1
init|;
name|i
operator|>
literal|1
condition|;
operator|--
name|i
control|)
block|{
name|d2z
index|[
name|i
index|]
operator|=
operator|(
literal|6
operator|*
name|b
index|[
name|i
operator|-
literal|2
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
name|a
index|[
name|i
operator|-
literal|2
index|]
expr_stmt|;
block|}
comment|/* step 5 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
name|dz
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
operator|(
literal|2
operator|*
name|d2z
index|[
name|i
index|]
operator|+
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
literal|6
expr_stmt|;
name|d3z
index|[
name|i
index|]
operator|=
name|h
index|[
name|i
index|]
condition|?
operator|(
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|d2z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
else|:
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end NaturalEndSpline */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	HGCurve(xpoints, ypoints, num_points)  |  | Results:	This routine generates a smooth curve through a set of points.  |		The method used is the parametric spline curve on unit knot  |		mesh described in "Spline Curve Techniques" by Patrick  |		Baudelaire, Robert Flegal, and Robert Sproull -- Xerox Parc.  *----------------------------------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|PointsPerInterval
value|32
end_define

begin_macro
name|HGCurve
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|numpoints
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numpoints
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|float
name|h
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|dx
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|dy
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|d2x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d2y
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|t
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|nx
decl_stmt|;
specifier|register
name|int
name|ny
decl_stmt|;
name|int
name|lx
decl_stmt|,
name|ly
decl_stmt|;
name|lx
operator|=
name|x
index|[
literal|1
index|]
expr_stmt|;
name|ly
operator|=
name|y
index|[
literal|1
index|]
expr_stmt|;
comment|/* Solve for derivatives of the curve at each point                * separately for x and y (parametric). 	      */
name|Paramaterize
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|h
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
comment|/* closed curve */
if|if
condition|(
operator|(
name|x
index|[
literal|1
index|]
operator|==
name|x
index|[
name|numpoints
index|]
operator|)
operator|&&
operator|(
name|y
index|[
literal|1
index|]
operator|==
name|y
index|[
name|numpoints
index|]
operator|)
condition|)
block|{
name|PeriodicSpline
argument_list|(
name|h
argument_list|,
name|x
argument_list|,
name|dx
argument_list|,
name|d2x
argument_list|,
name|d3x
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
name|PeriodicSpline
argument_list|(
name|h
argument_list|,
name|y
argument_list|,
name|dy
argument_list|,
name|d2y
argument_list|,
name|d3y
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NaturalEndSpline
argument_list|(
name|h
argument_list|,
name|x
argument_list|,
name|dx
argument_list|,
name|d2x
argument_list|,
name|d3x
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
name|NaturalEndSpline
argument_list|(
name|h
argument_list|,
name|y
argument_list|,
name|dy
argument_list|,
name|d2y
argument_list|,
name|d3y
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
block|}
comment|/* generate the curve using the above information and  	       * PointsPerInterval vectors between each specified knot. 	       */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|numpoints
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|(
name|x
index|[
name|j
index|]
operator|==
name|x
index|[
name|j
operator|+
literal|1
index|]
operator|)
operator|&&
operator|(
name|y
index|[
name|j
index|]
operator|==
name|y
index|[
name|j
operator|+
literal|1
index|]
operator|)
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|PointsPerInterval
condition|;
operator|++
name|k
control|)
block|{
name|t
operator|=
operator|(
name|float
operator|)
name|k
operator|*
name|h
index|[
name|j
index|]
operator|/
operator|(
name|float
operator|)
name|PointsPerInterval
expr_stmt|;
name|t2
operator|=
name|t
operator|*
name|t
expr_stmt|;
name|t3
operator|=
name|t
operator|*
name|t
operator|*
name|t
expr_stmt|;
name|nx
operator|=
name|x
index|[
name|j
index|]
operator|+
call|(
name|int
call|)
argument_list|(
name|t
operator|*
name|dx
index|[
name|j
index|]
operator|+
name|t2
operator|*
name|d2x
index|[
name|j
index|]
operator|/
literal|2
operator|+
name|t3
operator|*
name|d3x
index|[
name|j
index|]
operator|/
literal|6
argument_list|)
expr_stmt|;
name|ny
operator|=
name|y
index|[
name|j
index|]
operator|+
call|(
name|int
call|)
argument_list|(
name|t
operator|*
name|dy
index|[
name|j
index|]
operator|+
name|t2
operator|*
name|d2y
index|[
name|j
index|]
operator|/
literal|2
operator|+
name|t3
operator|*
name|d3y
index|[
name|j
index|]
operator|/
literal|6
argument_list|)
expr_stmt|;
name|HGtline
argument_list|(
name|lx
argument_list|,
name|ly
argument_list|,
name|nx
argument_list|,
name|ny
argument_list|)
expr_stmt|;
name|lx
operator|=
name|nx
expr_stmt|;
name|ly
operator|=
name|ny
expr_stmt|;
block|}
comment|/* end for k */
block|}
comment|/* end for j */
block|}
end_block

begin_comment
comment|/* end HGCurve */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------  | Routine:	HGtline(xstart, ystart, xend, yend)  |  | Results:	Creates a drawing path and draws the line.  If the line falls  |		off the end of the page, a crude clipping is done:  truncating  |		the offending ordinate.  |  | Bugs:	Does NOTHING about line style yet...  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|HGtline
argument_list|(
argument|x0
argument_list|,
argument|y0
argument_list|,
argument|x1
argument_list|,
argument|y1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|byte
argument_list|(
name|ASPATH
argument_list|)
expr_stmt|;
comment|/* send the coordinates first */
name|word
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* only two */
name|word
argument_list|(
name|xbound
argument_list|(
name|x0
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|ybound
argument_list|(
name|y0
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|xbound
argument_list|(
name|x1
argument_list|)
argument_list|)
expr_stmt|;
name|word
argument_list|(
name|ybound
argument_list|(
name|y1
argument_list|)
argument_list|)
expr_stmt|;
name|byte
argument_list|(
name|ADRAW
argument_list|)
expr_stmt|;
comment|/* now draw it */
name|byte
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|/* black */
block|}
end_block

begin_comment
comment|/* end HGtline */
end_comment

end_unit

