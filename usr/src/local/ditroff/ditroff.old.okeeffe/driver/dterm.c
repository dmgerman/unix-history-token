begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)dterm.c	1.9	(Berkeley)	%G%"  *  *	Converts ditroff output to text on a terminal.  It is NOT meant to  *	produce readable output, but is to show one how one's paper is (in  *	general) formatted - what will go where on which page.  *  *	options:  *  *	  -hn	set horizontal resolution to n (in characters per inch;  *		default is 10.0).  *  *	  -vn	set vertical resolution (default is 6.0).  *  *	  -ln	set maximum output line-length to n (default is 79).  *  *	-olist	output page list - as in troff.  *  *	  -c	continue at end of page.  Default is to stop at the end  *		of each page, print "dterm:" and wait for a command.  *		Type ? to get a list of available commands.  *  *	  -m	print margins.  Default action is to cut printing area down  *		to only the part of the page with information on it.  *  *	  -L	put a form feed (^L) at the end of each page  *  *	  -w	sets h = 20, v = 12, l = 131, also sets -c, -m and -L to allow  *		for extra-wide printouts on the printer.  *  *	-fxxx	get special character definition file "xxx".  Default is  *		/usr/lib/font/devter/specfile.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_define
define|#
directive|define
name|FATAL
value|1
end_define

begin_define
define|#
directive|define
name|PGWIDTH
value|266
end_define

begin_comment
comment|/* WAY too big - for good measure */
end_comment

begin_define
define|#
directive|define
name|PGHEIGHT
value|220
end_define

begin_define
define|#
directive|define
name|LINELEN
value|78
end_define

begin_define
define|#
directive|define
name|SPECFILE
value|"/usr/local/lib/font/devter/specfile"
end_define

begin_define
define|#
directive|define
name|hgoto
parameter_list|(
name|n
parameter_list|)
value|hpos = n
end_define

begin_define
define|#
directive|define
name|vgoto
parameter_list|(
name|n
parameter_list|)
value|vpos = n
end_define

begin_define
define|#
directive|define
name|hmot
parameter_list|(
name|n
parameter_list|)
value|hpos += n
end_define

begin_define
define|#
directive|define
name|vmot
parameter_list|(
name|n
parameter_list|)
value|vpos += n
end_define

begin_define
define|#
directive|define
name|sgn
parameter_list|(
name|n
parameter_list|)
value|((n> 0) ? 1 : ((n< 0) ? -1 : 0))
end_define

begin_define
define|#
directive|define
name|abs
parameter_list|(
name|n
parameter_list|)
value|((n)>= 0 ? (n) : -(n))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)> (y) ? (x) : (y))
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)< (y) ? (x) : (y))
end_define

begin_define
define|#
directive|define
name|arcmove
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|{ hgoto(x); vmot(-vpos-(y)); }
end_define

begin_define
define|#
directive|define
name|sqr
parameter_list|(
name|x
parameter_list|)
value|(long int)(x)*(x)
end_define

begin_decl_stmt
name|char
name|SccsId
index|[]
init|=
literal|"@(#)dterm.c	1.9	(Berkeley)	%G%"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|spectab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* here go the special characters */
end_comment

begin_decl_stmt
name|char
modifier|*
name|specfile
init|=
name|SPECFILE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place to look up special characters */
end_comment

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|operand
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|keepon
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flags:  Don't stop at the end of each page? */
end_comment

begin_decl_stmt
name|int
name|clearsc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Put out form feed at each page? */
end_comment

begin_decl_stmt
name|int
name|output
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do we do output at all? */
end_comment

begin_decl_stmt
name|int
name|nolist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output page list if> 0 */
end_comment

begin_decl_stmt
name|int
name|margin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print blank margins? */
end_comment

begin_decl_stmt
name|int
name|olist
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pairs of page numbers */
end_comment

begin_decl_stmt
name|float
name|hscale
init|=
literal|10.0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* characters and lines per inch for output */
end_comment

begin_decl_stmt
name|float
name|vscale
init|=
literal|6.0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*	device (defaults are for printer) */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fp
init|=
name|stdin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file pointer */
end_comment

begin_decl_stmt
name|char
name|pagebuf
index|[
name|PGHEIGHT
index|]
index|[
name|PGWIDTH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|minh
init|=
name|PGWIDTH
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxh
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|minv
init|=
name|PGHEIGHT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxv
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linelen
init|=
name|LINELEN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* horizontal position to be next (left = 0) */
end_comment

begin_decl_stmt
name|int
name|vpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current vertical position (down positive) */
end_comment

begin_decl_stmt
name|int
name|np
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pages seen */
end_comment

begin_decl_stmt
name|int
name|npmax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* high-water mark of np */
end_comment

begin_decl_stmt
name|int
name|pgnum
index|[
literal|40
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* their actual numbers */
end_comment

begin_decl_stmt
name|long
name|pgadr
index|[
literal|40
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* their seek addresses */
end_comment

begin_decl_stmt
name|int
name|DP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* step size for drawing */
end_comment

begin_decl_stmt
name|int
name|drawdot
init|=
literal|'.'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* draw with this character */
end_comment

begin_decl_stmt
name|int
name|maxdots
init|=
literal|3200
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum number of dots in an object */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|*
operator|*
operator|++
name|argv
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* special character filepath */
name|specfile
operator|=
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* output line length */
name|linelen
operator|=
name|atoi
argument_list|(
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* horizontal scale (char/inch) */
name|hscale
operator|=
name|atof
argument_list|(
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* vertical scale (char/inch) */
name|vscale
operator|=
name|atof
argument_list|(
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* output list */
name|outlist
argument_list|(
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* continue at endofpage */
name|keepon
operator|=
operator|!
name|keepon
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* print margins */
name|margin
operator|=
operator|!
name|margin
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* form feed after each page */
name|clearsc
operator|=
operator|!
name|clearsc
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* "wide" printer format */
name|hscale
operator|=
literal|16.0
expr_stmt|;
name|vscale
operator|=
literal|9.6
expr_stmt|;
name|linelen
operator|=
literal|131
expr_stmt|;
name|keepon
operator|=
literal|1
expr_stmt|;
name|clearsc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|conv
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|argc
operator|--
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|fp
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|conv
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|done
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	char  * operand (& argc,& argv)  |  | Results:	returns address of the operand given with a command-line  |		option.  It uses either "-Xoperand" or "-X operand", whichever  |		is present.  The program is terminated if no option is present.  |  | Side Efct:	argc and argv are updated as necessary.  *----------------------------------------------------------------------------*/
end_comment

begin_function
name|char
modifier|*
name|operand
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
operator|*
name|argvp
operator|)
index|[
literal|2
index|]
condition|)
return|return
operator|(
operator|*
operator|*
name|argvp
operator|+
literal|2
operator|)
return|;
comment|/* operand immediately follows */
if|if
condition|(
operator|(
operator|--
operator|*
name|argcp
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* operand next word */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"command-line option operand missing.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|*
operator|(
operator|++
operator|(
operator|*
name|argvp
operator|)
operator|)
operator|)
return|;
comment|/* no operand */
block|}
end_function

begin_macro
name|outlist
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* process list of page numbers to be printed */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|,
name|i
decl_stmt|;
name|nolist
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|n1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|do
name|n1
operator|=
literal|10
operator|*
name|n1
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
else|else
name|n1
operator|=
operator|-
literal|9999
expr_stmt|;
name|n2
operator|=
name|n1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|n2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|do
name|n2
operator|=
literal|10
operator|*
name|n2
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
else|else
name|n2
operator|=
literal|9999
expr_stmt|;
block|}
name|olist
index|[
name|nolist
operator|++
index|]
operator|=
name|n1
expr_stmt|;
name|olist
index|[
name|nolist
operator|++
index|]
operator|=
name|n2
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|olist
index|[
name|nolist
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|in_olist
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* is n in olist? */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nolist
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* everything is included */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nolist
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
name|n
operator|>=
name|olist
index|[
name|i
index|]
operator|&&
name|n
operator|<=
name|olist
index|[
name|i
operator|+
literal|1
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|conv
argument_list|(
name|fp
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|m
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|n1
decl_stmt|,
name|m1
decl_stmt|;
name|char
name|str
index|[
literal|100
index|]
decl_stmt|,
name|buf
index|[
literal|300
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* when input is text */
case|case
literal|'\t'
case|:
case|case
literal|' '
case|:
case|case
literal|0
case|:
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* two motion digits plus a character */
name|hmot
argument_list|(
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|getc
argument_list|(
name|fp
argument_list|)
operator|-
literal|'0'
argument_list|)
expr_stmt|;
name|put1
argument_list|(
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* single ascii character */
name|put1
argument_list|(
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* funny character */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|put1s
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* straight text */
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|t_text
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* draw function */
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'l'
case|:
comment|/* draw a line */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|drawline
argument_list|(
name|n
argument_list|,
name|m
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* circle */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawcirc
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* ellipse */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawellip
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* arc */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d %d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n1
argument_list|,
operator|&
name|m1
argument_list|)
expr_stmt|;
name|drawarc
argument_list|(
name|n
argument_list|,
name|m
argument_list|,
name|n1
argument_list|,
name|m1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* "gremlin" curve */
case|case
literal|'~'
case|:
comment|/* wiggly line */
name|drawwig
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* thickness - not important */
case|case
literal|'s'
case|:
comment|/* style - not important */
break|break;
default|default:
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unknown drawing command %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* point size - ignored */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* font request - ignored */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* absolute horizontal motion */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|hgoto
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* relative horizontal motion */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* word space */
break|break;
case|case
literal|'V'
case|:
comment|/* absolute vertical motion */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|vgoto
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* relative vertical motion */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* new page */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_page
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* new span (ignored) */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* end of line */
name|hpos
operator|=
literal|0
expr_stmt|;
case|case
literal|'#'
case|:
comment|/* comment */
while|while
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* device control */
name|devcntrl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"unknown input character %o %c\n"
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|devcntrl
argument_list|(
argument|fp
argument_list|)
end_macro

begin_comment
comment|/* interpret device control functions */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|char
name|str
index|[
literal|20
index|]
decl_stmt|;
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|str
index|[
literal|0
index|]
condition|)
block|{
comment|/* crude for now */
case|case
literal|'i'
case|:
comment|/* initialize */
name|t_init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* resolution assumed when prepared */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|hscale
operator|=
operator|(
name|float
operator|)
name|n
operator|/
name|hscale
expr_stmt|;
name|vscale
operator|=
operator|(
name|float
operator|)
name|n
operator|/
name|vscale
expr_stmt|;
name|DP
operator|=
name|min
argument_list|(
name|hscale
argument_list|,
name|vscale
argument_list|)
expr_stmt|;
comment|/* guess the drawing */
name|DP
operator|=
name|max
argument_list|(
name|DP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* resolution */
break|break;
case|case
literal|'f'
case|:
comment|/* font used */
case|case
literal|'T'
case|:
comment|/* device name */
case|case
literal|'t'
case|:
comment|/* trailer */
case|case
literal|'p'
case|:
comment|/* pause -- can restart */
case|case
literal|'s'
case|:
comment|/* stop */
break|break;
block|}
while|while
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|!=
literal|'\n'
condition|)
comment|/* skip rest of input line */
empty_stmt|;
block|}
end_block

begin_comment
comment|/* error printing routine - first argument is a "fatal" flag */
end_comment

begin_macro
name|error
argument_list|(
argument|f
argument_list|,
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|,
argument|a6
argument_list|,
argument|a7
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dterm: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|t_init
argument_list|(
argument|reinit
argument_list|)
end_macro

begin_comment
comment|/* initialize device */
end_comment

begin_decl_stmt
name|int
name|reinit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* file to look up special characters */
specifier|register
name|char
modifier|*
name|charptr
decl_stmt|;
comment|/* string pointer to step through specials */
specifier|register
name|char
modifier|*
name|tabptr
decl_stmt|;
comment|/* string pointer for spectab setting */
name|char
name|specials
index|[
literal|5000
index|]
decl_stmt|;
comment|/* intermediate input buffer (made bigger */
comment|/*   than we'll EVER use... */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|hpos
operator|=
name|vpos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PGHEIGHT
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|PGWIDTH
condition|;
name|j
operator|++
control|)
name|pagebuf
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|' '
expr_stmt|;
name|minh
operator|=
name|PGWIDTH
expr_stmt|;
name|maxh
operator|=
literal|0
expr_stmt|;
name|minv
operator|=
name|PGHEIGHT
expr_stmt|;
name|maxv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reinit
condition|)
return|return;
comment|/* if this is the first time, read */
comment|/* special character table file. */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|specfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|charptr
operator|=
operator|&
name|specials
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|charptr
argument_list|)
operator|!=
name|EOF
condition|;
name|i
operator|++
control|)
block|{
name|charptr
operator|+=
name|strlen
argument_list|(
name|charptr
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|*
name|charptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* ending strings */
operator|*
name|charptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* allocate table */
name|spectab
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|spectab
index|[
literal|0
index|]
operator|=
name|tabptr
operator|=
name|malloc
argument_list|(
name|j
operator|=
call|(
name|int
call|)
argument_list|(
name|charptr
operator|-
operator|&
name|specials
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copy whole table */
for|for
control|(
name|charptr
operator|=
operator|&
name|specials
index|[
literal|0
index|]
init|;
name|j
operator|--
condition|;
operator|*
name|tabptr
operator|++
operator|=
operator|*
name|charptr
operator|++
control|)
empty_stmt|;
name|tabptr
operator|=
name|spectab
index|[
literal|0
index|]
expr_stmt|;
comment|/* set up pointers to table */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|i
operator|--
condition|;
name|j
operator|++
control|)
block|{
name|spectab
index|[
name|j
index|]
operator|=
name|tabptr
expr_stmt|;
name|tabptr
operator|+=
name|strlen
argument_list|(
name|tabptr
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* didn't find table - allocate a null one */
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"Can't open special character file: %s"
argument_list|,
name|specfile
argument_list|)
expr_stmt|;
name|spectab
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|spectab
index|[
literal|0
index|]
operator|=
name|malloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|spectab
index|[
literal|1
index|]
operator|=
name|spectab
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
operator|*
name|spectab
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|spectab
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* just got "p#" command.  print the current page and */
end_comment

begin_macro
name|t_page
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* do whatever new page functions */
end_comment

begin_block
block|{
name|long
name|ftell
parameter_list|()
function_decl|;
name|int
name|c
decl_stmt|,
name|m
decl_stmt|,
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|pgnum
index|[
name|np
operator|++
index|]
operator|=
name|n
expr_stmt|;
name|pgadr
index|[
name|np
index|]
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|>
name|npmax
condition|)
name|npmax
operator|=
name|np
expr_stmt|;
if|if
condition|(
name|output
operator|==
literal|0
condition|)
block|{
name|output
operator|=
name|in_olist
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|t_init
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|putpage
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|clearsc
condition|)
name|putchar
argument_list|(
literal|'
literal|'
argument_list|)
expr_stmt|;
if|if
condition|(
name|keepon
condition|)
block|{
name|t_init
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|next
label|:
for|for
control|(
name|bp
operator|=
name|buf
init|;
operator|(
operator|*
name|bp
operator|=
name|readch
argument_list|()
operator|)
condition|;
control|)
if|if
condition|(
operator|*
name|bp
operator|++
operator|==
literal|'\n'
condition|)
break|break;
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0
case|:
name|done
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|output
operator|=
name|in_olist
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|t_init
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'-'
case|:
case|case
literal|'p'
case|:
name|m
operator|=
name|atoi
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|stdin
condition|)
block|{
name|fputs
argument_list|(
literal|"you can't; it's not a file\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|np
operator|-
name|m
operator|<=
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"too far back\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
block|}
name|np
operator|-=
name|m
expr_stmt|;
name|fseek
argument_list|(
name|fp
argument_list|,
name|pgadr
index|[
name|np
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output
operator|=
literal|1
expr_stmt|;
name|t_init
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|m
operator|=
name|atoi
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npmax
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|m
operator|==
name|pgnum
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|npmax
operator|||
name|fp
operator|==
name|stdin
condition|)
block|{
name|fputs
argument_list|(
literal|"you can't\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
block|}
name|np
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|fseek
argument_list|(
name|fp
argument_list|,
name|pgadr
index|[
name|np
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output
operator|=
literal|1
expr_stmt|;
name|t_init
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'o'
case|:
name|outlist
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|output
operator|=
literal|0
expr_stmt|;
name|t_init
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'?'
case|:
name|fputs
argument_list|(
literal|"p	print this page again\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"-n	go back n pages\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"n	print page n (previously printed)\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"o...	set the -o output list to ...\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fputs
argument_list|(
literal|"?\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|next
goto|;
block|}
end_block

begin_comment
comment|/* print the contents of the current page.  puts out */
end_comment

begin_macro
name|putpage
argument_list|()
end_macro

begin_comment
comment|/* only the part of the page that's been written on */
end_comment

begin_block
block|{
comment|/* unless "margin" is set. */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|margin
condition|)
name|minv
operator|=
name|minh
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|minv
init|;
name|i
operator|<=
name|maxv
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
name|maxh
init|;
name|pagebuf
index|[
name|i
index|]
index|[
name|k
index|]
operator|==
literal|' '
condition|;
name|k
operator|--
control|)
empty_stmt|;
if|if
condition|(
name|k
operator|>
name|minh
operator|+
name|linelen
condition|)
name|k
operator|=
name|minh
operator|+
name|linelen
expr_stmt|;
for|for
control|(
name|j
operator|=
name|minh
init|;
name|j
operator|<=
name|k
condition|;
name|j
operator|++
control|)
name|putchar
argument_list|(
name|pagebuf
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|t_text
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* print string s as text */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
name|char
name|str
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
return|return;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
switch|switch
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'\\'
case|:
case|case
literal|'e'
case|:
name|put1
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|str
index|[
literal|0
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|str
index|[
literal|1
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|str
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|put1s
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|put1
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|hmot
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|put1s
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* s is a funny char name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|prev
index|[
literal|10
index|]
init|=
literal|""
decl_stmt|;
specifier|static
name|int
name|previ
decl_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|prev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|previ
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|spectab
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|spectab
index|[
name|i
index|]
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|prev
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|previ
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|previ
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
name|spectab
index|[
name|previ
operator|+
literal|1
index|]
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|store
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|prev
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_macro
name|put1
argument_list|(
argument|c
argument_list|)
end_macro

begin_comment
comment|/* output char c */
end_comment

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|output
condition|)
return|return;
name|store
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|done
argument_list|()
end_macro

begin_block
block|{
name|output
operator|=
literal|1
expr_stmt|;
name|putpage
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|readch
argument_list|()
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|;
specifier|static
name|FILE
modifier|*
name|rcf
decl_stmt|;
specifier|static
name|nbol
expr_stmt|;
comment|/* 0 if at beginning of a line */
if|if
condition|(
name|rcf
operator|==
name|NULL
condition|)
block|{
name|rcf
operator|=
name|fopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|rcf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nbol
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dterm: "
argument_list|)
expr_stmt|;
comment|/* issue prompt */
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|rcf
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return
literal|0
return|;
name|nbol
operator|=
operator|(
name|c
operator|!=
literal|'\n'
operator|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_block

begin_macro
name|store
argument_list|(
argument|c
argument_list|)
end_macro

begin_comment
comment|/* put 'c' in the page at (hpos, vpos) */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|i
operator|=
name|hpos
operator|/
name|hscale
expr_stmt|;
comment|/* scale the position to page coordinates */
name|j
operator|=
name|vpos
operator|/
name|vscale
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|PGWIDTH
condition|)
name|i
operator|=
name|PGWIDTH
operator|-
literal|1
expr_stmt|;
comment|/* don't go over the edge */
elseif|else
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|PGHEIGHT
condition|)
name|j
operator|=
name|PGHEIGHT
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|j
operator|=
literal|0
expr_stmt|;
name|pagebuf
index|[
name|j
index|]
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
comment|/* write the character */
if|if
condition|(
name|i
operator|>
name|maxh
condition|)
name|maxh
operator|=
name|i
expr_stmt|;
comment|/* update the page bounds */
if|if
condition|(
name|i
operator|<
name|minh
condition|)
name|minh
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|maxv
condition|)
name|maxv
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|minv
condition|)
name|minv
operator|=
name|j
expr_stmt|;
block|}
end_block

begin_macro
name|drawline
argument_list|(
argument|dx
argument_list|,
argument|dy
argument_list|,
argument|s
argument_list|)
end_macro

begin_comment
comment|/* draw line from here to dx, dy using s */
end_comment

begin_decl_stmt
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|xd
decl_stmt|;
specifier|register
name|int
name|yd
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|numdots
decl_stmt|;
name|int
name|dirmot
decl_stmt|,
name|perp
decl_stmt|;
name|int
name|motincr
decl_stmt|,
name|perpincr
decl_stmt|;
name|int
name|ohpos
decl_stmt|,
name|ovpos
decl_stmt|;
name|float
name|val
decl_stmt|,
name|slope
decl_stmt|;
name|float
name|incrway
decl_stmt|;
name|ohpos
operator|=
name|hpos
expr_stmt|;
name|ovpos
operator|=
name|vpos
expr_stmt|;
name|xd
operator|=
name|dx
operator|/
name|DP
expr_stmt|;
name|yd
operator|=
name|dy
operator|/
name|DP
expr_stmt|;
if|if
condition|(
name|xd
operator|==
literal|0
condition|)
block|{
name|numdots
operator|=
name|abs
argument_list|(
name|yd
argument_list|)
expr_stmt|;
name|numdots
operator|=
name|min
argument_list|(
name|numdots
argument_list|,
name|maxdots
argument_list|)
expr_stmt|;
name|motincr
operator|=
name|DP
operator|*
name|sgn
argument_list|(
name|yd
argument_list|)
expr_stmt|;
name|put1
argument_list|(
name|drawdot
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdots
condition|;
name|i
operator|++
control|)
block|{
name|vmot
argument_list|(
name|motincr
argument_list|)
expr_stmt|;
name|put1
argument_list|(
name|drawdot
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|yd
operator|==
literal|0
condition|)
block|{
name|numdots
operator|=
name|abs
argument_list|(
name|xd
argument_list|)
expr_stmt|;
name|numdots
operator|=
name|min
argument_list|(
name|numdots
argument_list|,
name|maxdots
argument_list|)
expr_stmt|;
name|motincr
operator|=
name|DP
operator|*
name|sgn
argument_list|(
name|xd
argument_list|)
expr_stmt|;
name|put1
argument_list|(
name|drawdot
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdots
condition|;
name|i
operator|++
control|)
block|{
name|hmot
argument_list|(
name|motincr
argument_list|)
expr_stmt|;
name|put1
argument_list|(
name|drawdot
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|abs
argument_list|(
name|xd
argument_list|)
operator|>
name|abs
argument_list|(
name|yd
argument_list|)
condition|)
block|{
name|val
operator|=
name|slope
operator|=
operator|(
name|float
operator|)
name|xd
operator|/
name|yd
expr_stmt|;
name|numdots
operator|=
name|abs
argument_list|(
name|xd
argument_list|)
expr_stmt|;
name|dirmot
operator|=
literal|'h'
expr_stmt|;
name|perp
operator|=
literal|'v'
expr_stmt|;
name|motincr
operator|=
name|DP
operator|*
name|sgn
argument_list|(
name|xd
argument_list|)
expr_stmt|;
name|perpincr
operator|=
name|DP
operator|*
name|sgn
argument_list|(
name|yd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|slope
operator|=
operator|(
name|float
operator|)
name|yd
operator|/
name|xd
expr_stmt|;
name|numdots
operator|=
name|abs
argument_list|(
name|yd
argument_list|)
expr_stmt|;
name|dirmot
operator|=
literal|'v'
expr_stmt|;
name|perp
operator|=
literal|'h'
expr_stmt|;
name|motincr
operator|=
name|DP
operator|*
name|sgn
argument_list|(
name|yd
argument_list|)
expr_stmt|;
name|perpincr
operator|=
name|DP
operator|*
name|sgn
argument_list|(
name|xd
argument_list|)
expr_stmt|;
block|}
name|numdots
operator|=
name|min
argument_list|(
name|numdots
argument_list|,
name|maxdots
argument_list|)
expr_stmt|;
name|incrway
operator|=
name|sgn
argument_list|(
operator|(
name|int
operator|)
name|slope
argument_list|)
expr_stmt|;
name|put1
argument_list|(
name|drawdot
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdots
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|-=
name|incrway
expr_stmt|;
if|if
condition|(
name|dirmot
operator|==
literal|'h'
condition|)
name|hmot
argument_list|(
name|motincr
argument_list|)
expr_stmt|;
else|else
name|vmot
argument_list|(
name|motincr
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|*
name|slope
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|perp
operator|==
literal|'h'
condition|)
name|hmot
argument_list|(
name|perpincr
argument_list|)
expr_stmt|;
else|else
name|vmot
argument_list|(
name|perpincr
argument_list|)
expr_stmt|;
name|val
operator|+=
name|slope
expr_stmt|;
block|}
name|put1
argument_list|(
name|drawdot
argument_list|)
expr_stmt|;
block|}
block|}
name|hgoto
argument_list|(
name|ohpos
operator|+
name|dx
argument_list|)
expr_stmt|;
name|vgoto
argument_list|(
name|ovpos
operator|+
name|dy
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|drawwig
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* draw wiggly line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
index|[
literal|50
index|]
decl_stmt|,
name|y
index|[
literal|50
index|]
decl_stmt|,
name|xp
decl_stmt|,
name|yp
decl_stmt|,
name|pxp
decl_stmt|,
name|pyp
decl_stmt|;
name|float
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|w
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|numdots
decl_stmt|,
name|N
decl_stmt|;
name|char
name|temp
index|[
literal|50
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|getstr
argument_list|()
decl_stmt|;
name|p
operator|=
name|s
expr_stmt|;
for|for
control|(
name|N
operator|=
literal|2
init|;
operator|(
name|p
operator|=
name|getstr
argument_list|(
name|p
argument_list|,
name|temp
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|N
operator|<
sizeof|sizeof
argument_list|(
name|x
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|x
index|[
literal|0
index|]
argument_list|)
condition|;
control|)
block|{
name|x
index|[
name|N
index|]
operator|=
name|atoi
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|p
operator|=
name|getstr
argument_list|(
name|p
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|y
index|[
name|N
operator|++
index|]
operator|=
name|atoi
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|x
index|[
literal|0
index|]
operator|=
name|x
index|[
literal|1
index|]
operator|=
name|hpos
expr_stmt|;
name|y
index|[
literal|0
index|]
operator|=
name|y
index|[
literal|1
index|]
operator|=
name|vpos
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|N
condition|;
name|i
operator|++
control|)
block|{
name|x
index|[
name|i
operator|+
literal|1
index|]
operator|+=
name|x
index|[
name|i
index|]
expr_stmt|;
name|y
index|[
name|i
operator|+
literal|1
index|]
operator|+=
name|y
index|[
name|i
index|]
expr_stmt|;
block|}
name|x
index|[
name|N
index|]
operator|=
name|x
index|[
name|N
operator|-
literal|1
index|]
expr_stmt|;
name|y
index|[
name|N
index|]
operator|=
name|y
index|[
name|N
operator|-
literal|1
index|]
expr_stmt|;
name|pxp
operator|=
name|pyp
operator|=
operator|-
literal|9999
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
comment|/* interval */
name|numdots
operator|=
operator|(
name|dist
argument_list|(
name|x
index|[
name|i
index|]
argument_list|,
name|y
index|[
name|i
index|]
argument_list|,
name|x
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|y
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|+
name|dist
argument_list|(
name|x
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|y
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|x
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
name|y
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
operator|)
operator|/
literal|2
expr_stmt|;
name|numdots
operator|/=
name|DP
expr_stmt|;
name|numdots
operator|=
name|min
argument_list|(
name|numdots
argument_list|,
name|maxdots
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numdots
condition|;
name|j
operator|++
control|)
block|{
comment|/* points within */
name|w
operator|=
operator|(
name|float
operator|)
name|j
operator|/
name|numdots
expr_stmt|;
name|t1
operator|=
literal|0.5
operator|*
name|w
operator|*
name|w
expr_stmt|;
name|w
operator|=
name|w
operator|-
literal|0.5
expr_stmt|;
name|t2
operator|=
literal|0.75
operator|-
name|w
operator|*
name|w
expr_stmt|;
name|w
operator|=
name|w
operator|-
literal|0.5
expr_stmt|;
name|t3
operator|=
literal|0.5
operator|*
name|w
operator|*
name|w
expr_stmt|;
name|xp
operator|=
name|t1
operator|*
name|x
index|[
name|i
operator|+
literal|2
index|]
operator|+
name|t2
operator|*
name|x
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|t3
operator|*
name|x
index|[
name|i
index|]
operator|+
literal|0.5
expr_stmt|;
name|yp
operator|=
name|t1
operator|*
name|y
index|[
name|i
operator|+
literal|2
index|]
operator|+
name|t2
operator|*
name|y
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|t3
operator|*
name|y
index|[
name|i
index|]
operator|+
literal|0.5
expr_stmt|;
if|if
condition|(
name|xp
operator|!=
name|pxp
operator|||
name|yp
operator|!=
name|pyp
condition|)
block|{
name|hgoto
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|vgoto
argument_list|(
name|yp
argument_list|)
expr_stmt|;
name|put1
argument_list|(
name|drawdot
argument_list|)
expr_stmt|;
name|pxp
operator|=
name|xp
expr_stmt|;
name|pyp
operator|=
name|yp
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/* copy next non-blank string from p to temp, update p */
end_comment

begin_function
name|char
modifier|*
name|getstr
parameter_list|(
name|p
parameter_list|,
name|temp
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|,
decl|*
name|temp
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|temp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|*
name|temp
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|temp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_macro
name|drawcirc
argument_list|(
argument|d
argument_list|)
end_macro

begin_block
block|{
name|int
name|xc
decl_stmt|,
name|yc
decl_stmt|;
name|xc
operator|=
name|hpos
expr_stmt|;
name|yc
operator|=
name|vpos
expr_stmt|;
name|conicarc
argument_list|(
name|hpos
operator|+
name|d
operator|/
literal|2
argument_list|,
operator|-
name|vpos
argument_list|,
name|hpos
argument_list|,
operator|-
name|vpos
argument_list|,
name|hpos
argument_list|,
operator|-
name|vpos
argument_list|,
name|d
operator|/
literal|2
argument_list|,
name|d
operator|/
literal|2
argument_list|)
expr_stmt|;
name|hgoto
argument_list|(
name|xc
operator|+
name|d
argument_list|)
expr_stmt|;
comment|/* circle goes to right side */
name|vgoto
argument_list|(
name|yc
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dist
argument_list|(
argument|x1
argument_list|,
argument|y1
argument_list|,
argument|x2
argument_list|,
argument|y2
argument_list|)
end_macro

begin_comment
comment|/* integer distance from x1,y1 to x2,y2 */
end_comment

begin_block
block|{
name|float
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|dx
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
name|dy
operator|=
name|y2
operator|-
name|y1
expr_stmt|;
return|return
name|sqrt
argument_list|(
name|dx
operator|*
name|dx
operator|+
name|dy
operator|*
name|dy
argument_list|)
operator|+
literal|0.5
return|;
block|}
end_block

begin_macro
name|drawarc
argument_list|(
argument|dx1
argument_list|,
argument|dy1
argument_list|,
argument|dx2
argument_list|,
argument|dy2
argument_list|)
end_macro

begin_block
block|{
name|int
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|r
decl_stmt|;
name|x0
operator|=
name|hpos
operator|+
name|dx1
expr_stmt|;
comment|/* center */
name|y0
operator|=
name|vpos
operator|+
name|dy1
expr_stmt|;
name|x2
operator|=
name|x0
operator|+
name|dx2
expr_stmt|;
comment|/* "to" */
name|y2
operator|=
name|y0
operator|+
name|dy2
expr_stmt|;
name|r
operator|=
name|sqrt
argument_list|(
operator|(
name|float
operator|)
name|dx1
operator|*
name|dx1
operator|+
operator|(
name|float
operator|)
name|dy1
operator|*
name|dy1
argument_list|)
operator|+
literal|0.5
expr_stmt|;
name|conicarc
argument_list|(
name|x0
argument_list|,
operator|-
name|y0
argument_list|,
name|hpos
argument_list|,
operator|-
name|vpos
argument_list|,
name|x2
argument_list|,
operator|-
name|y2
argument_list|,
name|r
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|drawellip
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_block
block|{
name|int
name|xc
decl_stmt|,
name|yc
decl_stmt|;
name|xc
operator|=
name|hpos
expr_stmt|;
name|yc
operator|=
name|vpos
expr_stmt|;
name|conicarc
argument_list|(
name|hpos
operator|+
name|a
operator|/
literal|2
argument_list|,
operator|-
name|vpos
argument_list|,
name|hpos
argument_list|,
operator|-
name|vpos
argument_list|,
name|hpos
argument_list|,
operator|-
name|vpos
argument_list|,
name|a
operator|/
literal|2
argument_list|,
name|b
operator|/
literal|2
argument_list|)
expr_stmt|;
name|hgoto
argument_list|(
name|xc
operator|+
name|a
argument_list|)
expr_stmt|;
name|vgoto
argument_list|(
name|yc
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|conicarc
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|x0
argument_list|,
argument|y0
argument_list|,
argument|x1
argument_list|,
argument|y1
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_block
block|{
comment|/* based on Bresenham, CACM Feb 77, pp 102-3 by Chris Van Wyk */
comment|/* capitalized vars are an internal reference frame */
name|long
name|dotcount
init|=
literal|0
decl_stmt|;
name|int
name|xs
decl_stmt|,
name|ys
decl_stmt|,
name|xt
decl_stmt|,
name|yt
decl_stmt|,
name|Xs
decl_stmt|,
name|Ys
decl_stmt|,
name|qs
decl_stmt|,
name|Xt
decl_stmt|,
name|Yt
decl_stmt|,
name|qt
decl_stmt|,
name|M1x
decl_stmt|,
name|M1y
decl_stmt|,
name|M2x
decl_stmt|,
name|M2y
decl_stmt|,
name|M3x
decl_stmt|,
name|M3y
decl_stmt|,
name|Q
decl_stmt|,
name|move
decl_stmt|,
name|Xc
decl_stmt|,
name|Yc
decl_stmt|;
name|int
name|ox1
decl_stmt|,
name|oy1
decl_stmt|;
name|long
name|delta
decl_stmt|;
name|float
name|xc
decl_stmt|,
name|yc
decl_stmt|;
name|float
name|radius
decl_stmt|,
name|slope
decl_stmt|;
name|float
name|xstep
decl_stmt|,
name|ystep
decl_stmt|;
name|ox1
operator|=
name|x1
expr_stmt|;
name|oy1
operator|=
name|y1
expr_stmt|;
if|if
condition|(
name|a
operator|!=
name|b
condition|)
comment|/* an arc of an ellipse; internally, think of circle */
if|if
condition|(
name|a
operator|>
name|b
condition|)
block|{
name|xstep
operator|=
operator|(
name|float
operator|)
name|a
operator|/
name|b
expr_stmt|;
name|ystep
operator|=
literal|1
expr_stmt|;
name|radius
operator|=
name|b
expr_stmt|;
block|}
else|else
block|{
name|xstep
operator|=
literal|1
expr_stmt|;
name|ystep
operator|=
operator|(
name|float
operator|)
name|b
operator|/
name|a
expr_stmt|;
name|radius
operator|=
name|a
expr_stmt|;
block|}
else|else
block|{
comment|/* a circular arc; radius computed from center and first point */
name|xstep
operator|=
name|ystep
operator|=
literal|1
expr_stmt|;
name|radius
operator|=
name|sqrt
argument_list|(
call|(
name|float
call|)
argument_list|(
name|sqr
argument_list|(
name|x0
operator|-
name|x
argument_list|)
operator|+
name|sqr
argument_list|(
name|y0
operator|-
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|xc
operator|=
name|x0
expr_stmt|;
name|yc
operator|=
name|y0
expr_stmt|;
comment|/* now, use start and end point locations to figure out 	the angle at which start and end happen; use these 	angles with known radius to figure out where start 	and end should be 	*/
name|slope
operator|=
name|atan2
argument_list|(
call|(
name|double
call|)
argument_list|(
name|y0
operator|-
name|y
argument_list|)
argument_list|,
call|(
name|double
call|)
argument_list|(
name|x0
operator|-
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|slope
operator|==
literal|0.0
operator|&&
name|x0
operator|<
name|x
condition|)
name|slope
operator|=
literal|3.14159265
expr_stmt|;
name|x0
operator|=
name|x
operator|+
name|radius
operator|*
name|cos
argument_list|(
name|slope
argument_list|)
operator|+
literal|0.5
expr_stmt|;
name|y0
operator|=
name|y
operator|+
name|radius
operator|*
name|sin
argument_list|(
name|slope
argument_list|)
operator|+
literal|0.5
expr_stmt|;
name|slope
operator|=
name|atan2
argument_list|(
call|(
name|double
call|)
argument_list|(
name|y1
operator|-
name|y
argument_list|)
argument_list|,
call|(
name|double
call|)
argument_list|(
name|x1
operator|-
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|slope
operator|==
literal|0.0
operator|&&
name|x1
operator|<
name|x
condition|)
name|slope
operator|=
literal|3.14159265
expr_stmt|;
name|x1
operator|=
name|x
operator|+
name|radius
operator|*
name|cos
argument_list|(
name|slope
argument_list|)
operator|+
literal|0.5
expr_stmt|;
name|y1
operator|=
name|y
operator|+
name|radius
operator|*
name|sin
argument_list|(
name|slope
argument_list|)
operator|+
literal|0.5
expr_stmt|;
comment|/* step 2: translate to zero-centered circle */
name|xs
operator|=
name|x0
operator|-
name|x
expr_stmt|;
name|ys
operator|=
name|y0
operator|-
name|y
expr_stmt|;
name|xt
operator|=
name|x1
operator|-
name|x
expr_stmt|;
name|yt
operator|=
name|y1
operator|-
name|y
expr_stmt|;
comment|/* step 3: normalize to first quadrant */
if|if
condition|(
name|xs
operator|<
literal|0
condition|)
if|if
condition|(
name|ys
operator|<
literal|0
condition|)
block|{
name|Xs
operator|=
name|abs
argument_list|(
name|ys
argument_list|)
expr_stmt|;
name|Ys
operator|=
name|abs
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|qs
operator|=
literal|3
expr_stmt|;
name|M1x
operator|=
literal|0
expr_stmt|;
name|M1y
operator|=
operator|-
literal|1
expr_stmt|;
name|M2x
operator|=
literal|1
expr_stmt|;
name|M2y
operator|=
operator|-
literal|1
expr_stmt|;
name|M3x
operator|=
literal|1
expr_stmt|;
name|M3y
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Xs
operator|=
name|abs
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|Ys
operator|=
name|abs
argument_list|(
name|ys
argument_list|)
expr_stmt|;
name|qs
operator|=
literal|2
expr_stmt|;
name|M1x
operator|=
operator|-
literal|1
expr_stmt|;
name|M1y
operator|=
literal|0
expr_stmt|;
name|M2x
operator|=
operator|-
literal|1
expr_stmt|;
name|M2y
operator|=
operator|-
literal|1
expr_stmt|;
name|M3x
operator|=
literal|0
expr_stmt|;
name|M3y
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ys
operator|<
literal|0
condition|)
block|{
name|Xs
operator|=
name|abs
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|Ys
operator|=
name|abs
argument_list|(
name|ys
argument_list|)
expr_stmt|;
name|qs
operator|=
literal|0
expr_stmt|;
name|M1x
operator|=
literal|1
expr_stmt|;
name|M1y
operator|=
literal|0
expr_stmt|;
name|M2x
operator|=
literal|1
expr_stmt|;
name|M2y
operator|=
literal|1
expr_stmt|;
name|M3x
operator|=
literal|0
expr_stmt|;
name|M3y
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|Xs
operator|=
name|abs
argument_list|(
name|ys
argument_list|)
expr_stmt|;
name|Ys
operator|=
name|abs
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|qs
operator|=
literal|1
expr_stmt|;
name|M1x
operator|=
literal|0
expr_stmt|;
name|M1y
operator|=
literal|1
expr_stmt|;
name|M2x
operator|=
operator|-
literal|1
expr_stmt|;
name|M2y
operator|=
literal|1
expr_stmt|;
name|M3x
operator|=
operator|-
literal|1
expr_stmt|;
name|M3y
operator|=
literal|0
expr_stmt|;
block|}
name|Xc
operator|=
name|Xs
expr_stmt|;
name|Yc
operator|=
name|Ys
expr_stmt|;
if|if
condition|(
name|xt
operator|<
literal|0
condition|)
if|if
condition|(
name|yt
operator|<
literal|0
condition|)
block|{
name|Xt
operator|=
name|abs
argument_list|(
name|yt
argument_list|)
expr_stmt|;
name|Yt
operator|=
name|abs
argument_list|(
name|xt
argument_list|)
expr_stmt|;
name|qt
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|Xt
operator|=
name|abs
argument_list|(
name|xt
argument_list|)
expr_stmt|;
name|Yt
operator|=
name|abs
argument_list|(
name|yt
argument_list|)
expr_stmt|;
name|qt
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yt
operator|<
literal|0
condition|)
block|{
name|Xt
operator|=
name|abs
argument_list|(
name|xt
argument_list|)
expr_stmt|;
name|Yt
operator|=
name|abs
argument_list|(
name|yt
argument_list|)
expr_stmt|;
name|qt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Xt
operator|=
name|abs
argument_list|(
name|yt
argument_list|)
expr_stmt|;
name|Yt
operator|=
name|abs
argument_list|(
name|xt
argument_list|)
expr_stmt|;
name|qt
operator|=
literal|1
expr_stmt|;
block|}
comment|/* step 4: calculate number of quadrant crossings */
if|if
condition|(
operator|(
operator|(
literal|4
operator|+
name|qt
operator|-
name|qs
operator|)
operator|%
literal|4
operator|==
literal|0
operator|)
operator|&&
operator|(
name|Xt
operator|<=
name|Xs
operator|)
operator|&&
operator|(
name|Yt
operator|>=
name|Ys
operator|)
condition|)
name|Q
operator|=
literal|3
expr_stmt|;
else|else
name|Q
operator|=
operator|(
literal|4
operator|+
name|qt
operator|-
name|qs
operator|)
operator|%
literal|4
operator|-
literal|1
expr_stmt|;
comment|/* step 5: calculate initial decision difference */
name|delta
operator|=
name|sqr
argument_list|(
name|Xs
operator|+
literal|1
argument_list|)
operator|+
name|sqr
argument_list|(
name|Ys
operator|-
literal|1
argument_list|)
operator|-
name|sqr
argument_list|(
name|xs
argument_list|)
operator|-
name|sqr
argument_list|(
name|ys
argument_list|)
expr_stmt|;
comment|/* here begins the work of drawing. */
while|while
condition|(
operator|(
name|Q
operator|>=
literal|0
operator|)
operator|||
operator|(
operator|(
name|Q
operator|>
operator|-
literal|2
operator|)
operator|&&
operator|(
operator|(
name|Xt
operator|>
name|Xc
operator|)
operator|&&
operator|(
name|Yt
operator|<
name|Yc
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|dotcount
operator|++
operator|%
name|DP
operator|==
literal|0
condition|)
name|putdot
argument_list|(
operator|(
name|int
operator|)
name|xc
argument_list|,
operator|(
name|int
operator|)
name|yc
argument_list|)
expr_stmt|;
if|if
condition|(
name|Yc
operator|<
literal|0.5
condition|)
block|{
comment|/* reinitialize */
name|Xs
operator|=
name|Xc
operator|=
literal|0
expr_stmt|;
name|Ys
operator|=
name|Yc
operator|=
name|sqrt
argument_list|(
call|(
name|float
call|)
argument_list|(
name|sqr
argument_list|(
name|xs
argument_list|)
operator|+
name|sqr
argument_list|(
name|ys
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|=
name|sqr
argument_list|(
name|Xs
operator|+
literal|1
argument_list|)
operator|+
name|sqr
argument_list|(
name|Ys
operator|-
literal|1
argument_list|)
operator|-
name|sqr
argument_list|(
name|xs
argument_list|)
operator|-
name|sqr
argument_list|(
name|ys
argument_list|)
expr_stmt|;
name|Q
operator|--
expr_stmt|;
name|M1x
operator|=
name|M3x
expr_stmt|;
name|M1y
operator|=
name|M3y
expr_stmt|;
block|{
name|int
name|T
decl_stmt|;
name|T
operator|=
name|M2y
expr_stmt|;
name|M2y
operator|=
name|M2x
expr_stmt|;
name|M2x
operator|=
operator|-
name|T
expr_stmt|;
name|T
operator|=
name|M3y
expr_stmt|;
name|M3y
operator|=
name|M3x
expr_stmt|;
name|M3x
operator|=
operator|-
name|T
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|delta
operator|<=
literal|0
condition|)
if|if
condition|(
literal|2
operator|*
name|delta
operator|+
literal|2
operator|*
name|Yc
operator|-
literal|1
operator|<=
literal|0
condition|)
name|move
operator|=
literal|1
expr_stmt|;
else|else
name|move
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
literal|2
operator|*
name|delta
operator|-
literal|2
operator|*
name|Xc
operator|-
literal|1
operator|<=
literal|0
condition|)
name|move
operator|=
literal|2
expr_stmt|;
else|else
name|move
operator|=
literal|3
expr_stmt|;
switch|switch
condition|(
name|move
condition|)
block|{
case|case
literal|1
case|:
name|Xc
operator|++
expr_stmt|;
name|delta
operator|+=
literal|2
operator|*
name|Xc
operator|+
literal|1
expr_stmt|;
name|xc
operator|+=
name|M1x
operator|*
name|xstep
expr_stmt|;
name|yc
operator|+=
name|M1y
operator|*
name|ystep
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|Xc
operator|++
expr_stmt|;
name|Yc
operator|--
expr_stmt|;
name|delta
operator|+=
literal|2
operator|*
name|Xc
operator|-
literal|2
operator|*
name|Yc
operator|+
literal|2
expr_stmt|;
name|xc
operator|+=
name|M2x
operator|*
name|xstep
expr_stmt|;
name|yc
operator|+=
name|M2y
operator|*
name|ystep
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|Yc
operator|--
expr_stmt|;
name|delta
operator|-=
literal|2
operator|*
name|Yc
operator|+
literal|1
expr_stmt|;
name|xc
operator|+=
name|M3x
operator|*
name|xstep
expr_stmt|;
name|yc
operator|+=
name|M3y
operator|*
name|ystep
expr_stmt|;
break|break;
block|}
block|}
block|}
name|drawline
argument_list|(
operator|(
name|int
operator|)
name|xc
operator|-
name|ox1
argument_list|,
operator|(
name|int
operator|)
name|yc
operator|-
name|oy1
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putdot
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_block
block|{
name|arcmove
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|put1
argument_list|(
name|drawdot
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

