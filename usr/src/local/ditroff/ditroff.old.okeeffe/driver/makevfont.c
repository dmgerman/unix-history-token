begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	makevfont.c	(Berkeley)	85/05/03	1.6  *  * Font description file producer for versatec fonts:  David Slattengren  * Taken from vfontinfo by Andy Hertzfeld  4/79  *  *	Use:  makevfont [ -nNAME ]  [ -s -a -o -l -c -p# -r# -f# -ddir ]  *		[ "-xs1,s2[;s1,s2...]" ]  [ "-ys1,s2[;s1,s2...]" ]  font  *  *	Makefont takes the font named "font" (with or without pointsize  *	extension on the filename) and produces a ditroff description file  *	from it.  The -n option takes the 1 or 2 letter troff name to put  *	the description (default = XX).  The -f option takes an integer per-  *	centage factor to multiply widths by.  The -s, -o and -a options select  *	a different character mapping than for a "roman" font.  s = special;  *	o = otimespecal; a = ascii.  The -l option indicates it has ligatures.  *	The -c option tells makevfont that the font is constant width and  *	will set parameters appropriately.  *  *	Both -x and -y options allow character name mapping.  A colon separated  *	list of comma-separated character-name pairs follows the x or y.  *	Notice that there are no spaces in the -x or -y command.  A -x pair  *	REPLACES the definition for s1 by s2.  A -y pair creates a synonym for  *	s1 and calls it s2.  -x and -y MUST be sent after -s, -m, -i, or -a  *	if one of them is used.  Some synonyms are defaulted.  To remove a  *	synonym or character, leave out s2.  *  *	The -p# option tells what point size the DESC file has as it's  *	"unitwidth" argument (default: 36).  The -r# option is the resolution  *	of the device (default: 200, in units/inch).  The -d option tells  *	where to find fonts (default: /usr/lib/vfont).  */
end_comment

begin_comment
comment|/*  *  Here's an ascii character set, just in case you need it:       | 00 nul| 01 soh| 02 stx| 03 etx| 04 eot| 05 enq| 06 ack| 07 bel|      | 08 bs | 09 ht | 0a nl | 0b vt | 0c np | 0d cr | 0e so | 0f si |      | 10 dle| 11 dc1| 12 dc2| 13 dc3| 14 dc4| 15 nak| 16 syn| 17 etb|      | 18 can| 19 em | 1a sub| 1b esc| 1c fs | 1d gs | 1e rs | 1f us |      | 20 sp | 21  ! | 22  " | 23  # | 24  $ | 25  % | 26& | 27  ' |      | 28  ( | 29  ) | 2a  * | 2b  + | 2c  , | 2d  - | 2e  . | 2f  / |      | 30  0 | 31  1 | 32  2 | 33  3 | 34  4 | 35  5 | 36  6 | 37  7 |      | 38  8 | 39  9 | 3a  : | 3b  ; | 3c< | 3d  = | 3e> | 3f  ? |      | 40  @ | 41  A | 42  B | 43  C | 44  D | 45  E | 46  F | 47  G |      | 48  H | 49  I | 4a  J | 4b  K | 4c  L | 4d  M | 4e  N | 4f  O |      | 50  P | 51  Q | 52  R | 53  S | 54  T | 55  U | 56  V | 57  W |      | 58  X | 59  Y | 5a  Z | 5b  [ | 5c  \ | 5d  ] | 5e  ^ | 5f  _ |      | 60  ` | 61  a | 62  b | 63  c | 64  d | 65  e | 66  f | 67  g |      | 68  h | 69  i | 6a  j | 6b  k | 6c  l | 6d  m | 6e  n | 6f  o |      | 70  p | 71  q | 72  r | 73  s | 74  t | 75  u | 76  v | 77  w |      | 78  x | 79  y | 7a  z | 7b  { | 7c  | | 7d  } | 7e  ~ | 7f del|   *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<vfont.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_decl_stmt
name|char
name|sccsid
index|[]
init|=
literal|"@(#)makevfont.c	1.6	(Berkeley)	%G%"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAGICN
value|0436
end_define

begin_comment
comment|/* font file magic number */
end_comment

begin_define
define|#
directive|define
name|PCNTUP
value|62
end_define

begin_comment
comment|/* percent of maximum height for an ascender */
end_comment

begin_define
define|#
directive|define
name|PCNTDOWN
value|73
end_define

begin_comment
comment|/* percent of maximum droop for a descender */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BITDIR
end_ifndef

begin_define
define|#
directive|define
name|BITDIR
value|"/usr/lib/vfont"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|POINTSIZE
value|36
end_define

begin_comment
comment|/* this is the "unitwidth" point size */
end_comment

begin_define
define|#
directive|define
name|MINSIZE
value|6
end_define

begin_comment
comment|/* the minimum and maximum point size values */
end_comment

begin_define
define|#
directive|define
name|MAXSIZE
value|36
end_define

begin_comment
comment|/*    acceptible for use as "unitwidth"s */
end_comment

begin_define
define|#
directive|define
name|RESOLUTION
value|200
end_define

begin_comment
comment|/* resolution of versatec (dots/inch) */
end_comment

begin_define
define|#
directive|define
name|MINRES
value|10
end_define

begin_comment
comment|/* check up on resolution input by setting */
end_comment

begin_define
define|#
directive|define
name|MAXRES
value|100000
end_define

begin_comment
comment|/*    absurdly out-of-range limits on them */
end_comment

begin_define
define|#
directive|define
name|APOINT
value|72
end_define

begin_comment
comment|/* 1/APOINT inches = 1 point */
end_comment

begin_define
define|#
directive|define
name|SYNON
value|100
end_define

begin_comment
comment|/* 2 * pairs allowed in synonym table */
end_comment

begin_decl_stmt
name|struct
name|header
name|FontHeader
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dispatch
name|disptable
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|res
init|=
name|RESOLUTION
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* resolution of the device (units/inch) */
end_comment

begin_decl_stmt
name|int
name|pointsize
init|=
name|POINTSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* point size being used for unitwidth */
end_comment

begin_decl_stmt
name|int
name|factor
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* percent for magnifying (shrinking) widths */
end_comment

begin_decl_stmt
name|int
name|psize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* point size of font actually used */
end_comment

begin_decl_stmt
name|int
name|psizelist
index|[]
init|=
block|{
literal|36
block|,
literal|24
block|,
literal|22
block|,
literal|20
block|,
literal|18
block|,
literal|16
block|,
literal|14
block|,
literal|28
block|,
literal|12
block|,
literal|11
block|,
literal|10
block|,
literal|9
block|,
literal|8
block|,
literal|7
block|,
literal|6
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fontname
init|=
literal|"XX"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* troff font name - set on command line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fontdir
init|=
name|BITDIR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place to look for fonts */
end_comment

begin_decl_stmt
name|char
name|IName
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file name put here */
end_comment

begin_function_decl
name|char
modifier|*
name|rdchar
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* function makes strings for ascii */
end_comment

begin_decl_stmt
name|int
name|FID
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file number */
end_comment

begin_decl_stmt
name|int
name|maxdown
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of the most "droopy" character */
end_comment

begin_decl_stmt
name|int
name|maxup
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of the tallest character */
end_comment

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1, 2, or 3 for type of ascend/descending */
end_comment

begin_decl_stmt
name|int
name|nullchar
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* finds non-existant character in the font */
end_comment

begin_decl_stmt
name|int
name|ligsf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag "does this font have ligatures?" */
end_comment

begin_decl_stmt
name|int
name|constant
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag constant width font (spacewidth, etc.)*/
end_comment

begin_comment
comment|/* following are the character maps for */
end_comment

begin_comment
comment|/* ascii code-conversion to printables... */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|charmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|synonyms
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numsyn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|vregular
index|[]
init|=
block|{
literal|"??"
block|,
literal|"fi"
block|,
literal|"fl"
block|,
literal|"ff"
block|,
literal|"\\-"
block|,
literal|"ru"
block|,
literal|"em"
block|,
literal|"bu"
block|,
literal|"sq"
block|,
literal|"Fi"
block|,
literal|"Fl"
block|,
literal|"de"
block|,
literal|"dg"
block|,
literal|"fm"
block|,
literal|"co"
block|,
literal|"rg"
block|,
literal|"ct"
block|,
literal|"14"
block|,
literal|"12"
block|,
literal|"34"
block|,
literal|"^T"
block|,
literal|"^U"
block|,
literal|"^V"
block|,
literal|"^W"
block|,
literal|"^X"
block|,
literal|"^Y"
block|,
literal|"^Z"
block|,
literal|"^["
block|,
literal|"^\\"
block|,
literal|"^]"
block|,
literal|"^^"
block|,
literal|"^_"
block|,
literal|""
block|,
literal|"!"
block|,
literal|"\""
block|,
literal|"#"
block|,
literal|"$"
block|,
literal|"%"
block|,
literal|"&"
block|,
literal|"'"
block|,
literal|"("
block|,
literal|")"
block|,
literal|"*"
block|,
literal|"+"
block|,
literal|","
block|,
literal|"-"
block|,
literal|"."
block|,
literal|"/"
block|,
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|":"
block|,
literal|";"
block|,
literal|"<"
block|,
literal|"="
block|,
literal|">"
block|,
literal|"?"
block|,
literal|"@"
block|,
literal|"A"
block|,
literal|"B"
block|,
literal|"C"
block|,
literal|"D"
block|,
literal|"E"
block|,
literal|"F"
block|,
literal|"G"
block|,
literal|"H"
block|,
literal|"I"
block|,
literal|"J"
block|,
literal|"K"
block|,
literal|"L"
block|,
literal|"M"
block|,
literal|"N"
block|,
literal|"O"
block|,
literal|"P"
block|,
literal|"Q"
block|,
literal|"R"
block|,
literal|"S"
block|,
literal|"T"
block|,
literal|"U"
block|,
literal|"V"
block|,
literal|"W"
block|,
literal|"X"
block|,
literal|"Y"
block|,
literal|"Z"
block|,
literal|"["
block|,
literal|"\\"
block|,
literal|"]"
block|,
literal|"^"
block|,
literal|"_"
block|,
literal|"`"
block|,
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|,
literal|"d"
block|,
literal|"e"
block|,
literal|"f"
block|,
literal|"g"
block|,
literal|"h"
block|,
literal|"i"
block|,
literal|"j"
block|,
literal|"k"
block|,
literal|"l"
block|,
literal|"m"
block|,
literal|"n"
block|,
literal|"o"
block|,
literal|"p"
block|,
literal|"q"
block|,
literal|"r"
block|,
literal|"s"
block|,
literal|"t"
block|,
literal|"u"
block|,
literal|"v"
block|,
literal|"w"
block|,
literal|"x"
block|,
literal|"y"
block|,
literal|"z"
block|,
literal|"{"
block|,
literal|"|"
block|,
literal|"}"
block|,
literal|"~"
block|,
literal|"^?"
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nregular
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sregular
index|[
name|SYNON
index|]
init|=
block|{
literal|"-"
block|,
literal|"hy"
block|,
literal|"_"
block|,
literal|"\\_"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|vspecial
index|[]
init|=
block|{
literal|"??"
block|,
literal|"if"
block|,
literal|"ip"
block|,
literal|"pt"
block|,
literal|"rh"
block|,
literal|"cu"
block|,
literal|"rn"
block|,
literal|"bs"
block|,
literal|"+-"
block|,
literal|"<="
block|,
literal|">="
block|,
literal|"sr"
block|,
literal|"ts"
block|,
literal|"is"
block|,
literal|"sl"
block|,
literal|"bv"
block|,
literal|"lf"
block|,
literal|"rf"
block|,
literal|"lc"
block|,
literal|"rc"
block|,
literal|"lt"
block|,
literal|"lb"
block|,
literal|"rt"
block|,
literal|"rb"
block|,
literal|"lk"
block|,
literal|"rk"
block|,
literal|"sb"
block|,
literal|"sp"
block|,
literal|"ca"
block|,
literal|"no"
block|,
literal|"lh"
block|,
literal|"mo"
block|,
literal|""
block|,
literal|"!"
block|,
literal|"\""
block|,
literal|"#"
block|,
literal|"$"
block|,
literal|"%"
block|,
literal|"&"
block|,
literal|"aa"
block|,
literal|"gr"
block|,
literal|")"
block|,
literal|"mu"
block|,
literal|"pl"
block|,
literal|","
block|,
literal|"mi"
block|,
literal|"."
block|,
literal|"di"
block|,
literal|"=="
block|,
literal|"~="
block|,
literal|"ap"
block|,
literal|"!="
block|,
literal|"<-"
block|,
literal|"->"
block|,
literal|"ua"
block|,
literal|"da"
block|,
literal|"sc"
block|,
literal|"**"
block|,
literal|":"
block|,
literal|";"
block|,
literal|"<"
block|,
literal|"eq"
block|,
literal|">"
block|,
literal|"?"
block|,
literal|"@"
block|,
literal|"*A"
block|,
literal|"*B"
block|,
literal|"*G"
block|,
literal|"*D"
block|,
literal|"*E"
block|,
literal|"*Z"
block|,
literal|"*Y"
block|,
literal|"*H"
block|,
literal|"*I"
block|,
literal|"*K"
block|,
literal|"*L"
block|,
literal|"*M"
block|,
literal|"*N"
block|,
literal|"*C"
block|,
literal|"*O"
block|,
literal|"*P"
block|,
literal|"*R"
block|,
literal|"*S"
block|,
literal|"*T"
block|,
literal|"*U"
block|,
literal|"*F"
block|,
literal|"*X"
block|,
literal|"*Q"
block|,
literal|"*W"
block|,
literal|"dd"
block|,
literal|"br"
block|,
literal|"ib"
block|,
literal|"\\"
block|,
literal|"ci"
block|,
literal|"^"
block|,
literal|"ul"
block|,
literal|"ga"
block|,
literal|"*a"
block|,
literal|"*b"
block|,
literal|"*g"
block|,
literal|"*d"
block|,
literal|"*e"
block|,
literal|"*z"
block|,
literal|"*y"
block|,
literal|"*h"
block|,
literal|"*i"
block|,
literal|"*k"
block|,
literal|"*l"
block|,
literal|"*m"
block|,
literal|"*n"
block|,
literal|"*c"
block|,
literal|"*o"
block|,
literal|"*p"
block|,
literal|"*r"
block|,
literal|"*s"
block|,
literal|"*t"
block|,
literal|"*u"
block|,
literal|"es"
block|,
literal|"*x"
block|,
literal|"*q"
block|,
literal|"*w"
block|,
literal|"pd"
block|,
literal|"*f"
block|,
literal|"{"
block|,
literal|"|"
block|,
literal|"}"
block|,
literal|"~"
block|,
literal|"^?"
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nspecial
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sspecial
index|[
name|SYNON
index|]
init|=
block|{
literal|""
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|vtimes
index|[]
init|=
block|{
literal|"??"
block|,
literal|"if"
block|,
literal|"ip"
block|,
literal|"pt"
block|,
literal|"rh"
block|,
literal|"cu"
block|,
literal|"rn"
block|,
literal|"bs"
block|,
literal|"+-"
block|,
literal|"<="
block|,
literal|">="
block|,
literal|"mi"
block|,
literal|"**"
block|,
literal|"pl"
block|,
literal|"eq"
block|,
literal|"gr"
block|,
literal|"lt"
block|,
literal|"lk"
block|,
literal|"lb"
block|,
literal|"rt"
block|,
literal|"rk"
block|,
literal|"rb"
block|,
literal|"ap"
block|,
literal|"mo"
block|,
literal|"br"
block|,
literal|"rk"
block|,
literal|"sb"
block|,
literal|"sp"
block|,
literal|"ca"
block|,
literal|"no"
block|,
literal|"~="
block|,
literal|"mo"
block|,
literal|""
block|,
literal|"da"
block|,
literal|"no"
block|,
literal|"ua"
block|,
literal|"sc"
block|,
literal|"dd"
block|,
literal|"if"
block|,
literal|"pd"
block|,
literal|"sb"
block|,
literal|"sp"
block|,
literal|"mu"
block|,
literal|"+-"
block|,
literal|"ca"
block|,
literal|"cu"
block|,
literal|"<-"
block|,
literal|"di"
block|,
literal|"->"
block|,
literal|"!="
block|,
literal|"sr"
block|,
literal|"<="
block|,
literal|">="
block|,
literal|"=="
block|,
literal|"or"
block|,
literal|"is"
block|,
literal|"bv"
block|,
literal|"lc"
block|,
literal|"rc"
block|,
literal|"lf"
block|,
literal|"rf"
block|,
literal|"~="
block|,
literal|"_"
block|,
literal|"ib"
block|,
literal|"ul"
block|,
literal|"rn"
block|,
literal|"ip"
block|,
literal|"*G"
block|,
literal|"*D"
block|,
literal|"*E"
block|,
literal|"*F"
block|,
literal|"*G"
block|,
literal|"*H"
block|,
literal|"*I"
block|,
literal|"??"
block|,
literal|"*L"
block|,
literal|"*L"
block|,
literal|"*N"
block|,
literal|"*C"
block|,
literal|"*O"
block|,
literal|"*P"
block|,
literal|"*H"
block|,
literal|"*S"
block|,
literal|"*S"
block|,
literal|"*U"
block|,
literal|"*U"
block|,
literal|"*X"
block|,
literal|"*W"
block|,
literal|"*C"
block|,
literal|"*Q"
block|,
literal|"br"
block|,
literal|"ib"
block|,
literal|"ga"
block|,
literal|"aa"
block|,
literal|"^"
block|,
literal|"ul"
block|,
literal|"ga"
block|,
literal|"*a"
block|,
literal|"*b"
block|,
literal|"*g"
block|,
literal|"*d"
block|,
literal|"*e"
block|,
literal|"*z"
block|,
literal|"*y"
block|,
literal|"*h"
block|,
literal|"*i"
block|,
literal|"*k"
block|,
literal|"*l"
block|,
literal|"*m"
block|,
literal|"*n"
block|,
literal|"*c"
block|,
literal|"*o"
block|,
literal|"*p"
block|,
literal|"*r"
block|,
literal|"*s"
block|,
literal|"*t"
block|,
literal|"*u"
block|,
literal|"es"
block|,
literal|"*x"
block|,
literal|"*q"
block|,
literal|"*w"
block|,
literal|"pd"
block|,
literal|"*f"
block|,
literal|"{"
block|,
literal|"|"
block|,
literal|"}"
block|,
literal|"~"
block|,
literal|"^?"
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ntimes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|stimes
index|[
name|SYNON
index|]
init|=
block|{
literal|""
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|vascii
index|[]
init|=
block|{
literal|""
block|,
literal|"da"
block|,
literal|"*a"
block|,
literal|"*b"
block|,
literal|"an"
block|,
literal|"no"
block|,
literal|"mo"
block|,
literal|"*p"
block|,
literal|"*l"
block|,
literal|"*g"
block|,
literal|"*d"
block|,
literal|"ua"
block|,
literal|"+-"
block|,
literal|"O+"
block|,
literal|"if"
block|,
literal|"pd"
block|,
literal|"sb"
block|,
literal|"sp"
block|,
literal|"ca"
block|,
literal|"cu"
block|,
literal|"fa"
block|,
literal|"te"
block|,
literal|"OX"
block|,
literal|"<>"
block|,
literal|"<-"
block|,
literal|"->"
block|,
literal|"!="
block|,
literal|"ap"
block|,
literal|"<="
block|,
literal|">="
block|,
literal|"=="
block|,
literal|"or"
block|,
literal|""
block|,
literal|"!"
block|,
literal|"\""
block|,
literal|"#"
block|,
literal|"$"
block|,
literal|"%"
block|,
literal|"&"
block|,
literal|"'"
block|,
literal|"("
block|,
literal|")"
block|,
literal|"*"
block|,
literal|"+"
block|,
literal|","
block|,
literal|"-"
block|,
literal|"."
block|,
literal|"/"
block|,
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|":"
block|,
literal|";"
block|,
literal|"<"
block|,
literal|"="
block|,
literal|">"
block|,
literal|"?"
block|,
literal|"@"
block|,
literal|"A"
block|,
literal|"B"
block|,
literal|"C"
block|,
literal|"D"
block|,
literal|"E"
block|,
literal|"F"
block|,
literal|"G"
block|,
literal|"H"
block|,
literal|"I"
block|,
literal|"J"
block|,
literal|"K"
block|,
literal|"L"
block|,
literal|"M"
block|,
literal|"N"
block|,
literal|"O"
block|,
literal|"P"
block|,
literal|"Q"
block|,
literal|"R"
block|,
literal|"S"
block|,
literal|"T"
block|,
literal|"U"
block|,
literal|"V"
block|,
literal|"W"
block|,
literal|"X"
block|,
literal|"Y"
block|,
literal|"Z"
block|,
literal|"["
block|,
literal|"\\"
block|,
literal|"]"
block|,
literal|"^"
block|,
literal|"_"
block|,
literal|"`"
block|,
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|,
literal|"d"
block|,
literal|"e"
block|,
literal|"f"
block|,
literal|"g"
block|,
literal|"h"
block|,
literal|"i"
block|,
literal|"j"
block|,
literal|"k"
block|,
literal|"l"
block|,
literal|"m"
block|,
literal|"n"
block|,
literal|"o"
block|,
literal|"p"
block|,
literal|"q"
block|,
literal|"r"
block|,
literal|"s"
block|,
literal|"t"
block|,
literal|"u"
block|,
literal|"v"
block|,
literal|"w"
block|,
literal|"x"
block|,
literal|"y"
block|,
literal|"z"
block|,
literal|"{"
block|,
literal|"|"
block|,
literal|"}"
block|,
literal|"~"
block|,
literal|"??"
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nascii
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sascii
index|[
name|SYNON
index|]
init|=
block|{
literal|"-"
block|,
literal|"hy"
block|,
literal|"-"
block|,
literal|"\\-"
block|,
literal|"_"
block|,
literal|"\\_"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* two indexes */
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* string traveler */
specifier|register
name|char
name|delimit
decl_stmt|;
comment|/* place for delimiters on command line */
name|char
modifier|*
name|replacelist
init|=
name|NULL
decl_stmt|;
comment|/* string of character name replacements */
name|char
modifier|*
name|synonymlist
init|=
name|NULL
decl_stmt|;
comment|/* string of synonym entries */
name|char
name|tostring
parameter_list|()
function_decl|;
comment|/* function makes a string */
name|char
modifier|*
name|nextstring
parameter_list|()
function_decl|;
comment|/* moves to next string on list */
name|char
modifier|*
name|operand
parameter_list|()
function_decl|;
name|charmap
operator|=
name|vregular
expr_stmt|;
comment|/* default character map */
name|synonyms
operator|=
name|sregular
expr_stmt|;
name|numsyn
operator|=
name|nregular
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|*
operator|(
operator|*
operator|(
operator|++
name|argv
operator|)
operator|)
operator|==
literal|'-'
condition|)
block|{
comment|/* do options... */
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'s'
case|:
name|charmap
operator|=
name|vspecial
expr_stmt|;
comment|/* special font */
name|synonyms
operator|=
name|sspecial
expr_stmt|;
name|numsyn
operator|=
name|nspecial
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|charmap
operator|=
name|vtimes
expr_stmt|;
comment|/* times special font */
name|synonyms
operator|=
name|stimes
expr_stmt|;
name|numsyn
operator|=
name|ntimes
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|charmap
operator|=
name|vascii
expr_stmt|;
comment|/* ascii font */
name|synonyms
operator|=
name|sascii
expr_stmt|;
name|numsyn
operator|=
name|nascii
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|constant
operator|=
literal|1
expr_stmt|;
comment|/* constant width font */
break|break;
case|case
literal|'l'
case|:
name|ligsf
operator|=
literal|1
expr_stmt|;
comment|/* ascii font */
break|break;
case|case
literal|'n'
case|:
name|fontname
operator|=
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
comment|/* troff font name */
break|break;
case|case
literal|'x'
case|:
name|replacelist
operator|=
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
comment|/* replacements */
break|break;
case|case
literal|'y'
case|:
name|synonymlist
operator|=
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
comment|/* synonyms */
break|break;
case|case
literal|'d'
case|:
name|fontdir
operator|=
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
comment|/* directory */
break|break;
case|case
literal|'p'
case|:
name|pointsize
operator|=
name|atoi
argument_list|(
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* point size */
if|if
condition|(
name|pointsize
operator|<
name|MINSIZE
operator|||
name|pointsize
operator|>
name|MAXSIZE
condition|)
name|error
argument_list|(
literal|"Illegal point size: %d"
argument_list|,
name|pointsize
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|factor
operator|=
name|atoi
argument_list|(
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  % reduction */
if|if
condition|(
name|factor
operator|<
literal|1
operator|||
name|factor
operator|>
literal|1000
condition|)
name|error
argument_list|(
literal|"Illegal factor: %d"
argument_list|,
name|factor
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|res
operator|=
name|atoi
argument_list|(
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* resolution */
if|if
condition|(
name|res
operator|<
name|MINRES
operator|||
name|res
operator|>
name|MAXRES
condition|)
name|error
argument_list|(
literal|"Illegal resolution: %d"
argument_list|,
name|res
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Bad option: %c"
argument_list|,
operator|*
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* do character name replacements */
if|if
condition|(
name|replacelist
operator|!=
name|NULL
condition|)
block|{
name|ptr
operator|=
name|replacelist
expr_stmt|;
while|while
condition|(
name|delimit
operator|=
name|tostring
argument_list|(
name|ptr
argument_list|,
literal|','
argument_list|)
condition|)
block|{
comment|/* get s1 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|charmap
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
comment|/* search for match */
if|if
condition|(
name|strcmp
argument_list|(
name|charmap
index|[
name|i
index|]
argument_list|,
name|ptr
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|charmap
index|[
name|i
index|]
condition|)
name|error
argument_list|(
literal|"-x option: no match"
argument_list|)
expr_stmt|;
name|charmap
index|[
name|i
index|]
operator|=
name|ptr
operator|=
name|nextstring
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
comment|/* replace s1 */
name|delimit
operator|=
name|tostring
argument_list|(
name|ptr
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
comment|/* with string s2 */
if|if
condition|(
name|delimit
condition|)
name|ptr
operator|=
name|nextstring
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* do the synonym list */
if|if
condition|(
name|synonymlist
operator|!=
name|NULL
condition|)
block|{
name|ptr
operator|=
name|synonymlist
expr_stmt|;
while|while
condition|(
name|delimit
operator|=
name|tostring
argument_list|(
name|ptr
argument_list|,
literal|','
argument_list|)
condition|)
block|{
comment|/* get s1 */
name|synonyms
index|[
literal|2
operator|*
name|numsyn
index|]
operator|=
name|ptr
expr_stmt|;
comment|/* set on end of list */
name|ptr
operator|=
name|nextstring
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
comment|/* get string s2 */
name|delimit
operator|=
name|tostring
argument_list|(
name|ptr
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
condition|)
block|{
comment|/* if something there */
name|synonyms
index|[
literal|2
operator|*
name|numsyn
operator|++
operator|+
literal|1
index|]
operator|=
name|ptr
expr_stmt|;
comment|/* add to list */
block|}
else|else
block|{
comment|/* otherwise remove */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numsyn
condition|;
name|i
operator|++
control|)
block|{
comment|/* from list */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|synonyms
index|[
literal|2
operator|*
name|i
index|]
argument_list|,
name|synonyms
index|[
literal|2
operator|*
name|numsyn
index|]
argument_list|)
condition|)
block|{
name|numsyn
operator|--
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|--
init|;
name|j
operator|<
name|numsyn
condition|;
name|j
operator|++
control|)
block|{
name|synonyms
index|[
literal|2
operator|*
name|j
index|]
operator|=
name|synonyms
index|[
literal|2
operator|*
operator|(
name|j
operator|+
literal|1
operator|)
index|]
expr_stmt|;
name|synonyms
index|[
literal|2
operator|*
name|j
operator|+
literal|1
index|]
operator|=
name|synonyms
index|[
literal|2
operator|*
name|j
operator|+
literal|3
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|delimit
condition|)
name|ptr
operator|=
name|nextstring
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|numsyn
operator|>
name|SYNON
condition|)
name|error
argument_list|(
literal|"out of synonym space"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
comment|/* open font file */
name|error
argument_list|(
literal|"A vfont filename must be the last operand."
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|=
name|rindex
argument_list|(
operator|*
name|argv
argument_list|,
literal|'.'
argument_list|)
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
name|ptr
operator|&&
operator|*
name|ptr
operator|<=
literal|'9'
operator|&&
operator|*
name|ptr
operator|>=
literal|'0'
condition|)
block|{
name|psize
operator|=
name|atoi
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|psize
operator|<
name|MINSIZE
operator|||
name|psize
operator|>
name|MAXSIZE
condition|)
name|error
argument_list|(
literal|"point size of file \"%s\" out of range"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|IName
argument_list|,
literal|"%s/%s"
argument_list|,
name|fontdir
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|FID
operator|=
name|open
argument_list|(
name|IName
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|FID
operator|<
literal|0
operator|&&
operator|(
name|psize
operator|=
name|psizelist
index|[
name|i
index|]
operator|)
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|IName
argument_list|,
literal|"%s/%s.%d"
argument_list|,
name|fontdir
argument_list|,
operator|*
name|argv
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|FID
operator|=
name|open
argument_list|(
name|IName
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|FID
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Can't open %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
comment|/* read font width table */
if|if
condition|(
name|read
argument_list|(
name|FID
argument_list|,
operator|&
name|FontHeader
argument_list|,
sizeof|sizeof
name|FontHeader
argument_list|)
operator|!=
sizeof|sizeof
name|FontHeader
condition|)
name|error
argument_list|(
literal|"Bad header in Font file."
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|FID
argument_list|,
operator|&
name|disptable
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
name|disptable
argument_list|)
operator|!=
sizeof|sizeof
name|disptable
condition|)
name|error
argument_list|(
literal|"Bad dispatch table in Font file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|FontHeader
operator|.
name|magic
operator|!=
name|MAGICN
condition|)
name|printf
argument_list|(
literal|"Magic number %o wrong\n"
argument_list|,
name|FontHeader
operator|.
name|magic
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"# Font %s, "
argument_list|,
name|IName
argument_list|)
expr_stmt|;
comment|/* head off the file */
name|printf
argument_list|(
literal|"max width %d, max height %d\n"
argument_list|,
name|FontHeader
operator|.
name|maxx
argument_list|,
name|FontHeader
operator|.
name|maxy
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"name %s\n"
argument_list|,
name|fontname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ligsf
condition|)
name|printf
argument_list|(
literal|"ligatures ff fl fi ffl ffi 0\n"
argument_list|)
expr_stmt|;
comment|/* pass 1 - set up maximums for ups and downs */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
comment|/* and find out constant width if requested */
if|if
condition|(
name|disptable
index|[
name|j
index|]
operator|.
name|nbytes
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|disptable
index|[
name|j
index|]
operator|.
name|up
operator|>
name|maxup
condition|)
name|maxup
operator|=
name|disptable
index|[
name|j
index|]
operator|.
name|up
expr_stmt|;
if|if
condition|(
name|disptable
index|[
name|j
index|]
operator|.
name|down
operator|>
name|maxdown
condition|)
name|maxdown
operator|=
name|disptable
index|[
name|j
index|]
operator|.
name|down
expr_stmt|;
if|if
condition|(
name|constant
operator|&&
name|disptable
index|[
name|j
index|]
operator|.
name|width
condition|)
name|constant
operator|=
name|disptable
index|[
name|j
index|]
operator|.
name|width
expr_stmt|;
block|}
elseif|else
comment|/* find a non-existant character to put \| in */
if|if
condition|(
name|nullchar
operator|<
literal|0
condition|)
name|nullchar
operator|=
name|j
expr_stmt|;
block|}
if|if
condition|(
name|maxdown
operator|==
literal|0
condition|)
name|maxdown
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|constant
condition|)
block|{
name|constant
operator|=
operator|(
name|factor
operator|*
operator|(
name|pointsize
operator|*
name|constant
operator|+
name|psize
operator|/
literal|2
operator|)
operator|/
name|psize
operator|)
operator|/
literal|100
expr_stmt|;
name|printf
argument_list|(
literal|"spacewidth %d\n"
argument_list|,
name|constant
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"# char	width	u/d	octal\ncharset\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nullchar
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\\|	%4d	 0	0%o\n\\^	%4d	 0	0%o\n"
argument_list|,
name|constant
condition|?
name|constant
else|:
operator|(
name|res
operator|*
name|pointsize
operator|/
name|APOINT
operator|+
literal|4
operator|)
operator|/
literal|6
argument_list|,
name|nullchar
argument_list|,
name|constant
condition|?
literal|0
else|:
operator|(
name|res
operator|*
name|pointsize
operator|/
name|APOINT
operator|+
literal|7
operator|)
operator|/
literal|12
argument_list|,
name|nullchar
argument_list|)
expr_stmt|;
block|}
comment|/*******************************************************************************  	`type' is used to determine overhangs (up/down) from percentage of 	the maximum heights and dips.  Ascenders are higher than PCNTUP% 	of the highest, as descenders are more than PCNTDOWN%. 	widths [i = f(width)] are calculated from the definition point 	size (pointsize) and the one from this font (psize).  *******************************************************************************/
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|disptable
index|[
name|j
index|]
operator|.
name|nbytes
operator|!=
literal|0
condition|)
block|{
name|type
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|disptable
index|[
name|j
index|]
operator|.
name|up
operator|*
literal|100
operator|)
operator|/
name|maxup
operator|)
operator|>
name|PCNTUP
argument_list|)
operator|*
literal|2
operator||
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|disptable
index|[
name|j
index|]
operator|.
name|down
operator|*
literal|100
operator|)
operator|/
name|maxdown
operator|)
operator|>
name|PCNTDOWN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|ptr
operator|=
name|charmap
index|[
name|j
index|]
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s	%4d	 %d	0%o\n"
argument_list|,
name|ptr
argument_list|,
operator|(
name|factor
operator|*
operator|(
name|pointsize
operator|*
name|disptable
index|[
name|j
index|]
operator|.
name|width
operator|+
name|psize
operator|/
literal|2
operator|)
operator|/
name|psize
operator|)
operator|/
literal|100
argument_list|,
name|type
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numsyn
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ptr
argument_list|,
name|synonyms
index|[
literal|2
operator|*
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%s	\"\n"
argument_list|,
name|synonyms
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* for j */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	char  * operand (& argc,& argv)  |  | Results:	returns address of the operand given with a command-line  |		option.  It uses either "-Xoperand" or "-X operand", whichever  |		is present.  The program is terminated if no option is present.  |  | Side Efct:	argc and argv are updated as necessary.  *----------------------------------------------------------------------------*/
end_comment

begin_function
name|char
modifier|*
name|operand
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
operator|*
name|argvp
operator|)
index|[
literal|2
index|]
condition|)
return|return
operator|(
operator|*
operator|*
name|argvp
operator|+
literal|2
operator|)
return|;
comment|/* operand immediately follows */
if|if
condition|(
operator|(
operator|--
operator|*
name|argcp
operator|)
operator|<=
literal|0
condition|)
comment|/* no operand */
name|error
argument_list|(
literal|"command-line option operand missing."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
operator|(
operator|++
operator|(
operator|*
name|argvp
operator|)
operator|)
operator|)
return|;
comment|/* operand next word */
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	char  tostring (pointer, delimitter)  |  | Results:	checks string pointed to by pointer and turns it into a  |		string at 'delimitter' by replacing it with '\0'.  If the  |		end of the string is found first, '\0' is returned; otherwise  |		the delimitter found there is returned.  |  *----------------------------------------------------------------------------*/
end_comment

begin_function
name|char
name|tostring
parameter_list|(
name|p
parameter_list|,
name|d
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|d
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
name|d
condition|)
name|p
operator|++
expr_stmt|;
name|d
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	char  * nextstring (pointer)  |  | Results:	returns address of next string after one pointed to by  |		pointer.  The next string is after the '\0' byte.  |  *----------------------------------------------------------------------------*/
end_comment

begin_function
name|char
modifier|*
name|nextstring
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
while|while
condition|(
operator|*
operator|(
name|p
operator|++
operator|)
condition|)
empty_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_macro
name|error
argument_list|(
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"makefont: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

