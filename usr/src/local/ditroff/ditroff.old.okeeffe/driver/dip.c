begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	dip  *	driver for impress/imagen canon laser printer  */
end_comment

begin_comment
comment|/* output language from troff: all numbers are character strings  sn	size in points fn	font as number from 1-n cx	ascii character x Cxyz	funny char xyz. terminated by white space Hn	go to absolute horizontal position n Vn	go to absolute vertical position n (down is positive) hn	go n units horizontally (relative) vn	ditto vertically nnc	move right nn, then print c (exactly 2 digits!) 		(this wart is an optimization that shrinks output file size 		 about 35% and run-time about 15% while preserving ascii-ness) Dt ...\n	draw operation 't': 	Dl x y		line from here by x,y 	Dc d		circle of diameter d with left side here 	De x y		ellipse of axes x,y with left side here 	Da x y r	arc counter-clockwise by x,y of radius r 	D~ x y x y ...	wiggly line by x,y then x,y ... nb a	end of line (information only -- no action needed) 	b = space before line, a = after p	new page begins -- set v to 0 #...\n	comment x ...\n	device control functions: 	x i	init 	x T s	name of device is s 	x r n h v	resolution is n/inch 		h = min horizontal motion, v = min vert 	x p	pause (can restart) 	x s	stop -- done for ever 	x t	generate trailer 	x f n s	font position n contains font s 	x H n	set character height to n 	x S n	set slant to N  	Subcommands like "i" are often spelled out like "init". */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"dev.h"
end_include

begin_include
include|#
directive|include
file|"canon.h"
end_include

begin_include
include|#
directive|include
file|"glyph.h"
end_include

begin_define
define|#
directive|define
name|abs
parameter_list|(
name|n
parameter_list|)
value|((n)>= 0 ? (n) : -(n))
end_define

begin_define
define|#
directive|define
name|NFONT
value|10
end_define

begin_define
define|#
directive|define
name|RES
value|240
end_define

begin_comment
comment|/* resolution of canon */
end_comment

begin_decl_stmt
name|int
name|xx
decl_stmt|,
name|yy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inputarea
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input area = 5 * 8k bytes */
end_comment

begin_decl_stmt
name|int
name|rotate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 => portrait, 1 => landscape */
end_comment

begin_decl_stmt
name|int
name|output
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* do we do output at all? */
end_comment

begin_decl_stmt
name|int
name|pageno
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output page number */
end_comment

begin_decl_stmt
name|int
name|nolist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output page list if> 0 */
end_comment

begin_decl_stmt
name|int
name|olist
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pairs of page numbers */
end_comment

begin_decl_stmt
name|struct
name|dev
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|font
modifier|*
name|fontbase
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|pstab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nsizes
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfonts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|smnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of first special font */
end_comment

begin_decl_stmt
name|int
name|nchtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|chname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|chtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fitab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|widthtab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* widtab would be a better name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|codetab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device codes */
end_comment

begin_define
define|#
directive|define
name|FATAL
value|1
end_define

begin_define
define|#
directive|define
name|BMASK
value|0377
end_define

begin_decl_stmt
name|int
name|dbg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|res
init|=
literal|240
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input assumed computed according to this resolution */
end_comment

begin_comment
comment|/* initial value to avoid 0 divide */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|tf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output file pointer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tempfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fontdir
init|=
literal|"/usr/lib/font"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bitdir
init|=
literal|"/usr/src/local/ditroff/troff/devcan"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|acctfile
init|=
literal|"/usr/adm/dipacct"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|acctpages
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|copies
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|username
init|=
literal|"???"
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|getlogin
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
name|devname
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
init|=
name|stdin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file pointer */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|DX
decl_stmt|,
name|DY
decl_stmt|,
name|maxdots
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
name|int
name|cleanup
parameter_list|()
function_decl|;
name|username
operator|=
name|getlogin
argument_list|()
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'c'
case|:
name|copies
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|rotate
operator|=
operator|!
name|rotate
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tf
operator|=
name|stdout
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|bitdir
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|outlist
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* set input area parameter */
name|inputarea
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputarea
operator|<
literal|1
condition|)
name|inputarea
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|inputarea
operator|>
literal|5
condition|)
name|inputarea
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* pixels of resolution */
name|DX
operator|=
name|DY
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|DX
operator|==
literal|0
condition|)
name|DX
operator|=
name|DY
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* number of dots in object */
name|maxdots
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxdots
operator|<=
literal|0
condition|)
name|maxdots
operator|=
literal|32000
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"It's never busy!"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dbg
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
operator|==
literal|0
condition|)
name|dbg
operator|=
literal|1
expr_stmt|;
name|tf
operator|=
name|stdout
expr_stmt|;
break|break;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|tempfile
operator|=
name|mktemp
argument_list|(
literal|"/tmp/dipXXXXX"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tf
operator|!=
name|stdout
condition|)
block|{
if|if
condition|(
operator|(
name|tf
operator|=
name|fopen
argument_list|(
name|tempfile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open temporary file %s"
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|conv
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
operator|++
name|argv
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|fp
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|conv
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/*	banner(username); */
name|t_wrapup
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|tf
argument_list|)
expr_stmt|;
comment|/*	sprintf(buf, "ipr -p %d %s 0</dev/null 1>/dev/null 2>&1&", 		pageno, tempfile);					*/
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"executing %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tf
operator|!=
name|stdout
condition|)
block|{
name|system
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|account
argument_list|()
expr_stmt|;
block|}
name|done
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|outlist
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* process list of page numbers to be printed */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|,
name|i
decl_stmt|;
name|nolist
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|n1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|do
name|n1
operator|=
literal|10
operator|*
name|n1
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
else|else
name|n1
operator|=
operator|-
literal|9999
expr_stmt|;
name|n2
operator|=
name|n1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|n2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|do
name|n2
operator|=
literal|10
operator|*
name|n2
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
else|else
name|n2
operator|=
literal|9999
expr_stmt|;
block|}
name|olist
index|[
name|nolist
operator|++
index|]
operator|=
name|n1
expr_stmt|;
name|olist
index|[
name|nolist
operator|++
index|]
operator|=
name|n2
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|olist
index|[
name|nolist
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nolist
condition|;
name|i
operator|+=
literal|2
control|)
name|printf
argument_list|(
literal|"%3d %3d\n"
argument_list|,
name|olist
index|[
name|i
index|]
argument_list|,
name|olist
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|in_olist
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* is n in olist? */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nolist
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* everything is included */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nolist
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
name|n
operator|>=
name|olist
index|[
name|i
index|]
operator|&&
name|n
operator|<=
name|olist
index|[
name|i
operator|+
literal|1
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|conv
argument_list|(
name|fp
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|k
decl_stmt|;
name|int
name|m
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|n1
decl_stmt|,
name|m1
decl_stmt|;
name|char
name|str
index|[
literal|100
index|]
decl_stmt|,
name|buf
index|[
literal|300
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* when input is text */
case|case
literal|' '
case|:
case|case
literal|0
case|:
comment|/* occasional noise creeps in */
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* two motion digits plus a character */
name|hmot
argument_list|(
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|getc
argument_list|(
name|fp
argument_list|)
operator|-
literal|'0'
argument_list|)
expr_stmt|;
name|put1
argument_list|(
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* single ascii character */
name|put1
argument_list|(
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|put1s
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* draw function */
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'l'
case|:
comment|/* draw a line */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|t_line
argument_list|(
name|n
argument_list|,
name|m
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* circle */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawcirc
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* ellipse */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawellip
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* arc */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d %d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n1
argument_list|,
operator|&
name|m1
argument_list|)
expr_stmt|;
name|drawarc
argument_list|(
name|n
argument_list|,
name|m
argument_list|,
name|n1
argument_list|,
name|m1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* gremlin curve */
case|case
literal|'~'
case|:
comment|/* wiggly line */
name|drawwig
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
case|case
literal|'t'
case|:
case|case
literal|'s'
case|:
break|break;
default|default:
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unknown drawing function %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'s'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
comment|/* ignore fractional sizes */
name|setsize
argument_list|(
name|t_size
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|setfont
argument_list|(
name|t_font
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* absolute horizontal motion */
comment|/* fscanf(fp, "%d",&n); */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|hgoto
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* relative horizontal motion */
comment|/* fscanf(fp, "%d",&n); */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* word space */
break|break;
case|case
literal|'V'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|vgoto
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* new page */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_page
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* end of line */
while|while
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|t_newline
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* comment */
while|while
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* device control */
name|devcntrl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"unknown input character %o %c"
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|devcntrl
argument_list|(
argument|fp
argument_list|)
end_macro

begin_comment
comment|/* interpret device control functions */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|str
index|[
literal|20
index|]
decl_stmt|,
name|str1
index|[
literal|50
index|]
decl_stmt|,
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|str
index|[
literal|0
index|]
condition|)
block|{
comment|/* crude for now */
case|case
literal|'i'
case|:
comment|/* initialize */
name|fileinit
argument_list|()
expr_stmt|;
name|t_init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* device name */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* trailer */
name|t_trailer
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* pause -- can restart */
name|t_reset
argument_list|(
literal|'p'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* stop */
name|t_reset
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* resolution assumed when prepared */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* font used */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d %s"
argument_list|,
operator|&
name|n
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* in case there's a filename */
name|ungetc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* fgets goes too far */
name|str1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* in case there's nothing to come in */
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
name|str1
argument_list|)
expr_stmt|;
name|loadfont
argument_list|(
name|n
argument_list|,
name|str
argument_list|,
name|str1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* char height */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_charht
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* slant */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_slant
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
comment|/* skip rest of input line */
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
block|}
end_block

begin_macro
name|fileinit
argument_list|()
end_macro

begin_comment
comment|/* read in font and code files, etc. */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|,
name|fin
decl_stmt|,
name|nw
decl_stmt|;
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|filebase
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|temp
index|[
literal|60
index|]
decl_stmt|;
comment|/* open table for device, 	 * read in resolution, size info, font info, etc. 	 * and set params 	 */
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/dev%s/DESC.out"
argument_list|,
name|fontdir
argument_list|,
name|devname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|open
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open tables for %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fin
argument_list|,
operator|&
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|nfonts
operator|=
name|dev
operator|.
name|nfonts
expr_stmt|;
name|nsizes
operator|=
name|dev
operator|.
name|nsizes
expr_stmt|;
name|nchtab
operator|=
name|dev
operator|.
name|nchtab
expr_stmt|;
name|filebase
operator|=
name|malloc
argument_list|(
name|dev
operator|.
name|filesize
argument_list|)
expr_stmt|;
comment|/* enough room for whole file */
name|read
argument_list|(
name|fin
argument_list|,
name|filebase
argument_list|,
name|dev
operator|.
name|filesize
argument_list|)
expr_stmt|;
comment|/* all at once */
name|pstab
operator|=
operator|(
name|short
operator|*
operator|)
name|filebase
expr_stmt|;
name|chtab
operator|=
name|pstab
operator|+
name|nsizes
operator|+
literal|1
expr_stmt|;
name|chname
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|chtab
operator|+
name|dev
operator|.
name|nchtab
operator|)
expr_stmt|;
name|p
operator|=
name|chname
operator|+
name|dev
operator|.
name|lchname
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nfonts
condition|;
name|i
operator|++
control|)
block|{
name|fontbase
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|widthtab
index|[
name|i
index|]
operator|=
name|codetab
index|[
name|i
index|]
operator|=
name|fitab
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fontprint
argument_list|(
argument|i
argument_list|)
end_macro

begin_comment
comment|/* debugging print of font i (0,...) */
end_comment

begin_block
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"font %d:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
name|i
index|]
expr_stmt|;
name|n
operator|=
name|fontbase
index|[
name|i
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
name|printf
argument_list|(
literal|"base=0%o, nchars=%d, spec=%d, name=%s, widtab=0%o, fitab=0%o\n"
argument_list|,
name|p
argument_list|,
name|n
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|specfont
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|namefont
argument_list|,
name|widthtab
index|[
name|i
index|]
argument_list|,
name|fitab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"widths:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2d"
argument_list|,
name|widthtab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\ncodetab:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2d"
argument_list|,
name|codetab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nfitab:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|dev
operator|.
name|nchtab
operator|+
literal|128
operator|-
literal|32
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2d"
argument_list|,
name|fitab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|loadfont
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|,
argument|s1
argument_list|)
end_macro

begin_comment
comment|/* load font info for font s on position n (0...) */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|temp
index|[
literal|60
index|]
decl_stmt|;
name|int
name|fin
decl_stmt|,
name|nw
decl_stmt|,
name|norig
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|NFONT
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"illegal fp command %d %s"
argument_list|,
name|n
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontbase
index|[
name|n
index|]
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|s
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|namefont
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|s1
operator|==
name|NULL
operator|||
name|s1
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/dev%s/%s.out"
argument_list|,
name|fontdir
argument_list|,
name|devname
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/%s.out"
argument_list|,
name|s1
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|open
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"can't open font table %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fontbase
index|[
name|n
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|fontbase
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|fontbase
index|[
name|n
index|]
operator|=
operator|(
expr|struct
name|font
operator|*
operator|)
name|malloc
argument_list|(
literal|3
operator|*
literal|255
operator|+
name|dev
operator|.
name|nchtab
operator|+
operator|(
literal|128
operator|-
literal|32
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontbase
index|[
name|n
index|]
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"Out of space in loadfont %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fin
argument_list|,
name|fontbase
index|[
name|n
index|]
argument_list|,
literal|3
operator|*
literal|255
operator|+
name|nchtab
operator|+
literal|128
operator|-
literal|32
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
if|if
condition|(
name|smnt
operator|==
literal|0
operator|&&
name|fontbase
index|[
name|n
index|]
operator|->
name|specfont
operator|==
literal|1
condition|)
name|smnt
operator|=
name|n
expr_stmt|;
name|nw
operator|=
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
name|widthtab
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
name|n
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
expr_stmt|;
name|codetab
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|widthtab
index|[
name|n
index|]
operator|+
literal|2
operator|*
name|nw
expr_stmt|;
name|fitab
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|widthtab
index|[
name|n
index|]
operator|+
literal|3
operator|*
name|nw
expr_stmt|;
name|t_fp
argument_list|(
name|n
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|namefont
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|intname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
operator|>
literal|1
condition|)
name|fontprint
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cleanup
argument_list|()
end_macro

begin_block
block|{
name|unlink
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|f
argument_list|,
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|,
argument|a6
argument_list|,
argument|a7
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dip: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
name|cleanup
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	Here beginneth all the stuff that really depends 	on the canon (we hope). */
end_comment

begin_define
define|#
directive|define
name|SLOP
value|1
end_define

begin_comment
comment|/* how much positioning error is allowed? */
end_comment

begin_define
define|#
directive|define
name|MAXX
value|(8*RES + RES/2)
end_define

begin_comment
comment|/* 8-1/2 inches? */
end_comment

begin_define
define|#
directive|define
name|MAXY
value|(11 * RES)
end_define

begin_define
define|#
directive|define
name|WIDTH
value|8
end_define

begin_define
define|#
directive|define
name|LOGWID
value|3
end_define

begin_define
define|#
directive|define
name|K
value|* 1024
end_define

begin_comment
comment|/* clever, so watch out */
end_comment

begin_decl_stmt
name|char
name|devname
index|[
literal|20
index|]
init|=
literal|"ip"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nglyph
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of glyphs loaded */
end_comment

begin_decl_stmt
name|int
name|totglyph
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total space used by glyphs sent down */
end_comment

begin_decl_stmt
name|int
name|maxglyph
init|=
literal|28
name|K
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum space for glyphs */
end_comment

begin_define
define|#
directive|define
name|oput
parameter_list|(
name|c
parameter_list|)
value|if (output) xychar(c); else;
end_define

begin_comment
comment|/* input coordinate system: */
end_comment

begin_decl_stmt
name|int
name|size
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|font
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current font */
end_comment

begin_decl_stmt
name|int
name|hpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* horizontal position where we are supposed to be next (left = 0) */
end_comment

begin_decl_stmt
name|int
name|vpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current vertical position (down positive) */
end_comment

begin_decl_stmt
name|int
name|lastw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* width of last input character */
end_comment

begin_decl_stmt
name|int
name|DX
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* step size in x for drawing */
end_comment

begin_decl_stmt
name|int
name|DY
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* step size in y for drawing */
end_comment

begin_comment
comment|/* canon coordinate system: */
end_comment

begin_decl_stmt
name|int
name|lastsize
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastfont
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastx
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lasty
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastfam
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|drawdot
init|=
literal|'.'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* draw with this character */
end_comment

begin_decl_stmt
name|int
name|drawsize
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* shrink by this factor when drawing */
end_comment

begin_macro
name|t_init
argument_list|(
argument|reinit
argument_list|)
end_macro

begin_comment
comment|/* initialize device */
end_comment

begin_decl_stmt
name|int
name|reinit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|reinit
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchtab
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|chname
index|[
name|chtab
index|[
name|i
index|]
index|]
argument_list|,
literal|"l."
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|nchtab
condition|)
block|{
name|drawdot
operator|=
name|i
operator|+
literal|128
expr_stmt|;
name|drawsize
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|drawdot
operator|=
literal|'.'
expr_stmt|;
name|drawsize
operator|=
literal|2
expr_stmt|;
comment|/* half size */
block|}
comment|/* some Imagen-specific junk: */
name|fprintf
argument_list|(
name|tf
argument_list|,
literal|"%1d"
argument_list|,
name|inputarea
argument_list|)
expr_stmt|;
comment|/* their kludge for setting */
comment|/* input area to x * 8k */
name|maxglyph
operator|=
operator|(
literal|68
operator|-
name|inputarea
operator|-
literal|4
operator|)
name|K
expr_stmt|;
comment|/* glyph area = 68K - input */
name|fprintf
argument_list|(
name|tf
argument_list|,
literal|" %s\n\0"
argument_list|,
name|username
argument_list|)
expr_stmt|;
comment|/* terminated string */
name|fprintf
argument_list|(
name|tf
argument_list|,
literal|"%8.8s"
argument_list|,
literal|"d_ip1/24"
argument_list|)
expr_stmt|;
comment|/* padding 8 bytes */
comment|/* ignored but needed */
block|}
name|hpos
operator|=
name|vpos
operator|=
literal|0
expr_stmt|;
name|setsize
argument_list|(
name|t_size
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
comment|/* start somewhere */
block|}
end_block

begin_macro
name|t_line
argument_list|(
argument|n
argument_list|,
argument|m
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|,
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
comment|/* horizontal rule needed */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|t_rule
argument_list|(
name|n
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* finish at the end */
block|}
else|else
block|{
name|hmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|t_rule
argument_list|(
operator|-
name|n
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* vertical rule */
if|if
condition|(
name|m
operator|>
literal|0
condition|)
block|{
name|vmot
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* finish at the end */
name|t_rule
argument_list|(
literal|2
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t_rule
argument_list|(
literal|2
argument_list|,
operator|-
name|m
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|drawline
argument_list|(
name|n
argument_list|,
name|m
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|t_page
argument_list|(
argument|pg
argument_list|)
end_macro

begin_comment
comment|/* do whatever new page functions */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|int
name|firstpage
init|=
literal|1
decl_stmt|;
name|pageno
operator|=
name|pg
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"t_page %d, output=%d\n"
argument_list|,
name|pg
argument_list|,
name|output
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|!=
literal|0
condition|)
block|{
comment|/* beginning of first page, or */
comment|/* have just printed something, and seen p<n> for next one */
comment|/* ought to read in entire page, select needed glyphs */
name|putc
argument_list|(
name|AEND
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|firstpage
operator|=
literal|0
expr_stmt|;
block|}
name|output
operator|=
name|in_olist
argument_list|(
name|pg
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
condition|)
block|{
if|if
condition|(
name|totglyph
operator|>=
name|maxglyph
condition|)
block|{
name|clearglyphs
argument_list|()
expr_stmt|;
name|totglyph
operator|=
literal|0
expr_stmt|;
block|}
name|acctpages
operator|++
expr_stmt|;
block|}
name|lastx
operator|=
name|lasty
operator|=
operator|-
literal|1
expr_stmt|;
name|t_init
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|t_newline
argument_list|()
end_macro

begin_comment
comment|/* do whatever for the end of a line */
end_comment

begin_block
block|{
name|hpos
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|t_size
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* convert integer to internal size number*/
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|n
operator|<=
name|pstab
index|[
literal|0
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|n
operator|>=
name|pstab
index|[
name|nsizes
operator|-
literal|1
index|]
condition|)
return|return
operator|(
name|nsizes
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|n
operator|>
name|pstab
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|i
operator|+
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|t_charht
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set character height to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* punt for now */
block|}
end_block

begin_macro
name|t_slant
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set slant to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* punt for now */
block|}
end_block

begin_macro
name|t_font
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* convert string to internal font number */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|nfonts
condition|)
name|n
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|t_reset
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|output
condition|)
name|acctpages
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|t_wrapup
argument_list|()
end_macro

begin_block
block|{
name|putc
argument_list|(
name|AEND
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|AEOF
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|account
argument_list|()
end_macro

begin_comment
comment|/* record paper use */
end_comment

begin_block
block|{
comment|/*					HIDE THIS!!! 	FILE *f = NULL;  	if (tf == stdout) 		return; 	f = fopen(acctfile, "a"); 	if (f != NULL) { 		if (username == NULL) 			username = "???"; 		fprintf(f, "%4d %s\n", acctpages, username); 	} */
block|}
end_block

begin_macro
name|banner
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|t
decl_stmt|,
name|time
argument_list|()
decl_stmt|;
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|AEND
argument_list|,
name|tf
argument_list|)
expr_stmt|;
comment|/* clean up previous page */
name|setsize
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|loadfont
argument_list|(
literal|1
argument_list|,
literal|"CW"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|lastx
operator|=
name|lasty
operator|=
operator|-
literal|1
expr_stmt|;
name|vgoto
argument_list|(
literal|1500
argument_list|)
expr_stmt|;
name|hgoto
argument_list|(
literal|500
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|put1
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
literal|128
argument_list|)
expr_stmt|;
block|}
name|hmot
argument_list|(
literal|3
operator|*
literal|128
argument_list|)
expr_stmt|;
name|put1
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|t_rule
argument_list|(
literal|960
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|vgoto
argument_list|(
literal|2500
argument_list|)
expr_stmt|;
name|hgoto
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
name|s
operator|=
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|put1
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
literal|128
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|t_rule
argument_list|(
argument|w
argument_list|,
argument|h
argument_list|)
end_macro

begin_block
block|{
name|hvflush
argument_list|()
expr_stmt|;
name|putc
argument_list|(
name|ABRULE
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putint
argument_list|(
name|w
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putint
argument_list|(
name|h
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putint
argument_list|(
operator|-
name|h
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|t_trailer
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_macro
name|hgoto
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
name|hpos
operator|=
name|n
expr_stmt|;
comment|/* this is where we want to be */
comment|/* before printing a character, */
comment|/* have to make sure it's true */
block|}
end_block

begin_macro
name|hmot
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* generate n units of horizontal motion */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|hpos
operator|+=
name|n
expr_stmt|;
block|}
end_block

begin_macro
name|vgoto
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
name|vpos
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_macro
name|vmot
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* generate n units of vertical motion */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|vgoto
argument_list|(
name|vpos
operator|+
name|n
argument_list|)
expr_stmt|;
comment|/* ignores rounding */
block|}
end_block

begin_expr_stmt
name|put1s
argument_list|(
name|s
argument_list|)
comment|/* s is a funny char name */
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
return|return;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
operator|&
name|chname
index|[
name|chtab
index|[
name|i
index|]
index|]
argument_list|)
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchtab
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|chname
index|[
name|chtab
index|[
name|i
index|]
index|]
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|nchtab
condition|)
name|put1
argument_list|(
name|i
operator|+
literal|128
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|put1
argument_list|(
name|c
argument_list|)
comment|/* output char c */
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|pw
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|ofont
decl_stmt|,
name|code
decl_stmt|,
name|w
decl_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
return|return;
name|c
operator|-=
literal|32
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"non-exist 0%o\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|)
expr_stmt|;
return|return;
block|}
name|k
operator|=
name|ofont
operator|=
name|font
expr_stmt|;
name|i
operator|=
name|fitab
index|[
name|font
index|]
index|[
name|c
index|]
operator|&
name|BMASK
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* it's on this font */
name|p
operator|=
name|codetab
index|[
name|font
index|]
expr_stmt|;
name|pw
operator|=
name|widthtab
index|[
name|font
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|smnt
operator|>
literal|0
condition|)
block|{
comment|/* on special (we hope) */
for|for
control|(
name|k
operator|=
name|smnt
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|nfonts
condition|;
name|j
operator|++
operator|,
name|k
operator|=
operator|(
name|k
operator|+
literal|1
operator|)
operator|%
operator|(
name|nfonts
operator|+
literal|1
operator|)
control|)
if|if
condition|(
operator|(
name|i
operator|=
name|fitab
index|[
name|k
index|]
index|[
name|c
index|]
operator|&
name|BMASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|codetab
index|[
name|k
index|]
expr_stmt|;
name|pw
operator|=
name|widthtab
index|[
name|k
index|]
expr_stmt|;
name|setfont
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|||
operator|(
name|code
operator|=
name|p
index|[
name|i
index|]
operator|&
name|BMASK
operator|)
operator|==
literal|0
operator|||
name|k
operator|>
name|nfonts
condition|)
block|{
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"not found 0%o\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|)
expr_stmt|;
return|return;
block|}
name|lastw
operator|=
name|pw
index|[
name|i
index|]
operator|&
literal|077
expr_stmt|;
name|lastw
operator|=
operator|(
name|lastw
operator|*
name|pstab
index|[
name|size
operator|-
literal|1
index|]
operator|+
name|dev
operator|.
name|unitwidth
operator|/
literal|2
operator|)
operator|/
name|dev
operator|.
name|unitwidth
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
operator|+
literal|32
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%c %d\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%03o %d\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
else|else
name|oput
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|!=
name|ofont
condition|)
name|setfont
argument_list|(
name|ofont
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|setsize
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set point size to n (internal) */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|size
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_comment
comment|/* font position info: */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
name|fontname
index|[
name|NFONT
operator|+
literal|1
index|]
struct|;
end_struct

begin_macro
name|t_fp
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|,
argument|si
argument_list|)
end_macro

begin_comment
comment|/* font position n now contains font s, intname si */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|si
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fontname
index|[
name|n
index|]
operator|.
name|name
operator|=
name|s
expr_stmt|;
name|fontname
index|[
name|n
index|]
operator|.
name|number
operator|=
name|atoi
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|setfont
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set font to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|output
condition|)
return|return;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|NFONT
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"illegal font %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|font
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_macro
name|done
argument_list|()
end_macro

begin_block
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	The following things manage raster font information. 	The big problem is mapping desired font + size into 	available font + size.  For now, a file RASTERLIST 	contains entries like 		R 6 8 10 14 999 		I 8 10 12 999 		... 	This data is used to create an array "fontdata" that 	describes legal fonts and sizes, and pointers to any 	data from files that has actually been loaded. */
end_comment

begin_struct
struct|struct
name|fontdata
block|{
name|char
name|name
index|[
literal|4
index|]
decl_stmt|;
comment|/* e.g., "R" or "PA" */
name|int
name|size
index|[
literal|10
index|]
decl_stmt|;
comment|/* e.g., 6 8 10 14 0 */
name|struct
name|fontset
modifier|*
name|fsp
index|[
literal|10
index|]
decl_stmt|;
comment|/* either NULL or block of data */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAXFONT
value|60
end_define

begin_comment
comment|/* no more than this many fonts forever */
end_comment

begin_decl_stmt
name|struct
name|fontdata
name|fontdata
index|[
name|MAXFONT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxfonts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how many actually used; set in initfontdata() */
end_comment

begin_decl_stmt
name|struct
name|Fontheader
name|fh
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|fontset
block|{
name|int
name|size
decl_stmt|;
name|int
name|family
decl_stmt|;
name|struct
name|Charparam
modifier|*
name|chp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cdp
decl_stmt|;
comment|/* char data pointer */
name|unsigned
name|char
modifier|*
name|chused
decl_stmt|;
comment|/* bit-indexed; 1 if char downloaded */
block|}
struct|;
end_struct

begin_comment
comment|/* A global variable for the current font+size */
end_comment

begin_decl_stmt
name|struct
name|fontset
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfamily
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of "families" (font+size) */
end_comment

begin_macro
name|initfontdata
argument_list|()
end_macro

begin_comment
comment|/* read RASTERLIST information */
end_comment

begin_block
block|{
name|char
name|name
index|[
literal|100
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s/dev%s/RASTERLIST"
argument_list|,
name|fontdir
argument_list|,
name|devname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|maxfonts
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|fontdata
index|[
name|maxfonts
index|]
operator|.
name|name
argument_list|)
operator|!=
name|EOF
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
name|EOF
operator|&&
name|n
operator|<
literal|100
condition|)
block|{
name|fontdata
index|[
name|maxfonts
index|]
operator|.
name|size
index|[
name|i
index|]
operator|=
name|n
expr_stmt|;
name|fontdata
index|[
name|maxfonts
index|]
operator|.
name|fsp
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|fontdata
index|[
name|maxfonts
index|]
operator|.
name|size
index|[
name|i
index|]
operator|=
literal|999
expr_stmt|;
if|if
condition|(
operator|++
name|maxfonts
operator|>
name|MAXFONT
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"Too many fonts in RASTERLIST"
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"initfontdata():  maxfonts=%d\n"
argument_list|,
name|maxfonts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxfonts
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%.4s "
argument_list|,
name|fontdata
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|fontdata
index|[
name|i
index|]
operator|.
name|size
index|[
name|j
index|]
operator|<
literal|100
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %3d"
argument_list|,
name|fontdata
index|[
name|i
index|]
operator|.
name|size
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|getfontdata
argument_list|(
argument|f
argument_list|,
argument|s
argument_list|)
end_macro

begin_comment
comment|/* causes loading of font information if needed */
end_comment

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fd
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|name
index|[
literal|100
index|]
decl_stmt|;
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|initfontdata
argument_list|()
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxfonts
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|f
argument_list|,
name|fontdata
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|maxfonts
condition|)
comment|/* the requested font wasn't there */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* use the first one (probably R) */
comment|/* find the best approximation to size s */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|s
operator|>=
name|fontdata
index|[
name|i
index|]
operator|.
name|size
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
empty_stmt|;
name|j
operator|--
expr_stmt|;
comment|/* open file if necessary */
if|if
condition|(
name|fontdata
index|[
name|i
index|]
operator|.
name|fsp
index|[
name|j
index|]
operator|==
name|NULL
condition|)
block|{
name|fs
operator|=
operator|(
expr|struct
name|fontset
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fontset
argument_list|)
argument_list|)
expr_stmt|;
name|fontdata
index|[
name|i
index|]
operator|.
name|fsp
index|[
name|j
index|]
operator|=
name|fs
expr_stmt|;
name|fs
operator|->
name|chp
operator|=
operator|(
expr|struct
name|Charparam
operator|*
operator|)
name|malloc
argument_list|(
literal|256
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|Charparam
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s/%s.%d%s"
argument_list|,
name|bitdir
argument_list|,
name|f
argument_list|,
name|fontdata
index|[
name|i
index|]
operator|.
name|size
index|[
name|j
index|]
argument_list|,
name|rotate
condition|?
literal|"r"
else|:
literal|""
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|fh
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|Fontheader
argument_list|)
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fd
argument_list|,
name|fs
operator|->
name|chp
argument_list|,
literal|256
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|Charparam
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|->
name|size
operator|=
name|fontdata
index|[
name|i
index|]
operator|.
name|size
index|[
name|j
index|]
expr_stmt|;
name|fs
operator|->
name|family
operator|=
name|nfamily
expr_stmt|;
name|nfamily
operator|+=
literal|2
expr_stmt|;
comment|/* even-odd leaves room for big fonts */
name|fs
operator|->
name|cdp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|fh
operator|.
name|f_size
argument_list|)
expr_stmt|;
name|fs
operator|->
name|chused
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|256
operator|/
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|256
operator|/
literal|8
condition|;
name|n
operator|++
control|)
name|fs
operator|->
name|chused
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|fs
operator|->
name|cdp
argument_list|,
name|fh
operator|.
name|f_size
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|fs
operator|=
name|fontdata
index|[
name|i
index|]
operator|.
name|fsp
index|[
name|j
index|]
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|xychar
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|Charparam
modifier|*
name|par
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|;
specifier|register
name|int
name|y
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|rwid
decl_stmt|,
name|ht
decl_stmt|,
name|fam
decl_stmt|;
name|x
operator|=
name|hpos
expr_stmt|;
name|y
operator|=
name|vpos
expr_stmt|;
if|if
condition|(
name|font
operator|!=
name|lastfont
operator|||
name|size
operator|!=
name|lastsize
condition|)
block|{
name|getfontdata
argument_list|(
name|fontname
index|[
name|font
index|]
operator|.
name|name
argument_list|,
name|pstab
index|[
name|size
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|lastsize
operator|=
name|size
expr_stmt|;
name|lastfont
operator|=
name|font
expr_stmt|;
block|}
name|par
operator|=
name|fs
operator|->
name|chp
operator|+
name|c
expr_stmt|;
name|p
operator|=
name|fs
operator|->
name|cdp
operator|+
name|par
operator|->
name|c_addr
expr_stmt|;
name|fam
operator|=
name|fs
operator|->
name|family
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|127
condition|)
name|fam
operator|++
expr_stmt|;
if|if
condition|(
name|fam
operator|!=
name|lastfam
condition|)
block|{
name|putc
argument_list|(
name|AF
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|lastfam
operator|=
name|fam
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
comment|/* first cut:  ship each glyph as needed. */
comment|/* ignore memory use, efficiency, etc. */
if|if
condition|(
operator|!
name|bit
argument_list|(
name|fs
operator|->
name|chused
argument_list|,
name|c
argument_list|)
condition|)
block|{
comment|/* 1st use of this character */
name|nglyph
operator|++
expr_stmt|;
name|totglyph
operator|+=
name|glspace
argument_list|(
name|par
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|fs
operator|->
name|chused
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|ASGLY
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putint
argument_list|(
operator|(
name|fam
operator|<<
literal|7
operator|)
operator||
name|c
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|par
operator|->
name|c_width
operator|=
operator|(
name|lastw
operator|*
name|RES
operator|)
operator|/
name|res
expr_stmt|;
name|putc
argument_list|(
name|par
operator|->
name|c_width
argument_list|,
name|tf
argument_list|)
expr_stmt|;
comment|/* character width */
name|putc
argument_list|(
name|par
operator|->
name|c_left
operator|+
name|par
operator|->
name|c_right
operator|+
literal|1
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|par
operator|->
name|c_left
argument_list|,
name|tf
argument_list|)
expr_stmt|;
comment|/* this nonsense fixes a bug in output produced by rec.c: */
comment|/* when up is< 0 (and = 0?) size is one too big */
name|rwid
operator|=
operator|(
literal|1
operator|+
name|par
operator|->
name|c_left
operator|+
name|par
operator|->
name|c_right
operator|+
name|WIDTH
operator|-
literal|1
operator|)
operator|/
name|WIDTH
expr_stmt|;
name|ht
operator|=
name|par
operator|->
name|c_size
operator|/
name|rwid
expr_stmt|;
name|par
operator|->
name|c_down
operator|=
name|ht
operator|-
name|par
operator|->
name|c_up
expr_stmt|;
name|putc
argument_list|(
name|par
operator|->
name|c_down
operator|+
name|par
operator|->
name|c_up
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|par
operator|->
name|c_up
argument_list|,
name|tf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|par
operator|->
name|c_size
init|;
name|i
operator|--
condition|;
control|)
name|putc
argument_list|(
operator|*
name|p
operator|++
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|!=
name|lasty
condition|)
block|{
name|putc
argument_list|(
name|AV
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putint
argument_list|(
name|y
operator|<<
literal|1
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
block|}
if|if
condition|(
name|abs
argument_list|(
name|x
operator|-
name|lastx
argument_list|)
operator|>
literal|127
condition|)
block|{
name|putc
argument_list|(
name|AH
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putint
argument_list|(
name|x
operator|<<
literal|1
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|lastx
operator|=
name|x
operator|+
name|par
operator|->
name|c_width
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abs
argument_list|(
name|x
operator|-
name|lastx
argument_list|)
operator|>
name|SLOP
condition|)
block|{
name|putc
argument_list|(
name|AM
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|x
operator|-
name|lastx
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|AM
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|lastx
operator|=
name|x
operator|+
name|par
operator|->
name|c_width
expr_stmt|;
block|}
else|else
block|{
name|lastx
operator|+=
name|par
operator|->
name|c_width
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<=
literal|127
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|tf
argument_list|)
expr_stmt|;
comment|/* fails if c> 127, probably disastrously */
else|else
name|putc
argument_list|(
name|c
operator|-
literal|128
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hvflush
argument_list|()
end_macro

begin_comment
comment|/* force position recorded in hpos,vpos */
end_comment

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
specifier|register
name|int
name|y
decl_stmt|;
name|x
operator|=
name|hpos
expr_stmt|;
name|y
operator|=
name|vpos
expr_stmt|;
if|if
condition|(
name|y
operator|!=
name|lasty
condition|)
block|{
name|putc
argument_list|(
name|AV
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putint
argument_list|(
name|y
operator|<<
literal|1
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|lasty
operator|=
name|y
expr_stmt|;
block|}
if|if
condition|(
name|abs
argument_list|(
name|x
operator|-
name|lastx
argument_list|)
operator|>
literal|127
condition|)
block|{
name|putc
argument_list|(
name|AH
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putint
argument_list|(
name|x
operator|<<
literal|1
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|lastx
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abs
argument_list|(
name|x
operator|-
name|lastx
argument_list|)
operator|>
name|SLOP
condition|)
block|{
name|putc
argument_list|(
name|AM
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|x
operator|-
name|lastx
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|AM
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|lastx
operator|=
name|x
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|glspace
argument_list|(
argument|par
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|Charparam
modifier|*
name|par
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
comment|/* works only for small glyphs right now */
name|n
operator|=
literal|12
operator|+
operator|(
operator|(
name|par
operator|->
name|c_left
operator|+
name|par
operator|->
name|c_right
operator|+
literal|1
operator|+
literal|15
operator|)
operator|/
literal|16
operator|)
operator|*
operator|(
name|par
operator|->
name|c_up
operator|+
name|par
operator|->
name|c_down
operator|)
operator|+
literal|2
expr_stmt|;
return|return
name|n
return|;
block|}
end_block

begin_macro
name|clearglyphs
argument_list|()
end_macro

begin_comment
comment|/* remove "used" bits from all glyphs */
end_comment

begin_comment
comment|/* delete all families */
end_comment

begin_comment
comment|/* very conservative policy */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|struct
name|fontset
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|tf
operator|==
name|stdout
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"clear %d glyphs (%d/%d) on page %d\n"
argument_list|,
name|nglyph
argument_list|,
name|totglyph
argument_list|,
name|maxglyph
argument_list|,
name|pageno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxfonts
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|fontdata
index|[
name|i
index|]
operator|.
name|size
index|[
name|j
index|]
operator|<
literal|999
condition|;
name|j
operator|++
control|)
block|{
name|f
operator|=
name|fontdata
index|[
name|i
index|]
operator|.
name|fsp
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|putc
argument_list|(
name|ADELF
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|f
operator|->
name|family
argument_list|,
name|tf
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|256
operator|/
literal|8
condition|;
name|k
operator|++
control|)
name|f
operator|->
name|chused
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|bit
argument_list|(
argument|p
argument_list|,
argument|n
argument_list|)
end_macro

begin_comment
comment|/* return n-th bit of p[] */
end_comment

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|p
index|[
name|n
operator|/
literal|8
index|]
operator|>>
operator|(
literal|7
operator|-
name|n
operator|%
literal|8
operator|)
operator|)
operator|&
literal|01
return|;
block|}
end_block

begin_macro
name|setbit
argument_list|(
argument|p
argument_list|,
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set bit n of p[] */
end_comment

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p
index|[
name|n
operator|/
literal|8
index|]
operator||=
literal|01
operator|<<
operator|(
literal|7
operator|-
name|n
operator|%
literal|8
operator|)
expr_stmt|;
block|}
end_block

begin_macro
name|putint
argument_list|(
argument|n
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putc
argument_list|(
name|n
operator|>>
literal|8
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|n
operator|&
literal|0377
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

