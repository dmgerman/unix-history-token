begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	dip.c	1.3	(Berkeley)	83/10/22  *	dip  *	driver for impress/imagen canon laser printer  */
end_comment

begin_comment
comment|/* output language from troff: all numbers are character strings  sn	size in points fn	font as number from 1-n cx	ascii character x Cxyz	funny char xyz. terminated by white space Hn	go to absolute horizontal position n Vn	go to absolute vertical position n (down is positive) hn	go n units horizontally (relative) vn	ditto vertically nnc	move right nn, then print c (exactly 2 digits!) 		(this wart is an optimization that shrinks output file size 		 about 35% and run-time about 15% while preserving ascii-ness) Dt ...\n	draw operation 't': 	Dl x y		line from here by x,y 	Dc d		circle of diameter d with left side here 	De x y		ellipse of axes x,y with left side here 	Da x y r	arc counter-clockwise by x,y of radius r 	D~ x y x y ...	wiggly line by x,y then x,y ... nb a	end of line (information only -- no action needed) 	b = space before line, a = after pn	new page begins -- set v to 0 #...\n	comment x ...\n	device control functions: 	x i	init 	x T s	name of device is s 	x r n h v	resolution is n/inch 		h = min horizontal motion, v = min vert 	x p	pause (can restart) 	x s	stop -- done for ever 	x t	generate trailer 	x f n s	font position n contains font s 	x H n	set character height to n 	x S n	set slant to N  	Subcommands like "i" are often spelled out like "init". */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"dev.h"
end_include

begin_include
include|#
directive|include
file|"canon.h"
end_include

begin_include
include|#
directive|include
file|"rst.h"
end_include

begin_comment
comment|/* #define  DEBUGABLE	/* whether or not it'll accept the -d option */
end_comment

begin_define
define|#
directive|define
name|abs
parameter_list|(
name|n
parameter_list|)
value|((n)>= 0 ? (n) : -(n))
end_define

begin_define
define|#
directive|define
name|hmot
parameter_list|(
name|n
parameter_list|)
value|hpos += n
end_define

begin_define
define|#
directive|define
name|hgoto
parameter_list|(
name|n
parameter_list|)
value|hpos = n
end_define

begin_define
define|#
directive|define
name|vmot
parameter_list|(
name|n
parameter_list|)
value|vpos += n
end_define

begin_define
define|#
directive|define
name|vgoto
parameter_list|(
name|n
parameter_list|)
value|vpos = n
end_define

begin_define
define|#
directive|define
name|FATAL
value|1
end_define

begin_define
define|#
directive|define
name|BMASK
value|0377
end_define

begin_define
define|#
directive|define
name|NFONT
value|30
end_define

begin_comment
comment|/* maximum forever */
end_comment

begin_define
define|#
directive|define
name|FONTDIR
value|"/usr/lib/font";
end_define

begin_define
define|#
directive|define
name|BITDIR
value|"/usr/local/lib/ifontt";
end_define

begin_comment
comment|/* BOTTOMTHRESH and DELTATHRESH are used to */
end_comment

begin_comment
comment|/* search through the glyphs downloaded to */
end_comment

begin_comment
comment|/* determine which ones to keep and which to */
end_comment

begin_comment
comment|/* dump.  They're tested against BOTTOMTHRESH */
end_comment

begin_comment
comment|/* first, then if THAT doesn't release enough */
end_comment

begin_comment
comment|/* space, DELTATHRESH is added until it is. */
end_comment

begin_define
define|#
directive|define
name|BOTTOMTHRESH
value|16
end_define

begin_define
define|#
directive|define
name|DELTATHRESH
value|16
end_define

begin_define
define|#
directive|define
name|MEMSIZE
value|70000
end_define

begin_comment
comment|/* amount of memory inside imagen */
end_comment

begin_define
define|#
directive|define
name|BUFFER
value|20000
end_define

begin_comment
comment|/* imagen memory set aside for page buffer */
end_comment

begin_define
define|#
directive|define
name|CHARRAY
value|128
end_define

begin_comment
comment|/* size of character use count array */
end_comment

begin_decl_stmt
name|int
name|MAXX
init|=
operator|(
name|RES
operator|*
literal|8
operator|+
name|RES
operator|/
literal|3
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of the page... (not 8-1/2" x 11", */
end_comment

begin_decl_stmt
name|int
name|MAXY
init|=
operator|(
name|RES
operator|*
literal|10
operator|+
name|RES
operator|/
literal|2
operator|+
name|RES
operator|/
literal|4
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  but 8-1/3" x 10-3/4") */
end_comment

begin_decl_stmt
name|int
name|output
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* do we do output at all? */
end_comment

begin_decl_stmt
name|int
name|pageno
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output page number */
end_comment

begin_decl_stmt
name|int
name|nolist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output page list if> 0 */
end_comment

begin_decl_stmt
name|int
name|olist
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pairs of page numbers */
end_comment

begin_decl_stmt
name|struct
name|dev
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|font
modifier|*
name|fontbase
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|pstab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nsizes
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfonts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nchtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|chname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|chtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|fitab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* legal characters for each font */
end_comment

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|widtab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* width table for each font */
end_comment

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|codetab
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device code translation */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fontname
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* what font is on what position? */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGABLE
end_ifdef

begin_decl_stmt
name|int
name|dbg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|FILE
modifier|*
name|tf
init|=
name|stdout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output file pointer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fontdir
init|=
name|FONTDIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bitdir
init|=
name|BITDIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
init|=
name|stdin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file pointer */
end_comment

begin_decl_stmt
name|int
name|totglyph
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total space used by glyphs sent down */
end_comment

begin_decl_stmt
name|int
name|maxglyph
init|=
name|MEMSIZE
operator|-
name|BUFFER
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum space for glyphs */
end_comment

begin_decl_stmt
name|int
name|size
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|font
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|family
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current horizontal position (left = 0) */
end_comment

begin_decl_stmt
name|int
name|vpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current vertical position (down positive) */
end_comment

begin_decl_stmt
name|int
name|lastw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* width of last input character */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|linethickness
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line drawing pars:  Thickness (pixels) */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|style
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   and type (SOLID, DOTTED, . . . ) */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|font
decl_stmt|;
name|int
name|size
decl_stmt|;
name|unsigned
name|char
name|chused
index|[
name|CHARRAY
index|]
decl_stmt|;
comment|/* test array - character downloaded? */
name|glyph_dir
modifier|*
name|glyph
decl_stmt|;
comment|/* array of character descriptions */
name|unsigned
name|char
modifier|*
name|cdp
decl_stmt|;
comment|/* char data pointer */
block|}
name|fontset
typedef|;
end_typedef

begin_decl_stmt
name|fontset
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A global pointer to the current family */
end_comment

begin_decl_stmt
name|fontset
name|fontdata
index|[
name|NFONT
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of family data descripters */
end_comment

begin_decl_stmt
name|int
name|lastsize
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastfont
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastx
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lasty
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastfam
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
name|char
modifier|*
name|operand
parameter_list|()
function_decl|;
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|*
operator|*
operator|++
name|argv
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'X'
case|:
name|MAXX
operator|=
name|atoi
argument_list|(
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|MAXY
operator|=
name|atoi
argument_list|(
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|fontdir
operator|=
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|bitdir
operator|=
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|outlist
argument_list|(
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
operator|(
name|i
operator|=
name|atoi
argument_list|(
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
argument_list|)
operator|)
operator|<
literal|1000
condition|)
name|i
operator|=
literal|1000
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
name|MEMSIZE
operator|-
literal|1000
condition|)
name|i
operator|=
name|MEMSIZE
operator|-
literal|1000
expr_stmt|;
name|maxglyph
operator|=
name|MEMSIZE
operator|-
name|i
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUGABLE
case|case
literal|'d'
case|:
name|dbg
operator|=
name|atoi
argument_list|(
name|operand
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
operator|==
literal|0
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"no debug value"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|conv
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|fp
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|conv
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|t_wrapup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	char  * operand (& argc,& argv)  |  | Results:	returns address of the operand given with a command-line  |		option.  It uses either "-Xoperand" or "-X operand", whichever  |		is present.  The program is terminated if no option is present.  |  | Side Efct:	argc and argv are updated as necessary.  *----------------------------------------------------------------------------*/
end_comment

begin_function
name|char
modifier|*
name|operand
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
operator|*
name|argvp
operator|)
index|[
literal|2
index|]
condition|)
return|return
operator|(
operator|*
operator|*
name|argvp
operator|+
literal|2
operator|)
return|;
comment|/* operand immediately follows */
if|if
condition|(
operator|(
operator|--
operator|*
name|argcp
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* no operand */
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"command-line option operand missing."
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|*
operator|(
operator|++
operator|(
operator|*
name|argvp
operator|)
operator|)
operator|)
return|;
comment|/* operand next word */
block|}
end_function

begin_macro
name|outlist
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* process list of page numbers to be printed */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|,
name|i
decl_stmt|;
name|nolist
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|n1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|do
name|n1
operator|=
literal|10
operator|*
name|n1
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
else|else
name|n1
operator|=
operator|-
literal|9999
expr_stmt|;
name|n2
operator|=
name|n1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|n2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|do
name|n2
operator|=
literal|10
operator|*
name|n2
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
else|else
name|n2
operator|=
literal|9999
expr_stmt|;
block|}
name|olist
index|[
name|nolist
operator|++
index|]
operator|=
name|n1
expr_stmt|;
name|olist
index|[
name|nolist
operator|++
index|]
operator|=
name|n2
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|olist
index|[
name|nolist
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nolist
condition|;
name|i
operator|+=
literal|2
control|)
name|printf
argument_list|(
literal|"%3d %3d\n"
argument_list|,
name|olist
index|[
name|i
index|]
argument_list|,
name|olist
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|in_olist
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* is n in olist? */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nolist
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* everything is included */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nolist
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
name|n
operator|>=
name|olist
index|[
name|i
index|]
operator|&&
name|n
operator|<=
name|olist
index|[
name|i
operator|+
literal|1
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|conv
argument_list|(
name|fp
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|int
name|m
decl_stmt|,
name|n
decl_stmt|,
name|n1
decl_stmt|,
name|m1
decl_stmt|;
name|char
name|str
index|[
literal|100
index|]
decl_stmt|,
name|buf
index|[
literal|300
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* when input is text */
case|case
literal|' '
case|:
case|case
literal|0
case|:
comment|/* occasional noise creeps in */
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* two motion digits plus a character */
name|hmot
argument_list|(
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|getc
argument_list|(
name|fp
argument_list|)
operator|-
literal|'0'
argument_list|)
expr_stmt|;
name|put1
argument_list|(
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* single ascii character */
name|put1
argument_list|(
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|put1s
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* draw function */
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'l'
case|:
comment|/* draw a line */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|drawline
argument_list|(
name|n
argument_list|,
name|m
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* circle */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawcirc
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* ellipse */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawellip
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* arc */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d %d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n1
argument_list|,
operator|&
name|m1
argument_list|)
expr_stmt|;
name|drawarc
argument_list|(
name|n
argument_list|,
name|m
argument_list|,
name|n1
argument_list|,
name|m1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* gremlin curve */
case|case
literal|'~'
case|:
comment|/* wiggly line */
name|drawwig
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawthick
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|drawstyle
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unknown drawing function %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'s'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
comment|/* ignore fractional sizes */
name|setsize
argument_list|(
name|t_size
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|setfont
argument_list|(
name|t_font
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* absolute horizontal motion */
comment|/* fscanf(fp, "%d",&n); */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|hgoto
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* relative horizontal motion */
comment|/* fscanf(fp, "%d",&n); */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* word space */
break|break;
case|case
literal|'V'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|vgoto
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* new page */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_page
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* end of line */
while|while
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|hpos
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* comment */
while|while
condition|(
name|getc
argument_list|(
name|fp
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* device control */
name|devcntrl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unknown input character %o %c"
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|devcntrl
argument_list|(
argument|fp
argument_list|)
end_macro

begin_comment
comment|/* interpret device control functions */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|str
index|[
literal|20
index|]
decl_stmt|,
name|str1
index|[
literal|50
index|]
decl_stmt|,
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|str
index|[
literal|0
index|]
condition|)
block|{
comment|/* crude for now */
case|case
literal|'i'
case|:
comment|/* initialize */
name|fileinit
argument_list|()
expr_stmt|;
name|t_init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* device name */
case|case
literal|'t'
case|:
comment|/* trailer */
case|case
literal|'p'
case|:
comment|/* pause -- can restart */
case|case
literal|'s'
case|:
comment|/* stop */
break|break;
case|case
literal|'r'
case|:
comment|/* resolution assumed when prepared */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|RES
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"Input computed with wrong resolution"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* font used */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d %s"
argument_list|,
operator|&
name|n
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* in case there's a filename */
name|ungetc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* fgets goes too far */
name|str1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* in case there's nothing to come in */
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
name|str1
argument_list|)
expr_stmt|;
name|loadfont
argument_list|(
name|n
argument_list|,
name|str
argument_list|,
name|str1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* char height */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_charht
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* slant */
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|t_slant
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
comment|/* skip rest of input line */
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
block|}
end_block

begin_macro
name|fileinit
argument_list|()
end_macro

begin_comment
comment|/* read in font and code files, etc. */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|fin
decl_stmt|;
specifier|register
name|int
name|nw
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|filebase
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|char
name|temp
index|[
literal|100
index|]
decl_stmt|;
comment|/* open table for device, 		 * read in resolution, size info, font info, etc. 		 * and set params 		 */
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/devip/DESC.out"
argument_list|,
name|fontdir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|open
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open tables for %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fin
argument_list|,
operator|&
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|nfonts
operator|=
name|dev
operator|.
name|nfonts
expr_stmt|;
name|nsizes
operator|=
name|dev
operator|.
name|nsizes
expr_stmt|;
name|nchtab
operator|=
name|dev
operator|.
name|nchtab
expr_stmt|;
name|filebase
operator|=
name|malloc
argument_list|(
name|dev
operator|.
name|filesize
argument_list|)
expr_stmt|;
comment|/* enough room for whole file */
name|read
argument_list|(
name|fin
argument_list|,
name|filebase
argument_list|,
name|dev
operator|.
name|filesize
argument_list|)
expr_stmt|;
comment|/* all at once */
name|pstab
operator|=
operator|(
name|short
operator|*
operator|)
name|filebase
expr_stmt|;
name|chtab
operator|=
name|pstab
operator|+
name|nsizes
operator|+
literal|1
expr_stmt|;
name|chname
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|chtab
operator|+
name|dev
operator|.
name|nchtab
operator|)
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|chname
operator|+
name|dev
operator|.
name|lchname
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nfonts
condition|;
name|i
operator|++
control|)
block|{
name|fontbase
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|font
operator|*
operator|)
name|p
expr_stmt|;
name|nw
operator|=
operator|*
name|p
operator|&
name|BMASK
expr_stmt|;
comment|/* 1st thing is width count */
name|p
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
expr_stmt|;
name|widtab
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
comment|/* then width table */
name|codetab
index|[
name|i
index|]
operator|=
name|p
operator|+
literal|2
operator|*
name|nw
expr_stmt|;
comment|/* then code conversion table */
name|fitab
index|[
name|i
index|]
operator|=
name|p
operator|+
literal|3
operator|*
name|nw
expr_stmt|;
comment|/* then font inclusion table */
name|p
operator|+=
literal|3
operator|*
name|nw
operator|+
name|dev
operator|.
name|nchtab
operator|+
literal|128
operator|-
literal|32
expr_stmt|;
name|t_fp
argument_list|(
name|i
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|namefont
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|intname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
operator|>
literal|1
condition|)
name|fontprint
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|fontbase
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
comment|/* no fonts loaded yet */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NFONT
condition|;
name|i
operator|++
control|)
name|fontdata
index|[
name|i
index|]
operator|.
name|font
operator|=
name|fontdata
index|[
name|i
index|]
operator|.
name|size
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGABLE
end_ifdef

begin_macro
name|fontprint
argument_list|(
argument|i
argument_list|)
end_macro

begin_comment
comment|/* debugging print of font i (0,...) */
end_comment

begin_block
block|{
name|int
name|j
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
literal|"font %d:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|fontbase
index|[
name|i
index|]
expr_stmt|;
name|n
operator|=
name|fontbase
index|[
name|i
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
name|printf
argument_list|(
literal|"base=0%o, nchars=%d, spec=%d, name=%s, widtab=0%o, fitab=0%o\n"
argument_list|,
name|p
argument_list|,
name|n
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|specfont
argument_list|,
name|fontbase
index|[
name|i
index|]
operator|->
name|namefont
argument_list|,
name|widtab
index|[
name|i
index|]
argument_list|,
name|fitab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"widths:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2d"
argument_list|,
name|widtab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\ncodetab:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|n
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2d"
argument_list|,
name|codetab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nfitab:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|dev
operator|.
name|nchtab
operator|+
literal|128
operator|-
literal|32
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %2d"
argument_list|,
name|fitab
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|BMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|%
literal|20
operator|==
literal|19
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|loadfont
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|,
argument|s1
argument_list|)
end_macro

begin_comment
comment|/* load font info for font s on position n (0...) */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|temp
index|[
literal|60
index|]
decl_stmt|;
name|int
name|fin
decl_stmt|,
name|nw
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|NFONT
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"illegal fp command %d %s"
argument_list|,
name|n
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontbase
index|[
name|n
index|]
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|s
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|namefont
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|s1
operator|==
name|NULL
operator|||
name|s1
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/devip/%s.out"
argument_list|,
name|fontdir
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/%s.out"
argument_list|,
name|s1
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|open
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"can't open font table %s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fontbase
index|[
name|n
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|fontbase
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|fontbase
index|[
name|n
index|]
operator|=
operator|(
expr|struct
name|font
operator|*
operator|)
name|malloc
argument_list|(
literal|3
operator|*
literal|255
operator|+
name|dev
operator|.
name|nchtab
operator|+
operator|(
literal|128
operator|-
literal|32
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontbase
index|[
name|n
index|]
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"Out of space in loadfont %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fin
argument_list|,
name|fontbase
index|[
name|n
index|]
argument_list|,
literal|3
operator|*
literal|255
operator|+
name|nchtab
operator|+
literal|128
operator|-
literal|32
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|nw
operator|=
name|fontbase
index|[
name|n
index|]
operator|->
name|nwfont
operator|&
name|BMASK
expr_stmt|;
name|widtab
index|[
name|n
index|]
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fontbase
index|[
name|n
index|]
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|font
argument_list|)
expr_stmt|;
name|codetab
index|[
name|n
index|]
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|widtab
index|[
name|n
index|]
operator|+
literal|2
operator|*
name|nw
expr_stmt|;
name|fitab
index|[
name|n
index|]
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|widtab
index|[
name|n
index|]
operator|+
literal|3
operator|*
name|nw
expr_stmt|;
name|t_fp
argument_list|(
name|n
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|namefont
argument_list|,
name|fontbase
index|[
name|n
index|]
operator|->
name|intname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
operator|>
literal|1
condition|)
name|fontprint
argument_list|(
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*VARARGS2*/
end_comment

begin_macro
name|error
argument_list|(
argument|f
argument_list|,
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|,
argument|a6
argument_list|,
argument|a7
argument_list|)
end_macro

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dip: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|t_init
argument_list|(
argument|reinit
argument_list|)
end_macro

begin_comment
comment|/* initialize device */
end_comment

begin_decl_stmt
name|int
name|reinit
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|reinit
condition|)
block|{
name|drawthick
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* set the line thickness parameter */
block|}
name|hpos
operator|=
name|vpos
operator|=
literal|0
expr_stmt|;
name|setsize
argument_list|(
name|t_size
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
comment|/* start somewhere */
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	t_page ( page_number )  |  | Results:	mark this page done for printing.  If we think we've filled  |		the imagen too much, delete some of the info in the glyph cache.  |		This is a good time to do this since it's at the end of a page  |		and will get done every so often.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|t_page
argument_list|(
argument|pg
argument_list|)
end_macro

begin_comment
comment|/* do whatever new page functions */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|threshold
decl_stmt|;
name|pageno
operator|=
name|pg
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"t_page %d, output=%d\n"
argument_list|,
name|pg
argument_list|,
name|output
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|output
operator|!=
literal|0
condition|)
name|putc
argument_list|(
name|AEND
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|output
operator|=
name|in_olist
argument_list|(
name|pg
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
condition|)
block|{
name|threshold
operator|=
name|BOTTOMTHRESH
expr_stmt|;
while|while
condition|(
name|totglyph
operator|>=
name|maxglyph
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFONT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fontdata
index|[
name|i
index|]
operator|.
name|font
operator|!=
operator|-
literal|1
condition|)
name|clearglyphs
argument_list|(
name|i
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
block|}
name|threshold
operator|+=
name|DELTATHRESH
expr_stmt|;
block|}
block|}
name|lastx
operator|=
name|lasty
operator|=
operator|-
literal|1
expr_stmt|;
name|t_init
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|t_size
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* convert integer to internal size number*/
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|n
operator|<=
name|pstab
index|[
literal|0
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|n
operator|>=
name|pstab
index|[
name|nsizes
operator|-
literal|1
index|]
condition|)
return|return
operator|(
name|nsizes
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|n
operator|>
name|pstab
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|t_charht
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set character height to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* punt for now */
block|}
end_block

begin_macro
name|t_slant
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set slant to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* punt for now */
block|}
end_block

begin_macro
name|t_font
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* convert string to internal font number */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|nfonts
condition|)
name|n
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|t_wrapup
argument_list|()
end_macro

begin_block
block|{
name|putc
argument_list|(
name|AEND
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|AEOF
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|t_rule
argument_list|(
argument|w
argument_list|,
argument|h
argument_list|)
end_macro

begin_block
block|{
name|hvflush
argument_list|()
expr_stmt|;
name|putc
argument_list|(
name|ABRULE
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putint
argument_list|(
name|w
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putint
argument_list|(
name|h
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putint
argument_list|(
operator|-
name|h
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|put1s
argument_list|(
name|s
argument_list|)
comment|/* s is a funny char name */
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
operator|&
name|chname
index|[
name|chtab
index|[
name|i
index|]
index|]
argument_list|)
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchtab
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|chname
index|[
name|chtab
index|[
name|i
index|]
index|]
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|nchtab
condition|)
name|put1
argument_list|(
name|i
operator|+
literal|128
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|put1
argument_list|(
name|c
argument_list|)
comment|/* output char c */
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|pw
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|int
name|ofont
decl_stmt|,
name|code
decl_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
return|return;
name|c
operator|-=
literal|32
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"non-exist 0%o\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|ofont
operator|=
name|font
expr_stmt|;
name|i
operator|=
name|fitab
index|[
name|font
index|]
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* it's on this font */
name|p
operator|=
name|codetab
index|[
name|font
index|]
expr_stmt|;
name|pw
operator|=
name|widtab
index|[
name|font
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* on another font */
name|k
operator|=
name|font
expr_stmt|;
comment|/* start with current, then run down the list */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|++
operator|<=
name|nfonts
condition|;
name|k
operator|=
operator|(
name|k
operator|+
literal|1
operator|)
operator|%
operator|(
name|nfonts
operator|+
literal|1
operator|)
control|)
if|if
condition|(
name|fontbase
index|[
name|k
index|]
operator|!=
name|NULL
operator|&&
operator|(
name|i
operator|=
name|fitab
index|[
name|k
index|]
index|[
name|c
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|codetab
index|[
name|k
index|]
expr_stmt|;
name|pw
operator|=
name|widtab
index|[
name|k
index|]
expr_stmt|;
name|setfont
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|code
operator|=
name|p
index|[
name|i
index|]
operator|&
name|BMASK
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"not found 0%o\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|lastw
operator|=
operator|(
name|pw
index|[
name|i
index|]
operator|*
name|pstab
index|[
name|size
index|]
operator|+
name|dev
operator|.
name|unitwidth
operator|/
literal|2
operator|)
operator|/
name|dev
operator|.
name|unitwidth
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
operator|+
literal|32
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%c %d\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%03o %d\n"
argument_list|,
name|c
operator|+
literal|32
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|output
condition|)
name|xychar
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|font
operator|!=
name|ofont
condition|)
name|setfont
argument_list|(
name|ofont
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|setsize
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set point size to n (internal) */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|size
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	t_fp ( number, string, string_internal )  |  | Results:	font position number now contains font 'string', internal  |		font name (number) is ignored.  |  | Side Efct:	any fonts loaded into fontdata with this font number are  |		removed.  And, to make sure they're not accessed, if lastfont  |		equals number, it is "disabled" by setting lastfont to -1.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|t_fp
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|,
argument|si
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|si
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|fontname
index|[
name|n
index|]
operator|=
name|s
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NFONT
condition|;
name|i
operator|++
control|)
comment|/* release any font files */
if|if
condition|(
name|fontdata
index|[
name|i
index|]
operator|.
name|font
operator|==
name|n
condition|)
block|{
comment|/* for this font */
name|clearglyphs
argument_list|(
name|i
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|AFORCE
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fontdata
index|[
name|i
index|]
operator|.
name|cdp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fontdata
index|[
name|i
index|]
operator|.
name|glyph
argument_list|)
expr_stmt|;
name|fontdata
index|[
name|i
index|]
operator|.
name|font
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
name|lastfont
condition|)
name|lastfont
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|setfont
argument_list|(
argument|n
argument_list|)
end_macro

begin_comment
comment|/* set font to n */
end_comment

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|output
condition|)
return|return;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|NFONT
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"illegal font %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|font
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	rd1, rd2, rd3, rd4 ( file_pointer )  |  | Results:	gets one, two three or four bytes from a file and interprets  |		them as integers.  Most significant bytes come first.  *----------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|rd1
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"font file read error"
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
name|int
name|rd2
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|short
name|i
init|=
name|rd1
argument_list|(
name|fp
argument_list|)
operator|<<
literal|8
decl_stmt|;
return|return
name|i
operator||
name|rd1
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|rd3
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
name|rd2
argument_list|(
name|fp
argument_list|)
operator|<<
literal|8
decl_stmt|;
return|return
name|i
operator||
name|rd1
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|rd4
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
name|rd2
argument_list|(
name|fp
argument_list|)
operator|<<
literal|16
decl_stmt|;
return|return
name|i
operator||
name|rd2
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	getfontdata ( font, size )  |  | Results:	returns the family number of the font/size found.  The font  |		information pointer, fs, is set to point to data for "font"  |		at point size "size".  If no information for that font is  |		available, the info is read in from the appropriate font file.  |		The table "fontdata" holds all the fonts, and it is cleared  |		of a random font/size if necessary.  *----------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|getfontdata
parameter_list|(
name|f
parameter_list|,
name|s
parameter_list|)
name|int
name|f
decl_stmt|;
name|int
name|s
decl_stmt|;
block|{
name|char
name|name
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|fam
decl_stmt|;
specifier|register
name|int
name|bitbase
decl_stmt|;
specifier|register
name|glyph_dir
modifier|*
name|maxgp
decl_stmt|;
specifier|register
name|glyph_dir
modifier|*
name|mingp
decl_stmt|;
specifier|register
name|glyph_dir
modifier|*
name|gp
decl_stmt|;
name|preamble
name|p
decl_stmt|;
comment|/* first check if it's here already */
for|for
control|(
name|fam
operator|=
literal|0
init|;
name|fam
operator|<=
name|NFONT
condition|;
name|fam
operator|++
control|)
if|if
condition|(
name|fontdata
index|[
name|fam
index|]
operator|.
name|font
operator|==
name|f
operator|&&
name|fontdata
index|[
name|fam
index|]
operator|.
name|size
operator|==
name|s
condition|)
block|{
name|fs
operator|=
operator|&
name|fontdata
index|[
name|fam
index|]
expr_stmt|;
return|return
operator|(
name|fam
operator|)
return|;
block|}
comment|/* find an empty slot */
for|for
control|(
name|fam
operator|=
literal|0
init|;
name|fam
operator|<
name|NFONT
operator|&&
name|fontdata
index|[
name|fam
index|]
operator|.
name|font
operator|!=
operator|-
literal|1
condition|;
name|fam
operator|++
control|)
empty_stmt|;
name|fs
operator|=
operator|&
name|fontdata
index|[
name|fam
index|]
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|font
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* clear a slot if not empty */
name|clearglyphs
argument_list|(
name|fam
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
comment|/* dumb version - always take */
name|putc
argument_list|(
name|AFORCE
argument_list|,
name|tf
argument_list|)
expr_stmt|;
comment|/* the last one to replace */
name|free
argument_list|(
name|fs
operator|->
name|glyph
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fs
operator|->
name|cdp
argument_list|)
expr_stmt|;
block|}
comment|/* open font file */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s/%s.%d"
argument_list|,
name|bitdir
argument_list|,
name|fontname
index|[
name|f
index|]
argument_list|,
name|pstab
index|[
name|s
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* check for proper file mark */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FMARK
condition|;
name|filemark
index|[
name|i
operator|++
index|]
operator|=
name|getc
argument_list|(
name|fd
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|filemark
argument_list|,
literal|"Rast"
argument_list|,
literal|4
argument_list|)
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"bad File Mark in %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* get preamble */
name|p
operator|.
name|p_size
operator|=
name|rd2
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|p
operator|.
name|p_version
operator|=
name|rd1
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|.
name|p_version
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"wrong version of Font file: %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|p
operator|.
name|p_glyph
operator|=
name|rd3
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|p
operator|.
name|p_first
operator|=
name|rd2
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|p
operator|.
name|p_last
operator|=
name|rd2
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* skip rest of preamble */
name|i
operator|=
name|p
operator|.
name|p_glyph
operator|-
literal|18
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
name|getc
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fs
operator|->
name|glyph
operator|=
operator|(
name|glyph_dir
operator|*
operator|)
comment|/* allocate first */
operator|(
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|p
operator|.
name|p_last
operator|-
name|p
operator|.
name|p_first
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|glyph_dir
argument_list|)
argument_list|)
operator|-
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|.
name|p_first
operator|*
sizeof|sizeof
argument_list|(
name|glyph_dir
argument_list|)
operator|)
operator|)
expr_stmt|;
name|mingp
operator|=
name|maxgp
operator|=
name|gp
operator|=
name|fs
operator|->
name|glyph
expr_stmt|;
for|for
control|(
name|i
operator|=
name|p
operator|.
name|p_first
init|;
name|i
operator|++
operator|<=
name|p
operator|.
name|p_last
condition|;
name|gp
operator|++
control|)
block|{
name|gp
operator|->
name|g_height
operator|=
name|rd2
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|gp
operator|->
name|g_width
operator|=
name|rd2
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|gp
operator|->
name|g_up
operator|=
name|rd2
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|gp
operator|->
name|g_left
operator|=
name|rd2
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|gp
operator|->
name|g_pwidth
operator|=
name|rd4
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gp
operator|->
name|g_bitp
operator|=
name|rd3
argument_list|(
name|fd
argument_list|)
operator|)
operator|>
name|maxgp
operator|->
name|g_bitp
condition|)
comment|/* find the glyphs */
name|maxgp
operator|=
name|gp
expr_stmt|;
comment|/* farthest and */
elseif|else
if|if
condition|(
name|gp
operator|->
name|g_bitp
operator|<
name|mingp
operator|->
name|g_bitp
condition|)
comment|/* nearest to the */
name|mingp
operator|=
name|gp
expr_stmt|;
comment|/* start of the file */
block|}
name|bitbase
operator|=
name|mingp
operator|->
name|g_bitp
expr_stmt|;
comment|/* remove file offset in bit pointers */
for|for
control|(
name|gp
operator|=
name|fs
operator|->
name|glyph
operator|,
name|i
operator|=
name|p
operator|.
name|p_first
init|;
name|i
operator|++
operator|<=
name|p
operator|.
name|p_last
condition|;
name|gp
operator|++
control|)
name|gp
operator|->
name|g_bitp
operator|-=
name|bitbase
expr_stmt|;
name|i
operator|=
name|maxgp
operator|->
name|g_bitp
operator|+
name|maxgp
operator|->
name|g_height
operator|*
operator|(
operator|(
name|maxgp
operator|->
name|g_width
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
expr_stmt|;
name|fs
operator|->
name|cdp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|fileno
argument_list|(
name|fd
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|bitbase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fileno
argument_list|(
name|fd
argument_list|)
argument_list|,
name|fs
operator|->
name|cdp
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't read in %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fs
operator|->
name|size
operator|=
name|s
expr_stmt|;
name|fs
operator|->
name|font
operator|=
name|f
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CHARRAY
condition|;
name|fs
operator|->
name|chused
index|[
name|i
operator|++
index|]
operator|=
literal|0
control|)
empty_stmt|;
return|return
operator|(
name|fam
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|xychar
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|glyph_dir
modifier|*
name|par
decl_stmt|;
specifier|register
name|int
name|gsize
decl_stmt|;
if|if
condition|(
name|c
operator|>=
name|CHARRAY
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"character out of range: %d 0%o"
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|font
operator|!=
name|lastfont
operator|||
name|size
operator|!=
name|lastsize
condition|)
block|{
name|family
operator|=
name|getfontdata
argument_list|(
name|font
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|lastsize
operator|=
name|size
expr_stmt|;
name|lastfont
operator|=
name|font
expr_stmt|;
block|}
name|par
operator|=
operator|&
operator|(
name|fs
operator|->
name|glyph
index|[
name|c
index|]
operator|)
expr_stmt|;
name|p
operator|=
name|fs
operator|->
name|cdp
operator|+
name|par
operator|->
name|g_bitp
expr_stmt|;
if|if
condition|(
name|family
operator|!=
name|lastfam
condition|)
block|{
name|putc
argument_list|(
name|AF
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|lastfam
operator|=
name|family
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|->
name|chused
index|[
name|c
index|]
operator|==
literal|0
condition|)
block|{
comment|/* 1st use of this character */
name|totglyph
operator|+=
name|glspace
argument_list|(
name|par
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fs
operator|->
name|chused
index|[
name|c
index|]
operator|)
operator|++
operator|==
name|BMASK
condition|)
name|fs
operator|->
name|chused
index|[
name|c
index|]
operator|=
name|BMASK
expr_stmt|;
name|putc
argument_list|(
name|ABGLY
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putint
argument_list|(
operator|(
name|family
operator|<<
literal|7
operator|)
operator||
name|c
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putint
argument_list|(
name|lastw
argument_list|,
name|tf
argument_list|)
expr_stmt|;
comment|/* use troff's width, not */
name|putint
argument_list|(
name|par
operator|->
name|g_width
argument_list|,
name|tf
argument_list|)
expr_stmt|;
comment|/* the RST character width */
name|putint
argument_list|(
name|par
operator|->
name|g_left
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putint
argument_list|(
name|par
operator|->
name|g_height
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putint
argument_list|(
name|par
operator|->
name|g_up
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|gsize
operator|=
operator|(
operator|(
name|par
operator|->
name|g_width
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
operator|*
name|par
operator|->
name|g_height
expr_stmt|;
while|while
condition|(
name|gsize
operator|--
condition|)
name|putc
argument_list|(
operator|*
name|p
operator|++
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
name|hvflush
argument_list|()
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|tf
argument_list|)
expr_stmt|;
comment|/* guaranteed to be in range */
name|lastx
operator|+=
name|lastw
expr_stmt|;
comment|/* take account of the automatic advance */
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	hvflush ( )  |  | Results:	force current position (hpos, vpos) on the imagen  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|hvflush
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|vpos
operator|!=
name|lasty
condition|)
block|{
name|putc
argument_list|(
name|ASETV
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putint
argument_list|(
name|lasty
operator|=
name|vpos
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hpos
operator|!=
name|lastx
condition|)
block|{
name|putc
argument_list|(
name|ASETH
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putint
argument_list|(
name|lastx
operator|=
name|hpos
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	glspace ( glyph )  |  | Results:	returns how much space the glyph (defined by the glyph_dir  |		entry) will take in the imagen's memory.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|glspace
argument_list|(
argument|par
argument_list|)
end_macro

begin_decl_stmt
name|glyph_dir
modifier|*
name|par
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
literal|19
operator|+
operator|(
operator|(
name|par
operator|->
name|g_width
operator|+
literal|15
operator|)
operator|/
literal|16
operator|)
operator|*
operator|(
name|par
operator|->
name|g_height
operator|)
return|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	clearglyphs ( index, limit )  |  | Results:	any glyphs downloaded into the imagen with a "chused" entry  |		less than "limit" (and> 0) are marked for deletion and their  |		space is "unrecorded" in totglyph.  |  | Bugs:	clearglyphs does NOT check index to make sure the family exists  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|clearglyphs
argument_list|(
argument|index
argument_list|,
argument|limit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|limit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|fontset
modifier|*
name|f
init|=
operator|&
name|fontdata
index|[
name|index
index|]
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"clear %d family of %d (%d/%d) on page %d\n"
argument_list|,
name|index
argument_list|,
name|limit
argument_list|,
name|totglyph
argument_list|,
name|maxglyph
argument_list|,
name|pageno
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CHARRAY
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|f
operator|->
name|chused
index|[
name|j
index|]
operator|&&
name|f
operator|->
name|chused
index|[
name|j
index|]
operator|<
name|limit
condition|)
block|{
name|putc
argument_list|(
name|ADELG
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|putint
argument_list|(
name|index
operator|<<
literal|7
operator||
name|j
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|totglyph
operator|-=
name|glspace
argument_list|(
operator|&
operator|(
name|f
operator|->
name|glyph
index|[
name|j
index|]
operator|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|chused
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|putint
argument_list|(
argument|n
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putc
argument_list|(
name|n
operator|>>
literal|8
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|n
operator|&
literal|0377
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

