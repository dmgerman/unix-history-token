begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* graph.c	1.1	83/07/01  *  *	This file contains the functions for producing the graphics  *   images in the varian/versatec drivers for ditroff.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|MAXPOINTS
value|200
end_define

begin_comment
comment|/* number of points legal for a curve */
end_comment

begin_define
define|#
directive|define
name|SOLID
value|-1
end_define

begin_comment
comment|/* line styles:  these are used as bit masks to */
end_comment

begin_define
define|#
directive|define
name|DOTTED
value|004
end_define

begin_comment
comment|/* create the right style lines. */
end_comment

begin_define
define|#
directive|define
name|DASHED
value|020
end_define

begin_define
define|#
directive|define
name|DOTDASHED
value|024
end_define

begin_define
define|#
directive|define
name|LONGDASHED
value|074
end_define

begin_comment
comment|/* constants... */
end_comment

begin_define
define|#
directive|define
name|pi
value|3.141592653589793238462643
end_define

begin_define
define|#
directive|define
name|log2_10
value|3.3219280948873623
end_define

begin_comment
comment|/* imports from dver.c */
end_comment

begin_define
define|#
directive|define
name|hmot
parameter_list|(
name|n
parameter_list|)
value|hpos += n;
end_define

begin_define
define|#
directive|define
name|vmot
parameter_list|(
name|n
parameter_list|)
value|vgoto(vpos + n);
end_define

begin_decl_stmt
specifier|extern
name|int
name|hpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|vpos
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern vgoto(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern point(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|linethickness
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pixels wide to make lines */
end_comment

begin_decl_stmt
name|int
name|linmod
init|=
name|SOLID
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type of line (SOLID, DOTTED, DASHED...) */
end_comment

begin_decl_stmt
name|int
name|lastx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lasty
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|drawline
argument_list|(
name|dh
argument_list|,
name|dv
argument_list|)
specifier|register
name|int
name|dh
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|dv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HGtline
argument_list|(
name|hpos
argument_list|,
name|vpos
argument_list|,
name|hpos
operator|+
name|dh
argument_list|,
name|vpos
operator|+
name|dv
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|dh
argument_list|)
expr_stmt|;
comment|/* new position is at */
name|vmot
argument_list|(
name|dv
argument_list|)
expr_stmt|;
comment|/* the end of the line */
block|}
end_block

begin_expr_stmt
name|drawcirc
argument_list|(
name|d
argument_list|)
specifier|register
name|int
name|d
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|HGArc
argument_list|(
name|hpos
operator|+
name|d
operator|/
literal|2
argument_list|,
name|vpos
argument_list|,
name|hpos
argument_list|,
name|vpos
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* new postion is the right of the circle */
block|}
end_block

begin_expr_stmt
name|drawellip
argument_list|(
name|h
argument_list|,
name|v
argument_list|)
specifier|register
name|int
name|h
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_expr_stmt
name|drawarc
argument_list|(
name|cdh
argument_list|,
name|cdv
argument_list|,
name|pdh
argument_list|,
name|pdv
argument_list|)
specifier|register
name|int
name|cdh
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|cdv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|pdh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|pdv
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|double
name|angle
decl_stmt|;
comment|/* figure angle from the three points...*/
name|angle
operator|=
name|atan2
argument_list|(
operator|(
name|double
operator|)
operator|-
name|cdh
argument_list|,
operator|(
name|double
operator|)
operator|-
name|cdv
argument_list|)
operator|-
name|atan2
argument_list|(
operator|(
name|double
operator|)
name|pdh
argument_list|,
operator|(
name|double
operator|)
name|pdv
argument_list|)
expr_stmt|;
if|if
condition|(
name|angle
operator|<
literal|0.0
condition|)
name|angle
operator|+=
literal|2
operator|*
name|pi
expr_stmt|;
name|HGArc
argument_list|(
name|hpos
operator|+
name|cdh
argument_list|,
name|vpos
operator|+
name|cdv
argument_list|,
name|hpos
operator|+
name|cdh
operator|+
name|pdh
argument_list|,
name|vpos
operator|+
name|cdv
operator|+
name|pdv
argument_list|,
name|angle
operator|*
literal|180.0
operator|/
name|pi
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|cdh
operator|+
name|pdh
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|cdv
operator|+
name|pdv
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|drawwig
argument_list|(
argument|buf
argument_list|,
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
init|=
name|buf
decl_stmt|;
name|float
name|x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/* skip any leading spaces */
while|while
condition|(
operator|*
name|ptr
operator|!=
literal|'\n'
condition|)
block|{
comment|/* curve commands end with a "cr" */
name|hmot
argument_list|(
call|(
name|int
call|)
argument_list|(
name|x
index|[
name|i
index|]
operator|=
operator|(
name|float
operator|)
name|atoi
argument_list|(
name|ptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* convert text */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|ptr
argument_list|)
condition|)
empty_stmt|;
comment|/* to curve points */
while|while
condition|(
operator|*
operator|++
name|ptr
operator|==
literal|' '
condition|)
empty_stmt|;
name|vmot
argument_list|(
call|(
name|int
call|)
argument_list|(
name|y
index|[
name|i
index|]
operator|=
operator|(
name|float
operator|)
name|atoi
argument_list|(
name|ptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|ptr
argument_list|)
condition|)
empty_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/* if the amount we read wasn't the */
comment|/*    whole thing, read some more in */
if|if
condition|(
name|len
operator|-
operator|(
name|ptr
operator|-
name|buf
operator|)
operator|<
literal|15
operator|&&
operator|*
operator|(
name|buf
operator|+
name|len
operator|-
literal|1
operator|)
operator|!=
literal|'\n'
condition|)
block|{
name|char
modifier|*
name|cop
init|=
name|buf
decl_stmt|;
while|while
condition|(
operator|*
name|cop
operator|++
operator|=
operator|*
name|ptr
operator|++
condition|)
empty_stmt|;
comment|/* copy what's left to the beginning */
name|fgets
argument_list|(
operator|(
name|cop
operator|-
literal|1
operator|)
argument_list|,
name|len
operator|-
operator|(
name|cop
operator|-
name|buf
operator|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|MAXPOINTS
operator|-
literal|1
condition|)
name|i
operator|++
expr_stmt|;
comment|/* if too many points, forget some */
block|}
name|HGCurve
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* now, actually DO the curve */
block|}
end_block

begin_macro
name|line
argument_list|(
argument|x0
argument_list|,
argument|y0
argument_list|,
argument|x1
argument_list|,
argument|y1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This routine is called to draw a line from the point at (x0, y0) to (x1, y1).  * The line is drawn using a variation of   */
end_comment

begin_block
block|{
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|int
name|xinc
decl_stmt|,
name|yinc
decl_stmt|;
name|int
name|res1
decl_stmt|;
name|int
name|res2
decl_stmt|;
name|int
name|slope
decl_stmt|;
name|xinc
operator|=
literal|1
expr_stmt|;
name|yinc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|dx
operator|=
name|x1
operator|-
name|x0
operator|)
operator|<
literal|0
condition|)
block|{
name|xinc
operator|=
operator|-
literal|1
expr_stmt|;
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dy
operator|=
name|y1
operator|-
name|y0
operator|)
operator|<
literal|0
condition|)
block|{
name|yinc
operator|=
operator|-
literal|1
expr_stmt|;
name|dy
operator|=
operator|-
name|dy
expr_stmt|;
block|}
name|slope
operator|=
name|xinc
operator|*
name|yinc
expr_stmt|;
name|res1
operator|=
literal|0
expr_stmt|;
name|res2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dx
operator|>=
name|dy
condition|)
while|while
condition|(
name|x0
operator|!=
name|x1
condition|)
block|{
if|if
condition|(
operator|(
name|x0
operator|+
name|slope
operator|*
name|y0
operator|)
operator|&
name|linmod
condition|)
name|point
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res1
operator|>
name|res2
condition|)
block|{
name|res2
operator|+=
name|dx
operator|-
name|res1
expr_stmt|;
name|res1
operator|=
literal|0
expr_stmt|;
name|y0
operator|+=
name|yinc
expr_stmt|;
block|}
name|res1
operator|+=
name|dy
expr_stmt|;
name|x0
operator|+=
name|xinc
expr_stmt|;
block|}
else|else
while|while
condition|(
name|y0
operator|!=
name|y1
condition|)
block|{
if|if
condition|(
operator|(
name|x0
operator|+
name|slope
operator|*
name|y0
operator|)
operator|&
name|linmod
condition|)
name|point
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res1
operator|>
name|res2
condition|)
block|{
name|res2
operator|+=
name|dy
operator|-
name|res1
expr_stmt|;
name|res1
operator|=
literal|0
expr_stmt|;
name|x0
operator|+=
name|xinc
expr_stmt|;
block|}
name|res1
operator|+=
name|dx
expr_stmt|;
name|y0
operator|+=
name|yinc
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|x1
operator|+
name|slope
operator|*
name|y1
operator|)
operator|&
name|linmod
condition|)
name|point
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|HGArc
argument_list|(
name|cx
argument_list|,
name|cy
argument_list|,
name|px
argument_list|,
name|py
argument_list|,
name|angle
argument_list|)
specifier|register
name|int
name|cx
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|cy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|px
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|py
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|angle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This routine plots an arc centered about 'center' counter clockwise for  * the point 'cpoint' through 'angle' degrees.  If angle is 0, a full circle  * is drawn.  */
end_comment

begin_block
block|{
name|double
name|xs
decl_stmt|,
name|ys
decl_stmt|,
name|resolution
decl_stmt|,
name|epsilon
decl_stmt|,
name|degreesperpoint
decl_stmt|,
name|fullcircle
decl_stmt|;
name|double
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|extent
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|xs
operator|=
name|px
operator|-
name|cx
expr_stmt|;
name|ys
operator|=
name|py
operator|-
name|cy
expr_stmt|;
name|lastx
operator|=
name|cx
expr_stmt|;
name|lasty
operator|=
name|cy
expr_stmt|;
comment|/* calculate drawing parameters */
name|t1
operator|=
name|log10
argument_list|(
name|sqrt
argument_list|(
name|xs
operator|*
name|xs
operator|+
name|ys
operator|*
name|ys
argument_list|)
argument_list|)
operator|*
name|log2_10
expr_stmt|;
name|t1
operator|=
name|ceil
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|resolution
operator|=
name|pow
argument_list|(
literal|2.0
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|epsilon
operator|=
literal|1.0
operator|/
name|resolution
expr_stmt|;
name|fullcircle
operator|=
literal|2
operator|*
name|pi
operator|*
name|resolution
expr_stmt|;
name|fullcircle
operator|=
name|ceil
argument_list|(
name|fullcircle
argument_list|)
expr_stmt|;
name|degreesperpoint
operator|=
literal|360.0
operator|/
name|fullcircle
expr_stmt|;
if|if
condition|(
name|angle
operator|==
literal|0
condition|)
name|extent
operator|=
name|fullcircle
expr_stmt|;
else|else
name|extent
operator|=
name|angle
operator|/
name|degreesperpoint
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extent
condition|;
operator|++
name|i
control|)
block|{
name|xs
operator|+=
name|epsilon
operator|*
name|ys
expr_stmt|;
name|nx
operator|=
call|(
name|int
call|)
argument_list|(
name|xs
operator|+
name|cx
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|ys
operator|-=
name|epsilon
operator|*
name|xs
expr_stmt|;
name|ny
operator|=
call|(
name|int
call|)
argument_list|(
name|ys
operator|+
name|cy
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|RoundEnd
argument_list|(
name|nx
argument_list|,
name|ny
argument_list|,
call|(
name|int
call|)
argument_list|(
name|linethickness
operator|/
literal|2
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|lastx
operator|=
name|nx
expr_stmt|;
name|lasty
operator|=
name|ny
expr_stmt|;
block|}
comment|/* end for */
block|}
end_block

begin_comment
comment|/* end HGArc */
end_comment

begin_macro
name|RoundEnd
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|radius
argument_list|,
argument|filled
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|radius
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|filled
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indicates whether the circle is filled */
end_comment

begin_comment
comment|/* This routine plots a filled circle of the specified radius centered   * about (x, y).  */
end_comment

begin_block
block|{
name|double
name|xs
decl_stmt|,
name|ys
decl_stmt|,
name|epsilon
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|extent
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|int
name|cx
decl_stmt|,
name|cy
decl_stmt|;
if|if
condition|(
name|radius
operator|<
literal|1
condition|)
comment|/* too small to notice */
block|{
name|point
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
name|xs
operator|=
literal|0
expr_stmt|;
name|ys
operator|=
name|radius
expr_stmt|;
name|epsilon
operator|=
literal|1.0
operator|/
name|radius
expr_stmt|;
name|extent
operator|=
name|pi
operator|*
name|radius
operator|/
literal|2
expr_stmt|;
comment|/* 1/4 the circumference */
comment|/* Calculate the trajectory of the circle for 1/4 the circumference          * and mirror appropriately to get the other three quadrants.          */
name|point
argument_list|(
name|x
argument_list|,
name|y
operator|+
operator|(
operator|(
name|int
operator|)
name|ys
operator|)
argument_list|)
expr_stmt|;
comment|/* take care if end of arc missed by */
name|point
argument_list|(
name|x
argument_list|,
name|y
operator|-
operator|(
operator|(
name|int
operator|)
name|ys
operator|)
argument_list|)
expr_stmt|;
comment|/* below formulation                 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extent
condition|;
operator|++
name|i
control|)
block|{
comment|/* generate circumference */
name|xs
operator|+=
name|epsilon
operator|*
name|ys
expr_stmt|;
name|nx
operator|=
call|(
name|int
call|)
argument_list|(
name|xs
operator|+
name|x
operator|+
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|nx
operator|<
name|x
condition|)
name|nx
operator|=
name|x
expr_stmt|;
comment|/* 1st quadrant, should be positive */
name|ys
operator|-=
name|epsilon
operator|*
name|xs
expr_stmt|;
name|ny
operator|=
call|(
name|int
call|)
argument_list|(
name|ys
operator|+
name|y
operator|+
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|ny
operator|<
name|y
condition|)
name|ny
operator|=
name|y
expr_stmt|;
comment|/* 1st quadrant, should be positive */
if|if
condition|(
name|filled
operator|==
name|TRUE
condition|)
block|{
comment|/* fill from center */
name|cx
operator|=
name|x
expr_stmt|;
name|cy
operator|=
name|y
expr_stmt|;
block|}
else|else
block|{
comment|/* fill from perimeter only (no fill) */
name|cx
operator|=
name|nx
expr_stmt|;
name|cy
operator|=
name|ny
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
name|cx
init|;
name|j
operator|<=
name|nx
condition|;
operator|++
name|j
control|)
block|{
for|for
control|(
name|k
operator|=
name|cy
init|;
name|k
operator|<=
name|ny
condition|;
operator|++
name|k
control|)
block|{
name|point
argument_list|(
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|point
argument_list|(
name|j
argument_list|,
literal|2
operator|*
name|y
operator|-
name|k
argument_list|)
expr_stmt|;
name|point
argument_list|(
literal|2
operator|*
name|x
operator|-
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|point
argument_list|(
literal|2
operator|*
name|x
operator|-
name|j
argument_list|,
literal|2
operator|*
name|y
operator|-
name|k
argument_list|)
expr_stmt|;
block|}
comment|/* end for k */
block|}
comment|/* end for j */
empty_stmt|;
block|}
comment|/* end for i */
empty_stmt|;
block|}
end_block

begin_comment
comment|/* end RoundEnd */
end_comment

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|static
name|Paramaterize
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|h
argument_list|,
argument|n
argument_list|)
name|float
name|x
index|[
name|MAXPOINTS
index|]
operator|,
name|y
index|[
name|MAXPOINTS
index|]
operator|,
name|h
index|[
name|MAXPOINTS
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*     This routine calculates parameteric values for use in calculating  * curves.  The parametric values are returned in the array u.  The values  * are an approximation of cumulative arc lengths of the curve (uses cord  * length).  For additional information, see paper cited below.  */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|float
name|u
index|[
name|MAXPOINTS
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
operator|++
name|i
control|)
block|{
name|u
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|u
index|[
name|i
index|]
operator|+=
name|sqrt
argument_list|(
name|pow
argument_list|(
call|(
name|double
call|)
argument_list|(
name|x
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|x
index|[
name|j
index|]
argument_list|)
argument_list|,
operator|(
name|double
operator|)
literal|2.0
argument_list|)
operator|+
name|pow
argument_list|(
call|(
name|double
call|)
argument_list|(
name|y
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|y
index|[
name|j
index|]
argument_list|)
argument_list|,
operator|(
name|double
operator|)
literal|2.0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|h
index|[
name|i
index|]
operator|=
name|u
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|u
index|[
name|i
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end Paramaterize */
end_comment

begin_expr_stmt
specifier|static
name|PeriodicSpline
argument_list|(
argument|h
argument_list|,
argument|z
argument_list|,
argument|dz
argument_list|,
argument|d2z
argument_list|,
argument|d3z
argument_list|,
argument|npoints
argument_list|)
name|float
name|h
index|[
name|MAXPOINTS
index|]
operator|,
name|z
index|[
name|MAXPOINTS
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Point list and paramaterization  */
end_comment

begin_decl_stmt
name|float
name|dz
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to return the 1st derivative */
end_comment

begin_decl_stmt
name|float
name|d2z
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2nd and 3rd derivatives */
end_comment

begin_decl_stmt
name|int
name|npoints
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of valid points */
end_comment

begin_comment
comment|/*  *     This routine solves for the cubic polynomial to fit a spline  * curve to the the points  specified by the list of values.  * The Curve generated is periodic.  The alogrithms for this   * curve are from the "Spline Curve Techniques" paper cited below.  */
end_comment

begin_block
block|{
name|float
name|d
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|deltaz
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|a
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|b
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|c
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|r
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|s
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* step 1 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|h
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|deltaz
index|[
name|i
index|]
operator|=
operator|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
expr_stmt|;
else|else
name|deltaz
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|h
index|[
literal|0
index|]
operator|=
name|h
index|[
name|npoints
operator|-
literal|1
index|]
expr_stmt|;
name|deltaz
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
name|npoints
operator|-
literal|1
index|]
expr_stmt|;
comment|/* step 2 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|deltaz
index|[
name|i
index|]
expr_stmt|;
block|}
name|d
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
literal|1
index|]
operator|-
name|deltaz
index|[
literal|0
index|]
expr_stmt|;
comment|/* step 3a */
name|a
index|[
literal|1
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
literal|0
index|]
operator|+
name|h
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
name|d
index|[
literal|0
index|]
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
name|h
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|a
index|[
name|i
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|h
index|[
name|i
index|]
operator|)
operator|-
name|pow
argument_list|(
operator|(
name|double
operator|)
name|h
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
operator|(
name|double
operator|)
literal|2.0
argument_list|)
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|b
index|[
name|i
index|]
operator|=
name|d
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|h
index|[
name|i
operator|-
literal|1
index|]
operator|*
name|b
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|c
index|[
name|i
index|]
operator|=
operator|-
name|h
index|[
name|i
operator|-
literal|1
index|]
operator|*
name|c
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* step 3b */
name|r
index|[
name|npoints
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|s
index|[
name|npoints
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|npoints
operator|-
literal|2
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|r
index|[
name|i
index|]
operator|=
operator|-
operator|(
name|h
index|[
name|i
index|]
operator|*
name|r
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|c
index|[
name|i
index|]
operator|)
operator|/
name|a
index|[
name|i
index|]
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
operator|(
literal|6
operator|*
name|b
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
name|s
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
name|a
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* step 4 */
name|d2z
index|[
name|npoints
operator|-
literal|1
index|]
operator|=
operator|(
literal|6
operator|*
name|d
index|[
name|npoints
operator|-
literal|2
index|]
operator|-
name|h
index|[
literal|0
index|]
operator|*
name|s
index|[
literal|1
index|]
operator|-
name|h
index|[
name|npoints
operator|-
literal|1
index|]
operator|*
name|s
index|[
name|npoints
operator|-
literal|2
index|]
operator|)
operator|/
operator|(
name|h
index|[
literal|0
index|]
operator|*
name|r
index|[
literal|1
index|]
operator|+
name|h
index|[
name|npoints
operator|-
literal|1
index|]
operator|*
name|r
index|[
name|npoints
operator|-
literal|2
index|]
operator|+
literal|2
operator|*
operator|(
name|h
index|[
name|npoints
operator|-
literal|2
index|]
operator|+
name|h
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d2z
index|[
name|i
index|]
operator|=
name|r
index|[
name|i
index|]
operator|*
name|d2z
index|[
name|npoints
operator|-
literal|1
index|]
operator|+
name|s
index|[
name|i
index|]
expr_stmt|;
block|}
name|d2z
index|[
name|npoints
index|]
operator|=
name|d2z
index|[
literal|1
index|]
expr_stmt|;
comment|/* step 5 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
name|dz
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
operator|(
literal|2
operator|*
name|d2z
index|[
name|i
index|]
operator|+
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
literal|6
expr_stmt|;
if|if
condition|(
name|h
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|d3z
index|[
name|i
index|]
operator|=
operator|(
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|d2z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
expr_stmt|;
else|else
name|d3z
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end PeriodicSpline */
end_comment

begin_expr_stmt
specifier|static
name|NaturalEndSpline
argument_list|(
argument|h
argument_list|,
argument|z
argument_list|,
argument|dz
argument_list|,
argument|d2z
argument_list|,
argument|d3z
argument_list|,
argument|npoints
argument_list|)
name|float
name|h
index|[
name|MAXPOINTS
index|]
operator|,
name|z
index|[
name|MAXPOINTS
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Point list and parameterization */
end_comment

begin_decl_stmt
name|float
name|dz
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to return the 1st derivative */
end_comment

begin_decl_stmt
name|float
name|d2z
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2nd and 3rd derivatives */
end_comment

begin_decl_stmt
name|int
name|npoints
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of valid points */
end_comment

begin_comment
comment|/*  *     This routine solves for the cubic polynomial to fit a spline  * curve the the points  specified by the list of values.  The alogrithms for  * this curve are from the "Spline Curve Techniques" paper cited below.  */
end_comment

begin_block
block|{
name|float
name|d
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|deltaz
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|a
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|b
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* step 1 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|h
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|deltaz
index|[
name|i
index|]
operator|=
operator|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
expr_stmt|;
else|else
name|deltaz
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|deltaz
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
name|npoints
operator|-
literal|1
index|]
expr_stmt|;
comment|/* step 2 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|deltaz
index|[
name|i
index|]
expr_stmt|;
block|}
name|d
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
literal|1
index|]
operator|-
name|deltaz
index|[
literal|0
index|]
expr_stmt|;
comment|/* step 3 */
name|a
index|[
literal|0
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
literal|2
index|]
operator|+
name|h
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|d
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|a
index|[
name|i
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|h
index|[
name|i
operator|+
literal|2
index|]
operator|)
operator|-
name|pow
argument_list|(
operator|(
name|double
operator|)
name|h
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|(
name|double
operator|)
literal|2.0
argument_list|)
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|b
index|[
name|i
index|]
operator|=
name|d
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|h
index|[
name|i
operator|+
literal|1
index|]
operator|*
name|b
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* step 4 */
name|d2z
index|[
name|npoints
index|]
operator|=
name|d2z
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|npoints
operator|-
literal|1
init|;
name|i
operator|>
literal|1
condition|;
operator|--
name|i
control|)
block|{
name|d2z
index|[
name|i
index|]
operator|=
operator|(
literal|6
operator|*
name|b
index|[
name|i
operator|-
literal|2
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
name|a
index|[
name|i
operator|-
literal|2
index|]
expr_stmt|;
block|}
comment|/* step 5 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
name|dz
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
operator|(
literal|2
operator|*
name|d2z
index|[
name|i
index|]
operator|+
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
literal|6
expr_stmt|;
if|if
condition|(
name|h
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|d3z
index|[
name|i
index|]
operator|=
operator|(
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|d2z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
expr_stmt|;
else|else
name|d3z
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end NaturalEndSpline */
end_comment

begin_define
define|#
directive|define
name|PointsPerInterval
value|32
end_define

begin_macro
name|HGCurve
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|numpoints
argument_list|)
end_macro

begin_decl_stmt
name|float
name|x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numpoints
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *    This routine generates a smooth curve through a set of points.  The   * method used is the parametric spline curve on unit knot mesh described  * in "Spline Curve Techniques" by Patrick Baudelaire, Robert Flegal, and   * Robert Sproull -- Xerox Parc.  */
end_comment

begin_block
block|{
name|float
name|h
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|dx
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|dy
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|d2x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d2y
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|t
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|xinter
decl_stmt|,
name|yinter
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|lx
decl_stmt|,
name|ly
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|lx
operator|=
operator|(
name|int
operator|)
name|x
index|[
literal|0
index|]
expr_stmt|;
name|ly
operator|=
operator|(
name|int
operator|)
name|y
index|[
literal|0
index|]
expr_stmt|;
comment|/* Solve for derivatives of the curve at each point                * separately for x and y (parametric). 	      */
name|Paramaterize
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|h
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
comment|/* closed curve */
if|if
condition|(
operator|(
name|x
index|[
literal|0
index|]
operator|==
name|x
index|[
name|numpoints
index|]
operator|)
operator|&&
operator|(
name|y
index|[
literal|0
index|]
operator|==
name|y
index|[
name|numpoints
index|]
operator|)
condition|)
block|{
name|PeriodicSpline
argument_list|(
name|h
argument_list|,
name|x
argument_list|,
name|dx
argument_list|,
name|d2x
argument_list|,
name|d3x
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
name|PeriodicSpline
argument_list|(
name|h
argument_list|,
name|y
argument_list|,
name|dy
argument_list|,
name|d2y
argument_list|,
name|d3y
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NaturalEndSpline
argument_list|(
name|h
argument_list|,
name|x
argument_list|,
name|dx
argument_list|,
name|d2x
argument_list|,
name|d3x
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
name|NaturalEndSpline
argument_list|(
name|h
argument_list|,
name|y
argument_list|,
name|dy
argument_list|,
name|d2y
argument_list|,
name|d3y
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
block|}
comment|/* generate the curve using the above information and  	       * PointsPerInterval vectors between each specified knot. 	       */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|numpoints
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|(
name|x
index|[
name|j
index|]
operator|==
name|x
index|[
name|j
operator|+
literal|1
index|]
operator|)
operator|&&
operator|(
name|y
index|[
name|j
index|]
operator|==
name|y
index|[
name|j
operator|+
literal|1
index|]
operator|)
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|PointsPerInterval
condition|;
operator|++
name|k
control|)
block|{
name|t
operator|=
operator|(
name|float
operator|)
name|k
operator|*
name|h
index|[
name|j
index|]
operator|/
operator|(
name|float
operator|)
name|PointsPerInterval
expr_stmt|;
name|t2
operator|=
name|t
operator|*
name|t
expr_stmt|;
name|t3
operator|=
name|t
operator|*
name|t
operator|*
name|t
expr_stmt|;
name|xinter
operator|=
name|x
index|[
name|j
index|]
operator|+
name|t
operator|*
name|dx
index|[
name|j
index|]
operator|+
name|t2
operator|*
name|d2x
index|[
name|j
index|]
operator|/
literal|2
operator|+
name|t3
operator|*
name|d3x
index|[
name|j
index|]
operator|/
literal|6
expr_stmt|;
name|nx
operator|=
operator|(
name|int
operator|)
name|xinter
expr_stmt|;
name|yinter
operator|=
name|y
index|[
name|j
index|]
operator|+
name|t
operator|*
name|dy
index|[
name|j
index|]
operator|+
name|t2
operator|*
name|d2y
index|[
name|j
index|]
operator|/
literal|2
operator|+
name|t3
operator|*
name|d3y
index|[
name|j
index|]
operator|/
literal|6
expr_stmt|;
name|ny
operator|=
operator|(
name|int
operator|)
name|yinter
expr_stmt|;
name|HGtline
argument_list|(
name|lx
argument_list|,
name|ly
argument_list|,
name|nx
argument_list|,
name|ny
argument_list|)
expr_stmt|;
name|lx
operator|=
name|nx
expr_stmt|;
name|ly
operator|=
name|ny
expr_stmt|;
block|}
comment|/* end for k */
block|}
comment|/* end for j */
block|}
end_block

begin_comment
comment|/* end HGCurve */
end_comment

begin_expr_stmt
name|HGtline
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|)
specifier|register
name|int
name|x0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|y0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|x1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|y1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine calls line repeatedly until the line is   * of the proper thickness.  */
end_comment

begin_block
block|{
name|double
name|morelen
decl_stmt|,
name|theta
decl_stmt|,
name|wx
decl_stmt|,
name|wy
decl_stmt|,
name|xx
decl_stmt|,
name|xy
decl_stmt|;
name|int
name|xs
decl_stmt|,
name|xe
decl_stmt|,
name|ys
decl_stmt|,
name|ye
decl_stmt|;
name|int
name|addln
decl_stmt|,
name|j
decl_stmt|,
name|xdir
decl_stmt|,
name|ydir
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|xdir
operator|=
name|ydir
operator|=
literal|1
expr_stmt|;
name|dx
operator|=
name|x1
operator|-
name|x0
expr_stmt|;
comment|/* calculate direction to move to  */
name|dy
operator|=
name|y1
operator|-
name|y0
expr_stmt|;
comment|/* move to draw additional lines if needed */
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
comment|/* for extra thickness */
block|{
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
name|xdir
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dy
operator|<
literal|0
condition|)
block|{
name|dy
operator|=
operator|-
name|dy
expr_stmt|;
name|ydir
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|morelen
operator|=
name|linethickness
operator|/
literal|2
expr_stmt|;
name|addln
operator|=
operator|(
name|int
operator|)
name|morelen
expr_stmt|;
name|RoundEnd
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
operator|(
name|int
operator|)
name|morelen
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* add rounded end */
for|for
control|(
name|j
operator|=
operator|(
operator|-
name|addln
operator|)
init|;
name|j
operator|<=
name|addln
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|dy
operator|==
literal|0
condition|)
block|{
name|xs
operator|=
name|x0
expr_stmt|;
name|xe
operator|=
name|x1
expr_stmt|;
name|ys
operator|=
name|ye
operator|=
name|y0
operator|+
name|j
expr_stmt|;
block|}
if|if
condition|(
name|dx
operator|==
literal|0
condition|)
block|{
name|ys
operator|=
name|y0
expr_stmt|;
name|ye
operator|=
name|y1
expr_stmt|;
name|xs
operator|=
name|xe
operator|=
name|x0
operator|+
name|j
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dx
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|dy
operator|!=
literal|0
operator|)
condition|)
block|{
name|theta
operator|=
name|pi
operator|/
literal|2.0
operator|-
name|atan
argument_list|(
operator|(
operator|(
name|double
operator|)
name|dx
operator|)
operator|/
operator|(
operator|(
name|double
operator|)
name|dy
operator|)
argument_list|)
expr_stmt|;
name|wx
operator|=
name|j
operator|*
name|sin
argument_list|(
name|theta
argument_list|)
expr_stmt|;
name|wy
operator|=
name|j
operator|*
name|cos
argument_list|(
name|theta
argument_list|)
expr_stmt|;
name|xs
operator|=
name|x0
operator|+
name|wx
operator|*
name|xdir
expr_stmt|;
name|ys
operator|=
name|y0
operator|-
name|wy
operator|*
name|ydir
expr_stmt|;
name|xe
operator|=
name|x1
operator|+
name|wx
operator|*
name|xdir
expr_stmt|;
name|ye
operator|=
name|y1
operator|-
name|wy
operator|*
name|ydir
expr_stmt|;
block|}
name|line
argument_list|(
name|xs
argument_list|,
name|ys
argument_list|,
name|xe
argument_list|,
name|ye
argument_list|)
expr_stmt|;
block|}
comment|/* end for */
name|RoundEnd
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|int
operator|)
name|morelen
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* add rounded end */
block|}
end_block

begin_comment
comment|/* end HGtline */
end_comment

end_unit

