begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* graph.c	1.7	83/07/09  *  *	This file contains the functions for producing the graphics  *   images in the varian/versatec drivers for ditroff.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_comment
comment|/* imports from dver.c */
end_comment

begin_define
define|#
directive|define
name|hmot
parameter_list|(
name|n
parameter_list|)
value|hpos += n;
end_define

begin_define
define|#
directive|define
name|vmot
parameter_list|(
name|n
parameter_list|)
value|vgoto(vpos + n);
end_define

begin_decl_stmt
specifier|extern
name|int
name|hpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|vpos
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern vgoto(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern point(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|MAXPOINTS
value|200
end_define

begin_comment
comment|/* number of points legal for a curve */
end_comment

begin_define
define|#
directive|define
name|SOLID
value|-1
end_define

begin_comment
comment|/* line styles:  these are used as bit masks to */
end_comment

begin_define
define|#
directive|define
name|DOTTED
value|004
end_define

begin_comment
comment|/* create the right style lines. */
end_comment

begin_define
define|#
directive|define
name|DASHED
value|020
end_define

begin_define
define|#
directive|define
name|DOTDASHED
value|024
end_define

begin_define
define|#
directive|define
name|LONGDASHED
value|074
end_define

begin_comment
comment|/* constants... */
end_comment

begin_define
define|#
directive|define
name|pi
value|3.14159265358979324
end_define

begin_define
define|#
directive|define
name|log2_10
value|3.3219280948873623
end_define

begin_decl_stmt
name|int
name|linethickness
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pixels wide to make lines */
end_comment

begin_decl_stmt
name|int
name|linmod
init|=
name|SOLID
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type of line (SOLID, DOTTED, DASHED...) */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------  * Routine:	drawline (horizontal_motion, vertical_motion)  *  * Results:	Draws a line of "linethickness" width and "linmod" style  *		from current (hpos, vpos) to (hpos + dh, vpos + dv).  *  * Side Efct:	Resulting position is at end of line (hpos + dh, vpos + dv)  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
name|drawline
argument_list|(
name|dh
argument_list|,
name|dv
argument_list|)
specifier|register
name|int
name|dh
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|dv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HGtline
argument_list|(
name|hpos
argument_list|,
name|vpos
argument_list|,
name|hpos
operator|+
name|dh
argument_list|,
name|vpos
operator|+
name|dv
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|dh
argument_list|)
expr_stmt|;
comment|/* new position is at */
name|vmot
argument_list|(
name|dv
argument_list|)
expr_stmt|;
comment|/* the end of the line */
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  * Routine:	drawcirc (diameter)  *  * Results:	Draws a circle with leftmost point at current (hpos, vpos)  *		with the given diameter d.  *  * Side Efct:	Resulting position is at (hpos + diameter, vpos)  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
name|drawcirc
argument_list|(
name|d
argument_list|)
specifier|register
name|int
name|d
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* 0.0 is the angle to sweep the arc: = full circle */
name|HGArc
argument_list|(
name|hpos
operator|+
name|d
operator|/
literal|2
argument_list|,
name|vpos
argument_list|,
name|hpos
argument_list|,
name|vpos
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* new postion is the right of the circle */
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  * Routine:	drawellip (horizontal_diameter, vertical_diameter)  *  * Results:	Draws regular ellipses given the major "diameters."  It does  *		so by drawing many small lines, every other pixel.  The ellipse  *		formula:  ((x-x0)/hrad)**2 + ((y-y0)/vrad)**2 = 1 is used,  *		converting to:  y = y0 +- vrad * sqrt(1 - ((x-x0)/hrad)**2).  *		The line segments are duplicated (mirrored) on either side of  *		the horizontal "diameter".  *  * Side Efct:	Resulting position is at (hpos + hd, vpos).  *  * Bugs:	Odd numbered horizontal axes are rounded up to even numbers.  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
name|drawellip
argument_list|(
name|hd
argument_list|,
name|vd
argument_list|)
specifier|register
name|int
name|hd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|vd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|bx
decl_stmt|;
comment|/* multiplicative x factor */
specifier|register
name|int
name|x
decl_stmt|;
comment|/* x position drawing to */
specifier|register
name|int
name|yk
decl_stmt|;
comment|/* the square-root term */
specifier|register
name|int
name|y
decl_stmt|;
comment|/* y position drawing to */
name|double
name|k1
decl_stmt|;
comment|/* k? are constants depending on parameters */
name|int
name|k2
decl_stmt|,
name|oldy1
decl_stmt|,
name|oldy2
decl_stmt|;
comment|/* oldy? are last y points drawn to */
name|hd
operator|=
literal|2
operator|*
operator|(
operator|(
name|hd
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
comment|/* don't accept odd diameters */
name|bx
operator|=
literal|4
operator|*
operator|(
name|hpos
operator|+
name|hd
operator|)
expr_stmt|;
name|x
operator|=
name|hpos
expr_stmt|;
name|k1
operator|=
name|vd
operator|/
operator|(
literal|2.0
operator|*
name|hd
operator|)
expr_stmt|;
name|k2
operator|=
name|hd
operator|*
name|hd
operator|-
literal|4
operator|*
operator|(
name|hpos
operator|+
name|hd
operator|/
literal|2
operator|)
operator|*
operator|(
name|hpos
operator|+
name|hd
operator|/
literal|2
operator|)
expr_stmt|;
name|oldy1
operator|=
name|vpos
expr_stmt|;
name|oldy2
operator|=
name|vpos
expr_stmt|;
name|hmot
argument_list|(
name|hd
argument_list|)
expr_stmt|;
comment|/* end position is the right-hand side of the ellipse */
do|do
block|{
name|yk
operator|=
call|(
name|int
call|)
argument_list|(
name|k1
operator|*
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|k2
operator|+
operator|(
name|bx
operator|-=
literal|8
operator|)
operator|*
operator|(
name|x
operator|+=
literal|2
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|HGtline
argument_list|(
name|x
operator|-
literal|2
argument_list|,
name|oldy1
argument_list|,
name|x
argument_list|,
name|y
operator|=
name|vpos
operator|+
name|yk
argument_list|)
expr_stmt|;
comment|/* top half of ellipse */
name|oldy1
operator|=
name|y
expr_stmt|;
name|HGtline
argument_list|(
name|x
operator|-
literal|2
argument_list|,
name|oldy2
argument_list|,
name|x
argument_list|,
name|y
operator|=
name|vpos
operator|-
name|yk
argument_list|)
expr_stmt|;
comment|/* bottom half of ellipse */
name|oldy2
operator|=
name|y
expr_stmt|;
block|}
do|while
condition|(
name|hd
operator|-=
literal|2
condition|)
do|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  * Routine:	drawarc (xcenter, ycenter, xpoint, ypoint)  *  * Results:	Draws an arc starting at current (hpos, vpos).  Center is  *		at (hpos + cdh, vpos + cdv) and the terminating point is  *		at<center> + (pdh, pdv).  The angle between the lines  *		formed by the starting, ending, and center points is figured  *		first, then the points and angle are sent to HGArc for the  *		drawing.  *  * Side Efct:	Resulting position is at the last point of the arc.  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
name|drawarc
argument_list|(
name|cdh
argument_list|,
name|cdv
argument_list|,
name|pdh
argument_list|,
name|pdv
argument_list|)
specifier|register
name|int
name|cdh
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|cdv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|pdh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|pdv
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|double
name|angle
decl_stmt|;
comment|/* figure angle from the three points...*/
comment|/* and convert (and round) to degrees */
name|angle
operator|=
operator|(
name|atan2
argument_list|(
operator|(
name|double
operator|)
name|pdh
argument_list|,
operator|(
name|double
operator|)
name|pdv
argument_list|)
operator|-
name|atan2
argument_list|(
operator|(
name|double
operator|)
operator|-
name|cdh
argument_list|,
operator|(
name|double
operator|)
operator|-
name|cdv
argument_list|)
operator|)
operator|*
literal|180.0
operator|/
name|pi
expr_stmt|;
comment|/* "normalize" and round */
name|angle
operator|+=
operator|(
name|angle
operator|<
literal|0.0
operator|)
condition|?
literal|360.5
else|:
literal|0.5
expr_stmt|;
name|HGArc
argument_list|(
name|hpos
operator|+
name|cdh
argument_list|,
name|vpos
operator|+
name|cdv
argument_list|,
name|hpos
argument_list|,
name|vpos
argument_list|,
operator|(
name|int
operator|)
name|angle
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|cdh
operator|+
name|pdh
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|cdv
operator|+
name|pdv
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  * Routine:	drawwig (character_buffer, file_pointer, type_flag)  *  * Results:	Given the starting position, the motion list in buf, and any  *		extra characters from fp (terminated by a \n), drawwig sets  *		up a point list to make a spline from.  If "pic" is set picurve  *		is called to draw the curve in pic style; else it calls HGCurve  *		for the gremlin-style curve.  *  * Side Efct:	Resulting position is reached from adding successive motions  *		to the current position.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|drawwig
argument_list|(
argument|buf
argument_list|,
argument|fp
argument_list|,
argument|pic
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pic
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
comment|/* length of the string in "buf" */
specifier|register
name|int
name|npts
init|=
literal|2
decl_stmt|;
comment|/* point list index */
specifier|register
name|char
modifier|*
name|ptr
init|=
name|buf
decl_stmt|;
comment|/* "walking" pointer into buf */
name|int
name|x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
comment|/* point list */
while|while
condition|(
operator|*
name|ptr
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/* skip any leading spaces */
name|x
index|[
literal|1
index|]
operator|=
name|hpos
expr_stmt|;
comment|/* the curve starts at the */
name|y
index|[
literal|1
index|]
operator|=
name|vpos
expr_stmt|;
comment|/* current position */
while|while
condition|(
operator|*
name|ptr
operator|!=
literal|'\n'
condition|)
block|{
comment|/* curve commands end with a '\n' */
name|hmot
argument_list|(
name|atoi
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* convert motion to curve points */
name|x
index|[
name|npts
index|]
operator|=
name|hpos
expr_stmt|;
comment|/* and remember them */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|ptr
argument_list|)
condition|)
empty_stmt|;
comment|/* skip number*/
while|while
condition|(
operator|*
operator|++
name|ptr
operator|==
literal|' '
condition|)
empty_stmt|;
comment|/* skip spaces 'tween numbers */
name|vmot
argument_list|(
name|atoi
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|y
index|[
name|npts
index|]
operator|=
name|vpos
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|ptr
argument_list|)
condition|)
empty_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/* if the amount we read wasn't the */
comment|/*    whole thing, read some more in */
if|if
condition|(
name|len
operator|-
operator|(
name|ptr
operator|-
name|buf
operator|)
operator|<
literal|15
operator|&&
operator|*
operator|(
name|buf
operator|+
name|len
operator|-
literal|1
operator|)
operator|!=
literal|'\n'
condition|)
block|{
name|char
modifier|*
name|cop
init|=
name|buf
decl_stmt|;
while|while
condition|(
operator|*
name|cop
operator|++
operator|=
operator|*
name|ptr
operator|++
condition|)
empty_stmt|;
comment|/* copy what's left to the beginning */
name|fgets
argument_list|(
operator|(
name|cop
operator|-
literal|1
operator|)
argument_list|,
name|len
operator|-
operator|(
name|cop
operator|-
name|buf
operator|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|npts
operator|<
name|MAXPOINTS
operator|-
literal|1
condition|)
comment|/* if too many points, forget some */
name|npts
operator|++
expr_stmt|;
block|}
name|npts
operator|--
expr_stmt|;
comment|/* npts must point to the last coordinate in x and y */
comment|/* now, actually DO the curve */
if|if
condition|(
name|pic
condition|)
name|picurve
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|npts
argument_list|)
expr_stmt|;
else|else
name|HGCurve
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|npts
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	drawthick (thickness)  |  | Results:	sets the variable "linethickness" to the given size.  |		NO motion is involved.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|drawthick
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|linethickness
operator|=
name|s
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	drawstyle (style_bit_map)  |  | Results:	sets the variable "linmod" to the given bit map.  |		NO motion is involved.  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|drawstyle
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|linmod
operator|=
name|s
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  * Routine:	picurve (xpoints, ypoints, num_of_points)  *  * Results:	Draws a curve delimited by (not through) the line segments  *		traced by (xpoints, ypoints) point list.  This is the "Pic"  *		style curve.  *  * Bugs:	does nothing yet....  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|picurve
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|npts
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|npts
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* line segment traverser */
specifier|register
name|int
name|nseg
decl_stmt|;
comment|/* effective resolution for each curve */
specifier|register
name|float
name|w
decl_stmt|;
comment|/* position factor */
specifier|register
name|int
name|xp
decl_stmt|;
comment|/* current point (and intermediary) */
specifier|register
name|int
name|yp
decl_stmt|;
name|int
name|pxp
decl_stmt|,
name|pyp
decl_stmt|;
comment|/* previous point (to make lines from) */
name|float
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
comment|/* calculation temps */
name|int
name|j
decl_stmt|;
comment|/* inner curve segment traverser */
if|if
condition|(
name|x
index|[
literal|1
index|]
operator|==
name|x
index|[
name|npts
index|]
operator|&&
name|y
index|[
literal|1
index|]
operator|==
name|y
index|[
name|npts
index|]
condition|)
block|{
name|x
index|[
literal|0
index|]
operator|=
name|x
index|[
name|npts
operator|-
literal|1
index|]
expr_stmt|;
comment|/* if the lines' ends meet, make */
name|y
index|[
literal|0
index|]
operator|=
name|y
index|[
name|npts
operator|-
literal|1
index|]
expr_stmt|;
comment|/* sure the curve meets */
name|x
index|[
name|npts
operator|+
literal|1
index|]
operator|=
name|x
index|[
literal|2
index|]
expr_stmt|;
name|y
index|[
name|npts
operator|+
literal|1
index|]
operator|=
name|y
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* otherwise, make the ends of the */
name|x
index|[
literal|0
index|]
operator|=
name|x
index|[
literal|1
index|]
expr_stmt|;
comment|/* curve touch the ending points of */
name|y
index|[
literal|0
index|]
operator|=
name|y
index|[
literal|1
index|]
expr_stmt|;
comment|/* the line segments */
name|x
index|[
name|npts
operator|+
literal|1
index|]
operator|=
name|x
index|[
name|npts
index|]
expr_stmt|;
name|y
index|[
name|npts
operator|+
literal|1
index|]
operator|=
name|y
index|[
name|npts
index|]
expr_stmt|;
block|}
name|pxp
operator|=
operator|(
name|x
index|[
literal|0
index|]
operator|+
name|x
index|[
literal|1
index|]
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* make the last point pointers */
name|pyp
operator|=
operator|(
name|y
index|[
literal|0
index|]
operator|+
name|y
index|[
literal|1
index|]
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* point to the start of the 1st line */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npts
condition|;
name|i
operator|++
control|)
block|{
comment|/* traverse the line segments */
name|xp
operator|=
name|x
index|[
name|i
index|]
operator|-
name|x
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|yp
operator|=
name|y
index|[
name|i
index|]
operator|-
name|y
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|nseg
operator|=
operator|(
name|int
operator|)
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|xp
operator|*
name|xp
operator|+
name|yp
operator|*
name|yp
argument_list|)
argument_list|)
expr_stmt|;
name|xp
operator|=
name|x
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|x
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|yp
operator|=
name|y
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|y
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
comment|/* "nseg" is the number of line */
comment|/* segments that will be drawn for */
comment|/* each curve segment.  ">> 3" is */
comment|/* dropping the resolution ( == / 8) */
name|nseg
operator|=
operator|(
name|nseg
operator|+
operator|(
name|int
operator|)
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|xp
operator|*
name|xp
operator|+
name|yp
operator|*
name|yp
argument_list|)
argument_list|)
operator|)
operator|>>
literal|3
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|nseg
condition|;
name|j
operator|++
control|)
block|{
name|w
operator|=
operator|(
name|float
operator|)
name|j
operator|/
operator|(
name|float
operator|)
name|nseg
expr_stmt|;
name|t1
operator|=
literal|0.5
operator|*
name|w
operator|*
name|w
expr_stmt|;
name|w
operator|-=
literal|0.5
expr_stmt|;
name|t2
operator|=
literal|0.75
operator|-
name|w
operator|*
name|w
expr_stmt|;
name|w
operator|-=
literal|0.5
expr_stmt|;
name|t3
operator|=
literal|0.5
operator|*
name|w
operator|*
name|w
expr_stmt|;
name|xp
operator|=
name|t1
operator|*
name|x
index|[
name|i
operator|+
literal|2
index|]
operator|+
name|t2
operator|*
name|x
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|t3
operator|*
name|x
index|[
name|i
index|]
operator|+
literal|0.5
expr_stmt|;
name|yp
operator|=
name|t1
operator|*
name|y
index|[
name|i
operator|+
literal|2
index|]
operator|+
name|t2
operator|*
name|y
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|t3
operator|*
name|y
index|[
name|i
index|]
operator|+
literal|0.5
expr_stmt|;
name|HGtline
argument_list|(
name|pxp
argument_list|,
name|pyp
argument_list|,
name|xp
argument_list|,
name|yp
argument_list|)
expr_stmt|;
name|pxp
operator|=
name|xp
expr_stmt|;
name|pyp
operator|=
name|yp
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  * Routine:	line (xstart, ystart, xend, yend)  *  * Results:	Draws a one-pixel wide line from (x0, y0) to  *		(x1, y1) using point(x,y) to place the dots.  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
name|line
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|)
specifier|register
name|int
name|x0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|y0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|x1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|y1
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|dx
decl_stmt|;
specifier|register
name|int
name|dy
decl_stmt|;
specifier|register
name|int
name|res1
decl_stmt|;
name|int
name|res2
decl_stmt|;
name|int
name|xinc
decl_stmt|;
name|int
name|yinc
decl_stmt|;
name|int
name|slope
decl_stmt|;
name|xinc
operator|=
literal|1
expr_stmt|;
name|yinc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|dx
operator|=
name|x1
operator|-
name|x0
operator|)
operator|<
literal|0
condition|)
block|{
name|xinc
operator|=
operator|-
literal|1
expr_stmt|;
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dy
operator|=
name|y1
operator|-
name|y0
operator|)
operator|<
literal|0
condition|)
block|{
name|yinc
operator|=
operator|-
literal|1
expr_stmt|;
name|dy
operator|=
operator|-
name|dy
expr_stmt|;
block|}
name|slope
operator|=
name|xinc
operator|*
name|yinc
expr_stmt|;
name|res1
operator|=
literal|0
expr_stmt|;
name|res2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dx
operator|>=
name|dy
condition|)
while|while
condition|(
name|x0
operator|!=
name|x1
condition|)
block|{
if|if
condition|(
operator|(
name|x0
operator|+
name|slope
operator|*
name|y0
operator|)
operator|&
name|linmod
condition|)
name|point
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res1
operator|>
name|res2
condition|)
block|{
name|res2
operator|+=
name|dx
operator|-
name|res1
expr_stmt|;
name|res1
operator|=
literal|0
expr_stmt|;
name|y0
operator|+=
name|yinc
expr_stmt|;
block|}
name|res1
operator|+=
name|dy
expr_stmt|;
name|x0
operator|+=
name|xinc
expr_stmt|;
block|}
else|else
while|while
condition|(
name|y0
operator|!=
name|y1
condition|)
block|{
if|if
condition|(
operator|(
name|x0
operator|+
name|slope
operator|*
name|y0
operator|)
operator|&
name|linmod
condition|)
name|point
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res1
operator|>
name|res2
condition|)
block|{
name|res2
operator|+=
name|dy
operator|-
name|res1
expr_stmt|;
name|res1
operator|=
literal|0
expr_stmt|;
name|x0
operator|+=
name|xinc
expr_stmt|;
block|}
name|res1
operator|+=
name|dx
expr_stmt|;
name|y0
operator|+=
name|yinc
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|x1
operator|+
name|slope
operator|*
name|y1
operator|)
operator|&
name|linmod
condition|)
name|point
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------  * Routine:	HGArc (xcenter, ycenter, xstart, ystart, angle)  *  * Results:	This routine plots an arc centered about (cx, cy) counter  *		clockwise starting from the point (px, py) through 'angle'  *		degrees.  If angle is 0, a full circle is drawn.  *		It does so by calling RoundEnd (fat point maker) for points  *		along the circle with density depending on the circle's size.  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
name|HGArc
argument_list|(
name|cx
argument_list|,
name|cy
argument_list|,
name|px
argument_list|,
name|py
argument_list|,
name|angle
argument_list|)
specifier|register
name|int
name|cx
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|cy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|px
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|py
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|angle
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|xs
decl_stmt|,
name|ys
decl_stmt|,
name|resolution
decl_stmt|,
name|epsilon
decl_stmt|,
name|degreesperpoint
decl_stmt|,
name|fullcircle
decl_stmt|;
name|double
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|extent
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|xs
operator|=
name|px
operator|-
name|cx
expr_stmt|;
name|ys
operator|=
name|py
operator|-
name|cy
expr_stmt|;
comment|/* calculate drawing parameters */
name|t1
operator|=
name|log10
argument_list|(
name|sqrt
argument_list|(
name|xs
operator|*
name|xs
operator|+
name|ys
operator|*
name|ys
argument_list|)
argument_list|)
operator|*
name|log2_10
expr_stmt|;
name|t1
operator|=
name|ceil
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|resolution
operator|=
name|pow
argument_list|(
literal|2.0
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|epsilon
operator|=
literal|1.0
operator|/
name|resolution
expr_stmt|;
name|fullcircle
operator|=
literal|2
operator|*
name|pi
operator|*
name|resolution
expr_stmt|;
name|fullcircle
operator|=
name|ceil
argument_list|(
name|fullcircle
argument_list|)
expr_stmt|;
name|degreesperpoint
operator|=
literal|360.0
operator|/
name|fullcircle
expr_stmt|;
if|if
condition|(
name|angle
operator|==
literal|0
condition|)
name|extent
operator|=
name|fullcircle
expr_stmt|;
else|else
name|extent
operator|=
name|angle
operator|/
name|degreesperpoint
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extent
condition|;
operator|++
name|i
control|)
block|{
name|xs
operator|+=
name|epsilon
operator|*
name|ys
expr_stmt|;
name|nx
operator|=
call|(
name|int
call|)
argument_list|(
name|xs
operator|+
name|cx
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|ys
operator|-=
name|epsilon
operator|*
name|xs
expr_stmt|;
name|ny
operator|=
call|(
name|int
call|)
argument_list|(
name|ys
operator|+
name|cy
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|RoundEnd
argument_list|(
name|nx
argument_list|,
name|ny
argument_list|,
call|(
name|int
call|)
argument_list|(
name|linethickness
operator|/
literal|2
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* end for */
block|}
end_block

begin_comment
comment|/* end HGArc */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------  * Routine:	RoundEnd (x, y, radius, filled_flag)  *  * Results:	Plots a filled (if requested) circle of the specified radius  *		centered about (x, y).  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|RoundEnd
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|radius
argument_list|,
argument|filled
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|radius
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|filled
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|xs
decl_stmt|,
name|ys
decl_stmt|,
name|epsilon
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|extent
decl_stmt|,
name|nx
decl_stmt|,
name|ny
decl_stmt|;
name|int
name|cx
decl_stmt|,
name|cy
decl_stmt|;
if|if
condition|(
name|radius
operator|<
literal|1
condition|)
block|{
comment|/* too small to notice */
name|point
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
name|xs
operator|=
literal|0
expr_stmt|;
name|ys
operator|=
name|radius
expr_stmt|;
name|epsilon
operator|=
literal|1.0
operator|/
name|radius
expr_stmt|;
name|extent
operator|=
name|pi
operator|*
name|radius
operator|/
literal|2.0
expr_stmt|;
comment|/* 1/4 the circumference */
comment|/* Calculate the trajectory of the circle for 1/4 the circumference          * and mirror appropriately to get the other three quadrants.          */
name|point
argument_list|(
name|x
argument_list|,
name|y
operator|+
operator|(
operator|(
name|int
operator|)
name|ys
operator|)
argument_list|)
expr_stmt|;
comment|/* take care if end of arc missed by */
name|point
argument_list|(
name|x
argument_list|,
name|y
operator|-
operator|(
operator|(
name|int
operator|)
name|ys
operator|)
argument_list|)
expr_stmt|;
comment|/* below formulation                 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extent
condition|;
operator|++
name|i
control|)
block|{
comment|/* generate circumference */
name|xs
operator|+=
name|epsilon
operator|*
name|ys
expr_stmt|;
name|nx
operator|=
call|(
name|int
call|)
argument_list|(
name|xs
operator|+
name|x
operator|+
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|nx
operator|<
name|x
condition|)
name|nx
operator|=
name|x
expr_stmt|;
comment|/* 1st quadrant, should be positive */
name|ys
operator|-=
name|epsilon
operator|*
name|xs
expr_stmt|;
name|ny
operator|=
call|(
name|int
call|)
argument_list|(
name|ys
operator|+
name|y
operator|+
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|ny
operator|<
name|y
condition|)
name|ny
operator|=
name|y
expr_stmt|;
comment|/* 1st quadrant, should be positive */
if|if
condition|(
name|filled
operator|==
name|TRUE
condition|)
block|{
comment|/* fill from center */
name|cx
operator|=
name|x
expr_stmt|;
name|cy
operator|=
name|y
expr_stmt|;
block|}
else|else
block|{
comment|/* fill from perimeter only (no fill) */
name|cx
operator|=
name|nx
expr_stmt|;
name|cy
operator|=
name|ny
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
name|cx
init|;
name|j
operator|<=
name|nx
condition|;
operator|++
name|j
control|)
block|{
for|for
control|(
name|k
operator|=
name|cy
init|;
name|k
operator|<=
name|ny
condition|;
operator|++
name|k
control|)
block|{
name|point
argument_list|(
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|point
argument_list|(
name|j
argument_list|,
literal|2
operator|*
name|y
operator|-
name|k
argument_list|)
expr_stmt|;
name|point
argument_list|(
literal|2
operator|*
name|x
operator|-
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|point
argument_list|(
literal|2
operator|*
name|x
operator|-
name|j
argument_list|,
literal|2
operator|*
name|y
operator|-
name|k
argument_list|)
expr_stmt|;
block|}
comment|/* end for k */
block|}
comment|/* end for j */
empty_stmt|;
block|}
comment|/* end for i */
empty_stmt|;
block|}
end_block

begin_comment
comment|/* end RoundEnd */
end_comment

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*----------------------------------------------------------------------------  * Routine:	Paramaterize (xpoints, ypoints, hparams, num_points)  *  * Results:	This routine calculates parameteric values for use in  *		calculating curves.  The parametric values are returned  *		in the array h.  The values are an approximation of  *		cumulative arc lengths of the curve (uses cord length).  *		For additional information, see paper cited below.  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
specifier|static
name|Paramaterize
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|h
argument_list|,
argument|n
argument_list|)
name|int
name|x
index|[
name|MAXPOINTS
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|h
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|dx
decl_stmt|;
specifier|register
name|int
name|dy
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|float
name|u
index|[
name|MAXPOINTS
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
operator|++
name|i
control|)
block|{
name|u
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|dx
operator|=
name|x
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|x
index|[
name|j
index|]
expr_stmt|;
name|dy
operator|=
name|y
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|y
index|[
name|j
index|]
expr_stmt|;
name|u
index|[
name|i
index|]
operator|+=
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|dx
operator|*
name|dx
operator|+
name|dy
operator|*
name|dy
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|h
index|[
name|i
index|]
operator|=
name|u
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|u
index|[
name|i
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end Paramaterize */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------  * Routine:	PeriodicSpline (h, z, dz, d2z, d3z, npoints)  *  * Results:	This routine solves for the cubic polynomial to fit a  *		spline curve to the the points  specified by the list  *		of values.  The Curve generated is periodic.  The algorithms  *		for this curve are from the "Spline Curve Techniques" paper  *		cited below.  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
specifier|static
name|PeriodicSpline
argument_list|(
argument|h
argument_list|,
argument|z
argument_list|,
argument|dz
argument_list|,
argument|d2z
argument_list|,
argument|d3z
argument_list|,
argument|npoints
argument_list|)
name|float
name|h
index|[
name|MAXPOINTS
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* paramaterization  */
end_comment

begin_decl_stmt
name|int
name|z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* point list */
end_comment

begin_decl_stmt
name|float
name|dz
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to return the 1st derivative */
end_comment

begin_decl_stmt
name|float
name|d2z
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2nd and 3rd derivatives */
end_comment

begin_decl_stmt
name|int
name|npoints
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of valid points */
end_comment

begin_block
block|{
name|float
name|d
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|deltaz
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|a
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|b
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|c
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|r
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|s
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* step 1 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
name|deltaz
index|[
name|i
index|]
operator|=
name|h
index|[
name|i
index|]
condition|?
operator|(
call|(
name|double
call|)
argument_list|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|z
index|[
name|i
index|]
argument_list|)
operator|)
operator|/
name|h
index|[
name|i
index|]
else|:
literal|0
expr_stmt|;
block|}
name|h
index|[
literal|0
index|]
operator|=
name|h
index|[
name|npoints
operator|-
literal|1
index|]
expr_stmt|;
name|deltaz
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
name|npoints
operator|-
literal|1
index|]
expr_stmt|;
comment|/* step 2 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|deltaz
index|[
name|i
index|]
expr_stmt|;
block|}
name|d
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
literal|1
index|]
operator|-
name|deltaz
index|[
literal|0
index|]
expr_stmt|;
comment|/* step 3a */
name|a
index|[
literal|1
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
literal|0
index|]
operator|+
name|h
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
name|d
index|[
literal|0
index|]
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
name|h
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|a
index|[
name|i
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|h
index|[
name|i
index|]
operator|)
operator|-
name|pow
argument_list|(
operator|(
name|double
operator|)
name|h
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
operator|(
name|double
operator|)
literal|2.0
argument_list|)
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|b
index|[
name|i
index|]
operator|=
name|d
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|h
index|[
name|i
operator|-
literal|1
index|]
operator|*
name|b
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|c
index|[
name|i
index|]
operator|=
operator|-
name|h
index|[
name|i
operator|-
literal|1
index|]
operator|*
name|c
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* step 3b */
name|r
index|[
name|npoints
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|s
index|[
name|npoints
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|npoints
operator|-
literal|2
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|r
index|[
name|i
index|]
operator|=
operator|-
operator|(
name|h
index|[
name|i
index|]
operator|*
name|r
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|c
index|[
name|i
index|]
operator|)
operator|/
name|a
index|[
name|i
index|]
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
operator|(
literal|6
operator|*
name|b
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
name|s
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
name|a
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* step 4 */
name|d2z
index|[
name|npoints
operator|-
literal|1
index|]
operator|=
operator|(
literal|6
operator|*
name|d
index|[
name|npoints
operator|-
literal|2
index|]
operator|-
name|h
index|[
literal|0
index|]
operator|*
name|s
index|[
literal|1
index|]
operator|-
name|h
index|[
name|npoints
operator|-
literal|1
index|]
operator|*
name|s
index|[
name|npoints
operator|-
literal|2
index|]
operator|)
operator|/
operator|(
name|h
index|[
literal|0
index|]
operator|*
name|r
index|[
literal|1
index|]
operator|+
name|h
index|[
name|npoints
operator|-
literal|1
index|]
operator|*
name|r
index|[
name|npoints
operator|-
literal|2
index|]
operator|+
literal|2
operator|*
operator|(
name|h
index|[
name|npoints
operator|-
literal|2
index|]
operator|+
name|h
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d2z
index|[
name|i
index|]
operator|=
name|r
index|[
name|i
index|]
operator|*
name|d2z
index|[
name|npoints
operator|-
literal|1
index|]
operator|+
name|s
index|[
name|i
index|]
expr_stmt|;
block|}
name|d2z
index|[
name|npoints
index|]
operator|=
name|d2z
index|[
literal|1
index|]
expr_stmt|;
comment|/* step 5 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
name|dz
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
operator|(
literal|2
operator|*
name|d2z
index|[
name|i
index|]
operator|+
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
literal|6
expr_stmt|;
name|d3z
index|[
name|i
index|]
operator|=
name|h
index|[
name|i
index|]
condition|?
operator|(
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|d2z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
else|:
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end PeriodicSpline */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------  * Routine:	NaturalEndSpline (h, z, dz, d2z, d3z, npoints)  *  * Results:	This routine solves for the cubic polynomial to fit a  *		spline curve the the points  specified by the list of  *		values.  The alogrithms for this curve are from the  *		"Spline Curve Techniques" paper cited below.  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
specifier|static
name|NaturalEndSpline
argument_list|(
argument|h
argument_list|,
argument|z
argument_list|,
argument|dz
argument_list|,
argument|d2z
argument_list|,
argument|d3z
argument_list|,
argument|npoints
argument_list|)
name|float
name|h
index|[
name|MAXPOINTS
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* parameterization */
end_comment

begin_decl_stmt
name|int
name|z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Point list */
end_comment

begin_decl_stmt
name|float
name|dz
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to return the 1st derivative */
end_comment

begin_decl_stmt
name|float
name|d2z
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2nd and 3rd derivatives */
end_comment

begin_decl_stmt
name|int
name|npoints
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of valid points */
end_comment

begin_block
block|{
name|float
name|d
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|deltaz
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|a
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|b
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* step 1 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
name|deltaz
index|[
name|i
index|]
operator|=
name|h
index|[
name|i
index|]
condition|?
operator|(
call|(
name|double
call|)
argument_list|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|z
index|[
name|i
index|]
argument_list|)
operator|)
operator|/
name|h
index|[
name|i
index|]
else|:
literal|0
expr_stmt|;
block|}
name|deltaz
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
name|npoints
operator|-
literal|1
index|]
expr_stmt|;
comment|/* step 2 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|deltaz
index|[
name|i
index|]
expr_stmt|;
block|}
name|d
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
literal|1
index|]
operator|-
name|deltaz
index|[
literal|0
index|]
expr_stmt|;
comment|/* step 3 */
name|a
index|[
literal|0
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
literal|2
index|]
operator|+
name|h
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|d
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|a
index|[
name|i
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|h
index|[
name|i
operator|+
literal|2
index|]
operator|)
operator|-
name|pow
argument_list|(
operator|(
name|double
operator|)
name|h
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|(
name|double
operator|)
literal|2.0
argument_list|)
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|b
index|[
name|i
index|]
operator|=
name|d
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|h
index|[
name|i
operator|+
literal|1
index|]
operator|*
name|b
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* step 4 */
name|d2z
index|[
name|npoints
index|]
operator|=
name|d2z
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|npoints
operator|-
literal|1
init|;
name|i
operator|>
literal|1
condition|;
operator|--
name|i
control|)
block|{
name|d2z
index|[
name|i
index|]
operator|=
operator|(
literal|6
operator|*
name|b
index|[
name|i
operator|-
literal|2
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
name|a
index|[
name|i
operator|-
literal|2
index|]
expr_stmt|;
block|}
comment|/* step 5 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
name|dz
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
operator|(
literal|2
operator|*
name|d2z
index|[
name|i
index|]
operator|+
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
literal|6
expr_stmt|;
name|d3z
index|[
name|i
index|]
operator|=
name|h
index|[
name|i
index|]
condition|?
operator|(
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|d2z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
else|:
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end NaturalEndSpline */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------  * Routine:	HGCurve(xpoints, ypoints, num_points)  *  * Results:	This routine generates a smooth curve through a set of points.  *		The method used is the parametric spline curve on unit knot  *		mesh described in "Spline Curve Techniques" by Patrick  *		Baudelaire, Robert Flegal, and Robert Sproull -- Xerox Parc.  *----------------------------------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|PointsPerInterval
value|32
end_define

begin_macro
name|HGCurve
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|numpoints
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numpoints
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|float
name|h
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|dx
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|dy
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|d2x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d2y
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|t
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|int
name|nx
decl_stmt|;
specifier|register
name|int
name|ny
decl_stmt|;
name|int
name|lx
decl_stmt|,
name|ly
decl_stmt|;
name|lx
operator|=
name|x
index|[
literal|1
index|]
expr_stmt|;
name|ly
operator|=
name|y
index|[
literal|1
index|]
expr_stmt|;
comment|/* Solve for derivatives of the curve at each point                * separately for x and y (parametric). 	      */
name|Paramaterize
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|h
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
comment|/* closed curve */
if|if
condition|(
operator|(
name|x
index|[
literal|1
index|]
operator|==
name|x
index|[
name|numpoints
index|]
operator|)
operator|&&
operator|(
name|y
index|[
literal|1
index|]
operator|==
name|y
index|[
name|numpoints
index|]
operator|)
condition|)
block|{
name|PeriodicSpline
argument_list|(
name|h
argument_list|,
name|x
argument_list|,
name|dx
argument_list|,
name|d2x
argument_list|,
name|d3x
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
name|PeriodicSpline
argument_list|(
name|h
argument_list|,
name|y
argument_list|,
name|dy
argument_list|,
name|d2y
argument_list|,
name|d3y
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NaturalEndSpline
argument_list|(
name|h
argument_list|,
name|x
argument_list|,
name|dx
argument_list|,
name|d2x
argument_list|,
name|d3x
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
name|NaturalEndSpline
argument_list|(
name|h
argument_list|,
name|y
argument_list|,
name|dy
argument_list|,
name|d2y
argument_list|,
name|d3y
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
block|}
comment|/* generate the curve using the above information and  	       * PointsPerInterval vectors between each specified knot. 	       */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|numpoints
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|(
name|x
index|[
name|j
index|]
operator|==
name|x
index|[
name|j
operator|+
literal|1
index|]
operator|)
operator|&&
operator|(
name|y
index|[
name|j
index|]
operator|==
name|y
index|[
name|j
operator|+
literal|1
index|]
operator|)
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|PointsPerInterval
condition|;
operator|++
name|k
control|)
block|{
name|t
operator|=
operator|(
name|float
operator|)
name|k
operator|*
name|h
index|[
name|j
index|]
operator|/
operator|(
name|float
operator|)
name|PointsPerInterval
expr_stmt|;
name|t2
operator|=
name|t
operator|*
name|t
expr_stmt|;
name|t3
operator|=
name|t
operator|*
name|t
operator|*
name|t
expr_stmt|;
name|nx
operator|=
name|x
index|[
name|j
index|]
operator|+
call|(
name|int
call|)
argument_list|(
name|t
operator|*
name|dx
index|[
name|j
index|]
operator|+
name|t2
operator|*
name|d2x
index|[
name|j
index|]
operator|/
literal|2
operator|+
name|t3
operator|*
name|d3x
index|[
name|j
index|]
operator|/
literal|6
argument_list|)
expr_stmt|;
name|ny
operator|=
name|y
index|[
name|j
index|]
operator|+
call|(
name|int
call|)
argument_list|(
name|t
operator|*
name|dy
index|[
name|j
index|]
operator|+
name|t2
operator|*
name|d2y
index|[
name|j
index|]
operator|/
literal|2
operator|+
name|t3
operator|*
name|d3y
index|[
name|j
index|]
operator|/
literal|6
argument_list|)
expr_stmt|;
name|HGtline
argument_list|(
name|lx
argument_list|,
name|ly
argument_list|,
name|nx
argument_list|,
name|ny
argument_list|)
expr_stmt|;
name|lx
operator|=
name|nx
expr_stmt|;
name|ly
operator|=
name|ny
expr_stmt|;
block|}
comment|/* end for k */
block|}
comment|/* end for j */
block|}
end_block

begin_comment
comment|/* end HGCurve */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------  * Routine:	HGtline(xstart, ystart, xend, yend)  *  * Results:	Draws a line of proper thickness by calling "line" numerous  *		times until the desired thickness is reached.  *----------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
name|HGtline
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|)
specifier|register
name|int
name|x0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|y0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|x1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|y1
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|xs
decl_stmt|;
specifier|register
name|int
name|xe
decl_stmt|;
specifier|register
name|int
name|ys
decl_stmt|;
specifier|register
name|int
name|ye
decl_stmt|;
name|double
name|morelen
decl_stmt|,
name|theta
decl_stmt|,
name|wx
decl_stmt|,
name|wy
decl_stmt|,
name|xx
decl_stmt|,
name|xy
decl_stmt|;
name|int
name|addln
decl_stmt|,
name|j
decl_stmt|,
name|xdir
decl_stmt|,
name|ydir
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|xdir
operator|=
name|ydir
operator|=
literal|1
expr_stmt|;
name|dx
operator|=
name|x1
operator|-
name|x0
expr_stmt|;
comment|/* calculate direction to move to  */
name|dy
operator|=
name|y1
operator|-
name|y0
expr_stmt|;
comment|/* move to draw additional lines if needed */
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
block|{
comment|/* for extra thickness */
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
name|xdir
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dy
operator|<
literal|0
condition|)
block|{
name|dy
operator|=
operator|-
name|dy
expr_stmt|;
name|ydir
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|morelen
operator|=
name|linethickness
operator|/
literal|2
expr_stmt|;
name|addln
operator|=
operator|(
name|int
operator|)
name|morelen
expr_stmt|;
name|RoundEnd
argument_list|(
name|x0
argument_list|,
name|y0
argument_list|,
operator|(
name|int
operator|)
name|morelen
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* add rounded end */
for|for
control|(
name|j
operator|=
operator|(
operator|-
name|addln
operator|)
init|;
name|j
operator|<=
name|addln
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|dy
operator|==
literal|0
condition|)
block|{
name|xs
operator|=
name|x0
expr_stmt|;
name|xe
operator|=
name|x1
expr_stmt|;
name|ys
operator|=
name|ye
operator|=
name|y0
operator|+
name|j
expr_stmt|;
block|}
if|if
condition|(
name|dx
operator|==
literal|0
condition|)
block|{
name|ys
operator|=
name|y0
expr_stmt|;
name|ye
operator|=
name|y1
expr_stmt|;
name|xs
operator|=
name|xe
operator|=
name|x0
operator|+
name|j
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dx
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|dy
operator|!=
literal|0
operator|)
condition|)
block|{
name|theta
operator|=
name|pi
operator|/
literal|2.0
operator|-
name|atan
argument_list|(
operator|(
operator|(
name|double
operator|)
name|dx
operator|)
operator|/
operator|(
operator|(
name|double
operator|)
name|dy
operator|)
argument_list|)
expr_stmt|;
name|wx
operator|=
name|j
operator|*
name|sin
argument_list|(
name|theta
argument_list|)
expr_stmt|;
name|wy
operator|=
name|j
operator|*
name|cos
argument_list|(
name|theta
argument_list|)
expr_stmt|;
name|xs
operator|=
name|x0
operator|+
name|wx
operator|*
name|xdir
expr_stmt|;
name|ys
operator|=
name|y0
operator|-
name|wy
operator|*
name|ydir
expr_stmt|;
name|xe
operator|=
name|x1
operator|+
name|wx
operator|*
name|xdir
expr_stmt|;
name|ye
operator|=
name|y1
operator|-
name|wy
operator|*
name|ydir
expr_stmt|;
block|}
name|line
argument_list|(
name|xs
argument_list|,
name|ys
argument_list|,
name|xe
argument_list|,
name|ye
argument_list|)
expr_stmt|;
block|}
comment|/* end for */
name|RoundEnd
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
operator|(
name|int
operator|)
name|morelen
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* add rounded end */
block|}
end_block

begin_comment
comment|/* end HGtline */
end_comment

end_unit

