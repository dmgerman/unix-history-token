begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vsort.c	1.3	83/07/30  *  *	sort troff output into troff output that only goes one  *	direction down the page.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|DEBUGABLE
end_define

begin_comment
comment|/* compile-time flag for debugging */
end_comment

begin_define
define|#
directive|define
name|FATAL
value|1
end_define

begin_define
define|#
directive|define
name|NVLIST
value|1500
end_define

begin_comment
comment|/* size of list of vertical spans */
end_comment

begin_define
define|#
directive|define
name|OBUFSIZ
value|40000
end_define

begin_comment
comment|/* size of character buffer before sorting */
end_comment

begin_define
define|#
directive|define
name|SLOP
value|1000
end_define

begin_comment
comment|/* extra bit of buffer to allow for passing OBUFSIZ */
end_comment

begin_define
define|#
directive|define
name|hgoto
parameter_list|(
name|n
parameter_list|)
value|hpos = n
end_define

begin_define
define|#
directive|define
name|hmot
parameter_list|(
name|n
parameter_list|)
value|hgoto(hpos + (n))
end_define

begin_define
define|#
directive|define
name|vmot
parameter_list|(
name|n
parameter_list|)
value|vgoto(vpos + (n))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGABLE
end_ifdef

begin_decl_stmt
name|int
name|dbg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug flag != 0 means do debug output */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|size
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current size */
end_comment

begin_decl_stmt
name|int
name|font
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current font */
end_comment

begin_decl_stmt
name|int
name|thick
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line thickness */
end_comment

begin_decl_stmt
name|int
name|style
init|=
literal|255
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line style bit-mask */
end_comment

begin_decl_stmt
name|int
name|hpos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* horizontal position to be at next (left = 0) */
end_comment

begin_decl_stmt
name|int
name|vpos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current vertical position (down positive) */
end_comment

begin_struct
struct|struct
name|vlist
block|{
name|int
name|v
decl_stmt|;
comment|/* vertical position of this spread */
name|int
name|h
decl_stmt|;
comment|/* horizontal position */
name|int
name|s
decl_stmt|;
comment|/* point size */
name|int
name|t
decl_stmt|;
comment|/* line thickness */
name|char
name|f
decl_stmt|;
comment|/* font number */
name|char
name|st
decl_stmt|;
comment|/* style mask */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* text pointer to this spread */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|vlist
name|vlist
index|[
name|NVLIST
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vlist
modifier|*
name|vlp
init|=
name|vlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nvlist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|obufsiz
init|=
name|OBUFSIZ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|obuf
index|[
name|OBUFSIZ
operator|+
name|SLOP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|op
init|=
name|obuf
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
operator|*
operator|*
operator|++
name|argv
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
case|case
literal|'d'
case|:
name|dbg
operator|=
name|atoi
argument_list|(
operator|&
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
operator|==
literal|0
condition|)
block|{
name|dbg
operator|=
literal|1
expr_stmt|;
name|obufsiz
operator|=
literal|50
expr_stmt|;
block|}
else|else
name|obufsiz
operator|=
name|dbg
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|conv
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|conv
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|done
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* read number from input:  copy to output */
end_comment

begin_function
name|int
name|getnumber
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|+
operator|(
operator|*
name|op
operator|++
operator|=
name|c
operator|)
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_function

begin_comment
comment|/* read number from input:  do _
comment|N_
comment|O_
comment|T copy to output */
end_comment

begin_function
name|int
name|ngetnumber
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|conv
argument_list|(
name|fp
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|m
decl_stmt|,
name|n
decl_stmt|,
name|m1
decl_stmt|,
name|n1
decl_stmt|;
name|char
name|buf
index|[
name|SLOP
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c i=%d V=%d\n"
argument_list|,
name|c
argument_list|,
name|op
operator|-
name|obuf
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|op
operator|>
name|obuf
operator|+
name|obufsiz
condition|)
name|oflush
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* let text input through */
case|case
literal|'\t'
case|:
case|case
literal|' '
case|:
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
comment|/* push down current environment */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|t_push
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
comment|/* pop up last environment */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|t_pop
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* two motion digits plus a character */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|hmot
argument_list|(
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
operator|*
name|op
operator|++
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|-
literal|'0'
argument_list|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* single ascii character */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* white-space terminated funny character */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|op
operator|++
operator|=
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* straight text */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|fgets
argument_list|(
name|op
argument_list|,
name|SLOP
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* draw function */
name|fgets
argument_list|(
name|buf
argument_list|,
name|SLOP
argument_list|,
name|fp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* "style" */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|style
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"D%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* thickness */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|thick
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"D%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* draw a line */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
comment|/* if line starts higher, put */
comment|/* it on its own span */
if|if
condition|(
name|m
operator|<
literal|0
condition|)
block|{
name|startspan
argument_list|(
name|vpos
operator|+
name|m
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"V%d "
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"D%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* circle */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
comment|/* always put */
name|startspan
argument_list|(
name|vpos
operator|+
name|n
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* circles on */
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"V%d D%s"
argument_list|,
name|vpos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/*their own */
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* vertl list */
name|hmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|startspan
argument_list|(
name|vpos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* ellipse */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
comment|/* same here */
name|startspan
argument_list|(
name|vpos
operator|+
name|n
operator|/
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"V%d D%s"
argument_list|,
name|vpos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|startspan
argument_list|(
name|vpos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* arc */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d %d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n1
argument_list|,
operator|&
name|m1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|+=
name|m1
operator|)
operator|<
literal|0
condition|)
comment|/* set m1 to highest */
name|m1
operator|=
name|vpos
operator|+
name|m
expr_stmt|;
comment|/* of the endpoints */
else|else
name|m1
operator|=
name|vpos
expr_stmt|;
comment|/* can't be any more */
name|m1
operator|-=
operator|(
operator|(
operator|(
name|n
operator|+=
name|n1
operator|)
operator|<
literal|0
operator|)
condition|?
comment|/* than 1/2 */
operator|-
name|n
else|:
name|n
operator|)
operator|>>
literal|1
expr_stmt|;
comment|/* horiz diff higher */
name|startspan
argument_list|(
name|m1
operator|<
literal|0
condition|?
literal|0
else|:
name|m1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"V%d D%s"
argument_list|,
name|vpos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
comment|/* wiggly line */
case|case
literal|'g'
case|:
comment|/* gremlin curve */
block|{
specifier|register
name|char
modifier|*
name|pop
decl_stmt|;
comment|/* a curve goes on */
name|startspan
argument_list|(
name|vpos
argument_list|)
expr_stmt|;
comment|/* its own span */
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"V%dD"
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
comment|/* vertical move */
name|pop
operator|=
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* to curve start */
do|do
block|{
comment|/* read in rest of */
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* point input */
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|op
operator|-
literal|1
operator|)
operator|!=
literal|'\n'
condition|)
name|fgets
argument_list|(
name|buf
argument_list|,
name|SLOP
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|(
name|op
operator|-
literal|1
operator|)
operator|!=
literal|'\n'
condition|)
do|;
name|n
operator|=
name|vpos
expr_stmt|;
comment|/* = minimum vertical */
comment|/* position for curve */
while|while
condition|(
operator|*
operator|++
name|pop
operator|==
literal|' '
condition|)
empty_stmt|;
comment|/* skip '~'& blanks */
do|do
block|{
comment|/* calculate minimum */
name|hpos
operator|+=
name|atoi
argument_list|(
name|pop
argument_list|)
expr_stmt|;
comment|/* vertical */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|pop
argument_list|)
condition|)
empty_stmt|;
comment|/* position */
while|while
condition|(
operator|*
operator|++
name|pop
operator|==
literal|' '
condition|)
empty_stmt|;
name|vpos
operator|+=
name|atoi
argument_list|(
name|pop
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|pop
argument_list|)
condition|)
empty_stmt|;
while|while
condition|(
operator|*
name|pop
operator|==
literal|' '
condition|)
name|pop
operator|++
expr_stmt|;
if|if
condition|(
name|vpos
operator|<
name|n
condition|)
name|n
operator|=
name|vpos
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|pop
operator|!=
literal|'\n'
condition|)
do|;
operator|(
name|vlp
operator|-
literal|1
operator|)
operator|->
name|v
operator|=
name|n
expr_stmt|;
name|startspan
argument_list|(
name|vpos
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unknown drawing command %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'s'
case|:
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|size
operator|=
name|getnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|font
operator|=
name|getnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* absolute horizontal motion */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|hgoto
argument_list|(
name|getnumber
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* relative horizontal motion */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|hmot
argument_list|(
name|getnumber
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* useless */
break|break;
case|case
literal|'V'
case|:
comment|/* absolute vertical motion */
name|vgoto
argument_list|(
name|ngetnumber
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|vmot
argument_list|(
name|ngetnumber
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* new page */
name|vpos
operator|=
literal|0
expr_stmt|;
name|oflush
argument_list|()
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* end of line */
name|hpos
operator|=
literal|0
expr_stmt|;
case|case
literal|'#'
case|:
comment|/* comment */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|op
operator|++
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* device control */
name|oflush
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"unknown input character %o %c\n"
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|oflush
argument_list|()
end_macro

begin_comment
comment|/* sort, then dump out contents of obuf */
end_comment

begin_block
block|{
specifier|register
name|struct
name|vlist
modifier|*
name|vp
decl_stmt|;
specifier|register
name|int
name|lastv
init|=
operator|-
literal|1
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|compar
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"into oflush, V=%d\n"
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|op
operator|==
name|obuf
condition|)
return|return;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vlist
argument_list|,
name|nvlist
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vlist
argument_list|)
argument_list|,
name|compar
argument_list|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
literal|0
expr_stmt|;
name|vp
operator|=
name|vlist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvlist
condition|;
name|i
operator|++
operator|,
name|vp
operator|++
control|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|lastv
operator|!=
name|vp
operator|->
name|v
condition|)
name|printf
argument_list|(
literal|"V%d"
argument_list|,
name|lastv
operator|=
name|vp
operator|->
name|v
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"H%ds%df%d Ds %d\nDt %d\n"
argument_list|,
name|vp
operator|->
name|h
argument_list|,
name|vp
operator|->
name|s
argument_list|,
name|vp
operator|->
name|f
argument_list|,
name|vp
operator|->
name|st
argument_list|,
name|vp
operator|->
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|vp
operator|->
name|p
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|vlp
operator|=
name|vlist
expr_stmt|;
name|vlp
operator|->
name|p
operator|=
name|op
operator|=
name|obuf
expr_stmt|;
name|vlp
operator|->
name|h
operator|=
name|hpos
expr_stmt|;
name|vlp
operator|->
name|v
operator|=
name|vpos
expr_stmt|;
name|vlp
operator|->
name|s
operator|=
name|size
expr_stmt|;
name|vlp
operator|->
name|f
operator|=
name|font
expr_stmt|;
name|vlp
operator|->
name|st
operator|=
name|style
expr_stmt|;
name|vlp
operator|->
name|t
operator|=
name|thick
expr_stmt|;
operator|*
name|op
operator|=
literal|0
expr_stmt|;
name|vlp
operator|++
expr_stmt|;
name|nvlist
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|compar
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vlist
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|p1
operator|->
name|v
operator|-
name|p2
operator|->
name|v
operator|)
return|;
block|}
end_block

begin_macro
name|done
argument_list|()
end_macro

begin_block
block|{
name|oflush
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|f
argument_list|,
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|,
argument|a6
argument_list|,
argument|a7
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vsort: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
name|done
argument_list|()
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|MAXSTATE
value|5
end_define

begin_struct
struct|struct
name|state
block|{
name|int
name|ssize
decl_stmt|;
name|int
name|sfont
decl_stmt|;
name|int
name|shpos
decl_stmt|;
name|int
name|svpos
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|state
name|state
index|[
name|MAXSTATE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|state
modifier|*
name|statep
init|=
name|state
decl_stmt|;
end_decl_stmt

begin_macro
name|t_push
argument_list|()
end_macro

begin_comment
comment|/* begin a new block */
end_comment

begin_block
block|{
name|statep
operator|->
name|ssize
operator|=
name|size
expr_stmt|;
name|statep
operator|->
name|sfont
operator|=
name|font
expr_stmt|;
name|statep
operator|->
name|shpos
operator|=
name|hpos
expr_stmt|;
name|statep
operator|->
name|svpos
operator|=
name|vpos
expr_stmt|;
name|hpos
operator|=
name|vpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|statep
operator|++
operator|>=
name|state
operator|+
name|MAXSTATE
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"{ nested too deep"
argument_list|)
expr_stmt|;
name|hpos
operator|=
name|vpos
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|t_pop
argument_list|()
end_macro

begin_comment
comment|/* pop to previous state */
end_comment

begin_block
block|{
if|if
condition|(
operator|--
name|statep
operator|<
name|state
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"extra }"
argument_list|)
expr_stmt|;
name|size
operator|=
name|statep
operator|->
name|ssize
expr_stmt|;
name|font
operator|=
name|statep
operator|->
name|sfont
expr_stmt|;
name|hpos
operator|=
name|statep
operator|->
name|shpos
expr_stmt|;
name|vpos
operator|=
name|statep
operator|->
name|svpos
expr_stmt|;
block|}
end_block

begin_comment
comment|/* vertical motion:  start new vertical span if necessary */
end_comment

begin_expr_stmt
name|vgoto
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|!=
name|vpos
condition|)
name|startspan
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|vpos
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|startspan
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|*
name|op
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nvlist
operator|>=
name|NVLIST
condition|)
block|{
name|oflush
argument_list|()
expr_stmt|;
block|}
name|vlp
operator|->
name|p
operator|=
name|op
expr_stmt|;
name|vlp
operator|->
name|v
operator|=
name|n
expr_stmt|;
name|vlp
operator|->
name|h
operator|=
name|hpos
expr_stmt|;
name|vlp
operator|->
name|s
operator|=
name|size
expr_stmt|;
name|vlp
operator|->
name|f
operator|=
name|font
expr_stmt|;
name|vlp
operator|->
name|st
operator|=
name|style
expr_stmt|;
name|vlp
operator|->
name|t
operator|=
name|thick
expr_stmt|;
name|vlp
operator|++
expr_stmt|;
name|nvlist
operator|++
expr_stmt|;
block|}
end_block

end_unit

