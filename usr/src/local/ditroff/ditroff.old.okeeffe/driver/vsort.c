begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vsort.c	1.6	83/10/22  *  *	Sorts and shuffles ditroff output for versatec wide printer.  It  *	puts pages side-by-side on the output, and fits as many as it can  *	on one horizontal span.  The versatec driver sees only pages of  *	full width, not the individual pages.  Output is sorted vertically  *	and bands are created NLINES pixels high.  Any object that has  *	ANY part of it in a band is put on that band.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_comment
comment|/* #define DEBUGABLE	/* compile-time flag for debugging */
end_comment

begin_define
define|#
directive|define
name|FATAL
value|1
end_define

begin_define
define|#
directive|define
name|NVLIST
value|3000
end_define

begin_comment
comment|/* size of list of vertical spans */
end_comment

begin_define
define|#
directive|define
name|OBUFSIZ
value|250000
end_define

begin_comment
comment|/* size of character buffer before sorting */
end_comment

begin_define
define|#
directive|define
name|SLOP
value|1000
end_define

begin_comment
comment|/* extra bit of buffer to allow for passing OBUFSIZ */
end_comment

begin_define
define|#
directive|define
name|FONTDIR
value|"/usr/lib/font"
end_define

begin_define
define|#
directive|define
name|INCH
value|200
end_define

begin_comment
comment|/* assumed resolution of the printer (dots/inch) */
end_comment

begin_define
define|#
directive|define
name|POINT
value|72
end_define

begin_comment
comment|/* number of points per inch */
end_comment

begin_define
define|#
directive|define
name|WIDTH
value|7040
end_define

begin_comment
comment|/* number of pixels across the page */
end_comment

begin_define
define|#
directive|define
name|HALF
value|(INCH/2)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUGABLE
end_ifndef

begin_define
define|#
directive|define
name|BAND
value|2
end_define

begin_comment
comment|/* or defined below.... */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NLINES
value|(int)(BAND * INCH)
end_define

begin_comment
comment|/* number of pixels in each band */
end_comment

begin_define
define|#
directive|define
name|hgoto
parameter_list|(
name|n
parameter_list|)
value|if((hpos = leftmarg + n)> maxh) maxh = hpos
end_define

begin_define
define|#
directive|define
name|hmot
parameter_list|(
name|n
parameter_list|)
value|if((hpos += n)> maxh) maxh = hpos
end_define

begin_define
define|#
directive|define
name|vmot
parameter_list|(
name|n
parameter_list|)
value|vgoto(vpos + n)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGABLE
end_ifdef

begin_decl_stmt
name|int
name|dbg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug flag != 0 means do debug output */
end_comment

begin_decl_stmt
name|float
name|BAND
init|=
literal|2.0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|size
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current size (points) */
end_comment

begin_decl_stmt
name|int
name|up
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pixels that the current size pushes up */
end_comment

begin_decl_stmt
name|int
name|down
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of pixels that the current size will hang down */
end_comment

begin_decl_stmt
name|int
name|font
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current font */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fontdir
init|=
name|FONTDIR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place to find DESC.out file */
end_comment

begin_decl_stmt
name|int
name|thick
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line thickness */
end_comment

begin_decl_stmt
name|int
name|style
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line style bit-mask */
end_comment

begin_decl_stmt
name|int
name|hpos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* horizontal position to be at next (left = 0) */
end_comment

begin_decl_stmt
name|int
name|vpos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current vertical position (down positive) */
end_comment

begin_decl_stmt
name|int
name|maxh
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* farthest right we've gone on the current span */
end_comment

begin_decl_stmt
name|int
name|leftmarg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current page offset */
end_comment

begin_decl_stmt
name|int
name|spanno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current span number for driver in 'p#' commands */
end_comment

begin_decl_stmt
name|int
name|pageno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pages spread across a physical page */
end_comment

begin_struct
struct|struct
name|vlist
block|{
name|short
name|v
decl_stmt|;
comment|/* vertical position of this spread */
name|short
name|h
decl_stmt|;
comment|/* horizontal position */
name|short
name|t
decl_stmt|;
comment|/* line thickness */
name|short
name|st
decl_stmt|;
comment|/* style mask */
name|short
name|u
decl_stmt|;
comment|/* upper extent of height */
name|short
name|d
decl_stmt|;
comment|/* depth of height */
name|char
name|s
decl_stmt|;
comment|/* point size */
name|char
name|f
decl_stmt|;
comment|/* font number */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* text pointer to this spread */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|vlist
name|vlist
index|[
name|NVLIST
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vlist
modifier|*
name|vlp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current spread being added to */
end_comment

begin_decl_stmt
name|int
name|nvlist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of spreads in list */
end_comment

begin_decl_stmt
name|int
name|obufsiz
init|=
name|OBUFSIZ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|obuf
index|[
name|OBUFSIZ
operator|+
name|SLOP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|op
init|=
name|obuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to current spot in buffer */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|double
name|atof
parameter_list|()
function_decl|;
name|vlp
operator|=
operator|&
name|vlist
index|[
literal|0
index|]
operator|-
literal|1
expr_stmt|;
comment|/* initialize pointer to one less */
name|startspan
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* than beginning so "startspan" can */
comment|/* increment it before using it */
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
operator|*
operator|*
operator|++
name|argv
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'f'
case|:
name|fontdir
operator|=
operator|&
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUGABLE
case|case
literal|'B'
case|:
name|BAND
operator|=
name|atof
argument_list|(
operator|&
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dbg
operator|=
name|atoi
argument_list|(
operator|&
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbg
condition|)
name|dbg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|(
name|obufsiz
operator|=
name|atoi
argument_list|(
operator|&
operator|(
operator|*
name|argv
operator|)
index|[
literal|2
index|]
argument_list|)
operator|)
operator|>
name|OBUFSIZ
condition|)
name|obufsiz
operator|=
name|OBUFSIZ
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|conv
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|conv
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|done
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* read number from input:  copy to output */
end_comment

begin_function
name|int
name|getnumber
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|+
operator|(
operator|*
name|op
operator|++
operator|=
name|c
operator|)
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_function

begin_comment
comment|/* read number from input:  do _
comment|N_
comment|O_
comment|T copy to output */
end_comment

begin_function
name|int
name|ngetnumber
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|k
operator|=
literal|10
operator|*
name|k
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
do|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|conv
argument_list|(
name|fp
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|m
decl_stmt|,
name|n
decl_stmt|,
name|m1
decl_stmt|,
name|n1
decl_stmt|;
name|char
name|buf
index|[
name|SLOP
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c i=%d V=%d\n"
argument_list|,
name|c
argument_list|,
name|op
operator|-
name|obuf
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|op
operator|>
name|obuf
operator|+
name|obufsiz
condition|)
block|{
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"buffer overflow %d."
argument_list|,
name|op
operator|-
operator|(
name|obuf
operator|+
name|obufsiz
operator|)
argument_list|)
expr_stmt|;
name|oflush
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* let text input through */
case|case
literal|'\t'
case|:
case|case
literal|' '
case|:
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
comment|/* push down current environment */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|t_push
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
comment|/* pop up last environment */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|t_pop
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* two motion digits plus a character */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|hmot
argument_list|(
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
operator|*
name|op
operator|++
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|-
literal|'0'
argument_list|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|setlimit
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* single ascii character */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|setlimit
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* white-space terminated funny character */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|op
operator|++
operator|=
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|setlimit
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* straight text */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|fgets
argument_list|(
name|op
argument_list|,
name|SLOP
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|setlimit
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* draw function */
name|fgets
argument_list|(
name|buf
argument_list|,
name|SLOP
argument_list|,
name|fp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* "style" */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|style
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"D%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* thickness */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|thick
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"D%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* draw a line */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
comment|/* put line on its own spread */
if|if
condition|(
name|m
operator|<
literal|0
condition|)
block|{
name|startspan
argument_list|(
name|vpos
operator|+
name|m
argument_list|)
expr_stmt|;
name|vlp
operator|->
name|d
operator|=
name|vpos
operator|+
name|thick
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|startspan
argument_list|(
name|vpos
argument_list|)
expr_stmt|;
name|vlp
operator|->
name|d
operator|=
name|vpos
operator|+
name|m
operator|+
name|thick
operator|/
literal|2
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"V%dD%s"
argument_list|,
name|vpos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* circle */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
comment|/* put circle */
name|startspan
argument_list|(
name|vpos
operator|-
operator|(
name|n
operator|+
name|thick
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* on its own */
name|vlp
operator|->
name|d
operator|=
name|vpos
operator|+
operator|(
name|n
operator|+
name|thick
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* spread */
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"V%dD%s"
argument_list|,
name|vpos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|startspan
argument_list|(
name|vpos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* ellipse */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d"
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
comment|/* same here */
name|startspan
argument_list|(
name|vpos
operator|-
operator|(
name|n
operator|+
name|thick
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|vlp
operator|->
name|d
operator|=
name|vpos
operator|+
operator|(
name|n
operator|+
name|thick
operator|)
operator|/
literal|2
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"V%dD%s"
argument_list|,
name|vpos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|startspan
argument_list|(
name|vpos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* arc */
name|sscanf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"%d %d %d %d"
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n1
argument_list|,
operator|&
name|m1
argument_list|)
expr_stmt|;
name|startspan
argument_list|(
name|vpos
argument_list|)
expr_stmt|;
name|arcbounds
argument_list|(
name|n
argument_list|,
name|m
argument_list|,
name|n1
argument_list|,
name|m1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"V%dD%s"
argument_list|,
name|vpos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|hmot
argument_list|(
name|n
operator|+
name|n1
argument_list|)
expr_stmt|;
name|vmot
argument_list|(
name|m
operator|+
name|m1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
comment|/* wiggly line */
case|case
literal|'g'
case|:
comment|/* gremlin curve */
block|{
specifier|register
name|char
modifier|*
name|pop
decl_stmt|;
comment|/* a curve goes on */
name|startspan
argument_list|(
name|vpos
argument_list|)
expr_stmt|;
comment|/* its own span */
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"V%dD"
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
comment|/* vertical move */
name|pop
operator|=
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* to curve start */
do|do
block|{
comment|/* read in rest of */
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* point input */
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|op
operator|-
literal|1
operator|)
operator|!=
literal|'\n'
condition|)
name|fgets
argument_list|(
name|buf
argument_list|,
name|SLOP
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|(
name|op
operator|-
literal|1
operator|)
operator|!=
literal|'\n'
condition|)
do|;
name|m
operator|=
name|n
operator|=
name|vpos
expr_stmt|;
comment|/* = max/min vertical */
comment|/* position for curve */
while|while
condition|(
operator|*
operator|++
name|pop
operator|==
literal|' '
condition|)
empty_stmt|;
comment|/* skip '~'& blanks */
do|do
block|{
comment|/* calculate minimum */
name|hpos
operator|+=
name|atoi
argument_list|(
name|pop
argument_list|)
expr_stmt|;
comment|/* vertical */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|pop
argument_list|)
condition|)
empty_stmt|;
comment|/* position */
while|while
condition|(
operator|*
operator|++
name|pop
operator|==
literal|' '
condition|)
empty_stmt|;
name|vpos
operator|+=
name|atoi
argument_list|(
name|pop
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|pop
argument_list|)
condition|)
empty_stmt|;
while|while
condition|(
operator|*
name|pop
operator|==
literal|' '
condition|)
name|pop
operator|++
expr_stmt|;
if|if
condition|(
name|vpos
operator|<
name|n
condition|)
name|n
operator|=
name|vpos
expr_stmt|;
elseif|else
if|if
condition|(
name|vpos
operator|>
name|m
condition|)
name|m
operator|=
name|vpos
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|pop
operator|!=
literal|'\n'
condition|)
do|;
name|vlp
operator|->
name|u
operator|=
name|vlp
operator|->
name|v
operator|=
name|n
operator|<
literal|0
condition|?
literal|0
else|:
name|n
expr_stmt|;
name|vlp
operator|->
name|d
operator|=
name|m
expr_stmt|;
name|startspan
argument_list|(
name|vpos
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"unknown drawing command %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'s'
case|:
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|size
operator|=
name|getnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|up
operator|=
operator|(
name|size
operator|*
name|INCH
operator|)
operator|/
name|POINT
expr_stmt|;
comment|/* rough estimate */
name|down
operator|=
name|up
operator|/
literal|3
expr_stmt|;
comment|/* of max up/down */
break|break;
case|case
literal|'f'
case|:
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|font
operator|=
name|getnumber
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* absolute horizontal motion */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|hgoto
argument_list|(
name|ngetnumber
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"%d"
argument_list|,
name|hpos
argument_list|)
expr_stmt|;
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* reposition by page offset */
break|break;
case|case
literal|'h'
case|:
comment|/* relative horizontal motion */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|hmot
argument_list|(
name|getnumber
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* useless */
break|break;
case|case
literal|'V'
case|:
comment|/* absolute vertical motion */
name|vgoto
argument_list|(
name|ngetnumber
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|vmot
argument_list|(
name|ngetnumber
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* new page */
name|t_page
argument_list|(
name|ngetnumber
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|vpos
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* end of line */
name|hpos
operator|=
name|leftmarg
expr_stmt|;
case|case
literal|'#'
case|:
comment|/* comment */
case|case
literal|'x'
case|:
comment|/* device control */
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|op
operator|++
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
break|break;
default|default:
name|error
argument_list|(
operator|!
name|FATAL
argument_list|,
literal|"unknown input character %o %c\n"
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	setlimit  |  | Results:	using "up" and "down" set by point size changes, set the  |		maximum rise and/or fall of a vertical extent  |  | Side Efct:	may set vlp's u and/or d  |  | Bugs:	assumes all text of a particular point size is of the same  |		maximum rise fall above and below the text base line  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|setlimit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|upv
init|=
name|vpos
operator|-
name|up
decl_stmt|;
specifier|register
name|int
name|downv
init|=
name|vpos
operator|+
name|down
decl_stmt|;
if|if
condition|(
name|upv
operator|<
name|vlp
operator|->
name|u
condition|)
name|vlp
operator|->
name|u
operator|=
name|upv
expr_stmt|;
if|if
condition|(
name|downv
operator|>
name|vlp
operator|->
name|d
condition|)
name|vlp
operator|->
name|d
operator|=
name|downv
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------*  | Routine:	arcbounds (h, v, h1, v1)  |  | Results:	using the horizontal positions of the starting and ending  |		points relative to the center and vertically relative to  |		each other, arcbounds calculates the upper and lower extent  |		of the arc which is one of:  starting point, ending point  |		or center + rad for bottom, and center - rad for top.  |  | Side Efct:	sets vlp's v, u and d  *----------------------------------------------------------------------------*/
end_comment

begin_macro
name|arcbounds
argument_list|(
argument|h
argument_list|,
argument|v
argument_list|,
argument|h1
argument_list|,
argument|v1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|h
decl_stmt|,
name|v
decl_stmt|,
name|h1
decl_stmt|,
name|v1
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|rad
init|=
operator|(
call|(
name|int
call|)
argument_list|(
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
name|h
operator|*
name|h
operator|+
name|v
operator|*
name|v
argument_list|)
argument_list|)
operator|+
literal|0.5
argument_list|)
operator|)
operator|>>
literal|1
decl_stmt|;
specifier|register
name|int
name|i
init|=
operator|(
operator|(
name|h
operator|>=
literal|0
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|h1
operator|<
literal|0
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|v
operator|+
name|v1
operator|)
operator|<
literal|0
operator|)
decl_stmt|;
comment|/* i is a set of flags for the points being on the */
comment|/* left of the center point, and which is higher */
name|v1
operator|+=
name|vpos
operator|+
name|v
expr_stmt|;
comment|/* v1 is vertical position of ending point */
name|vlp
operator|->
name|v
operator|=
name|vpos
expr_stmt|;
comment|/* set vertical starting position of arc */
comment|/* test relative positions for maximums */
name|vlp
operator|->
name|u
operator|=
operator|(
operator|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|1
operator|)
condition|?
name|v1
else|:
operator|(
operator|(
operator|(
name|i
operator|&
literal|5
operator|)
operator|==
literal|4
operator|)
condition|?
name|vpos
else|:
name|vpos
operator|+
name|v
operator|-
name|rad
operator|)
operator|)
operator|-
name|thick
operator|/
literal|2
expr_stmt|;
name|vlp
operator|->
name|d
operator|=
operator|(
operator|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|2
operator|)
condition|?
name|v1
else|:
operator|(
operator|(
operator|(
name|i
operator|&
literal|5
operator|)
operator|==
literal|1
operator|)
condition|?
name|vpos
else|:
name|vpos
operator|+
name|v
operator|-
name|rad
operator|)
operator|)
operator|-
name|thick
operator|/
literal|2
expr_stmt|;
block|}
end_block

begin_macro
name|oflush
argument_list|()
end_macro

begin_comment
comment|/* sort, then dump out contents of obuf */
end_comment

begin_block
block|{
specifier|register
name|struct
name|vlist
modifier|*
name|vp
decl_stmt|;
specifier|register
name|int
name|notdone
decl_stmt|;
specifier|register
name|int
name|topv
decl_stmt|;
specifier|register
name|int
name|botv
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|compar
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"into oflush, V=%d\n"
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|op
operator|==
name|obuf
condition|)
return|return;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vlist
argument_list|,
name|nvlist
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vlist
argument_list|)
argument_list|,
name|compar
argument_list|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
literal|0
expr_stmt|;
name|topv
operator|=
literal|0
expr_stmt|;
name|botv
operator|=
name|NLINES
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|notdone
operator|=
literal|0
expr_stmt|;
name|vp
operator|=
name|vlist
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"topv=%d, botv=%d\n"
argument_list|,
name|topv
argument_list|,
name|botv
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvlist
condition|;
name|i
operator|++
operator|,
name|vp
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"u=%d, d=%d,%.60s\n"
argument_list|,
name|vp
operator|->
name|u
argument_list|,
name|vp
operator|->
name|d
argument_list|,
name|vp
operator|->
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vp
operator|->
name|u
operator|<=
name|botv
operator|&&
name|vp
operator|->
name|d
operator|>=
name|topv
condition|)
block|{
name|printf
argument_list|(
literal|"V%dH%ds%df%dDs%d\nDt%d\n"
argument_list|,
name|vp
operator|->
name|v
argument_list|,
name|vp
operator|->
name|h
argument_list|,
name|vp
operator|->
name|s
argument_list|,
name|vp
operator|->
name|f
argument_list|,
name|vp
operator|->
name|st
argument_list|,
name|vp
operator|->
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|vp
operator|->
name|p
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
name|notdone
operator||=
name|vp
operator|->
name|d
operator|>
name|botv
expr_stmt|;
comment|/* not done if there's still */
block|}
comment|/* something to put lower */
ifdef|#
directive|ifdef
name|DEBUGABLE
if|if
condition|(
name|dbg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"topv=%d, botv=%d\n"
argument_list|,
name|topv
argument_list|,
name|botv
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|notdone
condition|)
name|putchar
argument_list|(
literal|'P'
argument_list|)
expr_stmt|;
comment|/* mark the end of the spread */
name|topv
operator|+=
name|NLINES
expr_stmt|;
comment|/* unless it's the last one */
name|botv
operator|+=
name|NLINES
expr_stmt|;
block|}
do|while
condition|(
name|notdone
condition|)
do|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|vlp
operator|=
name|vlist
expr_stmt|;
name|vlp
operator|->
name|p
operator|=
name|op
operator|=
name|obuf
expr_stmt|;
name|vlp
operator|->
name|h
operator|=
name|hpos
expr_stmt|;
name|vlp
operator|->
name|v
operator|=
name|vpos
expr_stmt|;
name|vlp
operator|->
name|u
operator|=
name|vpos
expr_stmt|;
name|vlp
operator|->
name|d
operator|=
name|vpos
expr_stmt|;
name|vlp
operator|->
name|s
operator|=
name|size
expr_stmt|;
name|vlp
operator|->
name|f
operator|=
name|font
expr_stmt|;
name|vlp
operator|->
name|st
operator|=
name|style
expr_stmt|;
name|vlp
operator|->
name|t
operator|=
name|thick
expr_stmt|;
operator|*
name|op
operator|=
literal|0
expr_stmt|;
name|nvlist
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|compar
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vlist
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|p1
operator|->
name|v
operator|-
name|p2
operator|->
name|v
operator|)
return|;
block|}
end_block

begin_macro
name|done
argument_list|()
end_macro

begin_block
block|{
name|oflush
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|f
argument_list|,
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|,
argument|a6
argument_list|,
argument|a7
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vsort: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
name|done
argument_list|()
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|MAXSTATE
value|5
end_define

begin_struct
struct|struct
name|state
block|{
name|int
name|ssize
decl_stmt|;
name|int
name|sfont
decl_stmt|;
name|int
name|shpos
decl_stmt|;
name|int
name|svpos
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|state
name|state
index|[
name|MAXSTATE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|state
modifier|*
name|statep
init|=
name|state
decl_stmt|;
end_decl_stmt

begin_macro
name|t_push
argument_list|()
end_macro

begin_comment
comment|/* begin a new block */
end_comment

begin_block
block|{
name|statep
operator|->
name|ssize
operator|=
name|size
expr_stmt|;
name|statep
operator|->
name|sfont
operator|=
name|font
expr_stmt|;
name|statep
operator|->
name|shpos
operator|=
name|hpos
expr_stmt|;
name|statep
operator|->
name|svpos
operator|=
name|vpos
expr_stmt|;
name|hpos
operator|=
name|vpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|statep
operator|++
operator|>=
name|state
operator|+
name|MAXSTATE
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"{ nested too deep"
argument_list|)
expr_stmt|;
name|hpos
operator|=
name|vpos
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|t_pop
argument_list|()
end_macro

begin_comment
comment|/* pop to previous state */
end_comment

begin_block
block|{
if|if
condition|(
operator|--
name|statep
operator|<
name|state
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"extra }"
argument_list|)
expr_stmt|;
name|size
operator|=
name|statep
operator|->
name|ssize
expr_stmt|;
name|font
operator|=
name|statep
operator|->
name|sfont
expr_stmt|;
name|hpos
operator|=
name|statep
operator|->
name|shpos
expr_stmt|;
name|vpos
operator|=
name|statep
operator|->
name|svpos
expr_stmt|;
block|}
end_block

begin_comment
comment|/* vertical motion:  start new vertical span if necessary */
end_comment

begin_expr_stmt
name|vgoto
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|!=
name|vpos
condition|)
name|startspan
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|vpos
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_macro
name|t_page
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* flag to catch the 1st time through */
comment|/* if we're near the edge, we'll go over on */
if|if
condition|(
name|leftmarg
operator|+
literal|2
operator|*
operator|(
name|pageno
condition|?
name|leftmarg
operator|/
name|pageno
else|:
literal|0
operator|)
operator|>
name|WIDTH
comment|/* this page, */
operator|||
name|maxh
operator|>
name|WIDTH
operator|-
name|INCH
operator|||
name|first
condition|)
block|{
comment|/* or this is the first page */
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"p%d\n"
argument_list|,
name|spanno
operator|++
argument_list|)
expr_stmt|;
comment|/* make it a REAL page-break */
name|op
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|oflush
argument_list|()
expr_stmt|;
name|first
operator|=
name|pageno
operator|=
name|leftmarg
operator|=
name|maxh
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* x = last page's width (in half-inches) */
specifier|register
name|int
name|x
init|=
operator|(
name|maxh
operator|-
name|leftmarg
operator|+
operator|(
name|HALF
operator|-
literal|1
operator|)
operator|)
operator|/
name|HALF
decl_stmt|;
if|if
condition|(
name|x
operator|>
literal|11
operator|&&
name|x
operator|<=
literal|17
condition|)
name|leftmarg
operator|+=
operator|(
literal|8
operator|*
name|INCH
operator|)
operator|+
name|HALF
expr_stmt|;
comment|/* if close to 8.5"  */
else|else
comment|/* then make it so   */
name|leftmarg
operator|=
operator|(
operator|(
name|maxh
operator|+
name|HALF
operator|)
operator|/
name|HALF
operator|)
operator|*
name|HALF
expr_stmt|;
comment|/* else set it to the */
name|pageno
operator|++
expr_stmt|;
comment|/* nearest half-inch */
block|}
block|}
end_block

begin_expr_stmt
name|startspan
argument_list|(
name|n
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|*
name|op
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nvlist
operator|>=
name|NVLIST
condition|)
block|{
name|oflush
argument_list|()
expr_stmt|;
block|}
name|vlp
operator|++
expr_stmt|;
name|vlp
operator|->
name|p
operator|=
name|op
expr_stmt|;
name|vlp
operator|->
name|v
operator|=
name|n
expr_stmt|;
name|vlp
operator|->
name|d
operator|=
name|n
expr_stmt|;
name|vlp
operator|->
name|u
operator|=
name|n
expr_stmt|;
name|vlp
operator|->
name|h
operator|=
name|hpos
expr_stmt|;
name|vlp
operator|->
name|s
operator|=
name|size
expr_stmt|;
name|vlp
operator|->
name|f
operator|=
name|font
expr_stmt|;
name|vlp
operator|->
name|st
operator|=
name|style
expr_stmt|;
name|vlp
operator|->
name|t
operator|=
name|thick
expr_stmt|;
name|nvlist
operator|++
expr_stmt|;
block|}
end_block

end_unit

