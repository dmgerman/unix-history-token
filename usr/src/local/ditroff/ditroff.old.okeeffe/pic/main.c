begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* main.c	(Berkeley)	1.9	86/03/11	*/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"pic.h"
end_include

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_include
include|#
directive|include
file|"dev.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DEVDIR
end_ifndef

begin_define
define|#
directive|define
name|DEVDIR
value|"/usr/lib/font"
end_define

begin_comment
comment|/* place to look up device files */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|devdir
init|=
name|DEVDIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dev
init|=
literal|"va"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default typesetter is varian */
end_comment

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|obj
modifier|*
name|objlist
index|[
name|MAXOBJ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* store the elements here */
end_comment

begin_decl_stmt
name|int
name|nobj
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|attr
name|attr
index|[
literal|40
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* attributes stored here as collected */
end_comment

begin_decl_stmt
name|int
name|nattr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of entries in attr_list */
end_comment

begin_decl_stmt
name|struct
name|text
name|text
index|[
name|MAXTEXT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* text strings stored here as collected */
end_comment

begin_decl_stmt
name|int
name|ntext
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ntext1
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* record ntext here on entry to each figure */
end_comment

begin_decl_stmt
name|float
name|curx
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|cury
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hvmode
init|=
name|R_DIR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* R => join left to right, D => top to bottom, etc. */
end_comment

begin_decl_stmt
name|int
name|codegen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1=>output for this picture; 0=>no output */
end_comment

begin_decl_stmt
name|float
name|deltx
init|=
literal|6.0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max x value in output, for scaling */
end_comment

begin_decl_stmt
name|float
name|delty
init|=
literal|6.0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max y value in output, for scaling */
end_comment

begin_decl_stmt
name|float
name|xbound
init|=
literal|8.0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max allowed x value in output */
end_comment

begin_decl_stmt
name|float
name|ybound
init|=
literal|10.0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max allowed y value in output */
end_comment

begin_decl_stmt
name|int
name|dbg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|yyin
decl_stmt|,
comment|/* input file pointer */
modifier|*
name|skeldb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output pointer for dbg messeges */
end_comment

begin_decl_stmt
name|int
name|lineno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|filename
init|=
literal|"-"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|synerr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cmdname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|crop
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trim off exterior white space if non-zero */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|useDline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, use \D for all lines */
end_comment

begin_decl_stmt
name|int
name|res
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* resolution of output device (dots/inch) */
end_comment

begin_decl_stmt
name|int
name|DX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* smallest change in X, and Y for output device */
end_comment

begin_decl_stmt
name|int
name|DY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|hshift
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* move this far left for text (in em's) */
end_comment

begin_decl_stmt
name|float
name|vshift
init|=
literal|0.2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* this far down */
end_comment

begin_decl_stmt
name|float
name|sxmin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lower limit from s command */
end_comment

begin_decl_stmt
name|float
name|symin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|sxmax
init|=
literal|4096
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* upper */
end_comment

begin_decl_stmt
name|float
name|symax
init|=
literal|4096
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|xmin
init|=
literal|30000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* min values found in actual data */
end_comment

begin_decl_stmt
name|float
name|ymin
init|=
literal|30000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|xmax
init|=
operator|-
literal|30000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max */
end_comment

begin_decl_stmt
name|float
name|ymax
init|=
operator|-
literal|30000
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"PRINTER"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|dev
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"TYPESETTER"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|dev
operator|=
name|cp
expr_stmt|;
name|cmdname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
operator|*
name|argv
index|[
literal|1
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'F'
case|:
name|devdir
operator|=
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
case|case
literal|'P'
case|:
name|dev
operator|=
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dbg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|useDline
operator|=
operator|!
name|useDline
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|xbound
operator|=
name|atof
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|ybound
operator|=
name|atof
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|fileinit
argument_list|()
expr_stmt|;
name|setdefaults
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
block|{
name|yyin
operator|=
name|stdin
expr_stmt|;
name|getdata
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
name|argc
operator|--
operator|>
literal|1
condition|)
block|{
name|filename
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
operator|(
name|yyin
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|filename
index|[
literal|1
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pic: can't open %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yyin
operator|=
name|stdin
expr_stmt|;
name|filename
operator|=
literal|"standard input"
expr_stmt|;
block|}
block|}
name|getdata
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|synerr
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|fileinit
argument_list|()
end_macro

begin_block
block|{
name|int
name|fin
decl_stmt|;
name|struct
name|dev
name|device
decl_stmt|;
name|char
name|temp
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/dev%s/DESC.out"
argument_list|,
name|devdir
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|open
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't open tables for %s\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|read
argument_list|(
name|fin
argument_list|,
operator|&
name|device
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|device
operator|.
name|res
expr_stmt|;
name|DX
operator|=
name|device
operator|.
name|hor
expr_stmt|;
name|DY
operator|=
name|device
operator|.
name|vert
expr_stmt|;
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
end_block

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|float
name|val
decl_stmt|;
block|}
name|defaults
index|[]
init|=
block|{
literal|"scale"
block|,
name|SCALE
block|,
literal|"lineht"
block|,
name|HT
block|,
literal|"linewid"
block|,
name|HT
block|,
literal|"moveht"
block|,
name|HT
block|,
literal|"movewid"
block|,
name|HT
block|,
literal|"dashwid"
block|,
name|HT10
block|,
literal|"boxht"
block|,
name|HT
block|,
literal|"boxwid"
block|,
name|WID
block|,
literal|"circlerad"
block|,
name|HT2
block|,
literal|"arcrad"
block|,
name|HT2
block|,
literal|"ellipseht"
block|,
name|HT
block|,
literal|"ellipsewid"
block|,
name|WID
block|,
literal|"arrowht"
block|,
name|HT5
block|,
literal|"arrowwid"
block|,
name|HT10
block|,
literal|"textht"
block|,
name|HT
block|,
literal|"textwid"
block|,
name|WID
block|,
name|NULL
block|,
literal|0
block|}
struct|;
end_struct

begin_macro
name|setdefaults
argument_list|()
end_macro

begin_comment
comment|/* set default sizes for variables like boxht */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|;
name|YYSTYPE
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|defaults
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|.
name|f
operator|=
name|defaults
index|[
name|i
index|]
operator|.
name|val
expr_stmt|;
name|makevar
argument_list|(
name|tostring
argument_list|(
name|defaults
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|,
name|VARNAME
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|checkscale
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* if s is "scale", adjust default variables */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|float
name|scale
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"scale"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|scale
operator|=
name|getfval
argument_list|(
literal|"scale"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|defaults
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|setfval
argument_list|(
name|defaults
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|defaults
index|[
name|i
index|]
operator|.
name|val
operator|*
name|scale
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|getdata
argument_list|(
name|fin
argument_list|)
specifier|register
name|FILE
operator|*
name|fin
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|1000
index|]
decl_stmt|,
name|buf1
index|[
literal|50
index|]
decl_stmt|;
name|FILE
modifier|*
name|svyyin
decl_stmt|;
name|int
name|svlineno
decl_stmt|;
name|char
modifier|*
name|svfilename
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'.'
operator|&&
operator|*
operator|(
name|buf
operator|+
literal|1
operator|)
operator|==
literal|'P'
operator|&&
operator|*
operator|(
name|buf
operator|+
literal|2
operator|)
operator|==
literal|'S'
condition|)
block|{
for|for
control|(
name|p
operator|=
operator|&
name|buf
index|[
literal|3
index|]
init|;
operator|*
name|p
operator|==
literal|' '
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'<'
condition|)
block|{
name|svyyin
operator|=
name|yyin
expr_stmt|;
name|svlineno
operator|=
name|lineno
expr_stmt|;
name|svfilename
operator|=
name|filename
expr_stmt|;
name|sscanf
argument_list|(
name|p
argument_list|,
literal|"%s"
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|yyin
operator|=
name|fopen
argument_list|(
name|buf1
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pic: can't open %s\n"
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|lineno
operator|=
literal|0
expr_stmt|;
name|filename
operator|=
name|p
expr_stmt|;
name|getdata
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|svlineno
expr_stmt|;
name|yyin
operator|=
name|svyyin
expr_stmt|;
name|filename
operator|=
name|svfilename
expr_stmt|;
continue|continue;
block|}
name|reset
argument_list|()
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
comment|/* yylval now contains 'E' or 'F' from .PE or .PF */
if|if
condition|(
name|buf
index|[
literal|3
index|]
operator|==
literal|' '
condition|)
comment|/* assume next thing is width */
name|deltx
operator|=
name|delty
operator|=
name|atof
argument_list|(
operator|&
name|buf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|deltx
operator|=
name|xmax
operator|-
name|xmin
expr_stmt|;
if|if
condition|(
name|deltx
operator|<=
literal|0
condition|)
name|deltx
operator|=
name|ymax
operator|-
name|ymin
expr_stmt|;
name|deltx
operator|/=
name|getfval
argument_list|(
literal|"scale"
argument_list|)
expr_stmt|;
name|delty
operator|=
name|deltx
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|"deltx = %.3f\n"
argument_list|,
name|deltx
argument_list|)
expr_stmt|;
if|if
condition|(
name|codegen
operator|&&
operator|!
name|synerr
condition|)
block|{
name|openpl
argument_list|(
operator|&
name|buf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* puts out .PS, with ht& wid stuck in */
name|print
argument_list|()
expr_stmt|;
comment|/* assumes \n at end */
name|closepl
argument_list|(
name|yylval
operator|.
name|p
argument_list|)
expr_stmt|;
comment|/* does the .PE/F */
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|reset
argument_list|()
end_macro

begin_block
block|{
name|struct
name|obj
modifier|*
name|op
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
specifier|extern
name|int
name|nstack
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nobj
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|objlist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|o_type
operator|==
name|BLOCK
condition|)
name|freesymtab
argument_list|(
name|op
operator|->
name|o_dotdash
argument_list|)
expr_stmt|;
comment|/* funny place */
name|free
argument_list|(
name|objlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|nobj
operator|=
literal|0
expr_stmt|;
name|nattr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntext
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|text
index|[
name|i
index|]
operator|.
name|t_val
argument_list|)
expr_stmt|;
name|ntext
operator|=
name|ntext1
operator|=
literal|0
expr_stmt|;
name|codegen
operator|=
name|synerr
operator|=
literal|0
expr_stmt|;
name|nstack
operator|=
literal|0
expr_stmt|;
name|curx
operator|=
name|cury
operator|=
literal|0
expr_stmt|;
name|hvmode
operator|=
name|R_DIR
expr_stmt|;
name|sxmin
operator|=
name|symin
operator|=
literal|0
expr_stmt|;
name|sxmax
operator|=
name|symax
operator|=
literal|4096
expr_stmt|;
name|xmin
operator|=
name|ymin
operator|=
literal|30000
expr_stmt|;
name|xmax
operator|=
name|ymax
operator|=
operator|-
literal|30000
expr_stmt|;
block|}
end_block

end_unit

