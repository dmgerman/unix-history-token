begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)db1.c	1.2	%G%  *  * Copyright -C- 1982 Barry S. Roitblat  *  *      This file contains routines for database manipulation for the  * gremlin picture editor.  */
end_comment

begin_include
include|#
directive|include
file|"gremlin.h"
end_include

begin_include
include|#
directive|include
file|"grem2.h"
end_include

begin_comment
comment|/* imports from undodb */
end_comment

begin_extern
extern|extern UNRembAdd(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|UNRembDelete
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* imports from c */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|sprintf
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* imports from point.c */
end_comment

begin_function_decl
specifier|extern
name|POINT
modifier|*
name|PTInit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|POINT
modifier|*
name|PTMakePoint
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* imports from textio.c  */
end_comment

begin_extern
extern|extern TxPutMsg(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|TxMsgOK
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* imports from main */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|SEARCH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Search the path for filename ?? */
end_comment

begin_function
name|ELT
modifier|*
name|DBInit
parameter_list|()
comment|/*  *      This routine returns a pointer to an initialized database element  * which would be the only element in an empty list.  */
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end DBInit */
end_comment

begin_decl_stmt
name|ELT
modifier|*
name|DBCreateElt
argument_list|(
name|type
argument_list|,
name|pointlist
argument_list|,
name|brush
argument_list|,
name|size
argument_list|,
name|text
argument_list|,
name|db
argument_list|)
name|int
name|type
decl_stmt|,
name|brush
decl_stmt|,
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|POINT
modifier|*
name|pointlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|text
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ELT
argument_list|*
operator|(
operator|*
name|db
operator|)
argument_list|;
comment|/*  *      This routine creates a new element with the specified attributes and  * links it into database.  */
block|{
name|ELT
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|ELT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ELT
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|nextelt
operator|=
operator|*
name|db
expr_stmt|;
name|temp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|temp
operator|->
name|ptlist
operator|=
name|pointlist
expr_stmt|;
name|temp
operator|->
name|brushf
operator|=
name|brush
expr_stmt|;
name|temp
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|temp
operator|->
name|textpt
operator|=
name|text
expr_stmt|;
operator|*
name|db
operator|=
name|temp
expr_stmt|;
name|UNRembAdd
argument_list|(
name|temp
argument_list|,
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/* end CreateElt */
end_comment

begin_macro
name|DBDelete
argument_list|(
argument|element
argument_list|,
argument|db
argument_list|)
end_macro

begin_decl_stmt
name|ELT
modifier|*
name|element
decl_stmt|,
modifier|*
argument_list|(
operator|*
name|db
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine deletes the specified element by searching the database  * for its predecessor and deleting the pointer to the element.  * Flag indicates whether or not the element was in the current set  * and is passed along for use by the undo routines.  */
end_comment

begin_block
block|{
name|ELT
argument_list|*
operator|(
operator|*
name|temp
operator|)
argument_list|;
name|temp
operator|=
name|db
argument_list|;     while
operator|(
operator|*
name|temp
operator|!=
name|element
operator|)
block|{
if|if
condition|(
name|DBNullelt
argument_list|(
operator|*
name|temp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"no such element"
argument_list|)
expr_stmt|;
return|return;
block|}
argument_list|;
name|temp
operator|=
operator|&
operator|(
name|DBNextElt
argument_list|(
operator|(
operator|*
name|temp
operator|)
argument_list|)
operator|)
argument_list|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|UNRembDelete
argument_list|(
operator|*
name|temp
argument_list|,
name|db
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|temp
operator|=
name|DBNextElt
argument_list|(
name|element
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* end DBDelete */
end_comment

begin_define
define|#
directive|define
name|highval
value|10000
end_define

begin_comment
comment|/* arbitrary value greater than any                                       * expected distance                */
end_comment

begin_expr_stmt
unit|DBGravitate
operator|(
name|x1
operator|,
name|y1
operator|,
name|x2
operator|,
name|y2
operator|,
name|point
operator|,
name|element
operator|,
name|db
operator|)
name|float
name|x1
operator|,
name|y1
operator|,
operator|*
name|x2
operator|,
operator|*
name|y2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|POINT
argument_list|*
operator|(
operator|*
name|point
operator|)
argument_list|;
name|ELT
operator|*
operator|(
operator|*
name|element
operator|)
argument_list|,
operator|*
name|db
argument_list|;
comment|/*  *      This routine searches the database for the point closest to  * (Euclidean distance) point1.  This point is returned as point2  * and the element which contained the point is also returned.  * The point must be closer than some predefined maximum distance  * in order to be gravitated.  */
block|{
name|POINT
modifier|*
name|holdpt
decl_stmt|;
name|ELT
modifier|*
name|temp
decl_stmt|;
name|long
name|int
name|t
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|distance
init|=
name|highval
decl_stmt|;
name|temp
operator|=
name|db
expr_stmt|;
operator|*
name|element
operator|=
name|DBInit
argument_list|()
expr_stmt|;
operator|*
name|x2
operator|=
name|x1
expr_stmt|;
operator|*
name|y2
operator|=
name|y1
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|holdpt
operator|=
name|temp
operator|->
name|ptlist
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|holdpt
argument_list|)
condition|)
block|{
comment|/*  Calculate the distance between the point in the data                  * base and the specified point.  Use Euclidean distance                  * except that, since we only need relative distance and                  * not an absolute number, it is not necessary to take the                  * square root.  The equation for the distance was broken up                  * as below in order to allow integer arithmetic wherever                  * possible to increase efficiency when it was discovered                  * that this routine was too slow.                  */
name|t1
operator|=
name|holdpt
operator|->
name|x
operator|-
name|x1
expr_stmt|;
name|t1
operator|*=
name|t1
expr_stmt|;
name|t2
operator|=
name|holdpt
operator|->
name|y
operator|-
name|y1
expr_stmt|;
name|t2
operator|*=
name|t2
expr_stmt|;
name|t
operator|=
name|t1
operator|+
name|t2
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|<
name|distance
operator|)
operator|&&
operator|(
name|t
operator|<
name|MAXGDIST
operator|)
condition|)
block|{
name|distance
operator|=
name|t
expr_stmt|;
operator|*
name|x2
operator|=
name|holdpt
operator|->
name|x
expr_stmt|;
operator|*
name|y2
operator|=
name|holdpt
operator|->
name|y
expr_stmt|;
operator|*
name|point
operator|=
name|holdpt
expr_stmt|;
operator|*
name|element
operator|=
name|temp
expr_stmt|;
block|}
comment|/* end if */
empty_stmt|;
name|holdpt
operator|=
name|holdpt
operator|->
name|nextpt
expr_stmt|;
block|}
comment|/* end while holdpt */
empty_stmt|;
name|temp
operator|=
name|temp
operator|->
name|nextelt
expr_stmt|;
block|}
comment|/* end while temp */
empty_stmt|;
block|}
end_expr_stmt

begin_comment
comment|/* end Gravitate */
end_comment

begin_macro
name|DBSetGravitate
argument_list|(
argument|x1
argument_list|,
argument|y1
argument_list|,
argument|x2
argument_list|,
argument|y2
argument_list|,
argument|point
argument_list|,
argument|element
argument_list|,
argument|db
argument_list|)
end_macro

begin_decl_stmt
name|float
name|x1
decl_stmt|,
name|y1
decl_stmt|,
modifier|*
name|x2
decl_stmt|,
modifier|*
name|y2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|POINT
argument_list|*
operator|(
operator|*
name|point
operator|)
argument_list|;
name|ELT
operator|*
operator|(
operator|*
name|element
operator|)
argument_list|,
operator|*
name|db
argument_list|;
comment|/*  *      This routine searches the database for the point closest to  * (Euclidean distance) point1.  This point is returned as point2  * and the element which contained the point is also returned.  * The point must be closer than some predefined maximum distance  * in order to be gravitated.  */
block|{
name|POINT
modifier|*
name|holdpt
decl_stmt|;
name|ELT
modifier|*
name|temp
decl_stmt|;
name|long
name|int
name|t
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|distance
init|=
name|highval
decl_stmt|;
name|temp
operator|=
name|db
expr_stmt|;
operator|*
name|element
operator|=
name|DBInit
argument_list|()
expr_stmt|;
operator|*
name|x2
operator|=
name|x1
expr_stmt|;
operator|*
name|y2
operator|=
name|y1
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|holdpt
operator|=
name|temp
operator|->
name|ptlist
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|holdpt
argument_list|)
condition|)
block|{
comment|/*  Calculate the distance between the point in the data                  * base and the specified point.  Use Euclidean distance                  * except that, since we only need relative distance and                  * not an absolute number, it is not necessary to take the                  * square root.  The equation for the distance was broken up                  * as below in order to allow integer arithmetic wherever                  * possible to increase efficiency when it was discovered                  * that this routine was too slow.                  */
name|t1
operator|=
name|holdpt
operator|->
name|x
operator|-
name|x1
expr_stmt|;
name|t1
operator|*=
name|t1
expr_stmt|;
name|t2
operator|=
name|holdpt
operator|->
name|y
operator|-
name|y1
expr_stmt|;
name|t2
operator|*=
name|t2
expr_stmt|;
name|t
operator|=
name|t1
operator|+
name|t2
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|<
name|distance
operator|)
operator|&&
operator|(
name|t
operator|<
name|MAXGDIST
operator|)
condition|)
block|{
name|distance
operator|=
name|t
expr_stmt|;
operator|*
name|x2
operator|=
name|holdpt
operator|->
name|x
expr_stmt|;
operator|*
name|y2
operator|=
name|holdpt
operator|->
name|y
expr_stmt|;
operator|*
name|point
operator|=
name|holdpt
expr_stmt|;
operator|*
name|element
operator|=
name|temp
expr_stmt|;
block|}
comment|/* end if */
empty_stmt|;
name|holdpt
operator|=
name|holdpt
operator|->
name|nextpt
expr_stmt|;
block|}
comment|/* end while holdpt */
empty_stmt|;
name|temp
operator|=
name|temp
operator|->
name|setnext
expr_stmt|;
block|}
comment|/* end while temp */
empty_stmt|;
block|}
end_expr_stmt

begin_comment
comment|/* end Gravitate */
end_comment

begin_macro
name|DBClearElt
argument_list|(
argument|elt
argument_list|)
end_macro

begin_decl_stmt
name|ELT
modifier|*
name|elt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine returns all storage associated with the element to  * free storage  */
end_comment

begin_block
block|{
name|POINT
modifier|*
name|pt
decl_stmt|,
modifier|*
name|pt2
decl_stmt|;
name|pt
operator|=
name|elt
operator|->
name|ptlist
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|pt
argument_list|)
condition|)
block|{
name|pt2
operator|=
name|PTNextPoint
argument_list|(
name|pt
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pt
argument_list|)
expr_stmt|;
name|pt
operator|=
name|pt2
expr_stmt|;
block|}
comment|/* end while */
empty_stmt|;
name|free
argument_list|(
name|elt
operator|->
name|textpt
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|elt
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end DBClearElt */
end_comment

begin_function
name|ELT
modifier|*
name|DBRead
parameter_list|(
name|filename
parameter_list|,
name|orient
parameter_list|,
name|pos
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
modifier|*
name|orient
decl_stmt|;
name|POINT
modifier|*
name|pos
decl_stmt|;
comment|/*  *      This routine reads the specified file into a database and   * returns a pointer to that database.  Orient and pos are also set  * from the file.  *  * The format of a file written by gremlin is:  * the string: "gremlinfile" followed by a carriage return.  * the orientation (integer) and the x and y coordinates of a positioning  * point (float) followed by another carriage return.  * The output of 0 or more elements (see below).  * a -1 (integer) indicating end of data.  *  * The format of each element is:  * The element type (integer) followed by a carriage return.  * a list of 0 or more pairs of point coordinates (float) each on separate  * lines and terminated by the coordinates -1.0 -1.0.  * the brush (font) and size (integer) the element was defined with then<cr>  * the length (integer) of the string followed by the string terminated with  * a carriage return.  *  * All numbers are printed using standard c output conversion (ascii).  */
block|{
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|POpen
argument_list|()
decl_stmt|;
name|ELT
modifier|*
name|elist
decl_stmt|;
name|POINT
modifier|*
name|plist
decl_stmt|;
name|char
name|string
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|txt
decl_stmt|;
name|float
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|len
decl_stmt|,
name|type
decl_stmt|,
name|i
decl_stmt|,
name|brush
decl_stmt|,
name|size
decl_stmt|,
name|done
decl_stmt|;
name|elist
operator|=
name|DBInit
argument_list|()
expr_stmt|;
name|fp
operator|=
name|POpen
argument_list|(
name|filename
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
name|SEARCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"can't open %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
name|elist
operator|)
return|;
block|}
name|TxPutMsg
argument_list|(
literal|"reading file..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"gremlinfile"
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"not gremlin file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|elist
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d%f%f"
argument_list|,
name|orient
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|pos
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|pos
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|done
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|type
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|error
argument_list|(
literal|"error in file format"
argument_list|)
expr_stmt|;
return|return
operator|(
name|elist
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|<
literal|0
condition|)
comment|/* no more data */
block|{
name|done
operator|=
name|TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%f%f"
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|plist
operator|=
name|PTInit
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|x
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|y
operator|!=
operator|-
literal|1
operator|)
condition|)
comment|/* pointlist terminated by -1, -1 */
block|{
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|plist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%f%f"
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d%d"
argument_list|,
operator|&
name|brush
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|txt
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* throw away space character */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|txt
index|[
name|i
index|]
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|txt
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|DBCreateElt
argument_list|(
name|type
argument_list|,
name|plist
argument_list|,
name|brush
argument_list|,
name|size
argument_list|,
name|txt
argument_list|,
operator|&
name|elist
argument_list|)
expr_stmt|;
block|}
comment|/* end else */
block|}
comment|/* end while not done */
empty_stmt|;
name|TxMsgOK
argument_list|()
expr_stmt|;
return|return
operator|(
name|elist
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end DBRead */
end_comment

begin_macro
name|DBBounded
argument_list|(
argument|elt
argument_list|,
argument|x1
argument_list|,
argument|y1
argument_list|,
argument|x2
argument_list|,
argument|y2
argument_list|)
end_macro

begin_decl_stmt
name|ELT
modifier|*
name|elt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine returns true if all points in elt are bounded by  * the rectangle who diagonal is formed by (x1, y1) and (x2, y2).  */
end_comment

begin_block
block|{
name|POINT
modifier|*
name|p1
decl_stmt|;
name|float
name|lox
decl_stmt|,
name|loy
decl_stmt|,
name|hix
decl_stmt|,
name|hiy
decl_stmt|;
name|lox
operator|=
operator|(
name|x1
operator|<
name|x2
operator|)
condition|?
name|x1
else|:
name|x2
expr_stmt|;
name|loy
operator|=
operator|(
name|y1
operator|<
name|y2
operator|)
condition|?
name|y1
else|:
name|y2
expr_stmt|;
name|hix
operator|=
operator|(
name|x1
operator|>
name|x2
operator|)
condition|?
name|x1
else|:
name|x2
expr_stmt|;
name|hiy
operator|=
operator|(
name|y1
operator|>
name|y2
operator|)
condition|?
name|y1
else|:
name|y2
expr_stmt|;
name|p1
operator|=
name|elt
operator|->
name|ptlist
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|p1
argument_list|)
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|x
operator|<
name|lox
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|x
operator|>
name|hix
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|y
operator|<
name|loy
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|y
operator|>
name|hiy
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
empty_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/* end DBBounded */
end_comment

end_unit

