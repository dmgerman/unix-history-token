begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)path.c	1.2	%G%  *  * Copyright -C- 1982 Barry S. Roitblat  *  *  * This file contains routines that a) implement a path mechanism, whereby  * several places may be searched for files, and b) provide a defaulting  * mechanism for file name extensions.  *  * (modified from code originally written by John Ousterhout for the caesar  *  design system)  */
end_comment

begin_include
include|#
directive|include
file|"gremlin.h"
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Imports from config.c: */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|GLibrary
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Library routines: */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|strcpyn
argument_list|()
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|sprintf
argument_list|()
decl_stmt|,
modifier|*
name|malloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following string holds the current path,which consists of a bunch  * of directory names separated by spaces.  */
end_comment

begin_define
define|#
directive|define
name|PATHSIZE
value|400
end_define

begin_decl_stmt
specifier|static
name|char
name|path
index|[
name|PATHSIZE
index|]
init|=
literal|"."
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following string pointers constitute a cache of recently  * referenced tilde names.  */
end_comment

begin_define
define|#
directive|define
name|NTILDE
value|10
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tildename
index|[
name|NTILDE
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|realname
index|[
name|NTILDE
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|discard
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|PConvertTilde
parameter_list|(
name|psource
parameter_list|,
name|pdest
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
modifier|*
name|psource
decl_stmt|;
comment|/* Pointer to a pointer to the source string */
name|char
modifier|*
modifier|*
name|pdest
decl_stmt|;
comment|/* Pointer to a pointer to the dest. string */
name|int
modifier|*
name|size
decl_stmt|;
comment|/* Pointer to no. bytes available at pdest */
comment|/*---------------------------------------------------------  *	This routine converts tilde notation into standard directory names.  *  *	Results:  *	If the conversion was done successfully, then TRUE is returned.  *	If a user name couldn't be found in the password file, then  *	FALSE is returned.  *  *	Side Effects:  *	If the first character of the string indicated by psource is a  *	tilde ("~") then the subsequent user name is converted to a login  *	directory name and stored in the string indicated by pdest.  Then  *	remaining characters in the file name at psource are copied to  *	pdest and both pointers are updated.  Upon return, psource points  *	to the terminating character in the source file name and pdest  *	points to the next character after the last character in the file  *	name at that location.  If a tilde cannot be converted because the  *	user name cannot be found, psource is still advanced past the current  *	entry, but pdest is unaffected.  At most size characters will be  *	stored at pdest, and the size is decremented by the number of  *	characters we actually stored.  *---------------------------------------------------------  */
block|{
specifier|register
name|char
modifier|*
name|ps
decl_stmt|,
modifier|*
name|pd
decl_stmt|;
name|struct
name|passwd
modifier|*
name|passwd
decl_stmt|,
modifier|*
name|getpwnam
argument_list|()
decl_stmt|;
name|char
name|username
index|[
literal|17
index|]
decl_stmt|,
modifier|*
name|string
decl_stmt|;
name|int
name|i
decl_stmt|,
name|length
decl_stmt|;
name|ps
operator|=
operator|*
name|psource
expr_stmt|;
if|if
condition|(
operator|*
name|ps
operator|==
literal|'~'
condition|)
block|{
comment|/* Copy the user name into a string (at most 16 characters). 	 * If we don't have a cached entry for this name, then 	 * read the password file entry for the user and grab out  	 * the login directory. 	 */
name|pd
operator|=
name|username
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|pd
operator|=
operator|*
operator|++
name|ps
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|pd
argument_list|)
operator|||
operator|(
operator|*
name|pd
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|pd
operator|==
literal|'/'
operator|)
operator|||
operator|(
operator|*
name|pd
operator|==
literal|':'
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|16
condition|)
name|pd
operator|++
expr_stmt|;
block|}
operator|*
name|pd
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTILDE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tildename
index|[
name|i
index|]
argument_list|,
name|username
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string
operator|=
name|realname
index|[
name|i
index|]
expr_stmt|;
goto|goto
name|gotname
goto|;
block|}
block|}
comment|/* Since we don't have a cached entry, read the password file 	 * and make a new cache entry for this one.  Note that this 	 * means discarding an old entry. 	 */
name|passwd
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|string
operator|=
name|passwd
operator|->
name|pw_dir
expr_stmt|;
if|if
condition|(
name|passwd
operator|!=
name|NULL
condition|)
block|{
name|discard
operator|++
expr_stmt|;
if|if
condition|(
name|discard
operator|>=
name|NTILDE
condition|)
name|discard
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tildename
index|[
name|discard
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tildename
index|[
name|discard
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|realname
index|[
name|discard
index|]
argument_list|)
expr_stmt|;
block|}
name|tildename
index|[
name|discard
index|]
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|username
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tildename
index|[
name|discard
index|]
argument_list|,
name|username
argument_list|)
expr_stmt|;
name|realname
index|[
name|discard
index|]
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|realname
index|[
name|discard
index|]
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* The entry can't be found, so skip the source entry and return */
block|{
while|while
condition|(
operator|(
operator|*
name|ps
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|ps
argument_list|)
operator|&&
operator|(
operator|*
name|ps
operator|!=
literal|':'
operator|)
condition|)
name|ps
operator|++
expr_stmt|;
operator|*
name|psource
operator|=
name|ps
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|gotname
label|:
name|length
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
operator|*
name|size
condition|)
name|length
operator|=
operator|*
name|size
expr_stmt|;
name|strcpyn
argument_list|(
operator|*
name|pdest
argument_list|,
name|string
argument_list|,
name|length
argument_list|)
expr_stmt|;
operator|*
name|size
operator|-=
name|length
expr_stmt|;
name|pd
operator|=
operator|*
name|pdest
operator|+
name|length
expr_stmt|;
block|}
else|else
name|pd
operator|=
operator|*
name|pdest
expr_stmt|;
comment|/* Copy the rest of the directory name from the source to the dest. */
while|while
condition|(
operator|(
operator|*
name|ps
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|ps
argument_list|)
operator|&&
operator|(
operator|*
name|ps
operator|!=
literal|':'
operator|)
condition|)
if|if
condition|(
operator|*
name|size
operator|>
literal|0
condition|)
block|{
operator|*
name|pd
operator|++
operator|=
operator|*
name|ps
operator|++
expr_stmt|;
operator|(
operator|*
name|size
operator|)
operator|--
expr_stmt|;
block|}
else|else
name|ps
operator|++
expr_stmt|;
operator|*
name|psource
operator|=
name|ps
expr_stmt|;
operator|*
name|pdest
operator|=
name|pd
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|int
name|PSetPath
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
comment|/* Pointer to a string that is to become 				 * the new fle search path.  Must consist 				 * of one or more directory names separated 				 * by white space or colons.  Two adjacent 				 * colons are the same as ":.:".  Tilde 				 * notation is ok. 				 */
comment|/*---------------------------------------------------------  *	PSetPath sets up the current search path.  *  *	Results:  *	-1 is returned if one or more of the paths contained a tilde  *	notation that couldn't be converted.  -2 is returned if the  *	path space was exhausted.  Otherwise a value>= 0 is returned.  *  *	Side Effects:  *	The string is stored as the current path, and all entries with  *	tilde notation are converted to non-tilde notation.  Tilde entries  *	that cannot be converted are ignored.  Note:  only PATHSIZE total  *	bytes of path are stored, after tilde conversion.  Excess bytes  *	are truncated.  *---------------------------------------------------------  */
block|{
name|int
name|result
decl_stmt|,
name|spaceleft
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|spaceleft
operator|=
name|PATHSIZE
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|path
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'\0'
condition|)
block|{
name|path
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|path
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
operator|*
name|string
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|string
operator|==
literal|':'
condition|)
if|if
condition|(
operator|(
operator|*
operator|++
name|string
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|spaceleft
operator|>=
literal|2
operator|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|spaceleft
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|spaceleft
operator|<=
literal|0
condition|)
break|break;
while|while
condition|(
operator|(
operator|*
name|string
operator|==
literal|':'
operator|)
operator|||
name|isspace
argument_list|(
operator|*
name|string
argument_list|)
condition|)
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|PConvertTilde
argument_list|(
operator|&
name|string
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|spaceleft
argument_list|)
condition|)
name|result
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|spaceleft
operator|--
operator|>
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|spaceleft
operator|<
literal|2
condition|)
return|return
operator|-
literal|2
return|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|PGetPath
parameter_list|()
comment|/*---------------------------------------------------------  *	This routine merely returns a poiner to the current path.  *  *	Results:  *	The address of the current path (with all tildes expanded).  *  *	Side Effects:	None.  *---------------------------------------------------------  */
block|{
return|return
name|path
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|POpen
parameter_list|(
name|file
parameter_list|,
name|prealname
parameter_list|,
name|search
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
comment|/* Name of the file to be opened. */
name|char
modifier|*
modifier|*
name|prealname
decl_stmt|;
comment|/* Pointer to a location that will be filled 				 * in with the address of the real name of 				 * the file that was successfully opened. 				 * If NULL, then nothing is stored.                                  */
name|int
name|search
decl_stmt|;
comment|/* If FALSE, then the search path business 				 * doesn't happen.  A default extension 				 * will still be added. 				 */
comment|/*---------------------------------------------------------  *	This routine does a file lookup using the current path and  *	supplying a default extension.  *  *	Results:  *	A pointer to a FILE, or NULL if the file couldn't be found.  *  *	Side Effects:  *	If the first character of the  *	file name is "~" or "/" or if search is FALSE, then we try  *	to look up the file with the original name, doing tilde  *	expansion of course and returning that result.  If none of   *	these conditions is met, we go through the current path  *	trying to look up the file once for each path  *	entry by prepending the path entry to the original file name.  *	This concatenated name is stored in a static string and made  *	available to the caller through prealname if the open succeeds.  *	Note: the static string will be trashed on the next call to this  *	routine.  Also, note that no individual file name is allowed to  *	be more than NAMESIZE characters long.  Excess characters are lost.  *---------------------------------------------------------  */
block|{
define|#
directive|define
name|NAMESIZE
value|50
specifier|static
name|char
name|realname
index|[
name|NAMESIZE
index|]
decl_stmt|;
name|char
name|extendedname
index|[
name|NAMESIZE
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|int
name|length
decl_stmt|,
name|spaceleft
decl_stmt|,
name|size
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|(
name|FILE
operator|*
operator|)
name|NULL
return|;
if|if
condition|(
name|file
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|FILE
operator|*
operator|)
name|NULL
return|;
if|if
condition|(
name|prealname
operator|!=
name|NULL
condition|)
operator|*
name|prealname
operator|=
name|realname
expr_stmt|;
comment|/* Now try the original name.  If it starts with a ~ or / look       * it up directly.      */
if|if
condition|(
name|file
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
block|{
name|p
operator|=
name|realname
expr_stmt|;
name|length
operator|=
name|NAMESIZE
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|PConvertTilde
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|length
argument_list|)
condition|)
return|return
name|NULL
return|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|fopen
argument_list|(
name|realname
argument_list|,
literal|"r"
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|file
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
operator|||
operator|(
name|search
operator|==
name|FALSE
operator|)
condition|)
block|{
name|strcpyn
argument_list|(
name|realname
argument_list|,
name|file
argument_list|,
name|NAMESIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|realname
index|[
name|NAMESIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|fopen
argument_list|(
name|realname
argument_list|,
literal|"r"
argument_list|)
return|;
block|}
comment|/* Now try going through the path. */
name|p
operator|=
name|path
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|spaceleft
operator|=
name|NAMESIZE
operator|-
literal|1
expr_stmt|;
name|p2
operator|=
name|realname
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|!=
literal|'\0'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
if|if
condition|(
name|spaceleft
operator|--
operator|>
literal|0
condition|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|spaceleft
operator|--
operator|>
literal|0
condition|)
operator|*
name|p2
operator|++
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|spaceleft
operator|>
literal|0
condition|)
name|strcpyn
argument_list|(
name|p2
argument_list|,
name|file
argument_list|,
name|spaceleft
argument_list|)
expr_stmt|;
name|realname
index|[
name|NAMESIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|realname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
return|return
name|f
return|;
block|}
comment|/* We've tried the path and that didn't work.  As a last shot,      * try the library area.  Only use the library for reads.      */
name|p
operator|=
name|GLibrary
expr_stmt|;
name|p2
operator|=
name|realname
expr_stmt|;
name|size
operator|=
name|NAMESIZE
expr_stmt|;
if|if
condition|(
operator|!
name|PConvertTilde
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|p2
argument_list|,
operator|&
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|(
name|void
operator|)
name|strcpyn
argument_list|(
name|p2
argument_list|,
name|file
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|realname
index|[
name|NAMESIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|fopen
argument_list|(
name|realname
argument_list|,
literal|"r"
argument_list|)
return|;
block|}
end_function

end_unit

