begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)graphics3.c	1.3	%G%  *  * Copyright -C- 1982 Barry S. Roitblat  *  *      This file contains additional routines for implementing graphics  * primitives for the gremlin picture editor  */
end_comment

begin_include
include|#
directive|include
file|"gremlin.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/timeb.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* imports from graphics1.c */
end_comment

begin_extern
extern|extern GRsetwmask(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|extern
name|int
name|curx
decl_stmt|,
name|cury
decl_stmt|,
name|rmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|display
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern GRClear(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* library routines */
end_comment

begin_extern
extern|extern ftime(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_macro
name|GREnableTablet
argument_list|()
end_macro

begin_comment
comment|/*---------------------------------------------------------  *	This routine enables the graphics tablet.  *  *	Results: None.  *  *	Side Effects:  *	The tablet cursor is enabled on the AED.  This will cause characters  *	to be sent over the serial line whenever a button on the cursor is  *	pushed.  After calling this routine, the routine GrGetButton may  *	be called to wait for the next button to be pushed.  *  *	Design:  *	Note:  the AED really messes up with the cursor, because it  *	continually overwrites CAP with cursor coordinates.  Thus the  *	cursor must disabled before doing ANYTHING to the AED.  *---------------------------------------------------------  */
end_comment

begin_block
block|{
name|GRsetwmask
argument_list|(
literal|127
argument_list|)
expr_stmt|;
comment|/* don't write cursor on grid layer */
name|fputs
argument_list|(
literal|"3:"
argument_list|,
name|display
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|display
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|GRDisableTablet
argument_list|()
end_macro

begin_comment
comment|/*---------------------------------------------------------  *	This routine disables the graphics tablet so that other things may  *	be done with the AED.  *  *	Results:	None.  *	Side Effects:	The tablet is disabled.  *---------------------------------------------------------  */
end_comment

begin_block
block|{
name|putc
argument_list|(
literal|'3'
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\0'
argument_list|,
name|display
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|display
argument_list|)
expr_stmt|;
name|curx
operator|=
name|cury
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|MINTIME
value|100
end_define

begin_comment
comment|/* 100 milliseconds */
end_comment

begin_function
name|int
name|GRGetButton
parameter_list|(
name|stream
parameter_list|,
name|px
parameter_list|,
name|py
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
comment|/* File from which AED chars. can be read */
name|int
modifier|*
name|px
decl_stmt|;
comment|/* Address of a word to hold x-coordinate */
name|int
modifier|*
name|py
decl_stmt|;
comment|/* Address of word to hold y-coorinate */
comment|/*---------------------------------------------------------  *	This routine waits for cursor input.  *  *	Results:  *	The return value is the number of the button that was pushed.  *	If an error occurs while reading from the stream, -1 is returned.  *  *	Side Effects:  *	The integers pointed to by px and py are filled in with the  *	x- and y-coordinates of the cursor at the time the button  *	was pushed.  *  *	Design:  *	This is tricky.  The AED apparently sends bogus button data at  *	random times.  It can usually be distinguished by the presence  *	of an illegal button number.  We must pick out such data and throw  *	it away.  *  *	For systems up to 4.1BSD (characterized by the presence of the  *	SIGTINT signal) the routine waits for cursor input.  *	For 4.2BSD and beyond, the routine gives an error of -4 if input  *	is not immediately available (it expects to be called only when  *	input is available).  *---------------------------------------------------------  */
block|{
name|int
name|button
decl_stmt|;
name|struct
name|timeval
name|selectpoll
decl_stmt|;
specifier|static
name|unsigned
name|long
name|time
decl_stmt|,
name|lastime
init|=
literal|0
decl_stmt|;
name|struct
name|timeb
name|tp
decl_stmt|;
specifier|static
name|char
name|line1
index|[
literal|100
index|]
decl_stmt|;
name|selectpoll
operator|.
name|tv_sec
operator|=
literal|0l
expr_stmt|;
name|selectpoll
operator|.
name|tv_usec
operator|=
literal|0l
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
ifndef|#
directive|ifndef
name|SIGTINT
name|button
operator|=
literal|1
operator|<<
name|fileno
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
literal|20
argument_list|,
operator|&
name|button
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|selectpoll
argument_list|)
operator|<=
literal|0
condition|)
return|return
operator|-
literal|4
return|;
endif|#
directive|endif
if|if
condition|(
name|fgets
argument_list|(
name|line1
argument_list|,
literal|99
argument_list|,
name|stream
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|line1
index|[
literal|0
index|]
operator|!=
literal|':'
condition|)
continue|continue;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
operator|&
operator|(
name|line1
index|[
literal|1
index|]
operator|)
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|button
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|line1
argument_list|,
literal|99
argument_list|,
name|stream
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|2
return|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|line1
argument_list|,
literal|"%d"
argument_list|,
name|px
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|line1
argument_list|,
literal|99
argument_list|,
name|stream
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|3
return|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|line1
argument_list|,
literal|"%d"
argument_list|,
name|py
argument_list|)
expr_stmt|;
comment|/* wait for minimum duration before accepting   */
comment|/* new button to debounce the cursor            */
name|ftime
argument_list|(
operator|&
name|tp
argument_list|)
expr_stmt|;
name|time
operator|=
literal|1000
operator|*
name|tp
operator|.
name|time
operator|+
name|tp
operator|.
name|millitm
expr_stmt|;
if|if
condition|(
operator|(
name|time
operator|-
name|lastime
operator|)
operator|<
name|MINTIME
condition|)
continue|continue;
name|lastime
operator|=
name|time
expr_stmt|;
if|if
condition|(
name|button
operator|==
literal|2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|button
operator|==
literal|4
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|button
operator|==
literal|8
condition|)
return|return
literal|3
return|;
if|if
condition|(
name|button
operator|==
literal|1
condition|)
return|return
literal|0
return|;
block|}
block|}
end_function

begin_macro
name|GRSetGrid
argument_list|(
argument|x1
argument_list|,
argument|y1
argument_list|,
argument|x2
argument_list|,
argument|y2
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine sets the grid  according to the paramaters  * (lower left and upper right corners, and spacing) supplied.  The  * grid is written to the appropriate memory plane but will not be   * displayed unless that plane has been (Read) enabled.  */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|,
name|start
decl_stmt|;
name|POINT
name|end1
decl_stmt|,
name|end2
decl_stmt|;
name|GRClear
argument_list|(
name|gridmask
argument_list|)
expr_stmt|;
name|GRsetwmask
argument_list|(
name|gridmask
argument_list|)
expr_stmt|;
name|end1
operator|.
name|y
operator|=
operator|(
name|float
operator|)
name|y1
expr_stmt|;
name|end2
operator|.
name|y
operator|=
operator|(
name|float
operator|)
name|y2
expr_stmt|;
name|start
operator|=
operator|(
operator|(
name|x1
operator|+
name|size
operator|-
literal|1
operator|)
operator|-
operator|(
operator|(
name|x1
operator|+
name|size
operator|-
literal|1
operator|)
operator|%
name|size
operator|)
operator|)
expr_stmt|;
comment|/* start forces the lines to be drawn on pixel                 boundaries evenly divisible by size           */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<=
name|x2
condition|;
name|i
operator|+=
name|size
control|)
block|{
name|end1
operator|.
name|x
operator|=
name|end2
operator|.
name|x
operator|=
operator|(
name|float
operator|)
name|i
expr_stmt|;
name|GRVector
argument_list|(
operator|&
name|end1
argument_list|,
operator|&
name|end2
argument_list|,
name|gridstyle
argument_list|)
expr_stmt|;
block|}
comment|/* end for */
empty_stmt|;
name|end1
operator|.
name|x
operator|=
operator|(
name|float
operator|)
name|x1
expr_stmt|;
name|end2
operator|.
name|x
operator|=
operator|(
name|float
operator|)
name|x2
expr_stmt|;
name|start
operator|=
operator|(
operator|(
name|y1
operator|+
name|size
operator|-
literal|1
operator|)
operator|-
operator|(
operator|(
name|y1
operator|+
name|size
operator|-
literal|1
operator|)
operator|%
name|size
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<=
name|y2
condition|;
name|i
operator|+=
name|size
control|)
block|{
name|end1
operator|.
name|y
operator|=
name|end2
operator|.
name|y
operator|=
operator|(
name|float
operator|)
name|i
expr_stmt|;
name|GRVector
argument_list|(
operator|&
name|end1
argument_list|,
operator|&
name|end2
argument_list|,
name|gridstyle
argument_list|)
expr_stmt|;
block|}
comment|/* end for */
empty_stmt|;
block|}
end_block

begin_comment
comment|/* end SetGrid */
end_comment

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|GRSetRead
argument_list|(
argument|mask
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine sets the read mask.  */
end_comment

begin_block
block|{
ifndef|#
directive|ifndef
name|FASTIO
name|char
name|s1
index|[
literal|3
index|]
decl_stmt|,
name|s2
index|[
literal|3
index|]
decl_stmt|,
name|s3
index|[
literal|3
index|]
decl_stmt|,
name|s4
index|[
literal|3
index|]
decl_stmt|;
endif|#
directive|endif
name|rmask
operator|=
name|mask
expr_stmt|;
ifndef|#
directive|ifndef
name|FASTIO
name|GRchex
argument_list|(
name|rmask
argument_list|,
name|s1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|GRchex
argument_list|(
name|rmask1
argument_list|,
name|s2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|GRchex
argument_list|(
name|rmask2
argument_list|,
name|s3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|GRchex
argument_list|(
name|rmask3
argument_list|,
name|s4
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|display
argument_list|,
literal|"M%s%s%s%s"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|,
name|s4
argument_list|)
expr_stmt|;
else|#
directive|else
name|putc
argument_list|(
literal|'M'
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|rmask
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|rmask1
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|rmask2
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|rmask3
argument_list|,
name|display
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|display
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end SetRead */
end_comment

begin_macro
name|GRDisplayGrid
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine displays the grid created by setgrid by enabling  * the appropriate read layer.  */
end_comment

begin_block
block|{
name|GRSetRead
argument_list|(
name|rmask
operator||
name|gridmask
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end DisplayGrid */
end_comment

begin_macro
name|GRBlankGrid
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine assures that the grid is not displayed by  * setting the read mask to disable the grid layer.  */
end_comment

begin_block
block|{
name|GRSetRead
argument_list|(
name|rmask
operator|&
operator|~
name|gridmask
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end BlankGrid */
end_comment

end_unit

