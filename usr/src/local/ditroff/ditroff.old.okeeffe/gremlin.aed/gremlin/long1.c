begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_escape
end_escape

begin_comment
comment|/* long1.c -  *  * Copyright -C- 1982 Barry S. Roitblat  *  *  *      This file contains routines to implement the long text commands  * of the gremlin PICTURE editor.  *  */
end_comment

begin_include
include|#
directive|include
file|"gremlin.h"
end_include

begin_include
include|#
directive|include
file|"grem2.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* imports from config.c */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|GMailCommand
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* imports from graphics files */
end_comment

begin_extern
extern|extern GRVector(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|GRArc
argument_list|()
operator|,
name|GRPutText
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern GRDisplayPoint(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|GRDeletePoint
argument_list|()
operator|,
name|GRBlankPoints
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern charxsize
operator|,
extern|charysize;
end_extern

begin_extern
extern|extern artmode;
end_extern

begin_comment
comment|/* indication of point display size */
end_comment

begin_comment
comment|/* imports from display.c */
end_comment

begin_extern
extern|extern DISScreenAdd(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|DISScreenErase
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern DISDisplaySet(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|DISEraseSet
argument_list|()
operator|,
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* imports from database files */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|DBInit
argument_list|()
decl_stmt|,
modifier|*
name|DBCreateElt
argument_list|()
decl_stmt|,
modifier|*
name|DBRead
argument_list|()
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern DBDelete(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|DBSetGravitate
argument_list|()
operator|,
name|DBGravitate
argument_list|()
operator|,
name|DBClearElt
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|extern
name|ELT
modifier|*
name|DBCopy
parameter_list|()
function_decl|;
end_function_decl

begin_extern
extern|extern DBXform(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|DBChangeBrush
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern DBAddSet(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|DBClearSet
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|POINT
modifier|*
name|PTInit
argument_list|()
decl_stmt|,
modifier|*
name|PTMakePoint
argument_list|()
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern PTDeletePoint(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from undodb.c */
end_comment

begin_decl_stmt
specifier|extern
name|UNELT
modifier|*
name|unlist
decl_stmt|,
modifier|*
name|unback
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern UNRembMod(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from short.c */
end_comment

begin_extern
extern|extern SHUpdate(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from menu.c  */
end_comment

begin_extern
extern|extern MNHighLt(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|MNUnHighLt
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern MNInitMenu(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern HiMen[]
operator|,
extern|HiFont[]
operator|,
extern|HiBrush[]
operator|,
extern|HiMode[];
end_extern

begin_comment
comment|/* imports from textio.c */
end_comment

begin_extern
extern|extern TxMsgOK(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|TxPutString
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|TXFIELD
name|TAlign
decl_stmt|,
name|TAdjust
decl_stmt|,
name|TBrush
decl_stmt|,
name|TFont
decl_stmt|,
name|TGravity
decl_stmt|,
name|TCSize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|TXFIELD
name|TEdit
decl_stmt|,
name|TJustmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* imports from c */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|sprintf
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* imports from main.c */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|PICTURE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current PICTURE database      */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|cset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current set database          */
end_comment

begin_extern
extern|extern CBRUSH
operator|,
extern|CSIZE
operator|,
extern|CFONT;
end_extern

begin_comment
comment|/* current brush, size, font     */
end_comment

begin_extern
extern|extern CJUST;
end_extern

begin_comment
comment|/* current text justification    */
end_comment

begin_extern
extern|extern Gridon;
end_extern

begin_comment
comment|/* grid mode flag                */
end_comment

begin_extern
extern|extern Orientation;
end_extern

begin_comment
comment|/* orientation of workspace      */
end_comment

begin_extern
extern|extern Alignment;
end_extern

begin_comment
comment|/* point alignment indicator     */
end_comment

begin_decl_stmt
specifier|extern
name|float
name|PX
decl_stmt|,
name|PY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cursor coordinates            */
end_comment

begin_decl_stmt
specifier|extern
name|float
name|Lastx
decl_stmt|,
name|Lasty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* previous cursor coordinates   */
end_comment

begin_extern
extern|extern SEQ;
end_extern

begin_comment
comment|/* point sequence number         */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Editfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current edit file             */
end_comment

begin_decl_stmt
specifier|extern
name|POINT
modifier|*
name|POINTLIST
decl_stmt|,
modifier|*
name|BACKPOINT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* accumulated point list        */
end_comment

begin_extern
extern|extern Adjustment;
end_extern

begin_comment
comment|/* point adjustment mode         */
end_comment

begin_extern
extern|extern GravityOn;
end_extern

begin_comment
comment|/* gravity mode flag             */
end_comment

begin_extern
extern|extern Consume;
end_extern

begin_comment
comment|/* point clear flag              */
end_comment

begin_extern
extern|extern CHANGED;
end_extern

begin_comment
comment|/* PICTURE changed flag          */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|MEN
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers for user symbols     */
end_comment

begin_decl_stmt
specifier|extern
name|POINT
name|MENPOINT
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers used fo user symbols */
end_comment

begin_extern
extern|extern cmdbuf[];
end_extern

begin_comment
comment|/* line buffer for commands      */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|lines
index|[]
decl_stmt|,
modifier|*
name|fonts
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line and character styles     */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|lnum
index|[]
decl_stmt|,
name|fnum
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      The following is available to the outside world */
end_comment

begin_decl_stmt
name|int
name|bang
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*      The following are defined to allow creation of the command  * lookup table.  */
end_comment

begin_extern
extern|extern LGAlign(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|LGBrush
argument_list|()
operator|,
name|LGClearPoints
argument_list|()
operator|,
name|LGGripe
argument_list|()
operator|,
name|LGLittlePoint
argument_list|()
operator|,
name|LGDeletePoint
argument_list|()
operator|,
name|LGEdit
argument_list|()
operator|,
name|LGFont
argument_list|()
operator|,
name|LGIncludeSet
argument_list|()
operator|,
name|LGSize
argument_list|()
operator|,
name|LGSave
argument_list|()
operator|,
name|LGJust
argument_list|()
operator|,
name|LGMenu
argument_list|()
operator|,
name|LGPoint
argument_list|()
operator|,
name|LGPath
argument_list|()
operator|,
name|LGQuit
argument_list|()
operator|,
name|LGRead
argument_list|()
operator|,
name|LGHAdjust
argument_list|()
operator|,
name|LGMBrush
argument_list|()
operator|,
name|LGMFont
argument_list|()
operator|,
name|LGMSize
argument_list|()
operator|,
name|LGMText
argument_list|()
operator|,
name|LGMPoint
argument_list|()
operator|,
name|LGMirror
argument_list|()
operator|,
name|LGOrient
argument_list|()
operator|,
name|LGVAdjust
argument_list|()
operator|,
name|LGText
argument_list|()
operator|,
name|LGUndo
argument_list|()
operator|,
name|LGWrite
argument_list|()
operator|,
name|LGOpoint
argument_list|()
operator|,
name|LGShowPoints
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The following two arrays define the long commands and the routines  * that process them.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lcmds
index|[]
init|=
block|{
literal|"align"
block|,
literal|"brush"
block|,
literal|"buffer"
block|,
literal|"clearpoints"
block|,
literal|"deletepoint"
block|,
literal|"edit"
block|,
literal|"font"
block|,
literal|"gripe"
block|,
literal|"hadjust"
block|,
literal|"includeset"
block|,
literal|"justificaion"
block|,
literal|"littlepoint"
block|,
literal|"mbrush"
block|,
literal|"mfont"
block|,
literal|"mirror"
block|,
literal|"mpoint"
block|,
literal|"msize"
block|,
literal|"mtext"
block|,
literal|"orient"
block|,
literal|"path"
block|,
literal|"point"
block|,
literal|"quit"
block|,
literal|"read"
block|,
literal|"size"
block|,
literal|"saveset"
block|,
literal|"showpoints"
block|,
literal|"text"
block|,
literal|"undo"
block|,
literal|"vadjust"
block|,
literal|"write"
block|,
literal|"zpoint"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
operator|(
operator|*
operator|(
name|lrtns
index|[]
operator|)
operator|)
operator|(
operator|)
operator|=
block|{
name|LGAlign
block|,
comment|/* align */
name|LGBrush
block|,
comment|/* set brush */
name|LGMenu
block|,
comment|/* select user set buffer */
name|LGClearPoints
block|,
comment|/* clear points */
name|LGDeletePoint
block|,
comment|/* delete a point */
name|LGEdit
block|,
comment|/* edit new file */
name|LGFont
block|,
comment|/* set font */
name|LGGripe
block|,
comment|/* leave a gripe or bug */
name|LGHAdjust
block|,
comment|/* horizontal adjust */
name|LGIncludeSet
block|,
comment|/* add to set */
name|LGJust
block|,
comment|/* text justification */
name|LGLittlePoint
block|,
comment|/* point size */
name|LGMBrush
block|,
comment|/* modify brush */
name|LGMFont
block|,
comment|/* modify font */
name|LGMirror
block|,
comment|/* mirror current set */
name|LGMPoint
block|,
comment|/* move point */
name|LGMSize
block|,
comment|/* modify size */
name|LGMText
block|,
comment|/* modify text string */
name|LGOrient
block|,
comment|/* change picture orientation */
name|LGPath
block|,
comment|/* set path or toggle search mode */
name|LGOpoint
block|,
comment|/* obtain point from terminal */
name|LGQuit
block|,
comment|/* quit */
name|LGRead
block|,
comment|/* read user sysmbol */
name|LGSize
block|,
comment|/* character size */
name|LGSave
block|,
comment|/* save current set in file */
name|LGShowPoints
block|,
comment|/* display reference points in set */
name|LGText
block|,
comment|/* input text */
name|LGUndo
block|,
comment|/* undo last command */
name|LGVAdjust
block|,
comment|/* vertical adjust */
name|LGWrite
block|,
comment|/* write file */
name|LGPoint
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* create point from cursor */
end_comment

begin_escape
end_escape

begin_decl_stmt
name|int
name|LGLookup
argument_list|(
name|str
argument_list|,
name|table
argument_list|,
name|next
argument_list|)
name|char
name|str
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to a string to be looked up */
end_comment

begin_expr_stmt
name|char
argument_list|*
operator|(
name|table
index|[]
operator|)
argument_list|;
comment|/* Pointer to an array of string pointers 				 * which are the valid commands.  The strings 				 * must be ordered monotonically (i.e. all 				 * strings whose first characters are identical 				 * must be adjacent in the table). 				 */
name|int
operator|*
name|next
argument_list|;
comment|/*---------------------------------------------------------  *	LGLookup searches a table of strings to find one that matches a  *	given string.  *  *	Results:  *	If str is an unambiguous abbreviation for one of the entries  *	in table, then the index of the matching entry is returned.  *	If str is an abbreviation for more than one entry in table,  *	then -1 is returned.  If str doesn't match any entry, then  *	-2 is returned.  *  *	Side Effects:	None.  *  * (Modified from software written by John Ousterhout for the caesar  *  program)  *---------------------------------------------------------  */
block|{
comment|/* The search is carried out by using two pointers, one which moves      * forward through table from its start, and one which moves backward      * through table from its end.  The two pointers mark the range of      * strings that match the portion of str that we have scanned.  When      * all of the characters of str have been scanned, then the two      * pointers better be identical.      */
name|char
modifier|*
modifier|*
name|bot
decl_stmt|,
modifier|*
modifier|*
name|top
decl_stmt|;
name|int
name|match
decl_stmt|,
name|index
decl_stmt|;
name|bang
operator|=
name|FALSE
expr_stmt|;
name|match
operator|=
literal|0
expr_stmt|;
name|bot
operator|=
name|table
expr_stmt|;
for|for
control|(
name|top
operator|=
name|table
init|;
operator|*
name|top
operator|!=
name|NULL
condition|;
name|top
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|top
operator|==
name|bot
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|top
operator|--
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
condition|;
name|index
operator|++
control|)
block|{
operator|*
name|next
operator|=
name|index
expr_stmt|;
comment|/* Check for the end of string */
if|if
condition|(
operator|(
name|str
index|[
name|index
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|str
index|[
name|index
index|]
operator|==
literal|','
operator|)
operator|||
operator|(
name|str
index|[
name|index
index|]
operator|==
literal|' '
operator|)
condition|)
block|{
if|if
condition|(
name|bot
operator|==
name|top
condition|)
return|return
operator|(
name|match
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|str
index|[
name|index
index|]
operator|==
literal|'!'
condition|)
name|bang
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
comment|/* Move bot up until the string it points to matches str in the 	 * index'th position.  Make match refer to the index of bot in table. 	 */
while|while
condition|(
operator|(
operator|*
name|bot
operator|)
index|[
name|index
index|]
operator|!=
name|str
index|[
name|index
index|]
condition|)
block|{
if|if
condition|(
name|bot
operator|==
name|top
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|bot
operator|++
expr_stmt|;
name|match
operator|++
expr_stmt|;
block|}
comment|/* Move top down until it matches */
while|while
condition|(
operator|(
operator|*
name|top
operator|)
index|[
name|index
index|]
operator|!=
name|str
index|[
name|index
index|]
condition|)
block|{
if|if
condition|(
name|bot
operator|==
name|top
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|top
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
end_expr_stmt

begin_escape
end_escape

begin_macro
name|LGCommand
argument_list|(
argument|command
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*---------------------------------------------------------  *	This routine reads in, looks up, and executes a long command.  *  *	Results:	None.  *  *	Side Effects:  *	Depends on the command that is invoked.  *---------------------------------------------------------  */
end_comment

begin_block
block|{
name|int
name|index
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
operator|*
name|command
operator|==
literal|'\0'
condition|)
block|{
name|Consume
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|index
operator|=
name|LGLookup
argument_list|(
name|command
argument_list|,
name|lcmds
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
operator|(
operator|*
operator|(
name|lrtns
index|[
name|index
index|]
operator|)
operator|)
operator|(
name|command
operator|+
name|next
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"command is ambiguous."
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|2
condition|)
name|error
argument_list|(
literal|"not a command."
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
name|badarg
index|[
literal|10
index|]
init|=
literal|"bad args"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|noset
index|[
literal|15
index|]
init|=
literal|"no current set"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BADNUM
value|-1
end_define

begin_define
define|#
directive|define
name|NONUM
value|-2
end_define

begin_define
define|#
directive|define
name|Delimiter
parameter_list|(
name|c
parameter_list|)
value|((c == '\0') || (c == ' ') || (c == ','))
end_define

begin_macro
name|GetNumParm
argument_list|(
argument|line
argument_list|,
argument|index
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine trys to interpret the string starting at  * line+index as a positive integeral numeric parameter.  The function  * returns the numeric equivalent or a negative number it there is some  * error in interpreting the string.  */
end_comment

begin_block
block|{
name|char
name|num
index|[
literal|20
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|Delimiter
argument_list|(
operator|*
operator|(
name|line
operator|+
operator|*
name|index
operator|)
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|num
index|[
name|i
index|]
operator|=
operator|*
operator|(
name|line
operator|+
operator|*
name|index
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|num
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
name|BADNUM
operator|)
return|;
operator|++
operator|(
operator|*
name|index
operator|)
expr_stmt|;
block|}
comment|/* end for */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|NONUM
operator|)
return|;
name|num
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|num
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/* end GetNumParm */
end_comment

begin_escape
end_escape

begin_macro
name|LGOpoint
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine accepts coordinates from the text terminal  * and creates and displays a point from them by passing them  * along to LGPoint.  *  * NOTE: coordinates from the terminal must be non-negative  * integers.  */
end_comment

begin_block
block|{
name|int
name|index
decl_stmt|,
name|xcoord
decl_stmt|,
name|ycoord
decl_stmt|;
name|index
operator|=
literal|1
expr_stmt|;
name|xcoord
operator|=
name|GetNumParm
argument_list|(
name|line
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|xcoord
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
name|badarg
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|index
expr_stmt|;
name|ycoord
operator|=
name|GetNumParm
argument_list|(
name|line
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|ycoord
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
name|badarg
argument_list|)
expr_stmt|;
return|return;
block|}
name|PX
operator|=
name|xcoord
expr_stmt|;
name|PY
operator|=
name|ycoord
expr_stmt|;
name|LGPoint
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGOpoint */
end_comment

begin_escape
end_escape

begin_macro
name|LGPoint
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine accepts cursor coordinates and creates and  * displays points according to the current adjustment and alignment  * modes.  Note that alignment and gravity are mutually exclusive  * and adjustment takes precedence over either.  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|temp
decl_stmt|;
name|POINT
modifier|*
name|p1
decl_stmt|;
name|temp
operator|=
name|DBInit
argument_list|()
expr_stmt|;
if|if
condition|(
name|GravityOn
condition|)
name|DBGravitate
argument_list|(
name|PX
argument_list|,
name|PY
argument_list|,
operator|&
name|PX
argument_list|,
operator|&
name|PY
argument_list|,
operator|&
name|p1
argument_list|,
operator|&
name|temp
argument_list|,
name|PICTURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|DBNullelt
argument_list|(
name|temp
argument_list|)
condition|)
comment|/* no gravity in effect */
block|{
comment|/* Round to nearest alignment boundary */
name|PX
operator|=
call|(
name|float
call|)
argument_list|(
operator|(
call|(
name|int
call|)
argument_list|(
name|PX
operator|/
name|Alignment
operator|+
literal|0.5
argument_list|)
operator|)
operator|*
name|Alignment
argument_list|)
expr_stmt|;
name|PY
operator|=
call|(
name|float
call|)
argument_list|(
operator|(
call|(
name|int
call|)
argument_list|(
name|PY
operator|/
name|Alignment
operator|+
literal|0.5
argument_list|)
operator|)
operator|*
name|Alignment
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SEQ
operator|>
literal|0
condition|)
comment|/* this isn't the first point */
block|{
if|if
condition|(
name|Adjustment
operator|==
name|HORZ
condition|)
name|PY
operator|=
name|Lasty
expr_stmt|;
if|if
condition|(
name|Adjustment
operator|==
name|VERT
condition|)
name|PX
operator|=
name|Lastx
expr_stmt|;
if|if
condition|(
name|Adjustment
operator|==
name|MAN
condition|)
if|if
condition|(
name|fabs
argument_list|(
name|PX
operator|-
name|Lastx
argument_list|)
operator|>
name|fabs
argument_list|(
name|PY
operator|-
name|Lasty
argument_list|)
condition|)
name|PY
operator|=
name|Lasty
expr_stmt|;
else|else
name|PX
operator|=
name|Lastx
expr_stmt|;
block|}
comment|/* end if SEQ */
empty_stmt|;
name|GRDisplayPoint
argument_list|(
operator|(
name|int
operator|)
name|PX
argument_list|,
operator|(
name|int
operator|)
name|PY
argument_list|,
name|SEQ
argument_list|,
name|pointstyle
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|PX
argument_list|,
name|PY
argument_list|,
operator|&
name|POINTLIST
argument_list|)
expr_stmt|;
name|Lastx
operator|=
name|PX
expr_stmt|;
name|Lasty
operator|=
name|PY
expr_stmt|;
name|Consume
operator|=
name|FALSE
expr_stmt|;
operator|++
name|SEQ
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end Point */
end_comment

begin_macro
name|CP
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine deletes all points from the POINTLIST and   * clears them from the display also.  */
end_comment

begin_block
block|{
name|POINT
modifier|*
name|temp
decl_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|BACKPOINT
argument_list|)
condition|)
block|{
name|temp
operator|=
name|PTNextPoint
argument_list|(
name|BACKPOINT
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|BACKPOINT
argument_list|)
expr_stmt|;
name|BACKPOINT
operator|=
name|temp
expr_stmt|;
block|}
name|BACKPOINT
operator|=
name|POINTLIST
expr_stmt|;
name|POINTLIST
operator|=
name|PTInit
argument_list|()
expr_stmt|;
name|SEQ
operator|=
literal|0
expr_stmt|;
name|GRBlankPoints
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end CP */
end_comment

begin_escape
end_escape

begin_macro
name|LGClearPoints
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine is a no-op since all points are cleared by default  * each time through the interpreter loop unless Consume is false.  */
end_comment

begin_block
block|{ }
end_block

begin_macro
name|LGDeletePoint
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine removes the last point from the POINTLIST  * and erases it from the screen.  */
end_comment

begin_block
block|{
name|POINT
modifier|*
name|pt1
decl_stmt|,
modifier|*
name|pt2
decl_stmt|,
modifier|*
name|pt3
decl_stmt|;
name|float
name|savex
decl_stmt|,
name|savey
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|SEQ
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"no point"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pt2
operator|=
name|pt3
operator|=
name|POINTLIST
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|pt3
argument_list|)
condition|)
comment|/* find last point and pointer to it */
block|{
name|pt1
operator|=
name|pt2
expr_stmt|;
name|pt2
operator|=
name|pt3
expr_stmt|;
name|pt3
operator|=
name|PTNextPoint
argument_list|(
name|pt3
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|SEQ
operator|--
expr_stmt|;
name|savex
operator|=
name|pt2
operator|->
name|x
expr_stmt|;
name|savey
operator|=
name|pt2
operator|->
name|y
expr_stmt|;
name|GRErasePoint
argument_list|(
operator|(
name|int
operator|)
name|pt2
operator|->
name|x
argument_list|,
operator|(
name|int
operator|)
name|pt2
operator|->
name|y
argument_list|,
name|SEQ
argument_list|)
expr_stmt|;
name|PTDeletePoint
argument_list|(
name|pt2
argument_list|)
expr_stmt|;
if|if
condition|(
name|SEQ
operator|>
literal|0
condition|)
comment|/* any points left after deleting */
block|{
comment|/* then pt1 points to last of them */
name|Lastx
operator|=
name|pt1
operator|->
name|x
expr_stmt|;
name|Lasty
operator|=
name|pt1
operator|->
name|y
expr_stmt|;
name|pt3
operator|=
name|POINTLIST
expr_stmt|;
comment|/* redisplay any nearby points */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SEQ
condition|;
operator|++
name|i
control|)
comment|/* which may have been clobbered by */
block|{
comment|/* the erase */
if|if
condition|(
name|fabs
argument_list|(
name|pt3
operator|->
name|x
operator|-
name|savex
argument_list|)
operator|<
operator|(
literal|2
operator|*
name|halfpoint
operator|)
condition|)
if|if
condition|(
name|fabs
argument_list|(
name|pt3
operator|->
name|y
operator|-
name|savey
argument_list|)
operator|<
operator|(
literal|2
operator|*
name|halfpoint
operator|)
condition|)
name|GRDisplayPoint
argument_list|(
operator|(
name|int
operator|)
name|pt3
operator|->
name|x
argument_list|,
operator|(
name|int
operator|)
name|pt3
operator|->
name|y
argument_list|,
name|i
argument_list|,
name|pointstyle
argument_list|)
expr_stmt|;
name|pt3
operator|=
name|PTNextPoint
argument_list|(
name|pt3
argument_list|)
expr_stmt|;
block|}
comment|/* end for */
block|}
name|Consume
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end DeletePoint */
end_comment

begin_escape
end_escape

begin_macro
name|LGShowPoints
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine causes the text elements in the current set  * to be redrawn using the new font.  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|elist
decl_stmt|;
name|POINT
modifier|*
name|p1
decl_stmt|;
name|int
name|pno
decl_stmt|;
if|if
condition|(
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|noset
argument_list|)
expr_stmt|;
return|return;
block|}
name|elist
operator|=
name|cset
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elist
argument_list|)
condition|)
block|{
name|p1
operator|=
name|elist
operator|->
name|ptlist
expr_stmt|;
name|pno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|p1
argument_list|)
condition|)
block|{
name|GRDisplayPoint
argument_list|(
operator|(
name|int
operator|)
name|p1
operator|->
name|x
argument_list|,
operator|(
name|int
operator|)
name|p1
operator|->
name|y
argument_list|,
name|pno
argument_list|,
name|pointstyle
argument_list|)
expr_stmt|;
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|pno
operator|++
expr_stmt|;
block|}
name|elist
operator|=
name|DBNextofSet
argument_list|(
name|elist
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
name|Consume
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end ShowPoints */
end_comment

begin_escape
end_escape

begin_macro
name|LGText
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      This routine implements the text commands.  It first looks  * for a justification specification (if not specified, default is  * centering), and then the text string from the input line.  Text  * justification requires a point upon which the text is positioned.  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|e1
decl_stmt|;
name|POINT
name|pos
decl_stmt|,
name|ppnt
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
if|if
condition|(
name|SEQ
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"not enough points"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
return|return;
comment|/* no text */
for|for
control|(
init|;
operator|*
name|line
operator|==
literal|' '
condition|;
operator|++
name|line
control|)
comment|/* delete leading blanks */
name|i
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|text
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|text
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|DBClearSet
argument_list|()
expr_stmt|;
comment|/* clear old current set so this can form */
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
comment|/* the new one  */
name|GRsetwmask
argument_list|(
name|textmask
operator||
name|setmask
argument_list|)
expr_stmt|;
name|ppnt
operator|.
name|x
operator|=
name|POINTLIST
operator|->
name|x
expr_stmt|;
name|ppnt
operator|.
name|y
operator|=
name|POINTLIST
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|SEQ
operator|>
literal|1
condition|)
block|{
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|POINTLIST
argument_list|)
expr_stmt|;
name|ppnt
operator|.
name|x
operator|=
operator|(
name|POINTLIST
operator|->
name|x
operator|+
name|p1
operator|->
name|x
operator|)
operator|/
literal|2
expr_stmt|;
name|ppnt
operator|.
name|y
operator|=
operator|(
name|POINTLIST
operator|->
name|y
operator|+
name|p1
operator|->
name|y
operator|)
operator|/
literal|2
expr_stmt|;
block|}
name|GRPutText
argument_list|(
name|CJUST
argument_list|,
operator|&
name|ppnt
argument_list|,
name|CFONT
argument_list|,
name|CSIZE
argument_list|,
name|text
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|p1
operator|=
name|PTInit
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|ppnt
operator|.
name|x
argument_list|,
name|ppnt
operator|.
name|y
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
comment|/* end extra positioning points */
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|pos
operator|.
name|x
argument_list|,
name|pos
operator|.
name|y
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|pos
operator|.
name|x
operator|+
name|i
operator|*
name|charxsize
operator|/
literal|2
argument_list|,
name|pos
operator|.
name|y
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|pos
operator|.
name|x
operator|+
name|i
operator|*
name|charxsize
argument_list|,
name|pos
operator|.
name|y
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
name|e1
operator|=
name|DBCreateElt
argument_list|(
name|CJUST
argument_list|,
name|p1
argument_list|,
name|CFONT
argument_list|,
name|CSIZE
argument_list|,
name|text
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGText */
end_comment

begin_escape
end_escape

begin_macro
name|LGBrush
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine sets the current brush to that specified in the  * parameter.  */
end_comment

begin_block
block|{
name|int
name|newbrush
decl_stmt|,
name|index
decl_stmt|;
name|char
name|string
index|[
literal|2
index|]
decl_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
operator|*
operator|(
operator|++
name|line
operator|)
argument_list|)
condition|)
block|{
name|newbrush
operator|=
name|LGLookup
argument_list|(
name|line
argument_list|,
name|lines
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbrush
operator|>=
literal|0
condition|)
name|newbrush
operator|=
name|lnum
index|[
name|newbrush
index|]
expr_stmt|;
else|else
name|newbrush
operator|=
name|BADNUM
expr_stmt|;
block|}
else|else
name|newbrush
operator|=
name|GetNumParm
argument_list|(
name|line
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newbrush
operator|==
name|BADNUM
operator|)
operator|||
operator|(
name|newbrush
operator|>
name|NBRUSHES
operator|)
condition|)
block|{
name|error
argument_list|(
name|badarg
argument_list|)
expr_stmt|;
return|return;
block|}
name|MNUnHighLt
argument_list|(
name|HiBrush
index|[
name|CBRUSH
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|MNHighLt
argument_list|(
name|HiBrush
index|[
name|newbrush
operator|-
literal|1
index|]
argument_list|,
name|hicolor
argument_list|)
expr_stmt|;
name|CBRUSH
operator|=
name|newbrush
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%1d"
argument_list|,
name|newbrush
argument_list|)
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TBrush
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|Consume
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGBrush */
end_comment

begin_escape
end_escape

begin_macro
name|LGMBrush
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine causes the elements in the current set  * to be redrawn using the new brush.  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|elist
decl_stmt|;
name|int
name|new
decl_stmt|,
name|index
decl_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
operator|*
operator|(
operator|++
name|line
operator|)
argument_list|)
condition|)
block|{
name|new
operator|=
name|LGLookup
argument_list|(
name|line
argument_list|,
name|lines
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|>=
literal|0
condition|)
name|new
operator|=
name|lnum
index|[
name|new
index|]
expr_stmt|;
else|else
name|new
operator|=
name|BADNUM
expr_stmt|;
block|}
else|else
name|new
operator|=
name|GetNumParm
argument_list|(
name|line
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|<
literal|0
operator|)
operator|||
operator|(
name|new
operator|>
name|NBRUSHES
operator|)
condition|)
block|{
name|error
argument_list|(
name|badarg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|noset
argument_list|)
expr_stmt|;
return|return;
block|}
name|elist
operator|=
name|cset
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elist
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TEXT
argument_list|(
name|elist
operator|->
name|type
argument_list|)
condition|)
block|{
name|DISScreenErase
argument_list|(
name|elist
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|DBChangeBrush
argument_list|(
name|elist
argument_list|,
name|new
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|elist
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* end if */
name|elist
operator|=
name|DBNextofSet
argument_list|(
name|elist
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end MBrush */
end_comment

begin_escape
end_escape

begin_macro
name|LGMFont
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine causes the text elements in the current set  * to be redrawn using the new font.  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|elist
decl_stmt|;
name|int
name|new
decl_stmt|,
name|index
decl_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
operator|*
operator|(
operator|++
name|line
operator|)
argument_list|)
condition|)
block|{
name|new
operator|=
name|LGLookup
argument_list|(
name|line
argument_list|,
name|fonts
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|>=
literal|0
condition|)
name|new
operator|=
name|fnum
index|[
name|new
index|]
expr_stmt|;
else|else
name|new
operator|=
name|BADNUM
expr_stmt|;
block|}
else|else
name|new
operator|=
name|GetNumParm
argument_list|(
name|line
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|<
literal|0
operator|)
operator|||
operator|(
name|new
operator|>
name|NFONTS
operator|)
condition|)
block|{
name|error
argument_list|(
name|badarg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|noset
argument_list|)
expr_stmt|;
return|return;
block|}
name|elist
operator|=
name|cset
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elist
argument_list|)
condition|)
block|{
if|if
condition|(
name|TEXT
argument_list|(
name|elist
operator|->
name|type
argument_list|)
condition|)
block|{
name|DISScreenErase
argument_list|(
name|elist
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|TxMsgOK
argument_list|()
expr_stmt|;
name|DBChangeFont
argument_list|(
name|elist
argument_list|,
name|new
argument_list|,
name|elist
operator|->
name|size
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|elist
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* end if */
name|elist
operator|=
name|DBNextofSet
argument_list|(
name|elist
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end MFont */
end_comment

begin_escape
end_escape

begin_macro
name|LGMSize
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine causes the text elements in the current set  * to be redrawn using the new size.  *  */
end_comment

begin_block
block|{
name|POINT
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
name|pos
decl_stmt|;
name|ELT
modifier|*
name|elist
decl_stmt|;
name|int
name|new
decl_stmt|,
name|index
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|index
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|GetNumParm
argument_list|(
name|line
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|<
literal|0
operator|)
operator|||
operator|(
name|new
operator|>
name|NSIZES
operator|)
condition|)
block|{
name|error
argument_list|(
name|badarg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|noset
argument_list|)
expr_stmt|;
return|return;
block|}
name|elist
operator|=
name|cset
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elist
argument_list|)
condition|)
block|{
if|if
condition|(
name|TEXT
argument_list|(
name|elist
operator|->
name|type
argument_list|)
condition|)
block|{
name|DISScreenErase
argument_list|(
name|elist
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|TxMsgOK
argument_list|()
expr_stmt|;
name|UNRembMod
argument_list|(
name|elist
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|elist
operator|->
name|size
operator|=
name|new
expr_stmt|;
name|GRsetwmask
argument_list|(
name|textmask
operator||
name|setmask
argument_list|)
expr_stmt|;
name|p1
operator|=
name|elist
operator|->
name|ptlist
expr_stmt|;
name|GRPutText
argument_list|(
name|elist
operator|->
name|type
argument_list|,
name|p1
argument_list|,
name|elist
operator|->
name|brushf
argument_list|,
name|elist
operator|->
name|size
argument_list|,
name|elist
operator|->
name|textpt
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|elist
operator|->
name|textpt
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PTInit
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
comment|/* end extra positioning points */
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|pos
operator|.
name|x
argument_list|,
name|pos
operator|.
name|y
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|pos
operator|.
name|x
operator|+
name|i
operator|*
name|charxsize
operator|/
literal|2
argument_list|,
name|pos
operator|.
name|y
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|pos
operator|.
name|x
operator|+
name|i
operator|*
name|charxsize
argument_list|,
name|pos
operator|.
name|y
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
name|elist
operator|->
name|ptlist
operator|=
name|p2
expr_stmt|;
block|}
comment|/* end if */
name|elist
operator|=
name|DBNextofSet
argument_list|(
name|elist
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end MSize */
end_comment

begin_escape
end_escape

begin_macro
name|LGMText
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      This routine allows modification of text by replacing   * an existing string with a new one, appropriately repositioned  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|e1
decl_stmt|;
name|POINT
name|pos
decl_stmt|,
name|ppnt
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|i
operator|=
name|strlen
argument_list|(
operator|++
name|line
argument_list|)
expr_stmt|;
name|text
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|text
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|GRsetwmask
argument_list|(
name|textmask
operator||
name|setmask
argument_list|)
expr_stmt|;
name|e1
operator|=
name|cset
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e1
argument_list|)
condition|)
block|{
if|if
condition|(
name|TEXT
argument_list|(
name|e1
operator|->
name|type
argument_list|)
condition|)
block|{
name|DISScreenErase
argument_list|(
name|e1
argument_list|,
operator|(
name|textmask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|TxMsgOK
argument_list|()
expr_stmt|;
name|UNRembMod
argument_list|(
name|e1
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|ppnt
operator|.
name|x
operator|=
name|e1
operator|->
name|ptlist
operator|->
name|x
expr_stmt|;
name|ppnt
operator|.
name|y
operator|=
name|e1
operator|->
name|ptlist
operator|->
name|y
expr_stmt|;
name|GRPutText
argument_list|(
name|e1
operator|->
name|type
argument_list|,
operator|&
name|ppnt
argument_list|,
name|e1
operator|->
name|brushf
argument_list|,
name|e1
operator|->
name|size
argument_list|,
name|text
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|p1
operator|=
name|PTInit
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|ppnt
operator|.
name|x
argument_list|,
name|ppnt
operator|.
name|y
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
comment|/* end extra positioning points */
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|pos
operator|.
name|x
argument_list|,
name|pos
operator|.
name|y
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|pos
operator|.
name|x
operator|+
name|i
operator|*
name|charxsize
operator|/
literal|2
argument_list|,
name|pos
operator|.
name|y
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|pos
operator|.
name|x
operator|+
name|i
operator|*
name|charxsize
argument_list|,
name|pos
operator|.
name|y
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
name|e1
operator|->
name|textpt
operator|=
name|text
expr_stmt|;
block|}
comment|/* end if text */
name|e1
operator|=
name|DBNextofSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGMText */
end_comment

begin_escape
end_escape

begin_macro
name|LGMPoint
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine modifies the element which contains the point  * closest to the first of two specified points so that that point  * coincides with the second of the points (if specified).  *  *       Note: it implies knowlege of the database representation by modifying  *           the element directly.  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|e1
decl_stmt|;
name|POINT
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|,
modifier|*
name|p4
decl_stmt|;
name|float
name|x1
decl_stmt|,
name|y1
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|1
condition|)
comment|/* no points */
block|{
name|error
argument_list|(
literal|"no point specified"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* find point */
name|DBSetGravitate
argument_list|(
name|POINTLIST
operator|->
name|x
argument_list|,
name|POINTLIST
operator|->
name|y
argument_list|,
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|p1
argument_list|,
operator|&
name|e1
argument_list|,
name|cset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e1
argument_list|)
condition|)
block|{
name|DBClearSet
argument_list|()
expr_stmt|;
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
name|DISScreenErase
argument_list|(
name|e1
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|UNRembMod
argument_list|(
name|e1
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|SEQ
operator|>
literal|1
condition|)
comment|/* move a point, not delete */
block|{
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|POINTLIST
argument_list|)
expr_stmt|;
name|p1
operator|->
name|x
operator|=
name|p2
operator|->
name|x
expr_stmt|;
name|p1
operator|->
name|y
operator|=
name|p2
operator|->
name|y
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Nullpoint
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|p3
operator|=
name|PTInit
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|p2
argument_list|)
condition|)
block|{
name|p4
operator|=
name|PTMakePoint
argument_list|(
name|p2
operator|->
name|x
argument_list|,
name|p2
operator|->
name|y
argument_list|,
operator|&
name|p3
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p2
argument_list|)
expr_stmt|;
block|}
name|p4
operator|->
name|nextpt
operator|=
name|p1
operator|->
name|nextpt
expr_stmt|;
name|p1
operator|->
name|nextpt
operator|=
name|p3
expr_stmt|;
block|}
block|}
else|else
block|{
name|PTDeletePoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
comment|/* end if !DBNullelt */
block|}
end_block

begin_comment
comment|/* end MPOINT */
end_comment

begin_escape
end_escape

begin_macro
name|LGGripe
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine allows users to leave gripe messages or report  * bugs to the maintainer.  Mail is invoked via the defined constant GRIPE.  */
end_comment

begin_block
block|{
name|TxClose
argument_list|()
expr_stmt|;
comment|/* Restore text terminal to 'normal' state */
operator|(
name|void
operator|)
name|system
argument_list|(
name|GMailCommand
argument_list|)
expr_stmt|;
comment|/* mail complaint */
name|SHRedis
argument_list|()
expr_stmt|;
comment|/* reclaim terminal */
block|}
end_block

begin_comment
comment|/* end Gripe */
end_comment

begin_macro
name|LGLittlePoint
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine controls the size of the point that is displayed  * The sizes available are artmode in which a small (3 x 3) point is displayed  * with no number and regular (non- artmode).  */
end_comment

begin_block
block|{
if|if
condition|(
name|artmode
condition|)
name|artmode
operator|=
name|FALSE
expr_stmt|;
else|else
name|artmode
operator|=
name|TRUE
expr_stmt|;
name|Consume
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end Little Point */
end_comment

begin_escape
end_escape

begin_macro
name|SetOrient
argument_list|(
argument|orient
argument_list|)
end_macro

begin_decl_stmt
name|int
name|orient
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine sets up the orientation of the drawing area.  */
end_comment

begin_block
block|{
name|int
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|y1
decl_stmt|,
name|y2
decl_stmt|;
comment|/* used to set grid parameters */
if|if
condition|(
name|orient
operator|==
literal|0
condition|)
comment|/* initialize grid */
block|{
name|x1
operator|=
name|y1
operator|=
literal|0
expr_stmt|;
name|x2
operator|=
literal|511
expr_stmt|;
name|y2
operator|=
literal|395
expr_stmt|;
block|}
else|else
block|{
name|x1
operator|=
literal|116
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
name|x2
operator|=
literal|511
expr_stmt|;
name|y2
operator|=
literal|483
expr_stmt|;
block|}
empty_stmt|;
name|MNInitMenu
argument_list|(
name|orient
argument_list|)
expr_stmt|;
name|GRSetGrid
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|LGOrient
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine toggles the orientation of the drawing area.  */
end_comment

begin_block
block|{
if|if
condition|(
name|Orientation
operator|==
literal|1
condition|)
block|{
name|Orientation
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Orientation
operator|=
literal|1
expr_stmt|;
block|}
empty_stmt|;
name|SetOrient
argument_list|(
name|Orientation
argument_list|)
expr_stmt|;
name|SHUpdate
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end Orient */
end_comment

begin_escape
end_escape

begin_macro
name|LGSave
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine writes the current set into the specified filename  * or to the current Editfile  */
end_comment

begin_block
block|{
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|fopen
argument_list|()
decl_stmt|;
name|char
name|tname
index|[
literal|50
index|]
decl_stmt|,
name|filename
index|[
literal|100
index|]
decl_stmt|,
name|string
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|tn
decl_stmt|,
modifier|*
name|fn
decl_stmt|,
modifier|*
name|wfile
decl_stmt|;
name|ELT
modifier|*
name|elist
decl_stmt|;
name|POINT
modifier|*
name|plist
decl_stmt|,
name|pos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|space
decl_stmt|,
name|stat
decl_stmt|;
name|space
operator|=
literal|100
expr_stmt|;
operator|++
name|line
expr_stmt|;
name|tn
operator|=
name|tname
expr_stmt|;
name|fn
operator|=
name|filename
expr_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"%s"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
comment|/* no filename */
block|{
name|error
argument_list|(
literal|"write to where?"
argument_list|)
expr_stmt|;
return|return;
block|}
name|stat
operator|=
name|PConvertTilde
argument_list|(
operator|&
name|tn
argument_list|,
operator|&
name|fn
argument_list|,
operator|&
name|space
argument_list|)
expr_stmt|;
operator|*
name|fn
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|FALSE
condition|)
block|{
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"unknown path %s"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|bang
condition|)
comment|/* user doesn't insist */
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"file already exists"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|wfile
operator|=
name|filename
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
comment|/* file error */
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"can't open %s"
argument_list|,
name|wfile
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
name|TxPutMsg
argument_list|(
literal|"writing file..."
argument_list|)
expr_stmt|;
name|CHANGED
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|SEQ
operator|>
literal|0
condition|)
comment|/* specified a positioning point */
block|{
name|pos
operator|.
name|x
operator|=
name|POINTLIST
operator|->
name|x
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|POINTLIST
operator|->
name|y
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|DBNullelt
argument_list|(
name|PICTURE
argument_list|)
condition|)
block|{
name|pos
operator|.
name|x
operator|=
name|PICTURE
operator|->
name|ptlist
operator|->
name|x
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|PICTURE
operator|->
name|ptlist
operator|->
name|y
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|.
name|x
operator|=
name|pos
operator|.
name|y
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"gremlinfile\n"
argument_list|)
expr_stmt|;
comment|/* write header */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d %1.2f %1.2f\n"
argument_list|,
name|Orientation
argument_list|,
name|pos
operator|.
name|x
argument_list|,
name|pos
operator|.
name|y
argument_list|)
expr_stmt|;
name|elist
operator|=
name|cset
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elist
argument_list|)
condition|)
comment|/* write each element */
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d\n"
argument_list|,
name|elist
operator|->
name|type
argument_list|)
expr_stmt|;
name|plist
operator|=
name|elist
operator|->
name|ptlist
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|plist
argument_list|)
condition|)
comment|/* write each point */
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%1.2f %1.2f\n"
argument_list|,
name|plist
operator|->
name|x
argument_list|,
name|plist
operator|->
name|y
argument_list|)
expr_stmt|;
name|plist
operator|=
name|PTNextPoint
argument_list|(
name|plist
argument_list|)
expr_stmt|;
block|}
comment|/* end while plist */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%1.2f %1.2f\n"
argument_list|,
operator|-
literal|1.0
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
comment|/* end pointlist */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d %d\n"
argument_list|,
name|elist
operator|->
name|brushf
argument_list|,
name|elist
operator|->
name|size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d %s\n "
argument_list|,
name|strlen
argument_list|(
name|elist
operator|->
name|textpt
argument_list|)
argument_list|,
name|elist
operator|->
name|textpt
argument_list|)
expr_stmt|;
name|elist
operator|=
name|DBNextofSet
argument_list|(
name|elist
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d\n"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* end of element list */
name|TxMsgOK
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGSave */
end_comment

begin_empty_stmt
empty_stmt|;
end_empty_stmt

end_unit

