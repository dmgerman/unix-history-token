begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_escape
end_escape

begin_comment
comment|/* graphics2.c  *  * Copyright -C- 1982 Barry S. Roitblat  *  * This file contains more routines for implementing the graphics primitives  * for the gremlin picture editor  *  * (Modified from software written by John Ousterhout for the caesar  *  program)  */
end_comment

begin_include
include|#
directive|include
file|"gremlin.h"
end_include

begin_include
include|#
directive|include
file|"grem2.h"
end_include

begin_comment
comment|/* imports from graphics1.c */
end_comment

begin_extern
extern|extern GRsetlinestyle(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|GRsetcharstyle
argument_list|()
operator|,
name|GRsetcharsize
argument_list|()
operator|,
name|GRsetpos
argument_list|()
operator|,
name|GRoutxy20
argument_list|()
operator|,
name|GRSetRead
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|display
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|curx
decl_stmt|,
name|cury
decl_stmt|,
name|rmask
decl_stmt|,
name|GrXMax
decl_stmt|,
name|GrYMax
decl_stmt|,
name|charysize
decl_stmt|,
name|charxsize
decl_stmt|,
name|descenders
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* imports from main.c */
end_comment

begin_extern
extern|extern error(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* The following is available to the outside world */
end_comment

begin_decl_stmt
name|int
name|artmode
decl_stmt|;
end_decl_stmt

begin_macro
name|GRVector
argument_list|(
argument|point1
argument_list|,
argument|point2
argument_list|,
argument|style
argument_list|)
end_macro

begin_decl_stmt
name|POINT
modifier|*
name|point1
decl_stmt|,
modifier|*
name|point2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|style
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|GRsetlinestyle
argument_list|(
name|style
argument_list|)
expr_stmt|;
name|GRsetpos
argument_list|(
operator|(
name|int
operator|)
name|point1
operator|->
name|x
argument_list|,
operator|(
name|int
operator|)
name|point1
operator|->
name|y
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'A'
argument_list|,
name|display
argument_list|)
expr_stmt|;
comment|/* Draw vector absolute */
name|GRoutxy20
argument_list|(
operator|(
name|int
operator|)
name|point2
operator|->
name|x
argument_list|,
operator|(
name|int
operator|)
name|point2
operator|->
name|y
argument_list|)
expr_stmt|;
name|curx
operator|=
name|point2
operator|->
name|x
expr_stmt|;
name|cury
operator|=
name|point2
operator|->
name|y
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|display
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
specifier|static
name|RelativeVector
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
name|float
name|x
operator|,
name|y
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  *     This routine outputs the proper character sequence to the AED  * to draw a vector in the current line style and from the current position  * to the point (x, y).  */
end_comment

begin_block
block|{
name|int
name|nextx
decl_stmt|,
name|nexty
decl_stmt|;
name|nextx
operator|=
operator|(
name|int
operator|)
name|x
expr_stmt|;
name|nexty
operator|=
operator|(
name|int
operator|)
name|y
expr_stmt|;
name|putc
argument_list|(
literal|'A'
argument_list|,
name|display
argument_list|)
expr_stmt|;
comment|/* draw vector absolute */
name|GRoutxy20
argument_list|(
name|nextx
argument_list|,
name|nexty
argument_list|)
expr_stmt|;
comment|/* output coordinates */
name|curx
operator|=
name|nextx
expr_stmt|;
name|cury
operator|=
name|nexty
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end RelativeVector */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|pi
value|3.14159265357
end_define

begin_define
define|#
directive|define
name|log2_10
value|3.321915
end_define

begin_function
name|int
name|GRArc
parameter_list|(
name|center
parameter_list|,
name|cpoint
parameter_list|,
name|angle
parameter_list|,
name|style
parameter_list|)
name|POINT
modifier|*
name|center
decl_stmt|,
decl|*
name|cpoint
decl_stmt|;
end_function

begin_decl_stmt
name|double
name|angle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|style
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|xs
decl_stmt|,
name|ys
decl_stmt|,
name|radius
decl_stmt|,
name|resolution
decl_stmt|,
name|t1
decl_stmt|,
name|epsalon
decl_stmt|,
name|fullcircle
decl_stmt|;
name|double
name|degreesperpoint
decl_stmt|;
name|int
name|i
decl_stmt|,
name|extent
decl_stmt|;
name|POINT
name|next
decl_stmt|;
name|xs
operator|=
name|cpoint
operator|->
name|x
operator|-
name|center
operator|->
name|x
expr_stmt|;
name|ys
operator|=
name|cpoint
operator|->
name|y
operator|-
name|center
operator|->
name|y
expr_stmt|;
if|if
condition|(
operator|(
name|xs
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ys
operator|==
literal|0
operator|)
condition|)
comment|/* radius = 0 */
block|{
name|error
argument_list|(
literal|"zero radius"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* calculate drawing parameters */
name|radius
operator|=
name|sqrt
argument_list|(
name|xs
operator|*
name|xs
operator|+
name|ys
operator|*
name|ys
argument_list|)
expr_stmt|;
name|t1
operator|=
name|floor
argument_list|(
name|log10
argument_list|(
name|radius
argument_list|)
operator|*
name|log2_10
argument_list|)
expr_stmt|;
name|resolution
operator|=
name|pow
argument_list|(
literal|2.0
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|epsalon
operator|=
literal|1.0
operator|/
name|resolution
expr_stmt|;
name|fullcircle
operator|=
name|ceil
argument_list|(
literal|2
operator|*
name|pi
operator|*
name|resolution
argument_list|)
expr_stmt|;
name|degreesperpoint
operator|=
literal|360.0
operator|/
name|fullcircle
expr_stmt|;
if|if
condition|(
name|angle
operator|==
literal|0
condition|)
block|{
name|extent
operator|=
name|fullcircle
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|radius
operator|<
literal|128
condition|)
comment|/* manageable by AED hardware */
block|{
name|GRsetpos
argument_list|(
operator|(
name|int
operator|)
name|center
operator|->
name|x
argument_list|,
operator|(
name|int
operator|)
name|center
operator|->
name|y
argument_list|)
expr_stmt|;
name|GRsetlinestyle
argument_list|(
name|style
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'O'
argument_list|,
name|display
argument_list|)
expr_stmt|;
comment|/* draw circle */
name|putc
argument_list|(
operator|(
operator|(
name|int
operator|)
name|radius
operator|)
operator|&
literal|0377
argument_list|,
name|display
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
name|extent
operator|=
name|angle
operator|/
name|degreesperpoint
expr_stmt|;
name|GRsetpos
argument_list|(
operator|(
name|int
operator|)
name|cpoint
operator|->
name|x
argument_list|,
operator|(
name|int
operator|)
name|cpoint
operator|->
name|y
argument_list|)
expr_stmt|;
name|GRsetlinestyle
argument_list|(
name|style
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|extent
condition|;
operator|++
name|i
control|)
block|{
name|xs
operator|-=
name|epsalon
operator|*
name|ys
expr_stmt|;
name|next
operator|.
name|x
operator|=
name|xs
operator|+
name|center
operator|->
name|x
expr_stmt|;
comment|/* round */
name|ys
operator|+=
name|epsalon
operator|*
name|xs
expr_stmt|;
name|next
operator|.
name|y
operator|=
name|ys
operator|+
name|center
operator|->
name|y
expr_stmt|;
comment|/* round */
name|RelativeVector
argument_list|(
name|next
operator|.
name|x
argument_list|,
name|next
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
comment|/* end for */
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* end GRArc */
end_comment

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|MAXPOINTS
value|200
end_define

begin_expr_stmt
specifier|static
name|Paramaterize
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|h
argument_list|,
argument|n
argument_list|)
name|float
name|x
index|[
name|MAXPOINTS
index|]
operator|,
name|y
index|[
name|MAXPOINTS
index|]
operator|,
name|h
index|[
name|MAXPOINTS
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*     This routine calculates parameteric values for use in calculating  * curves.  The parametric values are returned in the array u.  The values  * are an approximation of cumulative arc lengths of the curve (uses cord  * length).  For additional information, see paper cited below.  */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|float
name|u
index|[
name|MAXPOINTS
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
operator|++
name|i
control|)
block|{
name|u
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
block|{
name|u
index|[
name|i
index|]
operator|+=
name|sqrt
argument_list|(
name|pow
argument_list|(
call|(
name|double
call|)
argument_list|(
name|x
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|x
index|[
name|j
index|]
argument_list|)
argument_list|,
operator|(
name|double
operator|)
literal|2.0
argument_list|)
operator|+
name|pow
argument_list|(
call|(
name|double
call|)
argument_list|(
name|y
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|y
index|[
name|j
index|]
argument_list|)
argument_list|,
operator|(
name|double
operator|)
literal|2.0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|h
index|[
name|i
index|]
operator|=
name|u
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|u
index|[
name|i
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end Paramaterize */
end_comment

begin_expr_stmt
specifier|static
name|PeriodicSpline
argument_list|(
argument|h
argument_list|,
argument|z
argument_list|,
argument|dz
argument_list|,
argument|d2z
argument_list|,
argument|d3z
argument_list|,
argument|npoints
argument_list|)
name|float
name|h
index|[
name|MAXPOINTS
index|]
operator|,
name|z
index|[
name|MAXPOINTS
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Point list and paramaterization  */
end_comment

begin_decl_stmt
name|float
name|dz
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to return the 1st derivative */
end_comment

begin_decl_stmt
name|float
name|d2z
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2nd and 3rd derivatives */
end_comment

begin_decl_stmt
name|int
name|npoints
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of valid points */
end_comment

begin_comment
comment|/*  *     This routine solves for the cubic polynomial to fit a spline  * curve to the the points  specified by the list of values.  * The Curve generated is periodic.  The alogrithms for this   * curve are from the "Spline Curve Techniques" paper cited below.  */
end_comment

begin_block
block|{
name|float
name|d
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|deltaz
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|a
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|b
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|c
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|r
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|s
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* step 1 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|h
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|deltaz
index|[
name|i
index|]
operator|=
operator|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
expr_stmt|;
else|else
name|deltaz
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|h
index|[
literal|0
index|]
operator|=
name|h
index|[
name|npoints
operator|-
literal|1
index|]
expr_stmt|;
name|deltaz
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
name|npoints
operator|-
literal|1
index|]
expr_stmt|;
comment|/* step 2 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|deltaz
index|[
name|i
index|]
expr_stmt|;
block|}
name|d
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
literal|1
index|]
operator|-
name|deltaz
index|[
literal|0
index|]
expr_stmt|;
comment|/* step 3a */
name|a
index|[
literal|1
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
literal|0
index|]
operator|+
name|h
index|[
literal|1
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|1
index|]
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 3 consecutive knots at same point */
name|b
index|[
literal|1
index|]
operator|=
name|d
index|[
literal|0
index|]
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
name|h
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|a
index|[
name|i
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|h
index|[
name|i
index|]
operator|)
operator|-
name|pow
argument_list|(
operator|(
name|double
operator|)
name|h
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
operator|(
name|double
operator|)
literal|2.0
argument_list|)
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|a
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 3 consec knots at same point */
name|b
index|[
name|i
index|]
operator|=
name|d
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|h
index|[
name|i
operator|-
literal|1
index|]
operator|*
name|b
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|c
index|[
name|i
index|]
operator|=
operator|-
name|h
index|[
name|i
operator|-
literal|1
index|]
operator|*
name|c
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* step 3b */
name|r
index|[
name|npoints
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|s
index|[
name|npoints
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|npoints
operator|-
literal|2
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|r
index|[
name|i
index|]
operator|=
operator|-
operator|(
name|h
index|[
name|i
index|]
operator|*
name|r
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|c
index|[
name|i
index|]
operator|)
operator|/
name|a
index|[
name|i
index|]
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
operator|(
literal|6
operator|*
name|b
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
name|s
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
name|a
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* step 4 */
name|d2z
index|[
name|npoints
operator|-
literal|1
index|]
operator|=
operator|(
literal|6
operator|*
name|d
index|[
name|npoints
operator|-
literal|2
index|]
operator|-
name|h
index|[
literal|0
index|]
operator|*
name|s
index|[
literal|1
index|]
operator|-
name|h
index|[
name|npoints
operator|-
literal|1
index|]
operator|*
name|s
index|[
name|npoints
operator|-
literal|2
index|]
operator|)
operator|/
operator|(
name|h
index|[
literal|0
index|]
operator|*
name|r
index|[
literal|1
index|]
operator|+
name|h
index|[
name|npoints
operator|-
literal|1
index|]
operator|*
name|r
index|[
name|npoints
operator|-
literal|2
index|]
operator|+
literal|2
operator|*
operator|(
name|h
index|[
name|npoints
operator|-
literal|2
index|]
operator|+
name|h
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d2z
index|[
name|i
index|]
operator|=
name|r
index|[
name|i
index|]
operator|*
name|d2z
index|[
name|npoints
operator|-
literal|1
index|]
operator|+
name|s
index|[
name|i
index|]
expr_stmt|;
block|}
name|d2z
index|[
name|npoints
index|]
operator|=
name|d2z
index|[
literal|1
index|]
expr_stmt|;
comment|/* step 5 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
name|dz
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
operator|(
literal|2
operator|*
name|d2z
index|[
name|i
index|]
operator|+
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
literal|6
expr_stmt|;
if|if
condition|(
name|h
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|d3z
index|[
name|i
index|]
operator|=
operator|(
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|d2z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
expr_stmt|;
else|else
name|d3z
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* end PeriodicSpline */
end_comment

begin_escape
end_escape

begin_expr_stmt
specifier|static
name|NaturalEndSpline
argument_list|(
argument|h
argument_list|,
argument|z
argument_list|,
argument|dz
argument_list|,
argument|d2z
argument_list|,
argument|d3z
argument_list|,
argument|npoints
argument_list|)
name|float
name|h
index|[
name|MAXPOINTS
index|]
operator|,
name|z
index|[
name|MAXPOINTS
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Point list and parameterization */
end_comment

begin_decl_stmt
name|float
name|dz
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to return the 1st derivative */
end_comment

begin_decl_stmt
name|float
name|d2z
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3z
index|[
name|MAXPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2nd and 3rd derivatives */
end_comment

begin_decl_stmt
name|int
name|npoints
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of valid points */
end_comment

begin_comment
comment|/*  *     This routine solves for the cubic polynomial to fit a spline  * curve the the points  specified by the list of values.  The alogrithms for  * this curve are from the "Spline Curve Techniques" paper cited below.  */
end_comment

begin_block
block|{
name|float
name|d
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|deltaz
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|a
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|b
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* step 1 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|h
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|deltaz
index|[
name|i
index|]
operator|=
operator|(
name|z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
expr_stmt|;
else|else
name|deltaz
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|deltaz
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
name|npoints
operator|-
literal|1
index|]
expr_stmt|;
comment|/* step 2 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|d
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|deltaz
index|[
name|i
index|]
expr_stmt|;
block|}
name|d
index|[
literal|0
index|]
operator|=
name|deltaz
index|[
literal|1
index|]
operator|-
name|deltaz
index|[
literal|0
index|]
expr_stmt|;
comment|/* step 3 */
name|a
index|[
literal|0
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
literal|2
index|]
operator|+
name|h
index|[
literal|1
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 3 consec knots at same point */
name|b
index|[
literal|0
index|]
operator|=
name|d
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
operator|-
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|a
index|[
name|i
index|]
operator|=
literal|2
operator|*
operator|(
name|h
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|h
index|[
name|i
operator|+
literal|2
index|]
operator|)
operator|-
name|pow
argument_list|(
operator|(
name|double
operator|)
name|h
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|(
name|double
operator|)
literal|2.0
argument_list|)
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|a
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 3 consec knots at same point */
name|b
index|[
name|i
index|]
operator|=
name|d
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|h
index|[
name|i
operator|+
literal|1
index|]
operator|*
name|b
index|[
name|i
operator|-
literal|1
index|]
operator|/
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* step 4 */
name|d2z
index|[
name|npoints
index|]
operator|=
name|d2z
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|npoints
operator|-
literal|1
init|;
name|i
operator|>
literal|1
condition|;
operator|--
name|i
control|)
block|{
name|d2z
index|[
name|i
index|]
operator|=
operator|(
literal|6
operator|*
name|b
index|[
name|i
operator|-
literal|2
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
name|a
index|[
name|i
operator|-
literal|2
index|]
expr_stmt|;
block|}
comment|/* step 5 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|npoints
condition|;
operator|++
name|i
control|)
block|{
name|dz
index|[
name|i
index|]
operator|=
name|deltaz
index|[
name|i
index|]
operator|-
name|h
index|[
name|i
index|]
operator|*
operator|(
literal|2
operator|*
name|d2z
index|[
name|i
index|]
operator|+
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|/
literal|6
expr_stmt|;
if|if
condition|(
name|h
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|d3z
index|[
name|i
index|]
operator|=
operator|(
name|d2z
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|d2z
index|[
name|i
index|]
operator|)
operator|/
name|h
index|[
name|i
index|]
expr_stmt|;
else|else
name|d3z
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* end NaturalEndSpline */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|PointsPerInterval
value|16
end_define

begin_macro
name|GRCurve
argument_list|(
argument|pointlist
argument_list|,
argument|style
argument_list|)
end_macro

begin_decl_stmt
name|POINT
modifier|*
name|pointlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|style
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *    This routine generates a smooth curve through a set of points.  The   * method used is the parametric spline curve on unit knot mesh described  * in "Spline Curve Techniques" by Patrick Baudelaire, Robert Flegal, and   * Robert Sproull -- Xerox Parc.  */
end_comment

begin_block
block|{
name|float
name|h
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|y
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|dx
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|dy
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|d2x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d2y
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3x
index|[
name|MAXPOINTS
index|]
decl_stmt|,
name|d3y
index|[
name|MAXPOINTS
index|]
decl_stmt|;
name|float
name|t
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|xinter
decl_stmt|,
name|yinter
decl_stmt|;
name|POINT
modifier|*
name|ptr
decl_stmt|;
name|int
name|numpoints
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|stat
decl_stmt|;
name|GRsetlinestyle
argument_list|(
name|style
argument_list|)
expr_stmt|;
name|GRsetpos
argument_list|(
operator|(
name|int
operator|)
name|pointlist
operator|->
name|x
argument_list|,
operator|(
name|int
operator|)
name|pointlist
operator|->
name|y
argument_list|)
expr_stmt|;
comment|/* Copy point list to array for easier access */
name|ptr
operator|=
name|pointlist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
operator|!
name|Nullpoint
argument_list|(
name|ptr
argument_list|)
operator|)
condition|;
operator|++
name|i
control|)
block|{
name|x
index|[
name|i
index|]
operator|=
name|ptr
operator|->
name|x
expr_stmt|;
name|y
index|[
name|i
index|]
operator|=
name|ptr
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|MAXPOINTS
operator|-
literal|1
condition|)
break|break;
name|ptr
operator|=
name|PTNextPoint
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
comment|/* Solve for derivatives of the curve at each point                * separately for x and y (parametric). 	      */
name|numpoints
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|Paramaterize
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|h
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
name|stat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|x
index|[
literal|1
index|]
operator|==
name|x
index|[
name|numpoints
index|]
operator|)
operator|&&
operator|(
name|y
index|[
literal|1
index|]
operator|==
name|y
index|[
name|numpoints
index|]
operator|)
condition|)
comment|/* closed curve */
block|{
name|stat
operator||=
name|PeriodicSpline
argument_list|(
name|h
argument_list|,
name|x
argument_list|,
name|dx
argument_list|,
name|d2x
argument_list|,
name|d3x
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
name|stat
operator||=
name|PeriodicSpline
argument_list|(
name|h
argument_list|,
name|y
argument_list|,
name|dy
argument_list|,
name|d2y
argument_list|,
name|d3y
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stat
operator||=
name|NaturalEndSpline
argument_list|(
name|h
argument_list|,
name|x
argument_list|,
name|dx
argument_list|,
name|d2x
argument_list|,
name|d3x
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
name|stat
operator||=
name|NaturalEndSpline
argument_list|(
name|h
argument_list|,
name|y
argument_list|,
name|dy
argument_list|,
name|d2y
argument_list|,
name|d3y
argument_list|,
name|numpoints
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* error occurred */
comment|/* generate the curve using the above information and  	       * PointsPerInterval vectors between each specified knot. 	       */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|numpoints
condition|;
operator|++
name|j
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|PointsPerInterval
condition|;
operator|++
name|k
control|)
block|{
name|t
operator|=
operator|(
name|float
operator|)
name|k
operator|*
name|h
index|[
name|j
index|]
operator|/
operator|(
name|float
operator|)
name|PointsPerInterval
expr_stmt|;
name|t2
operator|=
name|t
operator|*
name|t
expr_stmt|;
name|t3
operator|=
name|t
operator|*
name|t
operator|*
name|t
expr_stmt|;
name|xinter
operator|=
name|x
index|[
name|j
index|]
operator|+
name|t
operator|*
name|dx
index|[
name|j
index|]
operator|+
name|t2
operator|*
name|d2x
index|[
name|j
index|]
operator|/
literal|2.0
operator|+
name|t3
operator|*
name|d3x
index|[
name|j
index|]
operator|/
literal|6.0
expr_stmt|;
name|yinter
operator|=
name|y
index|[
name|j
index|]
operator|+
name|t
operator|*
name|dy
index|[
name|j
index|]
operator|+
name|t2
operator|*
name|d2y
index|[
name|j
index|]
operator|/
literal|2.0
operator|+
name|t3
operator|*
name|d3y
index|[
name|j
index|]
operator|/
literal|6.0
expr_stmt|;
name|RelativeVector
argument_list|(
name|xinter
argument_list|,
name|yinter
argument_list|)
expr_stmt|;
block|}
comment|/* end for k */
block|}
comment|/* end for j */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* end GRCurve */
end_comment

begin_escape
end_escape

begin_macro
name|GRPutText
argument_list|(
argument|justify
argument_list|,
argument|point1
argument_list|,
argument|font
argument_list|,
argument|size
argument_list|,
argument|string
argument_list|,
argument|pos
argument_list|)
end_macro

begin_decl_stmt
name|int
name|justify
decl_stmt|,
name|font
decl_stmt|,
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|POINT
modifier|*
name|point1
decl_stmt|,
modifier|*
name|pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|string
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|length
decl_stmt|,
name|nchars
decl_stmt|,
name|i
decl_stmt|;
name|GRsetcharstyle
argument_list|(
name|font
argument_list|)
expr_stmt|;
name|GRsetcharsize
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|nchars
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|length
operator|=
name|nchars
operator|*
name|charxsize
expr_stmt|;
switch|switch
condition|(
name|justify
condition|)
block|{
case|case
name|BOTLEFT
case|:
name|pos
operator|->
name|x
operator|=
name|point1
operator|->
name|x
expr_stmt|;
name|pos
operator|->
name|y
operator|=
name|point1
operator|->
name|y
expr_stmt|;
break|break;
case|case
name|BOTCENT
case|:
name|pos
operator|->
name|x
operator|=
name|point1
operator|->
name|x
operator|-
operator|(
name|length
operator|/
literal|2
operator|)
expr_stmt|;
name|pos
operator|->
name|y
operator|=
name|point1
operator|->
name|y
expr_stmt|;
break|break;
case|case
name|BOTRIGHT
case|:
name|pos
operator|->
name|x
operator|=
name|point1
operator|->
name|x
operator|-
name|length
expr_stmt|;
name|pos
operator|->
name|y
operator|=
name|point1
operator|->
name|y
expr_stmt|;
break|break;
case|case
name|CENTLEFT
case|:
name|pos
operator|->
name|x
operator|=
name|point1
operator|->
name|x
expr_stmt|;
name|pos
operator|->
name|y
operator|=
name|point1
operator|->
name|y
operator|-
operator|(
name|charysize
operator|/
literal|2
operator|)
expr_stmt|;
break|break;
case|case
name|CENTCENT
case|:
name|pos
operator|->
name|x
operator|=
name|point1
operator|->
name|x
operator|-
operator|(
name|length
operator|/
literal|2
operator|)
expr_stmt|;
name|pos
operator|->
name|y
operator|=
name|point1
operator|->
name|y
operator|-
operator|(
name|charysize
operator|/
literal|2
operator|)
expr_stmt|;
break|break;
case|case
name|CENTRIGHT
case|:
name|pos
operator|->
name|x
operator|=
name|point1
operator|->
name|x
operator|-
name|length
expr_stmt|;
name|pos
operator|->
name|y
operator|=
name|point1
operator|->
name|y
operator|-
operator|(
name|charysize
operator|/
literal|2
operator|)
expr_stmt|;
break|break;
case|case
name|TOPLEFT
case|:
name|pos
operator|->
name|x
operator|=
name|point1
operator|->
name|x
expr_stmt|;
name|pos
operator|->
name|y
operator|=
name|point1
operator|->
name|y
operator|-
name|charysize
operator|+
name|descenders
expr_stmt|;
break|break;
case|case
name|TOPCENT
case|:
name|pos
operator|->
name|x
operator|=
name|point1
operator|->
name|x
operator|-
operator|(
name|length
operator|/
literal|2
operator|)
expr_stmt|;
name|pos
operator|->
name|y
operator|=
name|point1
operator|->
name|y
operator|-
name|charysize
operator|+
name|descenders
expr_stmt|;
break|break;
case|case
name|TOPRIGHT
case|:
name|pos
operator|->
name|x
operator|=
name|point1
operator|->
name|x
operator|-
name|length
expr_stmt|;
name|pos
operator|->
name|y
operator|=
name|point1
operator|->
name|y
operator|-
name|charysize
operator|+
name|descenders
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|pos
operator|->
name|x
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|pos
operator|->
name|x
operator|+
name|length
operator|-
name|charxsize
operator|)
operator|>
name|GrXMax
operator|)
condition|)
block|{
name|TxPutMsg
argument_list|(
literal|"\7string too long"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pos
operator|->
name|y
operator|+
name|charysize
operator|)
operator|>
name|GrYMax
condition|)
name|pos
operator|->
name|y
operator|=
name|GrYMax
operator|-
name|charysize
expr_stmt|;
if|if
condition|(
name|pos
operator|->
name|y
operator|<
literal|0
condition|)
name|pos
operator|->
name|y
operator|=
literal|0
expr_stmt|;
name|GRsetpos
argument_list|(
operator|(
name|int
operator|)
name|pos
operator|->
name|x
argument_list|,
operator|(
name|int
operator|)
name|pos
operator|->
name|y
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\6'
argument_list|,
name|display
argument_list|)
expr_stmt|;
comment|/* enter text mode */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchars
condition|;
operator|++
name|i
control|)
block|{
name|putc
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|display
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\33Q"
argument_list|,
name|display
argument_list|)
expr_stmt|;
comment|/* re-enter graphics mode */
name|GRoutxy20
argument_list|(
name|curx
argument_list|,
name|cury
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|display
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end PutText */
end_comment

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_escape
end_escape

begin_macro
name|GRClear
argument_list|(
argument|mask
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine clears the memory planes enabled by mask.  * The read mask is first set to avoid an annoying flash when the  * clear is performed.  */
end_comment

begin_block
block|{
name|int
name|savemask
decl_stmt|;
name|savemask
operator|=
name|rmask
expr_stmt|;
name|GRSetRead
argument_list|(
name|rmask
operator|&
operator|~
name|mask
argument_list|)
expr_stmt|;
name|GRsetwmask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'~'
argument_list|,
name|display
argument_list|)
expr_stmt|;
name|GRSetRead
argument_list|(
name|savemask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|display
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end GRClear */
end_comment

begin_macro
name|GRDisplayPoint
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|number
argument_list|,
argument|mark
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|number
decl_stmt|,
name|mark
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine displays a point on the screen.  The point is  * displayed as a '+' centered about the point (x,y) and followed by  * number.  */
end_comment

begin_block
block|{
name|POINT
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|int
name|psize
decl_stmt|;
if|if
condition|(
name|artmode
condition|)
name|psize
operator|=
literal|1
expr_stmt|;
else|else
name|psize
operator|=
name|halfpoint
expr_stmt|;
name|GRsetwmask
argument_list|(
name|pointmask
argument_list|)
expr_stmt|;
name|p1
operator|.
name|y
operator|=
name|p2
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|p1
operator|.
name|x
operator|=
name|x
operator|-
name|psize
expr_stmt|;
name|p2
operator|.
name|x
operator|=
name|x
operator|+
name|psize
expr_stmt|;
name|GRVector
argument_list|(
operator|&
name|p1
argument_list|,
operator|&
name|p2
argument_list|,
name|mark
argument_list|)
expr_stmt|;
name|p1
operator|.
name|x
operator|=
name|p2
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|p1
operator|.
name|y
operator|=
name|y
operator|-
name|psize
expr_stmt|;
name|p2
operator|.
name|y
operator|=
name|y
operator|+
name|psize
expr_stmt|;
name|GRVector
argument_list|(
operator|&
name|p1
argument_list|,
operator|&
name|p2
argument_list|,
name|mark
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|artmode
condition|)
block|{
name|GRsetcharsize
argument_list|(
name|pointchar
argument_list|)
expr_stmt|;
name|GRsetpos
argument_list|(
operator|(
name|x
operator|+
name|numspace
operator|)
argument_list|,
operator|(
name|y
operator|-
name|charysize
operator|/
literal|2
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|display
argument_list|,
literal|"\6%d\33"
argument_list|,
name|number
argument_list|)
expr_stmt|;
block|}
name|GRsetpos
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|display
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end DisplayPoint */
end_comment

begin_escape
end_escape

begin_macro
name|GRErasePoint
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|number
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine erases the specified point by redrawing it in the  * background color  */
end_comment

begin_block
block|{
name|GRDisplayPoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|number
argument_list|,
name|eraseany
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end ErasePoint */
end_comment

begin_macro
name|GRBlankPoints
argument_list|()
end_macro

begin_comment
comment|/*  *      This routine clears all displayed points by clearing  * the memory plane they are written on.  */
end_comment

begin_block
block|{
name|GRClear
argument_list|(
name|pointmask
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end BlankPoints */
end_comment

end_unit

