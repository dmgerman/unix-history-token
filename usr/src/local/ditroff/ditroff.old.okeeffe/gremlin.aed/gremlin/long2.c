begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)long2.c	1.2	%G%  *  * Copyright -C- 1982 Barry S. Roitblat  *  *  *      This file contains routines to implement the long text commands  * of the gremlin PICTURE editor.  *  */
end_comment

begin_include
include|#
directive|include
file|"gremlin.h"
end_include

begin_include
include|#
directive|include
file|"grem2.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* imports from graphics files */
end_comment

begin_extern
extern|extern GRVector(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|GRArc
argument_list|()
operator|,
name|GRPutText
argument_list|()
operator|,
name|GRClose
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern GRDisplayPoint(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|GRDeletePoint
argument_list|()
operator|,
name|GRBlankPoints
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern charxsize
operator|,
extern|charysize
operator|,
extern|GrXMax
operator|,
extern|GrYMax;
end_extern

begin_comment
comment|/* import from path.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|PSetPath
argument_list|()
decl_stmt|,
name|PConvertTilde
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|PGetPath
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* imports from display.c */
end_comment

begin_extern
extern|extern DISScreenAdd(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|DISScreenErase
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern DISDisplaySet(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|DISEraseSet
argument_list|()
operator|,
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* imports from database files */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|DBInit
argument_list|()
decl_stmt|,
modifier|*
name|DBCreateElt
argument_list|()
decl_stmt|,
modifier|*
name|DBRead
argument_list|()
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern DBDelete(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|DBGravitate
argument_list|()
operator|,
name|DBClearElt
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|extern
name|ELT
modifier|*
name|DBCopy
parameter_list|()
function_decl|;
end_function_decl

begin_extern
extern|extern DBXform(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|DBChangeBrush
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern DBAddSet(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|DBClearSet
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|POINT
modifier|*
name|PTInit
argument_list|()
decl_stmt|,
modifier|*
name|PTMakePoint
argument_list|()
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern PTDeletePoint(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from undodb.c */
end_comment

begin_decl_stmt
specifier|extern
name|UNELT
modifier|*
name|unlist
decl_stmt|,
modifier|*
name|unback
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern UNForget(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from short.c */
end_comment

begin_extern
extern|extern SHUpdate(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|extern
name|int
name|adj
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* imports from textio.c */
end_comment

begin_extern
extern|extern TxPutString(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|TxPutMsg
argument_list|()
operator|,
name|TxMsgOK
argument_list|()
operator|,
name|TxClose
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|TXFIELD
name|TAlign
decl_stmt|,
name|TAdjust
decl_stmt|,
name|TBrush
decl_stmt|,
name|TFont
decl_stmt|,
name|TGravity
decl_stmt|,
name|TCSize
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern TEdit
operator|,
extern|TJustmode;
end_extern

begin_comment
comment|/* imports from menu.c  */
end_comment

begin_extern
extern|extern MNHighLt(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|MNUnHighLt
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern HiMen[]
operator|,
extern|HiFont[]
operator|,
extern|HiBrush[]
operator|,
extern|HiMode[];
end_extern

begin_comment
comment|/* imports from c */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|sprintf
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* imports from main.c */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|PICTURE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current PICTURE database      */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|cset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current set database          */
end_comment

begin_extern
extern|extern CBRUSH
operator|,
extern|CSIZE
operator|,
extern|CFONT;
end_extern

begin_comment
comment|/* current brush, size, font     */
end_comment

begin_extern
extern|extern CJUST;
end_extern

begin_comment
comment|/* current text justification    */
end_comment

begin_extern
extern|extern Gridon;
end_extern

begin_comment
comment|/* grid mode flag                */
end_comment

begin_extern
extern|extern Orientation;
end_extern

begin_comment
comment|/* orientation of workspace      */
end_comment

begin_extern
extern|extern SEARCH;
end_extern

begin_comment
comment|/* flag for path search          */
end_comment

begin_extern
extern|extern Alignment;
end_extern

begin_comment
comment|/* point alignment indicator     */
end_comment

begin_decl_stmt
specifier|extern
name|float
name|PX
decl_stmt|,
name|PY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cursor coordinates            */
end_comment

begin_decl_stmt
specifier|extern
name|float
name|Lastx
decl_stmt|,
name|Lasty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* previous cursor coordinates   */
end_comment

begin_extern
extern|extern SEQ;
end_extern

begin_comment
comment|/* point sequence number         */
end_comment

begin_decl_stmt
specifier|extern
name|POINT
modifier|*
name|POINTLIST
decl_stmt|,
modifier|*
name|BACKPOINT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* accumulated point list        */
end_comment

begin_extern
extern|extern Gridsize;
end_extern

begin_comment
comment|/* grid spacing                  */
end_comment

begin_extern
extern|extern Adjustment;
end_extern

begin_comment
comment|/* point adjustment mode         */
end_comment

begin_extern
extern|extern GravityOn;
end_extern

begin_comment
comment|/* gravity mode flag             */
end_comment

begin_extern
extern|extern Consume;
end_extern

begin_comment
comment|/* point clear flag              */
end_comment

begin_extern
extern|extern CHANGED;
end_extern

begin_comment
comment|/* PICTURE changed flag          */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|MEN
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers for user symbols     */
end_comment

begin_decl_stmt
specifier|extern
name|POINT
name|MENPOINT
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers used fo user symbols */
end_comment

begin_extern
extern|extern cmdbuf[];
end_extern

begin_comment
comment|/* line buffer for commands      */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|textpos
index|[]
decl_stmt|,
modifier|*
name|dispmode
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* text positioning modes        */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|textmode
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* text positioning              */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|lines
index|[]
decl_stmt|,
modifier|*
name|fonts
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line and character styles     */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|jmodes
decl_stmt|,
name|lnum
index|[]
decl_stmt|,
name|fnum
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  imports from long1.c         */
end_comment

begin_extern
extern|extern bang;
end_extern

begin_extern
extern|extern GetNumParm(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern LGLookup(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern SetOrient(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|char
modifier|*
name|Editfile
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BADNUM
value|-1
end_define

begin_define
define|#
directive|define
name|NONUM
value|-2
end_define

begin_define
define|#
directive|define
name|Delimiter
parameter_list|(
name|c
parameter_list|)
value|((c == '\0') || (c == ' ') || (c == ','))
end_define

begin_decl_stmt
specifier|static
name|char
name|badarg
index|[
literal|10
index|]
init|=
literal|"bad args"
decl_stmt|;
end_decl_stmt

begin_macro
name|LGFont
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine looks at the command line for parameters to set  * the current Font.  */
end_comment

begin_block
block|{
name|int
name|new
decl_stmt|,
name|index
decl_stmt|;
name|char
name|string
index|[
literal|2
index|]
decl_stmt|;
name|Consume
operator|=
name|FALSE
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
operator|*
operator|(
operator|++
name|line
operator|)
argument_list|)
condition|)
block|{
name|new
operator|=
name|LGLookup
argument_list|(
name|line
argument_list|,
name|fonts
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|>=
literal|0
condition|)
name|new
operator|=
name|fnum
index|[
name|new
index|]
expr_stmt|;
else|else
name|new
operator|=
name|BADNUM
expr_stmt|;
block|}
else|else
name|new
operator|=
name|GetNumParm
argument_list|(
name|line
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|==
name|BADNUM
operator|)
operator|||
operator|(
name|new
operator|>
name|NFONTS
operator|)
condition|)
block|{
name|error
argument_list|(
name|badarg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|new
operator|!=
name|NONUM
condition|)
block|{
name|MNUnHighLt
argument_list|(
name|HiFont
index|[
name|CFONT
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|MNHighLt
argument_list|(
name|HiFont
index|[
name|new
operator|-
literal|1
index|]
argument_list|,
name|hicolor
argument_list|)
expr_stmt|;
name|CFONT
operator|=
name|new
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%1d"
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TFont
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end LGFont */
end_comment

begin_macro
name|LGJust
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine looks at the command line for parameters to set  * the current text justification mode.  */
end_comment

begin_block
block|{
name|int
name|new
decl_stmt|,
name|index
decl_stmt|;
name|Consume
operator|=
name|FALSE
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
operator|*
operator|(
operator|++
name|line
operator|)
argument_list|)
condition|)
block|{
comment|/* make sure mode is in lower case, and look up in table */
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|line
argument_list|)
condition|)
block|{
operator|*
name|line
operator|=
name|tolower
argument_list|(
operator|*
name|line
argument_list|)
expr_stmt|;
operator|*
operator|(
name|line
operator|+
literal|1
operator|)
operator|=
name|tolower
argument_list|(
operator|*
operator|(
name|line
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|new
operator|=
literal|0
init|;
operator|(
name|strcmp
argument_list|(
name|line
argument_list|,
name|textpos
index|[
name|new
index|]
argument_list|)
operator|!=
literal|0
operator|)
condition|;
operator|++
name|new
control|)
if|if
condition|(
name|new
operator|>
name|jmodes
condition|)
block|{
name|error
argument_list|(
literal|"no such mode"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|new
operator|<
literal|0
condition|)
name|new
operator|=
name|BADNUM
expr_stmt|;
block|}
else|else
name|new
operator|=
name|GetNumParm
argument_list|(
name|line
argument_list|,
operator|&
name|index
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|<=
name|BADNUM
operator|)
operator|||
operator|(
name|new
operator|>
name|jmodes
operator|)
condition|)
block|{
name|error
argument_list|(
name|badarg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|new
operator|!=
name|NONUM
condition|)
block|{
name|new
operator|=
name|textmode
index|[
name|new
index|]
expr_stmt|;
name|CJUST
operator|=
name|new
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TJustmode
argument_list|,
name|dispmode
index|[
name|new
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* end LGJust */
end_comment

begin_macro
name|LGSize
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine changes the current character size.  */
end_comment

begin_block
block|{
name|int
name|new
decl_stmt|,
name|index
decl_stmt|;
name|char
name|string
index|[
literal|2
index|]
decl_stmt|;
name|index
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|GetNumParm
argument_list|(
name|line
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|==
name|BADNUM
operator|)
operator|||
operator|(
name|new
operator|>
name|NSIZES
operator|)
condition|)
block|{
name|error
argument_list|(
name|badarg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|new
operator|!=
name|NONUM
condition|)
block|{
name|CSIZE
operator|=
name|new
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%1d"
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TCSize
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
name|Consume
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGSize */
end_comment

begin_macro
name|LGAlign
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine sets the point alignment indicator  */
end_comment

begin_block
block|{
name|int
name|newalign
decl_stmt|,
name|index
decl_stmt|;
name|char
name|string
index|[
literal|4
index|]
decl_stmt|;
name|index
operator|=
literal|1
expr_stmt|;
name|newalign
operator|=
name|GetNumParm
argument_list|(
name|line
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|newalign
operator|==
name|NONUM
condition|)
if|if
condition|(
name|Alignment
operator|==
literal|1
condition|)
name|Alignment
operator|=
name|Gridsize
expr_stmt|;
else|else
name|Alignment
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|newalign
operator|<
literal|1
operator|)
operator|||
operator|(
name|newalign
operator|>
name|GrYMax
operator|/
literal|2
operator|)
condition|)
block|{
name|error
argument_list|(
name|badarg
argument_list|)
expr_stmt|;
return|return;
block|}
name|Alignment
operator|=
name|newalign
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%3d"
argument_list|,
name|Alignment
argument_list|)
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TAlign
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|Consume
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGAlign */
end_comment

begin_macro
name|LGIncludeSet
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine adds all elements selected by points in POINTLIST  * to the current set.  It does not remove previously selected elements.  *  */
end_comment

begin_block
block|{
name|POINT
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|ELT
modifier|*
name|e1
decl_stmt|;
name|float
name|n1
decl_stmt|,
name|n2
decl_stmt|;
if|if
condition|(
name|DBNullelt
argument_list|(
name|PICTURE
argument_list|)
condition|)
return|return;
if|if
condition|(
name|SEQ
operator|==
literal|0
condition|)
comment|/* no points: entire picture becomes */
block|{
comment|/* current set                       */
name|e1
operator|=
name|PICTURE
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e1
argument_list|)
condition|)
block|{
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|DISDisplaySet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|e1
operator|=
name|DBNextElt
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end if */
else|else
block|{
name|p1
operator|=
name|POINTLIST
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|p1
argument_list|)
condition|)
block|{
name|DBGravitate
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|n1
argument_list|,
operator|&
name|n2
argument_list|,
operator|&
name|p2
argument_list|,
operator|&
name|e1
argument_list|,
name|PICTURE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e1
argument_list|)
condition|)
block|{
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|DISDisplaySet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
empty_stmt|;
block|}
comment|/* end else */
block|}
end_block

begin_comment
comment|/* end LGIncludeSet */
end_comment

begin_macro
name|LGMenu
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine implements the menu command.  The contents of   * the specified user menu item is copied into the PICTURE transformed  * to the positioning point.  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|elist
decl_stmt|,
modifier|*
name|e1
decl_stmt|;
name|POINT
modifier|*
name|plist
decl_stmt|;
name|int
name|symbol
decl_stmt|,
name|index
decl_stmt|;
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"no positioning point"
argument_list|)
expr_stmt|;
return|return;
block|}
name|index
operator|=
literal|1
expr_stmt|;
name|symbol
operator|=
name|GetNumParm
argument_list|(
name|line
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|symbol
operator|<=
literal|0
operator|)
operator|||
operator|(
name|symbol
operator|>
name|NUSER
operator|)
condition|)
block|{
name|error
argument_list|(
name|badarg
argument_list|)
expr_stmt|;
return|return;
block|}
name|symbol
operator|--
expr_stmt|;
comment|/* users inputs number between 1 and N, actual                      symbol number is between 0 and N-1          */
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* create transformation matrix */
name|xmat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|xmat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* for copy into PICTURE        */
name|plist
operator|=
name|POINTLIST
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|plist
argument_list|)
condition|)
block|{
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
comment|/* Clear old current set */
name|DBClearSet
argument_list|()
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|plist
operator|->
name|x
operator|-
operator|(
name|MENPOINT
index|[
name|symbol
index|]
operator|)
operator|.
name|x
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|plist
operator|->
name|y
operator|-
operator|(
name|MENPOINT
index|[
name|symbol
index|]
operator|)
operator|.
name|y
expr_stmt|;
name|elist
operator|=
name|MEN
index|[
name|symbol
index|]
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elist
argument_list|)
condition|)
comment|/* copy buffer to picture */
block|{
name|e1
operator|=
name|DBCopy
argument_list|(
name|elist
argument_list|,
name|xmat
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|elist
operator|=
name|DBNextElt
argument_list|(
name|elist
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
name|plist
operator|=
name|PTNextPoint
argument_list|(
name|plist
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGMenu */
end_comment

begin_macro
name|LGRead
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine reads in the specified filename (command line) to the  * selected user symbol or current set if no user symbol is selected.  If  * no filename is specified, the current set is copied to the user symbol;  */
end_comment

begin_block
block|{
name|POINT
name|pos
decl_stmt|,
name|ppos
decl_stmt|;
name|ELT
modifier|*
name|elist
decl_stmt|,
modifier|*
name|e1
decl_stmt|;
name|char
name|tname
index|[
literal|50
index|]
decl_stmt|,
name|filename
index|[
literal|100
index|]
decl_stmt|;
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|orient
decl_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
comment|/* no arguments */
block|{
name|error
argument_list|(
name|badarg
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|line
expr_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"%s"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|elist
operator|=
name|DBRead
argument_list|(
name|tname
argument_list|,
operator|&
name|orient
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
comment|/* read file */
name|UNForget
argument_list|()
expr_stmt|;
comment|/* forget changes registered by DBRead */
if|if
condition|(
name|SEQ
operator|<
literal|1
condition|)
comment|/* no positioning point */
block|{
name|ppos
operator|.
name|x
operator|=
name|pos
operator|.
name|x
expr_stmt|;
name|ppos
operator|.
name|y
operator|=
name|pos
operator|.
name|y
expr_stmt|;
block|}
else|else
block|{
name|ppos
operator|.
name|x
operator|=
name|POINTLIST
operator|->
name|x
expr_stmt|;
name|ppos
operator|.
name|y
operator|=
name|POINTLIST
operator|->
name|y
expr_stmt|;
block|}
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* set up matrix to copy to */
name|xmat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|xmat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* appropriate place in     */
name|xmat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|ppos
operator|.
name|x
operator|-
name|pos
operator|.
name|x
expr_stmt|;
comment|/* picture as current set   */
name|xmat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|ppos
operator|.
name|y
operator|-
name|pos
operator|.
name|y
expr_stmt|;
name|DBClearSet
argument_list|()
expr_stmt|;
name|DISClearSetDisplay
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elist
argument_list|)
condition|)
block|{
name|e1
operator|=
name|DBCopy
argument_list|(
name|elist
argument_list|,
name|xmat
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|e1
operator|=
name|DBNextElt
argument_list|(
name|elist
argument_list|)
expr_stmt|;
name|DBClearElt
argument_list|(
name|elist
argument_list|)
expr_stmt|;
name|elist
operator|=
name|e1
expr_stmt|;
block|}
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGRead */
end_comment

begin_macro
name|LGEdit
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This routine reads in a new PICTURE for editing  */
end_comment

begin_block
block|{
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|POpen
argument_list|()
decl_stmt|;
name|POINT
name|pos
decl_stmt|;
name|ELT
modifier|*
name|e1
decl_stmt|;
name|char
modifier|*
name|tn
decl_stmt|,
name|tname
index|[
literal|50
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|bang
condition|)
comment|/* no ! */
block|{
if|if
condition|(
name|CHANGED
condition|)
block|{
name|error
argument_list|(
literal|"no write"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* end if !bang */
empty_stmt|;
name|DBClearSet
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|PICTURE
argument_list|)
condition|)
comment|/* clear current PICTURE */
block|{
name|e1
operator|=
name|DBNextElt
argument_list|(
name|PICTURE
argument_list|)
expr_stmt|;
name|DBClearElt
argument_list|(
name|PICTURE
argument_list|)
expr_stmt|;
name|PICTURE
operator|=
name|e1
expr_stmt|;
block|}
empty_stmt|;
operator|++
name|line
expr_stmt|;
name|tn
operator|=
name|tname
expr_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"%s"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|POINTLIST
operator|=
name|PTInit
argument_list|()
expr_stmt|;
comment|/* Initialize globals */
name|SEQ
operator|=
literal|0
expr_stmt|;
name|CHANGED
operator|=
name|FALSE
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
comment|/* filename present */
block|{
name|fp
operator|=
name|POpen
argument_list|(
name|tname
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
name|SEARCH
argument_list|)
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TEdit
argument_list|,
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|PICTURE
operator|=
name|DBInit
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|" (creating new file)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PICTURE
operator|=
name|DBRead
argument_list|(
name|tname
argument_list|,
operator|&
name|Orientation
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|SetOrient
argument_list|(
name|Orientation
argument_list|)
expr_stmt|;
comment|/* Set appropriate picture area                                         * orientation                    */
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Editfile
argument_list|,
name|tname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TxPutString
argument_list|(
operator|&
name|TEdit
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Editfile
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|unlist
operator|=
name|unback
operator|=
name|nullun
expr_stmt|;
name|CP
argument_list|()
expr_stmt|;
name|SHUpdate
argument_list|()
expr_stmt|;
comment|/* display new picture */
block|}
end_block

begin_comment
comment|/* end LGEdit */
end_comment

begin_expr_stmt
specifier|static
name|restorepoints
argument_list|()
comment|/* This routine (re) displays the points in the back-up pointlist  */
block|{
name|int
name|i
block|;
name|POINT
operator|*
name|plist
block|,
operator|*
name|pl1
block|,
operator|*
name|pl2
block|;
name|GRBlankPoints
argument_list|()
block|;
name|plist
operator|=
name|BACKPOINT
block|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|Nullpoint
argument_list|(
name|plist
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|Lastx
operator|=
name|plist
operator|->
name|x
expr_stmt|;
name|Lasty
operator|=
name|plist
operator|->
name|y
expr_stmt|;
name|GRDisplayPoint
argument_list|(
operator|(
name|int
operator|)
name|plist
operator|->
name|x
argument_list|,
operator|(
name|int
operator|)
name|plist
operator|->
name|y
argument_list|,
name|i
argument_list|,
name|pointstyle
argument_list|)
expr_stmt|;
name|plist
operator|=
name|PTNextPoint
argument_list|(
name|plist
argument_list|)
expr_stmt|;
block|}
name|pl1
operator|=
name|POINTLIST
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|POINTLIST
operator|=
name|BACKPOINT
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SEQ
operator|=
name|i
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BACKPOINT
operator|=
name|pl1
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* end restorepoints */
end_comment

begin_expr_stmt
unit|LGUndo
operator|(
name|line
operator|)
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*   *      This routine uses the information in the undo database to reconstruct  * the PICTURE as it was before the last command.  The undo database is set  * so that the next undo would nullify this one.  * An undo of an Add is to delete the new element.  * Add the old element back to undo a delete.  * Modified elements are undone by copying the old element into the database  * in place of the modified element.  */
end_comment

begin_block
block|{
name|UNELT
modifier|*
name|fix
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|ELT
argument_list|*
operator|(
operator|*
name|e1
operator|)
argument_list|;
name|fix
operator|=
name|unlist
argument_list|;
comment|/* initialize unlist so that undo-ing can   */
name|unlist
operator|=
name|nullun
argument_list|;
comment|/* add items to properly undo the undo      */
argument_list|if
operator|(
name|fix
operator|==
name|nullun
operator|)
block|{
name|fix
operator|=
name|unback
block|;
name|unback
operator|=
name|nullun
block|;     }
name|DBClearSet
argument_list|()
argument_list|;
name|DISClearSetDisplay
argument_list|()
argument_list|;
name|GRBlankPoints
argument_list|()
argument_list|;     while
operator|(
name|fix
operator|!=
name|nullun
operator|)
block|{
switch|switch
condition|(
name|fix
operator|->
name|action
condition|)
block|{
case|case
name|ADD
case|:
name|DISScreenErase
argument_list|(
name|fix
operator|->
name|newelt
argument_list|,
name|linemask
argument_list|)
expr_stmt|;
name|TxMsgOK
argument_list|()
expr_stmt|;
name|restorepoints
argument_list|()
expr_stmt|;
name|DBDelete
argument_list|(
name|fix
operator|->
name|newelt
argument_list|,
name|fix
operator|->
name|dbase
argument_list|)
expr_stmt|;
name|temp
operator|=
name|fix
operator|->
name|nextun
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fix
argument_list|)
expr_stmt|;
name|fix
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|DELETE
case|:
name|fix
operator|->
name|action
operator|=
name|ADD
expr_stmt|;
comment|/* create undo unelt */
name|fix
operator|->
name|newelt
operator|=
name|fix
operator|->
name|oldelt
expr_stmt|;
name|fix
operator|->
name|oldelt
operator|=
name|NULL
expr_stmt|;
name|fix
operator|->
name|newelt
operator|->
name|nextelt
operator|=
name|PICTURE
expr_stmt|;
name|restorepoints
argument_list|()
expr_stmt|;
name|DBAddSet
argument_list|(
name|fix
operator|->
name|newelt
argument_list|)
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|fix
operator|->
name|newelt
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|PICTURE
operator|=
name|fix
operator|->
name|newelt
expr_stmt|;
comment|/* put in database */
name|temp
operator|=
name|fix
operator|->
name|nextun
expr_stmt|;
name|fix
operator|->
name|nextun
operator|=
name|unlist
expr_stmt|;
comment|/* link into unlist */
name|unlist
operator|=
name|fix
expr_stmt|;
name|fix
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|MOD
case|:
name|DISScreenErase
argument_list|(
name|fix
operator|->
name|newelt
argument_list|,
name|linemask
argument_list|)
expr_stmt|;
name|TxMsgOK
argument_list|()
expr_stmt|;
name|restorepoints
argument_list|()
expr_stmt|;
name|DISScreenAdd
argument_list|(
name|fix
operator|->
name|oldelt
argument_list|,
operator|(
name|setmask
operator||
name|linemask
operator|)
argument_list|)
expr_stmt|;
name|DBAddSet
argument_list|(
name|fix
operator|->
name|oldelt
argument_list|)
expr_stmt|;
name|e1
operator|=
name|fix
operator|->
name|dbase
expr_stmt|;
while|while
condition|(
operator|*
name|e1
operator|!=
name|fix
operator|->
name|newelt
condition|)
block|{
comment|/* find elt to replace */
name|e1
operator|=
operator|&
operator|(
name|DBNextElt
argument_list|(
operator|(
operator|*
name|e1
operator|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|fix
operator|->
name|oldelt
operator|->
name|nextelt
operator|=
name|DBNextElt
argument_list|(
operator|(
operator|*
name|e1
operator|)
argument_list|)
argument_list|;
operator|*
name|e1
operator|=
name|fix
operator|->
name|oldelt
argument_list|;
name|fix
operator|->
name|oldelt
operator|=
name|fix
operator|->
name|newelt
argument_list|;
name|fix
operator|->
name|newelt
operator|=
operator|*
name|e1
argument_list|;
comment|/* create undo unelt */
name|temp
operator|=
name|fix
operator|->
name|nextun
argument_list|;
name|fix
operator|->
name|nextun
operator|=
name|unlist
argument_list|;
name|unlist
operator|=
name|fix
argument_list|;
comment|/* link into unlist */
name|fix
operator|=
name|temp
argument_list|;                       break;
block|}
end_block

begin_comment
comment|/* end switch */
end_comment

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/* end while */
end_comment

begin_expr_stmt
unit|Consume
operator|=
name|FALSE
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* LGUndo */
end_comment

begin_expr_stmt
unit|LGWrite
operator|(
name|line
operator|)
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  *      This routine writes the current PICTURE into the specified filename  * or to the current Editfile  */
end_comment

begin_block
block|{
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|fopen
argument_list|()
decl_stmt|;
name|char
name|tname
index|[
literal|50
index|]
decl_stmt|,
name|filename
index|[
literal|100
index|]
decl_stmt|,
name|string
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|tn
decl_stmt|,
modifier|*
name|fn
decl_stmt|,
modifier|*
name|wfile
decl_stmt|;
name|ELT
modifier|*
name|elist
decl_stmt|;
name|POINT
modifier|*
name|plist
decl_stmt|,
name|pos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|space
decl_stmt|,
name|stat
decl_stmt|;
name|space
operator|=
literal|100
expr_stmt|;
operator|++
name|line
expr_stmt|;
name|tn
operator|=
name|tname
expr_stmt|;
name|fn
operator|=
name|filename
expr_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"%s"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
comment|/* no filename */
block|{
if|if
condition|(
operator|*
name|Editfile
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"write to where?"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fp
operator|=
name|fopen
argument_list|(
name|Editfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|wfile
operator|=
name|Editfile
expr_stmt|;
block|}
else|else
block|{
name|stat
operator|=
name|PConvertTilde
argument_list|(
operator|&
name|tn
argument_list|,
operator|&
name|fn
argument_list|,
operator|&
name|space
argument_list|)
expr_stmt|;
operator|*
name|fn
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|FALSE
condition|)
block|{
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"unknown path %s"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|bang
condition|)
comment|/* user doesn't insist */
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"file already exists"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|wfile
operator|=
name|filename
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
comment|/* file error */
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"can't open %s"
argument_list|,
name|wfile
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
name|TxPutMsg
argument_list|(
literal|"writing file..."
argument_list|)
expr_stmt|;
name|CHANGED
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|SEQ
operator|>
literal|0
condition|)
comment|/* specified a positioning point */
block|{
name|pos
operator|.
name|x
operator|=
name|POINTLIST
operator|->
name|x
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|POINTLIST
operator|->
name|y
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|DBNullelt
argument_list|(
name|PICTURE
argument_list|)
condition|)
block|{
name|pos
operator|.
name|x
operator|=
name|PICTURE
operator|->
name|ptlist
operator|->
name|x
expr_stmt|;
name|pos
operator|.
name|y
operator|=
name|PICTURE
operator|->
name|ptlist
operator|->
name|y
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|.
name|x
operator|=
name|pos
operator|.
name|y
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"gremlinfile\n"
argument_list|)
expr_stmt|;
comment|/* write header */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d %1.2f %1.2f\n"
argument_list|,
name|Orientation
argument_list|,
name|pos
operator|.
name|x
argument_list|,
name|pos
operator|.
name|y
argument_list|)
expr_stmt|;
name|elist
operator|=
name|PICTURE
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|elist
argument_list|)
condition|)
comment|/* write each element */
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d\n"
argument_list|,
name|elist
operator|->
name|type
argument_list|)
expr_stmt|;
name|plist
operator|=
name|elist
operator|->
name|ptlist
expr_stmt|;
while|while
condition|(
operator|!
name|Nullpoint
argument_list|(
name|plist
argument_list|)
condition|)
comment|/* write each point */
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%1.2f %1.2f\n"
argument_list|,
name|plist
operator|->
name|x
argument_list|,
name|plist
operator|->
name|y
argument_list|)
expr_stmt|;
name|plist
operator|=
name|PTNextPoint
argument_list|(
name|plist
argument_list|)
expr_stmt|;
block|}
comment|/* end while plist */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%1.2f %1.2f\n"
argument_list|,
operator|-
literal|1.0
argument_list|,
operator|-
literal|1.0
argument_list|)
expr_stmt|;
comment|/* end pointlist */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d %d\n"
argument_list|,
name|elist
operator|->
name|brushf
argument_list|,
name|elist
operator|->
name|size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d %s\n "
argument_list|,
name|strlen
argument_list|(
name|elist
operator|->
name|textpt
argument_list|)
argument_list|,
name|elist
operator|->
name|textpt
argument_list|)
expr_stmt|;
name|elist
operator|=
name|DBNextElt
argument_list|(
name|elist
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d\n"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* end of element list */
name|TxMsgOK
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGWrite */
end_comment

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|LGQuit
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine terminates the editor.  The terminal states for the text  * terminal and the graphics display are restored and an EXIT is performed.  */
end_comment

begin_block
block|{
if|if
condition|(
operator|!
name|bang
condition|)
block|{
if|if
condition|(
name|CHANGED
condition|)
block|{
name|error
argument_list|(
literal|"no write"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* end if */
empty_stmt|;
name|GRClose
argument_list|()
expr_stmt|;
name|TxClose
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGQuit */
end_comment

begin_macro
name|LGHAdjust
argument_list|()
end_macro

begin_comment
comment|/*  * Horizontal adjust -  *      This routine toggles the adjustment mode.  */
end_comment

begin_block
block|{
if|if
condition|(
name|Adjustment
operator|==
name|HORZ
condition|)
block|{
name|MNUnHighLt
argument_list|(
name|HiMode
index|[
name|adj
index|[
name|HORZ
index|]
index|]
argument_list|)
expr_stmt|;
name|Adjustment
operator|=
name|NOADJ
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TAdjust
argument_list|,
literal|"NO ADJUSTMENT"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MNUnHighLt
argument_list|(
name|HiMode
index|[
name|adj
index|[
name|Adjustment
index|]
index|]
argument_list|)
expr_stmt|;
name|MNHighLt
argument_list|(
name|HiMode
index|[
name|adj
index|[
name|HORZ
index|]
index|]
argument_list|,
name|hicolor
argument_list|)
expr_stmt|;
name|Adjustment
operator|=
name|HORZ
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TAdjust
argument_list|,
literal|" HORIZONTAL  "
argument_list|)
expr_stmt|;
block|}
name|Consume
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_macro
name|LGVAdjust
argument_list|()
end_macro

begin_comment
comment|/*  * Vertical adjust -  *      This routine toggles the adjustment mode.  */
end_comment

begin_block
block|{
if|if
condition|(
name|Adjustment
operator|==
name|VERT
condition|)
block|{
name|MNUnHighLt
argument_list|(
name|HiMode
index|[
name|adj
index|[
name|VERT
index|]
index|]
argument_list|)
expr_stmt|;
name|Adjustment
operator|=
name|NOADJ
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TAdjust
argument_list|,
literal|"NO ADJUSTMENT"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MNUnHighLt
argument_list|(
name|HiMode
index|[
name|adj
index|[
name|Adjustment
index|]
index|]
argument_list|)
expr_stmt|;
name|MNHighLt
argument_list|(
name|HiMode
index|[
name|adj
index|[
name|VERT
index|]
index|]
argument_list|,
name|hicolor
argument_list|)
expr_stmt|;
name|Adjustment
operator|=
name|VERT
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TAdjust
argument_list|,
literal|"  VERTICAL   "
argument_list|)
expr_stmt|;
block|}
name|Consume
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|sign
argument_list|(
argument|x
argument_list|)
name|float
name|x
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  *      This local routine returns 1 if x>= 0  * otherwise returns 0;  */
end_comment

begin_block
block|{
if|if
condition|(
name|x
operator|>=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|LGMirror
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine mirrors the elements in the current set as defined  * by points.  The mirroring is accomplished by defining a transformation  * matrix and calling DBXform.  */
end_comment

begin_block
block|{
name|ELT
modifier|*
name|e1
decl_stmt|;
name|POINT
name|pt
decl_stmt|,
name|pos
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|float
name|xmat
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|,
name|scalex
decl_stmt|,
name|scaley
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|SEQ
operator|<
literal|3
condition|)
comment|/* not enough points */
block|{
name|error
argument_list|(
literal|"not enough points"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DBNullelt
argument_list|(
name|cset
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"no current set"
argument_list|)
expr_stmt|;
return|return;
block|}
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|POINTLIST
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|scalex
operator|=
name|scaley
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sign
argument_list|(
name|p1
operator|->
name|x
operator|-
name|POINTLIST
operator|->
name|x
argument_list|)
operator|!=
name|sign
argument_list|(
name|p2
operator|->
name|x
operator|-
name|POINTLIST
operator|->
name|x
argument_list|)
condition|)
name|scalex
operator|=
operator|-
name|scalex
expr_stmt|;
if|if
condition|(
name|sign
argument_list|(
name|p1
operator|->
name|y
operator|-
name|POINTLIST
operator|->
name|y
argument_list|)
operator|!=
name|sign
argument_list|(
name|p2
operator|->
name|y
operator|-
name|POINTLIST
operator|->
name|y
argument_list|)
condition|)
name|scaley
operator|=
operator|-
name|scaley
expr_stmt|;
comment|/* create transformation matrix to translate set to origin,         performing the mirroring and translating back               */
name|xmat
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|scalex
expr_stmt|;
name|xmat
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|scaley
expr_stmt|;
name|xmat
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|xmat
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
operator|-
name|POINTLIST
operator|->
name|x
operator|*
operator|(
name|scalex
operator|-
literal|1.0
operator|)
expr_stmt|;
name|xmat
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
operator|-
name|POINTLIST
operator|->
name|y
operator|*
operator|(
name|scaley
operator|-
literal|1.0
operator|)
expr_stmt|;
name|e1
operator|=
name|cset
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e1
argument_list|)
condition|)
block|{
name|DISScreenErase
argument_list|(
name|e1
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
name|TxMsgOK
argument_list|()
expr_stmt|;
name|DBXform
argument_list|(
name|e1
argument_list|,
name|xmat
argument_list|,
operator|&
name|PICTURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEXT
argument_list|(
name|e1
operator|->
name|type
argument_list|)
condition|)
block|{
name|GRsetwmask
argument_list|(
name|textmask
operator||
name|setmask
argument_list|)
expr_stmt|;
name|p1
operator|=
name|e1
operator|->
name|ptlist
expr_stmt|;
name|GRPutText
argument_list|(
name|e1
operator|->
name|type
argument_list|,
name|p1
argument_list|,
name|e1
operator|->
name|brushf
argument_list|,
name|e1
operator|->
name|size
argument_list|,
name|e1
operator|->
name|textpt
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|e1
operator|->
name|textpt
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PTInit
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|p1
operator|->
name|x
argument_list|,
name|p1
operator|->
name|y
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
comment|/* add extra positioning points */
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|pos
operator|.
name|x
argument_list|,
name|pos
operator|.
name|y
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|pos
operator|.
name|x
operator|+
name|i
operator|*
name|charxsize
operator|/
literal|2
argument_list|,
name|pos
operator|.
name|y
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
name|pos
operator|.
name|x
operator|+
name|i
operator|*
name|charxsize
argument_list|,
name|pos
operator|.
name|y
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
name|e1
operator|->
name|ptlist
operator|=
name|p2
expr_stmt|;
block|}
comment|/* end if TEXT */
else|else
block|{
if|if
condition|(
name|e1
operator|->
name|type
operator|==
name|ARC
condition|)
comment|/* arcs require special handling */
if|if
condition|(
name|e1
operator|->
name|size
operator|>
literal|0
condition|)
comment|/* circles are OK */
if|if
condition|(
name|scalex
operator|*
name|scaley
operator|<
literal|0
condition|)
comment|/* both directions OK */
block|{
comment|/* swap starting and ending points of arc */
name|p1
operator|=
name|PTNextPoint
argument_list|(
name|e1
operator|->
name|ptlist
argument_list|)
expr_stmt|;
name|p2
operator|=
name|PTNextPoint
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|pt
operator|.
name|x
operator|=
name|p1
operator|->
name|x
expr_stmt|;
name|pt
operator|.
name|y
operator|=
name|p1
operator|->
name|y
expr_stmt|;
name|p1
operator|->
name|x
operator|=
name|p2
operator|->
name|x
expr_stmt|;
name|p1
operator|->
name|y
operator|=
name|p2
operator|->
name|y
expr_stmt|;
name|p2
operator|->
name|x
operator|=
name|pt
operator|.
name|x
expr_stmt|;
name|p2
operator|->
name|y
operator|=
name|pt
operator|.
name|y
expr_stmt|;
block|}
name|DISScreenAdd
argument_list|(
name|e1
argument_list|,
operator|(
name|linemask
operator||
name|setmask
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* end else */
name|e1
operator|=
name|DBNextofSet
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
name|CHANGED
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGMirror */
end_comment

begin_macro
name|LGPath
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine looks at the command line for parameters to set  * the current search path.  */
end_comment

begin_block
block|{
name|char
name|path
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
name|TxPutMsg
argument_list|(
name|PGetPath
argument_list|()
argument_list|)
expr_stmt|;
comment|/* no arguments */
else|else
block|{
name|SEARCH
operator|=
name|TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|PSetPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
name|Consume
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end LGFont */
end_comment

end_unit

