begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)main.c	1.2	%G%  *  * Copyright -C- 1982 Barry S. Roitblat  *  *  *      This is the main routine for the gremlin picture editor.  */
end_comment

begin_include
include|#
directive|include
file|"gremlin.h"
end_include

begin_include
include|#
directive|include
file|"grem2.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/* imports from config.c */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|GMapFile
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* database imports */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|DBInit
argument_list|()
decl_stmt|,
modifier|*
name|DBRead
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|POINT
modifier|*
name|PTInit
argument_list|()
decl_stmt|,
modifier|*
name|PTMakePoint
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* imports from menu.c */
end_comment

begin_extern
extern|extern MNInterpretCursor(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern MNIcon(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|MNInitMenu
argument_list|()
operator|,
name|MNDisplayMenu
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* graphics imports */
end_comment

begin_extern
extern|extern GRInit(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|GRClose
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern GRSetGrid(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|GRDisplayGrid
argument_list|()
operator|,
name|GRBlankGrid
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern GRDisableTablet(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|GREnableTablet
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern GRSetMap(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|GRsetwmask
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern artmode;
end_extern

begin_comment
comment|/* imports from undodb.c */
end_comment

begin_extern
extern|extern UNForget(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|extern
name|UNELT
modifier|*
name|unlist
decl_stmt|,
modifier|*
name|unback
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* imports from long.c */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Editfile
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern CP(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|LGCommand
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern LGQuit(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* imports from short.c */
end_comment

begin_extern
extern|extern SHCommand(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern SHRedis(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern SHUpdate(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* other */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|FindAED
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Forward references within this file: */
end_comment

begin_extern
extern|extern OnStop(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|OnCommand
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Imports from textio.c: */
end_comment

begin_extern
extern|extern TxInit(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|TxRedisplay
argument_list|()
operator|,
name|TxClose
argument_list|()
operator|,
name|TxPutMsg
argument_list|()
operator|,
name|TxMsgOK
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern TxLine(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|TxPutString
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|extern
name|char
name|TxGetChar
parameter_list|()
function_decl|;
end_function_decl

begin_extern
extern|extern short
specifier|inline
namespace|; extern
name|TxPutString
namespace|(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|extern
name|TXFIELD
name|TAlign
decl_stmt|,
name|TAdjust
decl_stmt|,
name|TBrush
decl_stmt|,
name|TFont
decl_stmt|,
name|TGravity
decl_stmt|,
name|TCSize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|TXFIELD
name|TEdit
decl_stmt|,
name|TJustmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Library routines: */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|sprintf
argument_list|()
decl_stmt|,
modifier|*
name|strcat
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTINT
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|lintrup
init|=
name|LINTRUP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Constant for local mode bit */
end_comment

begin_endif
endif|#
directive|endif
endif|SIGTINT
end_endif

begin_comment
comment|/* Declaration of Globals */
end_comment

begin_decl_stmt
name|ELT
modifier|*
name|PICTURE
decl_stmt|,
modifier|*
name|cset
decl_stmt|,
name|arhead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|CBRUSH
decl_stmt|,
name|CFONT
decl_stmt|,
name|CSIZE
decl_stmt|,
name|CJUST
decl_stmt|,
name|Gridsize
decl_stmt|,
name|Gridon
decl_stmt|,
name|Orientation
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Alignment
decl_stmt|,
name|SEQ
decl_stmt|,
name|Adjustment
decl_stmt|,
name|GravityOn
decl_stmt|,
name|Consume
decl_stmt|,
name|CHANGED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|float
name|PX
decl_stmt|,
name|PY
decl_stmt|,
name|Lastx
decl_stmt|,
name|Lasty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|POINT
modifier|*
name|POINTLIST
decl_stmt|,
modifier|*
name|BACKPOINT
decl_stmt|,
name|MENPOINT
index|[
name|NUSER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ELT
modifier|*
name|MEN
index|[
name|NUSER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|cmdbuf
index|[
literal|400
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|SEARCH
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|jmodes
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|textpos
index|[]
init|=
block|{
literal|"bl"
block|,
literal|"bc"
block|,
literal|"br"
block|,
literal|"cl"
block|,
literal|"cc"
block|,
literal|"cr"
block|,
literal|"tl"
block|,
literal|"tc"
block|,
literal|"tr"
block|,
literal|"lb"
block|,
literal|"cb"
block|,
literal|"rb"
block|,
literal|"lc"
block|,
literal|"rc"
block|,
literal|"lt"
block|,
literal|"ct"
block|,
literal|"rt"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dispmode
index|[]
init|=
block|{
literal|"BL"
block|,
literal|"BR"
block|,
literal|"CC"
block|,
literal|"XX"
block|,
literal|"XX"
block|,
literal|"XX"
block|,
literal|"XX"
block|,
literal|"XX"
block|,
literal|"XX"
block|,
literal|"XX"
block|,
literal|"TL"
block|,
literal|"TC"
block|,
literal|"TR"
block|,
literal|"CL"
block|,
literal|"CR"
block|,
literal|"BC"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|textmode
index|[]
init|=
block|{
literal|0
block|,
literal|15
block|,
literal|1
block|,
literal|13
block|,
literal|2
block|,
literal|14
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|0
block|,
literal|15
block|,
literal|1
block|,
literal|13
block|,
literal|14
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbolic types, brushes, etc. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|lines
index|[]
init|=
block|{
literal|"broken"
block|,
literal|"dashed"
block|,
literal|"dotted"
block|,
literal|"medium"
block|,
literal|"narrow"
block|,
literal|"thick"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lnum
index|[]
init|=
block|{
literal|2
block|,
literal|4
block|,
literal|1
block|,
literal|6
block|,
literal|5
block|,
literal|3
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|types
index|[]
init|=
block|{
literal|'l'
block|,
literal|'r'
block|,
literal|'c'
block|,
literal|'v'
block|,
literal|'a'
block|,
literal|'u'
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fonts
index|[]
init|=
block|{
literal|"Bold"
block|,
literal|"Italics"
block|,
literal|"Roman"
block|,
literal|"Special"
block|,
literal|"bold"
block|,
literal|"italics"
block|,
literal|"roman"
block|,
literal|"special"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fnum
index|[]
init|=
block|{
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|error
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      This routine prints an error message and sets the Consume flag  * so that points are not cleared.  */
end_comment

begin_block
block|{
name|putchar
argument_list|(
literal|'\7'
argument_list|)
expr_stmt|;
name|TxPutMsg
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|Consume
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|POpen
argument_list|()
decl_stmt|,
modifier|*
name|fopen
argument_list|()
decl_stmt|,
modifier|*
name|grtty
decl_stmt|,
modifier|*
name|tablet
decl_stmt|,
modifier|*
name|map
decl_stmt|,
modifier|*
name|startup
decl_stmt|;
name|POINT
modifier|*
name|p1
decl_stmt|,
name|pos
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|y1
decl_stmt|,
name|x2
decl_stmt|,
name|y2
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|button
decl_stmt|,
name|cux
decl_stmt|,
name|cuy
decl_stmt|;
name|char
name|colours
index|[
literal|768
index|]
decl_stmt|,
name|msg
index|[
literal|50
index|]
decl_stmt|,
name|sw
decl_stmt|,
modifier|*
name|arg
decl_stmt|,
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|display
decl_stmt|,
modifier|*
name|type
decl_stmt|,
modifier|*
name|getenv
argument_list|()
decl_stmt|,
name|home
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|path
init|=
literal|"."
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
name|ino_t
name|inode
decl_stmt|;
name|display
operator|=
name|FindAED
argument_list|()
expr_stmt|;
if|if
condition|(
name|display
operator|==
name|NULL
condition|)
name|display
operator|=
literal|"/dev/null"
expr_stmt|;
name|Orientation
operator|=
literal|1
expr_stmt|;
name|file
operator|=
name|NULL
expr_stmt|;
comment|/* Parse the command line. */
name|argc
operator|-=
literal|1
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* Skip program name. */
while|while
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|argc
operator|-=
literal|1
expr_stmt|;
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
name|file
operator|=
name|arg
expr_stmt|;
else|else
block|{
name|sw
operator|=
operator|*
operator|++
name|arg
expr_stmt|;
switch|switch
condition|(
name|sw
condition|)
block|{
case|case
literal|'g'
case|:
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
condition|)
if|if
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"usage: gremlin -g<display name>"
argument_list|)
expr_stmt|;
name|display
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|*
name|display
operator|!=
literal|'/'
condition|)
name|display
operator|=
name|strcat
argument_list|(
literal|"/dev/"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
condition|)
if|if
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"usage: gremlin -g<path>"
argument_list|)
expr_stmt|;
name|path
operator|=
name|arg
expr_stmt|;
name|SEARCH
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|Orientation
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|Orientation
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"unknown switch: %c"
argument_list|,
name|sw
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|PSetPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|map
operator|=
name|fopen
argument_list|(
name|GMapFile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|768
condition|;
operator|++
name|i
control|)
comment|/* read in color map */
block|{
operator|(
name|void
operator|)
name|fscanf
argument_list|(
name|map
argument_list|,
literal|"%o"
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
name|colours
index|[
name|i
index|]
operator|=
name|j
operator|&
literal|0377
expr_stmt|;
block|}
empty_stmt|;
comment|/* Open the display, and call all of the initialization routines.      * Initialize all of the globals defined in this file.      */
name|type
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
name|TxInit
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Ignore quit signals, catch interrupts and stops. */
name|sigset
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGTSTP
argument_list|,
name|OnStop
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGTTIN
argument_list|,
name|OnStop
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|SIGTTOU
argument_list|,
name|OnStop
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTINT
name|sigset
argument_list|(
name|SIGTINT
argument_list|,
name|OnCommand
argument_list|)
expr_stmt|;
name|sighold
argument_list|(
name|SIGTINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SIGTINT
name|grtty
operator|=
name|fopen
argument_list|(
name|display
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|grtty
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"couldn't open display"
argument_list|)
expr_stmt|;
name|LGQuit
argument_list|(
name|display
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|tablet
operator|=
name|fopen
argument_list|(
name|display
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tablet
operator|==
name|NULL
condition|)
name|tablet
operator|=
name|fopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|GRInit
argument_list|(
name|grtty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|GRSetMap
argument_list|(
name|colours
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTINT
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCLBIS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lintrup
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SIGTINT
name|TxRedisplay
argument_list|()
expr_stmt|;
comment|/* display text screen */
name|CBRUSH
operator|=
literal|6
expr_stmt|;
name|CFONT
operator|=
literal|1
expr_stmt|;
name|CSIZE
operator|=
literal|1
expr_stmt|;
name|CJUST
operator|=
literal|0
expr_stmt|;
name|Gridon
operator|=
name|FALSE
expr_stmt|;
name|Adjustment
operator|=
name|NOADJ
expr_stmt|;
name|Alignment
operator|=
literal|4
expr_stmt|;
name|artmode
operator|=
name|FALSE
expr_stmt|;
name|SEQ
operator|=
literal|0
expr_stmt|;
name|GravityOn
operator|=
name|FALSE
expr_stmt|;
name|CHANGED
operator|=
name|FALSE
expr_stmt|;
name|POINTLIST
operator|=
name|PTInit
argument_list|()
expr_stmt|;
name|BACKPOINT
operator|=
name|PTInit
argument_list|()
expr_stmt|;
name|unlist
operator|=
name|unback
operator|=
name|nullun
expr_stmt|;
name|p1
operator|=
name|PTInit
argument_list|()
expr_stmt|;
comment|/* initialize arrowhead template */
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
operator|-
literal|5.0
argument_list|,
literal|3.0
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
operator|-
literal|3.0
argument_list|,
literal|0.0
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
operator|-
literal|5.0
argument_list|,
operator|-
literal|3.0
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|PTMakePoint
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
name|arhead
operator|.
name|type
operator|=
name|VECTOR
expr_stmt|;
name|arhead
operator|.
name|ptlist
operator|=
name|p1
expr_stmt|;
name|arhead
operator|.
name|brushf
operator|=
literal|0
expr_stmt|;
comment|/* brush filled in when used */
name|arhead
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|arhead
operator|.
name|textpt
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
operator|(
name|arhead
operator|.
name|textpt
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|PICTURE
operator|=
name|DBInit
argument_list|()
expr_stmt|;
comment|/* initialize picture databse */
name|cset
operator|=
name|DBInit
argument_list|()
expr_stmt|;
comment|/* and current set   */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
comment|/* and user symbols  */
name|MEN
index|[
name|i
index|]
operator|=
name|DBInit
argument_list|()
expr_stmt|;
name|Editfile
operator|=
name|malloc
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
operator|*
name|Editfile
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Editfile
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fp
operator|=
name|POpen
argument_list|(
name|Editfile
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
name|SEARCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"(creating new file)"
argument_list|)
expr_stmt|;
else|else
name|PICTURE
operator|=
name|DBRead
argument_list|(
name|Editfile
argument_list|,
operator|&
name|Orientation
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
block|}
name|unlist
operator|=
name|unback
operator|=
name|nullun
expr_stmt|;
name|TxPutString
argument_list|(
operator|&
name|TEdit
argument_list|,
name|Editfile
argument_list|)
expr_stmt|;
name|TxPutMsg
argument_list|(
literal|"        Gremlin - Version 2.3 (1982)"
argument_list|)
expr_stmt|;
name|MNIcon
argument_list|()
expr_stmt|;
name|MNInitMenu
argument_list|(
name|Orientation
argument_list|)
expr_stmt|;
comment|/* Initialize Menu */
name|SHUpdate
argument_list|()
expr_stmt|;
comment|/* Display menu and picture, if any */
if|if
condition|(
name|Orientation
operator|==
literal|0
condition|)
comment|/* initialize grid */
block|{
name|x1
operator|=
name|y1
operator|=
literal|0
expr_stmt|;
name|x2
operator|=
literal|511
expr_stmt|;
name|y2
operator|=
literal|395
expr_stmt|;
block|}
else|else
block|{
name|x1
operator|=
literal|116
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
name|x2
operator|=
literal|511
expr_stmt|;
name|y2
operator|=
literal|483
expr_stmt|;
block|}
empty_stmt|;
name|Gridsize
operator|=
literal|16
expr_stmt|;
name|GRSetGrid
argument_list|(
name|x1
argument_list|,
name|y1
argument_list|,
name|x2
argument_list|,
name|y2
argument_list|,
name|Gridsize
argument_list|)
expr_stmt|;
comment|/* read start-up file */
comment|/* look in home directory */
name|sprintf
argument_list|(
name|home
argument_list|,
literal|"%s/.gremlinrc"
argument_list|,
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
argument_list|)
expr_stmt|;
name|startup
operator|=
name|fopen
argument_list|(
name|home
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|startup
operator|!=
name|NULL
condition|)
block|{
name|fstat
argument_list|(
name|startup
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|inode
operator|=
name|buf
operator|.
name|st_ino
expr_stmt|;
name|ptr
operator|=
name|fgets
argument_list|(
name|cmdbuf
argument_list|,
literal|400
argument_list|,
name|startup
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|cmdbuf
index|[
name|i
index|]
operator|!=
literal|'\n'
operator|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|>
literal|399
condition|)
break|break;
name|cmdbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* remove trailing carriage return */
if|if
condition|(
name|cmdbuf
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
name|LGCommand
argument_list|(
operator|&
operator|(
name|cmdbuf
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
else|else
name|SHCommand
argument_list|(
operator|&
operator|(
name|cmdbuf
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|fgets
argument_list|(
name|cmdbuf
argument_list|,
literal|400
argument_list|,
name|startup
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
block|}
comment|/* end if startup */
else|else
name|inode
operator|=
literal|0
expr_stmt|;
comment|/* look in current directory */
name|startup
operator|=
name|fopen
argument_list|(
literal|".gremlinrc"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|startup
operator|!=
name|NULL
condition|)
block|{
name|fstat
argument_list|(
name|startup
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|.
name|st_ino
operator|!=
name|inode
condition|)
comment|/* This isn't the same file as above */
block|{
name|ptr
operator|=
name|fgets
argument_list|(
name|cmdbuf
argument_list|,
literal|400
argument_list|,
name|startup
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|cmdbuf
index|[
name|i
index|]
operator|!=
literal|'\n'
operator|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|>
literal|399
condition|)
break|break;
name|cmdbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* remove trailing carriage return */
if|if
condition|(
name|cmdbuf
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
name|LGCommand
argument_list|(
operator|&
operator|(
name|cmdbuf
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
else|else
name|SHCommand
argument_list|(
operator|&
operator|(
name|cmdbuf
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|fgets
argument_list|(
name|cmdbuf
argument_list|,
literal|400
argument_list|,
name|startup
argument_list|)
expr_stmt|;
block|}
comment|/* end while */
block|}
comment|/* end if buf */
block|}
comment|/* end if startup */
while|while
condition|(
name|TRUE
condition|)
comment|/* Exits through the 'quit' command */
block|{
name|Consume
operator|=
name|TRUE
expr_stmt|;
name|UNForget
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTINT
name|GREnableTablet
argument_list|()
expr_stmt|;
comment|/*  Allow keyboard interrupts while waiting                * for cursor input.                */
name|sigrelse
argument_list|(
name|SIGTINT
argument_list|)
expr_stmt|;
name|button
operator|=
name|GRGetButton
argument_list|(
name|tablet
argument_list|,
operator|&
name|cux
argument_list|,
operator|&
name|cuy
argument_list|)
expr_stmt|;
comment|/*  Ignore keyboard interrupts while processing commands.                */
name|sighold
argument_list|(
name|SIGTINT
argument_list|)
expr_stmt|;
name|GRDisableTablet
argument_list|()
expr_stmt|;
name|TxMsgOK
argument_list|()
expr_stmt|;
name|MNInterpretCursor
argument_list|(
name|button
argument_list|,
name|cux
argument_list|,
name|cuy
argument_list|)
expr_stmt|;
if|if
condition|(
name|Consume
condition|)
name|CP
argument_list|()
expr_stmt|;
else|#
directive|else
else|SIGTINT
name|i
operator|=
literal|1
operator|<<
name|fileno
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|GREnableTablet
argument_list|()
expr_stmt|;
name|i
operator||=
operator|(
literal|1
operator|<<
name|fileno
argument_list|(
name|tablet
argument_list|)
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|select
argument_list|(
literal|20
argument_list|,
operator|&
name|i
argument_list|,
literal|0
argument_list|,
literal|10000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|(
literal|1
operator|<<
name|fileno
argument_list|(
name|stdin
argument_list|)
operator|)
condition|)
block|{
name|TxMsgOK
argument_list|()
expr_stmt|;
name|OnCommand
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|button
operator|=
name|GRGetButton
argument_list|(
name|tablet
argument_list|,
operator|&
name|cux
argument_list|,
operator|&
name|cuy
argument_list|)
operator|)
operator|!=
operator|-
literal|4
condition|)
block|{
name|GRDisableTablet
argument_list|()
expr_stmt|;
name|TxMsgOK
argument_list|()
expr_stmt|;
name|MNInterpretCursor
argument_list|(
name|button
argument_list|,
name|cux
argument_list|,
name|cuy
argument_list|)
expr_stmt|;
if|if
condition|(
name|Consume
condition|)
name|CP
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|SIGTINT
block|}
comment|/* end while */
block|}
end_function

begin_comment
comment|/* end main */
end_comment

begin_macro
name|OnStop
argument_list|(
argument|signo
argument_list|)
end_macro

begin_decl_stmt
name|int
name|signo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-----------------------------------------------------------------------------  *    This procedure handles stop signals.  *  *    Results:    None.  *  *    Side Effects:  *    The text display is reset, we wait to get restarted, then  *    redisplay text.  *-----------------------------------------------------------------------------  */
end_comment

begin_block
block|{
name|TxClose
argument_list|()
expr_stmt|;
name|sigset
argument_list|(
name|signo
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|sigset
argument_list|(
name|signo
argument_list|,
name|OnStop
argument_list|)
expr_stmt|;
name|SHRedis
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|OnCommand
argument_list|()
end_macro

begin_comment
comment|/*-----------------------------------------------------------------------------  *    This routine responds to interrupts from the command terminal and  *    then processes commands as long as there is input.  *  *    Results:    None.  *  *    Side Effects:  *    Whatever is done by the commands.  *-----------------------------------------------------------------------------  */
end_comment

begin_block
block|{
ifdef|#
directive|ifdef
name|SIGTINT
name|long
name|charcount
decl_stmt|;
else|#
directive|else
else|SIGTINT
name|int
name|i
decl_stmt|;
endif|#
directive|endif
endif|SIGTINT
specifier|static
name|char
name|cmd
decl_stmt|,
name|lastcmd
decl_stmt|;
name|int
name|repeat
decl_stmt|;
name|GRDisableTablet
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTINT
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCLBIC
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lintrup
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SIGTINT
while|while
condition|(
name|TRUE
condition|)
block|{
comment|/* If there is no more input, then reenable the signal and return */
ifdef|#
directive|ifdef
name|SIGTINT
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|FIONREAD
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|charcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|charcount
operator|==
literal|0
condition|)
block|{
name|GREnableTablet
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|TIOCLBIS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lintrup
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
else|SIGTINT
name|i
operator|=
literal|1
operator|<<
name|fileno
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
literal|20
argument_list|,
operator|&
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|GREnableTablet
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
endif|SIGTINT
comment|/* Read the command and call the long or short command routine */
name|cmd
operator|=
name|TxGetChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|'.'
condition|)
block|{
name|repeat
operator|=
name|TRUE
expr_stmt|;
name|cmd
operator|=
name|lastcmd
expr_stmt|;
block|}
else|else
block|{
name|repeat
operator|=
name|FALSE
expr_stmt|;
name|lastcmd
operator|=
name|cmd
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
operator|!
name|repeat
condition|)
name|TxGetLine
argument_list|(
literal|":"
argument_list|,
name|cmdbuf
argument_list|,
literal|400
argument_list|)
expr_stmt|;
name|LGCommand
argument_list|(
name|cmdbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TxLine
argument_list|(
specifier|inline
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
literal|'
end_block

unit|\') putchar(cmd);         (void) fflush(stdout);         SHCommand(&cmd);     }     TxLine(inline);     printf("                                                                              ");     TxLine(inline);     if (Consume) CP();     Consume = TRUE;     UNForget();     } }
end_unit

