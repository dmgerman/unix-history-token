begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gprint.c-  *  * Copyright -C- 1982 Barry S. Roitblat  *  *      This file contains the main and file system dependent routines  * for producing hard copy from gremlin files.  It is extensively modified  * from the vplot source.  */
end_comment

begin_include
include|#
directive|include
file|"gprint.h"
end_include

begin_include
include|#
directive|include
file|"grem2.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<vfont.h>
end_include

begin_define
define|#
directive|define
name|VDAEMON
value|"/usr/lib/vad"
end_define

begin_define
define|#
directive|define
name|WDAEMON
value|"/usr/lib/vpd"
end_define

begin_define
define|#
directive|define
name|NB
value|1024
end_define

begin_comment
comment|/* Number of blocks in virtual memory */
end_comment

begin_define
define|#
directive|define
name|BSIZ
value|512
end_define

begin_comment
comment|/* Size of blocks */
end_comment

begin_define
define|#
directive|define
name|SETSTATE
value|(('v'<<8)+1)
end_define

begin_function_decl
specifier|extern
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getname
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* get login name or user name */
end_comment

begin_comment
comment|/* imports */
end_comment

begin_extern
extern|extern HGtline(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|HGArc
argument_list|()
operator|,
name|HGPutText
argument_list|()
operator|,
name|HGMove
argument_list|()
operator|,
name|HGSetFont
argument_list|()
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern HGSetBrush(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|HGInitFont
argument_list|()
operator|,
name|HGPrintElt
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|int
name|style
index|[]
decl_stmt|,
name|thick
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tfont
index|[]
decl_stmt|,
modifier|*
name|tsize
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* database imports */
end_comment

begin_decl_stmt
specifier|extern
name|ELT
modifier|*
name|DBInit
argument_list|()
decl_stmt|,
modifier|*
name|DBRead
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|POINT
modifier|*
name|PTInit
argument_list|()
decl_stmt|,
modifier|*
name|PTMakePoint
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linethickness
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* brush styles */
end_comment

begin_decl_stmt
name|int
name|linmod
init|=
name|SOLID
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|chrtab
index|[]
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|blocks
index|[
name|NB
index|]
index|[
name|BSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lasty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|angle
decl_stmt|,
name|startx
decl_stmt|,
name|starty
decl_stmt|,
name|endx
decl_stmt|,
name|endy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|scale
init|=
literal|4.0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables used to map gremlin screen */
end_comment

begin_decl_stmt
name|double
name|topx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* coordinates into output device coordinates */
end_comment

begin_decl_stmt
name|double
name|topy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|botx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|boty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|centx
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|centy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|delx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|dely
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|del
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|vspoolr
init|=
literal|"/usr/spool/vad/dfxXXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|wspoolr
init|=
literal|"/usr/spool/vpd/dfxXXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|vfilen
init|=
literal|"/usr/spool/vad/tmpXXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|wfilen
init|=
literal|"/usr/spool/vad/tmpXXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|DevRange
init|=
literal|1536
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bits per line for output device */
end_comment

begin_struct
struct|struct
name|buf
block|{
name|int
name|bno
decl_stmt|;
name|char
modifier|*
name|block
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|buf
name|bufs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dirty
index|[
name|NB
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* marks if a block has been written into */
end_comment

begin_decl_stmt
name|int
name|in
decl_stmt|,
name|out
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|picture
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|run
init|=
literal|"a"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gives uniqueness for multiple pictures */
end_comment

begin_decl_stmt
name|char
name|device
init|=
literal|'V'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|banner
init|=
literal|"gremlin"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* variables used to print from font file */
end_comment

begin_decl_stmt
name|int
name|Orientation
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cfont
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|csize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|header
name|header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dispatch
name|dispatch
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bits
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fontdir
init|=
literal|"/usr/lib/vfont/"
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|fopen
argument_list|()
decl_stmt|;
name|ELT
modifier|*
name|PICTURE
decl_stmt|,
modifier|*
name|e
decl_stmt|;
name|POINT
modifier|*
name|p1
decl_stmt|,
name|pos
decl_stmt|;
name|char
modifier|*
name|file
index|[
literal|50
index|]
decl_stmt|,
name|sw
decl_stmt|,
name|string
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
name|char
name|c
decl_stmt|,
name|string1
index|[
literal|50
index|]
decl_stmt|,
name|string2
index|[
literal|50
index|]
decl_stmt|,
name|string3
index|[
literal|50
index|]
decl_stmt|,
name|string4
index|[
literal|50
index|]
decl_stmt|,
name|string5
index|[
literal|50
index|]
decl_stmt|,
name|string6
index|[
literal|50
index|]
decl_stmt|,
name|string7
index|[
literal|50
index|]
decl_stmt|,
name|string8
index|[
literal|50
index|]
decl_stmt|;
specifier|extern
name|int
name|onintr
parameter_list|()
function_decl|;
name|float
name|mult
decl_stmt|;
name|int
name|WriteRaster
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|gfil
init|=
literal|0
decl_stmt|;
name|int
name|b
decl_stmt|,
name|brsh
decl_stmt|;
name|int
name|k
decl_stmt|;
comment|/* Parse the command line. */
name|argc
operator|-=
literal|1
expr_stmt|;
name|argv
operator|++
expr_stmt|;
comment|/* Skip program name. */
while|while
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|argc
operator|-=
literal|1
expr_stmt|;
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
name|file
index|[
name|gfil
operator|++
index|]
operator|=
name|arg
expr_stmt|;
else|else
block|{
name|sw
operator|=
operator|*
operator|++
name|arg
expr_stmt|;
switch|switch
condition|(
name|sw
condition|)
block|{
case|case
literal|'W'
case|:
comment|/* Print to wide (versatec) device */
name|device
operator|=
literal|'W'
expr_stmt|;
name|DevRange
operator|=
literal|2047
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* Print to narrow (varian) device */
name|device
operator|=
literal|'V'
expr_stmt|;
name|DevRange
operator|=
literal|1536
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
comment|/* select size 1 */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
condition|)
if|if
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|tsize
index|[
literal|0
index|]
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
comment|/* select size 2 */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
condition|)
if|if
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|tsize
index|[
literal|1
index|]
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
comment|/* select size 3 */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
condition|)
if|if
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|tsize
index|[
literal|2
index|]
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
comment|/* select size 4 */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
condition|)
if|if
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|tsize
index|[
literal|3
index|]
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* select Roman font */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
condition|)
if|if
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|tfont
index|[
literal|0
index|]
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* select italics font */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
condition|)
if|if
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|tfont
index|[
literal|1
index|]
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* select bold font */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
condition|)
if|if
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|tfont
index|[
literal|2
index|]
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* select special font */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
condition|)
if|if
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|tfont
index|[
literal|3
index|]
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* select narrow brush width */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
condition|)
if|if
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|arg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|brsh
argument_list|)
expr_stmt|;
name|thick
index|[
literal|0
index|]
operator|=
name|thick
index|[
literal|1
index|]
operator|=
name|thick
index|[
literal|3
index|]
operator|=
name|thick
index|[
literal|4
index|]
operator|=
name|brsh
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* select thick brush width */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
condition|)
if|if
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|arg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|brsh
argument_list|)
expr_stmt|;
name|thick
index|[
literal|2
index|]
operator|=
name|brsh
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* select medium brush width */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
condition|)
if|if
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|arg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|brsh
argument_list|)
expr_stmt|;
name|thick
index|[
literal|5
index|]
operator|=
name|brsh
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* send raster to standard output */
name|WriteRaster
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* select scale */
if|if
condition|(
operator|*
operator|++
name|arg
operator|==
literal|'\0'
condition|)
if|if
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|sscanf
argument_list|(
name|arg
argument_list|,
literal|"%f"
argument_list|,
operator|&
name|mult
argument_list|)
expr_stmt|;
name|scale
operator|*=
name|mult
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* prompt for font and size parameters */
name|printf
argument_list|(
literal|"Roman font name? (%s): "
argument_list|,
name|tfont
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string1
operator|!=
literal|'\0'
condition|)
name|tfont
index|[
literal|0
index|]
operator|=
name|string1
expr_stmt|;
name|printf
argument_list|(
literal|"Italic font name? (%s): "
argument_list|,
name|tfont
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string2
operator|!=
literal|'\0'
condition|)
name|tfont
index|[
literal|1
index|]
operator|=
name|string2
expr_stmt|;
name|printf
argument_list|(
literal|"Bold font name? (%s): "
argument_list|,
name|tfont
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string3
operator|!=
literal|'\0'
condition|)
name|tfont
index|[
literal|2
index|]
operator|=
name|string3
expr_stmt|;
name|printf
argument_list|(
literal|"Special font name? (%s): "
argument_list|,
name|tfont
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string4
operator|!=
literal|'\0'
condition|)
name|tfont
index|[
literal|3
index|]
operator|=
name|string4
expr_stmt|;
name|printf
argument_list|(
literal|"font size 1? (%s): "
argument_list|,
name|tsize
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string5
operator|!=
literal|'\0'
condition|)
name|tsize
index|[
literal|0
index|]
operator|=
name|string5
expr_stmt|;
name|printf
argument_list|(
literal|"font size 2? (%s): "
argument_list|,
name|tsize
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string6
operator|!=
literal|'\0'
condition|)
name|tsize
index|[
literal|1
index|]
operator|=
name|string6
expr_stmt|;
name|printf
argument_list|(
literal|"font size 3? (%s): "
argument_list|,
name|tsize
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string7
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string7
operator|!=
literal|'\0'
condition|)
name|tsize
index|[
literal|2
index|]
operator|=
name|string7
expr_stmt|;
name|printf
argument_list|(
literal|"font size 4? (%s): "
argument_list|,
name|tsize
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string8
operator|!=
literal|'\0'
condition|)
name|tsize
index|[
literal|3
index|]
operator|=
name|string8
expr_stmt|;
name|printf
argument_list|(
literal|"narrow brush size? (%d): "
argument_list|,
name|thick
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|!=
literal|'\0'
condition|)
block|{
name|sscanf
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|brsh
argument_list|)
expr_stmt|;
name|thick
index|[
literal|0
index|]
operator|=
name|thick
index|[
literal|1
index|]
operator|=
name|thick
index|[
literal|3
index|]
operator|=
name|thick
index|[
literal|4
index|]
operator|=
name|brsh
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"medium brush size? (%d): "
argument_list|,
name|thick
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|!=
literal|'\0'
condition|)
block|{
name|sscanf
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|brsh
argument_list|)
expr_stmt|;
name|thick
index|[
literal|5
index|]
operator|=
name|brsh
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"thick brush size? (%d): "
argument_list|,
name|thick
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|!=
literal|'\0'
condition|)
block|{
name|sscanf
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|brsh
argument_list|)
expr_stmt|;
name|thick
index|[
literal|2
index|]
operator|=
name|brsh
expr_stmt|;
block|}
break|break;
default|default:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"unknown switch: %c"
argument_list|,
name|sw
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* init constants for scaling */
name|topx
operator|=
name|topy
operator|=
name|DevRange
expr_stmt|;
name|botx
operator|=
name|boty
operator|=
literal|0
expr_stmt|;
name|delx
operator|=
name|dely
operator|=
name|del
operator|=
name|DevRange
expr_stmt|;
name|centx
operator|=
operator|(
name|DevRange
operator|-
name|mapx
argument_list|(
name|topx
operator|/
name|scale
argument_list|)
operator|)
operator|/
literal|2
expr_stmt|;
name|centy
operator|=
name|mapy
argument_list|(
name|topy
operator|/
name|scale
argument_list|)
operator|/
literal|2
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
if|if
condition|(
name|gfil
operator|==
literal|0
condition|)
comment|/* no filename, use standard input */
block|{
name|file
index|[
literal|0
index|]
operator|=
literal|"stdin"
expr_stmt|;
operator|++
name|gfil
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|gfil
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|file
index|[
name|j
index|]
argument_list|,
literal|"stdin"
argument_list|)
operator|!=
literal|0
condition|)
name|fp
operator|=
name|fopen
argument_list|(
name|file
index|[
name|j
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
name|fp
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't open %s"
argument_list|,
name|file
index|[
name|j
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|PICTURE
operator|=
name|DBRead
argument_list|(
name|fp
argument_list|,
operator|&
name|Orientation
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
comment|/* read picture file */
if|if
condition|(
name|DBNullelt
argument_list|(
name|PICTURE
argument_list|)
condition|)
continue|continue;
name|banner
operator|=
name|file
index|[
name|j
index|]
expr_stmt|;
name|picture
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* picture equals null string */
name|strcat
argument_list|(
name|picture
argument_list|,
name|mktemp
argument_list|(
literal|"/usr/tmp/#rastXXXXX"
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|picture
argument_list|,
name|run
argument_list|)
expr_stmt|;
operator|(
operator|*
name|run
operator|)
operator|++
expr_stmt|;
name|bufs
operator|.
name|bno
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no current block */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NB
condition|;
name|i
operator|++
control|)
block|{
name|dirty
index|[
name|i
index|]
operator|=
name|FALSE
expr_stmt|;
comment|/* no blocks written yet */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|BSIZ
condition|;
operator|++
name|k
control|)
comment|/* Zero out memory area for picture */
name|blocks
index|[
name|i
index|]
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|out
operator|=
name|creat
argument_list|(
name|picture
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|in
operator|=
name|open
argument_list|(
name|picture
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zseek
argument_list|(
name|out
argument_list|,
name|NB
argument_list|)
expr_stmt|;
comment|/* seek to end of file and write */
name|write
argument_list|(
name|out
argument_list|,
name|blocks
index|[
literal|0
index|]
argument_list|,
name|BSIZ
argument_list|)
expr_stmt|;
comment|/* intervening hole will be 0-filled */
name|e
operator|=
name|PICTURE
expr_stmt|;
while|while
condition|(
operator|!
name|DBNullelt
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|HGPrintElt
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* traverse picture, printing elements */
name|e
operator|=
name|DBNextElt
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NB
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|WriteRaster
operator|==
name|TRUE
condition|)
comment|/* put picture to standard output */
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BSIZ
condition|;
operator|++
name|j
control|)
name|putchar
argument_list|(
name|blocks
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dirty
index|[
name|i
index|]
operator|==
name|TRUE
condition|)
comment|/* write out only those blocks which */
block|{
comment|/* which have been written into, the */
name|zseek
argument_list|(
name|out
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* rest will default to be zeroes    */
name|write
argument_list|(
name|out
argument_list|,
name|blocks
index|[
name|i
index|]
argument_list|,
name|BSIZ
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|WriteRaster
operator|==
name|FALSE
condition|)
name|putpict
argument_list|(
name|picture
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
comment|/* end for j */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end main */
end_comment

begin_macro
name|putpict
argument_list|(
argument|picture
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|picture
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|temp
decl_stmt|;
name|char
modifier|*
name|fileName
decl_stmt|,
modifier|*
name|spoolerName
decl_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
name|fopen
argument_list|(
name|picture
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* picture image doesnt exist */
block|{
name|perror
argument_list|(
name|picture
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|==
literal|'V'
condition|)
comment|/* writing to varian */
block|{
name|fileName
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|vfilen
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fileName
argument_list|,
name|vfilen
argument_list|)
expr_stmt|;
name|fileName
operator|=
name|mktemp
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
name|spoolerName
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|vspoolr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|spoolerName
argument_list|,
name|vspoolr
argument_list|)
expr_stmt|;
name|spoolerName
operator|=
name|mktemp
argument_list|(
name|spoolerName
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* writing to versatec */
block|{
name|fileName
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|wfilen
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fileName
argument_list|,
name|wfilen
argument_list|)
expr_stmt|;
name|fileName
operator|=
name|mktemp
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
name|spoolerName
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|wspoolr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|spoolerName
argument_list|,
name|wspoolr
argument_list|)
expr_stmt|;
name|spoolerName
operator|=
name|mktemp
argument_list|(
name|spoolerName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|temp
operator|=
name|fopen
argument_list|(
name|fileName
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't make temporary spooling file\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* write file and command information to printer daemon */
name|fprintf
argument_list|(
name|temp
argument_list|,
literal|"L%s\n"
argument_list|,
name|getname
argument_list|()
argument_list|)
expr_stmt|;
comment|/* login name (for banner) */
name|fprintf
argument_list|(
name|temp
argument_list|,
literal|"B%s\n"
argument_list|,
name|banner
argument_list|)
expr_stmt|;
comment|/* gremlin file name (for banner) */
name|fprintf
argument_list|(
name|temp
argument_list|,
literal|"V%s\n"
argument_list|,
name|picture
argument_list|)
expr_stmt|;
comment|/* raster image file name  */
name|fprintf
argument_list|(
name|temp
argument_list|,
literal|"U%s\n"
argument_list|,
name|picture
argument_list|)
expr_stmt|;
comment|/* unlink file when through */
name|fclose
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|fileName
argument_list|,
name|spoolerName
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror
argument_list|(
name|spoolerName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|unlink
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
comment|/* Spawn daemon process */
if|if
condition|(
name|vfork
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|device
operator|==
literal|'V'
condition|)
name|execl
argument_list|(
name|VDAEMON
argument_list|,
name|VDAEMON
argument_list|)
expr_stmt|;
else|else
name|execl
argument_list|(
name|WDAEMON
argument_list|,
name|WDAEMON
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|getblk
argument_list|(
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|int
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|b
operator|<
literal|0
operator|||
name|NB
operator|<=
name|b
condition|)
comment|/* bad block number */
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vplot: internal error, b out of range in getblk\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|dirty
index|[
name|b
index|]
operator|=
name|TRUE
expr_stmt|;
comment|/* assume that present block has been written into */
name|bufs
operator|.
name|bno
operator|=
name|b
expr_stmt|;
name|bufs
operator|.
name|block
operator|=
name|blocks
index|[
name|b
index|]
expr_stmt|;
comment|/* get new block to write */
block|}
end_block

begin_macro
name|onintr
argument_list|()
end_macro

begin_block
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|point
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|bno
decl_stmt|;
name|bno
operator|=
operator|(
operator|(
name|x
operator|&
literal|03700
operator|)
operator|>>
literal|6
operator|)
operator|+
operator|(
operator|(
name|y
operator|&
literal|03700
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* calculate block number */
if|if
condition|(
name|bno
operator|!=
name|bufs
operator|.
name|bno
condition|)
comment|/* get appropriate block if necessary */
block|{
if|if
condition|(
name|bno
operator|<
literal|0
operator|||
name|bno
operator|>=
literal|1024
condition|)
return|return;
name|getblk
argument_list|(
name|bno
argument_list|)
expr_stmt|;
block|}
name|bufs
operator|.
name|block
index|[
operator|(
operator|(
name|y
operator|&
literal|077
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
name|x
operator|>>
literal|3
operator|)
operator|&
literal|07
operator|)
index|]
operator||=
literal|1
operator|<<
operator|(
literal|7
operator|-
operator|(
name|x
operator|&
literal|07
operator|)
operator|)
expr_stmt|;
comment|/* set bit */
block|}
end_block

begin_macro
name|zseek
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
name|lseek
argument_list|(
name|a
argument_list|,
operator|(
name|long
operator|)
name|b
operator|*
literal|512
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

end_unit

