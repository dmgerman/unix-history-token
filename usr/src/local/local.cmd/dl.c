begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)dl.c	4.2\t%G%"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_define
define|#
directive|define
name|DELIM
value|'/'
end_define

begin_define
define|#
directive|define
name|MODEBITS
value|07777
end_define

begin_define
define|#
directive|define
name|ISDIR
parameter_list|(
name|st
parameter_list|)
value|(((st).st_mode&S_IFMT) == S_IFDIR)
end_define

begin_define
define|#
directive|define
name|ISLNK
parameter_list|(
name|st
parameter_list|)
value|(((st).st_mode&S_IFMT) == S_IFLNK)
end_define

begin_define
define|#
directive|define
name|ISREG
parameter_list|(
name|st
parameter_list|)
value|(((st).st_mode&S_IFMT) == S_IFREG)
end_define

begin_define
define|#
directive|define
name|ISDEV
parameter_list|(
name|st
parameter_list|)
define|\
value|(((st).st_mode&S_IFMT) == S_IFCHR || ((st).st_mode&S_IFMT) == S_IFBLK)
end_define

begin_decl_stmt
name|struct
name|stat
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|errcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|path
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|path2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|line
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "copy" - same as cp  */
end_comment

begin_decl_stmt
name|int
name|dflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "debug" - enable trace printf statements */
end_comment

begin_decl_stmt
name|int
name|fflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "force" option: override protection, no messages */
end_comment

begin_decl_stmt
name|int
name|mflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "move" - same as mv  */
end_comment

begin_decl_stmt
name|int
name|cs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag used with cflag to prevent endless recursion */
end_comment

begin_decl_stmt
name|int
name|ms
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag used with mflag to prevent endless recursion */
end_comment

begin_decl_stmt
name|int
name|tflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* restore original time stamp */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
comment|/* dl.c - delete, undelete, move, copy */
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|aflg
init|=
literal|0
decl_stmt|;
comment|/* "all" option: undelete all deleted files */
name|int
name|iflg
init|=
literal|0
decl_stmt|;
comment|/* "interactive" option: send messages to user */
name|int
name|rflg
init|=
literal|0
decl_stmt|;
comment|/* "recursive" opt., used only with n */
name|int
name|sflg
init|=
literal|0
decl_stmt|;
comment|/* do not delete previous dlsave file */
name|int
name|uflg
init|=
literal|0
decl_stmt|;
comment|/* undelete named files and/or directories */
name|int
name|nflg
init|=
literal|0
decl_stmt|;
comment|/* do not provide back-up files */
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
operator|==
literal|0
condition|)
comment|/* if standard i/o is not a terminal, */
name|fflag
operator|++
expr_stmt|;
comment|/*  turn on the f flag                */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"ud"
argument_list|)
operator|==
literal|0
condition|)
name|uflg
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"copy"
argument_list|)
operator|==
literal|0
condition|)
name|cflag
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"move"
argument_list|)
operator|==
literal|0
condition|)
name|mflag
operator|++
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|arg
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
name|argc
operator|--
expr_stmt|;
comment|/* 		 *  all arguments following a null option (- ) are  		 *   treated as file names, so that file names may 		 *   begin with a minus sign (-). 		 */
if|if
condition|(
operator|*
operator|(
name|arg
operator|+
literal|1
operator|)
operator|==
literal|'\0'
condition|)
break|break;
while|while
condition|(
operator|*
operator|++
name|arg
operator|!=
literal|'\0'
condition|)
switch|switch
condition|(
operator|*
name|arg
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* "all" */
name|aflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* "copy" */
name|cflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* "debug" */
name|dflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* "force" */
name|fflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* "interactive" */
name|iflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* "recursive" */
name|rflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* "save" */
name|sflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* "time" stamp */
name|tflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* "undelete" */
name|uflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* "move" */
name|mflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* "not save" */
name|nflg
operator|++
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"dl: unknown option %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cflag
operator|||
name|mflag
operator|||
name|nflg
condition|)
name|sflg
operator|++
expr_stmt|;
comment|/* 	 * set up home directory pathname 	 */
name|setpath
argument_list|()
expr_stmt|;
comment|/* 	 * process "undelete all" request 	 */
if|if
condition|(
name|aflg
condition|)
block|{
name|undelete_all
argument_list|(
name|iflg
argument_list|)
expr_stmt|;
name|exit
expr_stmt|;
block|}
comment|/* 	 * remove previously saved files unless "save" option,    	 *  or ud or rm mode 	 */
if|if
condition|(
operator|!
name|sflg
operator|&&
operator|!
name|uflg
condition|)
name|dldir
argument_list|(
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nflg
operator|&&
name|lstat
argument_list|(
name|path
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * set up .dlsave directory  	 	 */
name|mode
operator|=
literal|0777
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dl: cannot mkdir ~/.dlsave\n"
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
operator|++
name|argv
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dl: cannot remove `..'\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 	 	* process "undelete" request(s) 	 	*/
if|if
condition|(
name|uflg
condition|)
block|{
name|undelete
argument_list|(
operator|*
name|argv
argument_list|,
name|iflg
argument_list|)
expr_stmt|;
name|exit
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * process delete request(s) 		 */
if|if
condition|(
name|cflag
condition|)
block|{
name|copy
argument_list|(
operator|*
name|argv
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|,
name|iflg
argument_list|,
name|rflg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|errcode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mflag
condition|)
block|{
name|move
argument_list|(
operator|*
name|argv
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|,
name|iflg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|errcode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nflg
condition|)
name|rm
argument_list|(
operator|*
name|argv
argument_list|,
name|iflg
argument_list|,
name|rflg
argument_list|)
expr_stmt|;
else|else
name|dl
argument_list|(
operator|*
name|argv
argument_list|,
name|iflg
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
name|errcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|setpath
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|home
decl_stmt|;
name|char
modifier|*
name|suffix
decl_stmt|;
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|home
operator|=
literal|"HOME"
expr_stmt|;
if|if
condition|(
operator|(
name|path
operator|=
name|getenv
argument_list|(
name|home
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dl: getenv failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|suffix
operator|=
literal|"/.dlsave"
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|package
argument_list|(
argument|argu
argument_list|)
end_macro

begin_decl_stmt
name|char
name|argu
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|char
modifier|*
name|slash
decl_stmt|,
modifier|*
name|slashdot
decl_stmt|;
name|char
modifier|*
name|place
decl_stmt|;
name|char
name|line2
index|[
literal|512
index|]
decl_stmt|;
name|place
operator|=
name|line2
expr_stmt|;
name|strcpy
argument_list|(
name|place
argument_list|,
name|argu
argument_list|)
expr_stmt|;
name|path2
operator|=
name|line
expr_stmt|;
name|strcpy
argument_list|(
name|path2
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|slashdot
operator|=
literal|"/.#"
expr_stmt|;
name|strcat
argument_list|(
name|path2
argument_list|,
name|slashdot
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|argu
argument_list|)
expr_stmt|;
name|slash
operator|=
literal|"/"
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|place
index|[
name|j
index|]
operator|==
operator|*
name|slash
condition|)
block|{
name|k
operator|=
name|j
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|strcat
argument_list|(
name|path2
argument_list|,
name|argu
operator|+
name|k
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|undelete_all
argument_list|(
argument|iflg
argument_list|)
end_macro

begin_block
block|{
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|x
decl_stmt|;
comment|/* 	 * undelete all saved files (a option) 	 */
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
name|printf
argument_list|(
literal|"uda: cannot read %s?\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_ino
operator|!=
literal|0
operator|&&
operator|!
name|dotname
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
condition|)
block|{
name|filename
operator|=
operator|(
name|dp
operator|->
name|d_name
operator|)
operator|+
literal|2
expr_stmt|;
name|package
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|iflg
condition|)
block|{
name|printf
argument_list|(
literal|"uda: undelete %s?"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yes
argument_list|()
condition|)
goto|goto
name|no
goto|;
block|}
if|if
condition|(
name|lstat
argument_list|(
name|filename
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"uda: %s exists. Override?"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yes
argument_list|()
condition|)
goto|goto
name|no
goto|;
block|}
name|x
operator|=
name|move
argument_list|(
name|path2
argument_list|,
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|iflg
condition|)
block|{
if|if
condition|(
name|x
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"uda: %s undeleted.\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"uda: unable to undelete %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
name|no
label|:
continue|continue;
block|}
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|undelete
argument_list|(
argument|arg
argument_list|,
argument|iflg
argument_list|)
end_macro

begin_decl_stmt
name|char
name|arg
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|buf1
decl_stmt|,
name|buf2
decl_stmt|;
name|int
name|x
decl_stmt|;
comment|/* 	 * undelete a saved file (u option) 	 */
name|package
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|path2
argument_list|,
operator|&
name|buf1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
name|printf
argument_list|(
literal|"ud: %s nonexistent\n"
argument_list|,
name|path2
argument_list|)
expr_stmt|;
operator|++
name|errcode
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|iflg
condition|)
block|{
name|printf
argument_list|(
literal|"ud: undelete %s?"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yes
argument_list|()
condition|)
return|return;
block|}
if|if
condition|(
name|lstat
argument_list|(
name|arg
argument_list|,
operator|&
name|buf2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ud: %s exists: overwrite?"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yes
argument_list|()
condition|)
return|return;
block|}
name|x
operator|=
name|move
argument_list|(
name|path2
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|iflg
condition|)
block|{
if|if
condition|(
name|x
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"ud: %s undeleted.\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ud: unable to undelete %s\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_macro
name|rm
argument_list|(
argument|arg
argument_list|,
argument|iflg
argument_list|,
argument|rflg
argument_list|)
end_macro

begin_decl_stmt
name|char
name|arg
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"rm entered: arg=%s fflag=%d iflg=%d rflg=%d\n"
argument_list|,
name|arg
argument_list|,
name|fflag
argument_list|,
name|iflg
argument_list|,
name|rflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|arg
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
name|printf
argument_list|(
literal|"rm: %s nonexistent\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
operator|++
name|errcode
expr_stmt|;
return|return;
block|}
comment|/* 	 * unlink file named by arg 	 */
if|if
condition|(
operator|(
name|buf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
operator|||
name|rflg
condition|)
block|{
if|if
condition|(
name|iflg
condition|)
block|{
name|printf
argument_list|(
literal|"rm: remove directory %s?"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yes
argument_list|()
condition|)
return|return;
block|}
name|dldir
argument_list|(
name|arg
argument_list|,
name|iflg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|fflag
operator|&&
name|iflg
condition|)
block|{
name|printf
argument_list|(
literal|"rm: remove %s?"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yes
argument_list|()
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|fflag
condition|)
block|{
if|if
condition|(
operator|(
name|buf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFLNK
operator|&&
name|access
argument_list|(
name|arg
argument_list|,
literal|02
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"rm: override protection %o for %s?\n"
argument_list|,
name|buf
operator|.
name|st_mode
operator|&
literal|0777
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yes
argument_list|()
condition|)
return|return;
block|}
block|}
if|if
condition|(
name|unlink
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
name|fflag
condition|)
block|{
name|printf
argument_list|(
literal|"rm: %s not removed.\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
operator|++
name|errcode
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|fflag
operator|&&
name|iflg
condition|)
name|printf
argument_list|(
literal|"rm: %s removed.\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_macro
name|dl
argument_list|(
argument|arg
argument_list|,
argument|iflg
argument_list|)
end_macro

begin_decl_stmt
name|char
name|arg
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * move the argument (file or directory) to  	 *  .dlsave directory in user's home directory 	 */
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"dl entered: arg=%s fflag=%d iflg=%d\n"
argument_list|,
name|arg
argument_list|,
name|fflag
argument_list|,
name|iflg
argument_list|)
expr_stmt|;
name|package
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|arg
argument_list|,
name|path2
argument_list|,
name|iflg
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|dldir
argument_list|(
argument|arg
argument_list|,
argument|iflg
argument_list|)
end_macro

begin_decl_stmt
name|char
name|arg
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|buf1
decl_stmt|,
name|buf2
decl_stmt|;
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|char
name|name
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"dldir entered: arg=%s fflag=%d iflg=%d\n"
argument_list|,
name|arg
argument_list|,
name|fflag
argument_list|,
name|iflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|arg
argument_list|,
operator|&
name|buf1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
operator|&&
name|iflg
condition|)
name|printf
argument_list|(
literal|"dldir: %s nonexistent\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
operator|++
name|errcode
expr_stmt|;
return|return;
block|}
comment|/* 	 * if the argument is a directory, 	 * recursively remove the directory's contents  	 * and then the directory. 	 */
if|if
condition|(
operator|(
name|buf1
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|arg
argument_list|,
literal|02
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
block|{
name|printf
argument_list|(
literal|"dldir: %s not accessable\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|errcode
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|arg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_ino
operator|!=
literal|0
operator|&&
operator|!
name|dotname
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s/%s"
argument_list|,
name|arg
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"dldir: name= %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|name
argument_list|,
operator|&
name|buf2
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
name|printf
argument_list|(
literal|"dldir: %s nonexistent\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|++
name|errcode
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|buf2
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
operator|&&
name|iflg
condition|)
block|{
name|printf
argument_list|(
literal|"dldir: delete directory %s?"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yes
argument_list|()
condition|)
return|return;
block|}
name|dldir
argument_list|(
name|name
argument_list|,
name|iflg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|fflag
operator|&&
name|iflg
condition|)
block|{
name|printf
argument_list|(
literal|"dldir: delete file %s?"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yes
argument_list|()
condition|)
return|return;
block|}
comment|/* 	 				 * permanently remove the file 	 				 */
if|if
condition|(
name|unlink
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
name|printf
argument_list|(
literal|"dldir: %s not removed\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|++
name|errcode
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|fflag
operator|&&
name|iflg
condition|)
name|printf
argument_list|(
literal|"dldir: %s removed.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dotname
argument_list|(
name|arg
argument_list|)
condition|)
return|return;
if|if
condition|(
name|rmdir
argument_list|(
name|arg
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
operator|&&
name|iflg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dldir: rmdir:"
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
name|errcode
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|fflag
operator|&&
name|iflg
condition|)
name|printf
argument_list|(
literal|"dldir: directory %s removed.\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
end_block

begin_macro
name|dotname
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
if|if
condition|(
name|s
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|yes
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|b
decl_stmt|;
name|i
operator|=
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|b
operator|!=
literal|'\n'
operator|&&
name|b
operator|!=
name|EOF
condition|)
name|b
operator|=
name|getchar
argument_list|()
expr_stmt|;
return|return
operator|(
name|i
operator|==
literal|'y'
operator|)
return|;
block|}
end_block

begin_macro
name|move
argument_list|(
argument|source
argument_list|,
argument|target
argument_list|,
argument|iflag
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|source
decl_stmt|,
modifier|*
name|target
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|targetexists
decl_stmt|;
name|int
name|sw
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"move entered: source=%s target=%s fflag=%d iflag=%d\n"
argument_list|,
name|source
argument_list|,
name|target
argument_list|,
name|fflag
argument_list|,
name|iflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|source
argument_list|,
operator|&
name|s1
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
name|error
argument_list|(
literal|"cannot access %s"
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"move: lstat(%s) successful\n"
argument_list|,
name|source
argument_list|)
expr_stmt|;
comment|/* 	 * First, try to rename source to target. 	 */
name|targetexists
operator|=
name|lstat
argument_list|(
name|target
argument_list|,
operator|&
name|s2
argument_list|)
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
name|targetexists
condition|)
block|{
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"move: lstat(%s) successful\n"
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
operator|.
name|st_dev
operator|==
name|s2
operator|.
name|st_dev
operator|&&
name|s1
operator|.
name|st_ino
operator|==
name|s2
operator|.
name|st_ino
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
name|error
argument_list|(
literal|"%s and %s are identical"
argument_list|,
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|access
argument_list|(
name|target
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|fflag
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"override protection %o for %s? "
argument_list|,
name|s2
operator|.
name|st_mode
operator|&
name|MODEBITS
argument_list|,
name|target
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|sw
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mflag
operator|&&
name|ms
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ISREG
argument_list|(
name|s2
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
operator|&&
name|sw
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"overwrite file %s?"
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yes
argument_list|()
condition|)
return|return;
block|}
name|ms
operator|=
literal|1
expr_stmt|;
name|dl
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s1
operator|.
name|st_dev
operator|!=
name|s2
operator|.
name|st_dev
operator|&&
name|ISDIR
argument_list|(
name|s2
argument_list|)
condition|)
goto|goto
name|copyit
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|fflag
operator|&&
name|iflag
operator|&&
operator|!
name|mflag
condition|)
block|{
if|if
condition|(
name|ISDIR
argument_list|(
name|s1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"dl: delete directory %s?"
argument_list|,
name|source
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"dl: delete file %s?"
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yes
argument_list|()
condition|)
return|return;
block|}
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"move(1)rename: source=%s, target=%s\n"
argument_list|,
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
operator|&&
name|iflag
operator|&&
operator|!
name|mflag
condition|)
name|printf
argument_list|(
literal|"dl: %s deleted. \n"
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"move: %s renamed %s.\n"
argument_list|,
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"move/rename: errno=%d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|EXDEV
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
operator|&&
name|iflag
condition|)
block|{
name|Perror2
argument_list|(
name|source
argument_list|,
literal|"rename"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|copyit
goto|;
block|}
if|if
condition|(
name|targetexists
operator|&&
name|unlink
argument_list|(
name|target
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
name|error
argument_list|(
literal|"cannot unlink %s"
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"move: target unlinked\n"
argument_list|)
expr_stmt|;
comment|/* 	 * If file or directory cannot be renamed: 	 *  If directory, copy it with r option  	 *   and delete the source 	 */
name|copyit
label|:
if|if
condition|(
name|ISDIR
argument_list|(
name|s1
argument_list|)
condition|)
block|{
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"move: directory copy %s to %s\n"
argument_list|,
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|source
argument_list|,
name|target
argument_list|,
name|iflag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dldir
argument_list|(
name|source
argument_list|,
name|iflag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 *  If link, recreate symbolic link 	 */
if|if
condition|(
name|ISLNK
argument_list|(
name|s1
argument_list|)
condition|)
block|{
specifier|register
name|m
expr_stmt|;
name|char
name|symln
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|readlink
argument_list|(
name|source
argument_list|,
name|symln
argument_list|,
sizeof|sizeof
argument_list|(
name|symln
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
name|Perror
argument_list|(
name|source
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|m
operator|=
name|umask
argument_list|(
operator|~
operator|(
name|s1
operator|.
name|st_mode
operator|&
name|MODEBITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|symlink
argument_list|(
name|symln
argument_list|,
name|target
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
name|Perror
argument_list|(
name|target
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"move: symlink to target successful\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 *  If device 	 */
if|if
condition|(
name|ISDEV
argument_list|(
name|s1
argument_list|)
condition|)
block|{
if|if
condition|(
name|mknod
argument_list|(
name|target
argument_list|,
name|s1
operator|.
name|st_mode
argument_list|,
name|s1
operator|.
name|st_rdev
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
name|Perror
argument_list|(
name|target
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"move: mknod for target successful\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 *  If regular file, copy it 	 */
if|if
condition|(
name|ISREG
argument_list|(
name|s1
argument_list|)
condition|)
block|{
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"move: file copy %s to %s\n"
argument_list|,
name|source
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|source
argument_list|,
name|target
argument_list|,
name|iflag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
operator|!
name|fflag
condition|)
name|error
argument_list|(
literal|"%s: unknown file type %o"
argument_list|,
name|source
argument_list|,
name|s1
operator|.
name|st_mode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 *  If a move has been successful, erase the source 	 */
name|cleanup
label|:
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"move: cleanup\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|source
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
name|error
argument_list|(
literal|"cannot unlink %s"
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"move: %s unlinked.\n"
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fflag
operator|&&
name|iflag
operator|&&
operator|!
name|mflag
condition|)
name|printf
argument_list|(
literal|"dl: %s deleted.\n"
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*VARARGS*/
end_comment

begin_macro
name|query
argument_list|(
argument|prompt
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|a1
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|i
decl_stmt|,
name|c
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|prompt
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|i
operator|=
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
return|return
operator|(
name|i
operator|==
literal|'y'
operator|)
return|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|fmt
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dl: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|Perror
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|MAXPATHLEN
operator|+
literal|10
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"move: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|Perror2
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|MAXPATHLEN
operator|+
literal|20
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"dl: %s: %s"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|BSIZE
value|8192
end_define

begin_function_decl
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|copy
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|,
argument|iflag
argument_list|,
argument|rflag
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fold
decl_stmt|,
name|fnew
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|last
decl_stmt|,
name|destname
index|[
name|BSIZE
index|]
decl_stmt|,
name|buf
index|[
name|BSIZE
index|]
decl_stmt|;
name|struct
name|stat
name|stfrom
decl_stmt|,
name|stto
decl_stmt|;
name|time_t
name|tv
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"copy entered: from=%s to=%s iflag=%d rflag=%d\n"
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|iflag
argument_list|,
name|rflag
argument_list|)
expr_stmt|;
name|fold
operator|=
name|open
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fold
operator|<
literal|0
condition|)
block|{
name|Cerror
argument_list|(
name|from
argument_list|,
name|fflag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fold
argument_list|,
operator|&
name|stfrom
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Cerror
argument_list|(
name|from
argument_list|,
name|fflag
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fold
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"copy: fstat(%s) OK.\n"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|to
argument_list|,
operator|&
name|stto
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|stto
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
name|last
operator|=
name|rindex
argument_list|(
name|from
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
name|last
operator|++
expr_stmt|;
else|else
name|last
operator|=
name|from
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|to
argument_list|)
operator|+
name|strlen
argument_list|(
name|last
argument_list|)
operator|>=
name|BSIZE
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cp: %s/%s: Name too long"
argument_list|,
name|to
argument_list|,
name|last
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fold
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|destname
argument_list|,
literal|"%s/%s"
argument_list|,
name|to
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"copy: stat %s& %s is dir., to=%s.\n"
argument_list|,
name|to
argument_list|,
name|to
argument_list|,
name|destname
argument_list|)
expr_stmt|;
name|to
operator|=
name|destname
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rflag
operator|&&
operator|(
name|stfrom
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cp: %s is a directory, and option -r not chosen.  Job aborted.\n"
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|rflag
operator|&&
operator|(
name|stfrom
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fold
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"copy: rflag& from is dir., %s closed.\n"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|to
argument_list|,
operator|&
name|stto
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|mkdir
argument_list|(
name|to
argument_list|,
operator|(
name|int
operator|)
name|stfrom
operator|.
name|st_mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Cerror
argument_list|(
name|to
argument_list|,
name|fflag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"copy: stat(%s) failed& mkdir % successful.\n"
argument_list|,
name|to
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
block|{
if|if
condition|(
operator|(
name|stto
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
name|dl
argument_list|(
name|to
argument_list|,
name|iflag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cp: %s: Not a directory.\n"
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"copy: return with rcopy(%s,%s,%d,%d)\n"
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|iflag
argument_list|,
name|rflag
argument_list|)
expr_stmt|;
return|return
operator|(
name|rcopy
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|iflag
argument_list|,
name|rflag
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|to
argument_list|,
operator|&
name|stto
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"cp:stat(%s) o.k.\n"
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|stfrom
operator|.
name|st_dev
operator|==
name|stto
operator|.
name|st_dev
operator|&&
name|stfrom
operator|.
name|st_ino
operator|==
name|stto
operator|.
name|st_ino
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cp: Cannot copy file to itself.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fold
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cflag
operator|&&
name|cs
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cp: %s exists: overwrite? "
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yes
argument_list|()
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fold
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|dl
argument_list|(
name|to
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cs
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|fnew
operator|=
name|creat
argument_list|(
name|to
argument_list|,
operator|(
name|int
operator|)
name|stfrom
operator|.
name|st_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnew
operator|<
literal|0
condition|)
block|{
name|Cerror
argument_list|(
name|to
argument_list|,
name|fflag
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fold
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"copy: creat(%s,%d) successful.\n"
argument_list|,
name|to
argument_list|,
name|stfrom
operator|.
name|st_mode
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|n
operator|=
name|read
argument_list|(
name|fold
argument_list|,
name|buf
argument_list|,
name|BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|Cerror
argument_list|(
name|from
argument_list|,
name|fflag
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fold
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fnew
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|write
argument_list|(
name|fnew
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
block|{
name|Cerror
argument_list|(
name|to
argument_list|,
name|fflag
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fold
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fnew
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"copy: %s copied to %s.\n"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tflag
condition|)
block|{
comment|/* restore original time-stamp */
name|tv
index|[
literal|0
index|]
operator|=
name|stfrom
operator|.
name|st_atime
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|=
name|stfrom
operator|.
name|st_mtime
expr_stmt|;
operator|(
name|void
operator|)
name|utime
argument_list|(
name|to
argument_list|,
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"copy: tflag on, tv[0]=%d, tv[1]=%d.\n"
argument_list|,
name|tv
index|[
literal|0
index|]
argument_list|,
name|tv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"copy: returning from copy, from=%s, to=%s.\n"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fold
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fnew
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|rcopy
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|,
argument|iflag
argument_list|,
argument|rflag
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DIR
modifier|*
name|fold
init|=
name|opendir
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|int
name|errs
init|=
literal|0
decl_stmt|;
name|char
name|fromname
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"rcopy: entered: from=%s, to=%s.\n"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|fold
operator|==
literal|0
condition|)
block|{
name|Cerror
argument_list|(
name|from
argument_list|,
name|fflag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|dp
operator|=
name|readdir
argument_list|(
name|fold
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
literal|0
condition|)
block|{
name|closedir
argument_list|(
name|fold
argument_list|)
expr_stmt|;
return|return
operator|(
name|errs
operator|)
return|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_ino
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strlen
argument_list|(
name|from
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|>=
name|BUFSIZ
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cp: %s/%s: Name too long.\n"
argument_list|,
name|from
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
name|errs
operator|++
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fromname
argument_list|,
literal|"%s/%s"
argument_list|,
name|from
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
name|printf
argument_list|(
literal|"rcopy: copy(%s,%s,%d,%d)\n"
argument_list|,
name|fromname
argument_list|,
name|to
argument_list|,
name|iflag
argument_list|,
name|rflag
argument_list|)
expr_stmt|;
name|errs
operator|+=
name|copy
argument_list|(
name|fromname
argument_list|,
name|to
argument_list|,
name|iflag
argument_list|,
name|rflag
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|Cerror
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|fflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cp: "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

