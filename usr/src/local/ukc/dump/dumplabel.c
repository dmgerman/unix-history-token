begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)dumplabel.c	1.3 (UKC) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/***  * program name: 	dumplabel.c * function: 	prints the label from a header 	writes a dummy dump header at the start of a tape 	Doesn't do any checksum * switches: 	-f<tapename> 	-r	rewind/offline each tape 	-l	label format 	followed by list of tape labels in the same format at given to the 		locally modified dump program 	if no tape labels are given print the details on the start of a tape * libraries used: 	standard * compile time parameters: 	cc -o dumplabel dumplabel.c * history: 	Written August 1987 Peter Collinson UKC  ***/
end_comment

begin_include
include|#
directive|include
file|"dump.h"
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_define
define|#
directive|define
name|LABMAX
value|100
end_define

begin_comment
comment|/* get space for 100 */
end_comment

begin_decl_stmt
name|char
modifier|*
name|labarg
index|[
name|LABMAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* vector of map entries */
end_comment

begin_decl_stmt
name|char
modifier|*
name|labfmt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* format for tape label */
end_comment

begin_decl_stmt
name|int
name|labct
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of entries */
end_comment

begin_comment
comment|/* if zero then no labels used */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tape
init|=
literal|"/dev/rmt8"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dorew
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if rewind offline on exit */
end_comment

begin_decl_stmt
name|int
name|tapecount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of tapes dealt with */
end_comment

begin_function_decl
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|--
name|argc
condition|)
block|{
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|p
operator|=
operator|*
name|argv
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'f'
case|:
if|if
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
name|argv
operator|++
expr_stmt|;
name|tape
operator|=
operator|*
name|argv
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
name|dorew
operator|++
expr_stmt|;
comment|/* no rewind/offline */
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
name|argv
operator|++
expr_stmt|;
name|labfmt
operator|=
operator|*
name|argv
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|storelabelmap
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|labfmt
operator|&&
name|labct
condition|)
if|if
condition|(
name|index
argument_list|(
name|labfmt
argument_list|,
literal|'%'
argument_list|)
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning - no format specifier (%%s) found in -l argument\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|labct
condition|;
name|i
operator|++
control|)
name|dolabel
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|labct
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tapecount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|labfmt
condition|)
block|{
name|labct
operator|=
literal|0
expr_stmt|;
name|dolabel
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* pretend a volume number of 1 */
block|}
else|else
name|printlabel
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Store map list  *	The map list   *	allows a simple way to specify a range of tapes  *	This generates a string which is inserted into the label format  *	by use of an sprint operation  *  *	The basic form here is:  *<string>			a single string  *<string>,<string>,......	a list of strings  *<string>-<string>		a range of strings  *					where the string is `incremented'  *					to generate a list  */
end_comment

begin_macro
name|storelabelmap
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ss
decl_stmt|,
modifier|*
name|es
decl_stmt|;
specifier|register
name|char
modifier|*
name|incbase
decl_stmt|,
modifier|*
name|incr
decl_stmt|;
specifier|register
name|lastc
expr_stmt|;
name|char
modifier|*
name|labskip
parameter_list|()
function_decl|;
name|char
modifier|*
name|strstore
parameter_list|()
function_decl|;
comment|/* 	 *	Parse the argument looking for a single string 	 */
for|for
control|(
name|ss
operator|=
name|arg
init|;
operator|*
name|ss
condition|;
name|ss
operator|=
name|es
control|)
block|{
name|es
operator|=
name|labskip
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|lastc
operator|=
operator|*
name|es
expr_stmt|;
comment|/* save last character */
operator|*
name|es
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* make the first label into a string */
if|if
condition|(
name|labct
operator|>
name|LABMAX
condition|)
name|labfatal
argument_list|(
literal|"Too many (> %d) tape labels specified\n"
argument_list|,
name|LABMAX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ss
operator|==
literal|'\0'
condition|)
name|labfatal
argument_list|(
literal|"Zero length label found\n"
argument_list|)
expr_stmt|;
name|labarg
index|[
name|labct
operator|++
index|]
operator|=
name|strstore
argument_list|(
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastc
operator|==
literal|0
condition|)
break|break;
comment|/* end of list */
if|if
condition|(
name|lastc
operator|==
literal|'-'
condition|)
block|{
comment|/* 			 * this gives a tape range 			 * increment the source number until it equals the final 			 * value 			 */
name|incbase
operator|=
name|ss
expr_stmt|;
name|ss
operator|=
name|es
expr_stmt|;
name|es
operator|=
name|labskip
argument_list|(
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|es
operator|==
literal|'-'
condition|)
name|labfatal
argument_list|(
literal|"Range has the format<string>-<string>\n"
argument_list|)
expr_stmt|;
name|lastc
operator|=
operator|*
name|es
expr_stmt|;
if|if
condition|(
name|lastc
condition|)
operator|*
name|es
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* 			 * basic test the source string length must be equal to the 			 * end string length 			 */
if|if
condition|(
name|strlen
argument_list|(
name|incbase
argument_list|)
operator|!=
name|strlen
argument_list|(
name|ss
argument_list|)
condition|)
name|labfatal
argument_list|(
literal|"strlen(\"%s\") != strlen(\"%s\")\n"
argument_list|,
name|incbase
argument_list|,
name|ss
argument_list|)
expr_stmt|;
name|labelrange
argument_list|(
name|incbase
argument_list|,
name|ss
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	Expand a label range  */
end_comment

begin_comment
comment|/* static */
end_comment

begin_macro
name|labelrange
argument_list|(
argument|startrange
argument_list|,
argument|endrange
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|startrange
decl_stmt|,
modifier|*
name|endrange
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|incr
decl_stmt|;
specifier|register
name|int
name|carry
decl_stmt|;
for|for
control|(
name|incr
operator|=
name|startrange
operator|+
name|strlen
argument_list|(
name|startrange
argument_list|)
operator|-
literal|1
init|;
name|strcmp
argument_list|(
name|startrange
argument_list|,
name|endrange
argument_list|)
operator|!=
literal|0
condition|;
control|)
block|{
comment|/* start incrementing */
name|carry
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|incr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|incr
operator|==
literal|'9'
condition|)
block|{
operator|*
name|incr
operator|=
literal|'0'
expr_stmt|;
name|carry
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|incr
operator|)
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|incr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|incr
operator|==
literal|'Z'
condition|)
block|{
operator|*
name|incr
operator|=
literal|'A'
expr_stmt|;
name|carry
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|incr
operator|)
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|islower
argument_list|(
operator|*
name|incr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|incr
operator|==
literal|'z'
condition|)
block|{
operator|*
name|incr
operator|=
literal|'a'
expr_stmt|;
name|carry
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|incr
operator|)
operator|++
expr_stmt|;
block|}
else|else
name|labfatal
argument_list|(
literal|"Problem with label map range spec - can only increment alphanumeric values\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|carry
condition|)
block|{
name|incr
operator|--
expr_stmt|;
if|if
condition|(
name|incr
operator|<
name|startrange
condition|)
name|labfatal
argument_list|(
literal|"Problem with label map range spec - end of range reached\n"
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|carry
condition|)
do|;
if|if
condition|(
name|labct
operator|>
name|LABMAX
condition|)
name|labfatal
argument_list|(
literal|"Too many (> %d) tape labels specified\n"
argument_list|,
name|LABMAX
argument_list|)
expr_stmt|;
name|labarg
index|[
name|labct
operator|++
index|]
operator|=
name|strstore
argument_list|(
name|startrange
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *	Store a string using malloc  */
end_comment

begin_comment
comment|/* static */
end_comment

begin_function
name|char
modifier|*
name|strstore
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|len
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
expr_stmt|;
specifier|register
name|char
modifier|*
name|dest
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|dest
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|NULL
condition|)
name|labfatal
argument_list|(
literal|"No memory for string storage\n"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|arg
argument_list|,
name|dest
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|dest
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Create a tape label from a volume number  */
end_comment

begin_function
name|char
modifier|*
name|createlabel
parameter_list|(
name|volno
parameter_list|)
name|int
name|volno
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|LBLSIZE
operator|+
name|LBLSIZE
index|]
decl_stmt|;
name|char
name|volbuf
index|[
literal|8
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
name|labfmt
operator|==
name|NULL
condition|)
name|labfmt
operator|=
literal|"%s"
expr_stmt|;
if|if
condition|(
name|labct
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|volbuf
argument_list|,
literal|"%d"
argument_list|,
name|volno
argument_list|)
expr_stmt|;
name|arg
operator|=
name|volbuf
expr_stmt|;
block|}
else|else
name|arg
operator|=
name|labarg
index|[
name|volno
operator|-
literal|1
index|]
expr_stmt|;
comment|/* volumes run 1-> */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|labfmt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|buf
index|[
name|LBLSIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Truncate to correct size */
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	skip forward looking for valid end of label characters  */
end_comment

begin_function
name|char
modifier|*
name|labskip
parameter_list|(
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|str
operator|!=
literal|','
operator|&&
operator|*
name|str
operator|!=
literal|'-'
operator|&&
operator|*
name|str
condition|)
name|str
operator|++
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	do the actual labelling  */
end_comment

begin_macro
name|dolabel
argument_list|(
argument|index
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|fd
expr_stmt|;
name|tapecount
operator|++
expr_stmt|;
name|askformount
argument_list|(
name|index
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|tape
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tape open error\n"
argument_list|)
expr_stmt|;
name|askformount
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spcl
operator|.
name|c_host
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|gethostname
argument_list|(
name|spcl
operator|.
name|c_host
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|spcl
operator|.
name|c_level
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|spcl
operator|.
name|c_filesys
argument_list|,
literal|"Tape has only been labelled"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|spcl
operator|.
name|c_dev
argument_list|,
literal|"???????????"
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|spcl
operator|.
name|c_label
argument_list|,
name|createlabel
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|u_spcl
argument_list|,
sizeof|sizeof
argument_list|(
name|u_spcl
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|u_spcl
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"Tape write error"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|rewind
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	ask for a tape to be mounted  */
end_comment

begin_macro
name|askformount
argument_list|(
argument|index
argument_list|)
end_macro

begin_block
block|{
while|while
condition|(
name|query
argument_list|(
literal|"Mount tape `%s'\nReady to go? "
argument_list|,
name|createlabel
argument_list|(
name|index
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
empty_stmt|;
block|}
end_block

begin_comment
comment|/*  *	ask yes/no question  *	return	1 on yes  *		0 on no  */
end_comment

begin_macro
name|query
argument_list|(
argument|question
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|question
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|replybuffer
index|[
literal|64
index|]
decl_stmt|;
name|int
name|back
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
name|question
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|replybuffer
argument_list|,
literal|63
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|qclean
argument_list|(
name|replybuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|replybuffer
argument_list|,
literal|"yes"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|replybuffer
argument_list|,
literal|"y"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|back
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|replybuffer
argument_list|,
literal|"no"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|replybuffer
argument_list|,
literal|"n"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"Abort? "
argument_list|)
condition|)
name|labfatal
argument_list|(
literal|"Aborting\n"
argument_list|)
expr_stmt|;
name|back
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"yes\" or \"no\" ONLY!\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|done
label|:
return|return
operator|(
name|back
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|qclean
argument_list|(
name|ptr
argument_list|)
specifier|register
name|char
operator|*
name|ptr
expr_stmt|;
end_expr_stmt

begin_block
block|{
for|for
control|(
init|;
operator|*
name|ptr
condition|;
name|ptr
operator|++
control|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
operator|*
name|ptr
operator|=
name|tolower
argument_list|(
operator|*
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_macro
name|rewind
argument_list|(
argument|fd
argument_list|)
end_macro

begin_block
block|{
name|struct
name|mtop
name|mtop
decl_stmt|;
if|if
condition|(
name|dorew
condition|)
block|{
name|mtop
operator|.
name|mt_op
operator|=
name|MTOFFL
expr_stmt|;
name|mtop
operator|.
name|mt_count
operator|=
literal|1
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|MTIOCTOP
argument_list|,
operator|&
name|mtop
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *	fatal error message routine  */
end_comment

begin_macro
name|labfatal
argument_list|(
argument|fmt
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|a4
decl_stmt|,
name|a5
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	print the label from a tape  */
end_comment

begin_macro
name|printlabel
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|fd
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|tape
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Tape open error"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|u_spcl
argument_list|,
sizeof|sizeof
name|u_spcl
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Tape read"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Dump   date: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|spcl
operator|.
name|c_date
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Dumped from: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|spcl
operator|.
name|c_ddate
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spcl
operator|.
name|c_host
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return;
name|printf
argument_list|(
literal|"Level %d dump of %s on %s:%s\n"
argument_list|,
name|spcl
operator|.
name|c_level
argument_list|,
name|spcl
operator|.
name|c_filesys
argument_list|,
name|spcl
operator|.
name|c_host
argument_list|,
name|spcl
operator|.
name|c_dev
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Label: %s\n"
argument_list|,
name|spcl
operator|.
name|c_label
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Volume %d of the dump, starting at inode %d\n"
argument_list|,
name|spcl
operator|.
name|c_volume
argument_list|,
name|spcl
operator|.
name|c_inumber
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

