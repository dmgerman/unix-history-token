begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)dumplab.c	1.2 (UKC) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  *	This file included by Peter Collinson  *	to handle tape labelling   *	There are two dump parameters which are used to specify labels  *	-l	Give the basic label format string - this may contain   *		a single %s to insert the volume number string  *	-m	Map string - used to map volume numbers into a string  *  *	Routines are:  *	storelabel(arg)		- called from main() to store a label format  *  *	storelabelmap(arg)	- called from main() to process a map argument  *				- which is  *					string		simple string  *					string-string	expanded by incrementing  *					string,string,..list of the above  *	char *  *	createlabel(volno)	- returns a label appropriate for the volume  *					  *	initialtape()		- called to print an operator message asking for  *				- the 1st tape   *	  *	labelest(etapes)	- checks if there are enough tape labels  *				- specified for a given dump  *  *	labelcheck()		- reads one record from tape  *				- checks that the labels match  *				- backspace one record back  *				- so that multi-volume dumps work  *  *	log_volume()		- write a logfile entry for the volume  *	  */
end_comment

begin_include
include|#
directive|include
file|"dump.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_define
define|#
directive|define
name|LABMAX
value|100
end_define

begin_comment
comment|/* get space for 100 */
end_comment

begin_decl_stmt
name|char
modifier|*
name|labfmt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Basic tape format */
end_comment

begin_decl_stmt
name|char
modifier|*
name|labarg
index|[
name|LABMAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to argument list */
end_comment

begin_decl_stmt
name|int
name|labct
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of entries */
end_comment

begin_comment
comment|/* if zero then no labels used */
end_comment

begin_decl_stmt
name|int
name|userlabel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if user has given a label */
end_comment

begin_decl_stmt
name|int
name|labchk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* check labels - set by t(est) flag */
end_comment

begin_comment
comment|/*  *	The file /etc/dumpvolumes is used to maintain a log of  *	tapes which are/have been used for tape dumping  *	The format is:  *	label: date dev=<devname> level=<dump level> reel=<volume number> inode=<start inode>  */
end_comment

begin_decl_stmt
name|char
name|dumpvolumes
index|[]
init|=
literal|"/etc/dumpvolumes"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Called from argument decoding to store the  *	basic label format  *	This is the parameter to the -l parameter  */
end_comment

begin_macro
name|storelabel
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|labfmt
operator|=
name|arg
expr_stmt|;
name|userlabel
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	Store map list  *	The map list   *	allows a simple way to specify a range of tapes  *	This generates a string which is inserted into the label format  *	by use of an sprint operation  *  *	The basic form here is:  *<string>			a single string  *<string>,<string>,......	a list of strings  *<string>-<string>		a range of strings  *					where the string is `incremented'  *					to generate a list  */
end_comment

begin_macro
name|storelabelmap
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ss
decl_stmt|,
modifier|*
name|es
decl_stmt|;
specifier|register
name|char
modifier|*
name|incbase
decl_stmt|,
modifier|*
name|incr
decl_stmt|;
specifier|register
name|lastc
expr_stmt|;
name|char
modifier|*
name|labskip
parameter_list|()
function_decl|;
name|char
modifier|*
name|strstore
parameter_list|()
function_decl|;
name|userlabel
operator|=
literal|1
expr_stmt|;
comment|/* 	 *	Parse the argument looking for a single string 	 */
for|for
control|(
name|ss
operator|=
name|arg
init|;
operator|*
name|ss
condition|;
name|ss
operator|=
name|es
control|)
block|{
name|es
operator|=
name|labskip
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|lastc
operator|=
operator|*
name|es
expr_stmt|;
comment|/* save last character */
operator|*
name|es
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* make the first label into a string */
if|if
condition|(
name|labct
operator|>
name|LABMAX
condition|)
name|labfatal
argument_list|(
literal|"Too many (> %d) tape labels specified\n"
argument_list|,
name|LABMAX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ss
operator|==
literal|'\0'
condition|)
name|labfatal
argument_list|(
literal|"Zero length tape label found\n"
argument_list|)
expr_stmt|;
name|labarg
index|[
name|labct
operator|++
index|]
operator|=
name|strstore
argument_list|(
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastc
operator|==
literal|0
condition|)
break|break;
comment|/* end of list */
if|if
condition|(
name|lastc
operator|==
literal|'-'
condition|)
block|{
comment|/* 			 * this gives a tape range 			 * increment the source number until it equals the final 			 * value 			 */
name|incbase
operator|=
name|ss
expr_stmt|;
name|ss
operator|=
name|es
expr_stmt|;
name|es
operator|=
name|labskip
argument_list|(
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|es
operator|==
literal|'-'
condition|)
name|labfatal
argument_list|(
literal|"Range has the format<string>-<string>\n"
argument_list|)
expr_stmt|;
name|lastc
operator|=
operator|*
name|es
expr_stmt|;
if|if
condition|(
name|lastc
condition|)
operator|*
name|es
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* 			 * basic test the source string length must be equal to the 			 * end string length 			 */
if|if
condition|(
name|strlen
argument_list|(
name|incbase
argument_list|)
operator|!=
name|strlen
argument_list|(
name|ss
argument_list|)
condition|)
name|labfatal
argument_list|(
literal|"strlen(\"%s\") != strlen(\"%s\")\n"
argument_list|,
name|incbase
argument_list|,
name|ss
argument_list|)
expr_stmt|;
name|labelrange
argument_list|(
name|incbase
argument_list|,
name|ss
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	Expand a label range  */
end_comment

begin_comment
comment|/* static */
end_comment

begin_macro
name|labelrange
argument_list|(
argument|startrange
argument_list|,
argument|endrange
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|startrange
decl_stmt|,
modifier|*
name|endrange
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|incr
decl_stmt|;
specifier|register
name|int
name|carry
decl_stmt|;
for|for
control|(
name|incr
operator|=
name|startrange
operator|+
name|strlen
argument_list|(
name|startrange
argument_list|)
operator|-
literal|1
init|;
name|strcmp
argument_list|(
name|startrange
argument_list|,
name|endrange
argument_list|)
operator|!=
literal|0
condition|;
control|)
block|{
comment|/* start incrementing */
name|carry
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|incr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|incr
operator|==
literal|'9'
condition|)
block|{
operator|*
name|incr
operator|=
literal|'0'
expr_stmt|;
name|carry
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|incr
operator|)
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|incr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|incr
operator|==
literal|'Z'
condition|)
block|{
operator|*
name|incr
operator|=
literal|'A'
expr_stmt|;
name|carry
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|incr
operator|)
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|islower
argument_list|(
operator|*
name|incr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|incr
operator|==
literal|'z'
condition|)
block|{
operator|*
name|incr
operator|=
literal|'a'
expr_stmt|;
name|carry
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|incr
operator|)
operator|++
expr_stmt|;
block|}
else|else
name|labfatal
argument_list|(
literal|"Problem with label map range spec - can only increment alphanumeric values\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|carry
condition|)
block|{
name|incr
operator|--
expr_stmt|;
if|if
condition|(
name|incr
operator|<
name|startrange
condition|)
name|labfatal
argument_list|(
literal|"Problem with label map range spec - end of range reached\n"
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|carry
condition|)
do|;
if|if
condition|(
name|labct
operator|>
name|LABMAX
condition|)
name|labfatal
argument_list|(
literal|"Too many (> %d) tape labels specified\n"
argument_list|,
name|LABMAX
argument_list|)
expr_stmt|;
name|labarg
index|[
name|labct
operator|++
index|]
operator|=
name|strstore
argument_list|(
name|startrange
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *	Store a string using malloc  */
end_comment

begin_comment
comment|/* static */
end_comment

begin_function
name|char
modifier|*
name|strstore
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|len
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
expr_stmt|;
specifier|register
name|char
modifier|*
name|dest
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|dest
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|NULL
condition|)
name|labfatal
argument_list|(
literal|"No memory for string storage\n"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|arg
argument_list|,
name|dest
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|dest
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Create a tape label from a volume number  */
end_comment

begin_function
name|char
modifier|*
name|createlabel
parameter_list|(
name|volno
parameter_list|)
name|int
name|volno
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|LBLSIZE
operator|+
name|LBLSIZE
index|]
decl_stmt|;
specifier|static
name|int
name|lastvol
decl_stmt|;
name|char
name|volbuf
index|[
literal|8
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
name|userlabel
operator|==
literal|0
condition|)
return|return
operator|(
literal|"none"
operator|)
return|;
comment|/* previous behaviour */
if|if
condition|(
name|volno
operator|==
name|lastvol
condition|)
comment|/* cache */
return|return
operator|(
name|buf
operator|)
return|;
name|lastvol
operator|=
name|volno
expr_stmt|;
if|if
condition|(
name|labfmt
operator|==
name|NULL
condition|)
name|labfmt
operator|=
literal|"%s"
expr_stmt|;
if|if
condition|(
name|labct
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|volbuf
argument_list|,
literal|"%d"
argument_list|,
name|volno
argument_list|)
expr_stmt|;
name|arg
operator|=
name|volbuf
expr_stmt|;
block|}
else|else
name|arg
operator|=
name|labarg
index|[
name|volno
operator|-
literal|1
index|]
expr_stmt|;
comment|/* volumes run 1-> */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|labfmt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|buf
index|[
name|LBLSIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Truncate to correct size */
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_macro
name|initialtape
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|firstpr
expr_stmt|;
if|if
condition|(
name|labchk
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|firstpr
operator|==
literal|0
condition|)
name|msg
argument_list|(
literal|"Mount tape %s for reel 1 of the dump\n"
argument_list|,
name|createlabel
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|firstpr
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	given an estimated number of tapes, check that  *	there are enough tapes on the label list  */
end_comment

begin_macro
name|labelest
argument_list|(
argument|etapes
argument_list|)
end_macro

begin_decl_stmt
name|double
name|etapes
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|et
decl_stmt|;
if|if
condition|(
name|labct
condition|)
block|{
name|et
operator|=
name|ceil
argument_list|(
name|etapes
argument_list|)
expr_stmt|;
if|if
condition|(
name|et
operator|>
name|labct
condition|)
name|labfatal
argument_list|(
literal|"Only %d labe%s given, estimated need %d\n"
argument_list|,
name|labct
argument_list|,
name|labct
operator|==
literal|1
condition|?
literal|"l"
else|:
literal|"ls"
argument_list|,
name|et
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *	labelcheck  *	read a dump header and check that the tape header contains  *	the label we expected  *	close the fd on error to allow upper levels to loop  */
end_comment

begin_macro
name|labelcheck
argument_list|(
argument|fd
argument_list|,
argument|tno
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tno
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|union
name|u_spcl
name|uin
decl_stmt|;
comment|/* lots on the stack but that should be OK */
specifier|register
name|char
modifier|*
name|label
decl_stmt|;
specifier|register
name|char
modifier|*
name|ontape
init|=
name|uin
operator|.
name|s_spcl
operator|.
name|c_label
decl_stmt|;
if|if
condition|(
name|labchk
operator|==
literal|0
operator|||
name|pipeout
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|label
operator|=
name|createlabel
argument_list|(
name|tno
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|uin
argument_list|,
sizeof|sizeof
name|uin
argument_list|)
operator|!=
sizeof|sizeof
name|uin
condition|)
block|{
name|msg
argument_list|(
literal|"Tape does not start with the correctly sized record\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ontape
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|ontape
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|ontape
argument_list|,
name|label
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* skip back one record */
if|if
condition|(
name|backone
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|labfatal
argument_list|(
literal|"Label check cannot backspace tape\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|msg
argument_list|(
literal|"Tape labels do not match should be `%s' is `%s'\n"
argument_list|,
name|label
argument_list|,
name|ontape
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	write a log entry for the volume into the log file  */
end_comment

begin_macro
name|log_volume
argument_list|(
argument|tlabel
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|tlabel
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
name|FILE
modifier|*
name|logfd
decl_stmt|;
if|if
condition|(
name|uflag
operator|==
literal|0
operator|||
name|labchk
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|logfd
operator|=
name|fopen
argument_list|(
name|dumpvolumes
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|fprintf
argument_list|(
name|logfd
argument_list|,
literal|"%s: date=%20.20s dev=%s level=%c reel=%d ino=%d\n"
argument_list|,
name|tlabel
argument_list|,
name|ctime
argument_list|(
operator|&
name|spcl
operator|.
name|c_date
argument_list|)
operator|+
literal|4
argument_list|,
name|disk
argument_list|,
name|incno
argument_list|,
name|tapeno
argument_list|,
name|tapeno
operator|==
literal|1
condition|?
name|ROOTINO
else|:
name|ino
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|logfd
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	skip forward looking for valid end of label characters  */
end_comment

begin_comment
comment|/* static */
end_comment

begin_function
name|char
modifier|*
name|labskip
parameter_list|(
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|str
operator|!=
literal|','
operator|&&
operator|*
name|str
operator|!=
literal|'-'
operator|&&
operator|*
name|str
condition|)
name|str
operator|++
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	generate a fatal error message  */
end_comment

begin_comment
comment|/* VARARGS1 */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|labfatal
argument_list|(
argument|fmt
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|a4
decl_stmt|,
name|a5
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|msg
argument_list|(
name|fmt
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|)
expr_stmt|;
name|dumpabort
argument_list|()
expr_stmt|;
block|}
end_block

end_unit

