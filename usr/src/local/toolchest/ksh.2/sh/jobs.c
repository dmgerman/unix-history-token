begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|USE_OLD_TTY
end_define

begin_comment
comment|/*   *      Copyright (c) 1984, 1985, 1986 AT&T  *      All Rights Reserved   *      THIS IS UNPUBLISHED PROPRIETARY SOURCE   *      CODE OF AT&T.  *      The copyright notice above does not   *      evidence any actual or intended  *      publication of such source code.   */
end_comment

begin_comment
comment|/* @(#)jobs.c	1.1 */
end_comment

begin_comment
comment|/*  *  Job control for UNIX Shell  *  *   David Korn  *   AT&T Bell Laboratories  *   Room 5D-112  *   Murray Hill, N. J. 07974  *   Tel. x7975  *  *  Written October, 1982  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|BSD_4_2
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD_4_2 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SXT
end_ifdef

begin_define
define|#
directive|define
name|SIGSTOP
value|20
end_define

begin_define
define|#
directive|define
name|SIGSTIN
value|21
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/sxt.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SXT */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"shtype.h"
end_include

begin_include
include|#
directive|include
file|"jobs.h"
end_include

begin_include
include|#
directive|include
file|"brkincr.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SXT
end_ifdef

begin_undef
undef|#
directive|undef
name|input
end_undef

begin_expr_stmt
specifier|static
name|status_update
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|open_chan
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|fd_chan
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|tinybuf
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SXT */
end_comment

begin_define
define|#
directive|define
name|LOBYTE
value|0377
end_define

begin_define
define|#
directive|define
name|MAXMSG
value|25
end_define

begin_function_decl
name|void
name|await
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|postclr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fault
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|hist_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|hist_position
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|itos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|failed
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_str
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_prp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_num
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_sub
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_nchr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_flush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_setout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_ttygrp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_job
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reset_ttygrp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|process
modifier|*
name|next_proc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|process
modifier|*
name|jobbyname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|process
modifier|*
name|job_bynum
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|process
modifier|*
name|job_bypid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|process
modifier|*
name|job_post
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|process
modifier|*
name|unpost
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|process
modifier|*
name|pgrp_jobs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_job
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|match_jobname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unstop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_job
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pw_unlink
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|process
modifier|*
name|freelist
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|numrun
value|jobstat.p_numrun
end_define

begin_comment
comment|/* number of running jobs */
end_comment

begin_define
define|#
directive|define
name|numpost
value|jobstat.p_numpost
end_define

begin_comment
comment|/* number of posted jobs */
end_comment

begin_define
define|#
directive|define
name|pwlist
value|jobstat.p_pwlist
end_define

begin_define
define|#
directive|define
name|freejobs
value|jobstat.p_freejobs
end_define

begin_comment
comment|/* free job numbers */
end_comment

begin_function_decl
specifier|static
name|long
name|pr_jobname
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|FIOLOOKLD
end_ifdef

begin_define
define|#
directive|define
name|version8
value|1
end_define

begin_decl_stmt
specifier|extern
name|int
name|tty_ld
decl_stmt|,
name|ntty_ld
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OTTYDISC
value|tty_ld
end_define

begin_define
define|#
directive|define
name|NTTYDISC
value|ntty_ld
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FIOLOOKLD */
end_comment

begin_decl_stmt
specifier|static
name|int
name|savepgrp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|savetgrp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BOOL
name|old_driver
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BOOL
name|beenhere
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|saveldisc
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|POSIX
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|termios
name|my_stty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminal state for shell */
end_comment

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|my_stty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminal state for shell */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|struct
name|termio
name|my_stty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminal state for shell */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !POSIX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_comment
comment|/*  * initialize job control  * if lflag is set the switching driver message will not print  */
end_comment

begin_function
name|int
name|init_jobs
parameter_list|(
name|lflag
parameter_list|)
block|{
name|int
name|ldisc
decl_stmt|;
specifier|register
name|int
name|ntry
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|pid
decl_stmt|;
name|jobstat
operator|.
name|mypid
operator|=
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|savepgrp
operator|=
name|getpgrp
argument_list|(
name|pid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|version8
if|if
condition|(
operator|(
name|ldisc
operator|=
name|ioctl
argument_list|(
literal|2
argument_list|,
name|FIOLOOKLD
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGETD
argument_list|,
operator|&
name|ldisc
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
comment|/* version8 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ldisc
operator|!=
name|NTTYDISC
ifdef|#
directive|ifdef
name|notdef
comment|/*POSIX*/
operator|&&
name|ldisc
operator|!=
name|POSXDISC
endif|#
directive|endif
operator|&&
name|ldisc
operator|!=
name|OTTYDISC
condition|)
block|{
comment|/* no job control when running with MPX */
ifdef|#
directive|ifdef
name|VSH
name|on_option
argument_list|(
name|VIRAW
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VSH */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|retry
label|:
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGPGRP
argument_list|,
operator|&
name|savetgrp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fputs
argument_list|(
name|j_not_tty
argument_list|,
name|output
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* This shell must be in foreground to change state */
if|if
condition|(
name|savetgrp
operator|!=
name|savepgrp
condition|)
block|{
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGTTOU
argument_list|)
expr_stmt|;
comment|/* wait for continue and try again */
if|if
condition|(
name|ntry
operator|++
operator|>
literal|100
condition|)
block|{
name|fputs
argument_list|(
name|j_no_start
argument_list|,
name|output
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
goto|goto
name|retry
goto|;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/*POSIX*/
if|if
condition|(
name|ldisc
operator|!=
name|POSXDISC
condition|)
block|{
name|saveldisc
operator|=
name|ldisc
expr_stmt|;
name|ldisc
operator|=
name|POSXDISC
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ldisc
operator|==
name|OTTYDISC
condition|)
block|{
name|ldisc
operator|=
name|NTTYDISC
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|version8
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|my_stty
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|FIOPOPLD
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|FIOPUSHLD
argument_list|,
operator|&
name|ldisc
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ldisc
operator|=
name|OTTYDISC
expr_stmt|;
name|ioctl
argument_list|(
literal|2
argument_list|,
name|FIOPUSHLD
argument_list|,
operator|&
name|ldisc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|my_stty
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSETD
argument_list|,
operator|&
name|ldisc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* version8 */
if|if
condition|(
name|lflag
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
name|j_newtty
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|old_driver
operator|++
expr_stmt|;
block|}
block|}
name|on_option
argument_list|(
name|MONITOR
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|fault
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|setpgrp
argument_list|(
name|pid
argument_list|,
name|pid
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fputs
argument_list|(
name|j_no_start
argument_list|,
name|output
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|set_ttygrp
argument_list|(
name|pid
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setpgrp
argument_list|(
name|pid
argument_list|,
name|savepgrp
argument_list|)
expr_stmt|;
comment|/* screwed if this fails */
name|fputs
argument_list|(
name|j_no_start
argument_list|,
name|output
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * see if there are any stopped jobs  * restore tty driver and pgrp  */
name|int
name|close_jobs
parameter_list|()
block|{
specifier|register
name|struct
name|process
modifier|*
name|pw
init|=
name|pwlist
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|ldisc
decl_stmt|;
if|if
condition|(
operator|(
name|states
operator|&
name|MONITOR
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
init|;
name|pw
condition|;
name|pw
operator|=
name|pw
operator|->
name|p_next
control|)
block|{
if|if
condition|(
operator|(
name|pw
operator|->
name|p_flag
operator|&
name|P_STOPPED
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|beenhere
condition|)
name|killpg
argument_list|(
name|pw
operator|->
name|p_pgrp
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|beenhere
operator|++
operator|==
literal|0
operator|&&
name|pwlist
condition|)
block|{
if|if
condition|(
name|count
condition|)
block|{
name|fputs
argument_list|(
name|j_terminate
argument_list|,
name|output
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|login_sh
condition|)
block|{
name|fputs
argument_list|(
name|j_running
argument_list|,
name|output
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|set_ttygrp
argument_list|(
name|savepgrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_driver
condition|)
block|{
comment|/* restore old line discipline */
ifdef|#
directive|ifdef
name|POSIX
name|ldisc
operator|=
name|saveldisc
expr_stmt|;
else|#
directive|else
name|ldisc
operator|=
name|OTTYDISC
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|version8
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|my_stty
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|FIOPOPLD
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|FIOPUSHLD
argument_list|,
operator|&
name|ldisc
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ldisc
operator|=
name|NTTYDISC
expr_stmt|;
name|ioctl
argument_list|(
literal|2
argument_list|,
name|FIOPUSHLD
argument_list|,
operator|&
name|ldisc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|my_stty
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSETD
argument_list|,
operator|&
name|ldisc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* version8 */
name|fputs
argument_list|(
name|j_oldtty
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Set the ttygroup id to pid  */
specifier|static
name|int
name|set_ttygrp
parameter_list|(
name|pid
parameter_list|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|&
name|pid
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Set the ttygroup id to a previously running job  */
else|#
directive|else
comment|/* !BSD */
ifdef|#
directive|ifdef
name|SXT
specifier|static
name|char
name|sxt
index|[]
init|=
literal|"/dev/sxt/000"
decl_stmt|;
specifier|static
name|struct
name|sxtblock
name|status1
decl_stmt|,
name|status2
decl_stmt|;
name|int
name|init_jobs
parameter_list|(
name|lflag
parameter_list|)
block|{
specifier|register
name|int
name|pid
decl_stmt|;
specifier|register
name|int
name|dev
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|jobstat
operator|.
name|mypid
operator|=
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|savepgrp
operator|=
name|getpgrp
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|SXTIOCSTAT
argument_list|,
operator|&
name|status2
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|my_stty
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|fstat
argument_list|(
literal|2
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|dev
operator|=
name|statbuf
operator|.
name|st_rdev
operator|&
literal|0xff
expr_stmt|;
comment|/* must be channel 0 */
if|if
condition|(
name|dev
operator|&
literal|07
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|dev
operator|>>=
literal|3
expr_stmt|;
name|sxt
index|[
literal|10
index|]
operator|=
literal|'0'
operator|+
operator|(
name|dev
operator|%
literal|10
operator|)
expr_stmt|;
name|sxt
index|[
literal|9
index|]
operator|=
literal|'0'
operator|+
name|dev
operator|/
literal|10
expr_stmt|;
name|my_stty
operator|.
name|c_cc
index|[
name|VSWTCH
index|]
operator|=
name|CSWTCH
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TCSETAF
argument_list|,
operator|&
name|my_stty
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|setpgrp
argument_list|(
name|pid
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|jobstat
operator|.
name|maxjob
operator|=
name|MAXPCHAN
expr_stmt|;
name|on_option
argument_list|(
name|MONITOR
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* SXT */
name|int
name|close_jobs
parameter_list|()
block|{
specifier|register
name|struct
name|process
modifier|*
name|pw
init|=
name|pwlist
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|states
operator|&
name|MONITOR
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|SXT
for|for
control|(
init|;
name|pw
condition|;
name|pw
operator|=
name|pw
operator|->
name|p_next
control|)
block|{
if|if
condition|(
operator|(
name|pw
operator|->
name|p_flag
operator|&
name|P_STOPPED
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|beenhere
condition|)
name|kill
argument_list|(
operator|-
name|pw
operator|->
name|p_pgrp
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SXT */
if|if
condition|(
name|beenhere
operator|++
operator|==
literal|0
operator|&&
name|pwlist
operator|&&
name|login_sh
condition|)
ifdef|#
directive|ifdef
name|SXT
block|{
if|if
condition|(
name|count
condition|)
block|{
name|fputs
argument_list|(
name|j_terminate
argument_list|,
name|output
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|login_sh
operator|||
name|jobstat
operator|.
name|maxjob
condition|)
endif|#
directive|endif
comment|/* SXT */
block|{
name|fputs
argument_list|(
name|j_running
argument_list|,
name|output
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SXT
block|}
if|if
condition|(
name|jobstat
operator|.
name|maxjob
condition|)
name|kill_all
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SXT */
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* !BSD */
specifier|static
name|int
name|set_job
parameter_list|(
name|pw
parameter_list|)
specifier|register
name|struct
name|process
modifier|*
name|pw
decl_stmt|;
block|{
comment|/* save current terminal state */
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|POSIX
argument_list|)
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|my_stty
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|my_stty
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
ifdef|#
directive|ifdef
name|SXT
comment|/* make sure child has opened channel */
if|if
condition|(
name|jobstat
operator|.
name|pipe
index|[
literal|0
index|]
operator|>
literal|0
condition|)
block|{
name|read
argument_list|(
name|jobstat
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|tinybuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|jobstat
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|jobstat
operator|.
name|pipe
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pw
operator|->
name|p_job
operator|<
name|jobstat
operator|.
name|maxjob
condition|)
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|SXTIOCSWTCH
argument_list|,
name|pw
operator|->
name|p_job
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* SXT */
if|if
condition|(
name|pw
operator|->
name|p_flag
operator|&
name|P_STTY
condition|)
block|{
comment|/* restore terminal state for job */
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|POSIX
argument_list|)
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|pw
operator|->
name|p_stty
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TCSETAF
argument_list|,
operator|&
name|pw
operator|->
name|p_stty
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
block|}
ifdef|#
directive|ifdef
name|BSD
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|&
name|pw
operator|->
name|p_pgrp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* BSD */
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|reset_ttygrp
parameter_list|(
name|pw
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|struct
name|process
modifier|*
name|pw
decl_stmt|;
block|{
comment|/* save the terminal state for current job */
ifdef|#
directive|ifdef
name|BSD
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|&
name|jobstat
operator|.
name|mypid
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* BSD */
ifdef|#
directive|ifdef
name|SXT
if|if
condition|(
name|pw
operator|&&
name|pw
operator|->
name|p_job
operator|<
name|jobstat
operator|.
name|maxjob
condition|)
block|{
comment|/* save the state of terminated process */
if|if
condition|(
name|flag
operator|==
literal|0
operator|&&
name|fd_chan
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|fd_chan
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|pw
operator|->
name|p_stty
argument_list|)
operator|==
literal|0
condition|)
block|{
name|my_stty
operator|=
name|pw
operator|->
name|p_stty
expr_stmt|;
comment|/* for timing problem */
name|ioctl
argument_list|(
name|fd_chan
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|my_stty
argument_list|)
expr_stmt|;
block|}
block|}
name|close
argument_list|(
name|fd_chan
argument_list|)
expr_stmt|;
name|fd_chan
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* grab control in channel 0 */
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|my_stty
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|SXTIOCSWTCH
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|my_stty
argument_list|)
expr_stmt|;
name|beenhere
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* SXT */
if|if
condition|(
name|pw
operator|&&
name|flag
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|POSIX
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|pw
operator|->
name|p_stty
argument_list|)
operator|==
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|pw
operator|->
name|p_stty
argument_list|)
operator|==
literal|0
condition|)
endif|#
directive|endif
comment|/* BSD */
name|pw
operator|->
name|p_flag
operator||=
name|P_STTY
expr_stmt|;
comment|/* restore terminal state for job */
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|POSIX
argument_list|)
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|my_stty
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TCSETAF
argument_list|,
operator|&
name|my_stty
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
block|}
name|beenhere
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|#
directive|if
name|BSD
operator|||
name|SXT
comment|/*  * move job to foreground if bgflag == 0  * move job to background if bgflag != 0  */
name|switch_jobs
argument_list|(
name|ajob
argument_list|,
name|bgflag
argument_list|)
specifier|register
name|char
operator|*
name|ajob
expr_stmt|;
block|{
specifier|register
name|struct
name|process
modifier|*
name|pw
init|=
name|NULL
decl_stmt|;
specifier|register
name|int
name|pgrp
decl_stmt|;
ifdef|#
directive|ifdef
name|SXT
if|if
condition|(
name|jobstat
operator|.
name|maxjob
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
endif|#
directive|endif
comment|/* SXT */
if|if
condition|(
operator|*
name|ajob
condition|)
name|pw
operator|=
name|pgrp_jobs
argument_list|(
name|ajob
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pwlist
condition|)
name|pw
operator|=
name|job_bynum
argument_list|(
operator|(
name|int
operator|)
name|pwlist
operator|->
name|p_job
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
condition|)
block|{
if|if
condition|(
name|bgflag
condition|)
block|{
name|pgrp
operator|=
name|pw
operator|->
name|p_pgrp
expr_stmt|;
if|if
condition|(
name|pw
operator|->
name|p_flag
operator|&
name|P_STOPPED
condition|)
block|{
name|p_sub
argument_list|(
operator|(
name|int
operator|)
name|pw
operator|->
name|p_job
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|pr_jobname
argument_list|(
name|pw
argument_list|,
literal|'&'
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|j_amp
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|unstop
argument_list|(
name|pgrp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pw_unlink
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|pw
operator|->
name|p_next
operator|=
name|pwlist
expr_stmt|;
name|pwlist
operator|=
name|pw
expr_stmt|;
name|pr_jobname
argument_list|(
name|pw
argument_list|,
literal|'&'
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|await
argument_list|(
name|pw
operator|->
name|p_pid
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|pw
operator|!=
name|NULL
operator|)
return|;
block|}
comment|/*  * list the current jobs  * flag L_FLAG for long listing  * flag N_FLAG for list only jobs marked for notification  */
endif|#
directive|endif
comment|/* BSD */
name|list_jobs
argument_list|(
argument|flag
argument_list|)
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|process
modifier|*
name|pw
decl_stmt|;
specifier|register
name|struct
name|process
modifier|*
name|px
decl_stmt|;
specifier|register
name|int
name|m
decl_stmt|;
specifier|register
name|struct
name|process
modifier|*
name|py
decl_stmt|;
name|int
name|n
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|int
name|jobm
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|msize
decl_stmt|;
if|if
condition|(
name|pwlist
operator|==
name|NULL
condition|)
return|return;
name|await
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|p_setout
argument_list|(
name|standout
argument_list|)
expr_stmt|;
comment|/* get job number corresponding to '-' */
if|if
condition|(
name|pw
operator|=
name|pgrp_jobs
argument_list|(
literal|"%-"
argument_list|)
condition|)
name|jobm
operator|=
name|pw
operator|->
name|p_job
expr_stmt|;
for|for
control|(
name|pw
operator|=
name|pwlist
init|;
name|pw
condition|;
name|pw
operator|=
name|py
control|)
block|{
name|py
operator|=
name|pw
operator|->
name|p_next
expr_stmt|;
if|if
condition|(
name|pw
operator|->
name|p_flag
operator|&
name|P_PIPEJOB
condition|)
continue|continue;
if|if
condition|(
operator|(
name|flag
operator|&
name|N_FLAG
operator|)
operator|&&
operator|(
name|pw
operator|->
name|p_flag
operator|&
name|P_NOTIFY
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|n
operator|=
name|pw
operator|->
name|p_job
expr_stmt|;
name|p_sub
argument_list|(
name|n
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|m
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|pw
operator|->
name|p_job
operator|==
name|pwlist
operator|->
name|p_job
condition|)
name|m
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|pw
operator|->
name|p_job
operator|==
name|jobm
condition|)
block|{
name|m
operator|=
literal|'-'
expr_stmt|;
name|jobm
operator|=
literal|0
expr_stmt|;
block|}
name|putc
argument_list|(
name|m
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|L_FLAG
condition|)
name|px
operator|=
name|next_proc
argument_list|(
name|pwlist
argument_list|,
operator|(
name|int
operator|)
name|pw
operator|->
name|p_job
argument_list|)
expr_stmt|;
else|else
name|px
operator|=
name|pw
expr_stmt|;
do|do
block|{
name|unsigned
name|xitval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flag
operator|&
name|L_FLAG
condition|)
name|p_num
argument_list|(
name|px
operator|->
name|p_pid
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|px
operator|->
name|p_sig
operator|&
literal|0177
condition|)
name|msg
operator|=
name|sysmsg
index|[
name|px
operator|->
name|p_sig
operator|&
literal|0177
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|px
operator|->
name|p_flag
operator|&
name|P_NOTIFY
condition|)
block|{
name|msg
operator|=
name|j_Done
expr_stmt|;
name|xitval
operator|=
name|px
operator|->
name|p_sig
operator|>>
literal|8
expr_stmt|;
block|}
else|else
name|msg
operator|=
name|j_Running
expr_stmt|;
name|fputs
argument_list|(
name|msg
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|msize
operator|=
name|strlen
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|xitval
condition|)
block|{
name|putc
argument_list|(
literal|'('
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|p_num
argument_list|(
operator|(
name|int
operator|)
name|xitval
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
name|msize
operator|+=
operator|(
literal|3
operator|+
operator|(
name|xitval
operator|>
literal|10
operator|)
operator|+
operator|(
name|xitval
operator|>
literal|100
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|px
operator|->
name|p_flag
operator|&
name|P_COREDUMP
condition|)
block|{
name|fputs
argument_list|(
name|j_coredump
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|msize
operator|+=
name|strlen
argument_list|(
name|j_coredump
argument_list|)
expr_stmt|;
block|}
name|p_nchr
argument_list|(
name|SP
argument_list|,
name|MAXMSG
operator|-
name|msize
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|L_FLAG
condition|)
name|px
operator|=
name|next_proc
argument_list|(
name|px
operator|->
name|p_next
argument_list|,
operator|(
name|int
operator|)
name|pw
operator|->
name|p_job
argument_list|)
expr_stmt|;
else|else
name|px
operator|=
name|NULL
expr_stmt|;
name|offset
operator|=
name|pr_jobname
argument_list|(
name|pw
argument_list|,
operator|(
name|px
condition|?
literal|'|'
else|:
literal|0
operator|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|L_FLAG
condition|)
block|{
if|if
condition|(
name|px
condition|)
name|fputs
argument_list|(
name|j_space
argument_list|,
name|output
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pw
operator|->
name|p_pid
operator|==
name|cpid
condition|)
name|fputs
argument_list|(
name|j_cpid
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|px
condition|)
do|;
if|if
condition|(
name|pw
operator|->
name|p_flag
operator|&
name|P_STOPPED
condition|)
name|pw
operator|->
name|p_flag
operator|&=
operator|~
name|P_NOTIFY
expr_stmt|;
elseif|else
if|if
condition|(
name|pw
operator|->
name|p_flag
operator|&
name|P_NOTIFY
condition|)
block|{
name|unpost
argument_list|(
name|pw
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobm
operator|&&
operator|(
name|px
operator|=
name|pgrp_jobs
argument_list|(
literal|"%-"
argument_list|)
operator|)
condition|)
name|jobm
operator|=
name|px
operator|->
name|p_job
expr_stmt|;
block|}
block|}
block|}
comment|/*  * return the pointer of next process with given job number after slot px  */
specifier|static
name|struct
name|process
modifier|*
name|next_proc
parameter_list|(
name|pw
parameter_list|,
name|job
parameter_list|)
specifier|register
name|struct
name|process
modifier|*
name|pw
decl_stmt|;
specifier|register
name|int
name|job
decl_stmt|;
block|{
for|for
control|(
init|;
name|pw
condition|;
name|pw
operator|=
name|pw
operator|->
name|p_next
control|)
block|{
if|if
condition|(
name|pw
operator|->
name|p_job
operator|==
name|job
condition|)
return|return
operator|(
name|pw
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*  * print the command  * Stop the output if character<ch> encountered  */
specifier|static
name|long
name|pr_jobname
parameter_list|(
name|pw
parameter_list|,
name|ch
parameter_list|,
name|offset
parameter_list|)
specifier|register
name|struct
name|process
modifier|*
name|pw
decl_stmt|;
specifier|register
name|long
name|offset
decl_stmt|;
name|int
name|ch
decl_stmt|;
block|{
if|if
condition|(
name|fc_fix
condition|)
block|{
name|offset
operator|=
name|hist_list
argument_list|(
name|pw
operator|->
name|p_name
operator|+
name|offset
argument_list|,
name|ch
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
name|offset
operator|-=
name|pw
operator|->
name|p_name
expr_stmt|;
block|}
return|return
operator|(
operator|++
name|offset
operator|)
return|;
block|}
comment|/*  * get the process group given the job number  * This routine returns the process group number or -1  */
specifier|static
name|struct
name|process
modifier|*
name|pgrp_jobs
parameter_list|(
name|ajob
parameter_list|)
specifier|register
name|char
modifier|*
name|ajob
decl_stmt|;
block|{
specifier|register
name|struct
name|process
modifier|*
name|pw
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|ajob
operator|++
operator|!=
literal|'%'
operator|||
name|pwlist
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|c
operator|=
operator|*
name|ajob
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|pw
operator|=
name|job_bynum
argument_list|(
name|atoi
argument_list|(
name|ajob
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'%'
condition|)
name|pw
operator|=
name|job_bynum
argument_list|(
operator|(
name|int
operator|)
name|pwlist
operator|->
name|p_job
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
comment|/* find the second jobnumber on the list */
for|for
control|(
name|pw
operator|=
name|pwlist
operator|->
name|p_next
init|;
name|pw
operator|&&
name|pw
operator|->
name|p_job
operator|==
name|pwlist
operator|->
name|p_job
condition|;
name|pw
operator|=
name|pw
operator|->
name|p_next
control|)
empty_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
return|return
operator|(
name|pw
operator|)
return|;
name|pw
operator|=
name|job_bynum
argument_list|(
operator|(
name|int
operator|)
name|pw
operator|->
name|p_job
argument_list|)
expr_stmt|;
block|}
else|else
name|pw
operator|=
name|jobbyname
argument_list|(
name|ajob
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|&&
name|pw
operator|->
name|p_flag
condition|)
return|return
operator|(
name|pw
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*  * send a hang-up signal to each of the jobs  */
name|int
name|kill_all
parameter_list|()
block|{
specifier|register
name|struct
name|process
modifier|*
name|pw
init|=
name|pwlist
decl_stmt|;
for|for
control|(
init|;
name|pw
condition|;
name|pw
operator|=
name|pw
operator|->
name|p_next
control|)
block|{
if|if
condition|(
name|pw
operator|->
name|p_pgrp
operator|==
name|pw
operator|->
name|p_pid
condition|)
block|{
ifdef|#
directive|ifdef
name|BSD
name|unstop
argument_list|(
name|pw
operator|->
name|p_pgrp
argument_list|)
expr_stmt|;
name|killpg
argument_list|(
name|pw
operator|->
name|p_pgrp
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
else|#
directive|else
name|kill
argument_list|(
operator|-
name|pw
operator|->
name|p_pgrp
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
block|}
block|}
block|}
comment|/*  * Kill a job or process  */
name|int
name|job_kill
parameter_list|(
name|job
parameter_list|,
name|sig
parameter_list|)
specifier|register
name|char
modifier|*
name|job
decl_stmt|;
name|int
name|sig
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|rjob
init|=
name|job
decl_stmt|;
specifier|register
name|struct
name|process
modifier|*
name|pw
decl_stmt|;
specifier|register
name|int
name|pid
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
operator|*
name|rjob
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|pw
operator|=
name|pgrp_jobs
argument_list|(
name|rjob
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|BSD
name|r
operator|=
name|unstop
argument_list|(
name|pw
operator|->
name|p_pgrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|!=
name|SIGCONT
operator|||
name|r
operator|<
literal|0
condition|)
name|r
operator|=
name|killpg
argument_list|(
name|pw
operator|->
name|p_pgrp
argument_list|,
name|sig
argument_list|)
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|pw
operator|->
name|p_pgrp
expr_stmt|;
if|if
condition|(
name|states
operator|&
name|MONITOR
condition|)
name|pid
operator|=
operator|-
name|pid
expr_stmt|;
name|r
operator|=
name|kill
argument_list|(
name|pid
argument_list|,
name|sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
block|}
else|else
block|{
name|r
operator|=
operator|-
literal|1
expr_stmt|;
name|errno
operator|=
name|ESRCH
expr_stmt|;
block|}
block|}
else|else
block|{
name|pid
operator|=
name|atoi
argument_list|(
name|rjob
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
operator|&&
operator|*
name|rjob
operator|!=
literal|'0'
condition|)
name|failed
argument_list|(
name|bkill
argument_list|,
name|kill_usage
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD
if|if
condition|(
name|sig
operator|==
name|SIGSTOP
operator|&&
name|pid
operator|==
name|jobstat
operator|.
name|mypid
operator|&&
operator|(
name|login_sh
operator|||
name|ppid
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* can't stop login shell */
name|errno
operator|=
name|EPERM
expr_stmt|;
name|r
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|pw
operator|=
name|job_bypid
argument_list|(
name|pid
argument_list|)
operator|)
operator|&&
operator|(
name|pw
operator|->
name|p_flag
operator|&
name|P_STOPPED
operator|)
condition|)
block|{
name|pw
operator|->
name|p_flag
operator|&=
operator|~
name|P_STOPPED
expr_stmt|;
name|numrun
operator|++
expr_stmt|;
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|kill
argument_list|(
name|pid
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|r
operator|=
name|kill
argument_list|(
name|pid
argument_list|,
name|sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD */
block|}
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|p_setout
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|j_kill
argument_list|,
name|output
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|rjob
operator|==
literal|'%'
condition|)
name|msg
operator|=
name|j_no_job
expr_stmt|;
else|else
name|msg
operator|=
name|j_no_proc
expr_stmt|;
name|p_str
argument_list|(
name|rjob
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EPERM
condition|)
name|msg
operator|=
name|j_perm
expr_stmt|;
name|p_str
argument_list|(
name|msg
argument_list|,
name|NL
argument_list|)
expr_stmt|;
name|r
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/*  * Get process structure from job number  */
specifier|static
name|struct
name|process
modifier|*
name|job_bynum
parameter_list|(
name|num
parameter_list|)
specifier|register
name|int
name|num
decl_stmt|;
block|{
specifier|register
name|struct
name|process
modifier|*
name|pw
init|=
name|pwlist
decl_stmt|;
for|for
control|(
init|;
name|pw
condition|;
name|pw
operator|=
name|pw
operator|->
name|p_next
control|)
block|{
if|if
condition|(
operator|(
name|pw
operator|->
name|p_flag
operator|&
operator|(
name|P_PIPEJOB
operator||
name|P_WAITED
operator|)
operator|)
operator|==
name|P_PIPEJOB
condition|)
continue|continue;
if|if
condition|(
name|pw
operator|->
name|p_job
operator|==
name|num
condition|)
return|return
operator|(
name|pw
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*  * Get process structure from first letters of jobname  *  */
specifier|static
name|struct
name|process
modifier|*
name|jobbyname
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|process
modifier|*
name|pw
init|=
name|pwlist
decl_stmt|;
specifier|register
name|struct
name|fixcmd
modifier|*
name|fp
init|=
name|fc_fix
decl_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
init|;
name|pw
condition|;
name|pw
operator|=
name|pw
operator|->
name|p_next
control|)
block|{
if|if
condition|(
operator|(
name|pw
operator|->
name|p_flag
operator|&
operator|(
name|P_PIPEJOB
operator||
name|P_WAITED
operator|)
operator|)
operator|==
name|P_PIPEJOB
condition|)
continue|continue;
if|if
condition|(
name|match_jobname
argument_list|(
name|fp
operator|->
name|fixfd
argument_list|,
name|pw
argument_list|,
name|name
argument_list|)
condition|)
goto|goto
name|retrn
goto|;
block|}
name|pw
operator|=
name|NULL
expr_stmt|;
name|retrn
label|:
return|return
operator|(
name|pw
operator|)
return|;
block|}
comment|/*  * match the name to the command starting with given name  */
specifier|static
name|int
name|match_jobname
parameter_list|(
name|fdi
parameter_list|,
name|pw
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|fdi
decl_stmt|;
specifier|register
name|struct
name|process
modifier|*
name|pw
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|fdi
operator|&&
name|pw
operator|->
name|p_name
operator|>
literal|0
condition|)
block|{
name|fseek
argument_list|(
name|fdi
argument_list|,
name|pw
operator|->
name|p_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|name
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fdi
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
operator|*
name|sp
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Initialize the process posting array  */
name|void
name|postclr
parameter_list|()
block|{
specifier|register
name|struct
name|process
modifier|*
name|pw
init|=
name|pwlist
decl_stmt|;
specifier|register
name|struct
name|process
modifier|*
name|px
decl_stmt|;
specifier|register
name|int
name|j
init|=
name|JBYTES
decl_stmt|;
for|for
control|(
init|;
name|pw
condition|;
name|pw
operator|=
name|px
control|)
block|{
name|px
operator|=
name|pw
operator|->
name|p_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pw
argument_list|)
expr_stmt|;
block|}
name|pwlist
operator|=
name|NULL
expr_stmt|;
name|numpost
operator|=
literal|0
expr_stmt|;
name|numrun
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
name|freejobs
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  * put the process<pcsid> on the process list and return the job number  * turn on the specified flag bits.  */
name|int
name|post
parameter_list|(
name|pid
parameter_list|,
name|flag
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
specifier|register
name|struct
name|process
modifier|*
name|pw
decl_stmt|;
if|if
condition|(
name|pw
operator|=
name|job_post
argument_list|(
name|pid
argument_list|)
condition|)
block|{
name|pw
operator|->
name|p_flag
operator||=
name|flag
expr_stmt|;
return|return
operator|(
name|pw
operator|->
name|p_job
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  * internal version of post, this routine returns a process structure  */
specifier|static
name|struct
name|process
modifier|*
name|job_post
parameter_list|(
name|pcsid
parameter_list|)
name|int
name|pcsid
decl_stmt|;
block|{
specifier|register
name|struct
name|process
modifier|*
name|pw
init|=
name|pwlist
decl_stmt|;
specifier|register
name|struct
name|process
modifier|*
name|px
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|fixcmd
modifier|*
name|fp
init|=
name|fc_fix
decl_stmt|;
if|if
condition|(
name|pcsid
condition|)
block|{
for|for
control|(
init|;
name|pw
condition|;
name|pw
operator|=
name|pw
operator|->
name|p_next
control|)
block|{
if|if
condition|(
name|pw
operator|->
name|p_pid
operator|==
name|pcsid
condition|)
return|return
operator|(
name|pw
operator|)
return|;
if|if
condition|(
name|pw
operator|->
name|p_pgrp
operator|==
name|jobstat
operator|.
name|cur_pgrp
condition|)
name|px
operator|=
name|pw
expr_stmt|;
block|}
if|if
condition|(
name|pw
operator|=
name|freelist
condition|)
name|freelist
operator|=
name|pw
operator|->
name|p_next
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pw
operator|=
operator|(
expr|struct
name|process
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|process
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|nospace
argument_list|)
expr_stmt|;
name|numrun
operator|++
expr_stmt|;
name|numpost
operator|++
expr_stmt|;
if|if
condition|(
name|px
condition|)
block|{
name|pw
operator|->
name|p_next
operator|=
name|px
operator|->
name|p_next
expr_stmt|;
name|px
operator|->
name|p_next
operator|=
name|pw
expr_stmt|;
name|pw
operator|->
name|p_job
operator|=
name|px
operator|->
name|p_job
expr_stmt|;
block|}
else|else
block|{
comment|/* put at front of list */
name|pw
operator|->
name|p_next
operator|=
name|pwlist
expr_stmt|;
name|pw
operator|->
name|p_job
operator|=
name|get_job
argument_list|()
expr_stmt|;
name|pwlist
operator|=
name|pw
expr_stmt|;
block|}
name|pw
operator|->
name|p_pid
operator|=
name|pcsid
expr_stmt|;
name|pw
operator|->
name|p_flag
operator|=
name|P_RUNNING
expr_stmt|;
name|pw
operator|->
name|p_pgrp
operator|=
name|jobstat
operator|.
name|cur_pgrp
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
name|pw
operator|->
name|p_name
operator|=
name|hist_position
argument_list|(
name|fp
operator|->
name|fixind
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|pw
operator|->
name|p_name
operator|=
operator|-
literal|1
expr_stmt|;
name|pw
operator|->
name|p_sig
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|numpost
operator|>=
name|MAXJ
operator|-
literal|1
condition|)
name|await
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|pw
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*  * get job number given the process id  */
specifier|static
name|struct
name|process
modifier|*
name|job_bypid
parameter_list|(
name|pid
parameter_list|)
specifier|register
name|int
name|pid
decl_stmt|;
block|{
specifier|register
name|struct
name|process
modifier|*
name|pw
decl_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|pw
operator|=
name|pwlist
init|;
name|pw
condition|;
name|pw
operator|=
name|pw
operator|->
name|p_next
control|)
if|if
condition|(
name|pw
operator|->
name|p_pid
operator|==
name|pid
condition|)
break|break;
return|return
operator|(
name|pw
operator|)
return|;
block|}
comment|/*  * Wait for process i to complete  * flag=1 when wait builtin invoked so that it can be interrupted  * flag=2 to check for waiting processes and return  * flag=3 to resume job in foreground  * i=0 to wait for any process  * i=-1 to wait for all runing processes  */
name|void
name|await
parameter_list|(
name|i
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|w
decl_stmt|;
name|int
name|my_job
init|=
operator|-
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD
name|union
name|wait
name|wstat
decl_stmt|;
endif|#
directive|endif
comment|/* BSD */
specifier|register
name|struct
name|process
modifier|*
name|pw
init|=
name|NULL
decl_stmt|;
name|struct
name|process
modifier|*
name|px
decl_stmt|;
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
operator|&&
name|i
condition|)
block|{
if|if
condition|(
name|flag
condition|)
block|{
name|pw
operator|=
name|job_bypid
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
literal|3
operator|&&
name|pw
condition|)
name|flag
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|pw
operator|=
name|job_post
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
if|if
condition|(
name|pw
operator|==
literal|0
operator|||
operator|(
name|pw
operator|->
name|p_flag
operator|&
name|P_STOPPED
operator|)
condition|)
return|return;
block|}
name|my_job
operator|=
name|pw
operator|->
name|p_job
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|==
literal|0
operator|&&
operator|(
name|states
operator|&
name|MONITOR
operator|)
operator|&&
name|pw
condition|)
block|{
name|set_job
argument_list|(
name|pw
argument_list|)
expr_stmt|;
comment|/* if job is stopped, resume it in the background */
if|#
directive|if
name|BSD
operator|||
name|SXT
if|if
condition|(
name|pw
operator|->
name|p_flag
operator|&
name|P_STOPPED
condition|)
name|unstop
argument_list|(
name|pw
operator|->
name|p_pgrp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SXT
if|if
condition|(
name|pw
operator|->
name|p_job
operator|<
name|jobstat
operator|.
name|maxjob
condition|)
name|open_chan
argument_list|(
name|pw
operator|->
name|p_job
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SXT */
endif|#
directive|endif
comment|/* BSD */
block|}
name|p_flush
argument_list|()
expr_stmt|;
while|while
condition|(
name|numrun
operator|>
literal|0
condition|)
block|{
specifier|register
name|int
name|p
decl_stmt|;
specifier|register
name|int
name|sig
decl_stmt|;
specifier|register
name|int
name|w_hi
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD
if|if
condition|(
name|is_option
argument_list|(
name|MONITOR
argument_list|)
operator|||
name|flag
operator|==
literal|2
condition|)
block|{
name|retry
label|:
name|errno
operator|=
literal|0
expr_stmt|;
name|sig
operator|=
name|sighold
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
name|trapnote
operator|&=
operator|~
name|SIGJOBS
expr_stmt|;
name|p
operator|=
name|wait3
argument_list|(
operator|&
name|wstat
argument_list|,
name|WNOHANG
operator||
name|WUNTRACED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
operator|&&
name|flag
operator|!=
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|BSD_4_2
name|sigpause
argument_list|(
name|sig
operator|&
operator|~
operator|(
literal|1
operator|<<
operator|(
name|SIGCHLD
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|sigpause
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD_4_2 */
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|&&
name|flag
operator|==
literal|1
operator|&&
operator|(
name|trapnote
operator|&
name|SIGJOBS
operator|)
operator|==
literal|0
condition|)
break|break;
goto|goto
name|retry
goto|;
block|}
name|trapnote
operator|&=
operator|~
name|SIGJOBS
expr_stmt|;
name|sigrelse
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
operator|||
name|p
operator|==
operator|-
literal|1
condition|)
return|return;
name|w
operator|=
name|wstat
operator|.
name|w_status
expr_stmt|;
name|pw
operator|=
name|job_bypid
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|->
name|p_job
operator|==
name|my_job
operator|&&
operator|(
name|states
operator|&
name|MONITOR
operator|)
condition|)
block|{
specifier|register
name|int
name|ssig
init|=
name|wstat
operator|.
name|w_S
operator|.
name|w_Stopsig
decl_stmt|;
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|wstat
argument_list|)
operator|&&
operator|(
name|ssig
operator|==
name|SIGTTIN
operator|||
name|ssig
operator|==
name|SIGTTOU
operator|)
condition|)
block|{
comment|/* job stopped before it got terminal */
name|killpg
argument_list|(
name|pw
operator|->
name|p_pgrp
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p
operator|==
name|i
condition|)
name|reset_ttygrp
argument_list|(
name|pw
argument_list|,
name|w
operator|&
name|LOBYTE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* BSD */
block|{
ifndef|#
directive|ifndef
name|BSD
ifdef|#
directive|ifdef
name|SXT
if|if
condition|(
name|jobstat
operator|.
name|maxjob
operator|>
literal|0
condition|)
block|{
comment|/* check for job status change */
name|status1
operator|=
name|status2
expr_stmt|;
name|status2
operator|.
name|input
operator|=
name|status2
operator|.
name|output
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|SXTIOCSTAT
argument_list|,
operator|&
name|status2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|jobstat
operator|.
name|maxjob
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status1
operator|.
name|input
operator|!=
name|status2
operator|.
name|input
condition|)
block|{
name|status_update
argument_list|(
name|status2
operator|.
name|input
argument_list|,
name|status1
operator|.
name|input
argument_list|,
name|SIGSTIN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status1
operator|.
name|output
operator|!=
name|status2
operator|.
name|output
condition|)
block|{
name|status_update
argument_list|(
name|status2
operator|.
name|output
argument_list|,
name|status1
operator|.
name|output
argument_list|,
name|SIGSTOP
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SXT */
comment|/* enable fault handler to see if there are any pending jobs */
if|if
condition|(
operator|(
name|trapnote
operator|&
name|SIGJOBS
operator|)
operator|==
literal|0
condition|)
name|signal
argument_list|(
name|SIGCLD
argument_list|,
name|fault
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
literal|2
operator|&&
operator|(
name|trapnote
operator|&
name|SIGJOBS
operator|)
operator|==
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|SXT
if|if
condition|(
name|my_job
operator|>=
literal|0
operator|&&
operator|(
name|trapnote
operator|&
name|SIGJOBS
operator|)
operator|==
literal|0
operator|&&
name|jobstat
operator|.
name|maxjob
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|ioctl
argument_list|(
literal|2
argument_list|,
name|SXTIOCWF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
comment|/* job stopped */
block|{
name|ioctl
argument_list|(
literal|2
argument_list|,
name|SXTIOCBLK
argument_list|,
name|my_job
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd_chan
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|fd_chan
argument_list|,
name|TCFLSH
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
empty_stmt|;
block|}
block|}
name|pw
operator|->
name|p_flag
operator||=
operator|(
name|P_NOTIFY
operator||
name|P_STOPPED
operator|)
expr_stmt|;
name|pw
operator|->
name|p_sig
operator|=
name|SIGSTOP
expr_stmt|;
name|reset_ttygrp
argument_list|(
name|pw
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* SXT */
endif|#
directive|endif
comment|/* BSD */
name|trapnote
operator|&=
operator|~
name|SIGJOBS
expr_stmt|;
name|p
operator|=
name|wait
argument_list|(
operator|&
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ECHILD
condition|)
block|{
name|postclr
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
if|if
condition|(
name|trapnote
operator|&
name|SIGJOBS
condition|)
continue|continue;
if|if
condition|(
name|flag
condition|)
break|break;
block|}
continue|continue;
block|}
name|trapnote
operator|&=
operator|~
name|SIGJOBS
expr_stmt|;
name|pw
operator|=
name|job_bypid
argument_list|(
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SXT
name|pw
operator|->
name|p_flag
operator|&=
operator|~
name|P_STOPPED
expr_stmt|;
endif|#
directive|endif
comment|/* SXT */
comment|/* restore original tty state if jobs aborted */
if|if
condition|(
name|p
operator|==
name|i
operator|&&
operator|(
name|states
operator|&
name|MONITOR
operator|)
condition|)
name|reset_ttygrp
argument_list|(
name|pw
argument_list|,
name|w
operator|&
name|LOBYTE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pw
condition|)
block|{
name|numrun
operator|--
expr_stmt|;
name|pw
operator|->
name|p_flag
operator||=
name|P_NOTIFY
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD
if|if
condition|(
operator|(
name|states
operator|&
name|MONITOR
operator|)
operator|&&
name|WIFSTOPPED
argument_list|(
name|wstat
argument_list|)
condition|)
name|pw
operator|->
name|p_flag
operator||=
name|P_STOPPED
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* BSD */
block|{
if|if
condition|(
name|p
operator|==
name|cpid
condition|)
block|{
name|cpid
operator|=
literal|0
expr_stmt|;
name|cpipe
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|i
operator|||
operator|(
name|states
operator|&
name|MONITOR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|px
operator|=
name|unpost
argument_list|(
name|pw
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|i
operator|&&
operator|(
name|states
operator|&
name|MONITOR
operator|)
condition|)
name|set_job
argument_list|(
name|px
argument_list|)
expr_stmt|;
name|i
operator|=
name|px
operator|->
name|p_pid
expr_stmt|;
block|}
continue|continue;
block|}
block|}
block|}
block|}
name|sig
operator|=
name|w
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|states
operator|&
name|MONITOR
condition|)
block|{
ifdef|#
directive|ifdef
name|BSD
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|wstat
argument_list|)
condition|)
block|{
if|if
condition|(
name|pw
condition|)
name|pw
operator|->
name|p_sig
operator|=
name|wstat
operator|.
name|w_S
operator|.
name|w_Stopsig
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|i
condition|)
break|break;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|p
operator|!=
name|i
condition|)
else|#
directive|else
if|if
condition|(
name|p
operator|!=
name|i
condition|)
endif|#
directive|endif
comment|/* BSD */
block|{
if|if
condition|(
name|pw
condition|)
name|pw
operator|->
name|p_sig
operator|=
name|w
expr_stmt|;
if|if
condition|(
name|w
operator|&
name|HIGHBIT
condition|)
name|pw
operator|->
name|p_flag
operator||=
name|P_COREDUMP
expr_stmt|;
continue|continue;
block|}
comment|/* this is needed since child not in same process group */
elseif|else
if|if
condition|(
name|sig
operator|==
name|SIGINT
operator|||
name|sig
operator|==
name|SIGQUIT
operator|||
name|sig
operator|==
name|SIGHUP
condition|)
name|fault
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
name|w_hi
operator|=
operator|(
name|w
operator|>>
literal|8
operator|)
operator|&
name|LOBYTE
expr_stmt|;
if|if
condition|(
name|sig
condition|)
block|{
if|if
condition|(
name|sig
operator|==
literal|0177
comment|/* ptrace! return */
condition|)
block|{
name|fputs
argument_list|(
name|ptrace
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|sig
operator|=
name|w_hi
expr_stmt|;
block|}
if|if
condition|(
name|sig
operator|!=
name|SIGINT
operator|&&
name|sig
operator|!=
name|SIGPIPE
condition|)
block|{
if|if
condition|(
name|i
operator|!=
name|p
operator|||
operator|(
name|states
operator|&
name|PROMPT
operator|)
operator|==
literal|0
condition|)
name|p_prp
argument_list|(
name|itos
argument_list|(
name|p
argument_list|)
argument_list|,
name|SP
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|sysmsg
index|[
name|sig
index|]
argument_list|,
name|output
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|&
name|HIGHBIT
condition|)
name|fputs
argument_list|(
name|coredump
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
name|newline
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|i
condition|)
block|{
name|rc
operator|=
operator|(
name|sig
condition|?
name|sig
operator||
name|SIGFAIL
else|:
name|w_hi
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|flag
operator|>=
literal|2
condition|)
return|return;
name|exitval
operator|=
name|rc
expr_stmt|;
name|exitset
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
name|BSD
operator|||
name|SXT
comment|/*  * turn off STOP state of a process group  */
specifier|static
name|int
name|unstop
parameter_list|(
name|grp
parameter_list|)
specifier|register
name|int
name|grp
decl_stmt|;
block|{
specifier|register
name|struct
name|process
modifier|*
name|pw
decl_stmt|;
specifier|register
name|int
name|num
init|=
name|numrun
decl_stmt|;
for|for
control|(
name|pw
operator|=
name|pwlist
init|;
name|pw
condition|;
name|pw
operator|=
name|pw
operator|->
name|p_next
control|)
block|{
if|if
condition|(
name|pw
operator|->
name|p_pgrp
operator|!=
name|grp
condition|)
continue|continue;
if|if
condition|(
name|pw
operator|->
name|p_flag
operator|&
name|P_STOPPED
condition|)
block|{
name|num
operator|++
expr_stmt|;
name|pw
operator|->
name|p_flag
operator|&=
operator|~
name|P_STOPPED
expr_stmt|;
name|pw
operator|->
name|p_sig
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SXT
break|break;
endif|#
directive|endif
comment|/* SXT */
block|}
block|}
if|if
condition|(
name|num
operator|!=
name|numrun
condition|)
block|{
name|p_flush
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD
name|numrun
operator|=
name|num
expr_stmt|;
return|return
operator|(
name|killpg
argument_list|(
name|grp
argument_list|,
name|SIGCONT
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* BSD */
comment|/*  * remove a process group from table  * If all the processes have not completed then unpost returns  * the structure pointer  of an unfinished process.  * Otherwise NULL is returned.  */
specifier|static
name|struct
name|process
modifier|*
name|unpost
parameter_list|(
name|pwtop
parameter_list|)
name|struct
name|process
modifier|*
name|pwtop
decl_stmt|;
block|{
specifier|register
name|struct
name|process
modifier|*
name|pw
decl_stmt|;
specifier|register
name|struct
name|process
modifier|*
name|px
init|=
name|NULL
decl_stmt|;
specifier|register
name|int
name|job
init|=
name|pwtop
operator|->
name|p_job
decl_stmt|;
specifier|register
name|struct
name|process
modifier|*
name|py
decl_stmt|;
comment|/* look for unfinished processes */
for|for
control|(
name|pw
operator|=
name|pwlist
init|;
name|pw
condition|;
name|pw
operator|=
name|pw
operator|->
name|p_next
control|)
block|{
if|if
condition|(
name|pw
operator|->
name|p_job
operator|!=
name|job
condition|)
continue|continue;
if|if
condition|(
operator|(
name|pw
operator|->
name|p_flag
operator|&
name|P_NOTIFY
operator|)
operator|==
literal|0
condition|)
name|px
operator|=
name|pw
expr_stmt|;
block|}
if|if
condition|(
name|px
condition|)
block|{
name|px
operator|->
name|p_flag
operator|&=
operator|~
name|P_PIPEJOB
expr_stmt|;
name|px
operator|->
name|p_flag
operator||=
name|P_WAITED
expr_stmt|;
return|return
operator|(
name|px
operator|)
return|;
block|}
comment|/* all processes complete, unpost job */
for|for
control|(
name|pw
operator|=
name|pwlist
init|;
name|pw
condition|;
name|pw
operator|=
name|py
control|)
block|{
name|py
operator|=
name|pw
operator|->
name|p_next
expr_stmt|;
if|if
condition|(
name|pw
operator|->
name|p_job
operator|!=
name|job
condition|)
block|{
name|px
operator|=
name|pw
expr_stmt|;
continue|continue;
block|}
name|numpost
operator|--
expr_stmt|;
if|if
condition|(
name|px
operator|==
name|NULL
condition|)
name|pwlist
operator|=
name|py
expr_stmt|;
else|else
name|px
operator|->
name|p_next
operator|=
name|py
expr_stmt|;
name|pw
operator|->
name|p_next
operator|=
name|freelist
expr_stmt|;
name|freelist
operator|=
name|pw
expr_stmt|;
block|}
name|free_job
argument_list|(
operator|(
name|int
operator|)
name|pwtop
operator|->
name|p_job
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*  * unlink a process form the process list  */
specifier|static
name|void
name|pw_unlink
parameter_list|(
name|pw
parameter_list|)
specifier|register
name|struct
name|process
modifier|*
name|pw
decl_stmt|;
block|{
specifier|register
name|struct
name|process
modifier|*
name|px
decl_stmt|;
if|if
condition|(
name|pw
operator|==
name|pwlist
condition|)
block|{
name|pwlist
operator|=
name|pw
operator|->
name|p_next
expr_stmt|;
return|return;
block|}
for|for
control|(
name|px
operator|=
name|pwlist
init|;
name|px
condition|;
name|px
operator|=
name|px
operator|->
name|p_next
control|)
if|if
condition|(
name|px
operator|->
name|p_next
operator|==
name|pw
condition|)
block|{
name|px
operator|->
name|p_next
operator|=
name|pw
operator|->
name|p_next
expr_stmt|;
return|return;
block|}
block|}
comment|/*  * get an unused job number  * freejobs is a bit vector, 0 is unused  */
specifier|static
name|int
name|get_job
parameter_list|()
block|{
specifier|register
name|int
name|j
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|mask
init|=
literal|1
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|freeword
decl_stmt|;
comment|/* skip to first word with a free slot */
while|while
condition|(
name|freejobs
index|[
name|j
index|]
operator|==
literal|0xff
condition|)
name|j
operator|++
expr_stmt|;
name|freeword
operator|=
operator|&
name|freejobs
index|[
name|j
index|]
expr_stmt|;
name|j
operator|*=
literal|8
expr_stmt|;
for|for
control|(
name|j
operator|++
init|;
name|mask
operator|&
operator|(
operator|*
name|freeword
operator|)
condition|;
name|j
operator|++
operator|,
name|mask
operator|<<=
literal|1
control|)
empty_stmt|;
operator|*
name|freeword
operator||=
name|mask
expr_stmt|;
return|return
operator|(
name|j
operator|)
return|;
block|}
comment|/*  * return a job number  */
specifier|static
name|void
name|free_job
parameter_list|(
name|n
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|int
name|j
init|=
operator|(
operator|--
name|n
operator|)
operator|/
literal|8
decl_stmt|;
specifier|register
name|unsigned
name|mask
decl_stmt|;
name|n
operator|-=
name|j
operator|*
literal|8
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
name|n
expr_stmt|;
name|freejobs
index|[
name|j
index|]
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SXT
comment|/*  * open up the input streams for a new channel  */
specifier|static
name|char
modifier|*
name|open_mode
index|[
literal|3
index|]
init|=
block|{
literal|"r"
block|,
literal|"w"
block|,
literal|"w+"
block|}
decl_stmt|;
name|j_new_chan
argument_list|()
block|{
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|sxt
index|[
literal|11
index|]
operator|=
literal|'0'
operator|+
name|jobstat
operator|.
name|cur_job
expr_stmt|;
name|close
argument_list|(
name|jobstat
operator|.
name|pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|sxt
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|fd
argument_list|)
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|my_stty
argument_list|)
operator|<
literal|0
operator|||
name|fd
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|jobstat
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isatty
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|file_fd
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fdopen
argument_list|(
name|dup
argument_list|(
name|fileno
argument_list|(
name|fd
argument_list|)
argument_list|)
argument_list|,
name|open_mode
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|jobstat
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|,
name|nullstr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|jobstat
operator|.
name|pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|int
name|next_job
parameter_list|()
block|{
specifier|register
name|int
name|i
init|=
name|get_job
argument_list|()
decl_stmt|;
name|free_job
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
specifier|static
name|status_update
argument_list|(
argument|mask2
argument_list|,
argument|mask1
argument_list|,
argument|sigval
argument_list|)
block|{
specifier|register
name|int
name|i
block|,
name|j
block|;
specifier|register
expr|struct
name|process
operator|*
name|pw
block|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAXPCHAN
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|mask1
operator|&
name|j
operator|)
operator|==
literal|0
operator|&&
operator|(
name|mask2
operator|&
name|j
operator|)
condition|)
block|{
if|if
condition|(
name|pw
operator|=
name|job_bynum
argument_list|(
name|i
argument_list|)
condition|)
name|pw
operator|->
name|p_sig
operator|=
name|sigval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|mask2
operator|&
name|j
operator|)
operator|==
literal|0
operator|&&
operator|(
name|mask1
operator|&
name|j
operator|)
condition|)
block|{
if|if
condition|(
name|pw
operator|=
name|job_bynum
argument_list|(
name|i
argument_list|)
condition|)
name|pw
operator|->
name|p_sig
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
unit|}  static
name|int
name|open_chan
parameter_list|(
name|j
parameter_list|)
block|{
name|sxt
index|[
literal|11
index|]
operator|=
literal|'0'
operator|+
name|j
expr_stmt|;
if|if
condition|(
name|fd_chan
operator|>=
literal|0
condition|)
block|{
return|return;
block|}
name|fd_chan
operator|=
name|open
argument_list|(
name|sxt
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SXT */
end_comment

begin_comment
comment|/* XXX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|POSIX
end_ifdef

begin_macro
name|cfgetospeed
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|t
operator|->
name|c_ospeed
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

