begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   *      Copyright (c) 1984, 1985, 1986 AT&T  *      All Rights Reserved   *      THIS IS UNPUBLISHED PROPRIETARY SOURCE   *      CODE OF AT&T.  *      The copyright notice above does not   *      evidence any actual or intended  *      publication of such source code.   */
end_comment

begin_comment
comment|/* @(#)macro.c	1.1 */
end_comment

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * AT&T Bell Laboratories  * Rewritten by David Korn  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"stak.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"shtype.h"
end_include

begin_include
include|#
directive|include
file|"mode.h"
end_include

begin_include
include|#
directive|include
file|"jobs.h"
end_include

begin_include
include|#
directive|include
file|"builtins.h"
end_include

begin_include
include|#
directive|include
file|"brkincr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE
end_ifdef

begin_include
include|#
directive|include
file|"national.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MULTIBYTE */
end_comment

begin_define
define|#
directive|define
name|unreadc
parameter_list|(
name|c
parameter_list|)
value|(peekc = (c)|MARK)
end_define

begin_define
define|#
directive|define
name|blt_no
parameter_list|(
name|t
parameter_list|)
value|((t)>>(COMBITS+1))
end_define

begin_define
define|#
directive|define
name|RBRACE
value|'}'
end_define

begin_comment
comment|/* These routines are defined by this module */
end_comment

begin_function_decl
name|char
modifier|*
name|macro
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|mactry
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|mactrim
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mac_subst
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* These external routines are referenced by this module */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|arg_dolminus
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|assign
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|await
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|chkopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|chkpipe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|TREPTR
name|cmd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|exfunct
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|failed
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|initf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|itos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|NAMPTR
name|lookup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|TREPTR
name|makefork
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|match_paren
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|movstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_setout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|readc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|tdystak
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|tmp_open
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|trim
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|valup
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE
end_ifdef

begin_function_decl
specifier|static
name|int
name|charlen
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MULTIBYTE */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|copyto
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|substring
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|skipto
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|comsubst
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mac_error
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
name|quote
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used locally */
end_comment

begin_decl_stmt
specifier|static
name|char
name|quoted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used locally */
end_comment

begin_decl_stmt
specifier|static
name|char
name|mflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set for macro expansion, unset for here docs */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|w_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mac_try
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|mac_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|idb
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|copyto
parameter_list|(
name|endch
parameter_list|)
specifier|register
name|char
name|endch
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getch
argument_list|(
name|endch
argument_list|)
operator|)
operator|!=
name|endch
operator|&&
name|c
condition|)
block|{
if|if
condition|(
name|quote
operator|||
name|c
operator|==
name|ESCAPE
condition|)
block|{
name|pushstak
argument_list|(
name|ESCAPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|ESCAPE
condition|)
block|{
name|c
operator|=
name|readc
argument_list|()
expr_stmt|;
if|if
condition|(
name|quote
operator|&&
operator|!
name|escchar
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'"'
condition|)
block|{
name|pushstak
argument_list|(
name|ESCAPE
argument_list|)
expr_stmt|;
name|pushstak
argument_list|(
name|ESCAPE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|pushstak
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|zerostak
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|endch
condition|)
name|mac_error
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* skip chars up to } */
end_comment

begin_function
specifier|static
name|void
name|skipto
parameter_list|(
name|endch
parameter_list|)
specifier|register
name|char
name|endch
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|readc
argument_list|()
operator|)
operator|&&
name|c
operator|!=
name|endch
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|SQUOTE
case|:
case|case
name|DQUOTE
case|:
name|skipto
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOLLAR
case|:
if|if
condition|(
name|readc
argument_list|()
operator|==
name|BRACE
condition|)
name|skipto
argument_list|(
name|RBRACE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
name|endch
condition|)
name|mac_error
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|getch
parameter_list|(
name|endch
parameter_list|)
name|int
name|endch
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|atflag
decl_stmt|;
comment|/* set if $@ or ${array[@]} within double quotes */
name|retry
label|:
name|c
operator|=
name|readc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|subchar
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
name|c
operator|==
name|DOLLAR
condition|)
block|{
specifier|register
name|int
name|bra
init|=
literal|0
decl_stmt|;
comment|/* {...} bra =1, {#...} bra=2 */
specifier|register
name|char
modifier|*
name|v
decl_stmt|;
specifier|register
name|char
modifier|*
name|argp
decl_stmt|;
specifier|register
name|NAMPTR
name|n
init|=
operator|(
name|NAMPTR
operator|)
name|NULL
decl_stmt|;
name|int
name|dolg
init|=
literal|0
decl_stmt|;
name|int
name|dolmax
init|=
name|dolc
operator|+
literal|1
decl_stmt|;
name|BOOL
name|nulflg
decl_stmt|;
name|char
modifier|*
name|id
init|=
name|idb
decl_stmt|;
operator|*
name|id
operator|=
literal|0
expr_stmt|;
name|retry1
label|:
name|c
operator|=
name|readc
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|DOLLAR
case|:
name|v
operator|=
name|pidadr
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|v
operator|=
name|pcsadr
expr_stmt|;
break|break;
case|case
name|BRACE
case|:
if|if
condition|(
name|bra
operator|++
operator|==
literal|0
condition|)
goto|goto
name|retry1
goto|;
case|case
name|LPAREN
case|:
if|if
condition|(
name|bra
operator|==
literal|0
operator|&&
name|mac_try
operator|==
literal|0
condition|)
block|{
name|comsubst
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
goto|goto
name|nosub
goto|;
case|case
name|RBRACE
case|:
if|if
condition|(
name|bra
operator|!=
literal|2
condition|)
goto|goto
name|nosub
goto|;
name|bra
operator|=
literal|0
expr_stmt|;
case|case
literal|'#'
case|:
if|if
condition|(
name|bra
operator|==
literal|1
condition|)
block|{
name|bra
operator|++
expr_stmt|;
goto|goto
name|retry1
goto|;
block|}
name|v
operator|=
name|itos
argument_list|(
name|dolc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|v
operator|=
name|itos
argument_list|(
name|savexit
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|v
operator|=
name|arg_dolminus
argument_list|()
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|argp
operator|=
operator|(
name|char
operator|*
operator|)
name|relstak
argument_list|()
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|pushstak
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|readc
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'['
operator|&&
name|bra
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|readc
argument_list|()
operator|,
name|astchar
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
operator|*
name|id
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|=
name|readc
argument_list|()
operator|!=
literal|']'
condition|)
name|mac_error
argument_list|()
expr_stmt|;
name|dolmax
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|savq
init|=
name|quote
decl_stmt|;
name|pushstak
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|unreadc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|quote
operator|=
literal|0
expr_stmt|;
name|copyto
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|quote
operator|=
name|savq
expr_stmt|;
name|pushstak
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|unreadc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|zerostak
argument_list|()
expr_stmt|;
name|n
operator|=
name|lookup
argument_list|(
name|absstak
argument_list|(
name|argp
argument_list|)
argument_list|)
expr_stmt|;
name|setstak
argument_list|(
name|argp
argument_list|)
expr_stmt|;
name|v
operator|=
name|valup
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|id
operator|=
name|n
operator|->
name|namid
expr_stmt|;
if|if
condition|(
name|dolmax
operator|==
literal|0
operator|&&
name|attest
argument_list|(
name|n
argument_list|,
name|ARRAY
argument_list|)
condition|)
block|{
name|dolg
operator|=
operator|-
operator|(
call|(
name|int
call|)
argument_list|(
name|arayp
argument_list|(
name|n
argument_list|)
operator|->
name|maxi
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|v
operator|==
literal|0
condition|)
block|{
name|arayp
argument_list|(
name|n
argument_list|)
operator|->
name|adot
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|dolg
operator|==
literal|0
condition|)
break|break;
name|v
operator|=
name|valup
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|cont1
goto|;
block|}
if|if
condition|(
name|digchar
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|id
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|astchar
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|dolg
operator|=
literal|1
expr_stmt|;
name|c
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|c
operator|-=
literal|'0'
expr_stmt|;
if|if
condition|(
name|bra
condition|)
block|{
name|int
name|d
decl_stmt|;
while|while
condition|(
operator|(
name|d
operator|=
name|readc
argument_list|()
operator|,
name|isdigit
argument_list|(
name|d
argument_list|)
operator|)
condition|)
name|c
operator|=
literal|10
operator|*
name|c
operator|+
operator|(
name|d
operator|-
literal|'0'
operator|)
expr_stmt|;
name|unreadc
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
name|v
operator|=
operator|(
operator|(
name|c
operator|==
literal|0
operator|)
condition|?
name|cmdadr
else|:
operator|(
name|c
operator|<=
name|dolc
operator|)
condition|?
name|dolv
index|[
name|c
index|]
else|:
operator|(
name|char
operator|*
operator|)
operator|(
name|dolg
operator|=
literal|0
operator|)
operator|)
expr_stmt|;
goto|goto
name|cont1
goto|;
block|}
name|nosub
label|:
if|if
condition|(
name|bra
condition|)
name|mac_error
argument_list|()
expr_stmt|;
else|else
block|{
name|unreadc
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|DOLLAR
operator|)
return|;
block|}
block|}
name|cont1
label|:
name|c
operator|=
name|readc
argument_list|()
expr_stmt|;
if|if
condition|(
name|bra
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|c
operator|!=
name|RBRACE
condition|)
name|mac_error
argument_list|()
expr_stmt|;
if|if
condition|(
name|dolg
operator|==
literal|0
operator|&&
name|dolmax
condition|)
ifdef|#
directive|ifdef
name|MULTIBYTE
name|c
operator|=
operator|(
name|v
condition|?
name|charlen
argument_list|(
name|v
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
else|#
directive|else
name|c
operator|=
operator|(
name|v
condition|?
name|strlen
argument_list|(
name|v
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
elseif|else
if|if
condition|(
name|dolg
operator|>
literal|0
condition|)
name|c
operator|=
name|dolc
expr_stmt|;
elseif|else
if|if
condition|(
name|dolg
operator|<
literal|0
condition|)
name|c
operator|=
name|arayp
argument_list|(
name|n
argument_list|)
operator|->
name|maxi
operator|+
literal|1
expr_stmt|;
else|else
name|c
operator|=
operator|(
name|v
operator|!=
literal|0
operator|)
expr_stmt|;
name|v
operator|=
name|itos
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|dolg
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|RBRACE
expr_stmt|;
block|}
comment|/* check for quotes @ */
if|if
condition|(
name|idb
index|[
literal|0
index|]
operator|==
literal|'@'
operator|&&
name|quote
operator|&&
operator|!
name|atflag
condition|)
block|{
name|quoted
operator|--
expr_stmt|;
name|atflag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|':'
operator|&&
name|bra
condition|)
comment|/* null and unset fix */
block|{
name|nulflg
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|readc
argument_list|()
expr_stmt|;
block|}
else|else
name|nulflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|defchar
argument_list|(
name|c
argument_list|)
operator|&&
name|bra
condition|)
name|mac_error
argument_list|()
expr_stmt|;
name|argp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bra
condition|)
block|{
if|if
condition|(
name|c
operator|!=
name|RBRACE
condition|)
block|{
name|argp
operator|=
operator|(
name|char
operator|*
operator|)
name|relstak
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|==
literal|0
operator|||
operator|(
name|nulflg
operator|&&
operator|*
name|v
operator|==
literal|0
operator|)
operator|)
operator|^
operator|(
name|setchar
argument_list|(
name|c
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|copyto
argument_list|(
name|RBRACE
argument_list|)
expr_stmt|;
else|else
name|skipto
argument_list|(
name|RBRACE
argument_list|)
expr_stmt|;
name|argp
operator|=
name|absstak
argument_list|(
name|argp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|unreadc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
comment|/* check for substring operations */
if|if
condition|(
name|c
operator|==
literal|'#'
operator|||
name|c
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|dolg
operator|!=
literal|0
condition|)
name|mac_error
argument_list|()
expr_stmt|;
if|if
condition|(
name|v
operator|&&
operator|*
name|v
condition|)
block|{
comment|/* allow room for escapes */
name|staktop
operator|+=
name|strlen
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|staktop
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|trim
argument_list|(
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|argp
operator|==
name|c
condition|)
block|{
name|c
operator||=
name|MARK
expr_stmt|;
name|argp
operator|++
expr_stmt|;
block|}
name|v
operator|=
name|substring
argument_list|(
name|staktop
argument_list|,
name|argp
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|MARK
condition|)
name|argp
operator|--
expr_stmt|;
block|}
name|staktop
operator|=
name|argp
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|&&
operator|(
operator|!
name|nulflg
operator|||
operator|*
name|v
operator|)
operator|&&
name|c
operator|!=
literal|'+'
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|BOOL
name|no_ifs
init|=
literal|0
decl_stmt|;
name|int
name|sep
init|=
name|SP
decl_stmt|;
name|argp
operator|=
name|valup
argument_list|(
name|IFSNOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|argp
operator|==
literal|0
operator|||
operator|*
name|argp
operator|==
literal|0
condition|)
name|no_ifs
operator|++
expr_stmt|;
else|else
name|sep
operator|=
operator|*
name|argp
expr_stmt|;
comment|/* quoted null strings have to be marked */
if|if
condition|(
operator|*
name|v
operator|==
literal|0
operator|&&
name|quote
condition|)
block|{
name|pushstak
argument_list|(
name|ESCAPE
argument_list|)
expr_stmt|;
name|pushstak
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|=
operator|*
name|v
operator|++
condition|)
block|{
if|if
condition|(
name|staktop
operator|>=
name|brkend
condition|)
name|setbrk
argument_list|(
name|BRKINCR
argument_list|)
expr_stmt|;
if|if
condition|(
name|quote
operator|||
operator|(
name|c
operator|==
name|ESCAPE
operator|&&
name|mflag
operator|)
operator|||
operator|(
name|no_ifs
operator|&&
name|isspace
argument_list|(
name|c
argument_list|)
operator|)
condition|)
name|pushstak
argument_list|(
name|ESCAPE
argument_list|)
expr_stmt|;
name|pushstak
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dolg
operator|==
literal|0
operator|||
operator|(
operator|++
name|dolg
operator|>=
name|dolmax
operator|)
condition|)
break|break;
if|if
condition|(
name|dolg
operator|>
literal|0
condition|)
name|v
operator|=
name|dolv
index|[
name|dolg
index|]
expr_stmt|;
else|else
block|{
name|arayp
argument_list|(
name|n
argument_list|)
operator|->
name|adot
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|valup
argument_list|(
name|n
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|arayp
argument_list|(
name|n
argument_list|)
operator|->
name|adot
operator|++
expr_stmt|;
if|if
condition|(
name|dolg
operator|++
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|v
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|quote
operator|&&
operator|*
name|id
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|no_ifs
condition|)
continue|continue;
name|pushstak
argument_list|(
name|ESCAPE
argument_list|)
expr_stmt|;
block|}
name|pushstak
argument_list|(
name|sep
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|argp
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
block|{
if|if
condition|(
name|mac_try
condition|)
name|mac_error
argument_list|()
expr_stmt|;
else|else
block|{
name|trim
argument_list|(
name|argp
argument_list|)
expr_stmt|;
name|failed
argument_list|(
name|id
argument_list|,
operator|*
name|argp
condition|?
name|argp
else|:
name|badparam
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
name|n
condition|)
block|{
name|trim
argument_list|(
name|argp
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|n
argument_list|,
name|argp
argument_list|)
expr_stmt|;
name|staktop
operator|=
name|movstr
argument_list|(
name|valup
argument_list|(
name|n
argument_list|)
argument_list|,
name|argp
argument_list|)
expr_stmt|;
block|}
else|else
name|mac_error
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|is_option
argument_list|(
name|NOSET
argument_list|)
condition|)
block|{
if|if
condition|(
name|mac_try
condition|)
name|mac_error
argument_list|()
expr_stmt|;
else|else
name|failed
argument_list|(
name|id
argument_list|,
name|unset
argument_list|)
expr_stmt|;
block|}
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|endch
condition|)
return|return
operator|(
name|c
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
name|SQUOTE
operator|&&
name|mac_try
operator|==
literal|0
condition|)
block|{
name|comsubst
argument_list|(
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|DQUOTE
condition|)
block|{
if|if
condition|(
name|quote
operator|==
literal|0
condition|)
block|{
name|atflag
operator|=
literal|0
expr_stmt|;
name|quoted
operator|++
expr_stmt|;
block|}
name|quote
operator|^=
literal|1
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Strip "" and do $ substitution 	 * Leaves result on top of stack 	 */
end_comment

begin_function
name|char
modifier|*
name|macro
parameter_list|(
name|as
parameter_list|)
name|char
modifier|*
name|as
decl_stmt|;
block|{
specifier|register
name|BOOL
name|savqu
init|=
name|quoted
decl_stmt|;
specifier|register
name|char
name|savq
init|=
name|quote
decl_stmt|;
name|FILE
name|fblk
decl_stmt|;
name|FILEBLK
name|cb
decl_stmt|;
name|mflag
operator|=
literal|1
expr_stmt|;
name|push
argument_list|(
operator|&
name|cb
argument_list|)
expr_stmt|;
name|estabf
argument_list|(
name|as
argument_list|,
operator|&
name|fblk
argument_list|)
expr_stmt|;
name|usestak
argument_list|()
expr_stmt|;
name|quote
operator|=
literal|0
expr_stmt|;
name|quoted
operator|=
literal|0
expr_stmt|;
name|copyto
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|quoted
operator|&&
operator|(
name|stakbot
operator|==
name|staktop
operator|)
condition|)
block|{
name|pushstak
argument_list|(
name|ESCAPE
argument_list|)
expr_stmt|;
name|pushstak
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* above is the fix for *'.c' bug	*/
name|quote
operator|=
name|savq
expr_stmt|;
name|quoted
operator|=
name|savqu
expr_stmt|;
return|return
operator|(
name|fixstak
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * command substitution  * type==0 for ``  * type==1 for $() */
end_comment

begin_function
specifier|static
name|void
name|comsubst
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
name|FILEBLK
name|cb
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|;
name|FILE
modifier|*
name|pv
index|[
literal|2
index|]
decl_stmt|;
name|FILE
name|fblk
decl_stmt|;
name|char
name|tmp_fname
index|[
name|TMPSIZ
index|]
decl_stmt|;
specifier|register
name|unsigned
name|int
name|d
decl_stmt|;
specifier|register
name|TREPTR
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|argc
decl_stmt|;
name|IOPTR
name|saviotemp
init|=
name|iotemp
decl_stmt|;
name|int
name|forkflag
init|=
name|FPOU
operator||
name|FCOMSUB
decl_stmt|;
name|STKPTR
name|savtop
init|=
name|staktop
decl_stmt|;
name|STKPTR
name|savptr
init|=
name|fixstak
argument_list|()
decl_stmt|;
name|char
name|inbuff
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|saveflag
init|=
name|states
operator|&
name|FIXFLG
decl_stmt|;
specifier|register
name|int
name|waitflag
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|w_fd
condition|)
name|fflush
argument_list|(
name|w_fd
argument_list|)
expr_stmt|;
comment|/* flush before executing command */
name|usestak
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
condition|)
block|{
name|staktop
operator|=
call|(
name|STKPTR
call|)
argument_list|(
name|match_paren
argument_list|(
operator|(
name|char
operator|*
operator|)
name|stakbot
argument_list|,
name|LPAREN
argument_list|,
name|RPAREN
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|d
operator|=
name|readc
argument_list|()
operator|)
operator|!=
name|SQUOTE
operator|&&
name|d
condition|)
block|{
if|if
condition|(
name|d
operator|==
name|ESCAPE
condition|)
block|{
name|d
operator|=
name|readc
argument_list|()
expr_stmt|;
comment|/* 				 * This is wrong but it preserves compatibility with 				 * the SVR2 shell 				 */
if|if
condition|(
operator|!
operator|(
name|escchar
argument_list|(
name|d
argument_list|)
operator|||
operator|(
name|d
operator|==
literal|'"'
operator|&&
name|quote
operator|)
operator|)
condition|)
name|pushstak
argument_list|(
name|ESCAPE
argument_list|)
expr_stmt|;
block|}
name|pushstak
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|=
name|fixstak
argument_list|()
expr_stmt|;
name|states
operator|&=
operator|~
name|FIXFLG
expr_stmt|;
comment|/* do not save command subs in fc file */
name|push
argument_list|(
operator|&
name|cb
argument_list|)
expr_stmt|;
name|estabf
argument_list|(
name|argc
argument_list|,
operator|&
name|fblk
argument_list|)
expr_stmt|;
name|subflag
operator|=
literal|0
expr_stmt|;
name|exec_flag
operator|++
expr_stmt|;
name|t
operator|=
name|cmd
argument_list|(
name|EOFSYM
argument_list|,
name|MTFLG
operator||
name|NLFLG
argument_list|)
expr_stmt|;
name|exec_flag
operator|--
expr_stmt|;
name|d
operator|=
name|t
operator|->
name|tretyp
expr_stmt|;
if|if
condition|(
operator|!
name|subflag
operator|&&
operator|!
name|t
operator|->
name|treio
operator|&&
operator|(
name|d
operator|&
name|COMMSK
operator|)
operator|==
name|TCOM
operator|&&
name|blt_no
argument_list|(
name|d
argument_list|)
operator|>
name|SYSSPECIAL
condition|)
block|{
comment|/* nested command subs not handled specially */
comment|/* handle command substitution of most builtins separately */
comment|/* exec, login, cd, ., eval and shift not handled this way */
comment|/* put output into tmpfile */
name|FILE
modifier|*
name|save1_out
init|=
name|standout
decl_stmt|;
if|if
condition|(
operator|(
name|states
operator|&
name|IS_TMP
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* create and keep open a /tmp file for command subs */
name|fd
operator|=
name|tmp_open
argument_list|(
name|tmp_fname
argument_list|)
expr_stmt|;
name|fd
operator|=
name|frenumber
argument_list|(
name|fd
argument_list|,
name|TMPIO
argument_list|)
expr_stmt|;
name|states
operator||=
name|IS_TMP
expr_stmt|;
comment|/* root cannot unlink because fsck could give bad ref count */
if|if
condition|(
name|userid
condition|)
name|unlink
argument_list|(
name|tmp_fname
argument_list|)
expr_stmt|;
else|else
name|states
operator||=
name|RM_TMP
expr_stmt|;
block|}
else|else
name|fd
operator|=
name|file_fd
argument_list|(
name|TMPIO
argument_list|)
expr_stmt|;
name|standout
operator|=
name|fd
expr_stmt|;
comment|/* this will only flush the buffer if output is fd already */
name|p_setout
argument_list|(
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JOBS
name|states
operator||=
name|NONSTOP
expr_stmt|;
endif|#
directive|endif
comment|/* JOBS */
name|putc
argument_list|(
literal|0
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|exfunct
argument_list|(
name|t
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|states
operator|&
name|ERRFLG
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|0
argument_list|,
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JOBS
name|states
operator|&=
operator|~
name|NONSTOP
expr_stmt|;
endif|#
directive|endif
comment|/* JOBS */
if|if
condition|(
operator|*
name|_sobuf
operator|!=
literal|0
condition|)
block|{
comment|/* file is larger than buffer, read from it */
name|fflush
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
literal|1L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|initf
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|waitflag
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* The file is all in the buffer */
name|setbuf
argument_list|(
name|fd
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|inbuff
argument_list|,
operator|(
name|char
operator|*
operator|)
name|_sobuf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|_sobuf
argument_list|)
expr_stmt|;
name|estabf
argument_list|(
name|inbuff
argument_list|,
operator|(
name|fd
operator|=
operator|&
name|fblk
operator|)
argument_list|)
expr_stmt|;
block|}
name|standout
operator|=
name|save1_out
expr_stmt|;
goto|goto
name|readit
goto|;
block|}
elseif|else
if|if
condition|(
name|d
operator|==
literal|0
operator|&&
operator|(
operator|(
name|COMPTR
operator|)
name|t
operator|)
operator|->
name|comarg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|t
operator|->
name|treio
operator|)
operator|->
name|iofile
operator|)
operator|==
literal|0
condition|)
name|argc
operator|=
name|mactrim
argument_list|(
operator|(
name|t
operator|->
name|treio
operator|)
operator|->
name|ioname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|argc
operator|=
name|devnull
expr_stmt|;
name|fd
operator|=
name|chkopen
argument_list|(
name|argc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|waitflag
operator|++
expr_stmt|;
if|if
condition|(
name|iotemp
operator|!=
name|saviotemp
condition|)
name|forkflag
operator||=
name|FTMP
expr_stmt|;
name|t
operator|=
name|makefork
argument_list|(
name|forkflag
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* this is done like this so that the pipe 		   * is open only when needed 		   */
name|chkpipe
argument_list|(
name|pv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JOBS
name|jobstat
operator|.
name|cur_pgrp
operator|=
name|jobstat
operator|.
name|mypid
expr_stmt|;
name|jobstat
operator|.
name|j_flag
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* JOBS */
name|execute
argument_list|(
name|t
argument_list|,
name|states
operator|&
name|ERRFLG
argument_list|,
operator|(
name|FILE
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|pv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JOBS
name|jobstat
operator|.
name|j_flag
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* JOBS */
name|fd
operator|=
name|pv
index|[
name|INPIPE
index|]
expr_stmt|;
name|fclose
argument_list|(
name|pv
index|[
name|OTPIPE
index|]
argument_list|)
expr_stmt|;
block|}
name|setbuf
argument_list|(
name|fd
argument_list|,
name|inbuff
argument_list|)
expr_stmt|;
name|initf
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|readit
label|:
name|tdystak
argument_list|(
name|savptr
argument_list|)
expr_stmt|;
name|d
operator|=
name|savtop
operator|-
name|savptr
expr_stmt|;
while|while
condition|(
name|d
operator|--
condition|)
operator|*
name|staktop
operator|++
operator|=
operator|*
name|savptr
operator|++
expr_stmt|;
while|while
condition|(
name|d
operator|=
name|readc
argument_list|()
condition|)
block|{
if|if
condition|(
name|quote
operator|||
operator|(
name|d
operator|==
name|ESCAPE
operator|&&
name|mflag
operator|)
condition|)
name|pushstak
argument_list|(
name|ESCAPE
argument_list|)
expr_stmt|;
name|pushstak
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|waitflag
operator|>
literal|0
condition|)
name|await
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|stakbot
operator|!=
name|staktop
condition|)
block|{
if|if
condition|(
operator|*
operator|--
name|staktop
operator|!=
name|NL
condition|)
block|{
operator|*
operator|++
name|staktop
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|quote
condition|)
name|staktop
operator|--
expr_stmt|;
block|}
name|pop
argument_list|(
name|waitflag
operator|>=
literal|0
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
name|states
operator||=
name|saveflag
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mac_subst
parameter_list|(
name|in
parameter_list|,
name|ot
parameter_list|)
name|FILE
modifier|*
name|in
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|ot
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|flag
operator|=
name|is_option
argument_list|(
name|EXECPR
argument_list|)
expr_stmt|;
name|FILEBLK
name|fb
decl_stmt|;
name|char
name|inbuff
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|otbuff
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|mflag
operator|=
literal|0
expr_stmt|;
name|w_fd
operator|=
name|ot
expr_stmt|;
name|push
argument_list|(
operator|&
name|fb
argument_list|)
expr_stmt|;
name|initf
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|/* DQUOTE used to stop it from quoting */
name|setbuf
argument_list|(
name|in
argument_list|,
name|inbuff
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|ot
argument_list|,
name|otbuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
name|p_setout
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|usestak
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|getch
argument_list|(
name|DQUOTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|ESCAPE
condition|)
block|{
name|c
operator|=
name|readc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|escchar
argument_list|(
name|c
argument_list|)
condition|)
name|pushstak
argument_list|(
name|ESCAPE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|staktop
operator|!=
name|stakbot
condition|)
block|{
operator|*
name|staktop
operator|=
literal|0
expr_stmt|;
name|fputs
argument_list|(
name|stakbot
argument_list|,
name|ot
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
name|fputs
argument_list|(
name|stakbot
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|staktop
operator|=
name|stakbot
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
name|putc
argument_list|(
name|c
argument_list|,
name|ot
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
name|pop
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|w_fd
operator|=
name|NULL
expr_stmt|;
name|fflush
argument_list|(
name|ot
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|ot
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|ot
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Computes the substring of STRING using the expression PAT  * depending on which FLAG is set.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|substring
parameter_list|(
name|string
parameter_list|,
name|pat
parameter_list|,
name|flag
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|pat
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|sp
init|=
name|string
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
literal|'#'
case|:
case|case
name|MARK
operator||
literal|'#'
case|:
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|cp
operator|=
name|sp
expr_stmt|;
do|do
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE
name|c
operator|=
operator|*
name|sp
expr_stmt|;
name|c
operator|=
name|echarset
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|sp
operator|+=
operator|(
name|in_csize
argument_list|(
name|c
argument_list|)
operator|+
operator|(
name|c
operator|>=
literal|2
operator|)
operator|)
expr_stmt|;
name|c
operator|=
operator|*
name|sp
expr_stmt|;
else|#
directive|else
name|c
operator|=
operator|*
operator|++
name|sp
expr_stmt|;
endif|#
directive|endif
comment|/* MULTIBYTE */
operator|*
name|sp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gmatch
argument_list|(
name|string
argument_list|,
name|pat
argument_list|)
condition|)
block|{
name|cp
operator|=
name|sp
expr_stmt|;
if|if
condition|(
name|flag
operator|==
literal|'#'
condition|)
break|break;
block|}
operator|*
name|sp
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
name|c
condition|)
do|;
operator|*
name|sp
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
case|case
literal|'%'
case|:
case|case
name|MARK
operator||
literal|'%'
case|:
block|{
name|sp
operator|+=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|sp
expr_stmt|;
while|while
condition|(
name|sp
operator|>=
name|string
condition|)
block|{
if|if
condition|(
name|gmatch
argument_list|(
name|sp
argument_list|,
name|pat
argument_list|)
condition|)
block|{
name|cp
operator|=
name|sp
expr_stmt|;
if|if
condition|(
name|flag
operator|==
literal|'%'
condition|)
break|break;
block|}
name|sp
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE
if|if
condition|(
operator|*
name|sp
operator|&
name|HIGHBIT
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|sp
operator|-
name|in_csize
argument_list|(
literal|3
argument_list|)
operator|)
operator|==
name|ESS3
condition|)
name|sp
operator|-=
name|in_csize
argument_list|(
literal|3
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|(
name|sp
operator|-
name|in_csize
argument_list|(
literal|2
argument_list|)
operator|)
operator|==
name|ESS2
condition|)
name|sp
operator|-=
name|in_csize
argument_list|(
literal|2
argument_list|)
expr_stmt|;
else|else
name|sp
operator|-=
operator|(
name|in_csize
argument_list|(
literal|1
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MULTIBYTE */
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|string
operator|)
return|;
block|}
block|}
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * do parameter and command substitution and strip of quotes  * attempt file name expansion if<type> not zero  */
end_comment

begin_function
name|char
modifier|*
name|mactrim
parameter_list|(
name|s
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|t
init|=
name|macro
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|ARGPTR
name|schain
init|=
name|gchain
decl_stmt|;
if|if
condition|(
name|type
operator|&&
name|f_complete
argument_list|(
name|t
argument_list|,
name|nullstr
argument_list|)
operator|==
literal|1
condition|)
name|t
operator|=
name|gchain
operator|->
name|argval
expr_stmt|;
name|gchain
operator|=
name|schain
expr_stmt|;
name|trim
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * perform only parameter substitution and catch failures  */
end_comment

begin_function
name|char
modifier|*
name|mactry
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|mac_try
operator|++
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|mac_buf
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|=
name|mactrim
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mac_try
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mac_error
parameter_list|()
block|{
if|if
condition|(
name|mac_try
condition|)
name|longjmp
argument_list|(
name|mac_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|badsub
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE
end_ifdef

begin_function
specifier|static
name|int
name|charlen
parameter_list|(
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|int
name|n
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
name|c
operator|=
name|echarset
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
comment|/* find character set */
name|str
operator|+=
operator|(
name|in_csize
argument_list|(
name|c
argument_list|)
operator|+
operator|(
name|c
operator|>=
literal|2
operator|)
operator|)
expr_stmt|;
comment|/* move to next char */
name|n
operator|+=
name|out_csize
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* add character size */
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MULTIBYTE */
end_comment

end_unit

