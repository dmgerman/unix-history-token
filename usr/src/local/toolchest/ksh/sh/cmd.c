begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   *      Copyright (c) 1984, 1985, 1986 AT&T  *      All Rights Reserved   *      THIS IS UNPUBLISHED PROPRIETARY SOURCE   *      CODE OF AT&T.  *      The copyright notice above does not   *      evidence any actual or intended  *      publication of such source code.   */
end_comment

begin_comment
comment|/* @(#)cmd.c	1.1 */
end_comment

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * Rewritten by David Korn  * AT&T Bell Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"name.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_include
include|#
directive|include
file|"mode.h"
end_include

begin_include
include|#
directive|include
file|"stak.h"
end_include

begin_include
include|#
directive|include
file|"shtype.h"
end_include

begin_include
include|#
directive|include
file|"brkincr.h"
end_include

begin_include
include|#
directive|include
file|"builtins.h"
end_include

begin_comment
comment|/* These routines are defined by this module */
end_comment

begin_function_decl
name|void
name|synbad
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|TREPTR
name|cmd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|TREPTR
name|makefork
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* These routines are referenced by this module */
end_comment

begin_function_decl
specifier|extern
name|void
name|addblok
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|chkpr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|exitsh
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|STKPTR
name|getstak
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|hist_cancel
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|hist_flush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|hist_position
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|movstr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_setout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_str
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_prp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|p_num
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|TREPTR
name|makelist
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ARGPTR
name|qscan
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|IOPTR
name|inout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chkword
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chkflags
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chksym
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|TREPTR
name|term
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|TREPTR
name|list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|REGPTR
name|syncase
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|TREPTR
name|item
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|skipnl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prsym
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|heredoc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ========	command line decoding	========  *  *  This is the parser for a shell command line  */
end_comment

begin_comment
comment|/*  * Make a node which will cause the shell to fork  */
end_comment

begin_function
name|TREPTR
name|makefork
parameter_list|(
name|flgs
parameter_list|,
name|i
parameter_list|)
name|int
name|flgs
decl_stmt|;
name|TREPTR
name|i
decl_stmt|;
block|{
specifier|register
name|FORKPTR
name|t
decl_stmt|;
name|t
operator|=
operator|(
name|FORKPTR
operator|)
name|getstak
argument_list|(
name|FORKTYPE
argument_list|)
expr_stmt|;
name|t
operator|->
name|forktyp
operator|=
name|flgs
operator||
name|TFORK
expr_stmt|;
name|t
operator|->
name|forktre
operator|=
name|i
expr_stmt|;
name|t
operator|->
name|forkio
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|(
name|TREPTR
operator|)
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Make a node corresponding to a command list  */
end_comment

begin_function
specifier|static
name|TREPTR
name|makelist
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|,
name|r
parameter_list|)
name|int
name|type
decl_stmt|;
name|TREPTR
name|i
decl_stmt|,
name|r
decl_stmt|;
block|{
specifier|register
name|LSTPTR
name|t
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|r
operator|==
literal|0
condition|)
name|synbad
argument_list|()
expr_stmt|;
else|else
block|{
name|t
operator|=
operator|(
name|LSTPTR
operator|)
name|getstak
argument_list|(
name|LSTTYPE
argument_list|)
expr_stmt|;
name|t
operator|->
name|lsttyp
operator|=
name|type
expr_stmt|;
name|t
operator|->
name|lstlef
operator|=
name|i
expr_stmt|;
name|t
operator|->
name|lstrit
operator|=
name|r
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|TREPTR
operator|)
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cmd  *	empty  *	list  *	list& [ cmd ]  *	list [ ; cmd ]  */
end_comment

begin_function
name|TREPTR
name|cmd
parameter_list|(
name|sym
parameter_list|,
name|flg
parameter_list|)
specifier|register
name|int
name|sym
decl_stmt|;
name|int
name|flg
decl_stmt|;
block|{
specifier|register
name|int
name|flag
init|=
name|FINT
operator||
name|FPRS
operator||
name|FAMP
decl_stmt|;
specifier|register
name|TREPTR
name|i
decl_stmt|,
name|e
decl_stmt|;
name|IOPTR
name|saviotemp
init|=
name|iotemp
decl_stmt|;
comment|/* parser output goes on standard error */
name|p_setout
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|i
operator|=
name|list
argument_list|(
name|flg
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdval
operator|==
name|NL
condition|)
block|{
if|if
condition|(
name|flg
operator|&
name|NLFLG
condition|)
block|{
name|wdval
operator|=
literal|';'
expr_stmt|;
name|chkpr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|(
name|flg
operator|&
name|MTFLG
operator|)
operator|==
literal|0
condition|)
name|synbad
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|wdval
condition|)
block|{
case|case
name|COOPSYM
case|:
comment|/* set up a cooperating process */
name|flag
operator||=
name|FPIN
operator||
name|FPOU
expr_stmt|;
case|case
literal|'&'
case|:
if|if
condition|(
name|i
condition|)
block|{
if|if
condition|(
name|saviotemp
operator|!=
name|iotemp
operator|||
name|heredoc
condition|)
name|flag
operator||=
name|FTMP
expr_stmt|;
name|i
operator|=
operator|(
name|TREPTR
operator|)
name|makefork
argument_list|(
name|flag
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|synbad
argument_list|()
expr_stmt|;
case|case
literal|';'
case|:
if|if
condition|(
name|e
operator|=
name|cmd
argument_list|(
name|sym
argument_list|,
name|flg
operator||
name|MTFLG
argument_list|)
condition|)
name|i
operator|=
operator|(
name|TREPTR
operator|)
name|makelist
argument_list|(
name|TLST
argument_list|,
name|i
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|EOFSYM
case|:
if|if
condition|(
name|sym
operator|==
name|NL
condition|)
break|break;
default|default:
if|if
condition|(
name|sym
condition|)
name|chksym
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
comment|/* restore output stream */
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * list  *	term  *	list&& term  *	list || term  */
end_comment

begin_function
specifier|static
name|TREPTR
name|list
parameter_list|(
name|flg
parameter_list|)
block|{
specifier|register
name|TREPTR
name|r
decl_stmt|;
specifier|register
name|int
name|b
decl_stmt|;
name|r
operator|=
name|term
argument_list|(
name|flg
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|&&
operator|(
operator|(
name|b
operator|=
operator|(
name|wdval
operator|==
name|ANDFSYM
operator|)
operator|)
operator|||
name|wdval
operator|==
name|ORFSYM
operator|)
condition|)
block|{
name|r
operator|=
name|makelist
argument_list|(
operator|(
name|b
condition|?
name|TAND
else|:
name|TORF
operator|)
argument_list|,
name|r
argument_list|,
name|term
argument_list|(
name|NLFLG
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * term  *	item  *	item |^ term  */
end_comment

begin_function
specifier|static
name|TREPTR
name|term
parameter_list|(
name|flg
parameter_list|)
specifier|register
name|int
name|flg
decl_stmt|;
block|{
specifier|register
name|TREPTR
name|t
decl_stmt|;
specifier|register
name|PARPTR
name|p
init|=
name|NULL
decl_stmt|;
name|heredoc
operator|=
literal|0
expr_stmt|;
name|reserv
operator|++
expr_stmt|;
if|if
condition|(
name|flg
operator|&
name|NLFLG
condition|)
name|skipnl
argument_list|()
expr_stmt|;
else|else
name|word
argument_list|()
expr_stmt|;
comment|/* check to see if pipeline is to be timed */
if|if
condition|(
name|wdval
operator|==
name|TIMSYM
condition|)
block|{
name|p
operator|=
operator|(
name|PARPTR
operator|)
name|getstak
argument_list|(
name|PARTYPE
argument_list|)
expr_stmt|;
name|p
operator|->
name|partyp
operator|=
name|TTIME
expr_stmt|;
name|reserv
operator|++
expr_stmt|;
name|word
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|t
operator|=
name|item
argument_list|(
name|NLFLG
operator||
name|MTFLG
argument_list|)
operator|)
operator|&&
name|wdval
operator|==
literal|'|'
condition|)
block|{
name|flg
operator|=
name|heredoc
operator||
name|FPOU
expr_stmt|;
name|t
operator|=
name|makelist
argument_list|(
name|TFIL
argument_list|,
name|makefork
argument_list|(
name|flg
argument_list|,
name|t
argument_list|)
argument_list|,
name|makefork
argument_list|(
name|FPIN
operator||
name|FPCL
argument_list|,
name|term
argument_list|(
name|NLFLG
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
condition|)
block|{
name|p
operator|->
name|partre
operator|=
name|t
expr_stmt|;
return|return
operator|(
operator|(
name|TREPTR
operator|)
name|p
operator|)
return|;
block|}
else|else
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * case statement  */
end_comment

begin_function
specifier|static
name|REGPTR
name|syncase
parameter_list|(
name|esym
parameter_list|)
specifier|register
name|int
name|esym
decl_stmt|;
block|{
name|wdset
operator||=
name|E_FLAG
expr_stmt|;
comment|/* set to avoid aliasing expressions */
name|skipnl
argument_list|()
expr_stmt|;
if|if
condition|(
name|wdval
operator|==
name|esym
condition|)
block|{
name|wdset
operator|&=
operator|~
name|E_FLAG
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
specifier|register
name|REGPTR
name|r
init|=
operator|(
name|REGPTR
operator|)
name|getstak
argument_list|(
name|REGTYPE
argument_list|)
decl_stmt|;
name|r
operator|->
name|regptr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|chkflags
argument_list|(
name|wdarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wdarg
operator|->
name|argnxt
operator|=
name|r
operator|->
name|regptr
expr_stmt|;
name|r
operator|->
name|regptr
operator|=
name|wdarg
expr_stmt|;
if|if
condition|(
name|wdval
operator|==
literal|')'
operator|||
name|wdval
operator|==
literal|'|'
operator|||
operator|(
name|word
argument_list|()
operator|!=
literal|')'
operator|&&
name|wdval
operator|!=
literal|'|'
operator|)
condition|)
name|synbad
argument_list|()
expr_stmt|;
if|if
condition|(
name|wdval
operator|==
literal|'|'
condition|)
name|word
argument_list|()
expr_stmt|;
else|else
break|break;
block|}
name|wdset
operator|&=
operator|~
name|E_FLAG
expr_stmt|;
name|r
operator|->
name|regcom
operator|=
name|cmd
argument_list|(
literal|0
argument_list|,
name|NLFLG
operator||
name|MTFLG
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdval
operator|==
name|ECSYM
condition|)
name|r
operator|->
name|regnxt
operator|=
name|syncase
argument_list|(
name|esym
argument_list|)
expr_stmt|;
else|else
block|{
name|chksym
argument_list|(
name|esym
argument_list|)
expr_stmt|;
name|r
operator|->
name|regnxt
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * item  *  *	( cmd ) [< in ] [> out ]  *	word word* [< in ] [> out ]  *	if ... then ... else ... fi  *	for ... while ... do ... done  *	case ... in ... esac  *	begin ... end  */
end_comment

begin_function
specifier|static
name|TREPTR
name|item
parameter_list|(
name|flag
parameter_list|)
name|BOOL
name|flag
decl_stmt|;
block|{
specifier|register
name|TREPTR
name|t
decl_stmt|;
specifier|register
name|IOPTR
name|io
decl_stmt|;
if|if
condition|(
name|flag
condition|)
name|io
operator|=
name|inout
argument_list|(
operator|(
name|IOPTR
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|io
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|wdval
condition|)
block|{
comment|/* case statement */
case|case
name|CASYM
case|:
block|{
name|t
operator|=
operator|(
name|TREPTR
operator|)
name|getstak
argument_list|(
name|SWTYPE
argument_list|)
expr_stmt|;
name|chkword
argument_list|()
expr_stmt|;
operator|(
operator|(
name|SWPTR
operator|)
name|t
operator|)
operator|->
name|swarg
operator|=
name|wdarg
operator|->
name|argval
expr_stmt|;
name|skipnl
argument_list|()
expr_stmt|;
name|chksym
argument_list|(
name|INSYM
operator||
name|BRSYM
argument_list|)
expr_stmt|;
operator|(
operator|(
name|SWPTR
operator|)
name|t
operator|)
operator|->
name|swlst
operator|=
name|syncase
argument_list|(
name|wdval
operator|==
name|INSYM
condition|?
name|ESSYM
else|:
name|KTSYM
argument_list|)
expr_stmt|;
operator|(
operator|(
name|SWPTR
operator|)
name|t
operator|)
operator|->
name|swtyp
operator|=
name|TSW
expr_stmt|;
break|break;
block|}
comment|/* if statement */
case|case
name|IFSYM
case|:
block|{
specifier|register
name|int
name|w
decl_stmt|;
name|t
operator|=
operator|(
name|TREPTR
operator|)
name|getstak
argument_list|(
name|IFTYPE
argument_list|)
expr_stmt|;
operator|(
operator|(
name|IFPTR
operator|)
name|t
operator|)
operator|->
name|iftyp
operator|=
name|TIF
expr_stmt|;
operator|(
operator|(
name|IFPTR
operator|)
name|t
operator|)
operator|->
name|iftre
operator|=
name|cmd
argument_list|(
name|THSYM
argument_list|,
name|NLFLG
argument_list|)
expr_stmt|;
operator|(
operator|(
name|IFPTR
operator|)
name|t
operator|)
operator|->
name|thtre
operator|=
name|cmd
argument_list|(
name|ELSYM
operator||
name|FISYM
operator||
name|EFSYM
argument_list|,
name|NLFLG
argument_list|)
expr_stmt|;
operator|(
operator|(
name|IFPTR
operator|)
name|t
operator|)
operator|->
name|eltre
operator|=
operator|(
operator|(
name|w
operator|=
name|wdval
operator|)
operator|==
name|ELSYM
condition|?
name|cmd
argument_list|(
name|FISYM
argument_list|,
name|NLFLG
argument_list|)
else|:
operator|(
name|w
operator|==
name|EFSYM
condition|?
operator|(
name|wdval
operator|=
name|IFSYM
operator|,
name|item
argument_list|(
literal|0
argument_list|)
operator|)
else|:
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|EFSYM
condition|)
return|return
operator|(
name|t
operator|)
return|;
break|break;
block|}
comment|/* for and select statement */
case|case
name|FORSYM
case|:
case|case
name|SELSYM
case|:
block|{
name|t
operator|=
operator|(
name|TREPTR
operator|)
name|getstak
argument_list|(
name|FORTYPE
argument_list|)
expr_stmt|;
operator|(
operator|(
name|FORPTR
operator|)
name|t
operator|)
operator|->
name|fortyp
operator|=
operator|(
name|wdval
operator|==
name|FORSYM
condition|?
name|TFOR
else|:
name|TSELECT
operator|)
expr_stmt|;
operator|(
operator|(
name|FORPTR
operator|)
name|t
operator|)
operator|->
name|forlst
operator|=
literal|0
expr_stmt|;
name|chkword
argument_list|()
expr_stmt|;
operator|(
operator|(
name|FORPTR
operator|)
name|t
operator|)
operator|->
name|fornam
operator|=
operator|(
name|char
operator|*
operator|)
name|wdarg
operator|->
name|argval
expr_stmt|;
if|if
condition|(
name|skipnl
argument_list|()
operator|==
name|INSYM
condition|)
block|{
name|chkword
argument_list|()
expr_stmt|;
operator|(
operator|(
name|FORPTR
operator|)
name|t
operator|)
operator|->
name|forlst
operator|=
operator|(
name|COMPTR
operator|)
name|item
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdval
operator|!=
name|NL
operator|&&
name|wdval
operator|!=
literal|';'
condition|)
name|synbad
argument_list|()
expr_stmt|;
if|if
condition|(
name|wdval
operator|==
name|NL
condition|)
name|chkpr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|skipnl
argument_list|()
expr_stmt|;
block|}
comment|/* 'for i;do cmd' is valid syntax */
elseif|else
if|if
condition|(
name|wdval
operator|==
literal|';'
condition|)
block|{
name|reserv
operator|=
literal|1
expr_stmt|;
name|word
argument_list|()
expr_stmt|;
block|}
name|chksym
argument_list|(
name|DOSYM
operator||
name|BRSYM
argument_list|)
expr_stmt|;
operator|(
operator|(
name|FORPTR
operator|)
name|t
operator|)
operator|->
name|fortre
operator|=
name|cmd
argument_list|(
name|wdval
operator|==
name|DOSYM
condition|?
name|ODSYM
else|:
name|KTSYM
argument_list|,
name|NLFLG
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* This is the code for parsing function definitions */
case|case
name|PROCSYM
case|:
name|funct_5_2
label|:
block|{
name|TREPTR
name|cmdptr
decl_stmt|;
name|BLKPTR
name|blokptr
decl_stmt|;
name|int
name|savstates
init|=
name|states
decl_stmt|;
name|int
name|saveline
init|=
name|firstline
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fd
init|=
name|NULL
decl_stmt|;
name|IOPTR
name|saviotemp
init|=
name|iotemp
decl_stmt|;
name|t
operator|=
operator|(
name|TREPTR
operator|)
name|getstak
argument_list|(
name|PROCTYPE
argument_list|)
expr_stmt|;
operator|(
operator|(
name|PROCPTR
operator|)
name|t
operator|)
operator|->
name|proctyp
operator|=
name|TPROC
expr_stmt|;
operator|(
operator|(
name|PROCPTR
operator|)
name|t
operator|)
operator|->
name|procloc
operator|=
operator|-
literal|1
expr_stmt|;
name|firstline
operator|=
name|standin
operator|->
name|flin
expr_stmt|;
if|if
condition|(
name|wdval
operator|==
name|PROCSYM
condition|)
name|chkword
argument_list|()
expr_stmt|;
operator|(
operator|(
name|PROCPTR
operator|)
name|t
operator|)
operator|->
name|procnam
operator|=
operator|(
name|char
operator|*
operator|)
name|wdarg
operator|->
name|argval
expr_stmt|;
name|skipnl
argument_list|()
expr_stmt|;
name|chksym
argument_list|(
name|BRSYM
argument_list|)
expr_stmt|;
comment|/* force a new stak frame to compile the command */
name|addblok
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_option
argument_list|(
name|INTFLG
argument_list|)
condition|)
block|{
comment|/* just in case history file not open yet */
name|hist_open
argument_list|()
expr_stmt|;
if|if
condition|(
name|fc_fix
condition|)
block|{
name|fd
operator|=
name|fc_fix
operator|->
name|fixfd
expr_stmt|;
name|states
operator||=
name|FIXFLG
expr_stmt|;
operator|(
operator|(
name|PROCPTR
operator|)
name|t
operator|)
operator|->
name|procloc
operator|=
name|hist_position
argument_list|(
name|fc_fix
operator|->
name|fixind
argument_list|)
operator|+
name|fd
operator|->
name|_ptr
operator|-
name|fd
operator|->
name|_base
expr_stmt|;
block|}
block|}
name|cmdptr
operator|=
name|cmd
argument_list|(
name|KTSYM
argument_list|,
name|NLFLG
argument_list|)
expr_stmt|;
comment|/* force another stak frame to save the command */
name|addblok
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|blokptr
operator|=
name|stakbsy
expr_stmt|;
name|stakbsy
operator|=
name|stakbsy
operator|->
name|word
expr_stmt|;
comment|/* save the entry point in block */
name|blokptr
operator|->
name|word
operator|=
name|BLK
argument_list|(
name|cmdptr
argument_list|)
expr_stmt|;
operator|(
operator|(
name|PROCPTR
operator|)
name|t
operator|)
operator|->
name|proctre
operator|=
name|blokptr
expr_stmt|;
if|if
condition|(
name|iotemp
operator|!=
name|saviotemp
condition|)
block|{
name|iotemp
operator|=
name|saviotemp
expr_stmt|;
name|states
operator||=
name|RM_TMP
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|&&
operator|(
name|savstates
operator|&
name|FIXFLG
operator|)
operator|==
literal|0
condition|)
block|{
name|hist_flush
argument_list|()
expr_stmt|;
name|hist_cancel
argument_list|()
expr_stmt|;
name|states
operator|&=
operator|~
name|FIXFLG
expr_stmt|;
block|}
name|firstline
operator|=
name|saveline
expr_stmt|;
break|break;
block|}
comment|/* while and until */
case|case
name|WHSYM
case|:
case|case
name|UNSYM
case|:
block|{
name|t
operator|=
operator|(
name|TREPTR
operator|)
name|getstak
argument_list|(
name|WHTYPE
argument_list|)
expr_stmt|;
operator|(
operator|(
name|WHPTR
operator|)
name|t
operator|)
operator|->
name|whtyp
operator|=
operator|(
name|wdval
operator|==
name|WHSYM
condition|?
name|TWH
else|:
name|TUN
operator|)
expr_stmt|;
operator|(
operator|(
name|WHPTR
operator|)
name|t
operator|)
operator|->
name|whtre
operator|=
name|cmd
argument_list|(
name|DOSYM
argument_list|,
name|NLFLG
argument_list|)
expr_stmt|;
operator|(
operator|(
name|WHPTR
operator|)
name|t
operator|)
operator|->
name|dotre
operator|=
name|cmd
argument_list|(
name|ODSYM
argument_list|,
name|NLFLG
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* command group with { */
case|case
name|BRSYM
case|:
name|t
operator|=
name|cmd
argument_list|(
name|KTSYM
argument_list|,
name|NLFLG
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
block|{
specifier|register
name|PARPTR
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|PARPTR
operator|)
name|getstak
argument_list|(
name|PARTYPE
argument_list|)
expr_stmt|;
name|p
operator|->
name|partre
operator|=
name|cmd
argument_list|(
literal|')'
argument_list|,
name|NLFLG
argument_list|)
expr_stmt|;
name|p
operator|->
name|partyp
operator|=
name|TPAR
expr_stmt|;
name|t
operator|=
name|makefork
argument_list|(
literal|0
argument_list|,
operator|(
name|TREPTR
operator|)
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
if|if
condition|(
name|io
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* simple command */
case|case
literal|0
case|:
block|{
specifier|register
name|ARGPTR
name|argp
decl_stmt|;
specifier|register
name|ARGPTR
modifier|*
name|argtail
decl_stmt|;
specifier|register
name|ARGPTR
modifier|*
name|argset
init|=
literal|0
decl_stmt|;
name|int
name|keywd
init|=
name|KEYFLG
decl_stmt|;
name|int
name|argno
init|=
literal|0
decl_stmt|;
name|int
name|bltin
init|=
literal|0
decl_stmt|;
name|t
operator|=
operator|(
name|TREPTR
operator|)
name|getstak
argument_list|(
name|COMTYPE
argument_list|)
expr_stmt|;
operator|(
operator|(
name|COMPTR
operator|)
name|t
operator|)
operator|->
name|comio
operator|=
name|io
expr_stmt|;
comment|/*initial io chain*/
comment|/* set command line number for error messages */
operator|(
operator|(
name|COMPTR
operator|)
name|t
operator|)
operator|->
name|comline
operator|=
operator|(
name|exec_flag
condition|?
name|cmdline
else|:
name|standin
operator|->
name|flin
operator|-
name|firstline
operator|-
literal|1
operator|)
expr_stmt|;
name|argtail
operator|=
operator|&
operator|(
operator|(
operator|(
name|COMPTR
operator|)
name|t
operator|)
operator|->
name|comarg
operator|)
expr_stmt|;
while|while
condition|(
name|wdval
operator|==
literal|0
condition|)
block|{
name|argp
operator|=
name|wdarg
expr_stmt|;
name|argp
operator|->
name|argchn
operator|=
literal|0
expr_stmt|;
comment|/* test for keyword argument */
if|if
condition|(
name|wdset
operator|&
name|keywd
condition|)
block|{
name|chkflags
argument_list|(
name|argp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argp
operator|->
name|argnxt
operator|=
operator|(
name|ARGPTR
operator|)
name|argset
expr_stmt|;
name|argset
operator|=
operator|(
name|ARGPTR
operator|*
operator|)
name|argp
expr_stmt|;
comment|/* alias substitutions allowed */
name|wdset
operator||=
operator|(
name|KEYFLG
operator||
name|S_FLAG
operator|)
expr_stmt|;
block|}
else|else
block|{
name|wdset
operator|=
literal|0
expr_stmt|;
comment|/* don't hunt for aliases*/
name|chkflags
argument_list|(
name|argp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|argp
operator|->
name|argflag
operator|&
name|A_RAW
operator|)
operator|==
literal|0
condition|)
name|argno
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|argno
operator|>=
literal|0
operator|&&
name|argno
operator|++
operator|==
literal|0
condition|)
block|{
comment|/* check for builtin command */
name|bltin
operator|=
name|syslook
argument_list|(
name|argp
operator|->
name|argval
argument_list|,
name|commands
argument_list|)
expr_stmt|;
block|}
operator|*
name|argtail
operator|=
name|argp
expr_stmt|;
name|argtail
operator|=
operator|&
operator|(
name|argp
operator|->
name|argnxt
operator|)
expr_stmt|;
name|wdset
operator|=
name|keywd
operator|=
name|is_option
argument_list|(
name|KEYFLG
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEVFD
name|retry
label|:
name|word
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|wdval
operator|&
name|STRIP
operator|)
operator|==
literal|'('
condition|)
block|{
name|TREPTR
name|t
decl_stmt|;
name|int
name|flag
init|=
operator|(
name|wdval
operator|==
name|OPROC
operator|)
decl_stmt|;
name|t
operator|=
name|cmd
argument_list|(
literal|')'
argument_list|,
name|NLFLG
operator||
operator|(
name|argno
operator|==
literal|1
operator|&&
name|wdval
operator|==
literal|'('
condition|?
name|MTFLG
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
name|wdarg
operator|=
name|argp
expr_stmt|;
goto|goto
name|funct_5_2
goto|;
block|}
name|argp
operator|=
operator|(
name|ARGPTR
operator|)
name|locstak
argument_list|()
expr_stmt|;
name|argno
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|argtail
operator|=
name|argp
expr_stmt|;
name|argtail
operator|=
operator|&
operator|(
name|argp
operator|->
name|argnxt
operator|)
expr_stmt|;
name|endstak
argument_list|(
name|movstr
argument_list|(
name|nullstr
argument_list|,
name|argp
operator|->
name|argval
argument_list|)
argument_list|)
expr_stmt|;
name|argp
operator|->
name|argchn
operator|=
operator|(
name|ARGPTR
operator|)
name|makefork
argument_list|(
name|flag
condition|?
name|FPIN
operator||
name|FAMP
operator||
name|FPCL
else|:
name|FPOU
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|argp
operator|->
name|argflag
operator|=
operator|(
name|A_EXP
operator||
name|flag
operator|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
else|#
directive|else
name|word
argument_list|()
expr_stmt|;
if|if
condition|(
name|argno
operator|==
literal|1
operator|&&
name|argset
operator|==
name|NULL
operator|&&
name|wdval
operator|==
literal|'('
condition|)
block|{
comment|/* SVR2 style function */
name|word
argument_list|()
expr_stmt|;
if|if
condition|(
name|wdval
operator|==
literal|')'
condition|)
block|{
name|wdarg
operator|=
name|argp
expr_stmt|;
goto|goto
name|funct_5_2
goto|;
block|}
name|wdval
operator|=
literal|'('
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEVFD */
if|if
condition|(
name|flag
condition|)
block|{
if|if
condition|(
name|io
condition|)
block|{
while|while
condition|(
name|io
operator|->
name|ionxt
condition|)
name|io
operator|=
name|io
operator|->
name|ionxt
expr_stmt|;
name|io
operator|->
name|ionxt
operator|=
name|inout
argument_list|(
operator|(
name|IOPTR
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
operator|(
name|COMPTR
operator|)
name|t
operator|)
operator|->
name|comio
operator|=
name|io
operator|=
name|inout
argument_list|(
operator|(
name|IOPTR
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|argtail
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|COMPTR
operator|)
name|t
operator|)
operator|->
name|comtyp
operator|=
operator|(
name|TCOM
operator||
operator|(
name|bltin
operator|<<
operator|(
name|COMBITS
operator|+
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* expand argument list if possible */
if|if
condition|(
name|argno
operator|>
literal|0
condition|)
operator|(
operator|(
name|COMPTR
operator|)
name|t
operator|)
operator|->
name|comarg
operator|=
name|qscan
argument_list|(
name|t
argument_list|,
name|argno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|COMPTR
operator|)
name|t
operator|)
operator|->
name|comarg
condition|)
operator|(
operator|(
name|COMPTR
operator|)
name|t
operator|)
operator|->
name|comtyp
operator||=
name|COMSCAN
expr_stmt|;
operator|(
operator|(
name|COMPTR
operator|)
name|t
operator|)
operator|->
name|comset
operator|=
operator|(
name|ARGPTR
operator|)
name|argset
expr_stmt|;
name|wdset
operator|&=
operator|~
name|S_FLAG
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
block|}
name|reserv
operator|++
expr_stmt|;
name|word
argument_list|()
expr_stmt|;
if|if
condition|(
name|io
operator|=
name|inout
argument_list|(
name|io
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|type
init|=
name|t
operator|->
name|tretyp
operator|&
name|COMMSK
decl_stmt|;
name|t
operator|=
name|makefork
argument_list|(
literal|0
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|->
name|treio
operator|=
name|io
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TFORK
condition|)
name|t
operator|->
name|tretyp
operator|=
name|TSETIO
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * skip past newlines but issue prompt if interactive  */
end_comment

begin_function
specifier|static
name|int
name|skipnl
parameter_list|()
block|{
while|while
condition|(
operator|(
name|reserv
operator|++
operator|,
name|word
argument_list|()
operator|==
name|NL
operator|)
condition|)
name|chkpr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|wdval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * check for and process and i/o redirections  * if flag is set then an alias can be in the next word  */
end_comment

begin_function
specifier|static
name|IOPTR
name|inout
parameter_list|(
name|lastio
parameter_list|,
name|flag
parameter_list|)
name|IOPTR
name|lastio
decl_stmt|;
block|{
specifier|register
name|int
name|iof
decl_stmt|;
specifier|register
name|IOPTR
name|iop
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|iof
operator|=
name|wdnum
expr_stmt|;
switch|switch
condition|(
name|wdval
condition|)
block|{
case|case
name|DOCSYM
case|:
comment|/*<<	*/
name|iof
operator||=
name|IODOC
expr_stmt|;
name|heredoc
operator|=
name|FTMP
expr_stmt|;
break|break;
case|case
name|APPSYM
case|:
comment|/*>>	*/
case|case
literal|'>'
case|:
if|if
condition|(
name|wdnum
operator|==
literal|0
condition|)
name|iof
operator||=
literal|1
expr_stmt|;
name|iof
operator||=
name|IOPUT
expr_stmt|;
if|if
condition|(
name|wdval
operator|==
name|APPSYM
condition|)
block|{
name|iof
operator||=
name|IOAPP
expr_stmt|;
break|break;
block|}
case|case
literal|'<'
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|nextc
argument_list|()
operator|)
operator|==
literal|'&'
condition|)
name|iof
operator||=
name|IOMOV
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
comment|/*<> is open for read and write	*/
comment|/*	unadvertised feature		*/
name|iof
operator||=
name|IORDW
expr_stmt|;
else|else
name|peekn
operator|=
name|c
operator||
name|MARK
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|lastio
operator|)
return|;
block|}
name|chkword
argument_list|()
expr_stmt|;
name|iop
operator|=
operator|(
name|IOPTR
operator|)
name|getstak
argument_list|(
name|IOTYPE
argument_list|)
expr_stmt|;
name|iop
operator|->
name|ioname
operator|=
name|wdarg
operator|->
name|argval
expr_stmt|;
name|iop
operator|->
name|iofile
operator|=
name|iof
expr_stmt|;
if|if
condition|(
name|iof
operator|&
name|IODOC
condition|)
block|{
name|iop
operator|->
name|iolst
operator|=
name|iopend
expr_stmt|;
name|iopend
operator|=
name|iop
expr_stmt|;
block|}
name|word
argument_list|()
expr_stmt|;
name|iop
operator|->
name|ionxt
operator|=
name|inout
argument_list|(
name|lastio
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* allow alias substitutions */
if|if
condition|(
name|flag
condition|)
name|wdset
operator||=
name|S_FLAG
expr_stmt|;
return|return
operator|(
name|iop
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * get next token and make sure that it is not a keyword or meta-character  */
end_comment

begin_function
specifier|static
name|void
name|chkword
parameter_list|()
block|{
if|if
condition|(
name|word
argument_list|()
condition|)
name|synbad
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * see if this token is syntactically correct  */
end_comment

begin_function
specifier|static
name|void
name|chksym
parameter_list|(
name|sym
parameter_list|)
specifier|register
name|int
name|sym
decl_stmt|;
block|{
specifier|register
name|int
name|x
init|=
name|sym
operator|&
name|wdval
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|x
operator|&
name|SYMFLG
operator|)
condition|?
name|x
else|:
name|sym
operator|)
operator|!=
name|wdval
condition|)
name|synbad
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * print the name of a syntactic token  */
end_comment

begin_function
specifier|static
name|void
name|prsym
parameter_list|(
name|sym
parameter_list|)
specifier|register
name|int
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|sym
operator|&
name|SYMFLG
condition|)
block|{
specifier|register
name|SYSPTR
name|sp
init|=
name|reserved
decl_stmt|;
while|while
condition|(
name|sp
operator|->
name|sysval
operator|&&
name|sp
operator|->
name|sysval
operator|!=
name|sym
condition|)
name|sp
operator|++
expr_stmt|;
name|fputs
argument_list|(
name|sp
operator|->
name|sysnam
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym
operator|==
name|EOFSYM
condition|)
name|fputs
argument_list|(
name|endoffile
argument_list|,
name|output
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sym
operator|&
name|SYMREP
condition|)
name|putc
argument_list|(
name|sym
argument_list|,
name|output
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NL
condition|)
name|fputs
argument_list|(
literal|"newline or ;"
argument_list|,
name|output
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
name|sym
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\''
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * print a bad syntax message  */
end_comment

begin_function
name|void
name|synbad
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|unexpected
decl_stmt|;
specifier|register
name|int
name|w
init|=
name|wdval
decl_stmt|;
name|p_setout
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|p_prp
argument_list|(
name|synmsg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|states
operator|&
name|TTYFLG
operator|)
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
name|atline
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|p_num
argument_list|(
operator|(
name|int
operator|)
name|standin
operator|->
name|flin
argument_list|,
name|SP
argument_list|)
expr_stmt|;
block|}
name|p_str
argument_list|(
name|colon
argument_list|,
literal|'`'
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
condition|)
name|prsym
argument_list|(
name|w
argument_list|)
expr_stmt|;
else|else
name|p_str
argument_list|(
name|wdarg
operator|->
name|argval
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|w
operator|&
name|EOFSYM
operator|)
operator|&&
name|w
operator|!=
name|EOFSYM
condition|)
name|cp
operator|=
name|unmatched
expr_stmt|;
name|p_str
argument_list|(
name|cp
argument_list|,
name|NL
argument_list|)
expr_stmt|;
name|hist_flush
argument_list|()
expr_stmt|;
name|exitsh
argument_list|(
name|SYNBAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * check argument for possible optimizations  * in many cases we can skip macro and file name expansion  * The fexp flag is set when file expansion is possible  */
end_comment

begin_define
define|#
directive|define
name|EXP_MACRO
value|2
end_define

begin_comment
comment|/* macro expansion needed */
end_comment

begin_define
define|#
directive|define
name|EXP_TRIM
value|4
end_define

begin_comment
comment|/* quoted characters in string */
end_comment

begin_define
define|#
directive|define
name|EXP_FILE
value|8
end_define

begin_comment
comment|/* file expansion characters*/
end_comment

begin_define
define|#
directive|define
name|EXP_QUOTE
value|16
end_define

begin_comment
comment|/* string contains " character */
end_comment

begin_function
specifier|static
name|void
name|chkflags
parameter_list|(
name|argp
parameter_list|,
name|fexp
parameter_list|)
specifier|register
name|ARGPTR
name|argp
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|argp
operator|->
name|argflag
operator|=
literal|0
expr_stmt|;
block|{
specifier|register
name|int
name|flag
init|=
literal|0
decl_stmt|;
name|char
name|nquote
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|sp
init|=
name|argp
operator|->
name|argval
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|sp
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|ESCAPE
condition|)
block|{
name|flag
operator||=
name|EXP_TRIM
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isexp
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'$'
operator|||
name|c
operator|==
literal|'`'
condition|)
block|{
name|flag
operator||=
name|EXP_MACRO
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'`'
condition|)
name|subflag
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nquote
operator|==
literal|0
condition|)
block|{
comment|/* special case of '[' */
if|if
condition|(
operator|*
name|sp
operator|||
name|c
operator|!=
literal|'['
condition|)
name|flag
operator||=
name|EXP_FILE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
comment|/* toggle the quote count */
name|nquote
operator|=
literal|1
operator|-
name|nquote
expr_stmt|;
name|flag
operator||=
name|EXP_QUOTE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fexp
operator|==
literal|0
condition|)
name|flag
operator|&=
operator|~
name|EXP_FILE
expr_stmt|;
comment|/* return if no macro expansion, file expansion or trimming required */
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
block|{
name|argp
operator|->
name|argflag
operator||=
name|A_RAW
expr_stmt|;
return|return;
block|}
comment|/* return if macro or command substitution needed */
if|if
condition|(
name|flag
operator|&
name|EXP_MACRO
condition|)
block|{
name|argp
operator|->
name|argflag
operator||=
operator|(
name|A_MAC
operator||
name|A_EXP
operator|)
expr_stmt|;
return|return;
block|}
comment|/* check to see if file expansion is required */
if|if
condition|(
name|flag
operator|&
name|EXP_FILE
condition|)
block|{
name|argp
operator|->
name|argflag
operator||=
name|A_EXP
expr_stmt|;
comment|/* return if no quotes otherwise don't optimize */
if|if
condition|(
name|flag
operator|&
operator|(
name|EXP_QUOTE
operator||
name|EXP_TRIM
operator|)
condition|)
block|{
name|argp
operator|->
name|argflag
operator|=
name|A_MAC
expr_stmt|;
return|return;
block|}
return|return;
block|}
name|argp
operator|->
name|argflag
operator||=
name|A_RAW
expr_stmt|;
block|}
comment|/* just get rid of quoting stuff and consider argument as expanded */
block|{
specifier|register
name|char
modifier|*
name|dp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|char
name|nquote
init|=
literal|0
decl_stmt|;
comment|/* set within quoted string */
name|dp
operator|=
name|sp
operator|=
name|argp
operator|->
name|argval
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|sp
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|ESCAPE
condition|)
block|{
comment|/* strip escchar's in double quotes */
name|c
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
if|if
condition|(
name|nquote
operator|&&
operator|!
name|escchar
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'"'
condition|)
operator|*
name|dp
operator|++
operator|=
name|ESCAPE
expr_stmt|;
block|}
operator|*
name|dp
operator|++
operator|=
name|c
expr_stmt|;
block|}
else|else
comment|/* toggle quote marker */
name|nquote
operator|=
literal|1
operator|-
name|nquote
expr_stmt|;
block|}
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * convert argument chain to argument list when no special arguments  */
end_comment

begin_function
specifier|static
name|ARGPTR
name|qscan
parameter_list|(
name|ac
parameter_list|,
name|argn
parameter_list|)
name|COMPTR
name|ac
decl_stmt|;
name|int
name|argn
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
specifier|register
name|ARGPTR
name|ap
decl_stmt|;
specifier|register
name|DOLPTR
name|dp
decl_stmt|;
comment|/* leave space for an extra argument at the front */
name|dp
operator|=
operator|(
name|DOLPTR
operator|)
name|getstak
argument_list|(
operator|(
name|unsigned
operator|)
name|DOLTYPE
operator|+
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|+
name|argn
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|dp
operator|->
name|dolarg
operator|+
literal|1
expr_stmt|;
name|dp
operator|->
name|doluse
operator|=
name|argn
expr_stmt|;
name|ap
operator|=
name|ac
operator|->
name|comarg
expr_stmt|;
while|while
condition|(
name|ap
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|ap
operator|->
name|argval
expr_stmt|;
name|ap
operator|=
name|ap
operator|->
name|argnxt
expr_stmt|;
block|}
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|(
name|ARGPTR
operator|)
name|dp
operator|)
return|;
block|}
end_function

end_unit

