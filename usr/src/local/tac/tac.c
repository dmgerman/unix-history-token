begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)tac.c	1.3 %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * tac.c - Print file segments in reverse order  *  * Original line-only version by unknown author off the net.  * Rewritten in 1985 by Jay Lepreau, Univ of Utah, to allocate memory  * dynamically, handle string bounded segments (suggested by Rob Pike),  * and handle pipes.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/*  * This should be defined for BSD releases later than 4.2 and for Sys V.2,  * at least.  fwrite is faster than putc only if you have a new speedy fwrite.  */
end_comment

begin_define
define|#
directive|define
name|FAST_FWRITE
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* dbx can't handle registers */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|register
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Default target string and bound */
end_comment

begin_decl_stmt
name|int
name|right
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* right or left bounded segments? */
end_comment

begin_decl_stmt
name|char
modifier|*
name|targ
init|=
literal|"\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|readsize
init|=
literal|4096
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* significantly faster than 1024 */
end_comment

begin_decl_stmt
name|int
name|bufsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|targlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numerr
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|cleanup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|off_t
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|,
modifier|*
name|mktemp
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|isdigit
argument_list|(
operator|*
name|argv
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|readsize
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
operator|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
name|targ
operator|=
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|right
operator|=
operator|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
operator|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|targlen
operator|=
name|strlen
argument_list|(
name|targ
argument_list|)
expr_stmt|;
name|bufsize
operator|=
operator|(
name|readsize
operator|<<
literal|1
operator|)
operator|+
name|targlen
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|bufsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"tac: initial malloc"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|targ
argument_list|)
expr_stmt|;
comment|/* stop string at beginning */
name|buf
operator|+=
name|targlen
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|tacstdin
argument_list|()
expr_stmt|;
while|while
condition|(
operator|--
name|argc
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
operator|++
name|argv
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|tacstdin
argument_list|()
expr_stmt|;
else|else
name|tacit
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|numerr
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|tacstdin
argument_list|()
end_macro

begin_block
block|{
name|int
argument_list|(
operator|*
name|sigint
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|sighup
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|sigterm
argument_list|)
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|sigint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sighup
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sigterm
operator|=
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|savestdin
argument_list|()
expr_stmt|;
name|tacit
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigint
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|sighup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|sigterm
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
name|template
index|[]
init|=
literal|"/tmp/tacXXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|workplate
index|[
sizeof|sizeof
name|template
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|savestdin
argument_list|()
end_macro

begin_block
block|{
name|int
name|fd
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|strcpy
argument_list|(
name|workplate
argument_list|,
name|template
argument_list|)
expr_stmt|;
name|tfile
operator|=
name|mktemp
argument_list|(
name|workplate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|tfile
argument_list|,
literal|0600
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|prterr
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|readsize
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
block|{
name|prterr
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|prterr
argument_list|(
literal|"stdin read"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|tacit
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|pastend
decl_stmt|;
specifier|register
name|int
name|firstchar
decl_stmt|,
name|targm1len
decl_stmt|;
comment|/* target length minus 1 */
name|struct
name|stat
name|st
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|;
name|firstchar
operator|=
operator|*
name|targ
expr_stmt|;
name|targm1len
operator|=
name|targlen
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|prterr
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|numerr
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|off
operator|=
name|st
operator|.
name|st_size
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|prterr
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|numerr
operator|++
expr_stmt|;
return|return;
block|}
comment|/*      * Arrange for the first read to lop off enough to      * leave the rest of the file a multiple of readsize.      * Since readsize can change, this may not always hold during      * the pgm run, but since it usually will, leave it here      * for i/o efficiency (page/sector boundaries and all that).      * Note: the efficiency gain has not been verified.      */
if|if
condition|(
operator|(
name|i
operator|=
name|off
operator|%
name|readsize
operator|)
operator|==
literal|0
condition|)
name|i
operator|=
name|readsize
expr_stmt|;
name|off
operator|-=
name|i
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
name|off
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
block|{
name|prterr
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|numerr
operator|++
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|pastend
operator|=
name|buf
operator|+
name|i
expr_stmt|;
comment|/* pastend always points to end+1 */
name|p
operator|-=
name|targm1len
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
operator|--
name|p
operator|!=
name|firstchar
operator|||
operator|(
name|targm1len
operator|&&
name|strncmp
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|targ
operator|+
literal|1
argument_list|,
name|targm1len
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|p
operator|<
name|buf
condition|)
block|{
comment|/* backed off front of buffer */
if|if
condition|(
name|off
operator|==
literal|0
condition|)
block|{
comment|/* beginning of file: dump last segment */
name|output
argument_list|(
name|p
operator|+
name|targlen
argument_list|,
name|pastend
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|pastend
operator|-
name|buf
operator|)
operator|>
name|readsize
condition|)
block|{
name|char
modifier|*
name|tbuf
decl_stmt|;
name|int
name|newbufsize
init|=
operator|(
name|readsize
operator|<<
literal|2
operator|)
operator|+
name|targlen
operator|+
literal|2
decl_stmt|;
if|if
condition|(
operator|(
name|tbuf
operator|=
name|realloc
argument_list|(
name|buf
operator|-
name|targlen
argument_list|,
operator|(
name|unsigned
operator|)
name|newbufsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* If realloc fails, old buf contents may be lost. */
name|perror
argument_list|(
literal|"tac: segment too long; may have garbage here"
argument_list|)
expr_stmt|;
name|numerr
operator|++
expr_stmt|;
name|i
operator|=
name|readsize
expr_stmt|;
block|}
else|else
block|{
name|tbuf
operator|+=
name|targlen
expr_stmt|;
comment|/* skip over the stop string */
name|p
operator|+=
name|tbuf
operator|-
name|buf
expr_stmt|;
name|pastend
operator|+=
name|tbuf
operator|-
name|buf
expr_stmt|;
name|buf
operator|=
name|tbuf
expr_stmt|;
name|bufsize
operator|=
name|newbufsize
expr_stmt|;
name|readsize
operator|=
name|readsize
operator|<<
literal|1
expr_stmt|;
comment|/* guaranteed to fit now (I think!) */
block|}
block|}
if|if
condition|(
name|off
operator|-
name|readsize
operator|<
literal|0
condition|)
block|{
name|readsize
operator|=
name|off
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|off
operator|-=
name|readsize
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
name|off
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* back up */
comment|/* Shift pending old data right to make room for new */
name|bcopy
argument_list|(
name|buf
argument_list|,
name|p
operator|=
name|buf
operator|+
name|readsize
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|pastend
operator|=
name|p
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|readsize
argument_list|)
operator|!=
name|readsize
condition|)
block|{
name|prterr
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|numerr
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
comment|/* Found a real instance of the target string */
name|output
argument_list|(
name|right
condition|?
name|p
operator|+
name|targlen
else|:
name|p
argument_list|,
name|pastend
argument_list|)
expr_stmt|;
name|pastend
operator|=
name|p
expr_stmt|;
name|p
operator|-=
name|targm1len
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Dump chars from p to pastend-1.  If right-bounded by target  * and not the first time through, append the target string.  */
end_comment

begin_expr_stmt
name|output
argument_list|(
name|p
argument_list|,
name|pastend
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|pastend
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|short
name|first
init|=
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|FAST_FWRITE
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|pastend
operator|-
name|p
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
name|p
operator|<
name|pastend
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|*
name|p
operator|++
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|right
operator|&&
operator|!
name|first
condition|)
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|targ
argument_list|,
literal|1
argument_list|,
name|targlen
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
if|if ferror
condition|(
name|stdout
condition|)
block|{
name|perror
argument_list|(
literal|"tac: fwrite/putc"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|++
name|numerr
operator|>
literal|1
condition|?
name|numerr
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|prterr
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tac: "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cleanup
argument_list|()
end_macro

begin_block
block|{
name|unlink
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

