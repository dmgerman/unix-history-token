begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * (c) Copyright 1986, Xerox Corporation  *  * pl2ip: convert Unix plot format to and interpress master  *  * Generally, this program is straightforward.  The main complication comes  * from the desire to string contigious lines into one Interpress trajectory.  * The main modivation for this is to provide for nice dashed lines on printers  * that accept IP 3.0 and higher.  It can also be used to round the corners  * of other lines.  *  * HISTORY  * 22-Apr-86  Lee Moore (lee) at Xerox Webster Research Center  *	Created.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"iptokens.h"
end_include

begin_include
include|#
directive|include
file|"operator.h"
end_include

begin_include
include|#
directive|include
file|"literal.h"
end_include

begin_comment
comment|/* #define DEBUG  /* */
end_comment

begin_define
define|#
directive|define
name|MAXSTRINGSIZE
value|128
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|F_font
value|10
end_define

begin_define
define|#
directive|define
name|STROKE_WIDTH
value|15L
end_define

begin_comment
comment|/* was 50 */
end_comment

begin_comment
comment|/* width for drawing lines */
end_comment

begin_define
define|#
directive|define
name|STROKEEND_BUTT
value|1L
end_define

begin_comment
comment|/* end lines hard */
end_comment

begin_decl_stmt
name|int
name|HaveTrajectory
init|=
name|FALSE
decl_stmt|,
comment|/* is a trajectory being built? */
name|CurrentX
init|=
literal|0
decl_stmt|,
comment|/* the current X position */
name|CurrentY
init|=
literal|0
decl_stmt|,
comment|/* the current Y position */
name|Pitch
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pitch of the default font */
end_comment

begin_comment
comment|/*  * declare the Unix plot commands  */
end_comment

begin_define
define|#
directive|define
name|MOVECMD
value|'m'
end_define

begin_define
define|#
directive|define
name|CONTCMD
value|'n'
end_define

begin_define
define|#
directive|define
name|POINTCMD
value|'p'
end_define

begin_define
define|#
directive|define
name|LINECMD
value|'l'
end_define

begin_define
define|#
directive|define
name|LABELCMD
value|'t'
end_define

begin_define
define|#
directive|define
name|ARCCMD
value|'a'
end_define

begin_define
define|#
directive|define
name|CIRCLECMD
value|'c'
end_define

begin_define
define|#
directive|define
name|ERASECMD
value|'e'
end_define

begin_define
define|#
directive|define
name|LINEMODCMD
value|'f'
end_define

begin_define
define|#
directive|define
name|SPACECMD
value|'s'
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|outputName
init|=
name|NULL
decl_stmt|;
name|int
name|command
decl_stmt|,
name|ipFD
decl_stmt|,
name|textSize
init|=
literal|8
decl_stmt|,
comment|/* size of text (in points) */
name|c
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"o:s:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'o'
case|:
name|outputName
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|textSize
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|outputName
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ipFD
operator|=
name|creat
argument_list|(
name|outputName
argument_list|,
literal|0644
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pl2ip: can't open %s for writing\n"
argument_list|,
name|outputName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ipFD
operator|=
literal|1
expr_stmt|;
comment|/* std. output */
name|ip_select
argument_list|(
name|ipFD
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_beginBlock
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_beginBody
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_endBody
argument_list|)
expr_stmt|;
comment|/* end preamble */
name|AppendOp
argument_list|(
name|OP_beginBody
argument_list|)
expr_stmt|;
comment|/* begin page 1 */
ifdef|#
directive|ifdef
name|notdef
name|SetupFont
argument_list|(
literal|"Xerox/XC1-1-1/Classic"
argument_list|,
operator|(
literal|10.
operator|*
literal|2.54
operator|)
operator|/
operator|(
literal|72.0
operator|*
literal|100.0
operator|)
argument_list|,
name|F_font
argument_list|)
expr_stmt|;
name|Setfont
argument_list|(
name|F_font
argument_list|)
expr_stmt|;
else|#
directive|else
name|AppendIdentifier
argument_list|(
literal|"Xerox"
argument_list|)
expr_stmt|;
name|AppendIdentifier
argument_list|(
literal|"XC1-1-1"
argument_list|)
expr_stmt|;
name|AppendIdentifier
argument_list|(
literal|"Terminal"
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
literal|3L
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_makevec
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_findfont
argument_list|)
expr_stmt|;
name|AppendRational
argument_list|(
literal|4096L
operator|*
name|textSize
argument_list|,
literal|36L
operator|*
literal|13
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_scale
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_modifyfont
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|I_font
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_iset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* set coordinate system */
name|AppendRational
argument_list|(
call|(
name|long
call|)
argument_list|(
literal|6.5
operator|*
literal|2.54
operator|*
literal|100.0
operator|+
literal|.5
argument_list|)
argument_list|,
literal|4096L
operator|*
literal|100L
operator|*
literal|100L
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_scale
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_concatt
argument_list|)
expr_stmt|;
comment|/* set the stroke width */
name|AppendInteger
argument_list|(
name|STROKE_WIDTH
argument_list|)
expr_stmt|;
comment|/* stroke width */
name|AppendInteger
argument_list|(
literal|15L
argument_list|)
expr_stmt|;
comment|/* stroke width imager variable */
name|AppendOp
argument_list|(
name|OP_iset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* set stroke end */
name|AppendInteger
argument_list|(
name|STROKEEND_BUTT
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
literal|16L
argument_list|)
expr_stmt|;
comment|/* stroke end imager variable */
name|AppendOp
argument_list|(
name|OP_iset
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|command
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|MOVECMD
case|:
name|move
argument_list|()
expr_stmt|;
break|break;
case|case
name|CONTCMD
case|:
name|cont
argument_list|()
expr_stmt|;
break|break;
case|case
name|POINTCMD
case|:
name|point
argument_list|()
expr_stmt|;
break|break;
case|case
name|LINECMD
case|:
name|line
argument_list|()
expr_stmt|;
break|break;
case|case
name|LABELCMD
case|:
name|label
argument_list|()
expr_stmt|;
break|break;
case|case
name|ARCCMD
case|:
name|arc
argument_list|()
expr_stmt|;
break|break;
case|case
name|CIRCLECMD
case|:
name|circle
argument_list|()
expr_stmt|;
break|break;
case|case
name|ERASECMD
case|:
name|erase
argument_list|()
expr_stmt|;
break|break;
case|case
name|LINEMODCMD
case|:
name|lineMod
argument_list|()
expr_stmt|;
break|break;
case|case
name|SPACECMD
case|:
name|space
argument_list|()
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown command: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|<=
literal|' '
operator|||
name|command
operator|>=
literal|0177
condition|)
name|printf
argument_list|(
literal|"\\%03o"
argument_list|,
name|command
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|HaveTrajectory
condition|)
name|ShowTrajectory
argument_list|()
expr_stmt|;
comment|/* wrap it up */
name|AppendOp
argument_list|(
name|OP_endBody
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_endBlock
argument_list|)
expr_stmt|;
name|ip_flush
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|getShort
argument_list|()
end_macro

begin_block
block|{
name|unsigned
name|char
name|c
decl_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
return|return
operator|(
name|getchar
argument_list|()
operator|<<
literal|8
operator|)
operator||
name|c
return|;
block|}
end_block

begin_comment
comment|/*  * move: The next four bytes give a new currect point  *  * The problem here is that there are two kind of moves: those  * for lines and those for characters.  We try to keep the apart.  */
end_comment

begin_macro
name|move
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|HaveTrajectory
condition|)
name|ShowTrajectory
argument_list|()
expr_stmt|;
name|CurrentX
operator|=
name|getShort
argument_list|()
expr_stmt|;
name|CurrentY
operator|=
name|getShort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"move to (%d, %d)\n"
argument_list|,
name|CurrentX
argument_list|,
name|CurrentY
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
end_block

begin_comment
comment|/*  * cont: Draw a line from the current point to the point given by the next  *	four bytes.  See plot(1g)  */
end_comment

begin_macro
name|cont
argument_list|()
end_macro

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|x
operator|=
name|getShort
argument_list|()
expr_stmt|;
name|y
operator|=
name|getShort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"continue to (%d, %d)\n"
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
operator|!
name|HaveTrajectory
condition|)
block|{
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|CurrentX
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|CurrentY
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_moveto
argument_list|)
expr_stmt|;
name|HaveTrajectory
operator|=
name|TRUE
expr_stmt|;
block|}
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|x
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|y
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_lineto
argument_list|)
expr_stmt|;
name|CurrentX
operator|=
name|x
expr_stmt|;
name|CurrentY
operator|=
name|y
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * point: Plot the point given by the next four bytes.  */
end_comment

begin_macro
name|point
argument_list|()
end_macro

begin_block
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|HaveTrajectory
condition|)
name|ShowTrajectory
argument_list|()
expr_stmt|;
name|x
operator|=
name|getShort
argument_list|()
expr_stmt|;
name|y
operator|=
name|getShort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"point at (%d, %d)\n"
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|x
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|y
argument_list|)
expr_stmt|;
name|CurrentX
operator|=
name|x
expr_stmt|;
name|CurrentY
operator|=
name|y
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * line: Draw a line from the point given by the next four bytes to the point  *	given by the following four bytes.  */
end_comment

begin_macro
name|line
argument_list|()
end_macro

begin_block
block|{
name|int
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|;
name|x0
operator|=
name|getShort
argument_list|()
expr_stmt|;
name|y0
operator|=
name|getShort
argument_list|()
expr_stmt|;
name|x1
operator|=
name|getShort
argument_list|()
expr_stmt|;
name|y1
operator|=
name|getShort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"line from (%d, %d) to (%d, %d)\n"
argument_list|,
name|x0
argument_list|,
name|y0
argument_list|,
name|x1
argument_list|,
name|y1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
operator|!
name|HaveTrajectory
condition|)
block|{
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|x0
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|y0
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_moveto
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x0
operator|!=
name|CurrentX
operator|||
name|y0
operator|!=
name|CurrentY
condition|)
block|{
name|ShowTrajectory
argument_list|()
expr_stmt|;
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|x0
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|y0
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_moveto
argument_list|)
expr_stmt|;
block|}
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|x1
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|y1
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_lineto
argument_list|)
expr_stmt|;
name|HaveTrajectory
operator|=
name|TRUE
expr_stmt|;
name|CurrentX
operator|=
name|x1
expr_stmt|;
name|CurrentY
operator|=
name|y1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * label: Place the following ASCII string so that its first character falls  *	on the current point.  The string is terminated by a newline.  *  * Unspoken in the documentation but implied by practice is   * that the current position is changed to the end of text string.  * This artifact can cause problems because we don't know the width  * of characters in a font.  */
end_comment

begin_macro
name|label
argument_list|()
end_macro

begin_block
block|{
name|char
name|labelString
index|[
name|MAXSTRINGSIZE
index|]
decl_stmt|;
if|if
condition|(
name|HaveTrajectory
condition|)
block|{
name|printf
argument_list|(
literal|"pl2ip: opps trying to put text at end of line!\n"
argument_list|)
expr_stmt|;
name|ShowTrajectory
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|gets
argument_list|(
name|labelString
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"output label string: '%s'\n"
argument_list|,
name|labelString
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|CurrentX
argument_list|)
expr_stmt|;
name|AppendInteger
argument_list|(
operator|(
name|long
operator|)
name|CurrentY
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_setxy
argument_list|)
expr_stmt|;
name|AppendString
argument_list|(
name|labelString
argument_list|)
expr_stmt|;
name|AppendOp
argument_list|(
name|OP_show
argument_list|)
expr_stmt|;
name|CurrentX
operator|+=
name|strlen
argument_list|(
name|labelString
argument_list|)
operator|*
operator|(
literal|4096.0
operator|/
operator|(
name|Pitch
operator|*
literal|6.5
operator|)
operator|)
operator|+
literal|.4999999
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * arc: The first four bytes give the center, the next four give the starting  *	proint and the last four give the end point of a circular arc.  The  *	least significant coordinate of the end point is used to only to  *	determine the quadrant.  The arc is drawn counter-clockwise.  */
end_comment

begin_macro
name|arc
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|centerX
decl_stmt|,
name|centerY
decl_stmt|,
name|startX
decl_stmt|,
name|startY
decl_stmt|,
name|endX
decl_stmt|,
name|endY
decl_stmt|;
if|if
condition|(
name|HaveTrajectory
condition|)
name|ShowTrajectory
argument_list|()
expr_stmt|;
name|centerX
operator|=
name|getShort
argument_list|()
expr_stmt|;
name|centerY
operator|=
name|getShort
argument_list|()
expr_stmt|;
name|startX
operator|=
name|getShort
argument_list|()
expr_stmt|;
name|startY
operator|=
name|getShort
argument_list|()
expr_stmt|;
name|endX
operator|=
name|getShort
argument_list|()
expr_stmt|;
name|endY
operator|=
name|getShort
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"arc with center (%d, %d), starting at (%d, %d) and ending at (%d, %d)\n"
argument_list|,
name|centerX
argument_list|,
name|centerY
argument_list|,
name|startX
argument_list|,
name|startY
argument_list|,
name|endX
argument_list|,
name|endY
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
end_block

begin_comment
comment|/*  * circle: The first four bytes give the center of the circle, the next  *	two the radius.  */
end_comment

begin_macro
name|circle
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|centerX
decl_stmt|,
name|centerY
decl_stmt|,
name|radius
decl_stmt|;
if|if
condition|(
name|HaveTrajectory
condition|)
name|ShowTrajectory
argument_list|()
expr_stmt|;
name|centerX
operator|=
name|getShort
argument_list|()
expr_stmt|;
name|centerY
operator|=
name|getShort
argument_list|()
expr_stmt|;
name|radius
operator|=
name|getShort
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"circle at (%d, %d) with radius %d\n"
argument_list|,
name|centerX
argument_list|,
name|centerY
argument_list|,
name|radius
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
end_block

begin_comment
comment|/*  * erase: Start another frame of output  */
end_comment

begin_macro
name|erase
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|HaveTrajectory
condition|)
name|ShowTrajectory
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"erase\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
end_block

begin_comment
comment|/*  * linemod: Take the following string, up to a newline, as the style for  *	drawing further lines.  The syles are 'dotted', 'solid', 'longdashed',  *	'shortdashed', and 'dotdashed'.  */
end_comment

begin_macro
name|lineMod
argument_list|()
end_macro

begin_block
block|{
name|char
name|lineType
index|[
name|MAXSTRINGSIZE
index|]
decl_stmt|;
if|if
condition|(
name|HaveTrajectory
condition|)
name|ShowTrajectory
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|gets
argument_list|(
name|lineType
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"change line mode to '%s'\n"
argument_list|,
name|lineType
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
end_block

begin_comment
comment|/*  * space: The next four bytes give the lower left corner of the plotting area;  *	the following four give the upper right corner.  The plot will be  * 	magnified or reduced to fit the device as closely as possible.  */
end_comment

begin_macro
name|space
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|lowerLeftX
decl_stmt|,
name|lowerLeftY
decl_stmt|,
name|upperRightX
decl_stmt|,
name|upperRightY
decl_stmt|;
name|lowerLeftX
operator|=
name|getShort
argument_list|()
expr_stmt|;
name|lowerLeftY
operator|=
name|getShort
argument_list|()
expr_stmt|;
name|upperRightX
operator|=
name|getShort
argument_list|()
expr_stmt|;
name|upperRightY
operator|=
name|getShort
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"space with lower left at (%d, %d) and upper right at (%d, %d)\n"
argument_list|,
name|lowerLeftX
argument_list|,
name|lowerLeftY
argument_list|,
name|upperRightX
argument_list|,
name|upperRightY
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
end_block

begin_comment
comment|/*  * draw the current trajectory  */
end_comment

begin_macro
name|ShowTrajectory
argument_list|()
end_macro

begin_block
block|{
name|AppendOp
argument_list|(
name|OP_maskstroke
argument_list|)
expr_stmt|;
name|HaveTrajectory
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

end_unit

