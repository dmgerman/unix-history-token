begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This software is Copyright (c) 1985 by Rick Adams.  *  * Permission is hereby granted to copy, reproduce, redistribute or  * otherwise use this software as long as: there is no monetary  * profit gained specifically from the use or reproduction or this  * software, it is not sold, rented, traded or otherwise marketed, and  * this copyright notice is included prominently in any copy  * made.  *  * The author make no claims as to the fitness or correctness of  * this software for any use whatsoever, and it is provided as is.   * Any use of this software is at the user's own risk.  *  * Batch: program to batch a list of news articles into an unbatch script.  * Usage: /usr/lib/news/batch listfile [bytecount]  *  where listfile is a file containing a list, one per line, of full  *  path names of files containing articles, e.g. as produced by the F  *  transmission option in the sys file.  *  bytecount is the maximum number of bytes to output before exiting  * Output is placed on standard output.  *  * Intended usage:  *  *	With the shellfile "sendbatch", with machine names as arguments:  * 		e.g  *		sendbatch rlgvax seismo  *  * This would be invoked every hour or two from crontab.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)batch.c	1.19	10/7/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCCSID */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|BSD4_2
argument_list|)
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|stat
name|sbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fd
decl_stmt|,
modifier|*
name|nfd
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|long
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|fdstatus
decl_stmt|;
name|long
name|maxbytes
decl_stmt|,
name|nbytes
decl_stmt|;
name|long
name|atol
parameter_list|()
function_decl|;
name|char
name|fname
index|[
literal|512
index|]
decl_stmt|;
name|char
name|workfile
index|[
literal|512
index|]
decl_stmt|;
name|char
name|cbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|fgets
argument_list|()
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: batch listfile [bytecount]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Rename real file to a work name to avoid race conditions. 	 * If workfile exists skip the rename in order 	 * to recover from a crash w/o losing anything. 	 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|workfile
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|workfile
argument_list|,
literal|".work"
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|workfile
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* no news */
if|if
condition|(
name|rename
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|workfile
argument_list|)
operator|<
literal|0
condition|)
block|{
name|logerror
argument_list|(
literal|"rename(%s,%s) %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|workfile
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|fd
operator|=
name|fopen
argument_list|(
name|workfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
block|{
name|logerror
argument_list|(
literal|"fopen(%s,r) %s"
argument_list|,
name|workfile
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|maxbytes
operator|=
name|atol
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|maxbytes
operator|=
literal|100000000L
expr_stmt|;
comment|/* backwards compatible */
name|nbytes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|fdstatus
operator|=
name|fgets
argument_list|(
name|fname
argument_list|,
sizeof|sizeof
name|fname
argument_list|,
name|fd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|index
argument_list|(
name|fname
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
name|nfd
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfd
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|fname
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|fstat
argument_list|(
name|fileno
argument_list|(
name|nfd
argument_list|)
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|sbuf
operator|.
name|st_size
operator|==
literal|0
condition|)
continue|continue;
name|nbytes
operator|+=
name|sbuf
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|nbytes
operator|>
name|maxbytes
operator|&&
name|nbytes
operator|!=
name|sbuf
operator|.
name|st_size
condition|)
break|break;
name|printf
argument_list|(
literal|"#! rnews %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|sbuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
comment|/* guess length of #! rnews string */
name|nbytes
operator|+=
literal|13
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
name|fread
argument_list|(
name|cbuf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|cbuf
argument_list|,
name|nfd
argument_list|)
condition|)
block|{
name|fwrite
argument_list|(
name|cbuf
argument_list|,
literal|1
argument_list|,
name|c
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|n
operator|+=
name|c
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|nfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
name|logerror
argument_list|(
literal|"stdout write %s"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|sbuf
operator|.
name|st_size
condition|)
block|{
comment|/* paranoia */
name|logerror
argument_list|(
literal|"%s, expected %ld bytes, got %ld"
argument_list|,
name|fname
argument_list|,
name|n
argument_list|,
name|sbuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
comment|/* breaking out of this early will end up resyncing 			   the batch files (isn't serendipity wonderful?) */
break|break;
block|}
block|}
if|if
condition|(
name|fdstatus
operator|!=
name|NULL
condition|)
block|{
comment|/* exceeded maxbytes */
name|char
name|tmpfile
index|[
literal|512
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpfile
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|tmpfile
argument_list|,
literal|".tmp"
argument_list|)
expr_stmt|;
name|nfd
operator|=
name|fopen
argument_list|(
name|tmpfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfd
operator|==
name|NULL
condition|)
block|{
name|logerror
argument_list|(
literal|"fopen(%s,w) %s"
argument_list|,
name|tmpfile
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|fputs
argument_list|(
name|fname
argument_list|,
name|nfd
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fgets
argument_list|(
name|fname
argument_list|,
sizeof|sizeof
name|fname
argument_list|,
name|fd
argument_list|)
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|ferror
argument_list|(
name|nfd
argument_list|)
condition|)
block|{
name|logerror
argument_list|(
literal|"write(%s) %s"
argument_list|,
name|tmpfile
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|nfd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* will pick it up next time thru */
if|if
condition|(
name|rename
argument_list|(
name|tmpfile
argument_list|,
name|workfile
argument_list|)
operator|<
literal|0
condition|)
block|{
name|logerror
argument_list|(
literal|"rename(%s,%s) %s"
argument_list|,
name|tmpfile
argument_list|,
name|workfile
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|workfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log the given message, with printf strings and parameters allowed,  * on the log file, if it can be written.  */
end_comment

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|logerror
argument_list|(
argument|fmt
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|,
argument|a6
argument_list|,
argument|a7
argument_list|,
argument|a8
argument_list|,
argument|a9
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|a4
decl_stmt|,
name|a5
decl_stmt|,
name|a6
decl_stmt|,
name|a7
decl_stmt|,
name|a8
decl_stmt|,
name|a9
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|logfile
decl_stmt|;
name|char
name|lfname
index|[
name|BUFLEN
index|]
decl_stmt|;
comment|/* the log file */
name|char
name|bfr
index|[
name|BUFLEN
index|]
decl_stmt|;
name|char
modifier|*
name|logtime
decl_stmt|,
modifier|*
name|ctime
argument_list|()
decl_stmt|;
name|time_t
name|t
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|logtime
operator|=
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|logtime
index|[
literal|16
index|]
operator|=
literal|0
expr_stmt|;
name|logtime
operator|+=
literal|4
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOGDIR
argument_list|)
operator|||
name|defined
argument_list|(
name|HOME
argument_list|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|lfname
argument_list|,
literal|"%s/%s/errlog"
argument_list|,
name|logdir
argument_list|(
name|HOME
argument_list|)
argument_list|,
name|LIBDIR
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|lfname
argument_list|,
literal|"%s/errlog"
argument_list|,
name|LIBDIR
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
name|fmt
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|lfname
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|logfile
operator|=
name|fopen
argument_list|(
name|lfname
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|BSD4_2
argument_list|)
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|logfile
argument_list|)
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|logfile
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
name|flags
operator||
name|O_APPEND
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* v7 */
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fileno
argument_list|(
name|logfile
argument_list|)
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* v7 */
name|fprintf
argument_list|(
name|logfile
argument_list|,
literal|"%s\tbatch\t%s\n"
argument_list|,
name|logtime
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BSD4_2
argument_list|)
end_if

begin_expr_stmt
name|rename
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
specifier|register
name|char
operator|*
name|from
operator|,
operator|*
name|to
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|from
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !BSD4_2 */
end_comment

end_unit

