begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This software is Copyright (c) 1986 by Rick Adams.  *  * Permission is hereby granted to copy, reproduce, redistribute or  * otherwise use this software as long as: there is no monetary  * profit gained specifically from the use or reproduction or this  * software, it is not sold, rented, traded or otherwise marketed, and  * this copyright notice is included prominently in any copy  * made.  *  * The author make no claims as to the fitness or correctness of  * this software for any use whatsoever, and it is provided as is.   * Any use of this software is at the user's own risk.  *  * This function initializes all the strings used for the various  * filenames.  They cannot be compiled into the program, since that  * would be non-portable.  With this convention, the netnews sub-system  * can be owned by any non-privileged user.  It is also possible  * to work when the administration randomly moves users from one  * filesystem to another.  The convention is that a particular user  * (HOME, see Makefile) is searched for in /etc/passwd and all files  * are presumed relative to there.  This method also allows one copy  * of the object code to be used on ANY machine.  (this code runs  * un-modified on 50+ machines at IH!!)  *  * The disadvantage to using this method is that all netnews programs  * (inews, readnews, rnews, checknews) must first search /etc/passwd  * before they can start up.  This can cause significant overhead if  * you have a big password file.  *  * Some games are played with ifdefs to get four .o files out of this  * one source file.  INEW is defined for inews, READ for readnews,  * CHKN for checknews, and EXP for expire.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)pathinit.c	1.24	10/7/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCCSID */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INEW
argument_list|)
operator|||
name|defined
argument_list|(
name|EXP
argument_list|)
end_if

begin_include
include|#
directive|include
file|"iparams.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INEW || EXP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|READ
end_ifdef

begin_include
include|#
directive|include
file|"rparams.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* READ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHKN
argument_list|)
end_if

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CHKN */
end_comment

begin_decl_stmt
name|char
modifier|*
name|FROMSYSNAME
decl_stmt|,
modifier|*
name|PATHSYSNAME
decl_stmt|,
modifier|*
name|LOCALSYSNAME
decl_stmt|,
modifier|*
name|LOCALPATHSYSNAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|SPOOL
decl_stmt|,
modifier|*
name|LIB
decl_stmt|,
modifier|*
name|BIN
decl_stmt|,
modifier|*
name|ACTIVE
decl_stmt|,
modifier|*
name|SUBFILE
decl_stmt|,
modifier|*
name|ARTFILE
decl_stmt|,
modifier|*
name|username
init|=
literal|"Unknown"
decl_stmt|,
modifier|*
name|userhome
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INEW
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|LOCKFILE
decl_stmt|,
modifier|*
name|SEQFILE
decl_stmt|,
modifier|*
name|ARTICLE
decl_stmt|,
modifier|*
name|INFILE
decl_stmt|,
modifier|*
name|TELLME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|c_cancel
argument_list|()
decl_stmt|,
name|c_newgroup
argument_list|()
decl_stmt|,
name|c_ihave
argument_list|()
decl_stmt|,
name|c_sendme
argument_list|()
decl_stmt|,
name|c_rmgroup
argument_list|()
decl_stmt|,
name|c_sendsys
argument_list|()
decl_stmt|,
name|c_version
argument_list|()
decl_stmt|,
name|c_checkgroups
argument_list|()
decl_stmt|,
name|c_unimp
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|msgtype
name|msgtype
index|[]
init|=
block|{
literal|"cancel"
block|,
name|NULL
block|,
name|c_cancel
block|,
literal|"newgroup"
block|,
name|NULL
block|,
name|c_newgroup
block|,
literal|"ihave"
block|,
name|NULL
block|,
name|c_ihave
block|,
literal|"sendme"
block|,
name|NULL
block|,
name|c_sendme
block|,
literal|"sendbad"
block|,
name|NULL
block|,
name|c_sendme
block|,
literal|"rmgroup"
block|,
name|NULL
block|,
name|c_rmgroup
block|,
literal|"sendsys"
block|,
name|NULL
block|,
name|c_sendsys
block|,
literal|"version"
block|,
name|NULL
block|,
name|c_version
block|,
literal|"checkgroups"
block|,
name|NULL
block|,
name|c_checkgroups
block|,
literal|"delsub"
block|,
name|NULL
block|,
name|c_unimp
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INEW */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INEW
argument_list|)
operator|||
name|defined
argument_list|(
name|READ
argument_list|)
end_if

begin_decl_stmt
name|char
modifier|*
name|ALIASES
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INEW || READ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXP
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|OLDNEWS
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EXP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|READ
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|MAILPARSER
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* READ */
end_comment

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|Sprintf
parameter_list|(
name|where
parameter_list|,
name|fmt
parameter_list|,
name|arg
parameter_list|)
value|(void) sprintf(bfr,fmt,arg); where = AllocCpy(bfr)
end_define

begin_function
name|char
modifier|*
name|AllocCpy
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|mp
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"malloc failed on %s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|mp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
name|mp
return|;
block|}
end_function

begin_macro
name|pathinit
argument_list|()
end_macro

begin_block
block|{
ifndef|#
directive|ifndef
name|ROOTID
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
comment|/* struct for pw lookup	*/
endif|#
directive|endif
comment|/* !ROOTID */
ifdef|#
directive|ifdef
name|EXP
name|char
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
comment|/* EXP */
ifndef|#
directive|ifndef
name|CHKN
name|struct
name|utsname
name|ubuf
decl_stmt|;
name|char
name|buf
index|[
name|BUFLEN
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|mydomain
parameter_list|()
function_decl|;
name|uname
argument_list|(
operator|&
name|ubuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HIDDENNET_IN_LOCALSYSNAME
comment|/* old compatibility code, remove when HIDDENNET is used no more */
if|if
condition|(
name|STRCMP
argument_list|(
name|ubuf
operator|.
name|nodename
argument_list|,
name|HIDDENNET
argument_list|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s.%s%s"
argument_list|,
name|ubuf
operator|.
name|nodename
argument_list|,
name|HIDDENNET
argument_list|,
name|mydomain
argument_list|()
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%s"
argument_list|,
name|ubuf
operator|.
name|nodename
argument_list|,
name|mydomain
argument_list|()
argument_list|)
expr_stmt|;
name|LOCALSYSNAME
operator|=
name|AllocCpy
argument_list|(
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GENERICFROM
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|GENERICFROM
argument_list|,
name|ubuf
operator|.
name|nodename
argument_list|,
name|mydomain
argument_list|()
argument_list|)
expr_stmt|;
name|FROMSYSNAME
operator|=
name|AllocCpy
argument_list|(
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !GENERICFROM */
name|FROMSYSNAME
operator|=
name|LOCALSYSNAME
expr_stmt|;
endif|#
directive|endif
comment|/* !GENERICFROM */
name|LOCALPATHSYSNAME
operator|=
name|AllocCpy
argument_list|(
name|ubuf
operator|.
name|nodename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GENERICPATH
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|GENERICPATH
argument_list|,
name|ubuf
operator|.
name|nodename
argument_list|,
name|mydomain
argument_list|()
argument_list|)
expr_stmt|;
name|PATHSYSNAME
operator|=
name|AllocCpy
argument_list|(
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !GENERICPATH */
name|PATHSYSNAME
operator|=
name|LOCALPATHSYSNAME
expr_stmt|;
endif|#
directive|endif
comment|/* !GENERICPATH */
endif|#
directive|endif
comment|/* !CHKN */
ifdef|#
directive|ifdef
name|HOME
comment|/* Relative to the home directory of user HOME */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s/%s"
argument_list|,
name|logdir
argument_list|(
name|HOME
argument_list|)
argument_list|,
name|SPOOLDIR
argument_list|)
expr_stmt|;
name|SPOOL
operator|=
name|AllocCpy
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s/%s"
argument_list|,
name|logdir
argument_list|(
name|HOME
argument_list|)
argument_list|,
name|LIBDIR
argument_list|)
expr_stmt|;
name|LIB
operator|=
name|AllocCpy
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !HOME */
comment|/* Fixed paths defined in Makefile */
name|SPOOL
operator|=
name|AllocCpy
argument_list|(
name|SPOOLDIR
argument_list|)
expr_stmt|;
name|LIB
operator|=
name|AllocCpy
argument_list|(
name|LIBDIR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !HOME */
ifdef|#
directive|ifdef
name|LOGDIR
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s/%s"
argument_list|,
name|logdir
argument_list|(
name|HOME
argument_list|)
argument_list|,
name|BINDIR
argument_list|)
expr_stmt|;
name|BIN
operator|=
name|AllocCpy
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !LOGDIR */
name|Sprintf
argument_list|(
name|BIN
argument_list|,
literal|"%s"
argument_list|,
name|BINDIR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !LOGDIR */
name|Sprintf
argument_list|(
name|ACTIVE
argument_list|,
literal|"%s/active"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXP
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|SPOOL
argument_list|)
expr_stmt|;
name|p
operator|=
name|rindex
argument_list|(
name|bfr
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|strcpy
argument_list|(
operator|++
name|p
argument_list|,
literal|"oldnews"
argument_list|)
expr_stmt|;
name|OLDNEWS
operator|=
name|AllocCpy
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
block|}
else|else
name|OLDNEWS
operator|=
name|AllocCpy
argument_list|(
literal|"oldnews"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EXP */
ifndef|#
directive|ifndef
name|CHKN
name|Sprintf
argument_list|(
name|SUBFILE
argument_list|,
literal|"%s/sys"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
name|Sprintf
argument_list|(
name|ARTFILE
argument_list|,
literal|"%s/history"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !CHKN */
ifdef|#
directive|ifdef
name|READ
ifdef|#
directive|ifdef
name|SENDMAIL
name|Sprintf
argument_list|(
name|MAILPARSER
argument_list|,
literal|"%s -oi -oem"
argument_list|,
name|SENDMAIL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !SENDMAIL */
name|Sprintf
argument_list|(
name|MAILPARSER
argument_list|,
literal|"%s/recmail"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SENDMAIL */
endif|#
directive|endif
comment|/* READ */
if|#
directive|if
name|defined
argument_list|(
name|READ
argument_list|)
operator|||
name|defined
argument_list|(
name|INEW
argument_list|)
name|Sprintf
argument_list|(
name|ALIASES
argument_list|,
literal|"%s/aliases"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* READ || INEW */
ifdef|#
directive|ifdef
name|INEW
name|Sprintf
argument_list|(
name|LOCKFILE
argument_list|,
literal|"%s/LOCK"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
name|Sprintf
argument_list|(
name|SEQFILE
argument_list|,
literal|"%s/seq"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
name|Sprintf
argument_list|(
name|ARTICLE
argument_list|,
literal|"%s/.arXXXXXX"
argument_list|,
name|SPOOL
argument_list|)
expr_stmt|;
name|Sprintf
argument_list|(
name|INFILE
argument_list|,
literal|"%s/.inXXXXXX"
argument_list|,
name|SPOOL
argument_list|)
expr_stmt|;
comment|/*  * The person notified by the netnews sub-system.  Again, no name is  * compiled in, but instead the information is taken from a file.  * If the file does not exist, a "default" person will get the mail.  * If the file exists, but is empty, nobody will get the mail.  This  * may seem backwards, but is a better fail-safe.  */
ifdef|#
directive|ifdef
name|NOTIFY
name|parse_notify
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* NOTIFY */
comment|/*  * Since the netnews owner's id number is different on different  * systems, we'll extract it from the /etc/passwd file.  If no entry,  * default to root.  This id number seems to only be used to control who  * can input certain control messages or cancel any message.  Note that  * entry is the name from the "notify" file as found above if possible.  * Defining ROOTID in defs.h hardwires in a number and avoids  * another search of /etc/passwd.  */
ifndef|#
directive|ifndef
name|ROOTID
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|TELLME
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ROOTID
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|HOME
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ROOTID
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
else|else
name|ROOTID
operator|=
literal|0
expr_stmt|;
comment|/* nobody left, let only root */
endif|#
directive|endif
comment|/* !ROOTID */
endif|#
directive|endif
comment|/* INEW */
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|INEW
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|NOTIFY
end_ifdef

begin_comment
comment|/*  * Attempt to parse the LIB/notify file into the global structure msgtype[].  */
end_comment

begin_macro
name|parse_notify
argument_list|()
end_macro

begin_block
block|{
name|FILE
modifier|*
name|nfd
decl_stmt|;
name|int
name|valid
init|=
literal|0
decl_stmt|,
name|done
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|msgtype
modifier|*
name|mp
decl_stmt|;
name|char
name|mtype
index|[
name|BUFLEN
index|]
decl_stmt|,
name|addr
index|[
name|BUFLEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s/notify"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ROOTID
name|TELLME
operator|=
name|AllocCpy
argument_list|(
name|NOTIFY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !ROOTID */
if|if
condition|(
operator|(
name|nfd
operator|=
name|fopen
argument_list|(
name|bfr
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/*  		 * Set defaults to NOTIFY 		 */
ifdef|#
directive|ifdef
name|debug
name|log
argument_list|(
literal|"parse_notify: %s/notify not found"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* debug */
operator|(
name|void
operator|)
name|setmsg
argument_list|(
literal|"all"
argument_list|,
name|NOTIFY
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|mtype
index|[
literal|0
index|]
operator|=
name|addr
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|get_notify
argument_list|(
name|nfd
argument_list|,
name|mtype
argument_list|,
name|addr
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
continue|continue;
case|case
literal|1
case|:
name|valid
operator|+=
name|setmsg
argument_list|(
name|mtype
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|valid
operator|+=
name|setmsg
argument_list|(
name|mtype
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
if|if
condition|(
operator|!
name|valid
condition|)
block|{
ifdef|#
directive|ifdef
name|debug
name|log
argument_list|(
literal|"parse_notify: no valid entries found."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* debug */
name|setmsg
argument_list|(
literal|"all"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* send mail to no one */
block|}
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
comment|/* 	 * point to zero length string for all entries we haven't touched 	 */
for|for
control|(
name|mp
operator|=
name|msgtype
init|;
name|mp
operator|->
name|m_name
condition|;
name|mp
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|m_who_to
operator|==
literal|0
condition|)
name|mp
operator|->
name|m_who_to
operator|=
literal|""
expr_stmt|;
block|}
end_block

begin_macro
name|setmsg
argument_list|(
argument|what
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|what
decl_stmt|,
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|msgtype
modifier|*
name|mp
decl_stmt|;
ifdef|#
directive|ifdef
name|debug
name|log
argument_list|(
literal|"setmsg: what='%s', to='%s'"
argument_list|,
name|what
argument_list|,
name|to
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* debug */
comment|/* 	 * Special case for "all" 	 */
if|if
condition|(
name|STRCMP
argument_list|(
name|what
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|mp
operator|=
name|msgtype
init|;
name|mp
operator|->
name|m_name
condition|;
name|mp
operator|++
control|)
block|{
name|mp
operator|->
name|m_who_to
operator|=
name|AllocCpy
argument_list|(
name|to
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|debug
name|log
argument_list|(
literal|"setmsg: '%s'='%s'"
argument_list|,
name|mp
operator|->
name|m_name
argument_list|,
name|mp
operator|->
name|m_who_to
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* debug */
block|}
return|return
literal|1
return|;
block|}
for|for
control|(
name|mp
operator|=
name|msgtype
init|;
name|mp
operator|->
name|m_name
condition|;
name|mp
operator|++
control|)
if|if
condition|(
name|STRCMP
argument_list|(
name|mp
operator|->
name|m_name
argument_list|,
name|what
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mp
operator|->
name|m_who_to
operator|=
name|AllocCpy
argument_list|(
name|to
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|debug
name|log
argument_list|(
literal|"setmsg: '%s'='%s'"
argument_list|,
name|mp
operator|->
name|m_name
argument_list|,
name|mp
operator|->
name|m_who_to
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* debug */
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|get_notify
argument_list|(
argument|fp
argument_list|,
argument|s
argument_list|,
argument|t
argument_list|)
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|cp
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\t'
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate first string */
while|while
condition|(
operator|*
name|cp
operator|&&
operator|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
operator|||
operator|*
name|cp
operator|==
literal|'\n'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* look for start of second */
if|if
condition|(
operator|!
operator|*
name|cp
operator|||
operator|*
name|cp
operator|==
literal|'\n'
condition|)
return|return
literal|1
return|;
comment|/* no second string */
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
condition|)
operator|*
name|t
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|2
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTIFY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INEW */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CHKN
end_ifndef

begin_comment
comment|/*  * At sites where the are many mail domains within the support area of a single  * news administrator, it is much nicer to be able to read the local domain of  * a machine from a file.  What we do here is:  * 1)	Check for the presence of a LIBDIR/localdomain file.  If it doesn't   * 	exist,assume that MYDOMAIN should be used instead.  * 2)	If it does exist, we make the following assumptions:  *	a)  If it is empty, has only comments, or only blank lines; we assume  *	    the domain is desired to be a zero length string ( ie "").  (this  *	    implies that the domain name is contained in the hostname.)  *	b)  If it is not empty, we assume the first line not beginning with a  *	    '#', blank/tab, or newline is the desired domain name.  *	    A like '.UUCP' or '.TEK.COM' should be used.  We could insure that  *	    the line begin with a '.' to be a valid domain name, but I don't   *	    think it is necessary to put that restriction on it.  */
end_comment

begin_function
name|char
modifier|*
name|mydomain
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|md
init|=
name|NULL
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|char
name|fbuf
index|[
name|BUFLEN
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|;
if|if
condition|(
name|md
condition|)
comment|/* we've been here before, so just return what we found */
return|return
operator|(
name|md
operator|)
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fbuf
argument_list|,
literal|"%s/localdomain"
argument_list|,
name|LIBDIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fbuf
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|md
operator|=
name|MYDOMAIN
expr_stmt|;
comment|/* No localdomain file, use MYDOMAIN instead */
block|}
else|else
block|{
while|while
condition|(
name|fgets
argument_list|(
name|fbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|fbuf
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|fbuf
operator|==
literal|'\n'
operator|||
operator|*
name|fbuf
operator|==
literal|'#'
operator|||
operator|*
name|fbuf
operator|==
literal|' '
operator|||
operator|*
name|fbuf
operator|==
literal|'\t'
condition|)
continue|continue;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|fbuf
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|md
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|fbuf
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|md
operator|=
name|MYDOMAIN
expr_stmt|;
comment|/* punt here */
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|md
argument_list|,
name|fbuf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fp
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|==
name|NULL
condition|)
name|md
operator|=
literal|""
expr_stmt|;
return|return
name|md
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !CHKN */
end_comment

end_unit

