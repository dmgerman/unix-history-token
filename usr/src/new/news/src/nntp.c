begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This software is Copyright 1987 by Stan Barber.   *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction or this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   *  * this is a file full of functions used by the various news client programs   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)nntp.c	2.2	10/15/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCCSID */
end_comment

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nntpserver
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ser_line
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|active_file_name
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|article_file_name
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|last_group
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * open_server open a connection to the server   */
end_comment

begin_macro
name|open_server
argument_list|()
end_macro

begin_block
block|{
name|int
name|response
decl_stmt|;
comment|/* open connection to nntpserver if appropriate */
name|nntpserver
operator|=
name|getserverbyfile
argument_list|(
name|SERVER_FILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nntpserver
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't get the name of the news server from %s\n"
argument_list|,
name|SERVER_FILE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Either fix this file, or put NNTPSERVER in your environment."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|response
operator|=
name|server_init
argument_list|(
name|nntpserver
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Couldn't connect to %s news server, try again later.\n"
argument_list|,
name|nntpserver
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|handle_server_response
argument_list|(
name|response
argument_list|,
name|nntpserver
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot handle response from nntpserver.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * open_active gets the active file and returns an open file descriptor to  * the calling program   */
end_comment

begin_function
name|FILE
modifier|*
name|open_active
parameter_list|()
block|{
name|FILE
modifier|*
name|openfp
decl_stmt|;
name|bzero
argument_list|(
name|active_file_name
argument_list|,
sizeof|sizeof
argument_list|(
name|active_file_name
argument_list|)
argument_list|)
expr_stmt|;
name|put_server
argument_list|(
literal|"LIST"
argument_list|)
expr_stmt|;
comment|/* tell server we want the active file */
operator|(
name|void
operator|)
name|get_server
argument_list|(
name|ser_line
argument_list|,
sizeof|sizeof
argument_list|(
name|ser_line
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ser_line
operator|!=
name|CHAR_OK
condition|)
block|{
comment|/* and then see if that's ok */
name|xerror
argument_list|(
literal|"Can't get active file from server: \n%s\n"
argument_list|,
name|ser_line
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|active_file_name
argument_list|,
literal|"/tmp/nsact.XXXXXX"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|active_file_name
argument_list|)
expr_stmt|;
comment|/* make a temporary name */
name|openfp
operator|=
name|fopen
argument_list|(
name|active_file_name
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
comment|/* and get ready */
if|if
condition|(
name|openfp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|get_server
argument_list|(
name|ser_line
argument_list|,
sizeof|sizeof
argument_list|(
name|ser_line
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* while */
if|if
condition|(
name|ser_line
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|strlen
argument_list|(
name|ser_line
argument_list|)
operator|==
literal|1
condition|)
comment|/* there's another line */
break|break;
comment|/* get it and write it to */
name|fputs
argument_list|(
name|ser_line
argument_list|,
name|openfp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|openfp
argument_list|)
expr_stmt|;
block|}
name|fseek
argument_list|(
name|openfp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* just get to the beginning */
return|return
name|openfp
return|;
block|}
end_function

begin_comment
comment|/*  * active_name() returns the name of the temporary file that contains the  * name of the current active file.   */
end_comment

begin_function
name|char
modifier|*
name|active_name
parameter_list|()
block|{
if|if
condition|(
name|active_file_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|active_file_name
index|[
literal|0
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * set_group() set the current group returns NULL if failure "string" if  * successful   */
end_comment

begin_function
name|char
modifier|*
name|set_group
parameter_list|(
name|newsgroup
parameter_list|)
name|char
modifier|*
name|newsgroup
decl_stmt|;
block|{
name|char
name|nntpbfr
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|newsgroup
operator|==
name|NULL
operator|||
operator|*
name|newsgroup
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|newsgroup
argument_list|,
name|last_group
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|nntpbfr
argument_list|,
literal|"GROUP %s"
argument_list|,
name|newsgroup
argument_list|)
expr_stmt|;
name|put_server
argument_list|(
name|nntpbfr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_server
argument_list|(
name|ser_line
argument_list|,
sizeof|sizeof
argument_list|(
name|ser_line
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ser_line
operator|!=
name|CHAR_OK
condition|)
return|return
name|NULL
return|;
name|strcpy
argument_list|(
name|last_group
argument_list|,
name|newsgroup
argument_list|)
expr_stmt|;
block|}
return|return
operator|&
name|ser_line
index|[
literal|0
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * getarticle() returns an open file descriptor to the requested article.   */
end_comment

begin_function
name|FILE
modifier|*
name|getarticle
parameter_list|(
name|newsgroup
parameter_list|,
name|number
parameter_list|,
name|command
parameter_list|)
name|char
modifier|*
name|newsgroup
decl_stmt|,
decl|*
name|command
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|number
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|nntpbfr
index|[
literal|256
index|]
decl_stmt|;
name|bzero
argument_list|(
name|article_file_name
argument_list|,
sizeof|sizeof
argument_list|(
name|article_file_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_group
argument_list|(
name|newsgroup
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|strcpy
argument_list|(
name|article_file_name
argument_list|,
literal|"/tmp/nsart.XXXXXX"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mktemp
argument_list|(
name|article_file_name
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|nntpbfr
argument_list|,
literal|"%s %ld"
argument_list|,
name|command
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|put_server
argument_list|(
name|nntpbfr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_server
argument_list|(
name|ser_line
argument_list|,
sizeof|sizeof
argument_list|(
name|ser_line
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ser_line
operator|!=
name|CHAR_OK
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|article_file_name
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* and get ready */
name|sync_server
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
while|while
condition|(
name|get_server
argument_list|(
name|ser_line
argument_list|,
sizeof|sizeof
argument_list|(
name|ser_line
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* while */
if|if
condition|(
name|ser_line
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|strlen
argument_list|(
name|ser_line
argument_list|)
operator|==
literal|1
condition|)
comment|/* there's another line */
break|break;
comment|/* get it and write it to */
name|fputs
argument_list|(
name|ser_line
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* the temp file */
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* just get to the beginning */
return|return
name|fp
return|;
block|}
end_block

begin_comment
comment|/*  * article_name() returns the name of the temporary file that contains the  * name of the current article file.   */
end_comment

begin_function
name|char
modifier|*
name|article_name
parameter_list|()
block|{
if|if
condition|(
name|article_file_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|article_file_name
index|[
literal|0
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * group_name() returns the name of the last group accessed from nntp   */
end_comment

begin_function
name|char
modifier|*
name|group_name
parameter_list|()
block|{
if|if
condition|(
name|last_group
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|last_group
index|[
literal|0
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * getartbyid retrieves an article by id number and returns an open file  * descriptor for that article   */
end_comment

begin_function
name|FILE
modifier|*
name|getartbyid
parameter_list|(
name|id
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|nntpbfr
index|[
literal|256
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|nntpbfr
argument_list|,
literal|"ARTICLE %s"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|put_server
argument_list|(
name|nntpbfr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_server
argument_list|(
name|ser_line
argument_list|,
sizeof|sizeof
argument_list|(
name|ser_line
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ser_line
operator|!=
name|CHAR_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot fetch article %s\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|strcpy
argument_list|(
name|article_file_name
argument_list|,
literal|"/tmp/nsart.XXXXXX"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mktemp
argument_list|(
name|article_file_name
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|article_file_name
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* and get ready */
name|sync_server
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
while|while
condition|(
name|get_server
argument_list|(
name|ser_line
argument_list|,
sizeof|sizeof
argument_list|(
name|ser_line
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* while */
if|if
condition|(
name|ser_line
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|strlen
argument_list|(
name|ser_line
argument_list|)
operator|==
literal|1
condition|)
comment|/* there's another line */
break|break;
comment|/* get it and write it to */
name|fputs
argument_list|(
name|ser_line
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* the temp file */
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* just get to the beginning */
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/*  * sync_server gobbles up the rest of the server output until it sees the .  * on the beginning of a line by itself   */
end_comment

begin_function
name|void
name|sync_server
parameter_list|()
block|{
while|while
condition|(
name|get_server
argument_list|(
name|ser_line
argument_list|,
sizeof|sizeof
argument_list|(
name|ser_line
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* while */
if|if
condition|(
name|ser_line
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|strlen
argument_list|(
name|ser_line
argument_list|)
operator|==
literal|1
condition|)
comment|/* there's another line */
break|break;
comment|/* get it and throw it away */
block|}
block|}
end_function

begin_comment
comment|/*  * strindex returns location of tx in sx   */
end_comment

begin_function
name|int
name|strindex
parameter_list|(
name|sx
parameter_list|,
name|tx
parameter_list|)
name|char
modifier|*
name|sx
decl_stmt|,
decl|*
name|tx
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|tx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sx
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|sx
operator|+
name|i
argument_list|,
name|tx
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_block

end_unit

