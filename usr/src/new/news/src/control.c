begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This software is Copyright (c) 1986 by Rick Adams.  *  * Permission is hereby granted to copy, reproduce, redistribute or  * otherwise use this software as long as: there is no monetary  * profit gained specifically from the use or reproduction or this  * software, it is not sold, rented, traded or otherwise marketed, and  * this copyright notice is included prominently in any copy  * made.  *  * The author make no claims as to the fitness or correctness of  * this software for any use whatsoever, and it is provided as is.   * Any use of this software is at the user's own risk.  *  * Control message handling code.  Deal with messages which are to be  * acted on by netnews itself rather than by people.  *  * See defs.h "news_version" for the real version of netnews.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)control.c	2.55	10/7/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCCSID */
end_comment

begin_include
include|#
directive|include
file|"iparams.h"
end_include

begin_define
define|#
directive|define
name|eq
parameter_list|(
name|msg
parameter_list|)
value|(msg[0] == cargv[0][0]&& strcmp(msg, cargv[0]) == 0)
end_define

begin_decl_stmt
name|int
name|cargc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|cargv
decl_stmt|;
end_decl_stmt

begin_function_decl
name|FILE
modifier|*
name|hfopen
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|FILE
modifier|*
name|popen
argument_list|()
decl_stmt|,
modifier|*
name|mhopen
argument_list|()
decl_stmt|,
modifier|*
name|mailhdr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NCARGS
value|30
end_define

begin_function_decl
name|char
modifier|*
name|senderof
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|u370
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|hbuf
name|htmp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* u370 */
end_comment

begin_comment
comment|/*  * The global structure is initialized to NOTIFY as the default (if defined)  * uid to send mail to for every state.  The following conditions are  * dealt with (assumes NOTIFY defined):  *  * 1) LIB/notify exists and is empty (or contains no recognizable control  *    message types).  *    	Action: force TELLME = "";  * 2) LIB/notify contains the control message name "all" and no associated  *    address.  *	Action: force TELLME = "";  * 3) LIB/notify contains the control message name "all" and has an address.  *	Action: set TELLME = AlloCpy(address);  * 4) LIB/notify contains only some of the known control message types.  *	Action: initialize all addresses to "" and set declared addresses  *		to listed address.  */
end_comment

begin_macro
name|control
argument_list|(
argument|h
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hbuf
modifier|*
name|h
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ctlmsgtext
decl_stmt|;
specifier|register
name|struct
name|msgtype
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|h
operator|->
name|title
argument_list|,
literal|"cmsg "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|cp1
operator|=
name|h
operator|->
name|title
expr_stmt|;
name|cp2
operator|=
name|h
operator|->
name|title
operator|+
literal|5
expr_stmt|;
while|while
condition|(
operator|*
name|cp1
operator|++
operator|=
operator|*
name|cp2
operator|++
condition|)
empty_stmt|;
block|}
if|if
condition|(
operator|*
name|h
operator|->
name|ctlmsg
condition|)
name|ctlmsgtext
operator|=
name|h
operator|->
name|ctlmsg
expr_stmt|;
else|else
name|ctlmsgtext
operator|=
name|h
operator|->
name|title
expr_stmt|;
name|log
argument_list|(
literal|"Ctl Msg %s from %s: %s"
argument_list|,
name|h
operator|->
name|nbuf
argument_list|,
name|h
operator|->
name|path
argument_list|,
name|ctlmsgtext
argument_list|)
expr_stmt|;
comment|/* 	 * Control messages have the standard format 	 *	command [args] 	 * much like shell commands.  Each site has the option 	 * of customizing this code to deal with control messages 	 * as they see fit, but we would like to buy back the 	 * code, ifdeffed or otherwise parameterized, to simplify 	 * the maintenence issues. 	 */
name|argparse
argument_list|(
name|ctlmsgtext
argument_list|)
expr_stmt|;
comment|/* 	 * We look for a match of the control message name and then 	 * set TELLME to the value parsed from the LIB/notify file 	 * (if any). 	 */
for|for
control|(
name|mp
operator|=
name|msgtype
init|;
name|mp
operator|->
name|m_name
condition|;
name|mp
operator|++
control|)
block|{
if|if
condition|(
name|eq
argument_list|(
name|mp
operator|->
name|m_name
argument_list|)
condition|)
block|{
comment|/* hit */
ifdef|#
directive|ifdef
name|NOTIFY
name|TELLME
operator|=
name|mp
operator|->
name|m_who_to
expr_stmt|;
comment|/* reset whom to tell */
endif|#
directive|endif
comment|/* NOTIFY */
return|return
call|(
modifier|*
name|mp
operator|->
name|m_func
call|)
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
return|;
comment|/* do it */
block|}
block|}
if|if
condition|(
operator|!
name|mp
operator|->
name|m_name
condition|)
block|{
ifdef|#
directive|ifdef
name|NOTIFY
name|TELLME
operator|=
name|NOTIFY
expr_stmt|;
endif|#
directive|endif
comment|/* NOTIFY */
name|c_unknown
argument_list|(
name|h
argument_list|,
name|ctlmsgtext
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Parse the string str into separate words in cargc and cargv  * as per the usual UNIX convention.  Nothing fancy here, just  * blanks and tabs separating words.  */
end_comment

begin_macro
name|argparse
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
modifier|*
name|cavpbuf
index|[
name|NCARGS
index|]
decl_stmt|;
specifier|static
name|char
name|cavbuf
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|nextfree
init|=
name|cavbuf
decl_stmt|;
if|if
condition|(
name|str
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|"Control message %s has no title"
argument_list|,
name|header
operator|.
name|ident
argument_list|)
expr_stmt|;
name|cargc
operator|=
operator|(
operator|*
name|str
operator|!=
literal|'\0'
operator|)
expr_stmt|;
name|cargv
operator|=
name|cavpbuf
expr_stmt|;
name|cargv
index|[
literal|0
index|]
operator|=
name|cavbuf
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|<=
literal|' '
condition|)
block|{
comment|/* skip over white space */
while|while
condition|(
operator|*
name|str
operator|!=
literal|'\0'
operator|&&
operator|*
name|str
operator|<=
literal|' '
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'\0'
condition|)
comment|/* line ends in white space */
return|return;
operator|*
name|nextfree
operator|++
operator|=
literal|0
expr_stmt|;
name|cargv
index|[
name|cargc
index|]
operator|=
name|nextfree
expr_stmt|;
if|if
condition|(
name|cargc
operator|++
operator|>=
name|NCARGS
condition|)
name|xerror
argument_list|(
literal|"Too many arguments to control message %s"
argument_list|,
name|header
operator|.
name|ident
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|nextfree
operator|++
operator|=
operator|*
name|str
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * ihave<artid> ...<remotesys>  *	or  * ihave<remotesys>  *	with<artid>s in message body.  *  * The other system is telling you it has article<artid>, in case  * you decide you want it to transmit it to you.  * The assumption is that the other system only tells you about articles  * in newsgroups you subscribe to.  *  * We turn the incoming ihave into an outgoing sendme on the fly.  * It then gets saved in the SPOOL directory and transmitted to the  * remote system.  (This way the sendme messages can be batched.)  */
end_comment

begin_expr_stmt
name|c_ihave
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|argv
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|list
index|[
sizeof|sizeof
name|header
operator|.
name|title
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|findhist
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|mydomain
parameter_list|()
function_decl|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|error
argument_list|(
literal|"ihave: Too few arguments."
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|PATHSYSNAME
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|,
name|SNLN
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|list
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|argc
operator|-
literal|1
operator|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|findhist
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|list
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|list
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|list
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
specifier|register
name|FILE
modifier|*
name|outfp
decl_stmt|;
specifier|register
name|long
name|outpos
decl_stmt|,
name|inpos
decl_stmt|;
name|char
name|myid
index|[
literal|256
index|]
decl_stmt|;
name|outfp
operator|=
name|xfopen
argument_list|(
name|INFILE
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|outpos
operator|=
name|ftell
argument_list|(
name|outfp
argument_list|)
expr_stmt|;
name|inpos
operator|=
name|ftell
argument_list|(
name|infp
argument_list|)
expr_stmt|;
while|while
condition|(
name|ftell
argument_list|(
name|infp
argument_list|)
operator|<
name|outpos
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|myid
argument_list|,
sizeof|sizeof
name|myid
argument_list|,
name|infp
argument_list|)
operator|!=
name|myid
condition|)
name|error
argument_list|(
literal|"iline: Can't reread article"
argument_list|)
expr_stmt|;
name|myid
index|[
name|strlen
argument_list|(
name|myid
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|findhist
argument_list|(
name|myid
argument_list|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|outfp
argument_list|,
literal|"%s\n"
argument_list|,
name|myid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outpos
operator|==
name|ftell
argument_list|(
name|outfp
argument_list|)
condition|)
block|{
comment|/* if nothing is wanted */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|outfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|infp
argument_list|,
name|inpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|outfp
argument_list|)
expr_stmt|;
comment|/* 		** The close and open may just be paranoia. 		*/
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|infp
argument_list|)
expr_stmt|;
name|infp
operator|=
name|xfopen
argument_list|(
name|INFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|infp
argument_list|,
name|outpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	** Turn the ihave into a sendme. 	*/
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|header
operator|.
name|nbuf
argument_list|,
literal|"to.%s.ctl"
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|header
operator|.
name|title
argument_list|,
literal|"sendme%s %s"
argument_list|,
name|list
argument_list|,
name|PATHSYSNAME
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|header
operator|.
name|ctlmsg
argument_list|,
name|header
operator|.
name|title
argument_list|)
expr_stmt|;
name|getident
argument_list|(
operator|&
name|header
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|header
operator|.
name|from
argument_list|,
literal|"%s@%s"
argument_list|,
literal|"usenet"
argument_list|,
name|FROMSYSNAME
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|header
operator|.
name|path
argument_list|,
name|NEWSUSR
argument_list|)
expr_stmt|;
name|header
operator|.
name|subdate
index|[
literal|0
index|]
operator|=
name|header
operator|.
name|expdate
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dates
argument_list|(
operator|&
name|header
argument_list|)
expr_stmt|;
comment|/* 	** What else of this kind should be done? 	*/
name|header
operator|.
name|organization
index|[
literal|0
index|]
operator|=
name|header
operator|.
name|distribution
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|header
operator|.
name|numlines
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUNREC
operator|&&
name|header
operator|.
name|unrec
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
name|free
argument_list|(
name|header
operator|.
name|unrec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|header
operator|.
name|unrec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	** Note that we do *not* change the history line 	** so that if the "ihave" message comes in again it gets rejected. 	*/
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * sendme<artid> ...<remotesys>  *	or  * sendme<remotesys>  *	with<artid>s in message body.  * The other system wants me to send out article<artid>.  * Give it to them with no fuss.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MULTICAST
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|c_mc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|c_sysnames
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MULTICAST */
end_comment

begin_expr_stmt
name|c_sendme
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|argv
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|srec
name|srec
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|error
argument_list|(
literal|"sendme: Too few arguments."
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|PATHSYSNAME
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|,
name|SNLN
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|s_find
argument_list|(
operator|&
name|srec
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|TRUE
condition|)
name|error
argument_list|(
literal|"sendme: Can't find sys record for %s"
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTICAST
name|c_mc
operator|=
name|index
argument_list|(
name|srec
operator|.
name|s_flags
argument_list|,
literal|'M'
argument_list|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|c_mc
condition|)
block|{
name|struct
name|srec
name|trec
decl_stmt|;
name|c_sysnames
operator|=
operator|&
name|argv
index|[
name|argc
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|s_find
argument_list|(
operator|&
name|trec
argument_list|,
name|srec
operator|.
name|s_xmit
argument_list|)
operator|!=
name|TRUE
condition|)
name|error
argument_list|(
literal|"sendme: Can't find sys record for %s for %s"
argument_list|,
name|srec
operator|.
name|s_xmit
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|srec
operator|=
name|trec
expr_stmt|;
block|}
else|else
name|c_sysnames
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* MULTICAST */
comment|/* Send the articles. */
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|fp
operator|=
name|xfopen
argument_list|(
name|INFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
operator|==
name|buf
condition|)
block|{
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* zap trailing '\n' */
name|sendmefunc
argument_list|(
name|buf
argument_list|,
operator|&
name|srec
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* argc> 2 */
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|argc
operator|-
literal|1
operator|)
condition|;
operator|++
name|i
control|)
name|sendmefunc
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|&
name|srec
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|sendmefunc
argument_list|(
name|id
argument_list|,
name|sp
argument_list|)
specifier|register
name|char
operator|*
name|id
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|srec
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|savedbufname
index|[
literal|256
index|]
decl_stmt|;
specifier|extern
name|char
name|firstbufname
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|dirname
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|findfname
parameter_list|()
function_decl|;
name|cp
operator|=
name|findfname
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
literal|"System %s wants unavailable article %s."
argument_list|,
ifdef|#
directive|ifdef
name|MULTICAST
operator|(
name|c_mc
condition|?
name|c_sysnames
index|[
literal|0
index|]
else|:
name|sp
operator|->
name|s_name
operator|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !MULTICAST */
name|sp
operator|->
name|s_name
operator|,
name|id
block|)
empty_stmt|;
endif|#
directive|endif
comment|/* !MULTICAST */
return|return;
block|}
end_block

begin_expr_stmt
name|cp
operator|=
name|dirname
argument_list|(
name|cp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fp
operator|=
name|fopen
argument_list|(
name|cp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|logerr
argument_list|(
literal|"Article %s unopenable as %s."
argument_list|,
name|id
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_expr_stmt
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|savedbufname
argument_list|,
name|firstbufname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|firstbufname
argument_list|,
name|cp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MULTICAST
end_ifdef

begin_expr_stmt
name|transmit
argument_list|(
name|sp
argument_list|,
name|fp
argument_list|,
name|FALSE
argument_list|,
name|c_sysnames
argument_list|,
name|c_mc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !MULTICAST */
end_comment

begin_expr_stmt
name|transmit
argument_list|(
name|sp
argument_list|,
name|fp
argument_list|,
name|FALSE
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !MULTICAST */
end_comment

begin_comment
comment|/* transmit closes fp */
end_comment

begin_expr_stmt
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|firstbufname
argument_list|,
name|savedbufname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * newgroup<groupname>  * A new newsgroup has been created.  * The body of the article, if present, is a description of the  * purpose of the newsgroup.  *  */
end_comment

begin_expr_stmt
unit|c_newgroup
operator|(
name|argc
operator|,
name|argv
operator|)
name|char
operator|*
operator|*
name|argv
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|char
name|abuf
index|[
name|BUFLEN
index|]
decl_stmt|,
name|subjline
index|[
name|BUFLEN
index|]
decl_stmt|;
name|int
name|didcreate
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
ifdef|#
directive|ifdef
name|NONEWGROUPS
ifdef|#
directive|ifdef
name|ORGDISTRIB
comment|/* local or ORGDISTRIB */
name|int
name|can_change
init|=
operator|(
name|strcmp
argument_list|(
name|header
operator|.
name|distribution
argument_list|,
literal|"local"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|header
operator|.
name|distribution
argument_list|,
name|ORGDISTRIB
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
else|#
directive|else
comment|/* ! ORGDISTRIB */
comment|/* local only */
name|int
name|can_change
init|=
name|strcmp
argument_list|(
name|header
operator|.
name|distribution
argument_list|,
literal|"local"
argument_list|)
operator|==
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* ORGDISTRIB */
else|#
directive|else
comment|/* ! NONEWGROUPS */
name|int
name|can_change
init|=
literal|1
decl_stmt|;
comment|/* allow changes for all distributions */
endif|#
directive|endif
comment|/* NONEWGROUPS */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|error
argument_list|(
literal|"newgroup: Too few arguments."
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|.
name|approved
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|logerr
argument_list|(
literal|"newgroup: %s not approved"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|lock
argument_list|()
expr_stmt|;
comment|/* see if it already exists */
operator|(
name|void
operator|)
name|rewind
argument_list|(
name|actfp
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|actfp
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|abuf
argument_list|,
name|BUFLEN
argument_list|,
name|actfp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|abuf
expr_stmt|;
name|q
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|==
operator|*
name|q
operator|++
condition|)
empty_stmt|;
if|if
condition|(
operator|*
operator|--
name|q
operator|==
literal|'\0'
operator|&&
operator|*
operator|--
name|p
operator|==
literal|' '
condition|)
block|{
comment|/* Now check if it's correctly moderated/unmoderated */
while|while
condition|(
operator|*
name|p
operator|++
condition|)
empty_stmt|;
name|p
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"moderated"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'m'
condition|)
block|{
name|unlock
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|p
operator|=
literal|'m'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'m'
condition|)
block|{
name|unlock
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|p
operator|=
literal|'y'
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NOTIFY
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|subjline
argument_list|,
literal|"Newsgroup %s changed from %smoderated to %smoderated"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|*
name|p
operator|==
literal|'y'
condition|?
literal|""
else|:
literal|"un"
argument_list|,
operator|*
name|p
operator|==
literal|'y'
condition|?
literal|"un"
else|:
literal|""
argument_list|)
expr_stmt|;
name|fd
operator|=
name|mailhdr
argument_list|(
operator|(
expr|struct
name|hbuf
operator|*
operator|)
name|NULL
argument_list|,
name|subjline
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|can_change
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s has been changed from %smoderated to %smoderated as requested by\n%s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|*
name|p
operator|==
literal|'y'
condition|?
literal|""
else|:
literal|"un"
argument_list|,
operator|*
name|p
operator|==
literal|'y'
condition|?
literal|"un"
else|:
literal|""
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s\nhas requested that %s be changed from %smoderated to %smoderated\n"
argument_list|,
name|header
operator|.
name|path
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|*
name|p
operator|==
literal|'y'
condition|?
literal|""
else|:
literal|"un"
argument_list|,
operator|*
name|p
operator|==
literal|'y'
condition|?
literal|"un"
else|:
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ORGDISTRIB
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"You can accomplish this by re-creating the newsgroup with a distribution\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"of '%s' by executing the command:\n"
argument_list|,
name|ORGDISTRIB
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s/inews -d %s -C %s%s\n"
argument_list|,
name|LIB
argument_list|,
name|ORGDISTRIB
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|*
name|p
operator|==
literal|'y'
condition|?
literal|""
else|:
literal|" moderated"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !ORGDISTRIB */
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"You can accomplish this by re-creating the newsgroup by executing the command:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s/inews -C %s%s\n"
argument_list|,
name|LIB
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|*
name|p
operator|==
literal|'y'
condition|?
literal|""
else|:
literal|" moderated"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !ORGDISTRIB */
block|}
operator|(
name|void
operator|)
name|mclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NOTIFY */
ifdef|#
directive|ifdef
name|NONEWGROUPS
comment|/* 			 * No permission to change 			 */
if|if
condition|(
operator|!
name|can_change
condition|)
block|{
name|unlock
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* NONEWGROUPS */
comment|/* The active file was wrong about the state of the 			 * group. Rewrite the active file 			 */
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|actfp
argument_list|,
operator|-
literal|2L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* back up 2 characters */
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|actfp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|actfp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'m'
condition|)
name|logerr
argument_list|(
literal|"Newsgroup %s changed from moderated to unmoderated"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|logerr
argument_list|(
literal|"Newsgroup %s changed from unmoderated to moderated"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|unlock
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* It doesn't already exist, we must create it */
if|if
condition|(
name|can_change
condition|)
block|{
name|didcreate
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|actfp
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|actfp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|actfp
argument_list|,
literal|"%s 00000 00001 %c\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
operator|(
name|argc
operator|>
literal|2
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"moderated"
argument_list|)
operator|==
literal|0
operator|)
condition|?
literal|'m'
else|:
literal|'y'
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|MG1
argument_list|)
comment|/* 		 * U G L Y   K L U D G E 		 * This utter piece of tripe is the only way I know of 		 * to get around the fact that ATT BROKE standard IO 		 * in System 5.2. Basically, you can't open a file for 		 * "r+" and then try and write to it. This hack works 		 * on all "real" USG Unix systems, It will probably 		 * break on some obscure look alike that doesnt use the 		 * real ATT stdio.h 		 * also broken in WCW MG-1 42nix 2.0 		 * Don't blame me, blame ATT. stdio should have 		 * already done the following line for us, but it didn't 		 */
name|actfp
operator|->
name|_flag
operator||=
name|_IOWRT
expr_stmt|;
endif|#
directive|endif
comment|/* USG */
name|fflush
argument_list|(
name|actfp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NOTIFY
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|subjline
argument_list|,
literal|"Newsgroup %s created"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fd
operator|=
name|mailhdr
argument_list|(
operator|(
expr|struct
name|hbuf
operator|*
operator|)
name|NULL
argument_list|,
name|subjline
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|didcreate
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"A new %snewsgroup called '%s' has been created by %s.\n"
argument_list|,
name|argc
operator|>
literal|2
condition|?
literal|"moderated "
else|:
literal|""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s requested that a new %snewsgroup called '%s' be created.\n"
argument_list|,
name|header
operator|.
name|path
argument_list|,
name|argc
operator|>
literal|2
condition|?
literal|"moderated "
else|:
literal|""
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"It was approved by %s\n\n"
argument_list|,
name|header
operator|.
name|approved
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"You can accomplish this by creating the newgroup yourself\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ORGDISTRIB
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"with a distribution of '%s'.\n"
argument_list|,
name|ORGDISTRIB
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"In other words, by executing the command:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s/inews -d %s -C %s %s\n"
argument_list|,
name|LIB
argument_list|,
name|ORGDISTRIB
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argc
operator|>
literal|2
condition|?
name|argv
index|[
literal|2
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !ORGDISTRIB */
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"In other words, by executing the command:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s/inews -C %s %s\n"
argument_list|,
name|LIB
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argc
operator|>
literal|2
condition|?
name|argv
index|[
literal|2
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !ORGDISTRIB */
block|}
operator|(
name|void
operator|)
name|mclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NOTIFY */
name|unlock
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * rmgroup<groupname>  * An old newsgroup is being cancelled on a network wide basis.  */
end_comment

begin_macro
name|c_rmgroup
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|int
name|shouldremove
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|NOTIFY
name|char
name|subjline
index|[
name|BUFLEN
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* NOTIFY */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|error
argument_list|(
literal|"rmgroup: Too few arguments."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|validng
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|header
operator|.
name|approved
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|logerr
argument_list|(
literal|"rmgroup: %s not approved"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|MANUALLY
ifdef|#
directive|ifdef
name|ORGDISTRIB
comment|/* 	 * Allow local as well as organizational removals 	 */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ORGDISTRIB
argument_list|,
name|header
operator|.
name|distribution
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"local"
argument_list|,
name|header
operator|.
name|distribution
argument_list|)
condition|)
else|#
directive|else
comment|/* !ORGDISTRIB */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"local"
argument_list|,
name|header
operator|.
name|distribution
argument_list|)
condition|)
endif|#
directive|endif
comment|/* !ORGDISTRIB */
endif|#
directive|endif
comment|/* MANUALLY */
name|shouldremove
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTIFY
name|sprintf
argument_list|(
name|subjline
argument_list|,
literal|"Received rmgroup for %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fd
operator|=
name|mailhdr
argument_list|(
operator|(
expr|struct
name|hbuf
operator|*
operator|)
name|NULL
argument_list|,
name|subjline
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|shouldremove
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Newsgroup '%s' has been removed by %s.\n\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"You may need to remove the directory %s by hand\n"
argument_list|,
name|dirname
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s requested that newsgroup %s be removed.\n"
argument_list|,
name|header
operator|.
name|path
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"You should remove it by hand\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"To do this, execute the command\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\t%s/rmgroup %s\n"
argument_list|,
name|LIB
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NOTIFY */
if|if
condition|(
name|shouldremove
condition|)
block|{
name|int
name|pid
decl_stmt|,
name|status
decl_stmt|;
comment|/* We let the shell do all the work. 		 * See the rmgrp shell script. 		 */
name|lock
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s/rmgroup"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
name|status
operator|=
name|fwait
argument_list|(
name|pid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|close
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
break|break;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|duid
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|bfr
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|log
argument_list|(
literal|"rmgroup status %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * cancel<artid>  * Cancel the named article  */
end_comment

begin_macro
name|c_cancel
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|poster
decl_stmt|;
name|char
modifier|*
name|findhist
parameter_list|()
function_decl|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|whatsisname
index|[
name|BUFLEN
index|]
decl_stmt|,
name|nfilename
index|[
name|BUFLEN
index|]
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|int
name|su
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|u370
name|struct
name|hbuf
name|htmp
decl_stmt|;
endif|#
directive|endif
comment|/* !u370 */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|error
argument_list|(
literal|"cancel: Too few arguments."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|whatsisname
argument_list|,
name|senderof
argument_list|(
operator|&
name|header
argument_list|)
argument_list|)
expr_stmt|;
name|line
operator|=
name|findhist
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
block|{
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|log
argument_list|(
literal|"Can't cancel %s:  non-existent"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
name|sprintf
argument_list|(
argument|bfr
argument_list|,
literal|"%s\t%2.2d/%2.2d/%d %2.2d:%2.2d\tcancelled"
argument_list|,
else|#
directive|else
comment|/* !USG */
argument|sprintf(bfr,
literal|"%s\t%02d/%02d/%d %02d:%02d\tcancelled"
argument|,
endif|#
directive|endif
comment|/* !USG */
argument|argv[
literal|1
argument|], tm->tm_mon+
literal|1
argument|, tm->tm_mday, tm->tm_year, tm->tm_hour, 		   tm->tm_min); 		savehist(bfr); 		return -
literal|1
argument|; 	}  	q = index(line,
literal|'\t'
argument|); 	p = index(q+
literal|1
argument|,
literal|'\t'
argument|); 	if (p == NULL || *++p ==
literal|'\0'
argument||| *p ==
literal|'\n'
argument|) { 		*q =
literal|'\0'
argument|; 		log(
literal|"Expired article %s"
argument|, line); 		return -
literal|1
argument|; 	} 	if (strcmp(p,
literal|"cancelled"
argument|) ==
literal|0
argument|) { 		*q =
literal|'\0'
argument|; 		log(
literal|"Already Cancelled %s"
argument|, line); 		return -
literal|1
argument|; 	} else 		log(
literal|"Cancelling %s"
argument|, line); 	if ((uid == ROOTID||uid ==
literal|0
argument|)&& (
ifdef|#
directive|ifdef
name|ORGDISTRIB
argument|strcmp(header.distribution, ORGDISTRIB) ==
literal|0
argument|||
endif|#
directive|endif
comment|/* ORGDISTRIB */
argument|strcmp(header.distribution,
literal|"local"
argument|) ==
literal|0
argument|)) 		su =
literal|1
argument|; 	while (*p) { 		q = index(p,
literal|' '
argument|); 		if (q) 			*q =
literal|'\0'
argument|; 		(void) strcpy(nfilename, dirname(p)); 		fp = fopen(nfilename,
literal|"r"
argument|); 		if (fp == NULL) { 			log(
literal|"Can't cancel %s: %s"
argument|, line, errmsg(errno)); 			return -
literal|1
argument|; 		} 		htmp.unrec[
literal|0
argument|] = NULL; 		if (hread(&htmp, fp, TRUE) == NULL) { 			if (bfr[
literal|0
argument|] ==
literal|'/'
argument|) { 				fp = fopen(bfr,
literal|"r"
argument|); 				if (fp == NULL 					|| hread(&htmp, fp, TRUE) == NULL) 					error(
literal|"Article is garbled."
argument|); 			} else  				error(
literal|"Article is garbled."
argument|); 		} 		(void) fclose(fp); 		poster = senderof(&htmp);
comment|/* only compare up to '.' or ' ' */
argument|r = index(poster,
literal|'.'
argument|); 		if (r == NULL) 			r = index(poster,
literal|' '
argument|); 		if (r != NULL) 			*r =
literal|'\0'
argument|; 		if (!su&& strncmp(whatsisname, poster,strlen(poster))) { 			error(
literal|"Not contributor: posted by %s, and you are %s"
argument|, poster, whatsisname); 		}  		(void) unlink(nfilename); 		p = q+
literal|1
argument|; 	} 	return
literal|0
argument|; }
comment|/*  * sendsys	(no arguments)  *  * Mail the sys file to the person submitting the article.  * POLICY: the contents of your sys file are public information  * and as such, you should not change this code.  You may feel  * free to arrange for it to manually notify you, in the event  * that you want to do something to clean it up before it goes out.  * Secret sites on the net are expressly frowned on.  *   * The purpose of this command is for making a network map.  The  * details of your link and which newsgroups are forwarded are not  * important, in case you want to sanitize them.  Since the definition  * of USENET is those sites getting net.announce, you can disable this  * on sites not getting net articles, but if you take out the list of  * forwarded newsgroups, and you have sites that only get local newsgroups,  * you should make this clear, or remove those sites from what you send out.  */
comment|/* ARGSUSED */
argument|c_sendsys(argc, argv) char **argv; { 	register FILE *f
argument_list|,
argument|*u; 	int c;
ifdef|#
directive|ifdef
name|NOTIFY
argument|f = mailhdr((struct hbuf *)NULL,
literal|"sendsys control message"
argument|); 	if (f != NULL) { 		fprintf(f,
literal|"%s requested your %s/sys file.\n"
argument|, header.path, LIB); 		fprintf(f,
literal|"It has been sent.\n"
argument|); 		(void) mclose(f); 	}
endif|#
directive|endif
comment|/* NOTIFY */
argument|f = mailhdr(&header,
literal|"response to your sendsys request"
argument|); 	u = fopen(SUBFILE,
literal|"r"
argument|); 	if (f != NULL&& u != NULL) { 		while ((c=getc(u)) != EOF) 			putc(c, f); 		(void) fclose(u); 		(void) mclose(f); 	} 	return
literal|0
argument|; }
comment|/*  * Send the version number to the right person.  */
comment|/* ARGSUSED */
argument|c_version(argc, argv) char **argv; { 	register FILE *f;  	f = mailhdr(&header,
literal|"Our news version"
argument|); 	if (f == NULL) 		error(
literal|"Cannot send back error message"
argument|); 	fprintf(f,
literal|"Currently running news version %s.\n\n"
argument|, news_version); 	fprintf(f,
literal|"The header of your message follows:\n\n"
argument|); 	(void) hwrite(&header, f); 	(void) mclose(f); 	return
literal|0
argument|; }
comment|/*  * Check the active file for old or missing newsgroups  * Body of article is list of valid groups  */
comment|/* ARGSUSED */
argument|c_checkgroups(argc, argv) char **argv; { 	int rc;  	(void) setuid(geteuid());
comment|/* dont change the cat %s| to< %s, it breaks some "unix" systems */
argument|(void) sprintf(bfr,
literal|"cat %s | %s/checkgroups %s"
argument|, INFILE, LIB,
ifdef|#
directive|ifdef
name|NOTIFY
argument|(TELLME&& *TELLME) ? TELLME : NEWSUSR );
else|#
directive|else
comment|/* !NOTIFY */
argument|NEWSUSR
argument_list|)
empty_stmt|;
endif|#
directive|endif
comment|/* !NOTIFY */
name|rc
operator|=
name|system
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"system(%s) status %d"
argument_list|,
name|bfr
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  * An unknown control message has been received.  */
name|c_unknown
argument_list|(
argument|h
argument_list|,
argument|ctlmsgtext
argument_list|)
name|struct
name|hbuf
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|ctlmsgtext
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|log
argument_list|(
literal|"UNKNOWN Ctl Msg %s from %s"
argument_list|,
name|ctlmsgtext
argument_list|,
name|h
operator|->
name|path
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTIFY
name|f
operator|=
name|mailhdr
argument_list|(
operator|(
expr|struct
name|hbuf
operator|*
operator|)
name|NULL
argument_list|,
literal|"Unrecognized Control Message"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Currently running news version %s.\n\n"
argument_list|,
name|news_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"The header of the message follows:\n\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hwrite
argument_list|(
name|h
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NOTIFY */
return|return
literal|0
return|;
block|}
comment|/* ARGSUSED */
name|c_unimp
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
ifdef|#
directive|ifdef
name|NOTIFY
name|f
operator|=
name|mailhdr
argument_list|(
operator|(
expr|struct
name|hbuf
operator|*
operator|)
name|NULL
argument_list|,
literal|"Unimplemented Control Message"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Currently running news version B %s.\n\n"
argument_list|,
name|news_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"The header of the message follows:\n\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hwrite
argument_list|(
operator|&
name|header
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NOTIFY */
return|return
literal|0
return|;
block|}
comment|/*  * This is a modified version of popen, made more secure.  Rather than  * forking off a shell, you get a bare process.  You must have exactly  * one argument, and the command must be mail (or sendmail if you have it).  */
define|#
directive|define
name|RDR
value|0
define|#
directive|define
name|WTR
value|1
specifier|static
name|int
name|mopen_pid
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|replyname
parameter_list|()
function_decl|;
name|FILE
modifier|*
name|mhopen
parameter_list|(
name|hptr
parameter_list|)
name|struct
name|hbuf
modifier|*
name|hptr
decl_stmt|;
block|{
name|int
name|p
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|myside
operator|,
name|hisside
operator|,
name|pid
expr_stmt|;
name|char
modifier|*
name|sendto
init|=
literal|"usenet"
decl_stmt|;
if|if
condition|(
name|hptr
condition|)
name|sendto
operator|=
name|replyname
argument_list|(
name|hptr
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|NOTIFY
if|if
condition|(
name|TELLME
condition|)
name|sendto
operator|=
name|TELLME
expr_stmt|;
endif|#
directive|endif
comment|/* NOTIFY */
if|if
condition|(
name|sendto
operator|==
name|NULL
operator|||
operator|*
name|sendto
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
block|}
name|verifyname
argument_list|(
name|sendto
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|myside
operator|=
name|p
index|[
name|WTR
index|]
expr_stmt|;
name|hisside
operator|=
name|p
index|[
name|RDR
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|vfork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* myside and hisside reverse roles in child */
operator|(
name|void
operator|)
name|close
argument_list|(
name|myside
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
name|hisside
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|hisside
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SENDMAIL
name|execl
argument_list|(
name|SENDMAIL
argument_list|,
literal|"sendmail"
argument_list|,
literal|"-oi"
argument_list|,
literal|"-oeq"
argument_list|,
name|sendto
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SENDMAIL */
ifdef|#
directive|ifdef
name|MMDF
name|execl
argument_list|(
name|MMDF
argument_list|,
literal|"inews-mail"
argument_list|,
literal|"-smuxto,cc*"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MMDF */
name|execl
argument_list|(
literal|"/usr/bin/mailx"
argument_list|,
literal|"mail"
argument_list|,
name|sendto
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/bin/mail"
argument_list|,
literal|"mail"
argument_list|,
name|sendto
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/ucb/mail"
argument_list|,
literal|"mail"
argument_list|,
name|sendto
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/mail"
argument_list|,
literal|"mail"
argument_list|,
name|sendto
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
name|mopen_pid
index|[
name|myside
index|]
operator|=
name|pid
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|hisside
argument_list|)
expr_stmt|;
return|return
operator|(
name|fdopen
argument_list|(
name|myside
argument_list|,
literal|"w"
argument_list|)
operator|)
return|;
block|}
name|mclose
argument_list|(
argument|ptr
argument_list|)
name|FILE
modifier|*
name|ptr
decl_stmt|;
block|{
specifier|register
name|f
operator|,
name|r
operator|,
call|(
modifier|*
name|hstat
call|)
argument_list|()
operator|,
call|(
modifier|*
name|istat
call|)
argument_list|()
operator|,
call|(
modifier|*
name|qstat
call|)
argument_list|()
expr_stmt|;
name|int
name|status
decl_stmt|;
name|f
operator|=
name|fileno
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|qstat
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|hstat
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|mopen_pid
index|[
name|f
index|]
operator|&&
name|r
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|hstat
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/*  * mhopen a pipe to mail, write out a std header, and return the file ptr.  *  * We don't include a From: field because this is probably uucp, i.e.  * explicitly routed.  Leave it up to the recipient's mailer.  * Always include the To: field because if we ge back failed mail, we  * might be able to deliver it by hand if we know to wom it was addressed.  * By convention, hptr==NULL means to send the message to the local contact person.  */
name|FILE
modifier|*
name|mailhdr
parameter_list|(
name|hptr
parameter_list|,
name|subject
parameter_list|)
name|struct
name|hbuf
modifier|*
name|hptr
decl_stmt|;
name|char
modifier|*
name|subject
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|char
modifier|*
name|to
init|=
literal|"usenet"
decl_stmt|;
specifier|extern
name|char
modifier|*
name|mydomain
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|NOTIFY
if|if
condition|(
name|TELLME
operator|&&
operator|*
name|TELLME
condition|)
name|to
operator|=
name|TELLME
expr_stmt|;
endif|#
directive|endif
comment|/* NOTIFY */
if|if
condition|(
name|hptr
condition|)
name|to
operator|=
name|replyname
argument_list|(
name|hptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|mhopen
argument_list|(
name|hptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Date: %s\n"
argument_list|,
name|arpadate
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MMDF
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"From: The News System<usenet@%s>\n"
argument_list|,
name|FROMSYSNAME
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MMDF */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"To: %s\n"
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Subject: %s\n"
argument_list|,
name|subject
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Responding-System: %s\n\n"
argument_list|,
name|LOCALSYSNAME
argument_list|)
expr_stmt|;
block|}
return|return
name|fp
return|;
block|}
comment|/*  * verify that the name mail is being sent to does not contain any  * nasty hooks to invoke funny functions from the shell or the like.  */
name|verifyname
argument_list|(
argument|sendto
argument_list|)
name|char
modifier|*
name|sendto
decl_stmt|;
block|{
comment|/* Be sure we DO allow alphabetics, !, :, ., -, @. *. */
name|char
modifier|*
name|nasty
init|=
literal|"\"'\\`^|;&<>/~"
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|sendto
index|[
literal|0
index|]
operator|<=
literal|' '
condition|)
block|{
name|xerror
argument_list|(
literal|"nasty mail name %s from %s"
argument_list|,
name|sendto
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|sendto
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|strpbrk
argument_list|(
name|sendto
argument_list|,
name|nasty
argument_list|)
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|"nasty mail name %s from %s"
argument_list|,
name|sendto
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
for|for
control|(
name|nasty
operator|=
name|sendto
init|;
operator|(
name|nasty
operator|=
name|index
argument_list|(
name|nasty
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|++
name|nasty
operator|==
literal|'.'
condition|)
comment|/* check for .. */
name|error
argument_list|(
literal|"nasty mail name %s from %s"
argument_list|,
name|sendto
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Checks to make sure the control message is OK to post.  */
name|ctlcheck
argument_list|()
block|{
name|char
name|msg
index|[
name|BUFLEN
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|is_ctl
condition|)
return|return;
if|if
condition|(
name|header
operator|.
name|ctlmsg
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|msg
argument_list|,
name|header
operator|.
name|ctlmsg
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|msg
argument_list|,
name|header
operator|.
name|title
argument_list|)
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|msg
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"ihave"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"sendbad"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"sendme"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
comment|/* no restrictions */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"newgroup"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|suser
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"rmgroup"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|suser
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"sendsys"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|suser
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"checkgroups"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|suser
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"version"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
comment|/* no restrictions */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"cancel"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
comment|/* no restrictions at this level */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"delsub"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|PREFIX
argument_list|(
name|header
operator|.
name|nbuf
argument_list|,
literal|"to."
argument_list|)
condition|)
block|{
name|log
argument_list|(
literal|"Must be in a 'to.system' newsgroup."
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
name|log
argument_list|(
literal|"Unrecognized control message - %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Make sure this guy is special. */
name|suser
argument_list|()
block|{
if|if
condition|(
name|uid
operator|==
literal|0
operator|||
name|uid
operator|==
name|ROOTID
condition|)
return|return;
comment|/* 	 * We assume that since our real uid is the same as NEWSUSR 	 * (the euid) we were run by rootid and it did a setuid. 	 * Too bad we can't set just the effective uid like suid does. 	 */
if|if
condition|(
name|uid
operator|==
name|geteuid
argument_list|()
condition|)
return|return;
ifdef|#
directive|ifdef
name|IHCC
name|printf
argument_list|(
literal|"Please use the command:\n\ttoolnews providers\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"then call one of the news people.\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"Get your local netnews contact to do it for you.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

