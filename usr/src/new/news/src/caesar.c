begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * program to to decrypt caesar(tm) cypher  * (caesar is a trademark of the roman empire)  *  * to compile:  *  *	cc decrypt.c -lm -o decrypt.c  *  * usage:  *  *	decrypt [n]< file  *  * where n is an optional forced rotation.  *  * authors: Stan King, John Eldridge, based on algorithm suggested by  *		Bob Morris  * 29-Sep-82  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)caesar.c	1.7	4/16/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCCSID */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|calloc
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
comment|/* letter frequencies (taken from some unix(tm) documentation) */
comment|/* (unix is a trademark of Bell Laboratories) */
specifier|static
name|double
name|stdf
index|[
literal|26
index|]
init|=
block|{
literal|7.97
block|,
literal|1.35
block|,
literal|3.61
block|,
literal|4.78
block|,
literal|12.37
block|,
literal|2.01
block|,
literal|1.46
block|,
literal|4.49
block|,
literal|6.39
block|,
literal|0.04
block|,
literal|0.42
block|,
literal|3.81
block|,
literal|2.69
block|,
literal|5.92
block|,
literal|6.96
block|,
literal|2.91
block|,
literal|0.08
block|,
literal|6.63
block|,
literal|8.77
block|,
literal|9.68
block|,
literal|2.62
block|,
literal|0.81
block|,
literal|1.88
block|,
literal|0.23
block|,
literal|2.07
block|,
literal|0.06
block|, 	}
decl_stmt|;
name|int
name|obs
index|[
literal|26
index|]
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|try
decl_stmt|;
name|double
name|dot
decl_stmt|,
name|winnerdot
decl_stmt|;
comment|/* .. */
name|int
name|winner
decl_stmt|,
name|forced
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|inbuf
decl_stmt|;
name|bufsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|sscanf
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|forced
argument_list|)
expr_stmt|;
if|if
condition|(
name|forced
operator|==
literal|0
condition|)
name|forced
operator|=
operator|-
literal|1000
expr_stmt|;
name|inbuf
operator|=
name|calloc
argument_list|(
name|BUFSIZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* adjust frequency table to weight low probs REAL low */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
block|{
name|stdf
index|[
name|i
index|]
operator|=
name|log
argument_list|(
name|stdf
index|[
name|i
index|]
argument_list|)
operator|+
name|log
argument_list|(
literal|26.0
operator|/
literal|100.0
argument_list|)
expr_stmt|;
block|}
comment|/* Decode each line separately */
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|25
condition|;
name|obs
index|[
name|i
operator|++
index|]
operator|=
literal|0
control|)
empty_stmt|;
comment|/* get a sample of the text */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUFSIZ
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|inbuf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|bufsize
operator|=
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
name|obs
index|[
name|c
operator|-
literal|'a'
index|]
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|obs
index|[
name|c
operator|-
literal|'A'
index|]
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* now "dot" the freqs with the observed letter freqs */
comment|/*	and keep track of best fit */
name|winner
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|try
operator|=
literal|0
init|;
name|try
operator|<
literal|26
condition|;
name|try
operator|+=
literal|13
control|)
block|{
name|dot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|26
condition|;
name|i
operator|++
control|)
block|{
name|dot
operator|+=
name|obs
index|[
name|i
index|]
operator|*
name|stdf
index|[
operator|(
name|i
operator|+
name|try
operator|)
operator|%
literal|26
index|]
expr_stmt|;
block|}
comment|/* initialize winning score */
if|if
condition|(
name|try
operator|==
literal|0
condition|)
name|winnerdot
operator|=
name|dot
expr_stmt|;
if|if
condition|(
name|dot
operator|>
name|winnerdot
condition|)
block|{
comment|/* got a new winner! */
name|winner
operator|=
name|try
expr_stmt|;
name|winnerdot
operator|=
name|dot
expr_stmt|;
block|}
block|}
if|if
condition|(
name|forced
operator|!=
operator|-
literal|1000
condition|)
name|winner
operator|=
name|forced
expr_stmt|;
comment|/* print out sample buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bufsize
condition|;
name|i
operator|++
control|)
name|putchar
argument_list|(
name|rotate
argument_list|(
name|inbuf
index|[
name|i
index|]
argument_list|,
name|winner
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|rotate
parameter_list|(
name|c
parameter_list|,
name|perm
parameter_list|)
name|char
name|c
decl_stmt|;
name|int
name|perm
decl_stmt|;
block|{
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
literal|'A'
operator|+
operator|(
name|c
operator|-
literal|'A'
operator|+
name|perm
operator|)
operator|%
literal|26
return|;
block|}
elseif|else
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
literal|'a'
operator|+
operator|(
name|c
operator|-
literal|'a'
operator|+
name|perm
operator|)
operator|%
literal|26
return|;
block|}
else|else
return|return
name|c
return|;
block|}
end_function

end_unit

