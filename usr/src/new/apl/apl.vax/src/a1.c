begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|Sccsid
index|[]
init|=
literal|"a1.c @(#)a1.c	1.1	10/1/82 Berkeley "
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"apl.h"
end_include

begin_macro
name|execute
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|data
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|;
name|struct
name|item
modifier|*
name|p1
decl_stmt|;
name|int
name|j
decl_stmt|;
name|data
argument_list|(
operator|*
name|f
argument_list|)
argument_list|()
decl_stmt|,
name|d
decl_stmt|;
specifier|extern
name|char
modifier|*
name|opname
index|[]
decl_stmt|;
name|char
modifier|*
name|psiskp
parameter_list|()
function_decl|;
if|if
condition|(
name|debug
condition|)
name|dump
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop
label|:
name|i
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|EOF
condition|)
name|i
operator|&=
literal|0377
expr_stmt|;
name|lastop
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|debug
operator|&&
name|i
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"	exec %s\n"
argument_list|,
name|opname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|error
argument_list|(
literal|"exec B"
argument_list|)
expr_stmt|;
case|case
name|EOF
case|:
return|return;
case|case
name|EOL
case|:
name|pop
argument_list|()
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|COMNT
case|:
operator|*
name|sp
operator|++
operator|=
name|newdat
argument_list|(
name|DA
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|ADD
case|:
case|case
name|SUB
case|:
case|case
name|MUL
case|:
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|MIN
case|:
case|case
name|MAX
case|:
case|case
name|PWR
case|:
case|case
name|LOG
case|:
case|case
name|CIR
case|:
case|case
name|COMB
case|:
case|case
name|AND
case|:
case|case
name|OR
case|:
case|case
name|NAND
case|:
case|case
name|NOR
case|:
name|f
operator|=
name|exop
index|[
name|i
index|]
expr_stmt|;
name|p
operator|=
name|fetch2
argument_list|()
expr_stmt|;
name|p1
operator|=
name|sp
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|ex_dscal
argument_list|(
literal|0
argument_list|,
name|f
argument_list|,
name|p
argument_list|,
name|p1
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|EQ
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|NE
case|:
name|f
operator|=
name|exop
index|[
name|i
index|]
expr_stmt|;
name|p
operator|=
name|fetch2
argument_list|()
expr_stmt|;
name|p1
operator|=
name|sp
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|ex_dscal
argument_list|(
literal|1
argument_list|,
name|f
argument_list|,
name|p
argument_list|,
name|p1
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|SGN
case|:
case|case
name|RECIP
case|:
case|case
name|ABS
case|:
case|case
name|FLOOR
case|:
case|case
name|CEIL
case|:
case|case
name|EXP
case|:
case|case
name|LOGE
case|:
case|case
name|PI
case|:
case|case
name|RAND
case|:
case|case
name|FAC
case|:
case|case
name|NOT
case|:
name|f
operator|=
name|exop
index|[
name|i
index|]
expr_stmt|;
name|p
operator|=
name|fetch1
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|DA
condition|)
name|error
argument_list|(
literal|"monadic T"
argument_list|)
expr_stmt|;
name|dp
operator|=
name|p
operator|->
name|datap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dp
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
operator|*
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
case|case
name|MEPS
case|:
comment|/*      execute         */
case|case
name|MENC
case|:
comment|/*      monadic encode  */
case|case
name|DRHO
case|:
case|case
name|DIOT
case|:
case|case
name|EPS
case|:
case|case
name|REP
case|:
case|case
name|BASE
case|:
case|case
name|DEAL
case|:
case|case
name|DTRN
case|:
case|case
name|CAT
case|:
case|case
name|CATK
case|:
case|case
name|TAKE
case|:
case|case
name|DROP
case|:
case|case
name|DDOM
case|:
case|case
name|MDOM
case|:
case|case
name|GDU
case|:
case|case
name|GDUK
case|:
case|case
name|GDD
case|:
case|case
name|GDDK
case|:
case|case
name|COM
case|:
case|case
name|COM0
case|:
case|case
name|COMK
case|:
case|case
name|EXD
case|:
case|case
name|EXD0
case|:
case|case
name|EXDK
case|:
case|case
name|ROT
case|:
case|case
name|ROT0
case|:
case|case
name|ROTK
case|:
case|case
name|MRHO
case|:
case|case
name|MTRN
case|:
case|case
name|RAV
case|:
case|case
name|RAVK
case|:
case|case
name|RED
case|:
case|case
name|RED0
case|:
case|case
name|REDK
case|:
case|case
name|SCAN
case|:
case|case
name|SCANK
case|:
case|case
name|SCAN0
case|:
case|case
name|REV
case|:
case|case
name|REV0
case|:
case|case
name|REVK
case|:
case|case
name|ASGN
case|:
case|case
name|INDEX
case|:
case|case
name|ELID
case|:
case|case
name|IPROD
case|:
case|case
name|OPROD
case|:
case|case
name|IMMED
case|:
case|case
name|HPRINT
case|:
case|case
name|PRINT
case|:
case|case
name|MIOT
case|:
case|case
name|MIBM
case|:
case|case
name|DIBM
case|:
case|case
name|BRAN0
case|:
case|case
name|BRAN
case|:
case|case
name|FUN
case|:
case|case
name|ARG1
case|:
case|case
name|ARG2
case|:
case|case
name|AUTO
case|:
case|case
name|REST
case|:
case|case
name|QRUN
case|:
case|case
name|QEXEC
case|:
case|case
name|FDEF
case|:
case|case
name|QFORK
case|:
case|case
name|QEXIT
case|:
case|case
name|QWAIT
case|:
case|case
name|QREAD
case|:
case|case
name|QWRITE
case|:
case|case
name|QUNLNK
case|:
case|case
name|QRD
case|:
case|case
name|QDUP
case|:
case|case
name|QAP
case|:
case|case
name|QKILL
case|:
case|case
name|QSEEK
case|:
case|case
name|QOPEN
case|:
case|case
name|QCREAT
case|:
case|case
name|QCLOSE
case|:
case|case
name|QCHDIR
case|:
case|case
name|QPIPE
case|:
case|case
name|QCRP
case|:
case|case
name|MFMT
case|:
case|case
name|DFMT
case|:
case|case
name|QNC
case|:
case|case
name|NILRET
case|:
case|case
name|LABEL
case|:
case|case
name|SICLR
case|:
case|case
name|SICLR0
case|:
case|case
name|QSIGNL
case|:
case|case
name|QFLOAT
case|:
case|case
name|QNL
case|:
name|pcp
operator|=
name|s
expr_stmt|;
call|(
modifier|*
name|exop
index|[
name|i
index|]
call|)
argument_list|()
expr_stmt|;
name|s
operator|=
name|pcp
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|RVAL
case|:
comment|/* de-referenced LVAL */
name|s
operator|+=
name|copy
argument_list|(
name|IN
argument_list|,
name|s
argument_list|,
operator|&
name|p1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|p1
operator|)
operator|->
name|use
operator|!=
name|DA
condition|)
name|ex_nilret
argument_list|()
expr_stmt|;
comment|/* no fn rslt */
else|else
operator|*
name|sp
operator|++
operator|=
name|fetch
argument_list|(
name|p1
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|NAME
case|:
name|s
operator|+=
name|copy
argument_list|(
name|IN
argument_list|,
name|s
argument_list|,
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|QUOT
case|:
name|j
operator|=
name|CH
expr_stmt|;
goto|goto
name|con
goto|;
case|case
name|CONST
case|:
name|j
operator|=
name|DA
expr_stmt|;
name|con
label|:
name|i
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|p
operator|=
name|newdat
argument_list|(
name|j
argument_list|,
name|i
operator|==
literal|1
condition|?
literal|0
else|:
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|s
operator|+=
name|copy
argument_list|(
name|j
argument_list|,
name|s
argument_list|,
name|p
operator|->
name|datap
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|p
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|QUAD
case|:
operator|*
name|sp
operator|++
operator|=
name|newdat
argument_list|(
name|QD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|XQUAD
case|:
operator|*
name|sp
operator|++
operator|=
name|newdat
argument_list|(
name|QX
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|QQUAD
case|:
operator|*
name|sp
operator|++
operator|=
name|newdat
argument_list|(
name|QQ
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|CQUAD
case|:
operator|*
name|sp
operator|++
operator|=
name|newdat
argument_list|(
name|QC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|PSI1
case|:
name|p
operator|=
name|fetch1
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|pop
argument_list|()
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
else|else
name|s
operator|=
name|psiskp
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|ISP1
case|:
name|p
operator|=
name|fetch1
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|pop
argument_list|()
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
else|else
name|s
operator|=
name|psiskp
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|PSI2
case|:
case|case
name|ISP2
case|:
goto|goto
name|loop
goto|;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|psiskp
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|;
specifier|register
name|cnt
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|cnt
operator|=
literal|1
expr_stmt|;
name|psilp
label|:
name|i
operator|=
operator|*
name|s
operator|++
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
goto|goto
name|psilp
goto|;
case|case
name|NAME
case|:
name|s
operator|+=
name|copy
argument_list|(
name|IN
argument_list|,
name|s
argument_list|,
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|++
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
goto|goto
name|psilp
goto|;
case|case
name|QUOT
case|:
name|i
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|s
operator|+=
name|i
expr_stmt|;
goto|goto
name|psilp
goto|;
case|case
name|CONST
case|:
name|i
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|s
operator|+=
name|i
operator|*
name|SDAT
expr_stmt|;
goto|goto
name|psilp
goto|;
case|case
name|PSI1
case|:
case|case
name|ISP1
case|:
name|cnt
operator|++
expr_stmt|;
goto|goto
name|psilp
goto|;
case|case
name|PSI2
case|:
case|case
name|ISP2
case|:
if|if
condition|(
operator|(
operator|--
name|cnt
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|sp
operator|++
operator|=
name|newdat
argument_list|(
name|DA
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
goto|goto
name|psilp
goto|;
block|}
block|}
end_function

begin_macro
name|ex_dscal
argument_list|(
argument|m
argument_list|,
argument|f
argument_list|,
argument|p1
argument_list|,
argument|p2
argument_list|)
end_macro

begin_function_decl
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|item
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|p1
operator|->
name|type
operator|!=
name|p2
operator|->
name|type
condition|)
name|error
argument_list|(
literal|"dyadic C"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|type
operator|==
name|CH
condition|)
if|if
condition|(
name|m
condition|)
name|ex_cdyad
argument_list|(
name|f
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"dyadic T"
argument_list|)
expr_stmt|;
else|else
name|ex_ddyad
argument_list|(
name|f
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ex_ddyad
argument_list|(
argument|f
argument_list|,
argument|ap
argument_list|,
argument|ap1
argument_list|)
end_macro

begin_function_decl
name|data
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|item
modifier|*
name|ap
decl_stmt|,
modifier|*
name|ap1
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|;
specifier|register
name|data
modifier|*
name|dp
decl_stmt|;
name|struct
name|item
modifier|*
name|p1
decl_stmt|;
name|data
name|d
decl_stmt|;
comment|/* Conform arguments to function if necessary.  If they 	 * do not conform and one argument is a scalar, extend 	 * it into an array with the same dimensions as the 	 * other argument.  If neither argument is a scalar, but 	 * one is a 1-element vector, extend its shape to match 	 * the other argument. 	 */
name|p
operator|=
name|ap
expr_stmt|;
name|p1
operator|=
name|ap1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rank
operator|<
literal|2
operator|&&
name|p
operator|->
name|size
operator|==
literal|1
operator|&&
name|p1
operator|->
name|rank
operator|!=
literal|0
condition|)
block|{
name|d
operator|=
name|p
operator|->
name|datap
index|[
literal|0
index|]
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
name|dp
operator|=
name|p
operator|->
name|datap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dp
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
name|d
argument_list|,
operator|*
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|p1
operator|->
name|rank
operator|<
literal|2
operator|&&
name|p1
operator|->
name|size
operator|==
literal|1
condition|)
block|{
name|sp
operator|--
expr_stmt|;
name|d
operator|=
name|p1
operator|->
name|datap
index|[
literal|0
index|]
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|p
expr_stmt|;
name|dp
operator|=
name|p
operator|->
name|datap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dp
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
operator|*
name|dp
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|p1
operator|->
name|rank
operator|!=
name|p
operator|->
name|rank
condition|)
name|error
argument_list|(
literal|"dyadic C"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|rank
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|dim
index|[
name|i
index|]
operator|!=
name|p1
operator|->
name|dim
index|[
name|i
index|]
condition|)
name|error
argument_list|(
literal|"dyadic C"
argument_list|)
expr_stmt|;
name|dp
operator|=
name|p1
operator|->
name|datap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dp
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
name|p
operator|->
name|datap
index|[
name|i
index|]
argument_list|,
operator|*
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
name|pop
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|ex_cdyad
argument_list|(
argument|f
argument_list|,
argument|ap
argument_list|,
argument|ap1
argument_list|)
end_macro

begin_function_decl
name|data
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|item
modifier|*
name|ap
decl_stmt|,
modifier|*
name|ap1
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|item
modifier|*
name|p1
decl_stmt|;
name|data
name|d1
decl_stmt|,
name|d2
decl_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
name|p1
operator|=
name|ap1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rank
operator|==
literal|0
operator|||
name|p
operator|->
name|size
operator|==
literal|1
condition|)
block|{
name|d1
operator|=
operator|(
operator|(
expr|struct
name|chrstrct
operator|*
operator|)
name|p
operator|->
name|datap
operator|)
operator|->
name|c
index|[
literal|0
index|]
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|datap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|d2
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p1
operator|->
name|rank
operator|==
literal|0
operator|||
name|p1
operator|->
name|size
operator|==
literal|1
condition|)
block|{
name|sp
operator|--
expr_stmt|;
name|d1
operator|=
operator|(
operator|(
expr|struct
name|chrstrct
operator|*
operator|)
name|p1
operator|->
name|datap
operator|)
operator|->
name|c
index|[
literal|0
index|]
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|p
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|datap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|d2
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
name|d2
argument_list|,
name|d1
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|p1
operator|->
name|rank
operator|!=
name|p
operator|->
name|rank
condition|)
name|error
argument_list|(
literal|"dyadic C"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|rank
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|dim
index|[
name|i
index|]
operator|!=
name|p1
operator|->
name|dim
index|[
name|i
index|]
condition|)
name|error
argument_list|(
literal|"dyadic C"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|p1
operator|->
name|datap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|d1
operator|=
operator|(
operator|(
expr|struct
name|chrstrct
operator|*
operator|)
name|p
operator|->
name|datap
operator|)
operator|->
name|c
index|[
name|i
index|]
expr_stmt|;
name|d2
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
name|p
operator|=
name|p1
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * now convert the character vector to 	 * a numeric array.  Someday, we can make this a 	 * call to whomever creates "logical" type data. 	 */
name|p1
operator|=
name|p
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|datap
expr_stmt|;
name|p
operator|=
name|newdat
argument_list|(
name|DA
argument_list|,
name|p
operator|->
name|rank
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|rank
condition|;
name|i
operator|++
control|)
name|p
operator|->
name|dim
index|[
name|i
index|]
operator|=
name|p1
operator|->
name|dim
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|size
condition|;
name|i
operator|++
control|)
name|p
operator|->
name|datap
index|[
name|i
index|]
operator|=
operator|(
operator|*
name|cp
operator|++
operator|)
operator|&
literal|0377
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|p
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *   exop[] moved to seperate file "at.c"  *   (a1.c had a "symbol table overflow".)  */
end_comment

begin_macro
name|ex_botch
argument_list|()
end_macro

begin_block
block|{
name|error
argument_list|(
literal|"exec P E"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

