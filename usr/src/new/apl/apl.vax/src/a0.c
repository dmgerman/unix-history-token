begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|Sccsid
index|[]
init|=
literal|"a0.c @(#)a0.c	1.5	6/16/87 Berkeley "
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"apl.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_decl_stmt
name|int
name|chartab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mkcore
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* produce core image upon fatal error */
end_comment

begin_decl_stmt
name|int
name|edmagic
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* turn on "ed" magic characters */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argp
parameter_list|)
name|char
modifier|*
modifier|*
name|argp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|a
operator|,
name|b
expr_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|fflag
decl_stmt|;
name|int
name|intr
argument_list|()
decl_stmt|,
name|intprws
argument_list|()
decl_stmt|;
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
extern|extern headline[];
ifdef|#
directive|ifdef
name|NBUF
name|struct
name|iobuf
name|iobf
index|[
name|NBUF
index|]
decl_stmt|;
comment|/* Actual buffers */
endif|#
directive|endif
name|time
argument_list|(
operator|&
name|stime
argument_list|)
expr_stmt|;
comment|/* 	 * kludge to force use of file descriptor in time part 	 * of C library; otherwise sbrks are going to die. 	 */
operator|(
name|void
operator|)
name|localtime
argument_list|(
operator|&
name|stime
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NBUF
name|iobuf
operator|=
name|iobf
expr_stmt|;
comment|/* Set up buffer pointer */
name|initbuf
argument_list|()
expr_stmt|;
comment|/* Set up to run */
endif|#
directive|endif
comment|/* 	 * setup scratch files  	 */
name|a
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|scr_file
operator|=
literal|"/tmp/apled.000000"
expr_stmt|;
name|ws_file
operator|=
literal|"/tmp/aplws.000000"
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|16
init|;
name|c
operator|>
literal|10
condition|;
name|c
operator|--
control|)
block|{
name|b
operator|=
literal|'0'
operator|+
name|a
operator|%
literal|10
expr_stmt|;
name|scr_file
index|[
name|c
index|]
operator|=
name|b
expr_stmt|;
name|ws_file
index|[
name|c
index|]
operator|=
name|b
expr_stmt|;
name|a
operator|/=
literal|10
expr_stmt|;
block|}
name|offexit
operator|=
name|isatty
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|echoflg
operator|=
operator|!
name|offexit
expr_stmt|;
name|a
operator|=
literal|1
expr_stmt|;
comment|/* catch signals */
comment|/* Check to see if argp[0] is "prws".  If so, set prwsflg */
for|for
control|(
name|p
operator|=
name|argp
index|[
literal|0
index|]
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
empty_stmt|;
while|while
condition|(
name|p
operator|>
name|argp
index|[
literal|0
index|]
operator|&&
operator|*
name|p
operator|!=
literal|'/'
condition|)
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|p
operator|++
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|4
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|!
name|p
index|[
name|c
index|]
operator|||
name|p
index|[
name|c
index|]
operator|!=
literal|"prws"
index|[
name|c
index|]
condition|)
goto|goto
name|notprws
goto|;
name|prwsflg
operator|=
literal|1
expr_stmt|;
name|CLOSEF
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|notprws
label|:
comment|/* other flags... */
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argp
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
operator|++
operator|*
name|argp
condition|)
switch|switch
condition|(
operator|*
operator|*
name|argp
condition|)
block|{
case|case
literal|'e'
case|:
name|echoflg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|echoflg
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|a
operator|=
literal|0
expr_stmt|;
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
name|mkcore
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|scr_file
operator|+=
literal|5
expr_stmt|;
name|ws_file
operator|+=
literal|5
expr_stmt|;
case|case
literal|'m'
case|:
name|apl_term
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|edmagic
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|offexit
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|prwsflg
condition|)
name|echoflg
operator|=
name|mkcore
operator|=
name|a
operator|=
literal|0
expr_stmt|;
comment|/* "prws" settings */
name|thread
operator|.
name|iorg
operator|=
literal|1
expr_stmt|;
name|srand
argument_list|(
name|thread
operator|.
name|rl
operator|=
literal|1
argument_list|)
expr_stmt|;
name|thread
operator|.
name|width
operator|=
literal|72
expr_stmt|;
name|thread
operator|.
name|digits
operator|=
literal|9
expr_stmt|;
name|thread
operator|.
name|fuzz
operator|=
literal|1.0e-13
expr_stmt|;
name|aplmod
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Turn on APL mode */
if|if
condition|(
name|a
condition|)
name|catchsigs
argument_list|()
expr_stmt|;
if|if
condition|(
name|prwsflg
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intprws
argument_list|)
expr_stmt|;
else|else
name|fppinit
argument_list|()
expr_stmt|;
comment|/* 	 * open ws file 	 */
name|CLOSEF
argument_list|(
name|opn
argument_list|(
name|WSFILE
argument_list|,
literal|0600
argument_list|)
argument_list|)
expr_stmt|;
name|wfile
operator|=
name|opn
argument_list|(
name|WSFILE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|zero
operator|=
literal|0
expr_stmt|;
name|one
operator|=
literal|1
expr_stmt|;
name|maxexp
operator|=
literal|88
expr_stmt|;
name|pi
operator|=
literal|3.141592653589793238462643383
expr_stmt|;
name|sp
operator|=
name|stack
expr_stmt|;
name|fflag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|prwsflg
condition|)
block|{
if|if
condition|(
operator|(
name|unsigned
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intr
argument_list|)
operator|&
literal|01
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|headline
argument_list|)
expr_stmt|;
block|}
name|setexit
argument_list|()
expr_stmt|;
if|if
condition|(
name|fflag
condition|)
block|{
name|fflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
operator|(
name|a
operator|=
name|opn
argument_list|(
name|argp
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|wsload
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|argp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|CLOSEF
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|a
operator|=
name|OPENF
argument_list|(
literal|"continue"
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"clear ws\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wsload
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" continue\n"
argument_list|)
expr_stmt|;
name|CLOSEF
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prwsflg
condition|)
block|{
name|ex_prws
argument_list|()
expr_stmt|;
name|term
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|evLlx
argument_list|()
expr_stmt|;
comment|/* eval latent expr, if any */
block|}
name|mainloop
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|mainloop
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|comp
decl_stmt|;
specifier|static
name|eotcount
operator|=
name|MAXEOT
expr_stmt|;
comment|/* maximum eot's on input */
name|setexit
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|echoflg
condition|)
name|echoflg
operator|=
literal|1
expr_stmt|;
comment|/* enabled echo echo suppress off */
name|checksp
argument_list|()
expr_stmt|;
if|if
condition|(
name|intflg
condition|)
name|error
argument_list|(
literal|"I"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|a
operator|=
name|rline
argument_list|(
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
block|{
name|offexit
operator|&=
name|isatty
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|offexit
condition|)
block|{
if|if
condition|(
name|eotcount
operator|--
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\ruse \')off\' to exit\n"
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|term
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* close down and exit */
block|}
name|comp
operator|=
name|compile
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|==
literal|0
condition|)
continue|continue;
name|execute
argument_list|(
name|comp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
comment|/* note that if the execute errors out, then 		 * the allocated space pointed to by comp is never 		 * freed.  This is hard to fix. 		 */
block|}
block|}
end_block

begin_macro
name|intr
argument_list|()
end_macro

begin_block
block|{
name|intflg
operator|=
literal|1
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intr
argument_list|)
expr_stmt|;
name|SEEKF
argument_list|(
literal|0
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|intprws
argument_list|()
end_macro

begin_block
block|{
comment|/* "prws" interrupt -- restore old tty modes and exit */
name|term
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|rline
parameter_list|(
name|s
parameter_list|)
block|{
name|int
name|rlcmp
parameter_list|()
function_decl|;
name|char
name|line
index|[
name|CANBS
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|c
operator|,
name|col
expr_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|retval
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
name|col
operator|=
name|s
expr_stmt|;
name|p
operator|=
name|line
expr_stmt|;
name|loop
label|:
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|intflg
condition|)
name|error
argument_list|(
literal|"I"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
operator|-
literal|1
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'\b'
case|:
if|if
condition|(
name|col
condition|)
name|col
operator|--
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'\t'
case|:
name|col
operator|=
operator|(
name|col
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|' '
case|:
name|col
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'\r'
case|:
name|col
operator|=
literal|0
expr_stmt|;
goto|goto
name|loop
goto|;
default|default:
if|if
condition|(
name|p
operator|>=
name|line
operator|+
name|CANBS
operator|-
literal|2
operator|||
name|col
operator|>
literal|127
condition|)
name|error
argument_list|(
literal|"line too long"
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|col
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
comment|/* was and'ed with 0177... */
name|col
operator|++
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'\n'
case|:
empty_stmt|;
block|}
name|qsort
argument_list|(
name|line
argument_list|,
operator|(
name|p
operator|-
name|line
operator|)
operator|/
literal|2
argument_list|,
literal|2
argument_list|,
name|rlcmp
argument_list|)
expr_stmt|;
name|c
operator|=
name|p
index|[
operator|-
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|line
condition|)
name|c
operator|=
literal|1
expr_stmt|;
comment|/* check for blank line */
operator|*
name|p
operator|=
operator|-
literal|1
expr_stmt|;
name|col
operator|=
operator|-
literal|1
expr_stmt|;
name|cp
operator|=
operator|(
name|retval
operator|=
name|alloc
argument_list|(
name|c
operator|+
literal|3
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|line
init|;
name|p
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|;
name|p
operator|+=
literal|2
control|)
block|{
while|while
condition|(
operator|++
name|col
operator|!=
name|p
index|[
literal|0
index|]
condition|)
operator|*
operator|++
name|cp
operator|=
literal|' '
expr_stmt|;
operator|*
operator|++
name|cp
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|p
index|[
literal|2
index|]
operator|==
name|col
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|!=
operator|*
name|cp
condition|)
block|{
name|i
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
name|p
index|[
literal|3
index|]
expr_stmt|;
break|break;
block|}
name|p
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|!=
name|col
condition|)
continue|continue;
while|while
condition|(
name|p
index|[
literal|2
index|]
operator|==
name|col
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|!=
operator|*
name|cp
condition|)
goto|goto
name|yuck
goto|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|vax
name|i
operator|=
operator|(
operator|(
name|i
operator|<<
literal|8
operator|)
operator||
operator|*
name|cp
operator|)
operator|&
literal|0177777
expr_stmt|;
else|#
directive|else
name|i
operator||=
operator|*
name|cp
operator|<<
literal|8
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|j
operator|=
literal|0
init|;
name|chartab
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|chartab
index|[
name|j
index|]
condition|)
block|{
operator|*
name|cp
operator|=
name|j
operator||
literal|0200
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|j
condition|)
block|{
name|yuck
label|:
operator|*
name|cp
operator|=
literal|'\n'
expr_stmt|;
name|pline
argument_list|(
name|cp
argument_list|,
operator|++
name|col
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Y error"
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
operator|++
name|cp
operator|=
literal|'\n'
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_macro
name|rlcmp
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|=
name|a
index|[
literal|0
index|]
operator|-
name|b
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|c
operator|)
return|;
return|return
operator|(
name|a
index|[
literal|1
index|]
operator|-
name|b
index|[
literal|1
index|]
operator|)
return|;
block|}
end_block

begin_macro
name|pline
argument_list|(
argument|str
argument_list|,
argument|loc
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|c
operator|,
name|l
operator|,
name|col
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|c
operator|=
operator|*
name|str
operator|++
expr_stmt|;
name|l
operator|++
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|loc
condition|)
name|col
operator|=
name|column
expr_stmt|;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
if|if
condition|(
name|col
condition|)
block|{
name|putto
argument_list|(
name|col
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|putto
argument_list|(
argument|col
argument_list|)
end_macro

begin_block
block|{
while|while
condition|(
name|col
operator|>
name|column
operator|+
literal|8
condition|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
while|while
condition|(
name|col
operator|>
name|column
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|term
argument_list|(
argument|s
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|j
expr_stmt|;
name|unlink
argument_list|(
name|WSFILE
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|scr_file
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|aplmod
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* turn off APL mode */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NFDS
condition|;
name|j
operator|++
control|)
comment|/* Close files */
name|CLOSEF
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fix
argument_list|(
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|data
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|i
operator|=
name|floor
argument_list|(
name|d
operator|+
literal|0.5
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|fuzz
argument_list|(
argument|d1
argument_list|,
argument|d2
argument_list|)
end_macro

begin_decl_stmt
name|data
name|d1
decl_stmt|,
name|d2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|f1
decl_stmt|,
name|f2
decl_stmt|;
name|f1
operator|=
name|d1
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|0.
condition|)
name|f1
operator|=
operator|-
name|f1
expr_stmt|;
name|f2
operator|=
name|d2
expr_stmt|;
if|if
condition|(
name|f2
operator|<
literal|0.
condition|)
name|f2
operator|=
operator|-
name|f2
expr_stmt|;
if|if
condition|(
name|f2
operator|>
name|f1
condition|)
name|f1
operator|=
name|f2
expr_stmt|;
name|f1
operator|*=
name|thread
operator|.
name|fuzz
expr_stmt|;
if|if
condition|(
name|d1
operator|>
name|d2
condition|)
block|{
if|if
condition|(
name|d2
operator|+
name|f1
operator|>=
name|d1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|d1
operator|+
name|f1
operator|>=
name|d2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|pop
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|sp
operator|<=
name|stack
condition|)
name|error
argument_list|(
literal|"pop B"
argument_list|)
expr_stmt|;
name|dealloc
argument_list|(
operator|*
operator|--
name|sp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|erase
argument_list|(
argument|np
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
operator|*
name|p
expr_stmt|;
name|p
operator|=
name|np
operator|->
name|itemp
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
switch|switch
condition|(
name|np
operator|->
name|use
condition|)
block|{
case|case
name|NF
case|:
case|case
name|MF
case|:
case|case
name|DF
case|:
for|for
control|(
init|;
operator|*
name|p
operator|>
literal|0
condition|;
operator|(
operator|*
name|p
operator|)
operator|--
control|)
name|free
argument_list|(
name|p
index|[
operator|*
name|p
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|np
operator|->
name|itemp
operator|=
literal|0
expr_stmt|;
block|}
name|np
operator|->
name|use
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|dealloc
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|item
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|p
operator|->
name|type
condition|)
block|{
default|default:
name|printf
argument_list|(
literal|"[dealloc botch: %d]\n"
argument_list|,
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
return|return;
case|case
name|LBL
case|:
operator|(
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|p
operator|)
operator|->
name|use
operator|=
literal|0
expr_stmt|;
comment|/* delete label */
case|case
name|LV
case|:
return|return;
case|case
name|DA
case|:
case|case
name|CH
case|:
case|case
name|QQ
case|:
case|case
name|QD
case|:
case|case
name|QC
case|:
case|case
name|EL
case|:
case|case
name|DU
case|:
case|case
name|QX
case|:
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|struct
name|item
modifier|*
name|newdat
parameter_list|(
name|type
parameter_list|,
name|rank
parameter_list|,
name|size
parameter_list|)
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|;
comment|/* Allocate a new data item.  I have searched the specifications 	 * for C and as far as I can tell, it should be legal to 	 * declare a zero-length array inside a structure.  However, 	 * the VAX C compiler (which I think is a derivative of the 	 * portable C compiler) does not allow this.  The Ritchie 	 * V7 PDP-11 compiler does.  I have redeclared "dim" to 	 * contain MRANK elements.  When the data is allocated, 	 * space is only allocated for as many dimensions as there 	 * actually are.  Thus, if there are 0 dimensions, no space 	 * will be allocated for "dim".  This had better make the 	 * VAX happy, since it has sure made me unhappy. 	 * 	 * --John Bruner 	 */
if|if
condition|(
name|rank
operator|>
name|MRANK
condition|)
name|error
argument_list|(
literal|"max R"
argument_list|)
expr_stmt|;
name|i
operator|=
sizeof|sizeof
expr|*
name|p
operator|-
name|SINT
operator|*
operator|(
name|MRANK
operator|-
name|rank
operator|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DA
condition|)
name|i
operator|+=
name|size
operator|*
name|SDAT
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|CH
condition|)
name|i
operator|+=
name|size
expr_stmt|;
name|p
operator|=
name|alloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|p
operator|->
name|rank
operator|=
name|rank
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|p
operator|->
name|index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rank
operator|==
literal|1
condition|)
name|p
operator|->
name|dim
index|[
literal|0
index|]
operator|=
name|size
expr_stmt|;
name|p
operator|->
name|datap
operator|=
operator|(
name|data
operator|*
operator|)
operator|&
name|p
operator|->
name|dim
index|[
name|rank
index|]
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|item
modifier|*
name|dupdat
parameter_list|(
name|ap
parameter_list|)
name|struct
name|item
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|item
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|p1
operator|=
name|ap
expr_stmt|;
name|p2
operator|=
name|newdat
argument_list|(
name|p1
operator|->
name|type
argument_list|,
name|p1
operator|->
name|rank
argument_list|,
name|p1
operator|->
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p1
operator|->
name|rank
condition|;
name|i
operator|++
control|)
name|p2
operator|->
name|dim
index|[
name|i
index|]
operator|=
name|p1
operator|->
name|dim
index|[
name|i
index|]
expr_stmt|;
name|copy
argument_list|(
name|p1
operator|->
name|type
argument_list|,
name|p1
operator|->
name|datap
argument_list|,
name|p2
operator|->
name|datap
argument_list|,
name|p1
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|p2
operator|)
return|;
block|}
end_function

begin_macro
name|copy
argument_list|(
argument|type
argument_list|,
argument|from
argument_list|,
argument|to
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|size
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|a
operator|=
name|from
expr_stmt|;
name|b
operator|=
name|to
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DA
condition|)
name|i
operator|*=
name|SDAT
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|IN
condition|)
name|i
operator|*=
name|SINT
expr_stmt|;
name|s
operator|=
name|i
expr_stmt|;
do|do
operator|*
name|b
operator|++
operator|=
operator|*
name|a
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|i
condition|)
do|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_block

begin_function
name|struct
name|item
modifier|*
name|fetch1
parameter_list|()
block|{
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|fetch
argument_list|(
name|sp
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|sp
index|[
operator|-
literal|1
index|]
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|item
modifier|*
name|fetch2
parameter_list|()
block|{
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|;
name|sp
index|[
operator|-
literal|2
index|]
operator|=
name|fetch
argument_list|(
name|sp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|fetch
argument_list|(
name|sp
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|sp
index|[
operator|-
literal|1
index|]
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|item
modifier|*
name|fetch
parameter_list|(
name|ip
parameter_list|)
name|struct
name|item
modifier|*
name|ip
decl_stmt|;
block|{
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|struct
name|nlist
modifier|*
name|n
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|chrstrct
modifier|*
name|cc
decl_stmt|;
extern|extern prolgerr;
name|p
operator|=
name|ip
expr_stmt|;
name|loop
label|:
switch|switch
condition|(
name|p
operator|->
name|type
condition|)
block|{
case|case
name|QX
case|:
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|n
operator|=
name|nlook
argument_list|(
literal|"Llx"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|q
operator|=
name|n
operator|->
name|itemp
expr_stmt|;
name|p
operator|=
name|dupdat
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|q
operator|->
name|type
argument_list|,
name|q
operator|->
name|datap
argument_list|,
name|p
operator|->
name|datap
argument_list|,
name|q
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
name|newdat
argument_list|(
name|CH
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|QQ
case|:
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cc
operator|=
name|rline
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"eof"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cc
operator|->
name|c
index|[
name|i
index|]
operator|!=
literal|'\n'
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|p
operator|=
name|newdat
argument_list|(
name|CH
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|CH
argument_list|,
name|cc
argument_list|,
name|p
operator|->
name|datap
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|QD
case|:
case|case
name|QC
case|:
name|printf
argument_list|(
literal|"L:\n\t"
argument_list|)
expr_stmt|;
name|i
operator|=
name|rline
argument_list|(
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"eof"
argument_list|)
expr_stmt|;
name|c
operator|=
name|compile
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
goto|goto
name|loop
goto|;
name|i
operator|=
name|pcp
expr_stmt|;
name|execute
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|pcp
operator|=
name|i
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
operator|--
name|sp
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|DU
case|:
if|if
condition|(
name|lastop
operator|!=
name|PRINT
condition|)
name|error
argument_list|(
literal|"no fn result"
argument_list|)
expr_stmt|;
case|case
name|DA
case|:
case|case
name|CH
case|:
name|p
operator|->
name|index
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
name|LV
case|:
comment|/* KLUDGE -- 		 * 		 * Currently, if something prevents APL from completing 		 * execution of line 0 of a function, it leaves with 		 * the stack in an unknown state and "gsip->oldsp" is 		 * zero.  This is nasty because there is no way to 		 * reset out of it.  The principle cause of error 		 * exits from line 0 is the fetch of an undefined 		 * function argument.  The following code attempts 		 * to fix this by setting an error flag and creating 		 * a dummy variable for the stack if "used before set" 		 * occurs in the function header.  "ex_fun" then will 		 * note that the flag is high and cause an error exit 		 * AFTER all header processing has been completed. 		 */
if|if
condition|(
operator|(
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|p
operator|)
operator|->
name|use
operator|!=
name|DA
condition|)
block|{
name|printf
argument_list|(
literal|"%s: used before set"
argument_list|,
operator|(
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|ip
operator|)
operator|->
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|gsip
operator|)
operator|||
name|gsip
operator|->
name|funlc
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|q
operator|=
name|newdat
argument_list|(
name|DA
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Dummy */
name|q
operator|->
name|datap
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|prolgerr
operator|=
literal|1
expr_stmt|;
comment|/* ERROR flag */
return|return
operator|(
name|q
operator|)
return|;
block|}
name|p
operator|=
operator|(
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|p
operator|)
operator|->
name|itemp
expr_stmt|;
name|i
operator|=
name|p
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|LBL
condition|)
name|i
operator|=
name|DA
expr_stmt|;
comment|/* treat label as data */
name|q
operator|=
name|newdat
argument_list|(
name|i
argument_list|,
name|p
operator|->
name|rank
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|IN
argument_list|,
name|p
operator|->
name|dim
argument_list|,
name|q
operator|->
name|dim
argument_list|,
name|p
operator|->
name|rank
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|i
argument_list|,
name|p
operator|->
name|datap
argument_list|,
name|q
operator|->
name|datap
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
default|default:
name|error
argument_list|(
literal|"fetch B"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|topfix
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|p
operator|=
name|fetch1
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|DA
operator|||
name|p
operator|->
name|size
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"topval C"
argument_list|)
expr_stmt|;
name|i
operator|=
name|fix
argument_list|(
name|p
operator|->
name|datap
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|bidx
argument_list|(
argument|ip
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|item
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ip
expr_stmt|;
name|idx
operator|.
name|type
operator|=
name|p
operator|->
name|type
expr_stmt|;
name|idx
operator|.
name|rank
operator|=
name|p
operator|->
name|rank
expr_stmt|;
name|copy
argument_list|(
name|IN
argument_list|,
name|p
operator|->
name|dim
argument_list|,
name|idx
operator|.
name|dim
argument_list|,
name|idx
operator|.
name|rank
argument_list|)
expr_stmt|;
name|size
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|size
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|s
expr_stmt|;
name|s
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|idx
operator|.
name|rank
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|idx
operator|.
name|del
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
name|s
operator|*=
name|idx
operator|.
name|dim
index|[
name|i
index|]
expr_stmt|;
block|}
name|idx
operator|.
name|size
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_block

begin_macro
name|colapse
argument_list|(
argument|k
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
operator|||
name|k
operator|>=
name|idx
operator|.
name|rank
condition|)
name|error
argument_list|(
literal|"collapse X"
argument_list|)
expr_stmt|;
name|idx
operator|.
name|dimk
operator|=
name|idx
operator|.
name|dim
index|[
name|k
index|]
expr_stmt|;
name|idx
operator|.
name|delk
operator|=
name|idx
operator|.
name|del
index|[
name|k
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|k
init|;
name|i
operator|<
name|idx
operator|.
name|rank
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|.
name|del
index|[
name|i
index|]
operator|=
name|idx
operator|.
name|del
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|idx
operator|.
name|dim
index|[
name|i
index|]
operator|=
name|idx
operator|.
name|dim
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|.
name|dimk
condition|)
name|idx
operator|.
name|size
operator|/=
name|idx
operator|.
name|dimk
expr_stmt|;
name|idx
operator|.
name|rank
operator|--
expr_stmt|;
block|}
end_block

begin_macro
name|forloop
argument_list|(
argument|co
argument_list|,
argument|arg
argument_list|)
end_macro

begin_function_decl
name|int
function_decl|(
modifier|*
name|co
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|idx
operator|.
name|size
operator|==
literal|0
condition|)
return|return;
comment|/* for null items */
if|if
condition|(
name|idx
operator|.
name|rank
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|co
call|)
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
control|)
block|{
while|while
condition|(
name|i
operator|<
name|idx
operator|.
name|rank
condition|)
name|idx
operator|.
name|idx
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|co
call|)
argument_list|(
name|arg
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|idx
operator|.
name|idx
index|[
name|i
operator|-
literal|1
index|]
operator|>=
name|idx
operator|.
name|dim
index|[
name|i
operator|-
literal|1
index|]
condition|)
if|if
condition|(
operator|--
name|i
operator|<=
literal|0
condition|)
return|return;
block|}
block|}
end_block

begin_macro
name|access
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|n
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idx
operator|.
name|rank
condition|;
name|i
operator|++
control|)
name|n
operator|+=
name|idx
operator|.
name|idx
index|[
name|i
index|]
operator|*
name|idx
operator|.
name|del
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_function
name|data
name|getdat
parameter_list|(
name|ip
parameter_list|)
name|struct
name|item
modifier|*
name|ip
decl_stmt|;
block|{
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|data
name|d
decl_stmt|;
comment|/* Get the data value stored at index p->index.  If the 	 * index is out of range it will be wrapped around.  If 	 * the data item is null, a zero or blank will be returned. 	 */
name|p
operator|=
name|ip
expr_stmt|;
name|i
operator|=
name|p
operator|->
name|index
expr_stmt|;
while|while
condition|(
name|i
operator|>=
name|p
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|size
operator|==
literal|0
condition|)
comment|/* let the caller beware */
return|return
operator|(
operator|(
name|p
operator|->
name|type
operator|==
name|DA
operator|)
condition|?
name|zero
else|:
operator|(
name|data
operator|)
literal|' '
operator|)
return|;
comment|/* 		if (i == 0) 			error("getdat B"); 		 */
name|i
operator|-=
name|p
operator|->
name|size
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|DA
condition|)
block|{
name|d
operator|=
name|p
operator|->
name|datap
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|CH
condition|)
block|{
name|d
operator|=
operator|(
operator|(
expr|struct
name|chrstrct
operator|*
operator|)
name|p
operator|->
name|datap
operator|)
operator|->
name|c
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"getdat B"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|p
operator|->
name|index
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|d
operator|)
return|;
block|}
end_function

begin_macro
name|putdat
argument_list|(
argument|ip
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|data
name|d
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|item
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|p
operator|=
name|ip
expr_stmt|;
name|i
operator|=
name|p
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|p
operator|->
name|size
condition|)
name|error
argument_list|(
literal|"putdat B"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|DA
condition|)
block|{
name|p
operator|->
name|datap
index|[
name|i
index|]
operator|=
name|d
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|CH
condition|)
block|{
operator|(
operator|(
expr|struct
name|chrstrct
operator|*
operator|)
name|p
operator|->
name|datap
operator|)
operator|->
name|c
index|[
name|i
index|]
operator|=
name|d
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"putdat B"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|p
operator|->
name|index
operator|=
name|i
expr_stmt|;
block|}
end_block

begin_comment
comment|/* aplmod has been moved to am.c */
end_comment

begin_function
name|struct
name|item
modifier|*
name|s2vect
parameter_list|(
name|ap
parameter_list|)
name|struct
name|item
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
name|q
operator|=
name|newdat
argument_list|(
name|p
operator|->
name|type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|q
operator|->
name|datap
operator|=
name|p
operator|->
name|datap
expr_stmt|;
name|q
operator|->
name|dim
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|nlist
modifier|*
name|nlook
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
for|for
control|(
name|np
operator|=
name|nlist
init|;
name|np
operator|->
name|namep
condition|;
name|np
operator|++
control|)
if|if
condition|(
name|equal
argument_list|(
name|np
operator|->
name|namep
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|np
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|checksp
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|sp
operator|>=
operator|&
name|stack
index|[
name|STKS
index|]
condition|)
name|error
argument_list|(
literal|"stack overflow"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|i
operator|=
name|lsize
argument_list|(
name|s1
argument_list|)
operator|-
literal|1
expr_stmt|;
name|j
operator|=
name|lsize
argument_list|(
name|s2
argument_list|)
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|q
operator|=
name|alloc
argument_list|(
name|i
operator|+
name|j
argument_list|)
expr_stmt|;
name|p
operator|+=
name|copy
argument_list|(
name|CH
argument_list|,
name|s1
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|CH
argument_list|,
name|s2
argument_list|,
name|p
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|catcode
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|i
operator|=
name|csize
argument_list|(
name|s1
argument_list|)
operator|-
literal|1
expr_stmt|;
name|j
operator|=
name|csize
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|=
name|alloc
argument_list|(
name|i
operator|+
name|j
argument_list|)
expr_stmt|;
name|p
operator|+=
name|copy
argument_list|(
name|CH
argument_list|,
name|s1
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|CH
argument_list|,
name|s2
argument_list|,
name|p
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * csize -- return size (in bytes) of a compiled string  */
end_comment

begin_macro
name|csize
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|c
operator|,
name|len
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
name|EOF
condition|)
block|{
name|len
operator|++
expr_stmt|;
name|c
operator|&=
literal|0377
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
name|i
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|QUOT
case|:
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
break|break;
case|case
name|CONST
case|:
name|i
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|i
operator|*=
name|SDAT
expr_stmt|;
name|len
operator|++
expr_stmt|;
break|break;
case|case
name|NAME
case|:
case|case
name|FUN
case|:
case|case
name|ARG1
case|:
case|case
name|ARG2
case|:
case|case
name|AUTO
case|:
case|case
name|REST
case|:
case|case
name|RVAL
case|:
name|i
operator|=
literal|2
expr_stmt|;
break|break;
block|}
name|p
operator|+=
name|i
expr_stmt|;
name|len
operator|+=
name|i
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_block

begin_macro
name|opn
argument_list|(
argument|file
argument_list|,
argument|rw
argument_list|)
end_macro

begin_decl_stmt
name|char
name|file
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|fd
operator|,
call|(
modifier|*
name|p
call|)
argument_list|()
expr_stmt|;
name|char
name|f2
index|[
literal|100
index|]
decl_stmt|;
extern|extern OPENF(
block|)
end_block

begin_operator
operator|,
end_operator

begin_expr_stmt
name|CREATF
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|p
operator|=
operator|(
name|rw
operator|>
literal|2
condition|?
name|CREATF
else|:
name|OPENF
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|fd
operator|=
call|(
modifier|*
name|p
call|)
argument_list|(
name|file
argument_list|,
name|rw
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
literal|13
condition|;
name|fd
operator|++
control|)
name|f2
index|[
name|fd
index|]
operator|=
name|LIBDIR
index|[
name|fd
index|]
expr_stmt|;
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|file
index|[
name|fd
index|]
condition|;
name|fd
operator|++
control|)
name|f2
index|[
name|fd
operator|+
literal|13
index|]
operator|=
name|file
index|[
name|fd
index|]
expr_stmt|;
name|f2
index|[
name|fd
operator|+
literal|13
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
call|(
modifier|*
name|p
call|)
argument_list|(
name|f2
argument_list|,
name|rw
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"[using %s]\n"
argument_list|,
name|f2
argument_list|)
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"can't open file %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
end_if

begin_return
return|return
operator|(
name|fd
operator|)
return|;
end_return

begin_expr_stmt
unit|}  catchsigs
operator|(
operator|)
block|{
specifier|extern
name|panic
argument_list|()
block|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|panic
argument_list|)
block|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|panic
argument_list|)
block|;
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|panic
argument_list|)
block|;
name|signal
argument_list|(
name|SIGTRAP
argument_list|,
name|panic
argument_list|)
block|;
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|panic
argument_list|)
block|;
comment|/*	signal(SIGFPE, fpe);		/* (fppinit called by "main") */
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|panic
argument_list|)
block|;
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|panic
argument_list|)
block|;
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|panic
argument_list|)
block|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|panic
argument_list|)
block|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|panic
argument_list|)
block|; }
name|panic
argument_list|(
argument|signum
argument_list|)
name|unsigned
name|signum
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|fd
expr_stmt|;
specifier|static
name|insane
operator|=
literal|0
expr_stmt|;
comment|/* if != 0, die */
specifier|static
name|char
modifier|*
name|abt_file
init|=
literal|"aplws.abort"
decl_stmt|;
specifier|static
name|char
modifier|*
name|errtbl
index|[]
init|=
block|{
literal|"excessive eofs"
block|,
literal|"hangup"
block|,
literal|"interrupt"
block|,
literal|"quit"
block|,
literal|"illegal instruction"
block|,
literal|"trace trap"
block|,
literal|"i/o trap instruction"
block|,
literal|"emt trap"
block|,
literal|"floating exception"
block|,
literal|"kill"
block|,
literal|"bus error"
block|,
literal|"segmentation violation"
block|,
literal|"bad system call"
block|,
literal|"write no pipe"
block|,
literal|"alarm clock"
block|,
literal|"software termination"
block|}
decl_stmt|;
comment|/* Attempt to save workspace.  A signal out of here always 	 * causes immediate death. 	 */
name|mencflg
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|signum
argument_list|,
name|panic
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nfatal signal: %s\n"
argument_list|,
name|errtbl
index|[
operator|(
name|signum
operator|<
name|NSIG
operator|)
condition|?
name|signum
else|:
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkcore
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|insane
operator|++
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|CREATF
argument_list|(
name|abt_file
argument_list|,
literal|0644
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"[attempting ws dump]\n"
argument_list|)
expr_stmt|;
name|wssave
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" workspace saved in %s\n"
argument_list|,
name|abt_file
argument_list|)
expr_stmt|;
name|CLOSEF
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"workspace lost -- sorry\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"recursive errors: unrecoverable\n"
argument_list|)
expr_stmt|;
name|term
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_macro
name|abort
argument_list|()
end_macro

begin_block
block|{
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGIOT
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

