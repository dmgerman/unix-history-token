begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|Sccsid
index|[]
init|=
literal|"al.c @(#)al.c	1.1	10/1/82 Berkeley "
decl_stmt|;
end_decl_stmt

begin_empty
empty|#
end_empty

begin_comment
comment|/*  *	monadic epsilon and encode /rww  */
end_comment

begin_include
include|#
directive|include
file|"apl.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_macro
name|ex_meps
argument_list|()
end_macro

begin_block
block|{
name|struct
name|item
modifier|*
name|p
decl_stmt|;
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|int
name|dim0
decl_stmt|,
name|dim1
decl_stmt|;
name|char
modifier|*
name|xpcp
decl_stmt|;
name|p
operator|=
name|fetch1
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rank
operator|>
literal|2
operator|||
name|p
operator|->
name|type
operator|!=
name|CH
condition|)
name|error
argument_list|(
literal|"execute C"
argument_list|)
expr_stmt|;
comment|/*get out if nothing to do, apr 2-23-77 */
if|if
condition|(
name|p
operator|->
name|size
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|b
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|datap
expr_stmt|;
name|dim0
operator|=
name|p
operator|->
name|rank
operator|<
literal|2
condition|?
literal|1
else|:
name|p
operator|->
name|dim
index|[
literal|0
index|]
expr_stmt|;
name|dim1
operator|=
name|p
operator|->
name|rank
operator|<
literal|2
condition|?
name|p
operator|->
name|size
else|:
name|p
operator|->
name|dim
index|[
literal|1
index|]
expr_stmt|;
name|a
operator|=
name|alloc
argument_list|(
name|dim1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xpcp
operator|=
name|pcp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dim0
condition|;
name|i
operator|++
control|)
block|{
name|copy
argument_list|(
name|CH
argument_list|,
name|b
argument_list|,
name|a
argument_list|,
name|dim1
argument_list|)
expr_stmt|;
name|a
index|[
name|dim1
index|]
operator|=
literal|'\n'
expr_stmt|;
name|c
operator|=
name|compile
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
name|execute
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|b
operator|+=
name|dim1
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|dim0
operator|-
literal|1
condition|)
name|pop
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|pcp
operator|=
name|xpcp
expr_stmt|;
name|p
operator|=
operator|*
operator|--
name|sp
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|p
expr_stmt|;
block|}
end_block

begin_macro
name|ex_menc
argument_list|()
end_macro

begin_block
block|{
name|struct
name|item
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|fetch1
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|DA
condition|)
name|menc1
argument_list|()
expr_stmt|;
comment|/* 	else 		return (char argument unchanged);	*/
block|}
end_block

begin_macro
name|ex_list
argument_list|()
end_macro

begin_comment
comment|/* List a function on the terminal */
end_comment

begin_block
block|{
specifier|register
name|char
name|lastc
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|n
decl_stmt|;
specifier|register
name|line
expr_stmt|;
name|char
name|c
decl_stmt|;
comment|/* Check for valid function */
name|n
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
operator|*
operator|--
name|sp
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|LV
condition|)
name|error
argument_list|(
literal|"fnlist B"
argument_list|)
expr_stmt|;
comment|/* If a function, locate it in workspace file and 	 * print on the terminal in formatted form. 	 */
switch|switch
condition|(
operator|(
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|n
operator|)
operator|->
name|use
condition|)
block|{
default|default:
name|error
argument_list|(
literal|"fnlist T"
argument_list|)
expr_stmt|;
case|case
name|NF
case|:
case|case
name|MF
case|:
case|case
name|DF
case|:
name|SEEKF
argument_list|(
name|wfile
argument_list|,
operator|(
name|long
operator|)
name|n
operator|->
name|label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line
operator|=
literal|0
expr_stmt|;
name|lastc
operator|=
literal|0
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
while|while
condition|(
name|READF
argument_list|(
name|wfile
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|c
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|lastc
condition|)
block|{
case|case
literal|'\n'
case|:
name|printf
argument_list|(
literal|"[%d]"
argument_list|,
operator|++
name|line
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
name|lastc
operator|=
name|c
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
literal|"workspace eof"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|ex_crp
argument_list|()
end_macro

begin_comment
comment|/* dredge up a function and put it into an array*/
end_comment

begin_block
block|{
name|char
name|name
index|[
name|NAMS
index|]
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
name|struct
name|item
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|,
name|dim0
decl_stmt|,
name|dim1
decl_stmt|;
specifier|register
name|i
expr_stmt|;
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
name|p
operator|=
name|fetch1
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|size
operator|==
literal|0
operator|||
name|p
operator|->
name|rank
operator|>
literal|1
operator|||
name|p
operator|->
name|size
operator|>=
name|NAMS
condition|)
name|error
argument_list|(
literal|"Lcr C"
argument_list|)
expr_stmt|;
comment|/* set up the name in search format     */
name|copy
argument_list|(
name|CH
argument_list|,
name|p
operator|->
name|datap
argument_list|,
name|name
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
name|name
index|[
name|p
operator|->
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
name|np
operator|=
name|nlook
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* if not found then domain error       */
if|if
condition|(
operator|!
name|np
operator|->
name|namep
condition|)
name|error
argument_list|(
literal|"Lcr D"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|np
operator|->
name|use
condition|)
block|{
default|default:
name|error
argument_list|(
literal|"Lcr D"
argument_list|)
expr_stmt|;
case|case
name|MF
case|:
case|case
name|DF
case|:
case|case
name|NF
case|:
comment|/* only allow functions */
empty_stmt|;
block|}
comment|/* set up new array                     */
name|dim0
operator|=
literal|0
expr_stmt|;
name|dim1
operator|=
literal|0
expr_stmt|;
name|ifile
operator|=
name|DUPF
argument_list|(
name|wfile
argument_list|)
expr_stmt|;
name|SEEKF
argument_list|(
name|ifile
argument_list|,
operator|(
name|long
operator|)
name|np
operator|->
name|label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* look up function     */
comment|/* compute max width and height         */
while|while
condition|(
name|c2
operator|=
name|c
operator|=
name|rline
argument_list|(
literal|0
argument_list|)
condition|)
block|{
while|while
condition|(
operator|*
name|c2
operator|++
operator|!=
literal|'\n'
condition|)
block|{}
name|dim0
operator|++
expr_stmt|;
name|len
operator|=
name|c2
operator|-
name|c
operator|-
literal|1
expr_stmt|;
name|dim1
operator|=
name|dim1
operator|<
name|len
condition|?
name|len
else|:
name|dim1
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|pop
argument_list|()
expr_stmt|;
comment|/* release old variable         */
comment|/* create new array and put function in */
name|p
operator|=
name|newdat
argument_list|(
name|CH
argument_list|,
literal|2
argument_list|,
name|dim0
operator|*
name|dim1
argument_list|)
expr_stmt|;
name|p
operator|->
name|rank
operator|=
literal|2
expr_stmt|;
name|p
operator|->
name|dim
index|[
literal|0
index|]
operator|=
name|dim0
expr_stmt|;
name|p
operator|->
name|dim
index|[
literal|1
index|]
operator|=
name|dim1
expr_stmt|;
name|dp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|->
name|datap
operator|)
expr_stmt|;
name|SEEKF
argument_list|(
name|ifile
argument_list|,
operator|(
name|long
operator|)
name|np
operator|->
name|label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|c2
operator|=
name|c
operator|=
name|rline
argument_list|(
literal|0
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dim1
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|*
name|c
operator|!=
literal|'\n'
condition|)
operator|*
name|dp
operator|++
operator|=
operator|*
name|c
operator|++
expr_stmt|;
else|else
operator|*
name|dp
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* fill w/blanks*/
name|free
argument_list|(
name|c2
argument_list|)
expr_stmt|;
block|}
comment|/* put the new array on the stack       */
operator|*
name|sp
operator|++
operator|=
name|p
expr_stmt|;
comment|/* reset the current file               */
name|CLOSEF
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
name|ifile
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|menc1
argument_list|()
end_macro

begin_comment
comment|/* change numbers into characters       */
end_comment

begin_block
block|{
name|struct
name|item
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|i
operator|,
name|j
operator|,
name|numsz
expr_stmt|;
name|data
modifier|*
name|dp
decl_stmt|;
name|int
name|total
decl_stmt|,
name|param
index|[
literal|4
index|]
decl_stmt|;
comment|/* zeroize size information vector      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|param
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* pick up the argument                 */
name|p
operator|=
name|fetch1
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rank
operator|>
literal|2
condition|)
name|error
argument_list|(
literal|"format R"
argument_list|)
expr_stmt|;
name|dp
operator|=
name|p
operator|->
name|datap
expr_stmt|;
comment|/* find the maximum # of chars in any # */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|size
condition|;
name|i
operator|++
control|)
name|epr1
argument_list|(
operator|*
name|dp
operator|++
argument_list|,
name|param
argument_list|)
expr_stmt|;
name|numsz
operator|=
name|param
index|[
literal|1
index|]
operator|+
name|param
index|[
literal|2
index|]
operator|+
operator|!
operator|!
name|param
index|[
literal|2
index|]
operator|+
name|param
index|[
literal|3
index|]
operator|+
literal|1
expr_stmt|;
comment|/* rowsize is max # size x last dim     */
name|rowsz
operator|=
name|p
operator|->
name|rank
condition|?
name|p
operator|->
name|dim
index|[
name|p
operator|->
name|rank
operator|-
literal|1
index|]
else|:
literal|1
expr_stmt|;
name|rowsz
operator|*=
name|numsz
expr_stmt|;
comment|/* row size x # of rows (incl blank)    */
name|total
operator|=
name|p
operator|->
name|size
operator|*
name|numsz
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|rank
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|dim
index|[
name|i
index|]
operator|!=
literal|1
condition|)
if|if
condition|(
name|j
operator|++
operator|>
literal|1
condition|)
name|total
operator|+=
name|rowsz
expr_stmt|;
comment|/* make new data and fill with blanks   */
if|if
condition|(
name|p
operator|->
name|rank
operator|==
literal|2
condition|)
block|{
name|q
operator|=
name|newdat
argument_list|(
name|CH
argument_list|,
literal|2
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|q
operator|->
name|dim
index|[
literal|0
index|]
operator|=
name|total
operator|/
name|rowsz
expr_stmt|;
name|q
operator|->
name|dim
index|[
literal|1
index|]
operator|=
name|rowsz
expr_stmt|;
block|}
else|else
block|{
comment|/* rank = 0 or 1 */
name|q
operator|=
name|newdat
argument_list|(
name|CH
argument_list|,
literal|1
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|q
operator|->
name|dim
index|[
literal|0
index|]
operator|=
name|rowsz
expr_stmt|;
block|}
name|mencptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|q
operator|->
name|datap
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total
condition|;
name|i
operator|++
control|)
operator|*
name|mencptr
operator|++
operator|=
literal|' '
expr_stmt|;
name|mencptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|q
operator|->
name|datap
operator|)
expr_stmt|;
comment|/* use putchar() to fill up the array   */
name|mencflg
operator|=
literal|2
expr_stmt|;
name|ex_hprint
argument_list|()
expr_stmt|;
name|mencflg
operator|=
literal|0
expr_stmt|;
comment|/* put it on the stack                  */
comment|/*	pop();		/* done by ex_hprint() */
operator|*
name|sp
operator|++
operator|=
name|q
expr_stmt|;
block|}
end_block

begin_macro
name|ex_run
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|;
specifier|register
name|data
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
modifier|*
name|p2
decl_stmt|;
name|char
name|ebuf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|run
parameter_list|()
function_decl|;
name|p
operator|=
name|fetch1
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|CH
operator|||
name|p
operator|->
name|rank
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"Lrun D"
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|CH
argument_list|,
name|p
operator|->
name|datap
argument_list|,
name|ebuf
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
name|ebuf
index|[
name|p
operator|->
name|size
index|]
operator|=
literal|0
expr_stmt|;
name|p2
operator|=
name|run
argument_list|(
name|ebuf
argument_list|)
expr_stmt|;
name|p
operator|=
name|newdat
argument_list|(
name|DA
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|p
expr_stmt|;
block|}
end_block

begin_function
name|int
modifier|*
name|run
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|p
expr_stmt|;
specifier|static
name|int
name|a
index|[
literal|3
index|]
decl_stmt|;
name|int
argument_list|(
operator|*
name|oldint
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|oldquit
argument_list|)
argument_list|()
decl_stmt|;
name|oldint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|oldquit
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|=
name|FORKF
argument_list|(
literal|1
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|p
operator|=
name|wait
argument_list|(
name|a
operator|+
literal|1
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|p
operator|==
name|a
index|[
literal|0
index|]
condition|)
break|break;
block|}
else|else
block|{
name|execl
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"-"
argument_list|,
literal|"-c"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITEF
argument_list|(
literal|1
argument_list|,
literal|"can't find shell\n"
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|a
index|[
literal|2
index|]
operator|=
operator|(
name|a
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0377
expr_stmt|;
name|a
index|[
literal|1
index|]
operator|&=
literal|0377
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|oldint
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|oldquit
argument_list|)
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_macro
name|ex_dfmt
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ecp
decl_stmt|;
specifier|register
name|data
modifier|*
name|fp
decl_stmt|;
specifier|register
name|j
expr_stmt|;
name|struct
name|item
modifier|*
name|lp
decl_stmt|,
modifier|*
name|rp
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
name|data
modifier|*
name|dp
decl_stmt|;
name|unsigned
name|nrow
decl_stmt|,
name|ncol
decl_stmt|,
name|rowlen
decl_stmt|,
name|inc
decl_stmt|,
name|wid
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sign
decl_stmt|,
name|decpt
decl_stmt|;
comment|/* Dyadic format.  This routine is a little crude and should 	 * probably be rewritten to take advantage of other conversion 	 * routines.  Nonetheless, it does do dyadic formatting for 	 * scalars, vectors, and 2-dimensional arrays when the left 	 * argument is a 2-element or appropriate-length vector 	 * specifying non-exponential ("F format") conversion. 	 */
name|lp
operator|=
name|fetch2
argument_list|()
expr_stmt|;
name|rp
operator|=
name|sp
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|nrow
operator|=
operator|(
name|rp
operator|->
name|rank
operator|<
literal|2
operator|)
condition|?
literal|1
else|:
name|rp
operator|->
name|dim
index|[
literal|0
index|]
expr_stmt|;
name|ncol
operator|=
name|rp
operator|->
name|rank
condition|?
name|rp
operator|->
name|dim
index|[
name|rp
operator|->
name|rank
operator|-
literal|1
index|]
else|:
literal|1
expr_stmt|;
name|inc
operator|=
operator|(
name|lp
operator|->
name|size
operator|!=
literal|2
operator|)
operator|*
literal|2
expr_stmt|;
comment|/* Check validity of arguments. */
if|if
condition|(
name|lp
operator|->
name|rank
operator|>
literal|1
operator|||
name|lp
operator|->
name|size
operator|<=
literal|1
operator|||
name|rp
operator|->
name|rank
operator|>
literal|2
operator|||
name|lp
operator|->
name|type
operator|!=
name|DA
operator|||
name|rp
operator|->
name|type
operator|!=
name|DA
operator|||
operator|(
name|lp
operator|->
name|size
operator|!=
literal|2
operator|&&
name|lp
operator|->
name|size
operator|!=
literal|2
operator|*
name|ncol
operator|)
condition|)
name|error
argument_list|(
literal|"dfmt D"
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|lp
operator|->
name|datap
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lp
operator|->
name|size
condition|;
name|i
operator|+=
literal|2
operator|,
name|fp
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|fp
index|[
literal|0
index|]
operator|<=
literal|0.0
operator|||
name|fp
index|[
literal|1
index|]
operator|<
literal|0.0
condition|)
name|error
argument_list|(
literal|"dfmt D"
argument_list|)
expr_stmt|;
name|fp
index|[
literal|0
index|]
operator|=
call|(
name|data
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
literal|0.5
operator|+
name|fp
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|fp
index|[
literal|1
index|]
operator|=
call|(
name|data
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
literal|0.5
operator|+
name|fp
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate result array */
for|for
control|(
name|i
operator|=
name|rowlen
operator|=
literal|0
operator|,
name|fp
operator|=
name|lp
operator|->
name|datap
init|;
name|i
operator|<
name|ncol
condition|;
name|i
operator|++
operator|,
name|fp
operator|+=
name|inc
control|)
name|rowlen
operator|+=
operator|(
name|int
operator|)
operator|*
name|fp
expr_stmt|;
name|ip
operator|=
name|newdat
argument_list|(
name|CH
argument_list|,
name|rp
operator|->
name|rank
condition|?
name|rp
operator|->
name|rank
else|:
literal|1
argument_list|,
name|rowlen
operator|*
name|nrow
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rank
operator|<
literal|2
condition|)
name|ip
operator|->
name|dim
index|[
literal|0
index|]
operator|=
name|rowlen
expr_stmt|;
else|else
block|{
name|ip
operator|->
name|dim
index|[
literal|0
index|]
operator|=
name|nrow
expr_stmt|;
name|ip
operator|->
name|dim
index|[
literal|1
index|]
operator|=
name|rowlen
expr_stmt|;
block|}
comment|/* Fill it up. The special case "fabs(*dp)< 1.0&& !fp[1]"  	 * insures that a zero is printed when 0 fractional digits are 	 * specified and the number being converted is less than one. 	 */
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|ip
operator|->
name|datap
expr_stmt|;
name|dp
operator|=
name|rp
operator|->
name|datap
expr_stmt|;
while|while
condition|(
name|nrow
operator|--
condition|)
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|fp
operator|=
name|lp
operator|->
name|datap
init|;
name|i
operator|<
name|ncol
condition|;
name|i
operator|++
operator|,
name|dp
operator|++
operator|,
name|fp
operator|+=
name|inc
control|)
block|{
if|if
condition|(
name|fp
index|[
literal|1
index|]
operator|==
literal|0.0
operator|&&
name|fabs
argument_list|(
operator|*
name|dp
argument_list|)
operator|<
literal|1.0
condition|)
operator|*
name|dp
operator|=
literal|0.0
expr_stmt|;
name|ecp
operator|=
name|ecvt
argument_list|(
operator|*
name|dp
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|0.5
operator|+
name|fp
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|&
name|decpt
argument_list|,
operator|&
name|sign
argument_list|)
expr_stmt|;
name|decpt
operator|+=
operator|(
operator|*
name|dp
operator|==
literal|0.0
operator|&&
name|fp
index|[
literal|1
index|]
operator|==
literal|0.0
operator|)
expr_stmt|;
name|j
operator|=
name|fp
index|[
literal|0
index|]
expr_stmt|;
name|wid
operator|=
operator|!
operator|!
name|sign
operator|+
name|fp
index|[
literal|1
index|]
operator|+
operator|!
operator|!
name|fp
index|[
literal|1
index|]
operator|+
operator|(
operator|(
name|decpt
operator|>
literal|0
operator|)
condition|?
name|decpt
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|wid
condition|)
while|while
condition|(
name|j
operator|--
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'*'
expr_stmt|;
comment|/* not wide enough */
else|else
block|{
while|while
condition|(
name|j
operator|>
name|wid
condition|)
block|{
comment|/* leading spaces */
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|sign
condition|)
block|{
comment|/* possible - sign */
operator|*
name|cp
operator|++
operator|=
literal|'-'
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|decpt
operator|>
literal|0
condition|)
block|{
comment|/* whole number part */
operator|*
name|cp
operator|++
operator|=
operator|*
name|ecp
operator|++
expr_stmt|;
name|j
operator|--
expr_stmt|;
name|decpt
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|--
condition|)
block|{
comment|/* fraction, if any */
operator|*
name|cp
operator|++
operator|=
literal|'.'
expr_stmt|;
while|while
condition|(
name|decpt
operator|++
operator|<
literal|0
operator|&&
name|j
condition|)
block|{
name|j
operator|--
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'0'
expr_stmt|;
block|}
while|while
condition|(
name|j
operator|--
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|ecp
operator|++
expr_stmt|;
block|}
block|}
block|}
name|pop
argument_list|()
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|ip
expr_stmt|;
block|}
end_block

begin_macro
name|ex_mfmt
argument_list|()
end_macro

begin_block
block|{
name|ex_menc
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|ex_nc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|item
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|p
operator|=
name|fetch1
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|CH
condition|)
name|error
argument_list|(
literal|"Lnc T"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|size
operator|>=
literal|40
operator|||
name|p
operator|->
name|rank
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"Lnc D"
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|CH
argument_list|,
name|p
operator|->
name|datap
argument_list|,
name|buf
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
name|buf
index|[
name|p
operator|->
name|size
index|]
operator|=
literal|0
expr_stmt|;
name|np
operator|=
name|nlook
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|np
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|np
operator|->
name|use
condition|)
block|{
case|case
literal|0
case|:
name|i
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MF
case|:
case|case
name|NF
case|:
case|case
name|DF
case|:
name|i
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|DA
case|:
case|case
name|CH
case|:
case|case
name|LV
case|:
name|i
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown Lnc type = %d\n"
argument_list|,
name|np
operator|->
name|use
argument_list|)
expr_stmt|;
name|i
operator|=
literal|4
expr_stmt|;
block|}
name|p
operator|=
name|newdat
argument_list|(
name|DA
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|datap
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|p
expr_stmt|;
block|}
end_block

begin_macro
name|ex_nl
argument_list|()
end_macro

begin_block
block|{
name|struct
name|item
modifier|*
name|ip
decl_stmt|;
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
name|data
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|int
name|count
decl_stmt|,
name|maxlen
decl_stmt|;
name|char
name|tlist
index|[
name|NTYPES
index|]
decl_stmt|;
comment|/* Namelist quad function.  This is monadic (dyadic not 	 * implemented).  The argument is a list of types: 	 *  1:	labels 	 *  2:	variables 	 *  3:	functions 	 * whose names are desired.  The result is a character array 	 * containing all defined names (in no particular order) of 	 * the specified type(s).  The number of rows in the matrix 	 * is the number of names; the number of columns is the 	 * same as the longest name (other names are space-filled). 	 */
name|ip
operator|=
name|fetch1
argument_list|()
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|rank
operator|>
literal|1
operator|||
name|ip
operator|->
name|type
operator|!=
name|DA
condition|)
name|error
argument_list|(
literal|"Lnl D"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTYPES
condition|;
name|i
operator|++
control|)
name|tlist
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|ip
operator|->
name|datap
init|;
name|dp
operator|<
name|ip
operator|->
name|datap
operator|+
name|ip
operator|->
name|size
condition|;
name|dp
operator|++
control|)
switch|switch
condition|(
operator|(
name|int
operator|)
operator|*
name|dp
condition|)
block|{
case|case
literal|1
case|:
name|tlist
index|[
name|LBL
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|tlist
index|[
name|CH
index|]
operator|=
name|tlist
index|[
name|DA
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|tlist
index|[
name|NF
index|]
operator|=
name|tlist
index|[
name|MF
index|]
operator|=
name|tlist
index|[
name|DF
index|]
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Lnl D"
argument_list|)
expr_stmt|;
break|break;
block|}
name|count
operator|=
name|maxlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|np
operator|=
name|nlist
init|;
name|np
operator|<
operator|&
name|nlist
index|[
name|NLS
index|]
condition|;
name|np
operator|++
control|)
block|{
if|if
condition|(
name|np
operator|->
name|use
operator|<
name|NTYPES
operator|&&
name|tlist
index|[
name|np
operator|->
name|use
index|]
condition|)
block|{
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|np
operator|->
name|namep
argument_list|)
operator|)
operator|>
name|maxlen
condition|)
name|maxlen
operator|=
name|i
expr_stmt|;
block|}
block|}
name|ip
operator|=
name|newdat
argument_list|(
name|CH
argument_list|,
literal|2
argument_list|,
name|count
operator|*
name|maxlen
argument_list|)
expr_stmt|;
name|ip
operator|->
name|dim
index|[
literal|0
index|]
operator|=
name|count
expr_stmt|;
name|ip
operator|->
name|dim
index|[
literal|1
index|]
operator|=
name|maxlen
expr_stmt|;
name|cp
operator|=
name|ip
operator|->
name|datap
expr_stmt|;
for|for
control|(
name|np
operator|=
name|nlist
init|;
name|np
operator|<
operator|&
name|nlist
index|[
name|NLS
index|]
condition|;
name|np
operator|++
control|)
if|if
condition|(
name|np
operator|->
name|use
operator|<
name|NTYPES
operator|&&
name|tlist
index|[
name|np
operator|->
name|use
index|]
condition|)
for|for
control|(
name|cp2
operator|=
operator|&
name|np
operator|->
name|namep
index|[
name|i
operator|=
literal|0
index|]
init|;
name|i
operator|<
name|maxlen
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|*
name|cp2
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cp2
operator|++
expr_stmt|;
else|else
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|ip
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|strlen
argument_list|(
name|p
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|p
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|ex_prws
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|item
modifier|*
name|ip
decl_stmt|;
specifier|register
name|i
expr_stmt|;
comment|/* Print workspace in ASCII format */
name|printf
argument_list|(
literal|"origin = %d\nwidth = %d\ndigits = %d\n\n\n"
argument_list|,
name|thread
operator|.
name|iorg
argument_list|,
name|thread
operator|.
name|width
argument_list|,
name|thread
operator|.
name|digits
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|nlist
init|;
name|np
operator|<
operator|&
name|nlist
index|[
name|NLS
index|]
condition|;
name|np
operator|++
control|)
switch|switch
condition|(
name|np
operator|->
name|use
condition|)
block|{
case|case
name|CH
case|:
case|case
name|DA
case|:
name|printf
argument_list|(
literal|"%s { "
argument_list|,
name|np
operator|->
name|namep
argument_list|)
expr_stmt|;
name|ip
operator|=
name|np
operator|->
name|itemp
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|rank
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ip
operator|->
name|rank
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|ip
operator|->
name|dim
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"R\n"
argument_list|)
expr_stmt|;
block|}
operator|*
name|sp
operator|++
operator|=
name|np
expr_stmt|;
name|ex_print
argument_list|()
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
name|NF
case|:
case|case
name|MF
case|:
case|case
name|DF
case|:
operator|*
name|sp
operator|++
operator|=
name|np
expr_stmt|;
name|ex_list
argument_list|()
expr_stmt|;
comment|/* pop(); in ex_list() */
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

end_unit

