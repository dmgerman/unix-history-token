begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                     RCS file input  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: rcslex.c,v 4.4 87/12/18 11:44:47 narten Exp $ Purdue CS"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*********************************************************************************  *                     Lexical Analysis.  *                     Character mapping table,  *                     hashtable, Lexinit, nextlex, getlex, getkey,  *                     getid, getnum, readstring, printstring, savestring,  *                     checkid, serror, fatserror, error, faterror, warn, diagnose  *                     fflsbuf, puts, fprintf  *                     Testprogram: define LEXDB  *********************************************************************************  *  * Copyright (C) 1982 by Walter F. Tichy  *                       Purdue University  *                       Computer Science Department  *                       West Lafayette, IN 47907  *  * All rights reserved. No part of this software may be sold or distributed  * in any form or by any means without the prior written permission of the  * author.  * Report problems and direct all inquiries to Tichy@purdue (ARPA net).  */
end_comment

begin_comment
comment|/* $Log:	rcslex.c,v $  * Revision 4.4  87/12/18  11:44:47  narten  * fixed to use "varargs" in "fprintf"; this is required if it is to  * work on a SPARC machine such as a Sun-4  *   * Revision 4.3  87/10/18  10:37:18  narten  * Updating version numbers. Changes relative to 1.1 actually relative  * to version 4.1  *   * Revision 1.3  87/09/24  14:00:17  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf   * warnings)  *   * Revision 1.2  87/03/27  14:22:33  jenkins  * Port to suns  *   * Revision 1.1  84/01/23  14:50:33  kcs  * Initial revision  *   * Revision 4.1  83/03/25  18:12:51  wft  * Only changed $Header to $Id.  *   * Revision 3.3  82/12/10  16:22:37  wft  * Improved error messages, changed exit status on error to 1.  *  * Revision 3.2  82/11/28  21:27:10  wft  * Renamed ctab to map and included EOFILE; ctab is now a macro in rcsbase.h.  * Added fflsbuf(), fputs(), and fprintf(), which abort the RCS operations  * properly in case there is an IO-error (e.g., file system full).  *  * Revision 3.1  82/10/11  19:43:56  wft  * removed unused label out:;  * made sure all calls to getc() return into an integer, not a char.  */
end_comment

begin_comment
comment|/* #define LEXDB /* version LEXDB is for testing the lexical analyzer. The testprogram  * reads a stream of lexemes, enters the revision numbers into the  * hashtable, and prints the recognized tokens. Keywords are recognized  * as identifiers.  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_comment
comment|/* character mapping table */
end_comment

begin_decl_stmt
name|enum
name|tokens
name|map
index|[]
init|=
block|{
name|EOFILE
block|,
comment|/* this will end up at ctab[-1] */
name|UNKN
block|,
name|INSERT
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|SPACE
block|,
name|NEWLN
block|,
name|UNKN
block|,
name|SPACE
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|UNKN
block|,
name|SPACE
block|,
name|EXCLA
block|,
name|DQUOTE
block|,
name|HASH
block|,
name|DOLLAR
block|,
name|PERCNT
block|,
name|AMPER
block|,
name|SQUOTE
block|,
name|LPARN
block|,
name|RPARN
block|,
name|TIMES
block|,
name|PLUS
block|,
name|COMMA
block|,
name|MINUS
block|,
name|PERIOD
block|,
name|DIVIDE
block|,
name|DIGIT
block|,
name|DIGIT
block|,
name|DIGIT
block|,
name|DIGIT
block|,
name|DIGIT
block|,
name|DIGIT
block|,
name|DIGIT
block|,
name|DIGIT
block|,
name|DIGIT
block|,
name|DIGIT
block|,
name|COLON
block|,
name|SEMI
block|,
name|LESS
block|,
name|EQUAL
block|,
name|GREAT
block|,
name|QUEST
block|,
name|AT
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LBRACK
block|,
name|BACKSL
block|,
name|RBRACK
block|,
name|UPARR
block|,
name|UNDER
block|,
name|ACCENT
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LETTER
block|,
name|LBRACE
block|,
name|BAR
block|,
name|RBRACE
block|,
name|TILDE
block|,
name|UNKN
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|nexthsh
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*pointer to next hashtable-entry, set by lookup*/
end_comment

begin_decl_stmt
name|enum
name|tokens
name|nexttok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*next token, set by nextlex                    */
end_comment

begin_decl_stmt
name|int
name|hshenter
comment|/*if true, next suitable lexeme will be entered */
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*into the symbol table. Handle with care.      */
end_comment

begin_decl_stmt
name|int
name|nextc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*next input character, initialized by Lexinit  */
end_comment

begin_decl_stmt
name|int
name|eof
comment|/*end-of-file indicator, set to>0 on end of file*/
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line
comment|/*current line-number of input                  */
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nerror
comment|/*counter for errors                            */
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nwarn
comment|/*counter for warnings                          */
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cmdid
comment|/*command identification for error messages     */
init|=
name|nil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quietflag
comment|/*indicates quiet mode                          */
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|finptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*input file descriptor                         */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|frewrite
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*file descriptor for echoing input             */
end_comment

begin_decl_stmt
name|int
name|rewriteflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*indicates whether to echo to frewrite         */
end_comment

begin_decl_stmt
name|char
name|StringTab
index|[
name|strtsize
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string table and heap               */
end_comment

begin_decl_stmt
name|char
modifier|*
name|NextString
comment|/*pointer to next identifier in StringTab*/
init|=
name|nil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Topchar
comment|/*pointer to next free byte in StringTab*/
init|=
operator|&
name|StringTab
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*set by nextlex, lookup                */
end_comment

begin_decl_stmt
name|struct
name|hshentry
name|hshtab
index|[
name|hshsize
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*hashtable                             */
end_comment

begin_macro
name|lookup
argument_list|()
end_macro

begin_block
block|{
comment|/* Function: Looks up the character string pointed to by NextString in the  * hashtable. If the string is not present, a new entry for it is created.  * If the string is present, TopChar is moved back to save the space for  * the string, and NextString is set to point to the original string.  * In any case, the address of the corresponding hashtable entry is placed  * into nexthsh.  * Algorithm: Quadratic hash, covering all entries.  * Assumptions: NextString points at the first character of the string.  * Topchar points at the first empty byte after the string.  */
specifier|register
name|int
name|ihash
decl_stmt|;
comment|/* index into hashtable */
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|int
name|c
decl_stmt|,
name|delta
decl_stmt|,
name|final
decl_stmt|,
name|FirstScan
decl_stmt|;
comment|/*loop control*/
comment|/* calculate hash code */
name|sp
operator|=
name|NextString
expr_stmt|;
name|ihash
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
name|ihash
operator|+=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* set up first search loop (c=0,step=1,until (hshsiz-1)/2 */
name|c
operator|=
literal|0
expr_stmt|;
name|delta
operator|=
literal|1
expr_stmt|;
name|final
operator|=
operator|(
name|hshsize
operator|-
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|FirstScan
operator|=
name|true
expr_stmt|;
comment|/*first loop */
for|for
control|(
init|;
condition|;
control|)
block|{
name|ihash
operator|=
operator|(
name|ihash
operator|+
name|c
operator|)
operator|%
name|hshsize
expr_stmt|;
comment|/*next index*/
if|if
condition|(
name|hshtab
index|[
name|ihash
index|]
operator|.
name|num
operator|==
name|nil
condition|)
block|{
comment|/*empty slot found*/
name|hshtab
index|[
name|ihash
index|]
operator|.
name|num
operator|=
name|NextString
expr_stmt|;
name|nexthsh
operator|=
operator|&
name|hshtab
index|[
name|ihash
index|]
expr_stmt|;
comment|/*save hashtable address*/
ifdef|#
directive|ifdef
name|LEXDB
name|VOID
name|printf
argument_list|(
literal|"\nEntered: %s at %d "
argument_list|,
name|nexthsh
operator|->
name|num
argument_list|,
name|ihash
argument_list|)
decl_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* compare strings */
name|sp
operator|=
name|NextString
expr_stmt|;
name|np
operator|=
name|hshtab
index|[
name|ihash
index|]
operator|.
name|num
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|==
operator|*
name|np
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|0
condition|)
block|{
comment|/* match found */
name|nexthsh
operator|=
operator|&
name|hshtab
index|[
name|ihash
index|]
expr_stmt|;
name|Topchar
operator|=
name|NextString
expr_stmt|;
name|NextString
operator|=
name|nexthsh
operator|->
name|num
expr_stmt|;
return|return;
block|}
else|else
name|sp
operator|++
expr_stmt|;
block|}
comment|/* neither empty slot nor string found */
comment|/* calculate next index and repeat */
if|if
condition|(
name|c
operator|!=
name|final
condition|)
name|c
operator|+=
name|delta
expr_stmt|;
else|else
block|{
if|if
condition|(
name|FirstScan
condition|)
block|{
comment|/*set up second sweep*/
name|delta
operator|=
operator|-
literal|1
expr_stmt|;
name|final
operator|=
literal|1
expr_stmt|;
name|FirstScan
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|fatserror
argument_list|(
literal|"Hashtable overflow"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|Lexinit
argument_list|()
end_macro

begin_comment
comment|/* Function: Initialization of lexical analyzer:  * initializes the hastable,  * initializes nextc, nexttok if finptr != NULL  */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|hshsize
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|hshtab
index|[
name|i
index|]
operator|.
name|num
operator|=
name|nil
expr_stmt|;
block|}
name|hshenter
operator|=
name|true
expr_stmt|;
name|eof
operator|=
literal|0
expr_stmt|;
name|line
operator|=
literal|1
expr_stmt|;
name|nerror
operator|=
literal|0
expr_stmt|;
name|nwarn
operator|=
literal|0
expr_stmt|;
name|NextString
operator|=
name|nil
expr_stmt|;
name|Topchar
operator|=
operator|&
name|StringTab
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|finptr
condition|)
block|{
name|nextc
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|rewriteflag
argument_list|)
expr_stmt|;
comment|/*initial character*/
name|nextlex
argument_list|()
expr_stmt|;
comment|/*initial token*/
block|}
else|else
block|{
name|nextc
operator|=
literal|'\0'
expr_stmt|;
name|nexttok
operator|=
name|EOFILE
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|nextlex
argument_list|()
end_macro

begin_comment
comment|/* Function: Reads the next token and sets nexttok to the next token code.  * Only if the hshenter==true, a revision number is entered into the  * hashtable and a pointer to it is placed into nexthsh.  * This is useful for avoiding that dates are placed into the hashtable.  * For ID's and NUM's, NextString is set to the character string in the  * string table. Assumption: nextc contains the next character.  */
end_comment

begin_block
block|{
specifier|register
name|c
expr_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|enum
name|tokens
name|d
decl_stmt|;
if|if
condition|(
name|eof
condition|)
block|{
name|nexttok
operator|=
name|EOFILE
expr_stmt|;
return|return;
block|}
name|loop
label|:
switch|switch
condition|(
name|nexttok
operator|=
name|ctab
index|[
name|nextc
index|]
condition|)
block|{
case|case
name|UNKN
case|:
case|case
name|IDCHAR
case|:
case|case
name|PERIOD
case|:
name|serror
argument_list|(
literal|"unknown Character: %c"
argument_list|,
name|nextc
argument_list|)
expr_stmt|;
name|nextc
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|rewriteflag
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|NEWLN
case|:
name|line
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|LEXDB
name|VOID
name|putchar
argument_list|(
literal|'\n'
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* Note: falls into next case */
case|case
name|SPACE
case|:
name|nextc
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|rewriteflag
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
name|EOFILE
case|:
name|eof
operator|++
expr_stmt|;
name|nexttok
operator|=
name|EOFILE
expr_stmt|;
return|return;
case|case
name|DIGIT
case|:
name|NextString
operator|=
name|sp
operator|=
name|Topchar
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|nextc
expr_stmt|;
while|while
condition|(
operator|(
name|d
operator|=
name|ctab
index|[
name|c
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|rewriteflag
argument_list|)
index|]
operator|)
operator|==
name|DIGIT
operator|||
name|d
operator|==
name|PERIOD
condition|)
block|{
operator|*
name|sp
operator|++
operator|=
name|c
expr_stmt|;
comment|/* 1.2. and 1.2 are different */
block|}
operator|*
name|sp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|sp
operator|>=
name|StringTab
operator|+
name|strtsize
condition|)
block|{
comment|/*may have written outside stringtable already*/
name|fatserror
argument_list|(
literal|"Stringtable overflow"
argument_list|)
expr_stmt|;
block|}
name|Topchar
operator|=
name|sp
expr_stmt|;
name|nextc
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|hshenter
operator|==
name|true
condition|)
name|lookup
argument_list|()
expr_stmt|;
comment|/* lookup updates NextString, Topchar*/
name|nexttok
operator|=
name|NUM
expr_stmt|;
return|return;
case|case
name|LETTER
case|:
name|NextString
operator|=
name|sp
operator|=
name|Topchar
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|nextc
expr_stmt|;
while|while
condition|(
operator|(
name|d
operator|=
name|ctab
index|[
name|c
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|rewriteflag
argument_list|)
index|]
operator|)
operator|==
name|LETTER
operator|||
name|d
operator|==
name|DIGIT
operator|||
name|d
operator|==
name|IDCHAR
condition|)
block|{
operator|*
name|sp
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|sp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|sp
operator|>=
name|StringTab
operator|+
name|strtsize
condition|)
block|{
comment|/*may have written outside stringtable already*/
name|fatserror
argument_list|(
literal|"Stringtable overflow"
argument_list|)
expr_stmt|;
block|}
name|Topchar
operator|=
name|sp
expr_stmt|;
name|nextc
operator|=
name|c
expr_stmt|;
name|nexttok
operator|=
name|ID
expr_stmt|;
comment|/* may be ID or keyword */
return|return;
case|case
name|SBEGIN
case|:
comment|/* long string */
name|nexttok
operator|=
name|STRING
expr_stmt|;
comment|/* note: only the initial SBEGIN has been read*/
comment|/* read the string, and reset nextc afterwards*/
return|return;
default|default:
name|nextc
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|rewriteflag
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_function
name|int
name|getlex
parameter_list|(
name|token
parameter_list|)
name|enum
name|tokens
name|token
decl_stmt|;
comment|/* Function: Checks if nexttok is the same as token. If so,  * advances the input by calling nextlex and returns true.  * otherwise returns false.  * Doesn't work for strings and keywords; loses the character string for ids.  */
block|{
if|if
condition|(
name|nexttok
operator|==
name|token
condition|)
block|{
name|nextlex
argument_list|()
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
else|else
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|int
name|getkey
parameter_list|(
name|key
parameter_list|)
name|char
modifier|*
name|key
decl_stmt|;
comment|/* Function: If the current token is a keyword identical to key,  * getkey advances the input by calling nextlex and returns true;  * otherwise returns false.  */
block|{
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
if|if
condition|(
name|nexttok
operator|==
name|ID
condition|)
block|{
name|s1
operator|=
name|key
expr_stmt|;
name|s2
operator|=
name|NextString
expr_stmt|;
while|while
condition|(
operator|*
name|s1
operator|==
operator|*
name|s2
operator|++
condition|)
if|if
condition|(
operator|*
name|s1
operator|++
operator|==
literal|'\0'
condition|)
block|{
comment|/* match found */
name|Topchar
operator|=
name|NextString
expr_stmt|;
comment|/*reset Topchar */
name|nextlex
argument_list|()
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|getid
parameter_list|()
comment|/* Function: Checks if nexttok is an identifier. If so,  * advances the input by calling nextlex and returns a pointer  * to the identifier; otherwise returns nil.  * Treats keywords as identifiers.  */
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|nexttok
operator|==
name|ID
condition|)
block|{
name|name
operator|=
name|NextString
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
return|return
name|name
return|;
block|}
else|else
return|return
name|nil
return|;
block|}
end_function

begin_function
name|struct
name|hshentry
modifier|*
name|getnum
parameter_list|()
comment|/* Function: Checks if nexttok is a number. If so,  * advances the input by calling nextlex and returns a pointer  * to the hashtable entry. Otherwise returns nil.  * Doesn't work if hshenter is false.  */
block|{
specifier|register
name|struct
name|hshentry
modifier|*
name|num
decl_stmt|;
if|if
condition|(
name|nexttok
operator|==
name|NUM
condition|)
block|{
name|num
operator|=
name|nexthsh
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
return|return
name|num
return|;
block|}
else|else
return|return
name|nil
return|;
block|}
end_function

begin_macro
name|readstring
argument_list|()
end_macro

begin_comment
comment|/* skip over characters until terminating single SDELIM        */
end_comment

begin_comment
comment|/* if rewriteflag==true, copy every character read to frewrite.*/
end_comment

begin_comment
comment|/* Does not advance nextlex at the end.                        */
end_comment

begin_block
block|{
specifier|register
name|c
expr_stmt|;
if|if
condition|(
name|rewriteflag
condition|)
block|{
comment|/* copy string verbatim to frewrite */
while|while
condition|(
operator|(
name|c
operator|=
name|putc
argument_list|(
name|getc
argument_list|(
name|finptr
argument_list|)
argument_list|,
name|frewrite
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|SDELIM
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|putc
argument_list|(
name|getc
argument_list|(
name|finptr
argument_list|)
argument_list|,
name|frewrite
argument_list|)
operator|)
operator|!=
name|SDELIM
condition|)
block|{
comment|/* end of string */
name|nextc
operator|=
name|c
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* skip string */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finptr
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|SDELIM
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finptr
argument_list|)
operator|)
operator|!=
name|SDELIM
condition|)
block|{
comment|/* end of string */
name|nextc
operator|=
name|c
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
name|nextc
operator|=
name|c
expr_stmt|;
name|error
argument_list|(
literal|"Unterminated string"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|printstring
argument_list|()
end_macro

begin_comment
comment|/* Function: copy a string to stdout, until terminated with a single SDELIM.  * Does not advance nextlex at the end.  */
end_comment

begin_block
block|{
specifier|register
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finptr
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|SDELIM
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finptr
argument_list|)
operator|)
operator|!=
name|SDELIM
condition|)
block|{
comment|/* end of string */
name|nextc
operator|=
name|c
expr_stmt|;
return|return;
block|}
block|}
name|VOID
name|putchar
parameter_list|(
name|c
parameter_list|)
function_decl|;
block|}
name|nextc
operator|=
name|c
expr_stmt|;
name|error
argument_list|(
literal|"Unterminated string"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|savestring
parameter_list|(
name|target
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
name|target
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* copies a string terminated with SDELIM from file finptr to buffer target,  * but not more than length bytes. If the string is longer than length,  * the extra characters are skipped. The string may be empty, in which  * case a '\0' is placed into target.  * Double SDELIM is replaced with SDELIM.  * If rewriteflag==true, the string is also copied unchanged to frewrite.  * Returns the length of the saved string.  * Does not advance nextlex at the end.  */
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|,
modifier|*
name|max
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|tp
operator|=
name|target
expr_stmt|;
name|max
operator|=
name|target
operator|+
name|length
expr_stmt|;
comment|/*max is one too large*/
while|while
condition|(
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|rewriteflag
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SDELIM
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|rewriteflag
argument_list|)
operator|)
operator|!=
name|SDELIM
condition|)
block|{
comment|/* end of string */
operator|*
operator|(
name|tp
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|nextc
operator|=
name|c
expr_stmt|;
return|return
name|tp
operator|-
name|target
return|;
block|}
block|}
if|if
condition|(
name|tp
operator|>=
name|max
condition|)
block|{
comment|/* overflow */
name|error
argument_list|(
literal|"string buffer overflow -- truncating string"
argument_list|)
expr_stmt|;
name|target
index|[
name|length
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* skip rest of string */
while|while
condition|(
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|rewriteflag
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|==
name|SDELIM
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|,
name|rewriteflag
argument_list|)
operator|)
operator|!=
name|SDELIM
operator|)
condition|)
block|{
comment|/* end of string */
name|nextc
operator|=
name|c
expr_stmt|;
return|return
name|length
return|;
block|}
block|}
name|nextc
operator|=
name|c
expr_stmt|;
name|error
argument_list|(
literal|"Can't find %c to terminate string before end of file"
argument_list|,
name|SDELIM
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
block|}
name|nextc
operator|=
name|c
expr_stmt|;
name|error
argument_list|(
literal|"Can't find %c to terminate string before end of file"
argument_list|,
name|SDELIM
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|checkid
parameter_list|(
name|id
parameter_list|,
name|delim
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|,
name|delim
decl_stmt|;
comment|/*   Function:  check whether the string starting at id is an   */
comment|/*              identifier and return a pointer to the last char*/
comment|/*              of the identifer. White space, delim and '\0'   */
comment|/*              are legal delimeters. Aborts the program if not */
comment|/*              a legal identifier. Useful for checking commands*/
block|{
specifier|register
name|enum
name|tokens
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|,
name|tc
decl_stmt|;
name|temp
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|ctab
index|[
operator|*
name|id
index|]
operator|==
name|LETTER
condition|)
block|{
while|while
condition|(
operator|(
name|d
operator|=
name|ctab
index|[
name|c
operator|=
operator|(
operator|*
operator|++
name|id
operator|)
index|]
operator|)
operator|==
name|LETTER
operator|||
name|d
operator|==
name|DIGIT
operator|||
name|d
operator|==
name|IDCHAR
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
name|delim
condition|)
block|{
comment|/* append \0 to end of id before error message */
name|tc
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|id
operator|)
operator|)
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
name|delim
condition|)
empty_stmt|;
operator|*
name|id
operator|=
literal|'\0'
expr_stmt|;
name|faterror
argument_list|(
literal|"Invalid character %c in identifier %s"
argument_list|,
name|tc
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
else|else
return|return
name|id
return|;
block|}
else|else
block|{
comment|/* append \0 to end of id before error message */
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|id
operator|)
operator|)
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
name|delim
condition|)
empty_stmt|;
operator|*
name|id
operator|=
literal|'\0'
expr_stmt|;
name|faterror
argument_list|(
literal|"Identifier %s does not start with letter"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
block|}
end_function

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|serror
argument_list|(
argument|e
argument_list|,
argument|e1
argument_list|,
argument|e2
argument_list|,
argument|e3
argument_list|,
argument|e4
argument_list|,
argument|e5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|e
decl_stmt|,
modifier|*
name|e1
decl_stmt|,
modifier|*
name|e2
decl_stmt|,
modifier|*
name|e3
decl_stmt|,
modifier|*
name|e4
decl_stmt|,
modifier|*
name|e5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non-fatal syntax error */
end_comment

begin_block
block|{
name|nerror
operator|++
expr_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s error, line %d: "
argument_list|,
name|cmdid
argument_list|,
name|line
argument_list|)
decl_stmt|;
name|VOID
name|fprintf
parameter_list|(
name|stderr
parameter_list|,
name|e
parameter_list|,
name|e1
parameter_list|,
name|e2
parameter_list|,
name|e3
parameter_list|,
name|e4
parameter_list|,
name|e5
parameter_list|)
function_decl|;
name|VOID
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
block|}
end_block

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|error
argument_list|(
argument|e
argument_list|,
argument|e1
argument_list|,
argument|e2
argument_list|,
argument|e3
argument_list|,
argument|e4
argument_list|,
argument|e5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|e
decl_stmt|,
modifier|*
name|e1
decl_stmt|,
modifier|*
name|e2
decl_stmt|,
modifier|*
name|e3
decl_stmt|,
modifier|*
name|e4
decl_stmt|,
modifier|*
name|e5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non-fatal error */
end_comment

begin_block
block|{
name|nerror
operator|++
expr_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s error: "
argument_list|,
name|cmdid
argument_list|)
decl_stmt|;
name|VOID
name|fprintf
parameter_list|(
name|stderr
parameter_list|,
name|e
parameter_list|,
name|e1
parameter_list|,
name|e2
parameter_list|,
name|e3
parameter_list|,
name|e4
parameter_list|,
name|e5
parameter_list|)
function_decl|;
name|VOID
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
block|}
end_block

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|fatserror
argument_list|(
argument|e
argument_list|,
argument|e1
argument_list|,
argument|e2
argument_list|,
argument|e3
argument_list|,
argument|e4
argument_list|,
argument|e5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|e
decl_stmt|,
modifier|*
name|e1
decl_stmt|,
modifier|*
name|e2
decl_stmt|,
modifier|*
name|e3
decl_stmt|,
modifier|*
name|e4
decl_stmt|,
modifier|*
name|e5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fatal syntax error */
end_comment

begin_block
block|{
name|nerror
operator|++
expr_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s error, line %d: "
argument_list|,
name|cmdid
argument_list|,
name|line
argument_list|)
decl_stmt|;
name|VOID
name|fprintf
parameter_list|(
name|stderr
parameter_list|,
name|e
parameter_list|,
name|e1
parameter_list|,
name|e2
parameter_list|,
name|e3
parameter_list|,
name|e4
parameter_list|,
name|e5
parameter_list|)
function_decl|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s aborted\n"
argument_list|,
name|cmdid
argument_list|)
decl_stmt|;
name|VOID
name|cleanup
parameter_list|()
function_decl|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|faterror
argument_list|(
argument|e
argument_list|,
argument|e1
argument_list|,
argument|e2
argument_list|,
argument|e3
argument_list|,
argument|e4
argument_list|,
argument|e5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|e
decl_stmt|,
modifier|*
name|e1
decl_stmt|,
modifier|*
name|e2
decl_stmt|,
modifier|*
name|e3
decl_stmt|,
modifier|*
name|e4
decl_stmt|,
modifier|*
name|e5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fatal error, terminates program after cleanup */
end_comment

begin_block
block|{
name|nerror
operator|++
expr_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s error: "
argument_list|,
name|cmdid
argument_list|)
decl_stmt|;
name|VOID
name|fprintf
parameter_list|(
name|stderr
parameter_list|,
name|e
parameter_list|,
name|e1
parameter_list|,
name|e2
parameter_list|,
name|e3
parameter_list|,
name|e4
parameter_list|,
name|e5
parameter_list|)
function_decl|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s aborted\n"
argument_list|,
name|cmdid
argument_list|)
decl_stmt|;
name|VOID
name|cleanup
parameter_list|()
function_decl|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|warn
argument_list|(
argument|e
argument_list|,
argument|e1
argument_list|,
argument|e2
argument_list|,
argument|e3
argument_list|,
argument|e4
argument_list|,
argument|e5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|e
decl_stmt|,
modifier|*
name|e1
decl_stmt|,
modifier|*
name|e2
decl_stmt|,
modifier|*
name|e3
decl_stmt|,
modifier|*
name|e4
decl_stmt|,
modifier|*
name|e5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prints a warning message */
end_comment

begin_block
block|{
name|nwarn
operator|++
expr_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s warning: "
argument_list|,
name|cmdid
argument_list|)
decl_stmt|;
name|VOID
name|fprintf
parameter_list|(
name|stderr
parameter_list|,
name|e
parameter_list|,
name|e1
parameter_list|,
name|e2
parameter_list|,
name|e3
parameter_list|,
name|e4
parameter_list|,
name|e5
parameter_list|)
function_decl|;
name|VOID
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
block|}
end_block

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|diagnose
argument_list|(
argument|e
argument_list|,
argument|e1
argument_list|,
argument|e2
argument_list|,
argument|e3
argument_list|,
argument|e4
argument_list|,
argument|e5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|e
decl_stmt|,
modifier|*
name|e1
decl_stmt|,
modifier|*
name|e2
decl_stmt|,
modifier|*
name|e3
decl_stmt|,
modifier|*
name|e4
decl_stmt|,
modifier|*
name|e5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prints a diagnostic message */
end_comment

begin_block
block|{
if|if
condition|(
operator|!
name|quietflag
condition|)
block|{
name|VOID
name|fprintf
parameter_list|(
name|stderr
parameter_list|,
name|e
parameter_list|,
name|e1
parameter_list|,
name|e2
parameter_list|,
name|e3
parameter_list|,
name|e4
parameter_list|,
name|e5
parameter_list|)
function_decl|;
name|VOID
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
block|}
block|}
end_block

begin_macro
name|fflsbuf
argument_list|(
argument|c
argument_list|,
argument|iop
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|iop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: Flush iop.  * Same routine as _flsbuf in stdio, but aborts program on error.  */
end_comment

begin_block
block|{
specifier|register
name|result
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|_flsbuf
argument_list|(
name|c
argument_list|,
name|iop
argument_list|)
operator|)
operator|==
name|EOF
condition|)
name|faterror
argument_list|(
literal|"write error"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_expr_stmt
name|fputs
argument_list|(
name|s
argument_list|,
name|iop
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|iop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: Put string s on file iop, abort on error.  * Same as puts in stdio, but with different putc macro.  */
end_comment

begin_block
block|{
specifier|register
name|r
expr_stmt|;
specifier|register
name|c
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
name|r
operator|=
name|putc
argument_list|(
name|c
argument_list|,
name|iop
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_block

begin_macro
name|fprintf
argument_list|(
argument|iop
argument_list|,
argument|fmt
argument_list|,
argument|va_alist
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|iop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_comment
comment|/* Function: formatted output. Same as fprintf in stdio,  * but aborts program on error  */
end_comment

begin_block
block|{
specifier|register
name|int
name|value
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VFPRINTF
name|VOID
name|vfprintf
parameter_list|(
name|iop
parameter_list|,
name|fmt
parameter_list|,
name|ap
parameter_list|)
function_decl|;
else|#
directive|else
name|_doprnt
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|,
name|iop
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|VFPRINTF
if|if
condition|(
name|ferror
argument_list|(
name|iop
argument_list|)
condition|)
block|{
name|faterror
argument_list|(
literal|"write error"
argument_list|)
expr_stmt|;
name|value
operator|=
name|EOF
expr_stmt|;
block|}
else|else
name|value
operator|=
literal|0
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|LEXDB
end_ifdef

begin_comment
comment|/* test program reading a stream of lexems and printing the tokens.  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|cmdid
operator|=
literal|"lextest"
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|VOID
name|fputs
argument_list|(
literal|"No input file\n"
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|finptr
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|faterror
argument_list|(
literal|"Can't open input file %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|Lexinit
argument_list|()
expr_stmt|;
name|rewriteflag
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|nexttok
operator|!=
name|EOFILE
condition|)
block|{
switch|switch
condition|(
name|nexttok
condition|)
block|{
case|case
name|ID
case|:
name|VOID
name|printf
argument_list|(
literal|"ID: %s"
argument_list|,
name|NextString
argument_list|)
decl_stmt|;
break|break;
case|case
name|NUM
case|:
if|if
condition|(
name|hshenter
operator|==
name|true
condition|)
name|VOID
name|printf
argument_list|(
literal|"NUM: %s, index: %d"
argument_list|,
name|nexthsh
operator|->
name|num
argument_list|,
name|nexthsh
operator|-
name|hshtab
argument_list|)
decl_stmt|;
else|else
name|VOID
name|printf
argument_list|(
literal|"NUM, unentered: %s"
argument_list|,
name|NextString
argument_list|)
decl_stmt|;
name|hshenter
operator|=
operator|!
name|hshenter
expr_stmt|;
comment|/*alternate between dates and numbers*/
break|break;
case|case
name|COLON
case|:
name|VOID
name|printf
argument_list|(
literal|"COLON"
argument_list|)
decl_stmt|;
break|break;
case|case
name|SEMI
case|:
name|VOID
name|printf
argument_list|(
literal|"SEMI"
argument_list|)
decl_stmt|;
break|break;
case|case
name|STRING
case|:
name|readstring
argument_list|()
expr_stmt|;
name|VOID
name|printf
argument_list|(
literal|"STRING"
argument_list|)
decl_stmt|;
break|break;
case|case
name|UNKN
case|:
name|VOID
name|printf
argument_list|(
literal|"UNKN"
argument_list|)
decl_stmt|;
break|break;
default|default:
name|VOID
name|printf
argument_list|(
literal|"DEFAULT"
argument_list|)
decl_stmt|;
break|break;
block|}
name|VOID
name|printf
argument_list|(
literal|" | "
argument_list|)
decl_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
block|}
name|VOID
name|printf
argument_list|(
literal|"\nEnd of lexical analyzer test\n"
argument_list|)
decl_stmt|;
block|}
end_function

begin_macro
name|cleanup
argument_list|()
end_macro

begin_comment
comment|/* dummy */
end_comment

begin_block
block|{}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

