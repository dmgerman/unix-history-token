begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"utran.h"
end_include

begin_include
include|#
directive|include
file|"token.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"char.h"
end_include

begin_decl_stmt
name|int
name|alclflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag (counter) for local table overflow */
end_comment

begin_decl_stmt
name|int
name|alcgflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag (counter) for global table overflow */
end_comment

begin_decl_stmt
name|int
name|alccflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag (counter) for constant table overflow */
end_comment

begin_function
name|char
modifier|*
name|instalid
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|l
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|extern
name|char
modifier|*
name|putident
parameter_list|()
function_decl|;
name|p1
operator|=
name|sfree
expr_stmt|;
name|p2
operator|=
name|s
expr_stmt|;
name|l
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|++
operator|=
operator|*
name|p2
operator|++
condition|)
block|{
if|if
condition|(
name|p1
operator|>=
name|send
condition|)
name|syserr
argument_list|(
literal|"out of string space"
argument_list|)
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|putident
argument_list|(
name|l
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|putident
parameter_list|(
name|len
parameter_list|)
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|hash
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|ientry
modifier|*
name|ip
decl_stmt|;
name|int
name|l
decl_stmt|;
specifier|extern
name|struct
name|ientry
modifier|*
name|alcident
parameter_list|()
function_decl|;
name|s
operator|=
name|sfree
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
name|hash
operator|+=
operator|*
name|s
operator|++
operator|&
literal|0377
expr_stmt|;
name|s
operator|=
name|sfree
expr_stmt|;
name|l
operator|=
name|len
expr_stmt|;
name|hash
operator|&=
name|imask
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|=
name|ihash
index|[
name|hash
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|l
operator|==
name|ip
operator|->
name|i_length
operator|&&
name|streq
argument_list|(
name|l
argument_list|,
name|s
argument_list|,
name|ip
operator|->
name|i_name
argument_list|)
condition|)
return|return
operator|(
name|ip
operator|->
name|i_name
operator|)
return|;
if|if
condition|(
name|ip
operator|->
name|i_blink
operator|==
name|NULL
condition|)
block|{
name|ip
operator|->
name|i_blink
operator|=
name|alcident
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|sfree
operator|+=
name|l
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
name|ip
operator|=
name|ip
operator|->
name|i_blink
expr_stmt|;
block|}
block|}
name|ihash
index|[
name|hash
index|]
operator|=
name|alcident
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|sfree
operator|+=
name|l
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|streq
argument_list|(
name|len
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
specifier|register
name|int
name|len
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|len
operator|--
condition|)
if|if
condition|(
operator|*
name|s1
operator|++
operator|!=
operator|*
name|s2
operator|++
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_function
name|struct
name|ientry
modifier|*
name|alcident
parameter_list|(
name|blink
parameter_list|,
name|nam
parameter_list|,
name|len
parameter_list|)
name|struct
name|ientry
modifier|*
name|blink
decl_stmt|;
name|char
modifier|*
name|nam
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|struct
name|ientry
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
name|ifree
operator|++
expr_stmt|;
name|ip
operator|->
name|i_blink
operator|=
name|blink
expr_stmt|;
name|ip
operator|->
name|i_name
operator|=
name|nam
expr_stmt|;
name|ip
operator|->
name|i_length
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|ip
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * loc_init() -  clear local symbol table  */
end_comment

begin_macro
name|loc_init
argument_list|()
end_macro

begin_block
block|{
specifier|register
operator|*
name|p
expr_stmt|;
specifier|static
name|int
name|maxlfree
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|maxcfree
init|=
literal|0
decl_stmt|;
comment|/* clear local table */
name|maxlfree
operator|=
operator|(
name|maxlfree
operator|>
name|lfree
operator|-
name|ltable
operator|)
condition|?
name|maxlfree
else|:
name|lfree
operator|-
name|ltable
expr_stmt|;
if|if
condition|(
name|alclflg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d more entries needed in local symbol table\n"
argument_list|,
name|alclflg
argument_list|)
expr_stmt|;
name|alclflg
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|lhash
init|;
name|p
operator|<
operator|&
name|lhash
index|[
name|lhsize
index|]
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
name|lfree
operator|=
name|ltable
expr_stmt|;
comment|/* clear constant table */
name|maxcfree
operator|=
operator|(
name|maxcfree
operator|>
name|ctfree
operator|-
name|ctable
operator|)
condition|?
name|maxcfree
else|:
name|ctfree
operator|-
name|ctable
expr_stmt|;
if|if
condition|(
name|alccflg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d more entries needed in literal symbol table\n"
argument_list|,
name|alccflg
argument_list|)
expr_stmt|;
name|alccflg
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|chash
init|;
name|p
operator|<
operator|&
name|chash
index|[
name|chsize
index|]
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
name|ctfree
operator|=
name|ctable
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * install - put an identifier into the global or local symbol table  */
end_comment

begin_macro
name|install
argument_list|(
argument|name
argument_list|,
argument|flag
argument_list|,
argument|argcnt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|,
name|argcnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
union|union
block|{
name|struct
name|gentry
modifier|*
name|gp
decl_stmt|;
name|struct
name|lentry
modifier|*
name|lp
decl_stmt|;
block|}
name|p
union|;
specifier|extern
name|struct
name|gentry
modifier|*
name|glocate
parameter_list|()
function_decl|;
specifier|extern
name|struct
name|lentry
modifier|*
name|llocate
parameter_list|()
function_decl|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|F_GLOBAL
case|:
if|if
condition|(
operator|(
name|p
operator|.
name|gp
operator|=
name|glocate
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|putglob
argument_list|(
name|name
argument_list|,
name|flag
argument_list|,
name|argcnt
argument_list|)
expr_stmt|;
else|else
name|p
operator|.
name|gp
operator|->
name|g_flag
operator||=
name|flag
expr_stmt|;
break|break;
case|case
name|F_PROC
operator||
name|F_GLOBAL
case|:
case|case
name|F_RECORD
operator||
name|F_GLOBAL
case|:
case|case
name|F_BUILTIN
operator||
name|F_GLOBAL
case|:
if|if
condition|(
operator|(
name|p
operator|.
name|gp
operator|=
name|glocate
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|putglob
argument_list|(
name|name
argument_list|,
name|flag
argument_list|,
name|argcnt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|p
operator|.
name|gp
operator|->
name|g_flag
operator|&
operator|(
operator|~
name|F_GLOBAL
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|.
name|gp
operator|->
name|g_flag
operator||=
name|flag
expr_stmt|;
name|p
operator|.
name|gp
operator|->
name|g_nargs
operator|=
name|argcnt
expr_stmt|;
block|}
else|else
name|err
argument_list|(
literal|"inconsistent redeclaration"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_STATIC
case|:
case|case
name|F_DYNAMIC
case|:
case|case
name|F_ARGUMENT
case|:
if|if
condition|(
operator|(
name|p
operator|.
name|lp
operator|=
name|llocate
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|putloc
argument_list|(
name|name
argument_list|,
name|flag
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|lp
operator|->
name|l_flag
operator|==
name|flag
condition|)
name|warn
argument_list|(
literal|"redeclared identifier"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
literal|"inconsistent redeclaration"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"install: unrecognized symbol table flag."
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * putloc - make a local symbol table entry.  */
end_comment

begin_function
name|int
name|putloc
parameter_list|(
name|id
parameter_list|,
name|id_type
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
name|int
name|id_type
decl_stmt|;
block|{
specifier|register
name|struct
name|lentry
modifier|*
name|ptr
decl_stmt|;
specifier|extern
name|struct
name|lentry
modifier|*
name|llocate
argument_list|()
decl_stmt|,
modifier|*
name|alcloc
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|llocate
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* add to head of hash chain */
name|ptr
operator|=
name|lhash
index|[
name|lhasher
argument_list|(
name|id
argument_list|)
index|]
expr_stmt|;
name|lhash
index|[
name|lhasher
argument_list|(
name|id
argument_list|)
index|]
operator|=
name|alcloc
argument_list|(
name|ptr
argument_list|,
name|id
argument_list|,
name|id_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|lhash
index|[
name|lhasher
argument_list|(
name|id
argument_list|)
index|]
operator|-
name|ltable
operator|)
return|;
block|}
return|return
operator|(
name|ptr
operator|-
name|ltable
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * putglob - make a global symbol table entry.  */
end_comment

begin_function
name|int
name|putglob
parameter_list|(
name|id
parameter_list|,
name|id_type
parameter_list|,
name|n_args
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
name|int
name|id_type
decl_stmt|,
name|n_args
decl_stmt|;
block|{
specifier|register
name|struct
name|gentry
modifier|*
name|ptr
decl_stmt|;
specifier|extern
name|struct
name|gentry
modifier|*
name|glocate
argument_list|()
decl_stmt|,
modifier|*
name|alcglob
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|glocate
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* add to head of hash chain */
name|ptr
operator|=
name|ghash
index|[
name|ghasher
argument_list|(
name|id
argument_list|)
index|]
expr_stmt|;
name|ghash
index|[
name|ghasher
argument_list|(
name|id
argument_list|)
index|]
operator|=
name|alcglob
argument_list|(
name|ptr
argument_list|,
name|id
argument_list|,
name|id_type
argument_list|,
name|n_args
argument_list|)
expr_stmt|;
return|return
operator|(
name|ghash
index|[
name|ghasher
argument_list|(
name|id
argument_list|)
index|]
operator|-
name|gtable
operator|)
return|;
block|}
return|return
operator|(
name|ptr
operator|-
name|gtable
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * putlit - make a constant symbol table entry.  */
end_comment

begin_function
name|int
name|putlit
parameter_list|(
name|id
parameter_list|,
name|idtype
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
name|int
name|len
decl_stmt|,
name|idtype
decl_stmt|;
block|{
specifier|register
name|struct
name|centry
modifier|*
name|ptr
decl_stmt|;
specifier|extern
name|struct
name|centry
modifier|*
name|clocate
argument_list|()
decl_stmt|,
modifier|*
name|alclit
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|clocate
argument_list|(
name|id
argument_list|,
name|idtype
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* add to head of hash chain */
name|ptr
operator|=
name|chash
index|[
name|chasher
argument_list|(
name|id
argument_list|)
index|]
expr_stmt|;
name|chash
index|[
name|chasher
argument_list|(
name|id
argument_list|)
index|]
operator|=
name|alclit
argument_list|(
name|ptr
argument_list|,
name|id
argument_list|,
name|len
argument_list|,
name|idtype
argument_list|)
expr_stmt|;
return|return
operator|(
name|chash
index|[
name|chasher
argument_list|(
name|id
argument_list|)
index|]
operator|-
name|ctable
operator|)
return|;
block|}
return|return
operator|(
name|ptr
operator|-
name|ctable
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * llocate() - lookup identifier in local symbol table, NIL if not present.  */
end_comment

begin_function
name|struct
name|lentry
modifier|*
name|llocate
parameter_list|(
name|id
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
block|{
specifier|register
name|struct
name|lentry
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|lhash
index|[
name|lhasher
argument_list|(
name|id
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
operator|&&
name|ptr
operator|->
name|l_name
operator|!=
name|id
condition|)
name|ptr
operator|=
name|ptr
operator|->
name|l_blink
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * glocate() - lookup identifier in global symbol table, NIL if not present.  */
end_comment

begin_function
name|struct
name|gentry
modifier|*
name|glocate
parameter_list|(
name|id
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
block|{
specifier|register
name|struct
name|gentry
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|ghash
index|[
name|ghasher
argument_list|(
name|id
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
operator|&&
name|ptr
operator|->
name|g_name
operator|!=
name|id
condition|)
block|{
name|ptr
operator|=
name|ptr
operator|->
name|g_blink
expr_stmt|;
block|}
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * clocate() - lookup identifier in constant symbol table, NIL if not present.  */
end_comment

begin_function
name|struct
name|centry
modifier|*
name|clocate
parameter_list|(
name|id
parameter_list|,
name|flag
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|centry
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|chash
index|[
name|chasher
argument_list|(
name|id
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
operator|&&
operator|(
name|ptr
operator|->
name|c_name
operator|!=
name|id
operator|||
name|ptr
operator|->
name|c_flag
operator|!=
name|flag
operator|)
condition|)
name|ptr
operator|=
name|ptr
operator|->
name|c_blink
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * klocate - look up keyword in keyword table  */
end_comment

begin_expr_stmt
name|klocate
argument_list|(
name|id
argument_list|)
specifier|register
name|int
name|id
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|keyent
modifier|*
name|kp
decl_stmt|;
for|for
control|(
name|kp
operator|=
name|keytab
init|;
name|kp
operator|->
name|keyid
operator|>=
literal|0
condition|;
name|kp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|kp
operator|->
name|keyname
argument_list|,
name|id
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|kp
operator|->
name|keyid
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * ldump() - display local symbol table to stdout.  */
end_comment

begin_macro
name|ldump
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|lentry
modifier|*
name|lptr
decl_stmt|;
name|printf
argument_list|(
literal|"Dump of local symbol table (%d entries)\n"
argument_list|,
name|lfree
operator|-
name|ltable
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" loc   blink   id              (name)      flags\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lhsize
condition|;
name|i
operator|++
control|)
for|for
control|(
name|lptr
operator|=
name|lhash
index|[
name|i
index|]
init|;
name|lptr
operator|!=
name|NULL
condition|;
name|lptr
operator|=
name|lptr
operator|->
name|l_blink
control|)
name|printf
argument_list|(
literal|"%5d  %5d  %5d  %20s  %7o\n"
argument_list|,
name|lptr
operator|-
name|ltable
argument_list|,
name|lptr
operator|->
name|l_blink
argument_list|,
name|lptr
operator|->
name|l_name
argument_list|,
name|lptr
operator|->
name|l_name
argument_list|,
name|lptr
operator|->
name|l_flag
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * gdump() - display global symbol table to stdout.  */
end_comment

begin_macro
name|gdump
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|gentry
modifier|*
name|gptr
decl_stmt|;
name|printf
argument_list|(
literal|"Dump of global symbol table (%d entries)\n"
argument_list|,
name|gfree
operator|-
name|gtable
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" loc   blink   id              (name)      flags       nargs\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ghsize
condition|;
name|i
operator|++
control|)
for|for
control|(
name|gptr
operator|=
name|ghash
index|[
name|i
index|]
init|;
name|gptr
operator|!=
name|NULL
condition|;
name|gptr
operator|=
name|gptr
operator|->
name|g_blink
control|)
name|printf
argument_list|(
literal|"%5d  %5d  %5d  %20s  %7o   %8d\n"
argument_list|,
name|gptr
operator|-
name|gtable
argument_list|,
name|gptr
operator|->
name|g_blink
argument_list|,
name|gptr
operator|->
name|g_name
argument_list|,
name|gptr
operator|->
name|g_name
argument_list|,
name|gptr
operator|->
name|g_flag
argument_list|,
name|gptr
operator|->
name|g_nargs
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * cdump() - display constant symbol table to stdout.  */
end_comment

begin_macro
name|cdump
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|centry
modifier|*
name|cptr
decl_stmt|;
name|printf
argument_list|(
literal|"Dump of constant symbol table (%d entries)\n"
argument_list|,
name|ctfree
operator|-
name|ctable
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" loc   blink   id              (name)      flags\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chsize
condition|;
name|i
operator|++
control|)
for|for
control|(
name|cptr
operator|=
name|chash
index|[
name|i
index|]
init|;
name|cptr
operator|!=
name|NULL
condition|;
name|cptr
operator|=
name|cptr
operator|->
name|c_blink
control|)
name|printf
argument_list|(
literal|"%5d  %5d  %5d  %20s  %7o\n"
argument_list|,
name|cptr
operator|-
name|ctable
argument_list|,
name|cptr
operator|->
name|c_blink
argument_list|,
name|cptr
operator|->
name|c_name
argument_list|,
name|cptr
operator|->
name|c_name
argument_list|,
name|cptr
operator|->
name|c_flag
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * alcloc - allocate a local symbol table entry, returns 0 if fails,  *   else returns offset of new entry.  */
end_comment

begin_function
name|struct
name|lentry
modifier|*
name|alcloc
parameter_list|(
name|blink
parameter_list|,
name|name
parameter_list|,
name|flag
parameter_list|)
name|struct
name|lentry
modifier|*
name|blink
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|lentry
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|lfree
operator|>=
operator|&
name|ltable
index|[
name|lsize
index|]
condition|)
block|{
comment|/* need more room */
if|if
condition|(
name|alclflg
operator|==
literal|0
condition|)
name|syserr
argument_list|(
literal|"out of local symbol table space"
argument_list|)
expr_stmt|;
name|alclflg
operator|++
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|lp
operator|=
name|lfree
operator|++
expr_stmt|;
name|lp
operator|->
name|l_blink
operator|=
name|blink
expr_stmt|;
name|lp
operator|->
name|l_name
operator|=
name|name
expr_stmt|;
name|lp
operator|->
name|l_flag
operator|=
name|flag
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * alcglob - allocate a global symbol table entry, returns 0 if fails,  *   else returns offset of new entry.  */
end_comment

begin_function
name|struct
name|gentry
modifier|*
name|alcglob
parameter_list|(
name|blink
parameter_list|,
name|name
parameter_list|,
name|flag
parameter_list|,
name|nargs
parameter_list|)
name|struct
name|gentry
modifier|*
name|blink
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|nargs
decl_stmt|;
block|{
specifier|register
name|struct
name|gentry
modifier|*
name|gp
decl_stmt|;
if|if
condition|(
name|gfree
operator|>=
operator|&
name|gtable
index|[
name|gsize
index|]
condition|)
block|{
comment|/* need more room */
if|if
condition|(
name|alcgflg
operator|==
literal|0
condition|)
name|syserr
argument_list|(
literal|"out of global symbol table space"
argument_list|)
expr_stmt|;
name|alcgflg
operator|++
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|gp
operator|=
name|gfree
operator|++
expr_stmt|;
name|gp
operator|->
name|g_blink
operator|=
name|blink
expr_stmt|;
name|gp
operator|->
name|g_name
operator|=
name|name
expr_stmt|;
name|gp
operator|->
name|g_flag
operator|=
name|flag
expr_stmt|;
name|gp
operator|->
name|g_nargs
operator|=
name|nargs
expr_stmt|;
return|return
operator|(
name|gp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * alclit - allocate a constant symbol table entry, returns 0 if fails,  *   else returns offset of new entry.  */
end_comment

begin_function
name|struct
name|centry
modifier|*
name|alclit
parameter_list|(
name|blink
parameter_list|,
name|name
parameter_list|,
name|len
parameter_list|,
name|flag
parameter_list|)
name|struct
name|centry
modifier|*
name|blink
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|,
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|centry
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|ctfree
operator|>=
operator|&
name|ctable
index|[
name|csize
index|]
condition|)
block|{
comment|/* need more room */
if|if
condition|(
name|alccflg
operator|==
literal|0
condition|)
name|syserr
argument_list|(
literal|"out of constant table space"
argument_list|)
expr_stmt|;
name|alccflg
operator|++
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cp
operator|=
name|ctfree
operator|++
expr_stmt|;
name|cp
operator|->
name|c_blink
operator|=
name|blink
expr_stmt|;
name|cp
operator|->
name|c_name
operator|=
name|name
expr_stmt|;
name|cp
operator|->
name|c_length
operator|=
name|len
expr_stmt|;
name|cp
operator|->
name|c_flag
operator|=
name|flag
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lout - dump local symbol table to file.  */
end_comment

begin_macro
name|lout
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|lentry
modifier|*
name|lp
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|ltable
init|;
name|lp
operator|<
name|lfree
condition|;
name|lp
operator|++
control|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\tlocal\t%d,%06o,%s\n"
argument_list|,
name|i
operator|++
argument_list|,
name|lp
operator|->
name|l_flag
argument_list|,
name|lp
operator|->
name|l_name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * cout(fd) - dump constant symbol table to file.  */
end_comment

begin_macro
name|cout
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|l
decl_stmt|;
specifier|register
name|char
modifier|*
name|c
decl_stmt|;
specifier|register
name|struct
name|centry
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|ctable
init|;
name|cp
operator|<
name|ctfree
condition|;
name|cp
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\tcon\t%d,%06o"
argument_list|,
name|i
operator|++
argument_list|,
name|cp
operator|->
name|c_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|c_flag
operator|&
operator|(
name|F_INTLIT
operator||
name|F_REALLIT
operator|)
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|",%s\n"
argument_list|,
name|cp
operator|->
name|c_name
argument_list|)
expr_stmt|;
else|else
block|{
name|c
operator|=
name|cp
operator|->
name|c_name
expr_stmt|;
name|l
operator|=
name|cp
operator|->
name|c_length
operator|-
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|",%d"
argument_list|,
name|l
argument_list|)
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|",%03o"
argument_list|,
operator|*
name|c
operator|++
operator|&
literal|0377
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * rout - dump a record declaration to file fd.  */
end_comment

begin_macro
name|rout
argument_list|(
argument|fd
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|lentry
modifier|*
name|lp
decl_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"record\t%s,%d\n"
argument_list|,
name|name
argument_list|,
name|lfree
operator|-
name|ltable
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|ltable
init|;
name|lp
operator|<
name|lfree
condition|;
name|lp
operator|++
control|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\t%d,%s\n"
argument_list|,
name|i
operator|++
argument_list|,
name|lp
operator|->
name|l_name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * gout - dump global table to file fd.  */
end_comment

begin_macro
name|gout
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|gentry
modifier|*
name|gp
decl_stmt|;
if|if
condition|(
name|implicit
operator|==
name|LOCAL
condition|)
name|name
operator|=
literal|"local"
expr_stmt|;
else|else
name|name
operator|=
literal|"error"
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"impl\t%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"trace\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"global\t%d\n"
argument_list|,
name|gfree
operator|-
name|gtable
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|gtable
init|;
name|gp
operator|<
name|gfree
condition|;
name|gp
operator|++
control|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\t%d,%06o,%s,%d\n"
argument_list|,
name|i
operator|++
argument_list|,
name|gp
operator|->
name|g_flag
argument_list|,
name|gp
operator|->
name|g_name
argument_list|,
name|gp
operator|->
name|g_nargs
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

