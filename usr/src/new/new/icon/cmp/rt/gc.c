begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"../h/gc.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VAX
end_ifdef

begin_comment
comment|/*  * hneed(bytes) - insure at least 'bytes' space left in heap.  */
end_comment

begin_macro
name|hneed
argument_list|(
argument|bytes
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|bytes
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|heapneed
operator|=
name|bytes
expr_stmt|;
if|if
condition|(
name|bytes
operator|>
name|maxheap
operator|-
name|hpfree
condition|)
name|gcollect
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * sneed(chars) - insure at least 'chars' bytes left in string space.  */
end_comment

begin_macro
name|sneed
argument_list|(
argument|chars
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|chars
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|strneed
operator|=
name|chars
expr_stmt|;
if|if
condition|(
name|chars
operator|>
name|estrings
operator|-
name|sfree
condition|)
name|gcollect
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * esneed() - insure stack space free list is not empty.  */
end_comment

begin_macro
name|esneed
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|esfree
operator|==
name|NULL
condition|)
name|gcollect
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * escollect() - collect the expression stack space after marking.  */
end_comment

begin_macro
name|escollect
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
modifier|*
name|ep
decl_stmt|;
specifier|register
name|struct
name|b_estack
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|descrip
modifier|*
name|nxtptr
decl_stmt|,
modifier|*
name|tptr
decl_stmt|;
name|BLKLOC
argument_list|(
name|k_main
argument_list|)
operator|->
name|estack
operator|.
name|type
operator|=
name|T_ESTACK
expr_stmt|;
comment|/* must reset */
name|esfree
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|stacks
init|;
name|ep
operator|<
name|estacks
condition|;
name|ep
operator|+=
name|STACKSIZE
control|)
block|{
name|sp
operator|=
name|ep
operator|+
operator|(
name|STACKSIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|b_estack
argument_list|)
operator|/
name|ADDRSIZE
operator|)
expr_stmt|;
if|if
condition|(
name|blktype
argument_list|(
name|sp
argument_list|)
operator|==
name|T_ESTACK
condition|)
block|{
comment|/* add to free list */
operator|*
name|ep
operator|=
name|esfree
expr_stmt|;
name|esfree
operator|=
name|ep
expr_stmt|;
block|}
else|else
comment|/* adjust type field */
name|blktype
argument_list|(
name|sp
argument_list|)
operator|=
name|T_ESTACK
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * collect - call the heap garbage collector.  */
end_comment

begin_macro
name|collect
argument_list|(
argument|esneed
argument_list|)
end_macro

begin_decl_stmt
name|int
name|esneed
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|extra
decl_stmt|;
specifier|register
name|char
modifier|*
name|newend
decl_stmt|;
specifier|register
name|struct
name|descrip
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|sptr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|brk
parameter_list|()
function_decl|;
name|sqfree
operator|=
name|sqlist
expr_stmt|;
comment|/* initialize string qualifier list */
name|mark
argument_list|(
operator|&
name|k_main
argument_list|)
expr_stmt|;
comment|/* mark main stack */
name|mark
argument_list|(
operator|&
name|current
argument_list|)
expr_stmt|;
comment|/* mark current stack */
name|mark
argument_list|(
operator|&
name|k_subject
argument_list|)
expr_stmt|;
comment|/* mark tended descriptors */
name|mark
argument_list|(
operator|&
name|maps2
argument_list|)
expr_stmt|;
name|mark
argument_list|(
operator|&
name|maps3
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|tended
init|;
name|dp
operator|<
name|etended
condition|;
name|dp
operator|++
control|)
name|mark
argument_list|(
name|dp
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|globals
init|;
name|dp
operator|<
name|eglobals
condition|;
name|dp
operator|++
control|)
name|mark
argument_list|(
name|dp
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|statics
init|;
name|dp
operator|<
name|estatics
condition|;
name|dp
operator|++
control|)
name|mark
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|escollect
argument_list|()
expr_stmt|;
comment|/* collect available expression stacks */
if|if
condition|(
name|esneed
operator|&&
name|esfree
operator|==
name|NULL
condition|)
block|{
name|esfree
operator|=
name|estacks
expr_stmt|;
comment|/* need to make room for another stack */
operator|*
name|estacks
operator|=
literal|0
expr_stmt|;
name|estacks
operator|+=
name|STACKSIZE
expr_stmt|;
name|extra
operator|=
name|STACKSIZE
operator|*
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
expr_stmt|;
comment|/* string and heap ptrs are chars */
comment|/*+ note that the above is a 					   calc. of number of words. 					   Actually, it was sizeof(int), so 					   I don't guess that using int* will 					   help much. -- whm */
name|newend
operator|=
name|sqlist
operator|+
name|extra
expr_stmt|;
if|if
condition|(
name|newend
operator|<
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|||
name|newend
operator|>
operator|(
name|char
operator|*
operator|)
literal|0x7fffffff
operator|||
operator|(
name|newend
operator|>
operator|(
name|char
operator|*
operator|)
name|esqlist
operator|&&
name|brk
argument_list|(
name|newend
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|runerr
argument_list|(
literal|305
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|extra
operator|=
literal|0
expr_stmt|;
name|scollect
argument_list|(
name|extra
argument_list|)
expr_stmt|;
comment|/* collect string space */
name|sptr
operator|=
name|strings
operator|+
name|extra
expr_stmt|;
comment|/* remember new location of string space */
name|estrings
operator|+=
name|extra
expr_stmt|;
name|sqlist
operator|+=
name|extra
expr_stmt|;
if|if
condition|(
name|sqlist
operator|>
name|esqlist
condition|)
name|esqlist
operator|=
name|sqlist
expr_stmt|;
name|extra
operator|=
operator|(
name|MAX
argument_list|(
literal|2
operator|*
name|strneed
argument_list|,
operator|(
name|estrings
operator|-
operator|(
name|char
operator|*
operator|)
name|estacks
operator|)
operator|/
literal|4
argument_list|)
operator|-
operator|(
name|estrings
operator|-
name|extra
operator|-
name|sfree
operator|)
operator|+
literal|63
operator|)
operator|&
operator|~
literal|077
expr_stmt|;
while|while
condition|(
name|extra
operator|>
literal|0
condition|)
block|{
comment|/* need breathing room? */
name|newend
operator|=
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|+
name|extra
expr_stmt|;
if|if
condition|(
name|newend
operator|>=
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|&&
operator|(
name|newend
operator|<=
operator|(
name|char
operator|*
operator|)
name|esqlist
operator|||
name|brk
argument_list|(
name|newend
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|estrings
operator|+=
name|extra
expr_stmt|;
name|sqlist
operator|=
name|newend
expr_stmt|;
break|break;
block|}
name|extra
operator|-=
literal|64
expr_stmt|;
block|}
name|adjust
argument_list|(
name|hpbase
argument_list|,
name|estrings
argument_list|)
expr_stmt|;
comment|/* adjust pointers into heap */
name|compact
argument_list|(
name|hpbase
argument_list|)
expr_stmt|;
comment|/* compact heap */
name|extra
operator|=
operator|(
name|MAX
argument_list|(
literal|2
operator|*
name|heapneed
argument_list|,
operator|(
name|maxheap
operator|-
name|hpbase
operator|)
operator|/
literal|4
argument_list|)
operator|+
name|hpfree
operator|-
name|maxheap
operator|+
literal|63
operator|)
operator|&
operator|~
literal|077
expr_stmt|;
while|while
condition|(
name|extra
operator|>
literal|0
condition|)
block|{
comment|/* need breathing room? */
name|newend
operator|=
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|+
name|extra
expr_stmt|;
if|if
condition|(
name|newend
operator|>=
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|&&
operator|(
name|newend
operator|<=
operator|(
name|char
operator|*
operator|)
name|esqlist
operator|||
name|brk
argument_list|(
name|newend
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sqlist
operator|=
name|newend
expr_stmt|;
break|break;
block|}
name|extra
operator|-=
literal|64
expr_stmt|;
block|}
if|if
condition|(
name|sqlist
operator|>
name|esqlist
condition|)
name|esqlist
operator|=
name|sqlist
expr_stmt|;
if|if
condition|(
name|estrings
operator|!=
name|hpbase
condition|)
block|{
comment|/* move heap */
name|mvc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|hpfree
operator|-
name|hpbase
argument_list|)
argument_list|,
name|hpbase
argument_list|,
name|estrings
argument_list|)
expr_stmt|;
name|hpfree
operator|+=
name|estrings
operator|-
name|hpbase
expr_stmt|;
name|hpbase
operator|=
name|estrings
expr_stmt|;
block|}
if|if
condition|(
name|sptr
operator|!=
name|strings
condition|)
block|{
comment|/* move string space */
name|mvc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|sfree
operator|-
name|strings
argument_list|)
argument_list|,
name|strings
argument_list|,
name|sptr
argument_list|)
expr_stmt|;
name|sfree
operator|+=
name|sptr
operator|-
name|strings
expr_stmt|;
name|strings
operator|=
name|sptr
expr_stmt|;
block|}
name|maxheap
operator|=
operator|(
name|char
operator|*
operator|)
name|sqlist
expr_stmt|;
comment|/* expand heap */
return|return;
block|}
end_block

begin_comment
comment|/*  * yields ap of a frame addressed by fp  */
end_comment

begin_function
name|int
modifier|*
name|vax_apof
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|int
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|mask
init|=
name|fp
index|[
literal|1
index|]
operator|>>
literal|15
operator|&
literal|0x1ffe
decl_stmt|;
name|fp
operator|+=
literal|5
expr_stmt|;
while|while
condition|(
name|mask
operator|>>=
literal|1
condition|)
name|fp
operator|+=
name|mask
operator|&
literal|1
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/*  * sweep - sweep the stack, marking all descriptors there.  *  * This needs some documentation due to its cleverness--whm  */
end_comment

begin_macro
name|sweep
argument_list|(
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|sp
decl_stmt|,
modifier|*
name|r5
decl_stmt|,
modifier|*
name|r4
decl_stmt|;
name|int
modifier|*
name|r3
decl_stmt|,
name|nargs
decl_stmt|;
specifier|register
name|int
modifier|*
name|ap
decl_stmt|;
name|sp
operator|=
name|b
expr_stmt|;
name|r5
operator|=
name|sp
expr_stmt|;
name|ap
operator|=
name|vax_apof
argument_list|(
name|r5
argument_list|)
expr_stmt|;
name|sp
operator|=
name|r5
operator|-
literal|2
expr_stmt|;
name|nargs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|r5
operator|!=
literal|0
operator|||
name|nargs
operator|)
condition|)
block|{
if|if
condition|(
name|sp
operator|==
name|r5
operator|-
name|FRAMELIMIT
condition|)
block|{
comment|/* at a procedure frame */
name|r4
operator|=
name|ap
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|r3
operator|=
name|ap
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|sp
operator|=
name|ap
operator|+
literal|2
expr_stmt|;
name|ap
operator|=
name|r5
index|[
literal|2
index|]
expr_stmt|;
name|r5
operator|=
name|r5
index|[
literal|3
index|]
expr_stmt|;
name|nargs
operator|=
name|sp
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|==
name|r3
operator|-
literal|3
condition|)
block|{
comment|/* at a generator frame */
name|r5
operator|=
name|r3
index|[
literal|0
index|]
expr_stmt|;
name|sp
operator|=
name|r5
operator|-
name|FRAMELIMIT
expr_stmt|;
name|ap
operator|=
name|vax_apof
argument_list|(
name|r5
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|==
name|r4
operator|-
literal|2
condition|)
block|{
comment|/* at an expression frame */
name|r3
operator|=
name|r4
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|r4
operator|=
name|r4
index|[
literal|0
index|]
expr_stmt|;
name|sp
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
comment|/* must be a descriptor! */
name|mark
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|nargs
condition|)
name|nargs
operator|--
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * mark - mark each accessible block in the heap and build back-list of  *  descriptors pointing to that block. (Phase I of garbage collection)  */
end_comment

begin_macro
name|mark
argument_list|(
argument|cdesc
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|descrip
modifier|*
name|cdesc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current descriptor */
end_comment

begin_block
block|{
specifier|register
name|struct
name|descrip
modifier|*
name|ndesc
decl_stmt|;
specifier|register
name|char
modifier|*
name|endblock
decl_stmt|,
modifier|*
name|block
decl_stmt|;
specifier|static
name|char
modifier|*
name|type
decl_stmt|;
specifier|static
name|int
name|fdesc
decl_stmt|;
if|if
condition|(
name|QUAL
argument_list|(
operator|*
name|cdesc
argument_list|)
condition|)
comment|/* if descriptor is a string qualifier, */
name|marksq
argument_list|(
name|cdesc
argument_list|)
expr_stmt|;
comment|/*   mark it for scollect */
elseif|else
if|if
condition|(
name|isptr
argument_list|(
name|cdesc
argument_list|)
condition|)
block|{
comment|/* ok, descriptor is a pointer */
name|block
operator|=
name|BLKLOC
argument_list|(
operator|*
name|cdesc
argument_list|)
expr_stmt|;
comment|/* get pointer to top of block */
if|if
condition|(
name|VAR
argument_list|(
operator|*
name|cdesc
argument_list|)
operator|&&
operator|!
name|TVAR
argument_list|(
operator|*
name|cdesc
argument_list|)
condition|)
comment|/* if variable, need offset */
name|block
operator|=
operator|(
name|int
operator|*
operator|)
name|block
operator|-
name|OFFSET
argument_list|(
operator|*
name|cdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|>=
name|hpbase
operator|&&
name|block
operator|<
name|hpfree
condition|)
block|{
comment|/* insure it points to heap */
name|type
operator|=
name|blktype
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|/* save type and end of block */
if|if
condition|(
name|type
operator|<=
name|MAXTYPE
condition|)
name|endblock
operator|=
name|block
operator|+
name|getsize
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BLKLOC
argument_list|(
operator|*
name|cdesc
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* add descriptor to back chain */
name|blktype
argument_list|(
name|block
argument_list|)
operator|=
name|cdesc
expr_stmt|;
comment|/* sweep descriptors in block */
if|if
condition|(
operator|(
name|type
operator|<=
name|MAXTYPE
operator|)
operator|&&
operator|(
operator|(
name|fdesc
operator|=
name|firstd
index|[
operator|(
name|int
operator|)
name|type
index|]
operator|)
operator|>
literal|0
operator|)
condition|)
for|for
control|(
name|ndesc
operator|=
name|block
operator|+
name|fdesc
init|;
name|ndesc
operator|<
name|endblock
condition|;
name|ndesc
operator|++
control|)
name|mark
argument_list|(
name|ndesc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|VAR
argument_list|(
operator|*
name|cdesc
argument_list|)
operator|&&
name|TYPE
argument_list|(
operator|*
name|cdesc
argument_list|)
operator|==
name|T_ESTACK
operator|&&
operator|(
name|char
operator|*
operator|)
name|blktype
argument_list|(
name|block
argument_list|)
operator|<=
name|MAXTYPE
condition|)
block|{
name|blktype
argument_list|(
name|block
argument_list|)
operator|=
name|cdesc
expr_stmt|;
comment|/* note block as visited */
name|sweep
argument_list|(
operator|(
operator|(
expr|struct
name|b_estack
operator|*
operator|)
name|block
operator|)
operator|->
name|boundary
argument_list|)
expr_stmt|;
name|mark
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|b_estack
operator|*
operator|)
name|block
operator|)
operator|->
name|activator
argument_list|)
expr_stmt|;
name|mark
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|b_estack
operator|*
operator|)
name|block
operator|)
operator|->
name|freshblk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * adjust - adjust pointers into heap, beginning with heapblock 'oblk'.  *   (Phase II of garbage collection)  */
end_comment

begin_macro
name|adjust
argument_list|(
argument|oblk
argument_list|,
argument|nblk
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|oblk
decl_stmt|,
modifier|*
name|nblk
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|descrip
modifier|*
name|nxtptr
decl_stmt|,
modifier|*
name|tptr
decl_stmt|;
while|while
condition|(
name|oblk
operator|<
name|hpfree
condition|)
block|{
comment|/* linear sweep through heap */
if|if
condition|(
operator|(
name|nxtptr
operator|=
name|blktype
argument_list|(
name|oblk
argument_list|)
operator|)
operator|>
name|MAXTYPE
condition|)
block|{
while|while
condition|(
operator|(
name|unsigned
operator|)
name|nxtptr
operator|>
name|MAXTYPE
condition|)
block|{
name|tptr
operator|=
name|nxtptr
expr_stmt|;
name|nxtptr
operator|=
name|BLKLOC
argument_list|(
operator|*
name|nxtptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|VAR
argument_list|(
operator|*
name|tptr
argument_list|)
operator|&&
operator|!
name|TVAR
argument_list|(
operator|*
name|tptr
argument_list|)
condition|)
name|BLKLOC
argument_list|(
operator|*
name|tptr
argument_list|)
operator|=
operator|(
name|int
operator|*
operator|)
name|nblk
operator|+
name|OFFSET
argument_list|(
operator|*
name|tptr
argument_list|)
expr_stmt|;
else|else
name|BLKLOC
argument_list|(
operator|*
name|tptr
argument_list|)
operator|=
name|nblk
expr_stmt|;
block|}
name|blktype
argument_list|(
name|oblk
argument_list|)
operator|=
operator|(
name|unsigned
operator|)
name|nxtptr
operator||
name|MARK
expr_stmt|;
name|nblk
operator|+=
name|getsize
argument_list|(
name|oblk
argument_list|)
expr_stmt|;
block|}
name|oblk
operator|+=
name|getsize
argument_list|(
name|oblk
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * compact - compact good blocks in heap, beginning with block 'oblk'.  *   (Phase III of garbage collection)  */
end_comment

begin_macro
name|compact
argument_list|(
argument|oblk
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|oblk
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|nblk
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
name|nblk
operator|=
name|oblk
expr_stmt|;
comment|/* linear sweep through heap */
while|while
condition|(
name|oblk
operator|<
name|hpfree
condition|)
block|{
name|size
operator|=
name|getsize
argument_list|(
name|oblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|blktype
argument_list|(
name|oblk
argument_list|)
operator|&
name|MARK
condition|)
block|{
comment|/* move good block */
name|blktype
argument_list|(
name|oblk
argument_list|)
operator|&=
operator|~
name|MARK
expr_stmt|;
comment|/* turn off mark */
if|if
condition|(
name|oblk
operator|!=
name|nblk
condition|)
name|mvc
argument_list|(
operator|(
name|unsigned
operator|)
name|size
argument_list|,
name|oblk
argument_list|,
name|nblk
argument_list|)
expr_stmt|;
name|nblk
operator|+=
name|size
expr_stmt|;
block|}
name|oblk
operator|+=
name|size
expr_stmt|;
block|}
name|hpfree
operator|=
name|nblk
expr_stmt|;
comment|/* reset free space pointer */
block|}
end_block

begin_comment
comment|/*  * marksq - mark a string qualifier.  If it points into the  * string space, put a pointer to it in the string qualifier  * list.  */
end_comment

begin_macro
name|marksq
argument_list|(
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|descrip
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|brk
parameter_list|()
function_decl|;
name|int
name|slen
decl_stmt|;
name|char
name|s
index|[
literal|100
index|]
decl_stmt|;
name|strncpy
argument_list|(
name|s
argument_list|,
name|STRLOC
argument_list|(
operator|*
name|d
argument_list|)
argument_list|,
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|STRLOC
argument_list|(
operator|*
name|d
argument_list|)
operator|>=
name|strings
operator|&&
name|STRLOC
argument_list|(
operator|*
name|d
argument_list|)
operator|<
name|estrings
condition|)
block|{
if|if
condition|(
name|sqfree
operator|>=
name|esqlist
condition|)
block|{
name|esqlist
operator|+=
name|SQLINC
expr_stmt|;
if|if
condition|(
name|brk
argument_list|(
name|esqlist
argument_list|)
condition|)
name|runerr
argument_list|(
literal|303
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|*
name|sqfree
operator|++
operator|=
name|d
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * scollect - collect the string space.  * A list of string qualifiers points to all valid strings.  */
end_comment

begin_macro
name|scollect
argument_list|(
argument|extra
argument_list|)
end_macro

begin_decl_stmt
name|int
name|extra
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
specifier|register
name|struct
name|descrip
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
specifier|extern
name|int
name|sqcmp
parameter_list|()
function_decl|;
if|if
condition|(
name|sqfree
operator|<=
name|sqlist
condition|)
block|{
name|sfree
operator|=
name|strings
expr_stmt|;
return|return;
block|}
name|qsort
argument_list|(
name|sqlist
argument_list|,
name|sqfree
operator|-
name|sqlist
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|descrip
operator|*
argument_list|)
argument_list|,
name|sqcmp
argument_list|)
expr_stmt|;
name|d
operator|=
name|strings
expr_stmt|;
name|s
operator|=
name|e
operator|=
name|STRLOC
argument_list|(
operator|*
operator|*
name|sqlist
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sqlist
init|;
name|p
operator|<
name|sqfree
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|>
name|e
condition|)
block|{
comment|/* outside last clump */
while|while
condition|(
name|s
operator|<
name|e
condition|)
comment|/* move the clump */
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|e
operator|=
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
expr_stmt|;
comment|/* start a new clump */
block|}
if|if
condition|(
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|+
name|STRLEN
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|>
name|e
condition|)
comment|/* extend the clump */
name|e
operator|=
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|+
name|STRLEN
argument_list|(
operator|*
operator|*
name|p
argument_list|)
expr_stmt|;
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|+=
name|d
operator|-
name|s
operator|+
name|extra
expr_stmt|;
comment|/* relocate the string qualifier */
block|}
while|while
condition|(
name|s
operator|<
name|e
condition|)
comment|/* move the last clump */
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|sfree
operator|=
name|d
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * sqcmp - compare the location fields of two string qualifiers for qsort.  */
end_comment

begin_macro
name|sqcmp
argument_list|(
argument|q1
argument_list|,
argument|q2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|descrip
modifier|*
modifier|*
name|q1
decl_stmt|,
modifier|*
modifier|*
name|q2
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|STRLOC
argument_list|(
operator|*
operator|*
name|q1
argument_list|)
operator|-
name|STRLOC
argument_list|(
operator|*
operator|*
name|q2
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * mvc - move n bytes from src to dst.  * src and dst must be at word boundaries.  */
end_comment

begin_macro
name|mvc
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|words
decl_stmt|;
specifier|register
name|int
modifier|*
name|srcw
decl_stmt|,
modifier|*
name|dstw
decl_stmt|;
comment|/* word aligned pointers */
name|int
name|bytes
decl_stmt|;
name|words
operator|=
name|n
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|n
operator|%
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|srcw
operator|=
operator|(
name|int
operator|*
operator|)
name|s
expr_stmt|;
name|dstw
operator|=
operator|(
name|int
operator|*
operator|)
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|s
condition|)
block|{
comment|/* move back */
while|while
condition|(
operator|--
name|words
operator|>=
literal|0
condition|)
operator|*
operator|(
name|dstw
operator|)
operator|++
operator|=
operator|*
operator|(
name|srcw
operator|)
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|bytes
operator|>=
literal|0
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|>
name|s
condition|)
block|{
comment|/* move forward */
name|s
operator|+=
name|n
expr_stmt|;
name|d
operator|+=
name|n
expr_stmt|;
while|while
condition|(
operator|--
name|bytes
operator|>=
literal|0
condition|)
operator|*
operator|--
name|d
operator|=
operator|*
operator|--
name|s
expr_stmt|;
name|srcw
operator|=
operator|(
name|int
operator|*
operator|)
name|s
expr_stmt|;
name|dstw
operator|=
operator|(
name|int
operator|*
operator|)
name|d
expr_stmt|;
while|while
condition|(
operator|--
name|words
operator|>=
literal|0
condition|)
operator|*
operator|--
name|dstw
operator|=
operator|*
operator|--
name|srcw
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|VAX
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PDP11
end_ifdef

begin_comment
comment|/*  * hneed(bytes) - insure at least 'bytes' space left in heap.  */
end_comment

begin_macro
name|hneed
argument_list|(
argument|bytes
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|bytes
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|heapneed
operator|=
name|bytes
expr_stmt|;
if|if
condition|(
name|bytes
operator|>
name|maxheap
operator|-
name|hpfree
condition|)
name|gcollect
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * sneed(chars) - insure at least 'chars' bytes left in string space.  */
end_comment

begin_macro
name|sneed
argument_list|(
argument|chars
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|chars
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|strneed
operator|=
name|chars
expr_stmt|;
if|if
condition|(
name|chars
operator|>
name|estrings
operator|-
name|sfree
condition|)
name|gcollect
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * esneed() - insure stack space free list is not empty.  */
end_comment

begin_macro
name|esneed
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|esfree
operator|==
name|NULL
condition|)
name|gcollect
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * escollect() - collect the expression stack space after marking.  */
end_comment

begin_macro
name|escollect
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
modifier|*
name|ep
decl_stmt|;
specifier|register
name|struct
name|b_estack
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|descrip
modifier|*
name|nxtptr
decl_stmt|,
modifier|*
name|tptr
decl_stmt|;
name|BLKLOC
argument_list|(
name|k_main
argument_list|)
operator|->
name|estack
operator|.
name|type
operator|=
name|T_ESTACK
expr_stmt|;
comment|/* must reset */
name|esfree
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|stacks
init|;
name|ep
operator|<
name|estacks
condition|;
name|ep
operator|+=
name|STACKSIZE
control|)
block|{
name|sp
operator|=
name|ep
operator|+
operator|(
name|STACKSIZE
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|b_estack
argument_list|)
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|blktype
argument_list|(
name|sp
argument_list|)
operator|==
name|T_ESTACK
condition|)
block|{
comment|/* add to free list */
operator|*
name|ep
operator|=
name|esfree
expr_stmt|;
name|esfree
operator|=
name|ep
expr_stmt|;
block|}
else|else
comment|/* adjust type field */
name|blktype
argument_list|(
name|sp
argument_list|)
operator|=
name|T_ESTACK
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * collect - call the heap garbage collector.  */
end_comment

begin_macro
name|collect
argument_list|(
argument|esneed
argument_list|)
end_macro

begin_decl_stmt
name|int
name|esneed
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|extra
decl_stmt|;
specifier|register
name|char
modifier|*
name|newend
decl_stmt|;
specifier|register
name|struct
name|descrip
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|sptr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|brk
parameter_list|()
function_decl|;
name|sqfree
operator|=
name|sqlist
expr_stmt|;
comment|/* initialize string qualifier list */
name|mark
argument_list|(
operator|&
name|k_main
argument_list|)
expr_stmt|;
comment|/* mark main stack */
name|mark
argument_list|(
operator|&
name|current
argument_list|)
expr_stmt|;
comment|/* mark current stack */
name|mark
argument_list|(
operator|&
name|k_subject
argument_list|)
expr_stmt|;
comment|/* mark tended descriptors */
name|mark
argument_list|(
operator|&
name|maps2
argument_list|)
expr_stmt|;
name|mark
argument_list|(
operator|&
name|maps3
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|tended
init|;
name|dp
operator|<
name|etended
condition|;
name|dp
operator|++
control|)
name|mark
argument_list|(
name|dp
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|globals
init|;
name|dp
operator|<
name|eglobals
condition|;
name|dp
operator|++
control|)
name|mark
argument_list|(
name|dp
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|statics
init|;
name|dp
operator|<
name|estatics
condition|;
name|dp
operator|++
control|)
name|mark
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|escollect
argument_list|()
expr_stmt|;
comment|/* collect available expression stacks */
if|if
condition|(
name|esneed
operator|&&
name|esfree
operator|==
name|NULL
condition|)
block|{
name|esfree
operator|=
name|estacks
expr_stmt|;
comment|/* need to make room for another stack */
operator|*
name|estacks
operator|=
literal|0
expr_stmt|;
name|estacks
operator|+=
name|STACKSIZE
expr_stmt|;
name|extra
operator|=
name|STACKSIZE
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* string and heap ptrs are chars */
name|newend
operator|=
name|sqlist
operator|+
name|extra
expr_stmt|;
if|if
condition|(
name|newend
operator|<
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|||
name|newend
operator|>
operator|(
name|char
operator|*
operator|)
literal|0177700
operator|||
operator|(
name|newend
operator|>
operator|(
name|char
operator|*
operator|)
name|esqlist
operator|&&
name|brk
argument_list|(
name|newend
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|runerr
argument_list|(
literal|305
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|extra
operator|=
literal|0
expr_stmt|;
name|scollect
argument_list|(
name|extra
argument_list|)
expr_stmt|;
comment|/* collect string space */
name|sptr
operator|=
name|strings
operator|+
name|extra
expr_stmt|;
comment|/* remember new location of string space */
name|estrings
operator|+=
name|extra
expr_stmt|;
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|+=
name|extra
expr_stmt|;
if|if
condition|(
name|sqlist
operator|>
name|esqlist
condition|)
name|esqlist
operator|=
name|sqlist
expr_stmt|;
name|extra
operator|=
operator|(
name|MAX
argument_list|(
literal|2
operator|*
name|strneed
argument_list|,
operator|(
name|estrings
operator|-
name|estacks
operator|)
operator|/
literal|4
argument_list|)
operator|-
operator|(
name|estrings
operator|-
name|extra
operator|-
name|sfree
operator|)
operator|+
literal|63
operator|)
operator|&
operator|~
literal|077
expr_stmt|;
while|while
condition|(
name|extra
operator|>
literal|0
condition|)
block|{
comment|/* need breathing room? */
name|newend
operator|=
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|+
name|extra
expr_stmt|;
if|if
condition|(
name|newend
operator|>=
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|&&
name|newend
operator|<=
operator|(
name|char
operator|*
operator|)
literal|0177700
operator|&&
operator|(
name|newend
operator|<=
operator|(
name|char
operator|*
operator|)
name|esqlist
operator|||
name|brk
argument_list|(
name|newend
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|estrings
operator|+=
name|extra
expr_stmt|;
name|sqlist
operator|=
name|newend
expr_stmt|;
break|break;
block|}
name|extra
operator|-=
literal|64
expr_stmt|;
block|}
name|adjust
argument_list|(
name|hpbase
argument_list|,
name|estrings
argument_list|)
expr_stmt|;
comment|/* adjust pointers into heap */
name|compact
argument_list|(
name|hpbase
argument_list|)
expr_stmt|;
comment|/* compact heap */
name|extra
operator|=
operator|(
name|MAX
argument_list|(
literal|2
operator|*
name|heapneed
argument_list|,
operator|(
name|maxheap
operator|-
name|hpbase
operator|)
operator|/
literal|4
argument_list|)
operator|+
name|hpfree
operator|-
name|maxheap
operator|+
literal|63
operator|)
operator|&
operator|~
literal|077
expr_stmt|;
while|while
condition|(
name|extra
operator|>
literal|0
condition|)
block|{
comment|/* need breathing room? */
name|newend
operator|=
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|+
name|extra
expr_stmt|;
if|if
condition|(
name|newend
operator|>=
operator|(
name|char
operator|*
operator|)
name|sqlist
operator|&&
name|newend
operator|<=
operator|(
name|char
operator|*
operator|)
literal|0177700
operator|&&
operator|(
name|newend
operator|<=
operator|(
name|char
operator|*
operator|)
name|esqlist
operator|||
name|brk
argument_list|(
name|newend
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sqlist
operator|=
name|newend
expr_stmt|;
break|break;
block|}
name|extra
operator|-=
literal|64
expr_stmt|;
block|}
if|if
condition|(
name|sqlist
operator|>
name|esqlist
condition|)
name|esqlist
operator|=
name|sqlist
expr_stmt|;
if|if
condition|(
name|estrings
operator|!=
name|hpbase
condition|)
block|{
comment|/* move heap */
name|mvc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|hpfree
operator|-
name|hpbase
argument_list|)
argument_list|,
name|hpbase
argument_list|,
name|estrings
argument_list|)
expr_stmt|;
name|hpfree
operator|+=
name|estrings
operator|-
name|hpbase
expr_stmt|;
name|hpbase
operator|=
name|estrings
expr_stmt|;
block|}
if|if
condition|(
name|sptr
operator|!=
name|strings
condition|)
block|{
comment|/* move string space */
name|mvc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|sfree
operator|-
name|strings
argument_list|)
argument_list|,
name|strings
argument_list|,
name|sptr
argument_list|)
expr_stmt|;
name|sfree
operator|+=
name|sptr
operator|-
name|strings
expr_stmt|;
name|strings
operator|=
name|sptr
expr_stmt|;
block|}
name|maxheap
operator|=
operator|(
name|char
operator|*
operator|)
name|sqlist
expr_stmt|;
comment|/* expand heap */
return|return;
block|}
end_block

begin_comment
comment|/*  * sweep - sweep the stack, marking all descriptors there.  */
end_comment

begin_macro
name|sweep
argument_list|(
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|sp
decl_stmt|,
modifier|*
name|r5
decl_stmt|,
modifier|*
name|r4
decl_stmt|;
name|int
modifier|*
name|r3
decl_stmt|,
name|nargs
decl_stmt|;
name|r5
operator|=
name|b
expr_stmt|;
comment|/* start at last Icon/C boundary */
name|sp
operator|=
name|r5
operator|-
literal|5
expr_stmt|;
name|nargs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|r5
operator|!=
literal|0
operator|||
name|nargs
operator|)
operator|&&
name|sp
operator|<
operator|(
name|int
operator|*
operator|)
literal|0177776
condition|)
block|{
if|if
condition|(
name|sp
operator|==
name|r5
operator|-
literal|5
condition|)
block|{
comment|/* at a procedure frame */
name|r3
operator|=
name|r5
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|r4
operator|=
name|r5
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|r5
operator|=
name|r5
index|[
literal|0
index|]
expr_stmt|;
name|sp
operator|+=
literal|8
expr_stmt|;
name|nargs
operator|=
name|sp
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|==
name|r3
operator|-
literal|3
condition|)
block|{
comment|/* at a generator frame */
name|r5
operator|=
name|r3
index|[
literal|0
index|]
expr_stmt|;
comment|/*   go to next boundary */
name|sp
operator|=
name|r5
operator|-
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|==
name|r4
operator|-
literal|2
condition|)
block|{
comment|/* at an expression frame */
name|r3
operator|=
name|r4
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|r4
operator|=
name|r4
index|[
literal|0
index|]
expr_stmt|;
name|sp
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
comment|/* must be a descriptor! */
name|mark
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|nargs
condition|)
name|nargs
operator|--
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * mark - mark each accessible block in the heap and build back-list of  *  descriptors pointing to that block. (Phase I of garbage collection)  */
end_comment

begin_macro
name|mark
argument_list|(
argument|cdesc
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|descrip
modifier|*
name|cdesc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current descriptor */
end_comment

begin_block
block|{
specifier|register
name|struct
name|descrip
modifier|*
name|ndesc
decl_stmt|;
specifier|register
name|char
modifier|*
name|endblock
decl_stmt|,
modifier|*
name|block
decl_stmt|;
specifier|static
name|char
modifier|*
name|type
decl_stmt|;
specifier|static
name|int
name|fdesc
decl_stmt|;
if|if
condition|(
name|QUAL
argument_list|(
operator|*
name|cdesc
argument_list|)
condition|)
comment|/* if descriptor is a string qualifier, */
name|marksq
argument_list|(
name|cdesc
argument_list|)
expr_stmt|;
comment|/*   mark it for scollect */
elseif|else
if|if
condition|(
name|isptr
argument_list|(
name|cdesc
argument_list|)
condition|)
block|{
comment|/* ok, descriptor is a pointer */
name|block
operator|=
name|BLKLOC
argument_list|(
operator|*
name|cdesc
argument_list|)
expr_stmt|;
comment|/* get pointer to top of block */
if|if
condition|(
name|VAR
argument_list|(
operator|*
name|cdesc
argument_list|)
operator|&&
operator|!
name|TVAR
argument_list|(
operator|*
name|cdesc
argument_list|)
condition|)
comment|/* if variable, need offset */
name|block
operator|=
operator|(
name|int
operator|*
operator|)
name|block
operator|-
name|OFFSET
argument_list|(
operator|*
name|cdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|>=
name|hpbase
operator|&&
name|block
operator|<
name|hpfree
condition|)
block|{
comment|/* insure it points to heap */
name|type
operator|=
name|blktype
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|/* save type and end of block */
if|if
condition|(
name|type
operator|<=
name|MAXTYPE
condition|)
name|endblock
operator|=
name|block
operator|+
name|getsize
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BLKLOC
argument_list|(
operator|*
name|cdesc
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* add descriptor to back chain */
name|blktype
argument_list|(
name|block
argument_list|)
operator|=
name|cdesc
expr_stmt|;
comment|/* sweep descriptors in block */
if|if
condition|(
operator|(
name|type
operator|<=
name|MAXTYPE
operator|)
operator|&&
operator|(
operator|(
name|fdesc
operator|=
name|firstd
index|[
operator|(
name|int
operator|)
name|type
index|]
operator|)
operator|>
literal|0
operator|)
condition|)
for|for
control|(
name|ndesc
operator|=
name|block
operator|+
name|fdesc
init|;
name|ndesc
operator|<
name|endblock
condition|;
name|ndesc
operator|++
control|)
name|mark
argument_list|(
name|ndesc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|VAR
argument_list|(
operator|*
name|cdesc
argument_list|)
operator|&&
name|TYPE
argument_list|(
operator|*
name|cdesc
argument_list|)
operator|==
name|T_ESTACK
operator|&&
operator|(
name|char
operator|*
operator|)
name|blktype
argument_list|(
name|block
argument_list|)
operator|<=
name|MAXTYPE
condition|)
block|{
name|blktype
argument_list|(
name|block
argument_list|)
operator|=
name|cdesc
expr_stmt|;
comment|/* note block as visited */
name|sweep
argument_list|(
operator|(
operator|(
expr|struct
name|b_estack
operator|*
operator|)
name|block
operator|)
operator|->
name|boundary
argument_list|)
expr_stmt|;
name|mark
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|b_estack
operator|*
operator|)
name|block
operator|)
operator|->
name|activator
argument_list|)
expr_stmt|;
name|mark
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|b_estack
operator|*
operator|)
name|block
operator|)
operator|->
name|freshblk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * adjust - adjust pointers into heap, beginning with heapblock 'oblk'.  *   (Phase II of garbage collection)  */
end_comment

begin_macro
name|adjust
argument_list|(
argument|oblk
argument_list|,
argument|nblk
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|oblk
decl_stmt|,
modifier|*
name|nblk
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|descrip
modifier|*
name|nxtptr
decl_stmt|,
modifier|*
name|tptr
decl_stmt|;
while|while
condition|(
name|oblk
operator|<
name|hpfree
condition|)
block|{
comment|/* linear sweep through heap */
if|if
condition|(
operator|(
name|nxtptr
operator|=
name|blktype
argument_list|(
name|oblk
argument_list|)
operator|)
operator|>
name|MAXTYPE
condition|)
block|{
while|while
condition|(
operator|(
name|unsigned
operator|)
name|nxtptr
operator|>
name|MAXTYPE
condition|)
block|{
name|tptr
operator|=
name|nxtptr
expr_stmt|;
name|nxtptr
operator|=
name|BLKLOC
argument_list|(
operator|*
name|nxtptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|VAR
argument_list|(
operator|*
name|tptr
argument_list|)
operator|&&
operator|!
name|TVAR
argument_list|(
operator|*
name|tptr
argument_list|)
condition|)
name|BLKLOC
argument_list|(
operator|*
name|tptr
argument_list|)
operator|=
operator|(
name|int
operator|*
operator|)
name|nblk
operator|+
name|OFFSET
argument_list|(
operator|*
name|tptr
argument_list|)
expr_stmt|;
else|else
name|BLKLOC
argument_list|(
operator|*
name|tptr
argument_list|)
operator|=
name|nblk
expr_stmt|;
block|}
name|blktype
argument_list|(
name|oblk
argument_list|)
operator|=
operator|(
name|unsigned
operator|)
name|nxtptr
operator||
name|MARK
expr_stmt|;
name|nblk
operator|+=
name|getsize
argument_list|(
name|oblk
argument_list|)
expr_stmt|;
block|}
name|oblk
operator|+=
name|getsize
argument_list|(
name|oblk
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * compact - compact good blocks in heap, beginning with block 'oblk'.  *   (Phase III of garbage collection)  */
end_comment

begin_macro
name|compact
argument_list|(
argument|oblk
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|oblk
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|nblk
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
name|nblk
operator|=
name|oblk
expr_stmt|;
comment|/* linear sweep through heap */
while|while
condition|(
name|oblk
operator|<
name|hpfree
condition|)
block|{
name|size
operator|=
name|getsize
argument_list|(
name|oblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|blktype
argument_list|(
name|oblk
argument_list|)
operator|&
name|MARK
condition|)
block|{
comment|/* move good block */
name|blktype
argument_list|(
name|oblk
argument_list|)
operator|&=
operator|~
name|MARK
expr_stmt|;
comment|/* turn off mark */
if|if
condition|(
name|oblk
operator|!=
name|nblk
condition|)
name|mvc
argument_list|(
operator|(
name|unsigned
operator|)
name|size
argument_list|,
name|oblk
argument_list|,
name|nblk
argument_list|)
expr_stmt|;
name|nblk
operator|+=
name|size
expr_stmt|;
block|}
name|oblk
operator|+=
name|size
expr_stmt|;
block|}
name|hpfree
operator|=
name|nblk
expr_stmt|;
comment|/* reset free space pointer */
block|}
end_block

begin_comment
comment|/*  * marksq - mark a string qualifier.  If it points into the  * string space, put a pointer to it in the string qualifier  * list.  */
end_comment

begin_macro
name|marksq
argument_list|(
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|descrip
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|brk
parameter_list|()
function_decl|;
if|if
condition|(
name|STRLOC
argument_list|(
operator|*
name|d
argument_list|)
operator|>=
name|strings
operator|&&
name|STRLOC
argument_list|(
operator|*
name|d
argument_list|)
operator|<
name|estrings
condition|)
block|{
if|if
condition|(
name|sqfree
operator|>=
name|esqlist
condition|)
block|{
name|esqlist
operator|+=
name|SQLINC
expr_stmt|;
if|if
condition|(
name|brk
argument_list|(
name|esqlist
argument_list|)
condition|)
name|runerr
argument_list|(
literal|303
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|*
name|sqfree
operator|++
operator|=
name|d
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * scollect - collect the string space.  * A list of string qualifiers points to all valid strings.  */
end_comment

begin_macro
name|scollect
argument_list|(
argument|extra
argument_list|)
end_macro

begin_decl_stmt
name|int
name|extra
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
specifier|register
name|struct
name|descrip
modifier|*
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
specifier|extern
name|int
name|sqcmp
parameter_list|()
function_decl|;
if|if
condition|(
name|sqfree
operator|<=
name|sqlist
condition|)
block|{
name|sfree
operator|=
name|strings
expr_stmt|;
return|return;
block|}
name|qsort
argument_list|(
name|sqlist
argument_list|,
name|sqfree
operator|-
name|sqlist
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|descrip
operator|*
argument_list|)
argument_list|,
name|sqcmp
argument_list|)
expr_stmt|;
name|d
operator|=
name|strings
expr_stmt|;
name|s
operator|=
name|e
operator|=
name|STRLOC
argument_list|(
operator|*
operator|*
name|sqlist
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sqlist
init|;
name|p
operator|<
name|sqfree
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|>
name|e
condition|)
block|{
comment|/* outside last clump */
while|while
condition|(
name|s
operator|<
name|e
condition|)
comment|/* move the clump */
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|e
operator|=
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
expr_stmt|;
comment|/* start a new clump */
block|}
if|if
condition|(
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|+
name|STRLEN
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|>
name|e
condition|)
comment|/* extend the clump */
name|e
operator|=
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|+
name|STRLEN
argument_list|(
operator|*
operator|*
name|p
argument_list|)
expr_stmt|;
name|STRLOC
argument_list|(
operator|*
operator|*
name|p
argument_list|)
operator|+=
name|d
operator|-
name|s
operator|+
name|extra
expr_stmt|;
comment|/* relocate the string qualifier */
block|}
while|while
condition|(
name|s
operator|<
name|e
condition|)
comment|/* move the last clump */
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|sfree
operator|=
name|d
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * sqcmp - compare the location fields of two string qualifiers for qsort.  */
end_comment

begin_macro
name|sqcmp
argument_list|(
argument|q1
argument_list|,
argument|q2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|descrip
modifier|*
modifier|*
name|q1
decl_stmt|,
modifier|*
modifier|*
name|q2
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|STRLOC
argument_list|(
operator|*
operator|*
name|q1
argument_list|)
operator|-
name|STRLOC
argument_list|(
operator|*
operator|*
name|q2
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * mvc - move n bytes from src to dst.  * src and dst must be at word boundaries.  */
end_comment

begin_macro
name|mvc
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|words
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|words
operator|=
name|n
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|n
operator|%
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|s
condition|)
block|{
comment|/* move back */
while|while
condition|(
operator|--
name|words
operator|>=
literal|0
condition|)
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|d
operator|)
operator|++
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|s
operator|)
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|bytes
operator|>=
literal|0
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|>
name|s
condition|)
block|{
comment|/* move forward */
name|s
operator|+=
name|n
expr_stmt|;
name|d
operator|+=
name|n
expr_stmt|;
while|while
condition|(
operator|--
name|bytes
operator|>=
literal|0
condition|)
operator|*
operator|--
name|d
operator|=
operator|*
operator|--
name|s
expr_stmt|;
while|while
condition|(
operator|--
name|words
operator|>=
literal|0
condition|)
operator|*
operator|--
operator|(
name|int
operator|*
operator|)
name|d
operator|=
operator|*
operator|--
operator|(
name|int
operator|*
operator|)
name|s
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|PDP11
end_endif

end_unit

