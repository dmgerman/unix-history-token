begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"ulink.h"
end_include

begin_include
include|#
directive|include
file|"code.h"
end_include

begin_include
include|#
directive|include
file|"opcode.h"
end_include

begin_include
include|#
directive|include
file|"datatype.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VAX
end_ifdef

begin_decl_stmt
name|int
name|nproc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of procedures encountered */
end_comment

begin_comment
comment|/*  * gencode - read .ucode file, resolve variable references,  * and generate assembler code.  */
end_comment

begin_macro
name|gencode
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|op
decl_stmt|,
name|k
decl_stmt|,
name|lab
decl_stmt|;
name|int
name|j
decl_stmt|,
name|nargs
decl_stmt|,
name|flags
decl_stmt|,
name|implicit
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|procname
decl_stmt|;
name|struct
name|centry
modifier|*
name|cp
decl_stmt|;
name|struct
name|gentry
modifier|*
name|gp
decl_stmt|;
name|struct
name|fentry
modifier|*
name|fp
decl_stmt|;
specifier|extern
name|long
name|getint
parameter_list|()
function_decl|;
specifier|extern
name|double
name|getreal
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|getid
argument_list|()
decl_stmt|,
modifier|*
name|getstrlit
argument_list|()
decl_stmt|;
specifier|extern
name|struct
name|gentry
modifier|*
name|glocate
parameter_list|()
function_decl|;
while|while
condition|(
operator|(
name|op
operator|=
name|getop
argument_list|(
operator|&
name|name
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_TOBY
case|:
comment|/* ternary operators */
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|3
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SECT
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHN
argument_list|,
name|C_CALL
argument_list|,
literal|4
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ASGN
case|:
comment|/* binary operators */
case|case
name|OP_CAT
case|:
case|case
name|OP_DIFF
case|:
case|case
name|OP_DIV
case|:
case|case
name|OP_EQV
case|:
case|case
name|OP_INTER
case|:
case|case
name|OP_LCONCAT
case|:
case|case
name|OP_LEXEQ
case|:
case|case
name|OP_LEXGE
case|:
case|case
name|OP_LEXGT
case|:
case|case
name|OP_LEXLE
case|:
case|case
name|OP_LEXLT
case|:
case|case
name|OP_LEXNE
case|:
case|case
name|OP_MINUS
case|:
case|case
name|OP_MOD
case|:
case|case
name|OP_MULT
case|:
case|case
name|OP_NEQV
case|:
case|case
name|OP_NUMEQ
case|:
case|case
name|OP_NUMGE
case|:
case|case
name|OP_NUMGT
case|:
case|case
name|OP_NUMLE
case|:
case|case
name|OP_NUMLT
case|:
case|case
name|OP_NUMNE
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_POWER
case|:
case|case
name|OP_RASGN
case|:
case|case
name|OP_UNIONCS
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|2
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RSWAP
case|:
case|case
name|OP_SUBSC
case|:
case|case
name|OP_SWAP
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHN
argument_list|,
name|C_CALL
argument_list|,
literal|3
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_COMPL
case|:
comment|/* unary operators */
case|case
name|OP_NEG
case|:
case|case
name|OP_NONNULL
case|:
case|case
name|OP_NULL
case|:
case|case
name|OP_NUMBER
case|:
case|case
name|OP_REFRESH
case|:
case|case
name|OP_SIZE
case|:
case|case
name|OP_VALUE
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|1
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BANG
case|:
case|case
name|OP_RANDOM
case|:
case|case
name|OP_TABMAT
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHN
argument_list|,
name|C_CALL
argument_list|,
literal|2
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BSCAN
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_MOVQ
argument_list|,
literal|"_k_subject"
argument_list|,
literal|"-(sp)"
argument_list|,
name|C_PUSH
argument_list|,
literal|"_k_pos"
argument_list|,
name|C_PUSHI
argument_list|,
name|D_INTEGER
argument_list|,
name|C_CALL
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CCASE
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHN
argument_list|,
name|C_MOVQ
argument_list|,
literal|"4(r11)"
argument_list|,
literal|"-(sp)"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CHFAIL
case|:
name|lab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_MOVL
argument_list|,
name|lab
argument_list|,
name|n
argument_list|,
literal|"-8(r11)"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_COACT
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|1
argument_list|,
literal|"coact"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_COFAIL
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|0
argument_list|,
literal|"cofail"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CORET
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|0
argument_list|,
literal|"coret"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CREATE
case|:
name|lab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHL
argument_list|,
name|lab
argument_list|,
name|n
argument_list|,
name|C_PUSHI
argument_list|,
name|D_INTEGER
argument_list|,
name|C_CALL
argument_list|,
literal|0
argument_list|,
literal|"create"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CSET
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|cp
operator|=
operator|&
name|ctable
index|[
name|k
index|]
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHC
argument_list|,
name|k
argument_list|,
name|nproc
argument_list|,
name|C_PUSHI
argument_list|,
name|D_CSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_DUP
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHN
argument_list|,
name|C_MOVQ
argument_list|,
literal|"8(sp)"
argument_list|,
literal|"-(sp)"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_EFAIL
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALLJ
argument_list|,
literal|0
argument_list|,
literal|"efail"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ERET
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_MOVQ
argument_list|,
literal|"(sp)+"
argument_list|,
literal|"r0"
argument_list|,
name|C_MOV
argument_list|,
literal|"-4(r11)"
argument_list|,
literal|"r10"
argument_list|,
name|C_MOV
argument_list|,
literal|"r11"
argument_list|,
literal|"sp"
argument_list|,
name|C_POP
argument_list|,
literal|"r11"
argument_list|,
name|C_MOVQ
argument_list|,
literal|"r0"
argument_list|,
literal|"-(sp)"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ESCAN
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|3
argument_list|,
literal|"escan"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ESUSP
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|1
argument_list|,
literal|"esusp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_FIELD
case|:
name|id
operator|=
name|getid
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|fp
operator|=
name|flocate
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
name|id
argument_list|,
literal|"invalid field name"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|emit
argument_list|(
name|C_PUSHI
argument_list|,
name|fp
operator|->
name|f_fid
argument_list|,
name|C_PUSHI
argument_list|,
name|D_INTEGER
argument_list|,
name|C_CALL
argument_list|,
literal|2
argument_list|,
literal|"field"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_FILE
case|:
name|file
operator|=
name|getid
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_MOVA
argument_list|,
literal|"ident"
argument_list|,
name|file
operator|-
name|strings
argument_list|,
literal|"_file"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_GOTO
case|:
name|lab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_JUMP
argument_list|,
literal|"br"
argument_list|,
name|lab
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_INCRES
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_MOV
argument_list|,
literal|"_current+4"
argument_list|,
literal|"r0"
argument_list|,
name|C_MISC
argument_list|,
literal|"incl"
argument_list|,
literal|"28(r0)"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_INIT
case|:
name|lab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_INIT
argument_list|,
name|nproc
argument_list|,
name|lab
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_INT
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|cp
operator|=
operator|&
name|ctable
index|[
name|k
index|]
expr_stmt|;
ifndef|#
directive|ifndef
name|VAX
if|if
condition|(
name|cp
operator|->
name|c_flag
operator|&
name|F_LONGLIT
condition|)
name|emit
argument_list|(
name|C_PUSHC
argument_list|,
name|k
argument_list|,
name|nproc
argument_list|,
name|C_PUSHI
argument_list|,
name|D_LONGINT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|emit
argument_list|(
name|C_PUSHI
argument_list|,
operator|(
name|int
operator|)
name|cp
operator|->
name|c_val
operator|.
name|ival
argument_list|,
name|C_PUSHI
argument_list|,
name|D_INTEGER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_INVOKE
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
name|k
argument_list|,
literal|"invoke"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_KEYWD
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHI
argument_list|,
name|k
argument_list|,
name|C_PUSHI
argument_list|,
name|D_INTEGER
argument_list|,
name|C_CALL
argument_list|,
literal|0
argument_list|,
literal|"keywd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LAB
case|:
name|lab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_LABEL
argument_list|,
name|lab
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LIMIT
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|0
argument_list|,
literal|"limit"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LINE
case|:
name|line
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_MOVI
argument_list|,
name|line
argument_list|,
literal|"_line"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LLIST
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
name|k
argument_list|,
literal|"llist"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LSUSP
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|0
argument_list|,
literal|"lsusp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_MARK
case|:
name|lab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSH
argument_list|,
literal|"r11"
argument_list|,
name|C_MOV
argument_list|,
literal|"sp"
argument_list|,
literal|"r11"
argument_list|,
name|C_PUSH
argument_list|,
literal|"r10"
argument_list|,
name|C_CLR
argument_list|,
literal|"r10"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lab
operator|!=
literal|0
condition|)
name|emit
argument_list|(
name|C_PUSHL
argument_list|,
name|lab
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|emit
argument_list|(
name|C_PUSHZ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_PFAIL
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALLJ
argument_list|,
literal|0
argument_list|,
literal|"pfail"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_PNULL
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_POP
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_MISC
argument_list|,
literal|"addl2"
argument_list|,
literal|"$8,sp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_PRET
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|1
argument_list|,
literal|"pret"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_PSUSP
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|0
argument_list|,
literal|"psusp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_PUSH1
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHI
argument_list|,
literal|1
argument_list|,
name|C_PUSHI
argument_list|,
name|D_INTEGER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_PUSHN1
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHI
argument_list|,
operator|-
literal|1
argument_list|,
name|C_PUSHI
argument_list|,
name|D_INTEGER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_REAL
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHC
argument_list|,
name|k
argument_list|,
name|nproc
argument_list|,
name|C_PUSHI
argument_list|,
name|D_REAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SDUP
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_MOVQ
argument_list|,
literal|"(sp)"
argument_list|,
literal|"-(sp)"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_STR
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|id
operator|=
name|ctable
index|[
name|k
index|]
operator|.
name|c_val
operator|.
name|sval
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHA
argument_list|,
literal|"ident"
argument_list|,
name|id
operator|-
name|strings
argument_list|,
name|C_PUSHI
argument_list|,
name|ctable
index|[
name|k
index|]
operator|.
name|c_length
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_UNMARK
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
while|while
condition|(
name|k
operator|--
operator|>
literal|1
condition|)
name|emit
argument_list|(
name|C_MOV
argument_list|,
literal|"(r11)"
argument_list|,
literal|"r11"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit
argument_list|(
name|C_MOV
argument_list|,
literal|"-4(r11)"
argument_list|,
literal|"r10"
argument_list|,
name|C_MOV
argument_list|,
literal|"r11"
argument_list|,
literal|"sp"
argument_list|,
name|C_POP
argument_list|,
literal|"r11"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_VAR
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|=
name|ltable
index|[
name|k
index|]
operator|.
name|l_flag
operator|)
operator|&
name|F_GLOBAL
condition|)
name|emit
argument_list|(
name|C_PUSHA
argument_list|,
literal|"globals"
argument_list|,
literal|2
operator|*
name|BYTES
operator|*
operator|(
name|ltable
index|[
name|k
index|]
operator|.
name|l_val
operator|.
name|global
operator|-
name|gtable
operator|)
argument_list|,
name|C_PUSHI
argument_list|,
name|D_VAR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_STATIC
condition|)
name|emit
argument_list|(
name|C_PUSHA
argument_list|,
literal|"statics"
argument_list|,
literal|2
operator|*
name|BYTES
operator|*
operator|(
name|ltable
index|[
name|k
index|]
operator|.
name|l_val
operator|.
name|staticid
operator|-
literal|1
operator|)
argument_list|,
name|C_PUSHI
argument_list|,
name|D_VAR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_ARGUMENT
condition|)
name|emit
argument_list|(
name|C_PUSHIN
argument_list|,
literal|2
operator|*
name|BYTES
operator|+
literal|2
operator|*
name|BYTES
operator|*
operator|(
name|nargs
operator|-
name|ltable
index|[
name|k
index|]
operator|.
name|l_val
operator|.
name|offset
operator|)
argument_list|,
literal|"ap"
argument_list|,
name|C_PUSHI
argument_list|,
name|D_VAR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|emit
argument_list|(
name|C_PUSHIN
argument_list|,
operator|-
literal|2
operator|*
name|BYTES
operator|-
literal|2
operator|*
name|BYTES
operator|*
name|ltable
index|[
name|k
index|]
operator|.
name|l_val
operator|.
name|offset
argument_list|,
literal|"fp"
argument_list|,
name|C_PUSHI
argument_list|,
name|D_VAR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_PROC
case|:
name|locinit
argument_list|()
expr_stmt|;
name|line
operator|=
literal|0
expr_stmt|;
name|procname
operator|=
name|getid
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|gp
operator|=
name|glocate
argument_list|(
name|procname
argument_list|)
expr_stmt|;
name|implicit
operator|=
name|gp
operator|->
name|g_flag
operator|&
name|F_IMPERROR
expr_stmt|;
name|nargs
operator|=
name|gp
operator|->
name|g_nargs
expr_stmt|;
name|gp
operator|->
name|g_procid
operator|=
operator|++
name|nproc
expr_stmt|;
break|break;
case|case
name|OP_LOCAL
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|flags
operator|=
name|getoct
argument_list|()
expr_stmt|;
name|id
operator|=
name|getid
argument_list|()
expr_stmt|;
name|putloc
argument_list|(
name|k
argument_list|,
name|id
argument_list|,
name|flags
argument_list|,
name|implicit
argument_list|,
name|procname
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CON
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|flags
operator|=
name|getoct
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|F_INTLIT
condition|)
name|putconst
argument_list|(
name|k
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
name|getint
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_REALLIT
condition|)
name|putconst
argument_list|(
name|k
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
name|getreal
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_STRLIT
condition|)
block|{
name|j
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|putconst
argument_list|(
name|k
argument_list|,
name|flags
argument_list|,
name|j
argument_list|,
name|getstrlit
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_CSETLIT
condition|)
block|{
name|j
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|putconst
argument_list|(
name|k
argument_list|,
name|flags
argument_list|,
name|j
argument_list|,
name|getstrlit
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencode: illegal constant\n"
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
break|break;
case|case
name|OP_DECLEND
case|:
name|newline
argument_list|()
expr_stmt|;
name|emitproc
argument_list|(
name|nproc
argument_list|,
name|procname
argument_list|,
name|nargs
argument_list|,
name|dynoff
argument_list|,
name|statics
operator|-
name|static1
argument_list|,
name|static1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_END
case|:
name|newline
argument_list|()
expr_stmt|;
name|procend
argument_list|()
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencode: illegal opcode(%d): %s\n"
argument_list|,
name|op
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * emit - emit assembler code to outfile.  This routine  * takes a variable number of arguments.  Each group of  * arguments begins with a template number, which selects  * one of the fprintf statements below.  Following the  * template number is zero or more parameters to that  * template.  */
end_comment

begin_macro
name|emit
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
union|union
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|integ
decl_stmt|;
block|}
modifier|*
name|ap
union|;
name|int
name|sp_incr
decl_stmt|;
name|int
name|r0save
init|=
literal|0
decl_stmt|;
name|ap
operator|=
operator|&
name|a
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|ap
operator|)
operator|.
name|integ
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|ap
operator|++
operator|)
operator|.
name|integ
condition|)
block|{
case|case
name|C_PUSH
case|:
comment|/* push something on the stack */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tpushl\t%s\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|++
expr_stmt|;
break|break;
case|case
name|C_PUSHI
case|:
comment|/* push an immediate on the stack */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tpushl\t$0x%x\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|ap
operator|++
expr_stmt|;
break|break;
case|case
name|C_PUSHIN
case|:
comment|/* push an indexed value onto the stack */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tpushab\t%d(%s)\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|C_PUSHN
case|:
comment|/* push a null descriptor on the stack */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tclrq\t-(sp)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_PUSHZ
case|:
comment|/* push a zero on the stack */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tpushl\t$0\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_PUSHR
case|:
comment|/* push registers */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tpushr\t$0x%x\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|ap
operator|++
expr_stmt|;
break|break;
case|case
name|C_PUSHA
case|:
comment|/* push an address on the stack */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tpushal\t_%s+%d\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|str
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|C_PUSHC
case|:
comment|/* push the address of a constant */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tpushl\t$C%dP%d\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|C_PUSHL
case|:
comment|/* push an label on the stack */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tpushl\t$L%dF%d\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|C_POP
case|:
comment|/* pop the stack into some location */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tmovl\t(sp)+,%s\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|++
expr_stmt|;
break|break;
case|case
name|C_MOV
case|:
comment|/* move one location to another */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tmovl\t%s,%s\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|str
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|C_MOVQ
case|:
comment|/* move a quadword */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tmovq\t%s,%s\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|str
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|C_MOVI
case|:
comment|/* move an immediate to some location */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tmovl\t$%d,%s\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|C_MOVL
case|:
comment|/* move a label to some location */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tmovl\t$L%dF%d,%s\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|2
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|C_MOVA
case|:
comment|/* move an address to some location */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tmoval\t_%s+%d,%s\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|str
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|2
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|C_CLR
case|:
comment|/* clr a word */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tclrl\t%s\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|++
expr_stmt|;
break|break;
case|case
name|C_ADDTOP
case|:
comment|/* add an immediate to the top of stack */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\taddl\t$%d,(sp)\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|ap
operator|++
expr_stmt|;
break|break;
case|case
name|C_INIT
case|:
comment|/* test initial flag of procedure */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tjbss\t$0,P%dI,L%dF%d\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|2
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|C_CALLJ
case|:
comment|/* jump to a subroutine */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tpushl\t$%d\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tjmp\t_%s\n"
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|C_CALL
case|:
comment|/* call a subroutine */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tpushl\t$%d\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tcalls\t$%d,_%s\n"
argument_list|,
literal|1
operator|+
literal|2
operator|*
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|C_JUMP
case|:
comment|/* conditional jump to a local label */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tj%s\tL%dF%d\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|str
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|2
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|C_LABEL
case|:
comment|/* place a local label */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"L%dF%d:\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|C_MISC
case|:
comment|/* miscellaneous */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%s\t%s\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|str
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"emit: illegal template number"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * emitproc - emit code for procedure block #n.  */
end_comment

begin_macro
name|emitproc
argument_list|(
argument|n
argument_list|,
argument|name
argument_list|,
argument|nargs
argument_list|,
argument|ndyn
argument_list|,
argument|nstat
argument_list|,
argument|fstat
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nargs
decl_stmt|,
name|ndyn
decl_stmt|,
name|nstat
decl_stmt|,
name|fstat
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".data\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"P%d:\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|T_PROC
argument_list|)
expr_stmt|;
comment|/* type code */
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
comment|/* size of block */
literal|9
operator|*
name|BYTES
operator|+
literal|2
operator|*
name|BYTES
operator|*
operator|(
name|nargs
operator|+
name|ndyn
operator|+
name|nstat
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t.long\tI%d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* entry point */
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
comment|/* # arguments */
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|ndyn
argument_list|)
expr_stmt|;
comment|/* # dynamic locals */
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|nstat
argument_list|)
expr_stmt|;
comment|/* # static locals */
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|fstat
argument_list|)
expr_stmt|;
comment|/* first static */
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|nameformat
argument_list|,
comment|/* qualifiers */
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
operator|-
name|strings
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nlocal
condition|;
name|i
operator|++
control|)
block|{
comment|/* names of arguments */
if|if
condition|(
name|ltable
index|[
name|i
index|]
operator|.
name|l_flag
operator|&
name|F_ARGUMENT
condition|)
block|{
name|p
operator|=
name|ltable
index|[
name|i
index|]
operator|.
name|l_name
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|nameformat
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
operator|-
name|strings
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nlocal
condition|;
name|i
operator|++
control|)
block|{
comment|/* names of dynamic locals */
if|if
condition|(
name|ltable
index|[
name|i
index|]
operator|.
name|l_flag
operator|&
name|F_DYNAMIC
condition|)
block|{
name|p
operator|=
name|ltable
index|[
name|i
index|]
operator|.
name|l_name
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|nameformat
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
operator|-
name|strings
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nlocal
condition|;
name|i
operator|++
control|)
block|{
comment|/* names of static locals */
if|if
condition|(
name|ltable
index|[
name|i
index|]
operator|.
name|l_flag
operator|&
name|F_STATIC
condition|)
block|{
name|p
operator|=
name|ltable
index|[
name|i
index|]
operator|.
name|l_name
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|nameformat
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
operator|-
name|strings
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"P%dI:\t.long 0\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* initial flag */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".text\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"I%d:\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * procend - emit constant table at end of procedure.  */
end_comment

begin_macro
name|procend
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|csbuf
index|[
name|CSETSIZE
index|]
decl_stmt|;
union|union
block|{
name|unsigned
name|int
name|i
index|[
literal|4
index|]
decl_stmt|;
name|long
name|int
name|l
decl_stmt|;
name|double
name|f
decl_stmt|;
block|}
name|x
union|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".data\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|nconst
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|ctable
index|[
name|k
index|]
operator|.
name|c_flag
operator|&
name|F_REALLIT
condition|)
block|{
name|x
operator|.
name|f
operator|=
name|ctable
index|[
name|k
index|]
operator|.
name|c_val
operator|.
name|rval
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"C%dP%d:"
argument_list|,
name|k
argument_list|,
name|nproc
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|T_REAL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|x
operator|.
name|i
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|x
operator|.
name|i
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|x
operator|.
name|i
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|x
operator|.
name|i
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t# %g\n"
argument_list|,
name|x
operator|.
name|f
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctable
index|[
name|k
index|]
operator|.
name|c_flag
operator|&
name|F_LONGLIT
condition|)
block|{
name|x
operator|.
name|l
operator|=
name|ctable
index|[
name|k
index|]
operator|.
name|c_val
operator|.
name|ival
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"C%dP%d:"
argument_list|,
name|k
argument_list|,
name|nproc
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|T_LONGINT
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|x
operator|.
name|i
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|x
operator|.
name|i
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t# %ld\n"
argument_list|,
name|x
operator|.
name|l
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctable
index|[
name|k
index|]
operator|.
name|c_flag
operator|&
name|F_CSETLIT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CSETSIZE
condition|;
name|i
operator|++
control|)
name|csbuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|ctable
index|[
name|k
index|]
operator|.
name|c_val
operator|.
name|sval
expr_stmt|;
name|i
operator|=
name|ctable
index|[
name|k
index|]
operator|.
name|c_length
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|setb
argument_list|(
operator|*
name|s
argument_list|,
name|csbuf
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"C%dP%d:"
argument_list|,
name|k
argument_list|,
name|nproc
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|T_CSET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CSETSIZE
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|csbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".text\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * gentables - generate assembler code for global, static,  * identifier, and record tables, and built-in procedure blocks.  */
end_comment

begin_macro
name|gentables
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|gentry
modifier|*
name|gp
decl_stmt|;
name|int
name|j
decl_stmt|;
name|struct
name|fentry
modifier|*
name|fp
decl_stmt|;
name|struct
name|rentry
modifier|*
name|rp
decl_stmt|;
comment|/* output record constructor procedure blocks */
for|for
control|(
name|gp
operator|=
name|gtable
init|;
name|gp
operator|<
name|gfree
condition|;
name|gp
operator|++
control|)
block|{
if|if
condition|(
name|gp
operator|->
name|g_flag
operator|&
operator|(
name|F_RECORD
operator|&
operator|~
name|F_GLOBAL
operator|)
condition|)
block|{
name|s
operator|=
name|gp
operator|->
name|g_name
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".data\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"R%d:"
argument_list|,
name|gp
operator|->
name|g_procid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|T_PROC
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
literal|9
operator|*
name|BYTES
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t.long\t_mkrec+2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|gp
operator|->
name|g_nargs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|gp
operator|->
name|g_procid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|nameformat
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
name|s
operator|-
name|strings
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".text\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* output record/field tables */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".data\n"
argument_list|)
expr_stmt|;
name|j
operator|=
name|ffree
operator|-
name|ftable
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|ftable
init|;
name|fp
operator|<
name|ffree
condition|;
name|fp
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"F%d:"
argument_list|,
name|fp
operator|->
name|f_fid
argument_list|)
expr_stmt|;
name|rp
operator|=
name|fp
operator|->
name|f_rlist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nrecords
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rp
operator|!=
name|NULL
operator|&&
name|rp
operator|->
name|r_recid
operator|==
name|i
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|rp
operator|->
name|r_fnum
argument_list|)
expr_stmt|;
name|rp
operator|=
name|rp
operator|->
name|r_link
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|nrecords
operator|||
operator|(
name|i
operator|&
literal|03
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".globl\t_ftab\n_ftab:\t.long %d\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|j
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t.long F%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|j
operator|||
operator|(
name|i
operator|&
literal|03
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
block|}
comment|/* output global declarations */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".globl\t_globals\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".globl\t_eglobals\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".globl\t_gnames\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".globl\t_egnames\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".globl\t_statics\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".globl\t_estatics\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".globl\t_ident\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".globl\t_eident\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".globl\t_k_trace\n_k_trace:"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|iformat
argument_list|,
name|trace
argument_list|)
expr_stmt|;
comment|/* output global variables */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n_globals:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|gtable
init|;
name|gp
operator|<
name|gfree
condition|;
name|gp
operator|++
control|)
block|{
if|if
condition|(
name|gp
operator|->
name|g_flag
operator|&
operator|(
name|F_BUILTIN
operator|&
operator|~
name|F_GLOBAL
operator|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t.long\t%d,_B%s\t# %s\n"
argument_list|,
name|D_PROC
argument_list|,
name|gp
operator|->
name|g_name
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gp
operator|->
name|g_flag
operator|&
operator|(
name|F_PROC
operator|&
operator|~
name|F_GLOBAL
operator|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t.long \t%d,P%d\t# %s\n"
argument_list|,
name|D_PROC
argument_list|,
name|gp
operator|->
name|g_procid
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gp
operator|->
name|g_flag
operator|&
operator|(
name|F_RECORD
operator|&
operator|~
name|F_GLOBAL
operator|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t.long\t%d,R%d\t# %s\n"
argument_list|,
name|D_PROC
argument_list|,
name|gp
operator|->
name|g_procid
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t.long\t0,0\t# %s\n"
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"_eglobals:\n"
argument_list|)
expr_stmt|;
comment|/* output names of global variables */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"_gnames:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|gtable
init|;
name|gp
operator|<
name|gfree
condition|;
name|gp
operator|++
control|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|nameformat
argument_list|,
name|strlen
argument_list|(
name|gp
operator|->
name|g_name
argument_list|)
argument_list|,
name|gp
operator|->
name|g_name
operator|-
name|strings
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"_egnames:\n"
argument_list|)
expr_stmt|;
comment|/* output static variables */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"_statics:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|statics
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t.long\t0,0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"_estatics:\n"
argument_list|)
expr_stmt|;
comment|/* output identifier table */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"_ident:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|strings
init|;
name|s
operator|<
name|sfree
condition|;
control|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t.byte\t0%03o"
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|s
operator|>=
name|sfree
condition|)
break|break;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|",0%03o"
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".align\t2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"_eident:\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|VAX
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PDP11
end_ifdef

begin_decl_stmt
name|int
name|nproc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of procedures encountered */
end_comment

begin_comment
comment|/*  * gencode - read .ucode file, resolve variable references,  * and generate assembler code.  */
end_comment

begin_macro
name|gencode
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|op
decl_stmt|,
name|k
decl_stmt|,
name|lab
decl_stmt|;
name|int
name|j
decl_stmt|,
name|nargs
decl_stmt|,
name|flags
decl_stmt|,
name|implicit
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|procname
decl_stmt|;
name|struct
name|centry
modifier|*
name|cp
decl_stmt|;
name|struct
name|gentry
modifier|*
name|gp
decl_stmt|;
name|struct
name|fentry
modifier|*
name|fp
decl_stmt|;
specifier|extern
name|long
name|getint
parameter_list|()
function_decl|;
specifier|extern
name|double
name|getreal
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|getid
argument_list|()
decl_stmt|,
modifier|*
name|getstrlit
argument_list|()
decl_stmt|;
specifier|extern
name|struct
name|gentry
modifier|*
name|glocate
parameter_list|()
function_decl|;
while|while
condition|(
operator|(
name|op
operator|=
name|getop
argument_list|(
operator|&
name|name
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_TOBY
case|:
comment|/* ternary operators */
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|3
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SECT
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHZ
argument_list|,
name|C_PUSHZ
argument_list|,
name|C_CALL
argument_list|,
literal|4
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ASGN
case|:
comment|/* binary operators */
case|case
name|OP_CAT
case|:
case|case
name|OP_DIFF
case|:
case|case
name|OP_DIV
case|:
case|case
name|OP_EQV
case|:
case|case
name|OP_INTER
case|:
case|case
name|OP_LCONCAT
case|:
case|case
name|OP_LEXEQ
case|:
case|case
name|OP_LEXGE
case|:
case|case
name|OP_LEXGT
case|:
case|case
name|OP_LEXLE
case|:
case|case
name|OP_LEXLT
case|:
case|case
name|OP_LEXNE
case|:
case|case
name|OP_MINUS
case|:
case|case
name|OP_MOD
case|:
case|case
name|OP_MULT
case|:
case|case
name|OP_NEQV
case|:
case|case
name|OP_NUMEQ
case|:
case|case
name|OP_NUMGE
case|:
case|case
name|OP_NUMGT
case|:
case|case
name|OP_NUMLE
case|:
case|case
name|OP_NUMLT
case|:
case|case
name|OP_NUMNE
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_POWER
case|:
case|case
name|OP_RASGN
case|:
case|case
name|OP_UNIONCS
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|2
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_RSWAP
case|:
case|case
name|OP_SUBSC
case|:
case|case
name|OP_SWAP
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHZ
argument_list|,
name|C_PUSHZ
argument_list|,
name|C_CALL
argument_list|,
literal|3
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_COMPL
case|:
comment|/* unary operators */
case|case
name|OP_NEG
case|:
case|case
name|OP_NONNULL
case|:
case|case
name|OP_NULL
case|:
case|case
name|OP_NUMBER
case|:
case|case
name|OP_REFRESH
case|:
case|case
name|OP_SIZE
case|:
case|case
name|OP_VALUE
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|1
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BANG
case|:
case|case
name|OP_RANDOM
case|:
case|case
name|OP_TABMAT
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHZ
argument_list|,
name|C_PUSHZ
argument_list|,
name|C_CALL
argument_list|,
literal|2
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_BSCAN
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSH
argument_list|,
literal|"_k_subject+2"
argument_list|,
name|C_PUSH
argument_list|,
literal|"_k_subject"
argument_list|,
name|C_PUSH
argument_list|,
literal|"_k_pos"
argument_list|,
name|C_PUSHI
argument_list|,
name|D_INTEGER
argument_list|,
name|C_CALL
argument_list|,
literal|0
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CCASE
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHZ
argument_list|,
name|C_PUSHZ
argument_list|,
name|C_PUSH
argument_list|,
literal|"4(r4)"
argument_list|,
name|C_PUSH
argument_list|,
literal|"2(r4)"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CHFAIL
case|:
name|lab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_MOVL
argument_list|,
name|lab
argument_list|,
name|n
argument_list|,
literal|"-4(r4)"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_COACT
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|1
argument_list|,
literal|"coact"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_COFAIL
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|0
argument_list|,
literal|"cofail"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CORET
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|0
argument_list|,
literal|"coret"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CREATE
case|:
name|lab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHL
argument_list|,
name|lab
argument_list|,
name|n
argument_list|,
name|C_PUSHI
argument_list|,
name|D_INTEGER
argument_list|,
name|C_CALL
argument_list|,
literal|0
argument_list|,
literal|"create"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CSET
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|cp
operator|=
operator|&
name|ctable
index|[
name|k
index|]
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHC
argument_list|,
name|k
argument_list|,
name|nproc
argument_list|,
name|C_PUSHI
argument_list|,
name|D_CSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_DUP
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHZ
argument_list|,
name|C_PUSHZ
argument_list|,
name|C_PUSH
argument_list|,
literal|"6(sp)"
argument_list|,
name|C_PUSH
argument_list|,
literal|"6(sp)"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_EFAIL
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|0
argument_list|,
literal|"efail"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ERET
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_POP
argument_list|,
literal|"r0"
argument_list|,
name|C_POP
argument_list|,
literal|"r1"
argument_list|,
name|C_MOV
argument_list|,
literal|"-2(r4)"
argument_list|,
literal|"r3"
argument_list|,
name|C_MOV
argument_list|,
literal|"r4"
argument_list|,
literal|"sp"
argument_list|,
name|C_POP
argument_list|,
literal|"r4"
argument_list|,
name|C_PUSH
argument_list|,
literal|"r1"
argument_list|,
name|C_PUSH
argument_list|,
literal|"r0"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ESCAN
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|3
argument_list|,
literal|"escan"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ESUSP
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|1
argument_list|,
literal|"esusp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_FIELD
case|:
name|id
operator|=
name|getid
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|fp
operator|=
name|flocate
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
name|id
argument_list|,
literal|"invalid field name"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|emit
argument_list|(
name|C_PUSHI
argument_list|,
name|fp
operator|->
name|f_fid
argument_list|,
name|C_PUSHI
argument_list|,
name|D_INTEGER
argument_list|,
name|C_CALL
argument_list|,
literal|2
argument_list|,
literal|"field"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_FILE
case|:
name|file
operator|=
name|getid
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_MOVA
argument_list|,
literal|"ident"
argument_list|,
name|file
operator|-
name|strings
argument_list|,
literal|"_file"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_GOTO
case|:
name|lab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_JUMP
argument_list|,
literal|"br"
argument_list|,
name|lab
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_INCRES
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_MOV
argument_list|,
literal|"_current+2"
argument_list|,
literal|"r0"
argument_list|,
name|C_MISC
argument_list|,
literal|"inc"
argument_list|,
literal|"14.(r0)"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_INIT
case|:
name|lab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_INIT
argument_list|,
name|nproc
argument_list|,
name|lab
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_INT
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|cp
operator|=
operator|&
name|ctable
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|c_flag
operator|&
name|F_LONGLIT
condition|)
name|emit
argument_list|(
name|C_PUSHC
argument_list|,
name|k
argument_list|,
name|nproc
argument_list|,
name|C_PUSHI
argument_list|,
name|D_LONGINT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|emit
argument_list|(
name|C_PUSHI
argument_list|,
operator|(
name|int
operator|)
name|cp
operator|->
name|c_val
operator|.
name|ival
argument_list|,
name|C_PUSHI
argument_list|,
name|D_INTEGER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_INVOKE
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
name|k
argument_list|,
literal|"invoke"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_KEYWD
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHI
argument_list|,
name|k
argument_list|,
name|C_PUSHI
argument_list|,
name|D_INTEGER
argument_list|,
name|C_CALL
argument_list|,
literal|0
argument_list|,
literal|"keywd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LAB
case|:
name|lab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_LABEL
argument_list|,
name|lab
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LIMIT
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|0
argument_list|,
literal|"limit"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LINE
case|:
name|line
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_MOVI
argument_list|,
name|line
argument_list|,
literal|"_line"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LLIST
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
name|k
argument_list|,
literal|"llist"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LSUSP
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|0
argument_list|,
literal|"lsusp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_MARK
case|:
name|lab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSH
argument_list|,
literal|"r4"
argument_list|,
name|C_MOV
argument_list|,
literal|"sp"
argument_list|,
literal|"r4"
argument_list|,
name|C_PUSH
argument_list|,
literal|"r3"
argument_list|,
name|C_CLR
argument_list|,
literal|"r3"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lab
operator|!=
literal|0
condition|)
name|emit
argument_list|(
name|C_PUSHL
argument_list|,
name|lab
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|emit
argument_list|(
name|C_PUSHZ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_PFAIL
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|0
argument_list|,
literal|"pfail"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_PNULL
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHZ
argument_list|,
name|C_PUSHZ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_POP
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_MISC
argument_list|,
literal|"cmp"
argument_list|,
literal|"(sp)+,(sp)+"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_PRET
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|1
argument_list|,
literal|"pret"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_PSUSP
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_CALL
argument_list|,
literal|0
argument_list|,
literal|"psusp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_PUSH1
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHI
argument_list|,
literal|1
argument_list|,
name|C_PUSHI
argument_list|,
name|D_INTEGER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_PUSHN1
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHI
argument_list|,
operator|-
literal|1
argument_list|,
name|C_PUSHI
argument_list|,
name|D_INTEGER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_REAL
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHC
argument_list|,
name|k
argument_list|,
name|nproc
argument_list|,
name|C_PUSHI
argument_list|,
name|D_REAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SDUP
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|C_PUSH
argument_list|,
literal|"2(sp)"
argument_list|,
name|C_PUSH
argument_list|,
literal|"2(sp)"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_STR
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|id
operator|=
name|ctable
index|[
name|k
index|]
operator|.
name|c_val
operator|.
name|sval
expr_stmt|;
name|emit
argument_list|(
name|C_PUSHA
argument_list|,
literal|"ident"
argument_list|,
name|id
operator|-
name|strings
argument_list|,
name|C_PUSHI
argument_list|,
name|ctable
index|[
name|k
index|]
operator|.
name|c_length
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_UNMARK
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
while|while
condition|(
name|k
operator|--
operator|>
literal|1
condition|)
name|emit
argument_list|(
name|C_MOV
argument_list|,
literal|"(r4)"
argument_list|,
literal|"r4"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit
argument_list|(
name|C_MOV
argument_list|,
literal|"-2(r4)"
argument_list|,
literal|"r3"
argument_list|,
name|C_MOV
argument_list|,
literal|"r4"
argument_list|,
literal|"sp"
argument_list|,
name|C_POP
argument_list|,
literal|"r4"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_VAR
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|=
name|ltable
index|[
name|k
index|]
operator|.
name|l_flag
operator|)
operator|&
name|F_GLOBAL
condition|)
name|emit
argument_list|(
name|C_PUSHA
argument_list|,
literal|"globals"
argument_list|,
literal|4
operator|*
operator|(
name|ltable
index|[
name|k
index|]
operator|.
name|l_val
operator|.
name|global
operator|-
name|gtable
operator|)
argument_list|,
name|C_PUSHI
argument_list|,
name|D_VAR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_STATIC
condition|)
name|emit
argument_list|(
name|C_PUSHA
argument_list|,
literal|"statics"
argument_list|,
literal|4
operator|*
operator|(
name|ltable
index|[
name|k
index|]
operator|.
name|l_val
operator|.
name|staticid
operator|-
literal|1
operator|)
argument_list|,
name|C_PUSHI
argument_list|,
name|D_VAR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_ARGUMENT
condition|)
name|emit
argument_list|(
name|C_PUSH
argument_list|,
literal|"r5"
argument_list|,
name|C_ADDTOP
argument_list|,
literal|6
operator|+
literal|4
operator|*
operator|(
name|nargs
operator|-
name|ltable
index|[
name|k
index|]
operator|.
name|l_val
operator|.
name|offset
operator|)
argument_list|,
name|C_PUSHI
argument_list|,
name|D_VAR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|emit
argument_list|(
name|C_PUSH
argument_list|,
literal|"r5"
argument_list|,
name|C_ADDTOP
argument_list|,
operator|-
literal|10
operator|-
literal|4
operator|*
name|ltable
index|[
name|k
index|]
operator|.
name|l_val
operator|.
name|offset
argument_list|,
name|C_PUSHI
argument_list|,
name|D_VAR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_PROC
case|:
name|locinit
argument_list|()
expr_stmt|;
name|line
operator|=
literal|0
expr_stmt|;
name|procname
operator|=
name|getid
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|gp
operator|=
name|glocate
argument_list|(
name|procname
argument_list|)
expr_stmt|;
name|implicit
operator|=
name|gp
operator|->
name|g_flag
operator|&
name|F_IMPERROR
expr_stmt|;
name|nargs
operator|=
name|gp
operator|->
name|g_nargs
expr_stmt|;
name|gp
operator|->
name|g_procid
operator|=
operator|++
name|nproc
expr_stmt|;
break|break;
case|case
name|OP_LOCAL
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|flags
operator|=
name|getoct
argument_list|()
expr_stmt|;
name|id
operator|=
name|getid
argument_list|()
expr_stmt|;
name|putloc
argument_list|(
name|k
argument_list|,
name|id
argument_list|,
name|flags
argument_list|,
name|implicit
argument_list|,
name|procname
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CON
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|flags
operator|=
name|getoct
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|F_INTLIT
condition|)
name|putconst
argument_list|(
name|k
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
name|getint
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_REALLIT
condition|)
name|putconst
argument_list|(
name|k
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
name|getreal
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_STRLIT
condition|)
block|{
name|j
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|putconst
argument_list|(
name|k
argument_list|,
name|flags
argument_list|,
name|j
argument_list|,
name|getstrlit
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_CSETLIT
condition|)
block|{
name|j
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|putconst
argument_list|(
name|k
argument_list|,
name|flags
argument_list|,
name|j
argument_list|,
name|getstrlit
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencode: illegal constant\n"
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
break|break;
case|case
name|OP_DECLEND
case|:
name|newline
argument_list|()
expr_stmt|;
name|emitproc
argument_list|(
name|nproc
argument_list|,
name|procname
argument_list|,
name|nargs
argument_list|,
name|dynoff
argument_list|,
name|statics
operator|-
name|static1
argument_list|,
name|static1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_END
case|:
name|newline
argument_list|()
expr_stmt|;
name|procend
argument_list|()
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencode: illegal opcode(%d): %s\n"
argument_list|,
name|op
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * emit - emit assembler code to outfile.  This routine  * takes a variable number of arguments.  Each group of  * arguments begins with a template number, which selects  * one of the fprintf statements below.  Following the  * template number is zero or more parameters to that  * template.  */
end_comment

begin_macro
name|emit
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
union|union
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|integ
decl_stmt|;
block|}
modifier|*
name|ap
union|;
name|ap
operator|=
operator|&
name|a
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|ap
operator|)
operator|.
name|integ
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|ap
operator|++
operator|)
operator|.
name|integ
condition|)
block|{
case|case
name|C_PUSH
case|:
comment|/* push something on the stack */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tmov\t%s,-(sp)\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|++
expr_stmt|;
break|break;
case|case
name|C_PUSHI
case|:
comment|/* push an immediate on the stack */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tmov\t$%o,-(sp)\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|ap
operator|++
expr_stmt|;
break|break;
case|case
name|C_PUSHZ
case|:
comment|/* push a zero on the stack */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tclr\t-(sp)\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_PUSHA
case|:
comment|/* push an address on the stack */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tmov\t$_%s+%o,-(sp)\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|str
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|C_PUSHC
case|:
comment|/* push the address of a constant */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tmov\t$C%dP%d,-(sp)\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|C_PUSHL
case|:
comment|/* push an label on the stack */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tmov\t$L%dF%d,-(sp)\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|C_POP
case|:
comment|/* pop the stack into some location */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tmov\t(sp)+,%s\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|++
expr_stmt|;
break|break;
case|case
name|C_MOV
case|:
comment|/* move one location to another */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tmov\t%s,%s\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|str
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|C_MOVI
case|:
comment|/* move an immediate to some location */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tmov\t$%o,%s\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|C_MOVL
case|:
comment|/* move a label to some location */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tmov\t$L%dF%d,%s\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|2
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|C_MOVA
case|:
comment|/* move an address to some location */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tmov\t$_%s+%o,%s\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|str
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|2
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|C_CLR
case|:
comment|/* clr a word */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tclr\t%s\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|++
expr_stmt|;
break|break;
case|case
name|C_ADDTOP
case|:
comment|/* add an immediate to the top of stack */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tadd\t$%o,(sp)\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|ap
operator|++
expr_stmt|;
break|break;
case|case
name|C_INIT
case|:
comment|/* test initial flag of procedure */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\ttst\tP%dI\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tjne\tL%dF%d\n"
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|2
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tinc\tP%dI\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|C_CALL
case|:
comment|/* call a subroutine */
if|if
condition|(
name|ap
index|[
literal|0
index|]
operator|.
name|integ
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tclr\t-(sp)\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tmov\t$%o,-(sp)\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tjsr\tpc,_%s\n"
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|C_JUMP
case|:
comment|/* conditional jump to a local label */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tj%s\tL%dF%d\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|str
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|2
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|C_LABEL
case|:
comment|/* place a local label */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"L%dF%d:\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|integ
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|integ
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|C_MISC
case|:
comment|/* miscellaneous */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%s\t%s\n"
argument_list|,
name|ap
index|[
literal|0
index|]
operator|.
name|str
argument_list|,
name|ap
index|[
literal|1
index|]
operator|.
name|str
argument_list|)
expr_stmt|;
name|ap
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"emit: illegal template number"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * emitproc - emit code for procedure block #n.  */
end_comment

begin_macro
name|emitproc
argument_list|(
argument|n
argument_list|,
argument|name
argument_list|,
argument|nargs
argument_list|,
argument|ndyn
argument_list|,
argument|nstat
argument_list|,
argument|fstat
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nargs
decl_stmt|,
name|ndyn
decl_stmt|,
name|nstat
decl_stmt|,
name|fstat
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".data\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"P%d:\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;"
argument_list|,
name|T_PROC
argument_list|)
expr_stmt|;
comment|/* type code */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;"
argument_list|,
comment|/* size of block */
literal|18
operator|+
literal|4
operator|*
operator|(
name|nargs
operator|+
name|ndyn
operator|+
name|nstat
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tI%d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* entry point */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;"
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
comment|/* # arguments */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;"
argument_list|,
name|ndyn
argument_list|)
expr_stmt|;
comment|/* # dynamic locals */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;"
argument_list|,
name|nstat
argument_list|)
expr_stmt|;
comment|/* # static locals */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o\n"
argument_list|,
name|fstat
argument_list|)
expr_stmt|;
comment|/* first static */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;\t_ident+%o\t/ %s\n"
argument_list|,
comment|/* qualifiers */
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
operator|-
name|strings
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nlocal
condition|;
name|i
operator|++
control|)
block|{
comment|/* names of arguments */
if|if
condition|(
name|ltable
index|[
name|i
index|]
operator|.
name|l_flag
operator|&
name|F_ARGUMENT
condition|)
block|{
name|p
operator|=
name|ltable
index|[
name|i
index|]
operator|.
name|l_name
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;\t_ident+%o\t/ %s\n"
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
operator|-
name|strings
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nlocal
condition|;
name|i
operator|++
control|)
block|{
comment|/* names of dynamic locals */
if|if
condition|(
name|ltable
index|[
name|i
index|]
operator|.
name|l_flag
operator|&
name|F_DYNAMIC
condition|)
block|{
name|p
operator|=
name|ltable
index|[
name|i
index|]
operator|.
name|l_name
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;\t_ident+%o\t/ %s\n"
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
operator|-
name|strings
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nlocal
condition|;
name|i
operator|++
control|)
block|{
comment|/* names of static locals */
if|if
condition|(
name|ltable
index|[
name|i
index|]
operator|.
name|l_flag
operator|&
name|F_STATIC
condition|)
block|{
name|p
operator|=
name|ltable
index|[
name|i
index|]
operator|.
name|l_name
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;\t_ident+%o\t/ %s\n"
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
operator|-
name|strings
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"P%dI:\t0\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* initial flag */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".text\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"I%d:\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * procend - emit constant table at end of procedure.  */
end_comment

begin_macro
name|procend
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|csbuf
index|[
name|CSETSIZE
index|]
decl_stmt|;
union|union
block|{
name|unsigned
name|int
name|i
index|[
literal|4
index|]
decl_stmt|;
name|long
name|int
name|l
decl_stmt|;
name|double
name|f
decl_stmt|;
block|}
name|x
union|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".data\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|nconst
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|ctable
index|[
name|k
index|]
operator|.
name|c_flag
operator|&
name|F_REALLIT
condition|)
block|{
name|x
operator|.
name|f
operator|=
name|ctable
index|[
name|k
index|]
operator|.
name|c_val
operator|.
name|rval
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"C%dP%d:\t%06o;\t%06o;\t%06o;\t%06o;\t%06o\t/ %g\n"
argument_list|,
name|k
argument_list|,
name|nproc
argument_list|,
name|T_REAL
argument_list|,
name|x
operator|.
name|i
index|[
literal|0
index|]
argument_list|,
name|x
operator|.
name|i
index|[
literal|1
index|]
argument_list|,
name|x
operator|.
name|i
index|[
literal|2
index|]
argument_list|,
name|x
operator|.
name|i
index|[
literal|3
index|]
argument_list|,
name|x
operator|.
name|f
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctable
index|[
name|k
index|]
operator|.
name|c_flag
operator|&
name|F_LONGLIT
condition|)
block|{
name|x
operator|.
name|l
operator|=
name|ctable
index|[
name|k
index|]
operator|.
name|c_val
operator|.
name|ival
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"C%dP%d:\t%06o;\t%06o;\t%06o\t/ %ld\n"
argument_list|,
name|k
argument_list|,
name|nproc
argument_list|,
name|T_LONGINT
argument_list|,
name|x
operator|.
name|i
index|[
literal|0
index|]
argument_list|,
name|x
operator|.
name|i
index|[
literal|1
index|]
argument_list|,
name|x
operator|.
name|l
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctable
index|[
name|k
index|]
operator|.
name|c_flag
operator|&
name|F_CSETLIT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CSETSIZE
condition|;
name|i
operator|++
control|)
name|csbuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|ctable
index|[
name|k
index|]
operator|.
name|c_val
operator|.
name|sval
expr_stmt|;
name|i
operator|=
name|ctable
index|[
name|k
index|]
operator|.
name|c_length
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|setb
argument_list|(
operator|*
name|s
argument_list|,
name|csbuf
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"C%dP%d:\t%06o;"
argument_list|,
name|k
argument_list|,
name|nproc
argument_list|,
name|T_CSET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CSETSIZE
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;"
argument_list|,
name|csbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".text\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * gentables - generate assembler code for global, static,  * identifier, and record tables, and built-in procedure blocks.  */
end_comment

begin_macro
name|gentables
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|gentry
modifier|*
name|gp
decl_stmt|;
name|int
name|j
decl_stmt|;
name|struct
name|fentry
modifier|*
name|fp
decl_stmt|;
name|struct
name|rentry
modifier|*
name|rp
decl_stmt|;
comment|/* output record constructor procedure blocks */
for|for
control|(
name|gp
operator|=
name|gtable
init|;
name|gp
operator|<
name|gfree
condition|;
name|gp
operator|++
control|)
block|{
if|if
condition|(
name|gp
operator|->
name|g_flag
operator|&
operator|(
name|F_RECORD
operator|&
operator|~
name|F_GLOBAL
operator|)
condition|)
block|{
name|s
operator|=
name|gp
operator|->
name|g_name
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".data\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"R%d:"
argument_list|,
name|gp
operator|->
name|g_procid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;"
argument_list|,
name|T_PROC
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;"
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t_mkrec+4\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;"
argument_list|,
name|gp
operator|->
name|g_nargs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;"
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;"
argument_list|,
name|gp
operator|->
name|g_procid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;\t_ident+%o\t/ %s\n"
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
name|s
operator|-
name|strings
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".text\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* output record/field tables */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".data\n"
argument_list|)
expr_stmt|;
name|j
operator|=
name|ffree
operator|-
name|ftable
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|ftable
init|;
name|fp
operator|<
name|ffree
condition|;
name|fp
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"F%d:"
argument_list|,
name|fp
operator|->
name|f_fid
argument_list|)
expr_stmt|;
name|rp
operator|=
name|fp
operator|->
name|f_rlist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nrecords
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rp
operator|!=
name|NULL
operator|&&
name|rp
operator|->
name|r_recid
operator|==
name|i
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o"
argument_list|,
name|rp
operator|->
name|r_fnum
argument_list|)
expr_stmt|;
name|rp
operator|=
name|rp
operator|->
name|r_link
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t-1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|nrecords
operator|||
operator|(
name|i
operator|&
literal|03
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".globl\t_ftab\n_ftab:\t%06o\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|j
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\tF%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|j
operator|||
operator|(
name|i
operator|&
literal|03
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
block|}
comment|/* output global declarations */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".globl\t_globals,_eglobals\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".globl\t_gnames,_egnames\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".globl\t_statics,_estatics\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".globl\t_ident,_eident\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".globl\t_k_trace\n_k_trace: %o\n"
argument_list|,
name|trace
argument_list|)
expr_stmt|;
comment|/* output global variables */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"_globals:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|gtable
init|;
name|gp
operator|<
name|gfree
condition|;
name|gp
operator|++
control|)
block|{
if|if
condition|(
name|gp
operator|->
name|g_flag
operator|&
operator|(
name|F_BUILTIN
operator|&
operator|~
name|F_GLOBAL
operator|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;\t_B%s\t/ %s\n"
argument_list|,
name|D_PROC
argument_list|,
name|gp
operator|->
name|g_name
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gp
operator|->
name|g_flag
operator|&
operator|(
name|F_PROC
operator|&
operator|~
name|F_GLOBAL
operator|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;\tP%d\t/ %s\n"
argument_list|,
name|D_PROC
argument_list|,
name|gp
operator|->
name|g_procid
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gp
operator|->
name|g_flag
operator|&
operator|(
name|F_RECORD
operator|&
operator|~
name|F_GLOBAL
operator|)
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;\tR%d\t/ %s\n"
argument_list|,
name|D_PROC
argument_list|,
name|gp
operator|->
name|g_procid
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t0;\t0\t/ %s\n"
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"_eglobals:\n"
argument_list|)
expr_stmt|;
comment|/* output names of global variables */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"_gnames:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|gtable
init|;
name|gp
operator|<
name|gfree
condition|;
name|gp
operator|++
control|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t%06o;\t_ident+%o\t/ %s\n"
argument_list|,
name|strlen
argument_list|(
name|gp
operator|->
name|g_name
argument_list|)
argument_list|,
name|gp
operator|->
name|g_name
operator|-
name|strings
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"_egnames:\n"
argument_list|)
expr_stmt|;
comment|/* output static variables */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"_statics:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|statics
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t0;\t0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"_estatics:\n"
argument_list|)
expr_stmt|;
comment|/* output identifier table */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"_ident:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|strings
init|;
name|s
operator|<
name|sfree
condition|;
control|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\t.byte\t%03o"
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|s
operator|>=
name|sfree
condition|)
break|break;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|",%03o"
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|".even\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"_eident:\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|PDP11
end_endif

end_unit

