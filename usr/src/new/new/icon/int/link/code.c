begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"ulink.h"
end_include

begin_include
include|#
directive|include
file|"code.h"
end_include

begin_include
include|#
directive|include
file|"opcode.h"
end_include

begin_include
include|#
directive|include
file|"datatype.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|pc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* simulated program counter */
end_comment

begin_comment
comment|/*  * gencode - read .u1 file, resolve variable references,  * and generate assembler code.  */
end_comment

begin_macro
name|gencode
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|op
decl_stmt|,
name|k
decl_stmt|,
name|lab
decl_stmt|;
name|int
name|j
decl_stmt|,
name|nargs
decl_stmt|,
name|flags
decl_stmt|,
name|implicit
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|procname
decl_stmt|;
name|struct
name|centry
modifier|*
name|cp
decl_stmt|;
name|struct
name|gentry
modifier|*
name|gp
decl_stmt|;
name|struct
name|fentry
modifier|*
name|fp
decl_stmt|,
modifier|*
name|flocate
argument_list|()
decl_stmt|;
specifier|extern
name|long
name|getint
parameter_list|()
function_decl|;
specifier|extern
name|double
name|getreal
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|getid
argument_list|()
decl_stmt|,
modifier|*
name|getstrlit
argument_list|()
decl_stmt|;
specifier|extern
name|struct
name|gentry
modifier|*
name|glocate
parameter_list|()
function_decl|;
while|while
condition|(
operator|(
name|op
operator|=
name|getop
argument_list|(
operator|&
name|name
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
comment|/* Ternary Operators */
case|case
name|OP_TOBY
case|:
case|case
name|OP_SECT
case|:
comment|/* Binary Operators */
case|case
name|OP_ASGN
case|:
case|case
name|OP_CAT
case|:
case|case
name|OP_DIFF
case|:
case|case
name|OP_DIV
case|:
case|case
name|OP_EQV
case|:
case|case
name|OP_INTER
case|:
case|case
name|OP_LCONCAT
case|:
case|case
name|OP_LEXEQ
case|:
case|case
name|OP_LEXGE
case|:
case|case
name|OP_LEXGT
case|:
case|case
name|OP_LEXLE
case|:
case|case
name|OP_LEXLT
case|:
case|case
name|OP_LEXNE
case|:
case|case
name|OP_MINUS
case|:
case|case
name|OP_MOD
case|:
case|case
name|OP_MULT
case|:
case|case
name|OP_NEQV
case|:
case|case
name|OP_NUMEQ
case|:
case|case
name|OP_NUMGE
case|:
case|case
name|OP_NUMGT
case|:
case|case
name|OP_NUMLE
case|:
case|case
name|OP_NUMLT
case|:
case|case
name|OP_NUMNE
case|:
case|case
name|OP_PLUS
case|:
case|case
name|OP_POWER
case|:
case|case
name|OP_RASGN
case|:
case|case
name|OP_RSWAP
case|:
case|case
name|OP_SUBSC
case|:
case|case
name|OP_SWAP
case|:
case|case
name|OP_UNIONCS
case|:
comment|/* Unary Operators */
case|case
name|OP_BANG
case|:
case|case
name|OP_COMPL
case|:
case|case
name|OP_NEG
case|:
case|case
name|OP_NONNULL
case|:
case|case
name|OP_NULL
case|:
case|case
name|OP_NUMBER
case|:
case|case
name|OP_RANDOM
case|:
case|case
name|OP_REFRESH
case|:
case|case
name|OP_SIZE
case|:
case|case
name|OP_TABMAT
case|:
case|case
name|OP_VALUE
case|:
comment|/* Instructions */
case|case
name|OP_BSCAN
case|:
case|case
name|OP_CCASE
case|:
case|case
name|OP_COACT
case|:
case|case
name|OP_COFAIL
case|:
case|case
name|OP_CORET
case|:
case|case
name|OP_DUP
case|:
case|case
name|OP_EFAIL
case|:
case|case
name|OP_ERET
case|:
case|case
name|OP_ESCAN
case|:
case|case
name|OP_ESUSP
case|:
case|case
name|OP_INCRES
case|:
case|case
name|OP_LIMIT
case|:
case|case
name|OP_LSUSP
case|:
case|case
name|OP_PFAIL
case|:
case|case
name|OP_PNULL
case|:
case|case
name|OP_POP
case|:
case|case
name|OP_PRET
case|:
case|case
name|OP_PSUSP
case|:
case|case
name|OP_PUSH1
case|:
case|case
name|OP_PUSHN1
case|:
case|case
name|OP_SDUP
case|:
name|newline
argument_list|()
expr_stmt|;
name|emit
argument_list|(
name|op
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CHFAIL
case|:
case|case
name|OP_CREATE
case|:
case|case
name|OP_GOTO
case|:
case|case
name|OP_INIT
case|:
name|lab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emitl
argument_list|(
name|op
argument_list|,
name|lab
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CSET
case|:
case|case
name|OP_REAL
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emitr
argument_list|(
name|op
argument_list|,
name|ctable
index|[
name|k
index|]
operator|.
name|c_pc
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_FIELD
case|:
name|id
operator|=
name|getid
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|fp
operator|=
name|flocate
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
name|id
argument_list|,
literal|"invalid field name"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|emitn
argument_list|(
name|op
argument_list|,
name|fp
operator|->
name|f_fid
operator|-
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_FILE
case|:
name|file
operator|=
name|getid
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emiti
argument_list|(
name|op
argument_list|,
name|file
operator|-
name|strings
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_INT
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|cp
operator|=
operator|&
name|ctable
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|c_flag
operator|&
name|F_LONGLIT
condition|)
name|emitr
argument_list|(
name|OP_CON
argument_list|,
name|cp
operator|->
name|c_pc
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/*  else     	       abbrev(op, (int)cp->c_val.ival, name, OP_INTX, 16); 	 */
else|else
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|int
operator|)
name|cp
operator|->
name|c_val
operator|.
name|ival
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
literal|16
condition|)
name|emit
argument_list|(
name|OP_INTX
operator|+
name|i
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|emitint
argument_list|(
name|op
argument_list|,
name|i
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_INVOKE
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|abbrev
argument_list|(
name|op
argument_list|,
name|k
argument_list|,
name|name
argument_list|,
name|OP_INVKX
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_KEYWD
case|:
case|case
name|OP_LLIST
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emitn
argument_list|(
name|op
argument_list|,
name|k
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LAB
case|:
name|lab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"L%d:\n"
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|backpatch
argument_list|(
name|lab
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LINE
case|:
name|line
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|abbrev
argument_list|(
name|op
argument_list|,
name|line
argument_list|,
name|name
argument_list|,
name|OP_LINEX
argument_list|,
literal|64
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_MARK
case|:
name|lab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
if|if
condition|(
name|lab
operator|!=
literal|0
condition|)
name|emitl
argument_list|(
name|op
argument_list|,
name|lab
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|emit
argument_list|(
name|OP_MARK0
argument_list|,
literal|"mark0"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_STR
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|cp
operator|=
operator|&
name|ctable
index|[
name|k
index|]
expr_stmt|;
name|id
operator|=
name|cp
operator|->
name|c_val
operator|.
name|sval
expr_stmt|;
name|emitin
argument_list|(
name|op
argument_list|,
name|id
operator|-
name|strings
argument_list|,
name|cp
operator|->
name|c_length
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_UNMARK
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|abbrev
argument_list|(
name|op
argument_list|,
name|k
argument_list|,
name|name
argument_list|,
name|OP_UNMKX
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_VAR
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|flags
operator|=
name|ltable
index|[
name|k
index|]
operator|.
name|l_flag
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|F_GLOBAL
condition|)
name|abbrev
argument_list|(
name|OP_GLOBAL
argument_list|,
name|ltable
index|[
name|k
index|]
operator|.
name|l_val
operator|.
name|global
operator|-
name|gtable
argument_list|,
literal|"global"
argument_list|,
name|OP_GLOBX
argument_list|,
literal|16
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_STATIC
condition|)
name|abbrev
argument_list|(
name|OP_STATIC
argument_list|,
name|ltable
index|[
name|k
index|]
operator|.
name|l_val
operator|.
name|staticid
operator|-
literal|1
argument_list|,
literal|"static"
argument_list|,
name|OP_STATX
argument_list|,
literal|8
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_ARGUMENT
condition|)
name|abbrev
argument_list|(
name|OP_ARG
argument_list|,
name|nargs
operator|-
name|ltable
index|[
name|k
index|]
operator|.
name|l_val
operator|.
name|offset
argument_list|,
literal|"arg"
argument_list|,
name|OP_ARGX
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
name|abbrev
argument_list|(
name|OP_LOCAL
argument_list|,
name|ltable
index|[
name|k
index|]
operator|.
name|l_val
operator|.
name|offset
operator|-
literal|1
argument_list|,
literal|"local"
argument_list|,
name|OP_LOCX
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
comment|/* Declarations */
case|case
name|OP_PROC
case|:
name|procname
operator|=
name|getid
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|locinit
argument_list|()
expr_stmt|;
name|clearlab
argument_list|()
expr_stmt|;
name|line
operator|=
literal|0
expr_stmt|;
name|gp
operator|=
name|glocate
argument_list|(
name|procname
argument_list|)
expr_stmt|;
name|implicit
operator|=
name|gp
operator|->
name|g_flag
operator|&
name|F_IMPERROR
expr_stmt|;
name|nargs
operator|=
name|gp
operator|->
name|g_nargs
expr_stmt|;
name|emiteven
argument_list|()
expr_stmt|;
break|break;
case|case
name|OP_LOCAL
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|flags
operator|=
name|getoct
argument_list|()
expr_stmt|;
name|id
operator|=
name|getid
argument_list|()
expr_stmt|;
name|putloc
argument_list|(
name|k
argument_list|,
name|id
argument_list|,
name|flags
argument_list|,
name|implicit
argument_list|,
name|procname
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CON
case|:
name|k
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|flags
operator|=
name|getoct
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|F_INTLIT
condition|)
name|putconst
argument_list|(
name|k
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|getint
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_REALLIT
condition|)
name|putconst
argument_list|(
name|k
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|getreal
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_STRLIT
condition|)
block|{
name|j
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|putconst
argument_list|(
name|k
argument_list|,
name|flags
argument_list|,
name|j
argument_list|,
name|pc
argument_list|,
name|getstrlit
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_CSETLIT
condition|)
block|{
name|j
operator|=
name|getdec
argument_list|()
expr_stmt|;
name|putconst
argument_list|(
name|k
argument_list|,
name|flags
argument_list|,
name|j
argument_list|,
name|pc
argument_list|,
name|getstrlit
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencode: illegal constant\n"
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|emitcon
argument_list|(
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_DECLEND
case|:
name|newline
argument_list|()
expr_stmt|;
name|gp
operator|->
name|g_pc
operator|=
name|pc
expr_stmt|;
name|emitproc
argument_list|(
name|procname
argument_list|,
name|nargs
argument_list|,
name|dynoff
argument_list|,
name|statics
operator|-
name|static1
argument_list|,
name|static1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_END
case|:
name|newline
argument_list|()
expr_stmt|;
name|flushcode
argument_list|()
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencode: illegal opcode(%d): %s\n"
argument_list|,
name|op
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * abbrev - for certain opcodes with small-enough integer arguments,  * use a special abbreviation that includes the integer argument in the opcode.  */
end_comment

begin_macro
name|abbrev
argument_list|(
argument|op
argument_list|,
argument|n
argument_list|,
argument|name
argument_list|,
argument|altop
argument_list|,
argument|limit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|altop
decl_stmt|,
name|limit
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|>=
literal|0
operator|&&
name|n
operator|<
name|limit
condition|)
name|emit
argument_list|(
name|altop
operator|+
name|n
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|emitn
argument_list|(
name|op
argument_list|,
name|n
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * emit - emit opcode.  * emitl - emit opcode with reference to program label.  * emitn - emit opcode with integer argument.  * emitr - emit opcode with pc-relative reference.  * emiti - emit opcode with reference to identifier table.  * emitin - emit opcode with reference to identifier table& integer argument.  * emitint - emit INT opcode with integer argument  * emiteven - emit a null byte if pc is odd.  * emitcon - emit constant table entry.  * emitproc - emit procedure block.  */
end_comment

begin_macro
name|emit
argument_list|(
argument|op
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\t\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|op
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|emitl
argument_list|(
argument|op
argument_list|,
argument|lab
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|,
name|lab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\tL%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|op
argument_list|,
name|lab
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lab
operator|>=
name|maxlabels
condition|)
name|syserr
argument_list|(
literal|"too many labels in ucode"
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|labels
index|[
name|lab
index|]
operator|<=
literal|0
condition|)
block|{
comment|/* forward reference */
name|outw
argument_list|(
name|labels
index|[
name|lab
index|]
argument_list|)
expr_stmt|;
name|labels
index|[
name|lab
index|]
operator|=
literal|2
operator|-
name|pc
expr_stmt|;
comment|/* add to front of reference chain */
block|}
else|else
comment|/* output relative offset */
name|outw
argument_list|(
name|labels
index|[
name|lab
index|]
operator|-
operator|(
name|pc
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|emitn
argument_list|(
argument|op
argument_list|,
argument|n
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\t%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|op
argument_list|,
name|n
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|emitr
argument_list|(
argument|op
argument_list|,
argument|loc
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|,
name|loc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|loc
operator|-=
name|pc
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
block|{
if|if
condition|(
name|loc
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\t*+%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|op
argument_list|,
name|loc
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\t*-%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|op
argument_list|,
operator|-
name|loc
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|loc
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|emiti
argument_list|(
argument|op
argument_list|,
argument|offset
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|,
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\tI+%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|op
argument_list|,
name|offset
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|emitin
argument_list|(
argument|op
argument_list|,
argument|offset
argument_list|,
argument|n
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|,
name|offset
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\tI+%d,%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|op
argument_list|,
name|offset
argument_list|,
name|n
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|emitint
argument_list|(
argument|op
argument_list|,
argument|i
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|,
name|i
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\t%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|op
argument_list|,
name|i
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|emiteven
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|pc
operator|&
literal|01
condition|)
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t0\n"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|emitcon
argument_list|(
name|k
argument_list|)
specifier|register
name|int
name|k
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|csbuf
index|[
name|CSETSIZE
index|]
decl_stmt|;
comment|/*     * Note--The array i is used to overlay l and f.  On the Vax     *  and the 11 this works, but might not on some other machine,     *  so beware--whm     */
union|union
block|{
name|unsigned
name|short
name|i
index|[
literal|4
index|]
decl_stmt|;
name|long
name|int
name|l
decl_stmt|;
name|double
name|f
decl_stmt|;
block|}
name|x
union|;
if|if
condition|(
name|ctable
index|[
name|k
index|]
operator|.
name|c_flag
operator|&
name|F_REALLIT
condition|)
block|{
name|x
operator|.
name|f
operator|=
name|ctable
index|[
name|k
index|]
operator|.
name|c_val
operator|.
name|rval
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\t%06o\t%06o\t%06o\t%06o\t\t\t# %g\n"
argument_list|,
name|pc
argument_list|,
name|T_REAL
argument_list|,
name|x
operator|.
name|i
index|[
literal|0
index|]
argument_list|,
name|x
operator|.
name|i
index|[
literal|1
index|]
argument_list|,
name|x
operator|.
name|i
index|[
literal|2
index|]
argument_list|,
name|x
operator|.
name|i
index|[
literal|3
index|]
argument_list|,
name|x
operator|.
name|f
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|T_REAL
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|x
operator|.
name|i
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|x
operator|.
name|i
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|x
operator|.
name|i
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|x
operator|.
name|i
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctable
index|[
name|k
index|]
operator|.
name|c_flag
operator|&
name|F_LONGLIT
condition|)
block|{
name|x
operator|.
name|l
operator|=
name|ctable
index|[
name|k
index|]
operator|.
name|c_val
operator|.
name|ival
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\t%06o\t%06o\t\t\t# %ld\n"
argument_list|,
name|pc
argument_list|,
name|T_LONGINT
argument_list|,
name|x
operator|.
name|i
index|[
literal|0
index|]
argument_list|,
name|x
operator|.
name|i
index|[
literal|1
index|]
argument_list|,
name|x
operator|.
name|l
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|T_LONGINT
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|x
operator|.
name|i
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|x
operator|.
name|i
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctable
index|[
name|k
index|]
operator|.
name|c_flag
operator|&
name|F_CSETLIT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CSETSIZE
condition|;
name|i
operator|++
control|)
name|csbuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|ctable
index|[
name|k
index|]
operator|.
name|c_val
operator|.
name|sval
expr_stmt|;
name|i
operator|=
name|ctable
index|[
name|k
index|]
operator|.
name|c_length
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|setb
argument_list|(
operator|*
name|s
argument_list|,
name|csbuf
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d"
argument_list|,
name|pc
argument_list|,
name|T_CSET
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|T_CSET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CSETSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Dflag
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|&
literal|03
operator|)
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|dbgfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%06o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|csbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|outl
argument_list|(
name|csbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Dflag
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|dbgfile
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|emitproc
argument_list|(
argument|name
argument_list|,
argument|nargs
argument_list|,
argument|ndyn
argument_list|,
argument|nstat
argument_list|,
argument|fstat
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nargs
decl_stmt|,
name|ndyn
decl_stmt|,
name|nstat
decl_stmt|,
name|fstat
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/*  * ProcBlockSize = sizeof(BasicProcBlock) +   *  sizeof(descrip)*(# of args + # of dynamics + # of statics)  */
name|size
operator|=
operator|(
literal|9
operator|*
name|ADDRSIZE
operator|)
operator|+
operator|(
literal|2
operator|*
name|ADDRSIZE
operator|)
operator|*
operator|(
name|nargs
operator|+
name|ndyn
operator|+
name|nstat
operator|)
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
block|{
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d"
argument_list|,
name|pc
argument_list|,
name|T_PROC
argument_list|)
expr_stmt|;
comment|/* type code */
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* size of block */
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\tZ+%d\n"
argument_list|,
name|pc
operator|+
name|size
argument_list|)
expr_stmt|;
comment|/* entry point */
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d"
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
comment|/* # arguments */
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d"
argument_list|,
name|ndyn
argument_list|)
expr_stmt|;
comment|/* # dynamic locals */
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d"
argument_list|,
name|nstat
argument_list|)
expr_stmt|;
comment|/* # static locals */
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d\n"
argument_list|,
name|fstat
argument_list|)
expr_stmt|;
comment|/* first static */
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d\tI+%d\t\t\t# %s\n"
argument_list|,
comment|/* name of procedure */
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
operator|-
name|strings
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|outl
argument_list|(
name|T_PROC
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|pc
operator|+
name|size
operator|-
literal|2
operator|*
name|ADDRSIZE
argument_list|)
expr_stmt|;
comment|/* Have to allow for the two words    				     that we've already output */
name|outl
argument_list|(
name|nargs
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|ndyn
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|nstat
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|fstat
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|name
operator|-
name|strings
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nlocal
condition|;
name|i
operator|++
control|)
block|{
comment|/* names of arguments */
if|if
condition|(
name|ltable
index|[
name|i
index|]
operator|.
name|l_flag
operator|&
name|F_ARGUMENT
condition|)
block|{
name|p
operator|=
name|ltable
index|[
name|i
index|]
operator|.
name|l_name
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d\tI+%d\t\t\t# %s\n"
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
operator|-
name|strings
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|p
operator|-
name|strings
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nlocal
condition|;
name|i
operator|++
control|)
block|{
comment|/* names of dynamic locals */
if|if
condition|(
name|ltable
index|[
name|i
index|]
operator|.
name|l_flag
operator|&
name|F_DYNAMIC
condition|)
block|{
name|p
operator|=
name|ltable
index|[
name|i
index|]
operator|.
name|l_name
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d\tI+%d\t\t\t# %s\n"
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
operator|-
name|strings
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|p
operator|-
name|strings
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nlocal
condition|;
name|i
operator|++
control|)
block|{
comment|/* names of static locals */
if|if
condition|(
name|ltable
index|[
name|i
index|]
operator|.
name|l_flag
operator|&
name|F_STATIC
condition|)
block|{
name|p
operator|=
name|ltable
index|[
name|i
index|]
operator|.
name|l_name
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d\tI+%d\t\t\t# %s\n"
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
operator|-
name|strings
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|p
operator|-
name|strings
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * gentables - generate interpreter code for global, static,  * identifier, and record tables, and built-in procedure blocks.  */
end_comment

begin_macro
name|gentables
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|gentry
modifier|*
name|gp
decl_stmt|;
name|struct
name|fentry
modifier|*
name|fp
decl_stmt|;
name|struct
name|rentry
modifier|*
name|rp
decl_stmt|;
name|struct
name|header
name|hdr
decl_stmt|;
name|emiteven
argument_list|()
expr_stmt|;
comment|/* output record constructor procedure blocks */
name|hdr
operator|.
name|records
operator|=
name|pc
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\t\t\t\t# record blocks\n"
argument_list|,
name|pc
argument_list|,
name|nrecords
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|nrecords
argument_list|)
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|gtable
init|;
name|gp
operator|<
name|gfree
condition|;
name|gp
operator|++
control|)
block|{
if|if
condition|(
name|gp
operator|->
name|g_flag
operator|&
operator|(
name|F_RECORD
operator|&
operator|~
name|F_GLOBAL
operator|)
condition|)
block|{
name|s
operator|=
name|gp
operator|->
name|g_name
expr_stmt|;
name|gp
operator|->
name|g_pc
operator|=
name|pc
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
block|{
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d"
argument_list|,
name|T_PROC
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d"
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t_mkrec+4\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d"
argument_list|,
name|gp
operator|->
name|g_nargs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t-2"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d"
argument_list|,
name|gp
operator|->
name|g_procid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d\tI+%d\t\t\t# %s\n"
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
name|s
operator|-
name|strings
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|outl
argument_list|(
name|T_PROC
argument_list|)
expr_stmt|;
comment|/* type code */
name|outl
argument_list|(
literal|18
argument_list|)
expr_stmt|;
comment|/* size of block */
name|outl
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* entry point (filled in by interp) */
name|outl
argument_list|(
name|gp
operator|->
name|g_nargs
argument_list|)
expr_stmt|;
comment|/* number of fields */
name|outl
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* record constructor indicator */
name|outl
argument_list|(
name|gp
operator|->
name|g_procid
argument_list|)
expr_stmt|;
comment|/* record id */
name|outl
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* not used */
name|outl
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|/* name of record */
name|outl
argument_list|(
name|s
operator|-
name|strings
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* output record/field table */
name|hdr
operator|.
name|ftab
operator|=
name|pc
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t\t\t\t\t# record/field table\n"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|ftable
init|;
name|fp
operator|<
name|ffree
condition|;
name|fp
operator|++
control|)
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|rp
operator|=
name|fp
operator|->
name|f_rlist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nrecords
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rp
operator|!=
name|NULL
operator|&&
name|rp
operator|->
name|r_recid
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t%d"
argument_list|,
name|rp
operator|->
name|r_fnum
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|rp
operator|->
name|r_fnum
argument_list|)
expr_stmt|;
name|rp
operator|=
name|rp
operator|->
name|r_link
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"\t-1"
argument_list|)
expr_stmt|;
name|outl
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Dflag
operator|&&
operator|(
name|i
operator|==
name|nrecords
operator|||
operator|(
name|i
operator|&
literal|03
operator|)
operator|==
literal|0
operator|)
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|dbgfile
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* output global variables */
name|hdr
operator|.
name|globals
operator|=
name|pc
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|gtable
init|;
name|gp
operator|<
name|gfree
condition|;
name|gp
operator|++
control|)
block|{
if|if
condition|(
name|gp
operator|->
name|g_flag
operator|&
operator|(
name|F_BUILTIN
operator|&
operator|~
name|F_GLOBAL
operator|)
condition|)
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%06o\t%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|D_PROC
argument_list|,
operator|-
name|gp
operator|->
name|g_procid
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|D_PROC
argument_list|)
expr_stmt|;
name|outl
argument_list|(
operator|-
name|gp
operator|->
name|g_procid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gp
operator|->
name|g_flag
operator|&
operator|(
name|F_PROC
operator|&
operator|~
name|F_GLOBAL
operator|)
condition|)
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%06o\tZ+%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|D_PROC
argument_list|,
name|gp
operator|->
name|g_pc
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|D_PROC
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|gp
operator|->
name|g_pc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gp
operator|->
name|g_flag
operator|&
operator|(
name|F_RECORD
operator|&
operator|~
name|F_GLOBAL
operator|)
condition|)
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%06o\tZ+%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|D_PROC
argument_list|,
name|gp
operator|->
name|g_pc
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|D_PROC
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|gp
operator|->
name|g_pc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t0\t0\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
name|outl
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|outl
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* output names of global variables */
name|hdr
operator|.
name|gnames
operator|=
name|pc
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|gtable
init|;
name|gp
operator|<
name|gfree
condition|;
name|gp
operator|++
control|)
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%d\tI+%d\t\t\t# %s\n"
argument_list|,
name|pc
argument_list|,
name|strlen
argument_list|(
name|gp
operator|->
name|g_name
argument_list|)
argument_list|,
name|gp
operator|->
name|g_name
operator|-
name|strings
argument_list|,
name|gp
operator|->
name|g_name
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|strlen
argument_list|(
name|gp
operator|->
name|g_name
argument_list|)
argument_list|)
expr_stmt|;
name|outl
argument_list|(
name|gp
operator|->
name|g_name
operator|-
name|strings
argument_list|)
expr_stmt|;
block|}
comment|/* output static variables */
name|hdr
operator|.
name|statics
operator|=
name|pc
expr_stmt|;
for|for
control|(
name|i
operator|=
name|statics
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|Dflag
condition|)
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t0\t0\n"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|outl
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|outl
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|flushcode
argument_list|()
expr_stmt|;
comment|/* output identifier table */
name|hdr
operator|.
name|ident
operator|=
name|pc
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
block|{
for|for
control|(
name|s
operator|=
name|strings
init|;
name|s
operator|<
name|sfree
condition|;
control|)
block|{
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"%d:\t%03o"
argument_list|,
name|pc
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|s
operator|>=
name|sfree
condition|)
break|break;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|" %03o"
argument_list|,
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|dbgfile
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*fwrite(strings, 1, sfree - strings, outfile);*/
name|write
argument_list|(
name|fileno
argument_list|(
name|outfile
argument_list|)
argument_list|,
name|strings
argument_list|,
name|sfree
operator|-
name|strings
argument_list|)
expr_stmt|;
name|pc
operator|+=
name|sfree
operator|-
name|strings
expr_stmt|;
comment|/* output interpreter file header */
name|hdr
operator|.
name|size
operator|=
name|pc
expr_stmt|;
name|hdr
operator|.
name|trace
operator|=
name|trace
expr_stmt|;
if|if
condition|(
name|Dflag
condition|)
block|{
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"size:    %d\n"
argument_list|,
name|hdr
operator|.
name|size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"trace:   %d\n"
argument_list|,
name|hdr
operator|.
name|trace
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"records: %d\n"
argument_list|,
name|hdr
operator|.
name|records
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"ftab:    %d\n"
argument_list|,
name|hdr
operator|.
name|ftab
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"globals: %d\n"
argument_list|,
name|hdr
operator|.
name|globals
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"gnames:  %d\n"
argument_list|,
name|hdr
operator|.
name|gnames
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"statics: %d\n"
argument_list|,
name|hdr
operator|.
name|statics
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbgfile
argument_list|,
literal|"ident:   %d\n"
argument_list|,
name|hdr
operator|.
name|ident
argument_list|)
expr_stmt|;
block|}
name|fseek
argument_list|(
name|outfile
argument_list|,
operator|(
name|long
operator|)
name|hdrloc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*fwrite(&hdr, sizeof hdr, 1, outfile);*/
name|write
argument_list|(
name|fileno
argument_list|(
name|outfile
argument_list|)
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
name|hdr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * outb - output a byte.  * outw - output a 16 bit word.  * outl - output a word of type "int"  */
end_comment

begin_macro
name|outb
argument_list|(
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|int
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|codep
operator|>=
name|code
operator|+
name|maxcode
condition|)
name|syserr
argument_list|(
literal|"out of code buffer space"
argument_list|)
expr_stmt|;
operator|*
name|codep
operator|++
operator|=
name|b
expr_stmt|;
name|pc
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|outw
argument_list|(
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|int
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|outb
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|w
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|outl
argument_list|(
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|int
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|BIT32
name|outb
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|l
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|l
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|l
operator|>>
literal|24
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BIT32
ifdef|#
directive|ifdef
name|BIT16
name|outw
argument_list|(
name|l
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BIT16
block|}
end_block

begin_comment
comment|/*  * flushcode - write buffered code to the output file.  */
end_comment

begin_macro
name|flushcode
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|codep
operator|>
name|code
condition|)
comment|/*fwrite(code, 1, codep - code, outfile);*/
name|write
argument_list|(
name|fileno
argument_list|(
name|outfile
argument_list|)
argument_list|,
name|code
argument_list|,
name|codep
operator|-
name|code
argument_list|)
expr_stmt|;
name|codep
operator|=
name|code
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * clearlab - clear label table to all zeroes.  */
end_comment

begin_macro
name|clearlab
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxlabels
condition|;
name|i
operator|++
control|)
name|labels
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * backpatch - fill in all forward references to lab.  */
end_comment

begin_macro
name|backpatch
argument_list|(
argument|lab
argument_list|)
end_macro

begin_decl_stmt
name|int
name|lab
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|p
decl_stmt|,
name|r
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|lab
operator|>=
name|maxlabels
condition|)
name|syserr
argument_list|(
literal|"too many labels in ucode"
argument_list|)
expr_stmt|;
name|p
operator|=
name|labels
index|[
name|lab
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|>
literal|0
condition|)
name|syserr
argument_list|(
literal|"multiply defined label in ucode"
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
literal|0
condition|)
block|{
comment|/* follow reference chain */
name|r
operator|=
name|pc
operator|-
operator|(
literal|2
operator|-
name|p
operator|)
expr_stmt|;
comment|/* compute relative offset */
name|q
operator|=
name|codep
operator|-
operator|(
name|pc
operator|+
name|p
operator|)
expr_stmt|;
name|p
operator|=
operator|*
name|q
operator|++
operator|&
literal|0377
expr_stmt|;
comment|/* get next address on chain */
name|p
operator||=
operator|*
name|q
operator|<<
literal|8
expr_stmt|;
operator|*
name|q
operator|=
name|r
operator|>>
literal|8
expr_stmt|;
comment|/* fill in correct offset */
operator|*
operator|--
name|q
operator|=
name|r
expr_stmt|;
block|}
name|labels
index|[
name|lab
index|]
operator|=
name|pc
expr_stmt|;
block|}
end_block

begin_macro
name|genheader
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s"
argument_list|,
name|ixhdr
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

