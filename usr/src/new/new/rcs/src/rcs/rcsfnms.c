begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                     RCS file name handling  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /usr/wft/RCS/SRC/RCS/rcsfnms.c,v 3.7 83/05/11 15:01:58 wft Exp $ Purdue CS"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************************************************************  *                     creation and deletion of semaphorefile,  *                     creation of temporary filenames and cleanup()  *                     pairing of RCS file names and working file names.  *                     Testprogram: define PAIRTEST  ****************************************************************************  *  * Copyright (C) 1982 by Walter F. Tichy  *                       Purdue University  *                       Computer Science Department  *                       West Lafayette, IN 47907  *  * All rights reserved. No part of this software may be sold or distributed  * in any form or by any means without the prior written permission of the  * author.  * Report problems and direct all inquiries to Tichy@purdue (ARPA net).  */
end_comment

begin_comment
comment|/* $Log:	rcsfnms.c,v $  * Revision 3.7  83/05/11  15:01:58  wft  * Added comtable[] which pairs file name suffixes with comment leaders;  * updated InitAdmin() accordingly.  *   * Revision 3.6  83/04/05  14:47:36  wft  * fixed Suffix in InitAdmin().  *   * Revision 3.5  83/01/17  18:01:04  wft  * Added getwd() and rename(); these can be removed by defining  * V4_2BSD, since they are not needed in 4.2 bsd.  * Changed sys/param.h to sys/types.h.  *   * Revision 3.4  82/12/08  21:55:20  wft  * removed unused variable.  *  * Revision 3.3  82/11/28  20:31:37  wft  * Changed mktempfile() to store the generated file names.  * Changed getfullRCSname() to store the file and pathname, and to  * delete leading "../" and "./".  *  * Revision 3.2  82/11/12  14:29:40  wft  * changed pairfilenames() to handle file.sfx,v; also deleted checkpathnosfx(),  * checksuffix(), checkfullpath(). Semaphore name generation updated.  * mktempfile() now checks for nil path; lastfilename initialized properly.  * Added Suffix .h to InitAdmin. Added testprogram PAIRTEST.  * Moved rmsema, trysema, trydiraccess, getfullRCSname from rcsutil.c to here.  *  * Revision 3.1  82/10/18  14:51:28  wft  * InitAdmin() now initializes StrictLocks=STRICT_LOCKING (def. in rcsbase.h).  * renamed checkpath() to checkfullpath().  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|fopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getwd
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* get working directory; forward decl       */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|finptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RCS input file descriptor                 */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|frewrite
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* New RCS file descriptor                   */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|RCSfilename
decl_stmt|,
modifier|*
name|workfilename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* filenames                     */
end_comment

begin_decl_stmt
name|char
name|tempfilename
index|[
name|NCPFN
operator|+
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used for derived file names               */
end_comment

begin_decl_stmt
name|char
name|subfilename
index|[
name|NCPFN
operator|+
literal|14
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used for files RCS/file.sfx,v             */
end_comment

begin_decl_stmt
name|char
name|semafilename
index|[
name|NCPPN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of semaphore file                    */
end_comment

begin_decl_stmt
name|int
name|madesema
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indicates whether a semaphore file has been set */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tfnames
index|[
literal|10
index|]
init|=
comment|/* temp. file names to be unlinked when finished   */
block|{
name|nil
block|,
name|nil
block|,
name|nil
block|,
name|nil
block|,
name|nil
block|,
name|nil
block|,
name|nil
block|,
name|nil
block|,
name|nil
block|,
name|nil
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastfilename
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of last file name in tfnames[]      */
end_comment

begin_struct
struct|struct
name|compair
block|{
name|char
modifier|*
name|suffix
decl_stmt|,
modifier|*
name|comlead
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|compair
name|comtable
index|[]
init|=
block|{
comment|/* comtable pairs each filename suffix with a comment leader. The comment   */
comment|/* leader is placed before each line generated by the $Log keyword. This    */
comment|/* table is used to guess the proper comment leader from the working file's */
comment|/* suffix during initial ci (see InitAdmin()). Comment leaders are needed   */
comment|/* for languages without multiline comments; for others they are optional.  */
literal|"c"
block|,
literal|" * "
block|,
comment|/* C           */
literal|"h"
block|,
literal|" * "
block|,
comment|/* C-header    */
literal|"p"
block|,
literal|" * "
block|,
comment|/* pascal      */
literal|"sh"
block|,
literal|"# "
block|,
comment|/* shell       */
literal|"s"
block|,
literal|"# "
block|,
comment|/* assembler   */
literal|"r"
block|,
literal|"# "
block|,
comment|/* ratfor      */
literal|"e"
block|,
literal|"# "
block|,
comment|/* efl         */
literal|"l"
block|,
literal|" * "
block|,
comment|/* lex         NOTE: conflict between lex and franzlisp*/
literal|"y"
block|,
literal|" * "
block|,
comment|/* yacc        */
literal|"yr"
block|,
literal|" * "
block|,
comment|/* yacc-ratfor */
literal|"ye"
block|,
literal|" * "
block|,
comment|/* yacc-efl    */
literal|"ml"
block|,
literal|"; "
block|,
comment|/* mocklisp    */
literal|"mac"
block|,
literal|"; "
block|,
comment|/* macro       vms or dec-20 or pdp-11 macro */
literal|"f"
block|,
literal|"c "
block|,
comment|/* fortran     */
literal|"ms"
block|,
literal|"\\\" "
block|,
comment|/* ms-macros   t/nroff*/
literal|"me"
block|,
literal|"\\\" "
block|,
comment|/* me-macros   t/nroff*/
literal|""
block|,
literal|"# "
block|,
comment|/* default for empty suffix */
name|nil
block|,
literal|""
comment|/* default for unknown suffix; must always be last */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|ffclose
argument_list|(
argument|fptr
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: checks ferror(fptr) and aborts the program if there were  * errors; otherwise closes fptr.  */
end_comment

begin_block
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fptr
argument_list|)
operator|||
name|fclose
argument_list|(
name|fptr
argument_list|)
operator|==
name|EOF
condition|)
name|faterror
argument_list|(
literal|"File read or write error; file system full?"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|trysema
parameter_list|(
name|RCSfilename
parameter_list|,
name|makesema
parameter_list|)
name|char
modifier|*
name|RCSfilename
decl_stmt|;
name|int
name|makesema
decl_stmt|;
comment|/* Function: Checks whether a semaphore file exists for RCSfilename. If yes,  * returns false. If not, creates one if makesema==true and returns true  * if successful. If a semaphore file was created, madesema is set to true.  * The name of the semaphore file is put into variable semafilename.  */
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|int
name|fdesc
decl_stmt|;
name|sp
operator|=
name|RCSfilename
expr_stmt|;
name|lp
operator|=
name|rindex
argument_list|(
name|sp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
literal|0
condition|)
block|{
name|semafilename
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|semafilename
index|[
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
name|tp
operator|=
operator|&
name|semafilename
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* copy path */
name|tp
operator|=
name|semafilename
expr_stmt|;
do|do
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
do|while
condition|(
name|sp
operator|<=
name|lp
condition|)
do|;
block|}
comment|/*now insert `,' and append file name */
operator|*
name|tp
operator|++
operator|=
literal|','
expr_stmt|;
name|lp
operator|=
name|rindex
argument_list|(
name|sp
argument_list|,
name|RCSSEP
argument_list|)
expr_stmt|;
while|while
condition|(
name|sp
operator|<
name|lp
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|','
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* will be the same length as RCSfilename*/
name|madesema
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|semafilename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"RCS file %s is in use"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|makesema
condition|)
block|{
if|if
condition|(
operator|(
name|fdesc
operator|=
name|creat
argument_list|(
name|semafilename
argument_list|,
literal|000
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Can't create semaphore file for RCS file %s"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
name|close
argument_list|(
name|fdesc
argument_list|)
expr_stmt|;
name|madesema
operator|=
name|true
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|int
name|rmsema
parameter_list|()
comment|/* Function: delete the semaphore file if madeseam==true;  * sets madesema to false.  */
block|{
if|if
condition|(
name|madesema
condition|)
block|{
name|madesema
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|semafilename
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Can't find semaphore file %s"
argument_list|,
name|semafilename
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_macro
name|InitCleanup
argument_list|()
end_macro

begin_block
block|{
name|lastfilename
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* initialize pointer */
block|}
end_block

begin_macro
name|cleanup
argument_list|()
end_macro

begin_comment
comment|/* Function: closes input file and rewrite file.  * Unlinks files in tfnames[], deletes semaphore file.  */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|finptr
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|finptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|frewrite
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|frewrite
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|lastfilename
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tfnames
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|unlink
argument_list|(
name|tfnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|InitCleanup
argument_list|()
expr_stmt|;
return|return
operator|(
name|rmsema
argument_list|()
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|mktempfile
parameter_list|(
name|fullpath
parameter_list|,
name|filename
parameter_list|)
specifier|register
name|char
modifier|*
name|fullpath
decl_stmt|,
decl|*
name|filename
decl_stmt|;
end_function

begin_comment
comment|/* Function: Creates a unique filename using the process id and stores it  * into a free slot in tfnames. The filename consists of the path contained  * in fullpath concatenated with filename. filename should end in "XXXXXX".  * Because of storage in tfnames, cleanup() can unlink the file later.  * lastfilename indicates the highest occupied slot in tfnames.  * Returns a pointer to the filename created.  * Example use: mktempfile("/tmp/", somefilename)  */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|lastslash
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|lastfilename
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|tfnames
index|[
name|lastfilename
index|]
operator|)
operator|==
name|nil
condition|)
name|tp
operator|=
name|tfnames
index|[
name|lastfilename
index|]
operator|=
name|malloc
argument_list|(
name|NCPPN
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullpath
operator|!=
name|nil
operator|&&
operator|(
name|lastslash
operator|=
name|rindex
argument_list|(
name|fullpath
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* copy path */
while|while
condition|(
name|fullpath
operator|<=
name|lastslash
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|fullpath
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|tp
operator|++
operator|=
operator|*
name|filename
operator|++
condition|)
empty_stmt|;
return|return
operator|(
name|mktemp
argument_list|(
name|tfnames
index|[
name|lastfilename
index|]
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|bindex
parameter_list|(
name|sp
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
name|c
decl_stmt|;
comment|/* Function: Finds the last occurrence of character c in string sp  * and returns a pointer to the character just beyond it. If the  * character doesn't occur in the string, sp is returned.  */
block|{
specifier|register
name|char
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|sp
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|++
operator|==
name|c
condition|)
name|r
operator|=
name|sp
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_macro
name|InitAdmin
argument_list|()
end_macro

begin_comment
comment|/* function: initializes an admin node */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|Suffix
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|Head
operator|=
name|nil
expr_stmt|;
name|AccessList
operator|=
name|nil
expr_stmt|;
name|Symbols
operator|=
name|nil
expr_stmt|;
name|Locks
operator|=
name|nil
expr_stmt|;
name|StrictLocks
operator|=
name|STRICT_LOCKING
expr_stmt|;
comment|/* guess the comment leader from the suffix*/
name|Suffix
operator|=
name|bindex
argument_list|(
name|workfilename
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|Suffix
operator|==
name|workfilename
condition|)
name|Suffix
operator|=
literal|""
expr_stmt|;
comment|/* empty suffix; will get default*/
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|comtable
index|[
name|i
index|]
operator|.
name|suffix
operator|==
name|nil
condition|)
block|{
name|Comment
operator|=
name|comtable
index|[
name|i
index|]
operator|.
name|comlead
expr_stmt|;
comment|/*default*/
break|break;
block|}
name|elsif
argument_list|(
argument|strcmp(Suffix,comtable[i].suffix)==
literal|0
argument_list|)
block|{
name|Comment
operator|=
name|comtable
index|[
name|i
index|]
operator|.
name|comlead
expr_stmt|;
comment|/*default*/
break|break;
block|}
block|}
name|Lexinit
argument_list|()
expr_stmt|;
comment|/* Note: if finptr==NULL, reads nothing; only initializes*/
block|}
end_block

begin_function
name|char
modifier|*
name|findpairfile
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|fname
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|,
decl|*
name|fname
decl_stmt|;
end_function

begin_comment
comment|/* Function: Given a filename fname, findpairfile scans argv for a pathname  * ending in fname. If found, returns a pointer to the pathname, and sets  * the corresponding pointer in argv to nil. Otherwise returns fname.  * argc indicates the number of entries in argv. Some of them may be nil.  */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|next
decl_stmt|,
modifier|*
name|match
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
for|for
control|(
name|next
operator|=
name|argv
operator|,
name|count
operator|=
name|argc
init|;
name|count
operator|>
literal|0
condition|;
name|next
operator|++
operator|,
name|count
operator|--
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|next
operator|!=
name|nil
operator|)
operator|&&
name|strcmp
argument_list|(
name|bindex
argument_list|(
operator|*
name|next
argument_list|,
literal|'/'
argument_list|)
argument_list|,
name|fname
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* bindex finds the beginning of the file name stem */
name|match
operator|=
operator|*
name|next
expr_stmt|;
operator|*
name|next
operator|=
name|nil
expr_stmt|;
return|return
name|match
return|;
block|}
block|}
return|return
name|fname
return|;
block|}
end_block

begin_function
name|int
name|pairfilenames
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|mustread
parameter_list|,
name|tostdout
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|mustread
decl_stmt|,
name|tostdout
decl_stmt|;
comment|/* Function: Pairs the filenames pointed to by argv; argc indicates  * how many there are.  * Places a pointer to the RCS filename into RCSfilename,  * and a pointer to the name of the working file into workfilename.  * If both the workfilename and the RCS filename are given, and tostdout  * is true, a warning is printed.  *  * If the RCS file exists, it is opened for reading, the file pointer  * is placed into finptr, and the admin-node is read in; returns 1.  * If the RCS file does not exist and mustread==true, an error is printed  * and 0 returned.  * If the RCS file does not exist and mustread==false, the admin node  * is initialized to empty (Head, AccessList, Locks, Symbols, StrictLocks),  * and -1 returned.  *  * 0 is returned on all errors.  * Also calls InitCleanup();  */
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
name|lastsep
decl_stmt|,
modifier|*
name|purefname
decl_stmt|,
modifier|*
name|pureRCSname
decl_stmt|;
name|int
name|opened
decl_stmt|,
name|returncode
decl_stmt|;
name|char
modifier|*
name|RCS1
decl_stmt|;
if|if
condition|(
operator|*
name|argv
operator|==
name|nil
condition|)
return|return
literal|0
return|;
comment|/* already paired filename */
name|InitCleanup
argument_list|()
expr_stmt|;
comment|/* first check suffix to see whether it is an RCS file or not */
name|purefname
operator|=
name|bindex
argument_list|(
operator|*
name|argv
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* skip path */
name|lastsep
operator|=
name|rindex
argument_list|(
name|purefname
argument_list|,
name|RCSSEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastsep
operator|!=
literal|0
operator|&&
operator|*
operator|(
name|lastsep
operator|+
literal|1
operator|)
operator|==
name|RCSSUF
operator|&&
operator|*
operator|(
name|lastsep
operator|+
literal|2
operator|)
operator|==
literal|'\0'
condition|)
block|{
comment|/* RCS file name given*/
name|RCS1
operator|=
operator|(
operator|*
name|argv
operator|)
expr_stmt|;
name|pureRCSname
operator|=
name|purefname
expr_stmt|;
comment|/* derive workfilename*/
name|sp
operator|=
name|purefname
expr_stmt|;
name|tp
operator|=
name|tempfilename
expr_stmt|;
while|while
condition|(
name|sp
operator|<
name|lastsep
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
comment|/* try to find workfile name among arguments */
name|workfilename
operator|=
name|findpairfile
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
name|tempfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|pureRCSname
argument_list|)
operator|>
name|NCPFN
condition|)
block|{
name|error
argument_list|(
literal|"RCS file name %s too long"
argument_list|,
name|RCS1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* working file given; now try to find RCS file */
name|workfilename
operator|=
operator|*
name|argv
expr_stmt|;
comment|/* derive RCS file name*/
name|sp
operator|=
name|purefname
expr_stmt|;
name|tp
operator|=
name|tempfilename
expr_stmt|;
while|while
condition|(
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
condition|)
empty_stmt|;
operator|*
operator|(
name|tp
operator|-
literal|1
operator|)
operator|=
name|RCSSEP
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
name|RCSSUF
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Try to find RCS file name among arguments*/
name|RCS1
operator|=
name|findpairfile
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
name|tempfilename
argument_list|)
expr_stmt|;
name|pureRCSname
operator|=
name|bindex
argument_list|(
name|RCS1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|pureRCSname
argument_list|)
operator|>
name|NCPFN
condition|)
block|{
name|error
argument_list|(
literal|"working file name %s too long"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* now we have a (tentative) RCS filename in RCS1 and workfilename  */
if|if
condition|(
name|pureRCSname
operator|!=
name|RCS1
condition|)
block|{
comment|/* a path for RCSfile is given; single RCS file to look for */
name|finptr
operator|=
name|fopen
argument_list|(
name|RCSfilename
operator|=
name|RCS1
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|finptr
operator|!=
name|NULL
condition|)
block|{
name|Lexinit
argument_list|()
expr_stmt|;
name|getadmin
argument_list|()
expr_stmt|;
name|returncode
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* could not open */
if|if
condition|(
name|access
argument_list|(
name|RCSfilename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't open existing %s"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|mustread
condition|)
block|{
name|error
argument_list|(
literal|"Can't find %s"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* initialize if not mustread */
name|InitAdmin
argument_list|()
expr_stmt|;
name|returncode
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* build second RCS file name by prefixing it with RCSDIR*/
comment|/* then try to open one of them */
name|strcpy
argument_list|(
name|subfilename
argument_list|,
name|RCSDIR
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|subfilename
argument_list|,
name|RCS1
argument_list|)
expr_stmt|;
name|opened
operator|=
operator|(
operator|(
operator|(
name|finptr
operator|=
name|fopen
argument_list|(
name|RCSfilename
operator|=
name|subfilename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|finptr
operator|=
name|fopen
argument_list|(
name|RCSfilename
operator|=
name|RCS1
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|opened
condition|)
block|{
comment|/* open succeeded */
name|Lexinit
argument_list|()
expr_stmt|;
name|getadmin
argument_list|()
expr_stmt|;
name|returncode
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* open failed; may be read protected */
if|if
condition|(
operator|(
name|access
argument_list|(
name|RCSfilename
operator|=
name|subfilename
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|access
argument_list|(
name|RCSfilename
operator|=
name|RCS1
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Can't open existing %s"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|mustread
condition|)
block|{
name|error
argument_list|(
literal|"Can't find %s nor %s"
argument_list|,
name|subfilename
argument_list|,
name|RCS1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* initialize new file. Put into ./RCS if possible, strip off suffix*/
name|RCSfilename
operator|=
operator|(
name|access
argument_list|(
name|RCSDIR
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
condition|?
name|subfilename
else|:
name|RCS1
expr_stmt|;
name|InitAdmin
argument_list|()
expr_stmt|;
name|returncode
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tostdout
operator|&&
operator|!
operator|(
name|RCS1
operator|==
name|tempfilename
operator|||
name|workfilename
operator|==
name|tempfilename
operator|)
condition|)
comment|/*The last term determines whether a pair of        */
comment|/* file names was given in the argument list        */
name|warn
argument_list|(
literal|"Option -p is set; ignoring output file %s"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
return|return
name|returncode
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|getfullRCSname
parameter_list|()
comment|/* Function: returns a pointer to the full path name of the RCS file.  * Calls getwd(), but only once.  * removes leading "../" and "./".  */
block|{
specifier|static
name|char
name|pathbuf
index|[
name|NCPPN
index|]
decl_stmt|;
specifier|static
name|char
name|namebuf
index|[
name|NCPPN
index|]
decl_stmt|;
specifier|static
name|int
name|pathlength
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|realname
decl_stmt|,
modifier|*
name|lastpathchar
decl_stmt|;
specifier|register
name|int
name|dotdotcounter
decl_stmt|,
name|realpathlength
decl_stmt|;
if|if
condition|(
operator|*
name|RCSfilename
operator|==
literal|'/'
condition|)
block|{
return|return
operator|(
name|RCSfilename
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|pathlength
operator|==
literal|0
condition|)
block|{
comment|/*call curdir for the first time*/
if|if
condition|(
name|getwd
argument_list|(
name|pathbuf
argument_list|)
operator|==
name|NULL
condition|)
name|faterror
argument_list|(
literal|"Can't build current directory path"
argument_list|)
expr_stmt|;
name|pathlength
operator|=
name|strlen
argument_list|(
name|pathbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|pathlength
operator|==
literal|1
operator|)
operator|&&
operator|(
name|pathbuf
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
operator|)
condition|)
block|{
name|pathbuf
index|[
name|pathlength
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
comment|/* Check needed because some getwd implementations */
comment|/* generate "/" for the root.                      */
block|}
block|}
comment|/*the following must be redone since RCSfilename may change*/
comment|/* find how many ../ to remvove from RCSfilename */
name|dotdotcounter
operator|=
literal|0
expr_stmt|;
name|realname
operator|=
name|RCSfilename
expr_stmt|;
while|while
condition|(
name|realname
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|realname
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
operator|(
name|realname
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|realname
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|realname
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* drop leading ./ */
name|realname
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* drop leading ../ and remember */
name|dotdotcounter
operator|++
expr_stmt|;
name|realname
operator|+=
literal|3
expr_stmt|;
block|}
block|}
comment|/* now remove dotdotcounter trailing directories from pathbuf*/
name|lastpathchar
operator|=
name|pathbuf
operator|+
name|pathlength
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|dotdotcounter
operator|>
literal|0
operator|&&
name|lastpathchar
operator|>
name|pathbuf
condition|)
block|{
comment|/* move pointer backwards over trailing directory */
name|lastpathchar
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|lastpathchar
operator|==
literal|'/'
condition|)
block|{
name|dotdotcounter
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dotdotcounter
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't generate full path name for RCS file"
argument_list|)
expr_stmt|;
return|return
name|RCSfilename
return|;
block|}
else|else
block|{
comment|/* build full path name */
name|realpathlength
operator|=
name|lastpathchar
operator|-
name|pathbuf
operator|+
literal|1
expr_stmt|;
name|strncpy
argument_list|(
name|namebuf
argument_list|,
name|pathbuf
argument_list|,
name|realpathlength
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|namebuf
index|[
name|realpathlength
index|]
argument_list|,
name|realname
argument_list|)
expr_stmt|;
return|return
operator|(
name|namebuf
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|trydiraccess
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* checks write permission in directory of filename and returns  * true if writable, false otherwise  */
block|{
name|char
name|pathname
index|[
name|NCPPN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|lp
operator|=
name|rindex
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
literal|0
condition|)
block|{
comment|/* check current directory */
if|if
condition|(
name|access
argument_list|(
literal|"."
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
else|else
block|{
name|error
argument_list|(
literal|"Current directory not writable"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* copy path */
name|sp
operator|=
name|filename
expr_stmt|;
name|tp
operator|=
name|pathname
expr_stmt|;
do|do
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
do|while
condition|(
name|sp
operator|<=
name|lp
condition|)
do|;
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|pathname
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
else|else
block|{
name|error
argument_list|(
literal|"Directory %s not writable"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|V4_2BSD
end_ifndef

begin_comment
comment|/* rename() and getwd() will be provided in bsd 4.2 */
end_comment

begin_function
name|int
name|rename
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_comment
comment|/* Function: renames a file with the name given by from to the name given by to.  * unlinks the to-file if it already exists. returns -1 on error, 0 otherwise.  */
end_comment

begin_block
block|{
name|unlink
argument_list|(
name|to
argument_list|)
expr_stmt|;
comment|/* no need to check return code; will be caught by link*/
comment|/* no harm done if file "to" does not exist            */
if|if
condition|(
name|link
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|unlink
argument_list|(
name|from
argument_list|)
operator|)
return|;
block|}
end_block

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_define
define|#
directive|define
name|dot
value|"."
end_define

begin_define
define|#
directive|define
name|dotdot
value|".."
end_define

begin_function
name|char
modifier|*
name|getwd
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Function: places full pathname of current working directory into name and  * returns name on success, NULL on failure.  * getwd is an adaptation of pwd. May not return to the current directory on  * failure.  */
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
name|struct
name|stat
name|d
decl_stmt|,
name|dd
decl_stmt|;
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
comment|/* to NUL-terminate dir.d_name */
name|struct
name|direct
name|dir
decl_stmt|;
name|int
name|rdev
decl_stmt|,
name|rino
decl_stmt|;
name|int
name|off
decl_stmt|;
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|name
index|[
name|off
operator|=
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|stat
argument_list|(
literal|"/"
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|rdev
operator|=
name|d
operator|.
name|st_dev
expr_stmt|;
name|rino
operator|=
name|d
operator|.
name|st_ino
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|dot
argument_list|,
operator|&
name|d
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|d
operator|.
name|st_ino
operator|==
name|rino
operator|&&
name|d
operator|.
name|st_dev
operator|==
name|rdev
condition|)
block|{
if|if
condition|(
name|name
index|[
name|off
index|]
operator|==
literal|'/'
condition|)
name|name
index|[
name|off
index|]
operator|=
literal|'\0'
expr_stmt|;
name|chdir
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/*change back to current directory*/
return|return
name|name
return|;
block|}
if|if
condition|(
operator|(
name|file
operator|=
name|fopen
argument_list|(
name|dotdot
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|file
argument_list|)
argument_list|,
operator|&
name|dd
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
name|chdir
argument_list|(
name|dotdot
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|.
name|st_dev
operator|==
name|dd
operator|.
name|st_dev
condition|)
block|{
if|if
condition|(
name|d
operator|.
name|st_ino
operator|==
name|dd
operator|.
name|st_ino
condition|)
block|{
if|if
condition|(
name|name
index|[
name|off
index|]
operator|==
literal|'/'
condition|)
name|name
index|[
name|off
index|]
operator|=
literal|'\0'
expr_stmt|;
name|chdir
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/*change back to current directory*/
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
do|do
block|{
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dir
argument_list|,
sizeof|sizeof
argument_list|(
name|dir
argument_list|)
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|fail
goto|;
block|}
do|while
condition|(
name|dir
operator|.
name|d_ino
operator|!=
name|d
operator|.
name|st_ino
condition|)
do|;
block|}
else|else
do|do
block|{
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dir
argument_list|,
sizeof|sizeof
argument_list|(
name|dir
argument_list|)
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
operator|!=
literal|1
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
name|stat
argument_list|(
name|dir
operator|.
name|d_name
argument_list|,
operator|&
name|dd
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dd
operator|.
name|st_ino
operator|!=
name|d
operator|.
name|st_ino
operator|||
name|dd
operator|.
name|st_dev
operator|!=
name|d
operator|.
name|st_dev
condition|)
do|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* concatenate file name */
name|i
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|dir
operator|.
name|d_name
index|[
operator|++
name|i
index|]
operator|!=
literal|0
condition|)
empty_stmt|;
for|for
control|(
name|j
operator|=
name|off
operator|+
literal|1
init|;
name|j
operator|>
literal|0
condition|;
operator|--
name|j
control|)
name|name
index|[
name|j
operator|+
name|i
operator|+
literal|1
index|]
operator|=
name|name
index|[
name|j
index|]
expr_stmt|;
name|off
operator|=
name|i
operator|+
name|off
operator|+
literal|1
expr_stmt|;
name|name
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
for|for
control|(
operator|--
name|i
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|name
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|dir
operator|.
name|d_name
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* end for */
name|fail
label|:
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PAIRTEST
end_ifdef

begin_comment
comment|/* test program for pairfilenames() and getfullRCSname() */
end_comment

begin_decl_stmt
name|char
modifier|*
name|workfilename
decl_stmt|,
modifier|*
name|RCSfilename
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|int
name|initflag
decl_stmt|,
name|tostdout
decl_stmt|;
name|tostdout
operator|=
name|initflag
operator|=
name|false
expr_stmt|;
name|cmdid
operator|=
literal|"pair"
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|,
operator|++
name|argv
operator|,
name|argc
operator|>=
literal|1
operator|&&
operator|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'p'
case|:
name|tostdout
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|initflag
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
do|do
block|{
name|RCSfilename
operator|=
name|workfilename
operator|=
name|nil
expr_stmt|;
name|result
operator|=
name|pairfilenames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|!
name|initflag
argument_list|,
name|tostdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|diagnose
argument_list|(
literal|"RCSfile: %s; working file: %s"
argument_list|,
name|RCSfilename
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
name|diagnose
argument_list|(
literal|"Full RCS file name: %s"
argument_list|,
name|getfullRCSname
argument_list|()
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|result
condition|)
block|{
case|case
literal|0
case|:
continue|continue;
comment|/* already paired file */
case|case
literal|1
case|:
if|if
condition|(
name|initflag
condition|)
block|{
name|error
argument_list|(
literal|"RCS file exists already"
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|diagnose
argument_list|(
literal|"RCS file exists"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|-
literal|1
case|:
name|diagnose
argument_list|(
literal|"RCS file does not exist"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|++
name|argv
operator|,
operator|--
name|argc
operator|>=
literal|1
condition|)
do|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

