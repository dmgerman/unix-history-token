begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Control message handling code.  Deal with messages which are to be  * acted on by netnews itself rather than by people.  *  * See defs.h "news_version" for the real version of netnews.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)control.c	2.20	6/24/83 (this is NOT the netnews version!)"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"iparams.h"
end_include

begin_define
define|#
directive|define
name|eq
parameter_list|(
name|msg
parameter_list|)
value|(strcmp(msg, cargv[0]) == 0)
end_define

begin_decl_stmt
name|int
name|cargc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|cargv
decl_stmt|;
end_decl_stmt

begin_function_decl
name|FILE
modifier|*
name|hfopen
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|FILE
modifier|*
name|popen
argument_list|()
decl_stmt|,
modifier|*
name|mhopen
argument_list|()
decl_stmt|,
modifier|*
name|mailhdr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|senderof
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|control
argument_list|(
argument|h
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hbuf
modifier|*
name|h
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ctlmsgtext
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|h
operator|->
name|ctlmsg
condition|)
name|ctlmsgtext
operator|=
name|h
operator|->
name|ctlmsg
expr_stmt|;
else|else
name|ctlmsgtext
operator|=
name|h
operator|->
name|title
expr_stmt|;
name|log
argument_list|(
literal|"Ctl Msg %s from %s: %s"
argument_list|,
name|h
operator|->
name|nbuf
argument_list|,
name|h
operator|->
name|path
argument_list|,
name|ctlmsgtext
argument_list|)
expr_stmt|;
comment|/* 	 * Control messages have the standard format 	 *	command [args] 	 * much like shell commands.  Each site has the option 	 * of customizing this code to deal with control messages 	 * as they see fit, but we would like to buy back the 	 * code, ifdeffed or otherwise parameterized, to simplify 	 * the maintenence issues. 	 */
name|argparse
argument_list|(
name|ctlmsgtext
argument_list|)
expr_stmt|;
if|if
condition|(
name|eq
argument_list|(
literal|"ihave"
argument_list|)
condition|)
name|c_ihave
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
literal|"sendme"
argument_list|)
condition|)
name|c_sendme
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
literal|"newgroup"
argument_list|)
condition|)
name|c_newgroup
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
literal|"rmgroup"
argument_list|)
condition|)
name|c_rmgroup
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
literal|"cancel"
argument_list|)
condition|)
name|c_cancel
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
literal|"sendsys"
argument_list|)
condition|)
name|c_sendsys
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
literal|"senduuname"
argument_list|)
condition|)
name|c_senduuname
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
literal|"version"
argument_list|)
condition|)
name|c_version
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
literal|"delsub"
argument_list|)
condition|)
name|c_unimp
argument_list|(
name|cargc
argument_list|,
name|cargv
argument_list|)
expr_stmt|;
else|else
name|c_unknown
argument_list|(
name|h
argument_list|,
name|ctlmsgtext
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Parse the string str into separate words in cargc and cargv  * as per the usual UNIX convention.  Nothing fancy here, just  * blanks and tabs separating words.  */
end_comment

begin_macro
name|argparse
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
modifier|*
name|cavpbuf
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|char
name|cavbuf
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|nextfree
init|=
name|cavbuf
decl_stmt|;
if|if
condition|(
name|str
operator|==
literal|0
condition|)
name|xerror
argument_list|(
literal|"Control message %s has no title"
argument_list|,
name|header
operator|.
name|ident
argument_list|)
expr_stmt|;
name|cargc
operator|=
literal|0
expr_stmt|;
name|cargv
operator|=
name|cavpbuf
expr_stmt|;
name|cargv
index|[
literal|0
index|]
operator|=
name|cavbuf
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|<=
literal|' '
condition|)
block|{
operator|*
name|nextfree
operator|++
operator|=
literal|0
expr_stmt|;
name|cargc
operator|++
expr_stmt|;
name|cargv
index|[
name|cargc
index|]
operator|=
name|nextfree
expr_stmt|;
comment|/* skip over white space */
while|while
condition|(
operator|*
name|str
operator|>
literal|0
operator|&&
operator|*
name|str
operator|<=
literal|' '
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|0
condition|)
comment|/* line ends in white space */
return|return;
block|}
else|else
operator|*
name|nextfree
operator|++
operator|=
operator|*
name|str
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * ihave<artid><remotesys>  * The other system is telling you it has article<artid>, in case  * you decide you want it to transmit it to you.  */
end_comment

begin_macro
name|c_ihave
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|tl
index|[
literal|256
index|]
decl_stmt|,
name|ng
index|[
literal|256
index|]
decl_stmt|;
comment|/* 	 * Check that we haven't already seen it (history) 	 * and then send back a "sendme" message if we subscribe. 	 */
if|if
condition|(
name|history
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Should probably check SUBFILE and NGFILE here. */
name|sprintf
argument_list|(
name|tl
argument_list|,
literal|"sendme %s %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|SYSNAME
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ng
argument_list|,
literal|"to.%s.ctl"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|xmitmsg
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
name|tl
argument_list|,
name|ng
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * sendme<artid> ...<remotesys>  * The other system wants me to send him article<artid>.  */
end_comment

begin_macro
name|c_sendme
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|srec
name|srec
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* Find the sys record */
name|s_openr
argument_list|()
expr_stmt|;
while|while
condition|(
name|s_read
argument_list|(
operator|&
name|srec
argument_list|)
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|srec
operator|.
name|s_name
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|,
name|SNLN
argument_list|)
condition|)
continue|continue;
comment|/* It's the right one.  Send them. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
comment|/* transmit checks that other sys subscribes. */
name|fp
operator|=
name|hfopen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|transmit
argument_list|(
operator|&
name|srec
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* transmit does fclose(fp) */
block|}
return|return;
block|}
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"Cannot find system %s to send article %s to."
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * newgroup<groupname>  * A new newsgroup has been created.  * The body of the article, if present, is a description of the  * purpose of the newsgroup.  *  * Site dependent.  Should make very sure the directory has been  * created and properly owned.  Might want to update ngfile.  * Might want to notify the contact person for this installation.  * Default action is to create the newsgroup, if it doesn't already  * exist.  */
end_comment

begin_macro
name|c_newgroup
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|dirname
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|bfr
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|mknewsg
argument_list|(
name|bfr
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* update ngfile */
name|fd
operator|=
name|fopen
argument_list|(
name|NGFILE
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTIFY
comment|/* 	 * Sample code to notify the contact person. 	 * Probably should dig up the text of the article 	 * and enclose that, too.  It can be found in the 	 * file ARTICLE.  Also, there needs to be 	 * an automatic provision to help you add the newsgroup. 	 * 	 * Note that even if you take out the above call to mknewsg, 	 * the newsgroup will still be created by the first article 	 * that comes in on it by a different call to mknewsg in inews.c 	 * (But only if you have AUTONEWNG defined in defs.h, which we 	 * disrecommend.) 	 */
name|fd
operator|=
name|mailhdr
argument_list|(
name|NULL
argument_list|,
literal|"creation of new newsgroup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\nA new newsgroup called '%s' has been created by %s.\n\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
name|mclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * rmgroup<groupname>  * An old newsgroup is being cancelled on a network wide basis.  */
end_comment

begin_macro
name|c_rmgroup
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|char
modifier|*
name|groupname
decl_stmt|;
name|char
name|groupdir
index|[
literal|128
index|]
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|groupname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|verifyname
argument_list|(
name|groupname
argument_list|)
expr_stmt|;
if|if
condition|(
name|groupname
index|[
literal|0
index|]
operator|==
literal|'.'
operator|||
name|groupname
index|[
literal|0
index|]
operator|<=
literal|' '
condition|)
name|xerror
argument_list|(
literal|"Illegal group name in rmgroup"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|groupdir
argument_list|,
name|dirname
argument_list|(
name|groupname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|groupdir
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* 		 * If the group already is gone, it's a nonfatal error - we 		 * want to propagate the message anyway, since what probably 		 * happened is somebody locally already removed it. 		 */
name|log
argument_list|(
literal|"Cannot remove newsgroup '%s'"
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|NOTIFY
name|fd
operator|=
name|mailhdr
argument_list|(
name|NULL
argument_list|,
literal|"rmgroup control message"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|MANUALLY
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\nA newsgroup called '%s' has been removed by %s.\n\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"You may need to remove the directory %s by hand\n"
argument_list|,
name|dirname
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\n%s has requested that newsgroup %s be removed.\n"
argument_list|,
name|header
operator|.
name|path
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"You should remove it by hand\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|MANUALLY
comment|/* We let the shell do all the work.  See the rmgrp shell script. */
name|setuid
argument_list|(
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* otherwise it won't rmdir the dir */
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"rm -rf %s"
argument_list|,
name|groupdir
argument_list|)
expr_stmt|;
name|rc
operator|=
name|system
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"system(%s) status %d"
argument_list|,
name|bfr
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"cp %s /tmp/$$ ; sed '/^%s /d'</tmp/$$> %s ; rm /tmp/$$"
argument_list|,
name|ACTIVE
argument_list|,
name|groupname
argument_list|,
name|ACTIVE
argument_list|)
expr_stmt|;
name|rc
operator|=
name|system
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"system(%s) status %d"
argument_list|,
name|bfr
argument_list|,
name|rc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * cancel<artid>  * Cancel the named article  */
end_comment

begin_macro
name|c_cancel
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|rr
decl_stmt|,
modifier|*
name|ss
decl_stmt|,
modifier|*
name|poster
decl_stmt|;
name|char
modifier|*
name|findhist
parameter_list|()
function_decl|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|whatsisname
index|[
literal|150
index|]
decl_stmt|;
name|char
name|msgbuf
index|[
literal|256
index|]
decl_stmt|;
name|char
name|msgng
index|[
literal|64
index|]
decl_stmt|;
name|int
name|su
init|=
literal|0
decl_stmt|;
name|strcpy
argument_list|(
name|whatsisname
argument_list|,
name|senderof
argument_list|(
operator|&
name|header
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|msgng
argument_list|,
name|header
operator|.
name|nbuf
argument_list|)
expr_stmt|;
name|line
operator|=
name|findhist
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
condition|)
name|log
argument_list|(
literal|"Cancelling %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
block|{
name|log
argument_list|(
literal|"Can't cancel %s:  non-existent"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|index
argument_list|(
name|line
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|dirname
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|=
name|xfopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hread
argument_list|(
operator|&
name|header
argument_list|,
name|fp
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Article is garbled.\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uid
operator|==
name|ROOTID
operator|||
name|uid
operator|==
literal|0
operator|)
operator|&&
name|strncmp
argument_list|(
name|msgng
argument_list|,
literal|"to."
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|su
operator|=
literal|1
expr_stmt|;
name|poster
operator|=
name|senderof
argument_list|(
operator|&
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|su
operator|&&
name|strcmp
argument_list|(
name|whatsisname
argument_list|,
name|poster
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"Not contributor: posted by %s, and you are %s"
argument_list|,
name|poster
argument_list|,
name|whatsisname
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
block|}
name|cancel
argument_list|()
expr_stmt|;
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * sendsys	(no arguments)  *  * Mail the sys file to the person submitting the article.  * POLICY: the contents of your sys file are public information  * and as such, you should not change this code.  You may feel  * free to arrange for it to manually notify you, in the event  * that you want to do something to clean it up before it goes out.  * Secret sites on the net are expressly frowned on.  *   * The purpose of this command is for making a network map.  The  * details of your link and which newsgroups are forwarded are not  * important, in case you want to sanitize them.  Since the definition  * of USENET is those sites getting net.general, you can disable this  * on sites not getting net articles, but if you take out the list of  * forwarded newsgroups, and you have sites that only get local newsgroups,  * you should make this clear, or remove those sites from what you send out.  */
end_comment

begin_macro
name|c_sendsys
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|,
modifier|*
name|u
decl_stmt|;
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|NOTIFY
name|f
operator|=
name|mailhdr
argument_list|(
name|NULL
argument_list|,
literal|"sendsys control message"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n%s requested your sys file.\n"
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"It has been sent.\n"
argument_list|)
expr_stmt|;
name|mclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|f
operator|=
name|mailhdr
argument_list|(
operator|&
name|header
argument_list|,
literal|"Subject: response to your sendsys request\n\n"
argument_list|)
expr_stmt|;
name|u
operator|=
name|fopen
argument_list|(
name|SUBFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|u
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|u
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|mclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * senduuname	(no arguments)  *  * Run the "uuname" command and send it back to the person who submitted  * the article.  The purpose of this control message is for attempting to  * make a uucp net map.  *  * POLICY: If you view this information as not public (because you have  * a connection you consider secret, or know a site that considers itself  * secret) you can feel free to change this code in whatever way is  * appropriate, so long as it sends some response back to the sender.  If  * you don't run uucp, this code does not make sense, and so an error  * message (or garbage, such as "research") will be mailed back.  *  * If you wish to add or remove sites from the output of uuname, you  * may wish to use the euuname.sh shell script here.  */
end_comment

begin_macro
name|c_senduuname
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|,
modifier|*
name|u
decl_stmt|;
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|NOTIFY
name|fd
operator|=
name|mailhdr
argument_list|(
name|NULL
argument_list|,
literal|"uuname control message"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\n%s requested your uuname output\n"
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
name|mclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fd
operator|=
name|mailhdr
argument_list|(
operator|&
name|header
argument_list|,
literal|"response to your senduuname request"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UUPROG
if|if
condition|(
name|UUPROG
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|UUPROG
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|LIB
argument_list|,
name|UUPROG
argument_list|)
expr_stmt|;
else|#
directive|else
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"uuname"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|u
operator|=
name|popen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|NULL
operator|&&
name|u
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|u
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|mclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Send the version number to the right person.  */
end_comment

begin_macro
name|c_version
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|mailhdr
argument_list|(
operator|&
name|header
argument_list|,
literal|"Our news version"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot send back error message"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nCurrently running news version %s.\n\n"
argument_list|,
name|news_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"The header of your message follows:\n"
argument_list|)
expr_stmt|;
name|hwrite
argument_list|(
operator|&
name|header
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|mclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * An unknown control message has been received.  */
end_comment

begin_macro
name|c_unknown
argument_list|(
argument|h
argument_list|,
argument|ctlmsgtext
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hbuf
modifier|*
name|h
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ctlmsgtext
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|log
argument_list|(
literal|"UNKNOWN Ctl Msg %s from %s"
argument_list|,
name|ctlmsgtext
argument_list|,
name|h
operator|->
name|path
argument_list|)
expr_stmt|;
name|f
operator|=
name|mailhdr
argument_list|(
name|h
argument_list|,
literal|"Unrecognized Control Message"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot send back error message"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Currently running news B version %s.\n\n"
argument_list|,
name|news_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"The header of the message follows:\n"
argument_list|)
expr_stmt|;
name|hwrite
argument_list|(
name|h
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|mclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|c_unimp
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|f
operator|=
name|mailhdr
argument_list|(
operator|&
name|header
argument_list|,
literal|"Unimplemented Control Message"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot send back error message"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Currently running news B version %s.\n\n"
argument_list|,
name|news_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"The header of the message follows:\n"
argument_list|)
expr_stmt|;
name|hwrite
argument_list|(
operator|&
name|header
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|mclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|xmitmsg
argument_list|(
argument|tosys
argument_list|,
argument|title
argument_list|,
argument|ng
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|tosys
decl_stmt|,
modifier|*
name|title
decl_stmt|,
modifier|*
name|ng
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|hbuf
name|h
decl_stmt|;
name|struct
name|srec
name|srec
decl_stmt|;
name|FILE
modifier|*
name|tfp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* Make an article called ARTICLE */
name|sprintf
argument_list|(
name|h
operator|.
name|from
argument_list|,
literal|"%s@%s%s"
argument_list|,
literal|"usenet"
argument_list|,
name|FULLSYSNAME
argument_list|,
name|MYDOMAIN
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|h
operator|.
name|path
argument_list|,
name|NEWSU
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|h
operator|.
name|nbuf
argument_list|,
name|ng
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|h
operator|.
name|title
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|h
operator|.
name|ctlmsg
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|h
operator|.
name|subdate
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|h
operator|.
name|recdate
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|h
operator|.
name|expdate
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|getident
argument_list|(
operator|&
name|h
argument_list|)
expr_stmt|;
name|dates
argument_list|(
operator|&
name|h
argument_list|)
expr_stmt|;
name|tfp
operator|=
name|xfopen
argument_list|(
name|fname
operator|=
name|mktemp
argument_list|(
literal|"/tmp/xmsgXXXXXX"
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|hwrite
argument_list|(
operator|&
name|h
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
comment|/* Find the sys record */
name|s_openr
argument_list|()
expr_stmt|;
while|while
condition|(
name|s_read
argument_list|(
operator|&
name|srec
argument_list|)
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|srec
operator|.
name|s_name
argument_list|,
name|tosys
argument_list|,
name|SNLN
argument_list|)
condition|)
continue|continue;
name|tfp
operator|=
name|xfopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|transmit
argument_list|(
operator|&
name|srec
argument_list|,
name|tfp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
name|log
argument_list|(
literal|"Can't find sys record for %s"
argument_list|,
name|tosys
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
literal|"Cannot find sys record"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This is a modified version of popen, made more secure.  Rather than  * forking off a shell, you get a bare process.  You must have exactly  * one argument, and the command must be mail.  */
end_comment

begin_comment
comment|/* @(#)popen.c	4.1 (Berkeley) 12/21/80 */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_define
define|#
directive|define
name|RDR
value|0
end_define

begin_define
define|#
directive|define
name|WTR
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|mopen_pid
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|replyname
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|FILE
modifier|*
name|mhopen
parameter_list|(
name|hptr
parameter_list|)
name|struct
name|hbuf
modifier|*
name|hptr
decl_stmt|;
block|{
name|int
name|p
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|myside
operator|,
name|hisside
operator|,
name|pid
expr_stmt|;
name|char
modifier|*
name|sendto
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|hptr
condition|)
name|sendto
operator|=
name|replyname
argument_list|(
name|hptr
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|NOTIFY
if|if
condition|(
name|TELLME
operator|&&
operator|*
name|TELLME
condition|)
name|sendto
operator|=
name|TELLME
expr_stmt|;
endif|#
directive|endif
endif|NOTIFY
if|if
condition|(
name|sendto
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|verifyname
argument_list|(
name|sendto
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|myside
operator|=
name|p
index|[
name|WTR
index|]
expr_stmt|;
name|hisside
operator|=
name|p
index|[
name|RDR
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* myside and hisside reverse roles in child */
name|close
argument_list|(
name|myside
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|hisside
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|hisside
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/mail"
argument_list|,
literal|"mail"
argument_list|,
name|sendto
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/bin/mail"
argument_list|,
literal|"mail"
argument_list|,
name|sendto
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/ucb/mail"
argument_list|,
literal|"mail"
argument_list|,
name|sendto
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
name|mopen_pid
index|[
name|myside
index|]
operator|=
name|pid
expr_stmt|;
name|close
argument_list|(
name|hisside
argument_list|)
expr_stmt|;
return|return
operator|(
name|fdopen
argument_list|(
name|myside
argument_list|,
literal|"w"
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|mclose
argument_list|(
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|f
operator|,
name|r
operator|,
call|(
modifier|*
name|hstat
call|)
argument_list|()
operator|,
call|(
modifier|*
name|istat
call|)
argument_list|()
operator|,
call|(
modifier|*
name|qstat
call|)
argument_list|()
expr_stmt|;
name|int
name|status
decl_stmt|;
name|f
operator|=
name|fileno
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|qstat
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|hstat
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|mopen_pid
index|[
name|f
index|]
operator|&&
name|r
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|hstat
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * mhopen a pipe to mail, write out a std header, and return the file ptr.  *  * We don't include a From: field because this is probably uucp, i.e.  * explicitly routed.  Leave it up to the recipient's mailer.  * Always include the To: field because if we ge back failed mail, we  * might be able to deliver it by hand if we know to wom it was addressed.  * By convention, hptr==NULL means to send the message to the local contact person.  */
end_comment

begin_function
name|FILE
modifier|*
name|mailhdr
parameter_list|(
name|hptr
parameter_list|,
name|subject
parameter_list|)
name|char
modifier|*
name|subject
decl_stmt|;
name|struct
name|hbuf
modifier|*
name|hptr
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|char
modifier|*
name|to
init|=
literal|"nobody"
decl_stmt|;
if|if
condition|(
name|hptr
condition|)
name|to
operator|=
name|replyname
argument_list|(
name|hptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTIFY
if|if
condition|(
name|TELLME
operator|&&
operator|*
name|TELLME
condition|)
name|to
operator|=
name|TELLME
expr_stmt|;
endif|#
directive|endif
endif|NOTIFY
if|if
condition|(
operator|(
name|fp
operator|=
name|mhopen
argument_list|(
name|hptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Date: %s\n"
argument_list|,
name|arpadate
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"To: %s\n"
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Subject: %s\n"
argument_list|,
name|subject
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Responding-System: %s%s\n"
argument_list|,
name|SYSNAME
argument_list|,
name|MYDOMAIN
argument_list|)
expr_stmt|;
block|}
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/*  * verify that the name mail is being sent to does not contain any  * nasty hooks to invoke funny functions from the shell or the like.  */
end_comment

begin_macro
name|verifyname
argument_list|(
argument|sendto
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sendto
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Be sure we DO allow alphabetics, !, :, ., -, @. *. */
name|char
modifier|*
name|nasty
init|=
literal|"\"'\\`^|;&<>/~"
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|sendto
index|[
literal|0
index|]
operator|<=
literal|' '
condition|)
block|{
name|log
argument_list|(
literal|"nasty mail name %s from %s"
argument_list|,
name|sendto
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|sendto
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
operator|*
name|nasty
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
name|sendto
argument_list|,
operator|*
name|nasty
operator|++
argument_list|)
condition|)
block|{
name|log
argument_list|(
literal|"nasty mail name %s from %s"
argument_list|,
name|sendto
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|nasty
operator|=
name|sendto
init|;
operator|(
name|nasty
operator|=
name|index
argument_list|(
name|nasty
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|++
name|nasty
operator|==
literal|'.'
condition|)
block|{
comment|/* check for .. */
name|log
argument_list|(
literal|"nasty mail name %s from %s"
argument_list|,
name|sendto
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Checks to make sure the control message is OK to post.  */
end_comment

begin_macro
name|ctlcheck
argument_list|()
end_macro

begin_block
block|{
name|char
name|msg
index|[
literal|150
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|is_ctl
condition|)
return|return;
if|if
condition|(
name|header
operator|.
name|ctlmsg
index|[
literal|0
index|]
condition|)
name|strcpy
argument_list|(
name|msg
argument_list|,
name|header
operator|.
name|ctlmsg
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|msg
argument_list|,
name|header
operator|.
name|title
argument_list|)
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|msg
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"ihave"
argument_list|)
operator|==
literal|0
condition|)
block|{ 	}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"sendme"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
comment|/* no restrictions */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"newgroup"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|suser
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"rmgroup"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|suser
argument_list|()
expr_stmt|;
name|checkpass
argument_list|(
literal|"mTnyckAVEMXWk"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"sendsys"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|suser
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"senduuname"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|suser
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"version"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
comment|/* no restrictions */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"cancel"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
comment|/* no restrictions at this level */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|msg
argument_list|,
literal|"delsub"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|prefix
argument_list|(
name|header
operator|.
name|nbuf
argument_list|,
literal|"to."
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Must be in a 'to.system' newsgroup."
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Unrecognized control message - %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Make sure this guy is special. */
end_comment

begin_macro
name|suser
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|uid
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|uid
operator|==
name|ROOTID
condition|)
return|return;
comment|/* 	 * We assume that since our real uid is the same as NEWSUSR 	 * (the euid) we were run by rootid and it did a setuid. 	 * Too bad we can't set just the effective uid like suid does. 	 */
if|if
condition|(
name|uid
operator|==
name|geteuid
argument_list|()
condition|)
return|return;
ifdef|#
directive|ifdef
name|IHCC
name|printf
argument_list|(
literal|"Please use the command:\n\ttoolnews providers\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"then call one of the news people.\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"Get your local netnews contact to do it for you.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Demand a password from the user.  */
end_comment

begin_macro
name|checkpass
argument_list|(
argument|encpw
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|encpw
argument_list|,
name|crypt
argument_list|(
name|getpass
argument_list|(
literal|"Password:"
argument_list|)
argument_list|,
literal|"mT"
argument_list|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Sorry\n"
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

