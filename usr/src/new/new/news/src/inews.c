begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * inews - insert, receive, and transmit news articles.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)inews.c	2.30	6/24/83"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"iparams.h"
end_include

begin_comment
comment|/* local defines for inews */
end_comment

begin_define
define|#
directive|define
name|OPTION
value|0
end_define

begin_comment
comment|/* pick up an option string */
end_comment

begin_define
define|#
directive|define
name|STRING
value|1
end_define

begin_comment
comment|/* pick up a string of arguments */
end_comment

begin_define
define|#
directive|define
name|UNKNOWN
value|0001
end_define

begin_comment
comment|/* possible modes for news program */
end_comment

begin_define
define|#
directive|define
name|UNPROC
value|0002
end_define

begin_comment
comment|/* Unprocessed input */
end_comment

begin_define
define|#
directive|define
name|PROC
value|0004
end_define

begin_comment
comment|/* Processed input */
end_comment

begin_define
define|#
directive|define
name|CANCEL
value|0010
end_define

begin_comment
comment|/* Cancel an article */
end_comment

begin_define
define|#
directive|define
name|CREATENG
value|0020
end_define

begin_comment
comment|/* Create a new newsgroup */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYSBUF
end_ifndef

begin_decl_stmt
name|char
name|SYSBUF
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to buffer std out */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|forgedname
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A user specified -f option. */
end_comment

begin_struct
struct|struct
block|{
comment|/* options table. */
name|char
name|optlet
decl_stmt|;
comment|/* option character. */
name|char
name|filchar
decl_stmt|;
comment|/* if to pickup string, fill character. */
name|int
name|flag
decl_stmt|;
comment|/* TRUE if have seen this opt. */
name|int
name|oldmode
decl_stmt|;
comment|/* OR of legal input modes. */
name|int
name|newmode
decl_stmt|;
comment|/* output mode. */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* string buffer */
block|}
modifier|*
name|optpt
struct|,
name|options
index|[]
init|=
block|{
comment|/* optlet	filchar		flag	oldmode	newmode		buf	*/
literal|'t'
block|,
literal|' '
block|,
name|FALSE
block|,
name|UNPROC
block|,
name|UNKNOWN
block|,
name|header
operator|.
name|title
block|,
literal|'n'
block|,
name|NGDELIM
block|,
name|FALSE
block|,
name|UNPROC
block|,
name|UNKNOWN
block|,
name|header
operator|.
name|nbuf
block|,
literal|'e'
block|,
literal|' '
block|,
name|FALSE
block|,
name|UNPROC
block|,
name|UNKNOWN
block|,
name|header
operator|.
name|expdate
block|,
literal|'p'
block|,
literal|'\0'
block|,
name|FALSE
block|,
name|UNKNOWN
block|,
name|PROC
block|,
name|filename
block|,
literal|'f'
block|,
literal|'\0'
block|,
name|FALSE
block|,
name|UNPROC
block|,
name|UNKNOWN
block|,
name|forgedname
block|,
literal|'F'
block|,
literal|' '
block|,
name|FALSE
block|,
name|UNPROC
block|,
name|UNKNOWN
block|,
name|header
operator|.
name|followid
block|,
literal|'c'
block|,
literal|'\0'
block|,
name|FALSE
block|,
name|UNKNOWN
block|,
name|CANCEL
block|,
name|filename
block|,
literal|'C'
block|,
literal|'\0'
block|,
name|FALSE
block|,
name|UNKNOWN
block|,
name|CREATENG
block|,
name|header
operator|.
name|nbuf
block|,
define|#
directive|define
name|Dflag
value|options[8].flag
literal|'D'
block|,
literal|'\0'
block|,
name|FALSE
block|,
name|UNPROC
block|,
name|UNKNOWN
block|,
name|filename
block|,
define|#
directive|define
name|hflag
value|options[9].flag
literal|'h'
block|,
literal|'\0'
block|,
name|FALSE
block|,
name|UNPROC
block|,
name|UNKNOWN
block|,
name|filename
block|,
literal|'\0'
block|,
literal|'\0'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
struct|;
end_struct

begin_function_decl
name|FILE
modifier|*
name|mailhdr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  *	Authors:  *		Matt Glickman	glickman@ucbarpa.Berkeley.ARPA  *		Mark Horton	mark@cbosgd.UUCP  *		Stephen Daniels	swd@mcnc.UUCP  *		Tom Truscott	trt@duke.UUCP  *	IHCC version adapted by:  *		Larry Marek	larry@ihuxf.UUCP  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|state
decl_stmt|;
comment|/* which type of argument to pick up	*/
name|int
name|tlen
decl_stmt|,
name|len
decl_stmt|;
comment|/* temps for string processing routine	*/
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* pointer to rest of buffer		*/
name|int
name|filchar
decl_stmt|;
comment|/* fill character (state = STRING)	*/
name|char
modifier|*
name|user
decl_stmt|,
modifier|*
name|home
decl_stmt|;
comment|/* environment temps			*/
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
comment|/* struct for pw lookup			*/
name|struct
name|group
modifier|*
name|gp
decl_stmt|;
comment|/* struct for group lookup		*/
name|struct
name|srec
name|srec
decl_stmt|;
comment|/* struct for sys file lookup		*/
name|struct
name|utsname
name|ubuf
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|mfd
decl_stmt|;
comment|/* mail file file-descriptor		*/
name|char
name|cbuf
index|[
name|BUFLEN
index|]
decl_stmt|;
comment|/* command buffer			*/
comment|/* uuxqt doesn't close all it's files */
for|for
control|(
name|i
operator|=
literal|3
init|;
operator|!
name|close
argument_list|(
name|i
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* set up defaults and initialize. */
name|mode
operator|=
name|UNKNOWN
expr_stmt|;
name|pathinit
argument_list|()
expr_stmt|;
name|ptr
operator|=
name|rindex
argument_list|(
operator|*
name|argv
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|ptr
operator|=
operator|*
name|argv
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
literal|"rnews"
argument_list|,
literal|5
argument_list|)
condition|)
name|mode
operator|=
name|PROC
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
goto|goto
name|usage
goto|;
name|state
operator|=
name|OPTION
expr_stmt|;
name|header
operator|.
name|title
index|[
literal|0
index|]
operator|=
name|header
operator|.
name|nbuf
index|[
literal|0
index|]
operator|=
name|filename
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* check for existence of special files */
if|if
condition|(
operator|!
name|rwaccess
argument_list|(
name|ARTFILE
argument_list|)
condition|)
block|{
name|mfd
operator|=
name|mailhdr
argument_list|(
name|NULL
argument_list|,
name|exists
argument_list|(
name|ARTFILE
argument_list|)
condition|?
literal|"Unwritable files!"
else|:
literal|"Missing files!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfd
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|mfd
argument_list|,
literal|"System: %s\n\nThere was a problem with %s!!\n"
argument_list|,
name|SYSNAME
argument_list|,
name|ARTFILE
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cbuf
argument_list|,
literal|"touch %s;chmod 666 %s"
argument_list|,
name|ARTFILE
argument_list|,
name|ARTFILE
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rwaccess
argument_list|(
name|ARTFILE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|mfd
argument_list|,
literal|"The problem has been taken care of.\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|mfd
argument_list|,
literal|"Corrective action failed - check suid bits.\n"
argument_list|)
expr_stmt|;
name|mclose
argument_list|(
name|mfd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|rwaccess
argument_list|(
name|ACTIVE
argument_list|)
condition|)
block|{
name|mfd
operator|=
name|mailhdr
argument_list|(
name|NULL
argument_list|,
name|exists
argument_list|(
name|ACTIVE
argument_list|)
condition|?
literal|"Unwritable files!"
else|:
literal|"Missing files!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfd
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|mfd
argument_list|,
literal|"System: %s\n\nThere was a problem with %s!!\n"
argument_list|,
name|SYSNAME
argument_list|,
name|ACTIVE
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cbuf
argument_list|,
literal|"touch %s;chmod 666 %s"
argument_list|,
name|ACTIVE
argument_list|,
name|ACTIVE
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rwaccess
argument_list|(
name|ACTIVE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|mfd
argument_list|,
literal|"The problem has been taken care of.\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|mfd
argument_list|,
literal|"Corrective action failed - check suid bits.\n"
argument_list|)
expr_stmt|;
name|mclose
argument_list|(
name|mfd
argument_list|)
expr_stmt|;
block|}
block|}
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|SYSBUF
argument_list|)
expr_stmt|;
name|sigtrap
operator|=
name|FALSE
expr_stmt|;
comment|/* true if a signal has been caught */
comment|/* 	signal(SIGQUIT, SIG_IGN); */
if|if
condition|(
name|mode
operator|!=
name|PROC
condition|)
block|{
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|onsig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onsig
argument_list|)
expr_stmt|;
block|}
name|savmask
operator|=
name|umask
argument_list|(
name|N_UMASK
argument_list|)
expr_stmt|;
comment|/* set up mask */
name|uid
operator|=
operator|(
name|unsigned
operator|)
name|getuid
argument_list|()
expr_stmt|;
name|gid
operator|=
operator|(
name|unsigned
operator|)
name|getgid
argument_list|()
expr_stmt|;
name|duid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|dgid
operator|=
name|getegid
argument_list|()
expr_stmt|;
if|if
condition|(
name|uid
operator|==
literal|0
operator|&&
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Must go through with this kludge since 		 * some systems do not honor the setuid bit 		 * when root invokes a setuid program. 		 */
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|NEWSU
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot get NEWSU pw entry"
argument_list|)
expr_stmt|;
name|duid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
if|if
condition|(
operator|(
name|gp
operator|=
name|getgrnam
argument_list|(
name|NEWSG
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot get NEWSG gr entry"
argument_list|)
expr_stmt|;
name|dgid
operator|=
name|gp
operator|->
name|gr_gid
expr_stmt|;
name|setuid
argument_list|(
name|duid
argument_list|)
expr_stmt|;
name|setgid
argument_list|(
name|dgid
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|IHCC
comment|/* 	 * We force the use of 'getuser()' to prevent forgery of articles 	 * by just changing $LOGNAME 	 */
if|if
condition|(
operator|(
name|user
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|user
operator|=
name|getenv
argument_list|(
literal|"LOGNAME"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|home
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|home
operator|=
name|getenv
argument_list|(
literal|"LOGDIR"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|user
operator|==
name|NULL
operator|||
name|home
operator|==
name|NULL
condition|)
name|getuser
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|username
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|username
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|userhome
argument_list|,
name|home
argument_list|)
expr_stmt|;
block|}
name|getuser
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|whatever
argument_list|,
name|username
argument_list|)
expr_stmt|;
comment|/* loop once per arg. */
operator|++
name|argv
expr_stmt|;
comment|/* skip first arg, which is prog name. */
while|while
condition|(
operator|--
name|argc
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|OPTION
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|argv
operator|!=
literal|'-'
condition|)
block|{
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"Bad option string \"%s\""
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
operator|++
operator|*
name|argv
operator|!=
literal|'\0'
condition|)
block|{
for|for
control|(
name|optpt
operator|=
name|options
init|;
name|optpt
operator|->
name|optlet
operator|!=
literal|'\0'
condition|;
operator|++
name|optpt
control|)
block|{
if|if
condition|(
name|optpt
operator|->
name|optlet
operator|==
operator|*
operator|*
name|argv
condition|)
goto|goto
name|found
goto|;
block|}
comment|/* unknown option letter */
name|usage
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: inews -t title"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" [ -n newsgroups ]"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" [ -e expiration date ]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t[ -f sender]\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"       inews -p [ filename ]\n"
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|found
label|:
empty_stmt|;
if|if
condition|(
name|optpt
operator|->
name|flag
operator|==
name|TRUE
operator|||
operator|(
name|mode
operator|!=
name|UNKNOWN
operator|&&
operator|(
name|mode
operator|&
name|optpt
operator|->
name|oldmode
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"Bad %c option"
argument_list|,
operator|*
operator|*
name|argv
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|UNKNOWN
condition|)
name|mode
operator|=
name|optpt
operator|->
name|newmode
expr_stmt|;
name|filchar
operator|=
name|optpt
operator|->
name|filchar
expr_stmt|;
name|optpt
operator|->
name|flag
operator|=
name|TRUE
expr_stmt|;
name|state
operator|=
name|STRING
expr_stmt|;
name|ptr
operator|=
name|optpt
operator|->
name|buf
expr_stmt|;
name|len
operator|=
name|BUFLEN
expr_stmt|;
block|}
name|argv
operator|++
expr_stmt|;
comment|/* done with this option arg. */
block|}
else|else
block|{
comment|/* 		 * Pick up a piece of a string and put it into 		 * the appropriate buffer. 		 */
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
name|state
operator|=
name|OPTION
expr_stmt|;
name|argc
operator|++
expr_stmt|;
comment|/* uncount this arg. */
continue|continue;
block|}
if|if
condition|(
operator|(
name|tlen
operator|=
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
operator|)
operator|>=
name|len
condition|)
name|xerror
argument_list|(
literal|"Argument string too long"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ptr
argument_list|,
operator|*
name|argv
operator|++
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|tlen
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|ptr
operator|-
literal|1
operator|)
operator|!=
name|filchar
condition|)
operator|*
name|ptr
operator|++
operator|=
name|filchar
expr_stmt|;
name|len
operator|-=
name|tlen
operator|+
literal|1
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
comment|/* 	 * ALL of the command line has now been processed. (!) 	 */
name|tty
operator|=
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Dflag
operator|&&
name|mode
operator|!=
name|PROC
operator|&&
name|mode
operator|!=
name|CREATENG
condition|)
block|{
if|if
condition|(
name|recording
argument_list|(
name|header
operator|.
name|nbuf
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|tty
condition|)
name|fwait
argument_list|(
name|fsubr
argument_list|(
name|newssave
argument_list|,
name|stdin
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
literal|"aborted due to recording"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* This code is really intended to be replaced by the control message. */
if|if
condition|(
name|mode
operator|==
name|CANCEL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|xfopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|hread
argument_list|(
operator|&
name|header
argument_list|,
name|f
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|header
operator|.
name|path
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|header
operator|.
name|path
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|whatever
argument_list|,
name|p
argument_list|,
name|strlen
argument_list|(
name|whatever
argument_list|)
argument_list|)
operator|&&
name|uid
operator|!=
name|ROOTID
operator|&&
name|uid
operator|!=
name|geteuid
argument_list|()
operator|&&
name|uid
condition|)
name|xerror
argument_list|(
literal|"Not contributor"
argument_list|)
expr_stmt|;
name|cancel
argument_list|()
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|header
operator|.
name|nbuf
condition|)
name|lcase
argument_list|(
name|header
operator|.
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|PROC
condition|)
block|{
name|getident
argument_list|(
operator|&
name|header
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MYORG
name|strcpy
argument_list|(
name|header
operator|.
name|organization
argument_list|,
name|MYORG
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|header
operator|.
name|organization
argument_list|,
literal|"Frobozz"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|header
operator|.
name|organization
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ptr
operator|=
name|getenv
argument_list|(
literal|"ORGANIZATION"
argument_list|)
condition|)
name|strcpy
argument_list|(
name|header
operator|.
name|organization
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* 		 * Note that the organization can also be turned off by 		 * setting it to the null string, either in MYORG or 		 * $ORGANIZATION in the environment. 		 */
if|if
condition|(
name|header
operator|.
name|organization
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|mfd
operator|=
name|fopen
argument_list|(
name|header
operator|.
name|organization
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfd
condition|)
block|{
name|fgets
argument_list|(
name|header
operator|.
name|organization
argument_list|,
sizeof|sizeof
name|header
operator|.
name|organization
argument_list|,
name|mfd
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|mfd
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|=
name|index
argument_list|(
name|header
operator|.
name|organization
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|hflag
condition|)
block|{
comment|/* Fill in a few to make frmread return TRUE */
name|strcpy
argument_list|(
name|header
operator|.
name|subdate
argument_list|,
literal|"today"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|header
operator|.
name|path
argument_list|,
literal|"me"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|header
operator|.
name|oident
argument_list|,
literal|"id"
argument_list|)
expr_stmt|;
comment|/* Allow the user to supply some headers. */
name|hread
argument_list|(
operator|&
name|header
argument_list|,
name|stdin
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* But there are certain fields we won't let him specify. */
if|if
condition|(
name|header
operator|.
name|from
condition|)
name|strcpy
argument_list|(
name|forgedname
argument_list|,
name|header
operator|.
name|from
argument_list|)
expr_stmt|;
name|header
operator|.
name|from
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|header
operator|.
name|path
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|header
operator|.
name|subdate
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|header
operator|.
name|sender
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|header
operator|.
name|oident
argument_list|,
literal|"id"
argument_list|)
operator|==
literal|0
condition|)
name|header
operator|.
name|oident
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ngcat
argument_list|(
name|header
operator|.
name|nbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|forgedname
index|[
literal|0
index|]
condition|)
block|{
name|strcpy
argument_list|(
name|header
operator|.
name|from
argument_list|,
name|forgedname
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|header
operator|.
name|sender
argument_list|,
literal|"%s@%s%s"
argument_list|,
name|username
argument_list|,
name|SYSNAME
argument_list|,
name|MYDOMAIN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gensender
argument_list|(
operator|&
name|header
argument_list|,
name|username
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|header
operator|.
name|postversion
argument_list|,
name|genversion
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* Authorize newsgroups. */
if|if
condition|(
name|mode
operator|==
name|PROC
condition|)
block|{
name|checkbatch
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|hread
argument_list|(
operator|&
name|header
argument_list|,
name|stdin
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Inbound news is garbled"
argument_list|)
expr_stmt|;
name|input
argument_list|()
expr_stmt|;
if|if
condition|(
name|history
argument_list|(
operator|&
name|header
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Duplicate article %s rejected\n"
argument_list|,
name|header
operator|.
name|ident
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"Duplicate article %s rejected"
argument_list|,
name|header
operator|.
name|ident
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|ngcat
argument_list|(
name|header
operator|.
name|nbuf
argument_list|)
expr_stmt|;
comment|/* Easy way to make control messages, since all.all.ctl is unblessed */
if|if
condition|(
name|mode
operator|!=
name|PROC
operator|&&
name|prefix
argument_list|(
name|header
operator|.
name|title
argument_list|,
literal|"cmsg "
argument_list|)
operator|&&
name|header
operator|.
name|ctlmsg
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|header
operator|.
name|ctlmsg
argument_list|,
operator|&
name|header
operator|.
name|title
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|is_ctl
operator|=
name|mode
operator|!=
name|CREATENG
operator|&&
operator|(
name|ngmatch
argument_list|(
name|header
operator|.
name|nbuf
argument_list|,
literal|"all.all.ctl,"
argument_list|)
operator|||
name|header
operator|.
name|ctlmsg
index|[
literal|0
index|]
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"is_ctl set to %d\n"
argument_list|,
name|is_ctl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Must end in comma (NGDELIM) */
define|#
directive|define
name|MODGROUPS
value|"mod.all,all.mod,all.announce,"
if|if
condition|(
name|ngmatch
argument_list|(
name|header
operator|.
name|nbuf
argument_list|,
name|MODGROUPS
argument_list|)
operator|&&
operator|!
name|header
operator|.
name|approved
index|[
literal|0
index|]
condition|)
block|{
name|mfd
operator|=
name|mailhdr
argument_list|(
operator|&
name|header
argument_list|,
literal|"Moderated newsgroup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfd
condition|)
block|{
name|fprintf
argument_list|(
name|mfd
argument_list|,
literal|"This newsgroup is moderated, and cannot be posted to directly.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mfd
argument_list|,
literal|"Please mail your article to the moderator for posting.\n"
argument_list|)
expr_stmt|;
name|hwrite
argument_list|(
operator|&
name|header
argument_list|,
name|mfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|infp
condition|)
while|while
condition|(
operator|(
name|i
operator|=
name|getc
argument_list|(
name|infp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|i
argument_list|,
name|mfd
argument_list|)
expr_stmt|;
name|mclose
argument_list|(
name|mfd
argument_list|)
expr_stmt|;
block|}
name|xerror
argument_list|(
literal|"Unapproved moderated newsgroup\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|PROC
condition|)
block|{
name|strcpy
argument_list|(
name|nbuf
argument_list|,
name|header
operator|.
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_find
argument_list|(
operator|&
name|srec
argument_list|,
name|FULLSYSNAME
argument_list|)
operator|==
name|FALSE
condition|)
name|xerror
argument_list|(
literal|"Cannot find my name '%s' in %s"
argument_list|,
name|FULLSYSNAME
argument_list|,
name|SUBFILE
argument_list|)
expr_stmt|;
name|ngsquash
argument_list|(
name|nbuf
argument_list|,
name|srec
operator|.
name|s_nbuf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|!=
name|CREATENG
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|header
operator|.
name|title
condition|)
name|xerror
argument_list|(
literal|"No title"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|header
operator|.
name|nbuf
condition|)
name|strcpy
argument_list|(
name|header
operator|.
name|nbuf
argument_list|,
name|DFLTNG
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_ctl
condition|)
name|ngfcheck
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|ngcat
argument_list|(
name|header
operator|.
name|nbuf
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|nbuf
argument_list|,
name|header
operator|.
name|nbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* mode == CREATENG */
name|ngcat
argument_list|(
name|header
operator|.
name|nbuf
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|nbuf
argument_list|,
name|header
operator|.
name|nbuf
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ptr
operator|=
name|nbuf
init|;
operator|(
name|ptr
operator|=
name|index
argument_list|(
name|ptr
argument_list|,
name|NGDELIM
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|is_ctl
operator|&&
name|header
operator|.
name|followid
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
for|for
control|(
name|ptr
operator|=
name|nbuf
init|;
operator|*
name|ptr
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|exists
argument_list|(
name|dirname
argument_list|(
name|ptr
argument_list|)
argument_list|)
condition|)
name|ngcheck
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|++
condition|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|<=
name|UNPROC
condition|)
name|ctlcheck
argument_list|()
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|nbuf
init|;
operator|*
name|ptr
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'-'
condition|)
goto|goto
name|out
goto|;
while|while
condition|(
operator|*
name|ptr
operator|++
condition|)
empty_stmt|;
block|}
name|xerror
argument_list|(
literal|"No valid newsgroups in '%s'"
argument_list|,
name|header
operator|.
name|nbuf
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* Determine input. */
if|if
condition|(
name|mode
operator|!=
name|PROC
condition|)
name|input
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
comment|/* Go into the background so the user can get on with his business. */
if|if
condition|(
name|mode
operator|!=
name|PROC
condition|)
block|{
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|VMS
comment|/* Do the actual insertion. */
name|insert
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Create directory named by bfr.  *	Don't if user doesn't want to.  */
end_comment

begin_macro
name|ngcheck
argument_list|(
argument|ngname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ngname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|class
index|[
literal|120
index|]
decl_stmt|;
name|char
name|dir
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|strcpy
argument_list|(
name|dir
argument_list|,
name|dirname
argument_list|(
name|ngname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|PROC
condition|)
block|{
ifdef|#
directive|ifdef
name|AUTONEWNG
name|mknewsg
argument_list|(
name|dir
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
comment|/* 	 * If a user is trying to input to a non-existent group complain. 	 * First check to see if the newsgroup ever existed.  To do this, try 	 * to find the name in the "active" file. 	 */
if|if
condition|(
name|mode
operator|!=
name|CREATENG
operator|&&
operator|!
name|is_ctl
condition|)
block|{
comment|/* Ick! Figure out if the newsgroup is in the active file. */
name|sprintf
argument_list|(
name|dir
argument_list|,
literal|"grep -s '^%s ' %s"
argument_list|,
name|ngname
argument_list|,
name|ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|system
argument_list|(
name|dir
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|xerror
argument_list|(
literal|"There is no such newsgroup as %s."
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|dir
argument_list|,
name|dirname
argument_list|(
name|ngname
argument_list|)
argument_list|)
expr_stmt|;
name|mknewsg
argument_list|(
name|dir
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* 	 * Only certain users are allowed to create newsgroups 	 */
if|if
condition|(
name|uid
operator|!=
name|ROOTID
operator|&&
name|uid
operator|!=
name|geteuid
argument_list|()
operator|&&
name|uid
condition|)
name|xerror
argument_list|(
literal|"Please contact one of the local netnews people\n\tto create this group for you"
argument_list|)
expr_stmt|;
comment|/* Broadcast the new newsgroup */
name|strcpy
argument_list|(
name|class
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|class
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'.'
condition|;
name|cp
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|cp
condition|)
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|mknewsg
argument_list|(
name|dir
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Local newsgroup */
block|}
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"inews -D -n %s.ctl -t cmsg newgroup %s"
argument_list|,
name|ngname
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Please type in a paragraph describing the new newsgroup.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"End with control D as usual.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
name|char
name|firstbufname
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Link ARTICLE into dir for ngname and update active file.  */
end_comment

begin_macro
name|localize
argument_list|(
argument|ngname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ngname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|stat
name|status
decl_stmt|;
name|char
name|afline
index|[
name|BUFLEN
index|]
decl_stmt|;
name|long
name|ngsize
decl_stmt|;
name|long
name|fpos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|e
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|lock
argument_list|()
expr_stmt|;
name|actfp
operator|=
name|fopen
argument_list|(
name|ACTIVE
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|fpos
operator|=
name|ftell
argument_list|(
name|actfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|afline
argument_list|,
sizeof|sizeof
name|afline
argument_list|,
name|actfp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|unlock
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
comment|/* No such newsgroup locally */
block|}
if|if
condition|(
name|prefix
argument_list|(
name|afline
argument_list|,
name|ngname
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|afline
argument_list|,
literal|"%s %ld"
argument_list|,
name|bfr
argument_list|,
operator|&
name|ngsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfr
argument_list|,
name|ngname
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|ngsize
operator|<
literal|0
operator|||
name|ngsize
operator|>
literal|99998
condition|)
block|{
name|log
argument_list|(
literal|"found bad ngsize %d ng %s, setting to 1"
argument_list|,
name|ngsize
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|ngsize
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s/%ld"
argument_list|,
name|dirname
argument_list|(
name|ngname
argument_list|)
argument_list|,
name|ngsize
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|ARTICLE
argument_list|,
name|bfr
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|e
operator|=
name|errno
expr_stmt|;
comment|/* keep log from clobbering it */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot install article as %s\n"
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"Cannot install article as %s"
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|EEXIST
condition|)
block|{
name|log
argument_list|(
literal|"Link into %s failed, errno %d, check dir permissions."
argument_list|,
name|bfr
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|unlock
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ngsize
operator|++
expr_stmt|;
block|}
comment|/* Next two lines program around a bug in 4.1BSD stdio. */
name|fclose
argument_list|(
name|actfp
argument_list|)
expr_stmt|;
name|actfp
operator|=
name|fopen
argument_list|(
name|ACTIVE
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|actfp
argument_list|,
name|fpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Has to be same size as old because of %05d. 	 * This will overflow with 99999 articles. 	 */
name|fprintf
argument_list|(
name|actfp
argument_list|,
literal|"%s %05ld\n"
argument_list|,
name|ngname
argument_list|,
name|ngsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|actfp
argument_list|)
expr_stmt|;
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|firstbufname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|firstbufname
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s/%ld "
argument_list|,
name|ngname
argument_list|,
name|ngsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|addhist
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/*  *	Localize for each newsgroup and broadcast.  */
end_comment

begin_macro
name|insert
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|tfp
decl_stmt|;
name|int
name|badgroup
init|=
literal|0
decl_stmt|,
name|goodgroup
init|=
literal|0
decl_stmt|;
comment|/* Fill up the rest of header. */
if|if
condition|(
name|mode
operator|!=
name|PROC
condition|)
block|{
name|history
argument_list|(
operator|&
name|header
argument_list|)
expr_stmt|;
block|}
name|dates
argument_list|(
operator|&
name|header
argument_list|)
expr_stmt|;
name|addhist
argument_list|(
name|header
operator|.
name|recdate
argument_list|)
expr_stmt|;
name|addhist
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"%s %s ng %s subj '%s'"
argument_list|,
name|mode
operator|==
name|PROC
condition|?
literal|"received"
else|:
literal|"posted"
argument_list|,
name|header
operator|.
name|ident
argument_list|,
name|header
operator|.
name|nbuf
argument_list|,
name|header
operator|.
name|title
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|PROC
condition|)
name|log
argument_list|(
literal|"from %s relay %s"
argument_list|,
name|header
operator|.
name|from
argument_list|,
name|header
operator|.
name|relayversion
argument_list|)
expr_stmt|;
comment|/* Write article to temp file. */
name|tfp
operator|=
name|xfopen
argument_list|(
name|mktemp
argument_list|(
name|ARTICLE
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|lhwrite
argument_list|(
operator|&
name|header
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|bfr
argument_list|,
name|BUFLEN
argument_list|,
name|infp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		if (!strncmp(bfr, "From ", 5)) 			putc('>', tfp); 		*/
name|fputs
argument_list|(
name|bfr
argument_list|,
name|tfp
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|infp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ctl
condition|)
block|{
name|control
argument_list|(
operator|&
name|header
argument_list|)
expr_stmt|;
name|goodgroup
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|localize
argument_list|(
literal|"control"
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s/%s"
argument_list|,
name|SPOOL
argument_list|,
literal|"control"
argument_list|)
expr_stmt|;
name|mknewsg
argument_list|(
name|bfr
argument_list|,
literal|"control"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|localize
argument_list|(
literal|"control"
argument_list|)
condition|)
block|{
name|tfp
operator|=
name|mailhdr
argument_list|(
name|NULL
argument_list|,
literal|"No control newsgroup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfp
condition|)
block|{
name|fprintf
argument_list|(
name|tfp
argument_list|,
literal|"Can't create newsgroup 'control'.\n"
argument_list|)
expr_stmt|;
name|mclose
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|ptr
operator|=
name|nbuf
init|;
operator|*
name|ptr
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'-'
condition|)
block|{
while|while
condition|(
operator|*
name|ptr
operator|++
condition|)
empty_stmt|;
continue|continue;
block|}
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|dirname
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exists
argument_list|(
name|bfr
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|AUTONEWNG
name|mknewsg
argument_list|(
name|bfr
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|getapproval
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|badgroup
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|goodgroup
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|nbuf
condition|)
name|localize
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|++
condition|)
empty_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|NOFORWARD
if|if
condition|(
operator|*
name|nbuf
condition|)
endif|#
directive|endif
if|if
condition|(
name|goodgroup
condition|)
name|broadcast
argument_list|()
expr_stmt|;
name|savehist
argument_list|()
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|input
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|empty
init|=
name|TRUE
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|long
name|chcount
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|tmpfp
decl_stmt|;
name|int
name|consec_newlines
init|=
literal|0
decl_stmt|;
name|int
name|linecount
init|=
literal|0
decl_stmt|;
name|tmpfp
operator|=
name|xfopen
argument_list|(
name|mktemp
argument_list|(
name|INFILE
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|filename
condition|)
block|{
name|tty
operator|=
name|FALSE
expr_stmt|;
name|infp
operator|=
name|xfopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|infp
operator|=
name|stdin
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|sigtrap
operator|&&
name|fgets
argument_list|(
name|bfr
argument_list|,
name|BUFLEN
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|PROC
condition|)
comment|/* zap trailing empty lines */
block|{
if|if
condition|(
name|bfr
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
comment|/* 1 empty line, to go */
block|{
name|consec_newlines
operator|++
expr_stmt|;
comment|/* count it, in case */
continue|continue;
comment|/* but don't write it*/
block|}
comment|/* foo! a non-empty line. write out all saved lines. */
while|while
condition|(
name|consec_newlines
operator|>
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|tmpfp
argument_list|)
expr_stmt|;
name|consec_newlines
operator|--
expr_stmt|;
name|linecount
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mode
operator|!=
name|PROC
operator|&&
name|tty
operator|&&
name|strcmp
argument_list|(
name|bfr
argument_list|,
literal|".\n"
argument_list|)
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|cp
operator|=
name|bfr
init|;
name|c
operator|=
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'\b'
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|tmpfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|chcount
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|linecount
operator|++
expr_stmt|;
block|}
name|empty
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|filename
condition|)
name|fclose
argument_list|(
name|infp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s/%s"
argument_list|,
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
argument_list|,
literal|".signature"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|PROC
operator|&&
operator|(
name|infp
operator|=
name|fopen
argument_list|(
name|bfr
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|tmpfp
argument_list|,
literal|"-- \n"
argument_list|)
expr_stmt|;
comment|/* To separate */
name|linecount
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|tmpfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|linecount
operator|++
expr_stmt|;
block|}
name|fclose
argument_list|(
name|infp
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|tmpfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigtrap
condition|)
block|{
if|if
condition|(
name|tty
condition|)
name|printf
argument_list|(
literal|"Interrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
operator|&&
operator|!
name|empty
condition|)
name|fwait
argument_list|(
name|fsubr
argument_list|(
name|newssave
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tty
condition|)
name|log
argument_list|(
literal|"Blown away by an interrupt %d"
argument_list|,
name|sigtrap
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tty
condition|)
name|printf
argument_list|(
literal|"EOT\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|infp
operator|=
name|fopen
argument_list|(
name|INFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chcount
operator|<
literal|5
operator|&&
name|mode
operator|<=
name|UNPROC
operator|&&
operator|!
name|is_ctl
condition|)
name|xerror
argument_list|(
literal|"You didn't really want to post THAT!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|.
name|numlines
index|[
literal|0
index|]
condition|)
block|{
comment|/* 		 * Check line count if there's already one attached to 		 * the article.  Could make this a fatal error - 		 * throwing it away if it got chopped, in hopes that 		 * another copy will come in later with a correct 		 * line count.  But that seems a bit much for now. 		 */
if|if
condition|(
name|linecount
operator|!=
name|header
operator|.
name|intnumlines
condition|)
name|log
argument_list|(
literal|"linecount expected %d, got %d\n"
argument_list|,
name|header
operator|.
name|intnumlines
argument_list|,
name|linecount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Attach a line count to the article. */
name|header
operator|.
name|intnumlines
operator|=
name|linecount
expr_stmt|;
name|sprintf
argument_list|(
name|header
operator|.
name|numlines
argument_list|,
literal|"%d"
argument_list|,
name|linecount
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Make the directory for a new newsgroup.  ngname should be the  * full pathname of the directory.  Do the other stuff too.  * The various games with setuid and chown are to try to make sure  * the directory is owned by NEWSUSR and NEWSGRP, which is tough to  * do if you aren't root.  This will work on a UCB system (which allows  * setuid(geteuid()) or a USG system (which allows you to give away files  * you own with chown), otherwise you have to change your kernel to allow  * one of these things or run with your dirs 777 so that it doesn't matter  * who owns them.  */
end_comment

begin_macro
name|mknewsg
argument_list|(
argument|fulldir
argument_list|,
argument|ngname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fulldir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ngname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pid
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|sysbuf
index|[
literal|200
index|]
decl_stmt|;
name|char
name|parent
index|[
literal|200
index|]
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|ngname
operator|==
name|NULL
operator|||
operator|!
name|isalpha
argument_list|(
name|ngname
index|[
literal|0
index|]
argument_list|)
condition|)
name|xerror
argument_list|(
literal|"Tried to make illegal newsgroup %s"
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
comment|/* 	 * If the parent is 755 and we're on a USG system, the setuid(getuid) 	 * will fail, and since mkdir is suid, and our real uid is random, 	 * the mkdir will fail.  So we have to temporarily chmod it to 755. 	 */
name|strcpy
argument_list|(
name|parent
argument_list|,
name|fulldir
argument_list|)
expr_stmt|;
name|p
operator|=
name|rindex
argument_list|(
name|parent
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|parent
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
name|sbuf
operator|.
name|st_mode
operator|=
literal|0777
expr_stmt|;
name|chmod
argument_list|(
name|parent
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|setuid
argument_list|(
name|geteuid
argument_list|()
argument_list|)
condition|)
comment|/* This fails on some systems, but 					 * works on 4BSD, and 2BSD. */
ifndef|#
directive|ifndef
name|USG
name|umask
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
expr_stmt|;
name|setgid
argument_list|(
name|getegid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Create the directory */
name|mkparents
argument_list|(
name|fulldir
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sysbuf
argument_list|,
literal|"mkdir %s"
argument_list|,
name|fulldir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|system
argument_list|(
name|sysbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fwait
argument_list|(
name|pid
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|sysbuf
argument_list|,
literal|"Cannot mkdir %s"
argument_list|,
name|fulldir
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
name|sysbuf
argument_list|)
expr_stmt|;
block|}
name|chmod
argument_list|(
name|parent
argument_list|,
name|sbuf
operator|.
name|st_mode
argument_list|)
expr_stmt|;
comment|/* put is back */
ifdef|#
directive|ifdef
name|USG
ifndef|#
directive|ifndef
name|CHEAP
comment|/* 	 * Give away the files we just created, which were assigned to our 	 * REAL uid.  This only works on USG systems.  It is an alternative 	 * to the setuid call above.  The directories we just made are owned 	 * by our real uid, so we have to temporarily set our effective uid 	 * the same to allow the chown.  Fortunately, USG lets us setuid back. 	 */
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|chown
argument_list|(
name|fulldir
argument_list|,
name|duid
argument_list|,
name|dgid
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|duid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* Update the "active newsgroup" file. */
if|if
condition|(
name|ngname
operator|&&
operator|*
name|ngname
condition|)
block|{
name|actfp
operator|=
name|xfopen
argument_list|(
name|ACTIVE
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|actfp
argument_list|,
literal|"%s 00000\n"
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|actfp
argument_list|)
expr_stmt|;
block|}
name|log
argument_list|(
literal|"make newsgroup %s in dir %s"
argument_list|,
name|ngname
argument_list|,
name|fulldir
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * If any parent directories of this dir don't exist, create them.  */
end_comment

begin_macro
name|mkparents
argument_list|(
argument|dirname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dirname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|,
name|sysbuf
index|[
literal|200
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|p
operator|=
name|rindex
argument_list|(
name|buf
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|exists
argument_list|(
name|buf
argument_list|)
condition|)
return|return;
name|mkparents
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sysbuf
argument_list|,
literal|"mkdir %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|sysbuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cancel
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|log
argument_list|(
literal|"cancel article %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fp
operator|=
name|xfopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hread
argument_list|(
operator|&
name|header
argument_list|,
name|fp
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Article is garbled.\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * An article has come in that isn't in a newsgroup we know about.  * Stash it in the junk directory and notify the local contact person.  * Note that such articles are NOT broadcast to our neighbors, on the  * assumption that they are a typographical error.  We only keep them  * here because we might be a new site.  */
end_comment

begin_macro
name|getapproval
argument_list|(
argument|ng
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ng
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
if|if
condition|(
name|localize
argument_list|(
literal|"junk"
argument_list|)
condition|)
return|return;
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s/%s"
argument_list|,
name|SPOOL
argument_list|,
literal|"junk"
argument_list|)
expr_stmt|;
name|mknewsg
argument_list|(
name|bfr
argument_list|,
literal|"junk"
argument_list|)
expr_stmt|;
if|if
condition|(
name|localize
argument_list|(
literal|"junk"
argument_list|)
condition|)
return|return;
name|fd
operator|=
name|mailhdr
argument_list|(
name|NULL
argument_list|,
literal|"Strange Newsgroup Received"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\nNewsgroup '%s' has been posted to\nby %s.\n\n"
argument_list|,
name|ng
argument_list|,
name|header
operator|.
name|from
index|[
literal|0
index|]
condition|?
name|header
operator|.
name|from
else|:
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"I was unable to save it in the newsgroup 'junk'\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"I was also unable to create the newsgroup 'junk'\n"
argument_list|)
expr_stmt|;
name|mclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

