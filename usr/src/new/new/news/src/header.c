begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * header.c - header functions plus some other goodies  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)header.c	2.20	6/24/83"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"header.h"
end_include

begin_decl_stmt
specifier|extern
name|char
name|bfr
index|[]
decl_stmt|,
name|FULLSYSNAME
index|[]
decl_stmt|,
name|SYSNAME
index|[]
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|time_t
name|defexp
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|hfgets
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|seenrelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read header from file fp into *hp.  If wholething is FALSE,  * it's an incremental read, otherwise start from scratch.  * Return (FILE *) if header okay, else NULL.  */
end_comment

begin_function
name|FILE
modifier|*
name|hread
parameter_list|(
name|hp
parameter_list|,
name|fp
parameter_list|,
name|wholething
parameter_list|)
specifier|register
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|wholething
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
if|if
condition|(
name|wholething
condition|)
name|bclear
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hp
argument_list|)
argument_list|)
expr_stmt|;
name|seenrelay
operator|=
literal|0
expr_stmt|;
comment|/* Check that it's a B news style header. */
if|if
condition|(
operator|(
operator|(
name|hfgets
argument_list|(
name|bfr
argument_list|,
name|PATHLEN
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|bfr
operator|>=
literal|'A'
operator|&&
operator|*
name|bfr
operator|<=
literal|'Z'
operator|)
operator|&&
name|index
argument_list|(
name|bfr
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
if|if
condition|(
name|frmread
argument_list|(
name|fp
argument_list|,
name|hp
argument_list|)
condition|)
goto|goto
name|strip
goto|;
comment|/* It's not.  Try A news (begins with PROTO). */
if|if
condition|(
operator|*
name|bfr
operator|!=
name|PROTO
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Read in an A news format article. */
name|strncpy
argument_list|(
name|hp
operator|->
name|oident
argument_list|,
operator|&
operator|(
name|bfr
index|[
literal|1
index|]
operator|)
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
comment|/* file name */
if|if
condition|(
operator|!
name|nstrip
argument_list|(
name|hp
operator|->
name|oident
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|hfgets
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|,
name|BUFLEN
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* newsgroup list */
if|if
condition|(
operator|!
name|nstrip
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ngcat
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|)
expr_stmt|;
name|hfgets
argument_list|(
name|hp
operator|->
name|path
argument_list|,
name|PATHLEN
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* source path */
if|if
condition|(
operator|!
name|nstrip
argument_list|(
name|hp
operator|->
name|path
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|hfgets
argument_list|(
name|hp
operator|->
name|subdate
argument_list|,
name|DATELEN
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* date */
if|if
condition|(
operator|!
name|nstrip
argument_list|(
name|hp
operator|->
name|subdate
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|hfgets
argument_list|(
name|hp
operator|->
name|title
argument_list|,
name|BUFLEN
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* title */
if|if
condition|(
operator|!
name|nstrip
argument_list|(
name|hp
operator|->
name|title
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|strip
label|:
comment|/* strip off sys! from front of path. */
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|FULLSYSNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|path
argument_list|,
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|bfr
argument_list|)
operator|)
argument_list|)
operator|==
literal|0
operator|&&
name|index
argument_list|(
name|NETCHRS
argument_list|,
name|hp
operator|->
name|path
index|[
name|len
index|]
argument_list|)
condition|)
name|strcpy
argument_list|(
name|hp
operator|->
name|path
argument_list|,
operator|&
operator|(
name|hp
operator|->
name|path
index|[
name|len
operator|+
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|lcase
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|)
expr_stmt|;
comment|/* Intuit the From: line if only a path was given. */
if|if
condition|(
name|wholething
operator|&&
name|hp
operator|->
name|from
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|intuitfrom
argument_list|(
name|hp
argument_list|)
expr_stmt|;
comment|/* Get old and new style message ID's. */
if|if
condition|(
name|wholething
condition|)
name|fixid
argument_list|(
name|hp
argument_list|)
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get header info from mail-format file.  * Return non-zero on success.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|FROM
value|1
end_define

begin_define
define|#
directive|define
name|NEWSGROUP
value|2
end_define

begin_define
define|#
directive|define
name|TITLE
value|3
end_define

begin_define
define|#
directive|define
name|SUBMIT
value|4
end_define

begin_define
define|#
directive|define
name|RECEIVE
value|5
end_define

begin_define
define|#
directive|define
name|EXPIRE
value|6
end_define

begin_define
define|#
directive|define
name|ARTICLEID
value|7
end_define

begin_define
define|#
directive|define
name|MESSAGEID
value|8
end_define

begin_define
define|#
directive|define
name|REPLYTO
value|9
end_define

begin_define
define|#
directive|define
name|FOLLOWID
value|10
end_define

begin_define
define|#
directive|define
name|CONTROL
value|11
end_define

begin_define
define|#
directive|define
name|SENDER
value|12
end_define

begin_define
define|#
directive|define
name|FOLLOWTO
value|13
end_define

begin_define
define|#
directive|define
name|PATH
value|14
end_define

begin_define
define|#
directive|define
name|POSTVERSION
value|15
end_define

begin_define
define|#
directive|define
name|RELAYVERSION
value|16
end_define

begin_define
define|#
directive|define
name|DISTRIBUTION
value|17
end_define

begin_define
define|#
directive|define
name|ORGANIZATION
value|18
end_define

begin_define
define|#
directive|define
name|NUMLINES
value|19
end_define

begin_define
define|#
directive|define
name|KEYWORDS
value|20
end_define

begin_define
define|#
directive|define
name|APPROVED
value|21
end_define

begin_define
define|#
directive|define
name|OTHER
value|99
end_define

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
name|frmread
argument_list|(
name|fp
argument_list|,
name|hp
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unreccnt
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|long
name|curpos
decl_stmt|;
name|int
name|hdrlineno
init|=
literal|0
decl_stmt|;
name|int
name|iu
decl_stmt|;
for|for
control|(
name|iu
operator|=
literal|0
init|;
name|iu
operator|<
name|NUNREC
condition|;
name|iu
operator|++
control|)
name|hp
operator|->
name|unrec
index|[
name|iu
index|]
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
name|type
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
do|do
block|{
name|curpos
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|hdrlineno
operator|++
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|PATH
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|path
argument_list|)
expr_stmt|;
break|break;
case|case
name|FROM
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|from
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEWSGROUP
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|TITLE
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|title
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBMIT
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|subdate
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECEIVE
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|recdate
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPIRE
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|expdate
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARTICLEID
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|oident
argument_list|)
expr_stmt|;
break|break;
case|case
name|MESSAGEID
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|ident
argument_list|)
expr_stmt|;
break|break;
case|case
name|REPLYTO
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|replyto
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOLLOWID
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|followid
argument_list|)
expr_stmt|;
break|break;
case|case
name|SENDER
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|sender
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOLLOWTO
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|followto
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONTROL
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|ctlmsg
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTVERSION
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|postversion
argument_list|)
expr_stmt|;
break|break;
case|case
name|DISTRIBUTION
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|distribution
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORGANIZATION
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|organization
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUMLINES
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|numlines
argument_list|)
expr_stmt|;
name|hp
operator|->
name|intnumlines
operator|=
name|atoi
argument_list|(
name|hp
operator|->
name|numlines
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEYWORDS
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|keywords
argument_list|)
expr_stmt|;
break|break;
case|case
name|APPROVED
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|approved
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELAYVERSION
case|:
comment|/* 			 * Only believe a relay version if it's the first 			 * line, otherwise it probably got passed through 			 * by some old neighbor. 			 */
if|if
condition|(
name|hdrlineno
operator|==
literal|1
condition|)
block|{
name|getfield
argument_list|(
name|hp
operator|->
name|relayversion
argument_list|)
expr_stmt|;
name|seenrelay
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|OTHER
case|:
if|if
condition|(
name|unreccnt
operator|<
name|NUNREC
condition|)
block|{
name|hp
operator|->
name|unrec
index|[
name|unreccnt
index|]
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|bfr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hp
operator|->
name|unrec
index|[
name|unreccnt
index|]
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|unreccnt
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|i
operator|=
name|type
argument_list|(
name|hfgets
argument_list|(
name|bfr
argument_list|,
name|LBUFLEN
argument_list|,
name|fp
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
do|;
if|if
condition|(
operator|*
name|bfr
operator|!=
literal|'\n'
condition|)
name|fseek
argument_list|(
name|fp
argument_list|,
name|curpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hp
operator|->
name|from
index|[
literal|0
index|]
operator|||
name|hp
operator|->
name|path
index|[
literal|0
index|]
operator|)
operator|&&
name|hp
operator|->
name|subdate
index|[
literal|0
index|]
operator|&&
operator|(
name|hp
operator|->
name|ident
index|[
literal|0
index|]
operator|||
name|hp
operator|->
name|oident
index|[
literal|0
index|]
operator|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_block

begin_comment
comment|/*  * There was no From: line in the message (because it was generated by  * an old news program).  Guess what it should have been and create it.  */
end_comment

begin_expr_stmt
name|intuitfrom
argument_list|(
name|hp
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|,
modifier|*
name|host
decl_stmt|,
modifier|*
name|fullname
decl_stmt|;
name|char
modifier|*
name|tailpath
argument_list|()
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|;
name|char
modifier|*
name|at
decl_stmt|,
modifier|*
name|dot
decl_stmt|;
name|tp
operator|=
name|tailpath
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|user
operator|=
name|rindex
argument_list|(
name|tp
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
operator|==
name|NULL
condition|)
name|user
operator|=
name|tp
expr_stmt|;
else|else
operator|*
name|user
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Check for an existing Internet address on the end. */
name|at
operator|=
name|index
argument_list|(
name|user
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
condition|)
block|{
name|dot
operator|=
name|index
argument_list|(
name|at
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
condition|)
block|{
name|strcpy
argument_list|(
name|hp
operator|->
name|from
argument_list|,
name|user
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* @ signs are illegal except for the biggie, so */
operator|*
name|at
operator|=
literal|'%'
expr_stmt|;
block|}
if|if
condition|(
name|tp
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
name|host
operator|=
name|index
argument_list|(
name|tp
argument_list|,
literal|'!'
argument_list|)
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|user
operator|==
name|tp
condition|)
name|host
operator|=
name|FULLSYSNAME
expr_stmt|;
else|else
name|host
operator|=
name|tp
expr_stmt|;
name|tp
operator|=
name|index
argument_list|(
name|host
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|hp
operator|->
name|from
argument_list|,
literal|"%s@%s%s"
argument_list|,
name|user
argument_list|,
name|host
argument_list|,
name|MYDOMAIN
argument_list|)
expr_stmt|;
name|fullname
operator|=
name|index
argument_list|(
name|hp
operator|->
name|path
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullname
operator|!=
name|NULL
condition|)
block|{
name|fullname
operator|--
expr_stmt|;
name|strcat
argument_list|(
name|hp
operator|->
name|from
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
operator|*
name|fullname
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * If the message has only one of ident/oident, guess what  * the other one should be and fill them both in.  */
end_comment

begin_expr_stmt
name|fixid
argument_list|(
name|hp
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|lbuf
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|hp
operator|->
name|ident
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|hp
operator|->
name|oident
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|strcpy
argument_list|(
name|lbuf
argument_list|,
name|hp
operator|->
name|oident
argument_list|)
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|lbuf
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|hp
operator|->
name|ident
argument_list|,
name|hp
operator|->
name|oident
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * It may seem strange that we hardwire ".UUCP" in 		 * here instead of MYDOMAIN.  However, we are trying 		 * to guess what the domain was on the posting system, 		 * not the local system.  Since we don't really know 		 * what the posting system does, we just go with the 		 * majority - almost everyone will be a .UUCP if they 		 * didn't fill in their Message-ID. 		 */
name|sprintf
argument_list|(
name|hp
operator|->
name|ident
argument_list|,
literal|"<%s@%s%s>"
argument_list|,
name|p
argument_list|,
name|lbuf
argument_list|,
literal|".UUCP"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OLD
if|if
condition|(
name|hp
operator|->
name|oident
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|hp
operator|->
name|ident
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|strcpy
argument_list|(
name|lbuf
argument_list|,
name|hp
operator|->
name|ident
argument_list|)
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|lbuf
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|hp
operator|->
name|oident
argument_list|,
name|hp
operator|->
name|ident
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|p
index|[
name|SNLN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|hp
operator|->
name|oident
argument_list|,
literal|"%s.%s"
argument_list|,
name|p
argument_list|,
name|lbuf
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Get the given field of a header (char * parm) from bfr, but only  * if there's something actually there (after the colon).  Don't  * bother if we already have an entry for this field.  */
end_comment

begin_macro
name|getfield
argument_list|(
argument|hpfield
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|hpfield
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|hpfield
index|[
literal|0
index|]
condition|)
return|return;
for|for
control|(
name|ptr
operator|=
name|index
argument_list|(
name|bfr
argument_list|,
literal|':'
argument_list|)
init|;
name|isspace
argument_list|(
operator|*
operator|++
name|ptr
argument_list|)
condition|;
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
block|{
name|strcpy
argument_list|(
name|hpfield
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|nstrip
argument_list|(
name|hpfield
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_define
define|#
directive|define
name|its
parameter_list|(
name|type
parameter_list|)
value|(prefix(ptr, type))
end_define

begin_macro
name|type
argument_list|(
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|colon
decl_stmt|,
modifier|*
name|space
decl_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|colon
operator|=
name|index
argument_list|(
name|ptr
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|space
operator|=
name|index
argument_list|(
name|ptr
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|colon
operator|||
name|colon
operator|+
literal|1
operator|!=
name|space
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|its
argument_list|(
literal|"From: "
argument_list|)
condition|)
if|if
condition|(
name|index
argument_list|(
name|ptr
argument_list|,
literal|'@'
argument_list|)
operator|&&
operator|!
name|index
argument_list|(
name|ptr
argument_list|,
literal|'!'
argument_list|)
operator|&&
name|seenrelay
condition|)
return|return
name|FROM
return|;
else|else
return|return
name|PATH
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Path: "
argument_list|)
condition|)
return|return
name|PATH
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Newsgroups: "
argument_list|)
condition|)
return|return
name|NEWSGROUP
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Subject: "
argument_list|)
operator|||
name|its
argument_list|(
literal|"Title: "
argument_list|)
condition|)
return|return
name|TITLE
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Posted: "
argument_list|)
operator|||
name|its
argument_list|(
literal|"Date: "
argument_list|)
condition|)
return|return
name|SUBMIT
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Date-Received: "
argument_list|)
operator|||
name|its
argument_list|(
literal|"Received: "
argument_list|)
condition|)
return|return
name|RECEIVE
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Expires: "
argument_list|)
condition|)
return|return
name|EXPIRE
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Article-I.D.: "
argument_list|)
condition|)
return|return
name|ARTICLEID
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Message-ID: "
argument_list|)
condition|)
return|return
name|MESSAGEID
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Reply-To: "
argument_list|)
condition|)
return|return
name|REPLYTO
return|;
if|if
condition|(
name|its
argument_list|(
literal|"References: "
argument_list|)
condition|)
return|return
name|FOLLOWID
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Control: "
argument_list|)
condition|)
return|return
name|CONTROL
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Sender: "
argument_list|)
condition|)
return|return
name|SENDER
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Followup-To: "
argument_list|)
condition|)
return|return
name|FOLLOWTO
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Posting-Version: "
argument_list|)
condition|)
return|return
name|POSTVERSION
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Relay-Version: "
argument_list|)
condition|)
return|return
name|RELAYVERSION
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Distribution: "
argument_list|)
condition|)
return|return
name|DISTRIBUTION
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Organization: "
argument_list|)
condition|)
return|return
name|ORGANIZATION
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Lines: "
argument_list|)
condition|)
return|return
name|NUMLINES
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Keywords: "
argument_list|)
condition|)
return|return
name|KEYWORDS
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Approved: "
argument_list|)
condition|)
return|return
name|APPROVED
return|;
return|return
name|OTHER
return|;
block|}
end_block

begin_comment
comment|/*  * Generate the current version of the news software.  */
end_comment

begin_function
name|char
modifier|*
name|genversion
parameter_list|()
block|{
specifier|static
name|char
name|retbuf
index|[
literal|32
index|]
decl_stmt|;
name|char
name|rb
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|strcpy
argument_list|(
name|rb
argument_list|,
name|news_version
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|=
name|index
argument_list|(
name|rb
argument_list|,
literal|'\t'
argument_list|)
condition|)
operator|*
name|t
operator|=
literal|' '
expr_stmt|;
comment|/* This is B news, so we say "B", the version, and the date. */
name|sprintf
argument_list|(
name|retbuf
argument_list|,
literal|"version %s; site %s%s"
argument_list|,
name|rb
argument_list|,
name|FULLSYSNAME
argument_list|,
name|MYDOMAIN
argument_list|)
expr_stmt|;
return|return
name|retbuf
return|;
block|}
end_function

begin_comment
comment|/*  * Write header at 'hp' on stream 'fp' in B format.  This goes out to  * some other system.  */
end_comment

begin_expr_stmt
name|hwrite
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ihwrite
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Same as above, except include receival date for local usage and  * an extra \n for looks.  */
end_comment

begin_expr_stmt
name|lhwrite
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ihwrite
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Write header at 'hp' on stream 'fp' in B+ format.  Include received date  * if wr is 1.  Leave off sysname if wr is 2.  */
end_comment

begin_expr_stmt
name|ihwrite
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|,
name|wr
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|iu
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|time_t
name|cgtdate
parameter_list|()
function_decl|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Relay-Version: %s\n"
argument_list|,
name|genversion
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|postversion
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Posting-Version: %s\n"
argument_list|,
name|hp
operator|->
name|postversion
argument_list|)
expr_stmt|;
comment|/* 	 * We're being tricky with Path/From because of upward compatibility 	 * issues.  The new version considers From and Path to be separate. 	 * The old one thinks they both mean "Path" but only believes the 	 * first one it sees, so will ignore the second. 	 */
if|if
condition|(
name|prefix
argument_list|(
name|hp
operator|->
name|path
argument_list|,
name|FULLSYSNAME
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Path: %s\n"
argument_list|,
name|hp
operator|->
name|path
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Path: %s!%s\n"
argument_list|,
name|FULLSYSNAME
argument_list|,
name|hp
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|from
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"From: %s\n"
argument_list|,
name|hp
operator|->
name|from
argument_list|)
expr_stmt|;
name|ngdel
argument_list|(
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|nbuf
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Newsgroups: %s\n"
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Subject: %s\n"
argument_list|,
name|hp
operator|->
name|title
argument_list|)
expr_stmt|;
name|fixid
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Message-ID: %s\n"
argument_list|,
name|hp
operator|->
name|ident
argument_list|)
expr_stmt|;
name|t
operator|=
name|cgtdate
argument_list|(
name|hp
operator|->
name|subdate
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Date: %s\n"
argument_list|,
name|arpadate
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OLD
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Article-I.D.: %s\n"
argument_list|,
name|hp
operator|->
name|oident
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Posted: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|wr
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Date-Received: %s\n"
argument_list|,
name|hp
operator|->
name|recdate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|expdate
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Expires: %s\n"
argument_list|,
name|hp
operator|->
name|expdate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|followid
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"References: %s\n"
argument_list|,
name|hp
operator|->
name|followid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|ctlmsg
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Control: %s\n"
argument_list|,
name|hp
operator|->
name|ctlmsg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|sender
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Sender: %s\n"
argument_list|,
name|hp
operator|->
name|sender
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|replyto
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Reply-To: %s\n"
argument_list|,
name|hp
operator|->
name|replyto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|followto
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Followup-To: %s\n"
argument_list|,
name|hp
operator|->
name|followto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|distribution
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Distribution: %s\n"
argument_list|,
name|hp
operator|->
name|distribution
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|organization
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Organization: %s\n"
argument_list|,
name|hp
operator|->
name|organization
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|numlines
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Lines: %s\n"
argument_list|,
name|hp
operator|->
name|numlines
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|keywords
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Keywords: %s\n"
argument_list|,
name|hp
operator|->
name|keywords
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|approved
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Approved: %s\n"
argument_list|,
name|hp
operator|->
name|approved
argument_list|)
expr_stmt|;
for|for
control|(
name|iu
operator|=
literal|0
init|;
name|iu
operator|<
name|NUNREC
condition|;
name|iu
operator|++
control|)
block|{
if|if
condition|(
name|hp
operator|->
name|unrec
index|[
name|iu
index|]
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
operator|&
name|hp
operator|->
name|unrec
index|[
name|iu
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set nc bytes, starting at cp, to zero.  */
end_comment

begin_expr_stmt
name|bclear
argument_list|(
name|cp
argument_list|,
name|nc
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|nc
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|nc
operator|--
condition|)
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * hfgets is like fgets, but deals with continuation lines.  * It also ensures that even if a line that is too long is  * received, the remainder of the line is thrown away  * instead of treated like a second line.  */
end_comment

begin_function
name|char
modifier|*
name|hfgets
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|,
name|fp
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|cp
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|tp
operator|=
name|cp
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
comment|/* Line too long - part read didn't fit into a newline */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
block|}
else|else
operator|*
operator|--
name|tp
operator|=
literal|'\0'
expr_stmt|;
comment|/* clobber newline */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
comment|/* for each cont line */
comment|/* Continuation line. */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'t'
condition|)
comment|/* skip white space */
empty_stmt|;
if|if
condition|(
name|tp
operator|-
name|cp
operator|<
name|len
condition|)
block|{
operator|*
name|tp
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
if|if
condition|(
name|tp
operator|-
name|cp
operator|<
name|len
condition|)
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|tp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* push back first char of next header */
return|return
name|cp
return|;
block|}
end_function

end_unit

