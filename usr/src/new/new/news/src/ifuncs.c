begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ifuncs - functions used by inews.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)ifuncs.c	2.21	3/31/83"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"iparams.h"
end_include

begin_comment
comment|/*  * Transmit this article to all interested systems.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|u370
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|srec
name|srec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hbuf
name|h
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|broadcast
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|nptr
decl_stmt|,
modifier|*
name|hptr
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
ifndef|#
directive|ifndef
name|u370
name|struct
name|srec
name|srec
decl_stmt|;
name|struct
name|hbuf
name|h
decl_stmt|;
endif|#
directive|endif
comment|/* h is a local copy of the header we can scribble on */
name|fp
operator|=
name|xfopen
argument_list|(
name|ARTICLE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hread
argument_list|(
operator|&
name|h
argument_list|,
name|fp
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot reread article"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|.
name|distribution
index|[
literal|0
index|]
condition|)
name|strcpy
argument_list|(
name|h
operator|.
name|nbuf
argument_list|,
name|h
operator|.
name|distribution
argument_list|)
expr_stmt|;
name|ngcat
argument_list|(
name|h
operator|.
name|nbuf
argument_list|)
expr_stmt|;
comment|/* break path into list of systems. */
name|hptr
operator|=
name|nptr
operator|=
name|h
operator|.
name|path
expr_stmt|;
while|while
condition|(
operator|*
name|hptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
name|NETCHRS
argument_list|,
operator|*
name|hptr
argument_list|)
condition|)
block|{
operator|*
name|hptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|nptr
operator|=
name|hptr
expr_stmt|;
block|}
else|else
name|hptr
operator|++
expr_stmt|;
block|}
operator|*
name|nptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* loop once per system. */
name|lock
argument_list|()
expr_stmt|;
name|s_openr
argument_list|()
expr_stmt|;
while|while
condition|(
name|s_read
argument_list|(
operator|&
name|srec
argument_list|)
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|srec
operator|.
name|s_name
argument_list|,
name|FULLSYSNAME
argument_list|,
name|SNLN
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|hptr
operator|=
name|h
operator|.
name|path
expr_stmt|;
while|while
condition|(
operator|*
name|hptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|srec
operator|.
name|s_name
argument_list|,
name|hptr
argument_list|,
name|SNLN
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|contin
goto|;
while|while
condition|(
operator|*
name|hptr
operator|++
operator|!=
literal|'\0'
condition|)
empty_stmt|;
block|}
if|if
condition|(
name|ngmatch
argument_list|(
name|h
operator|.
name|nbuf
argument_list|,
name|srec
operator|.
name|s_nbuf
argument_list|)
condition|)
block|{
name|transmit
argument_list|(
operator|&
name|srec
argument_list|,
name|xfopen
argument_list|(
name|ARTICLE
argument_list|,
literal|"r"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|contin
label|:
empty_stmt|;
block|}
name|s_close
argument_list|()
expr_stmt|;
name|unlock
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Transmit file to system.  */
end_comment

begin_define
define|#
directive|define
name|PROC
value|0004
end_define

begin_expr_stmt
name|transmit
argument_list|(
name|sp
argument_list|,
name|ifp
argument_list|,
name|maynotify
argument_list|)
specifier|register
expr|struct
name|srec
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maynotify
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|ofp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
name|struct
name|hbuf
name|hh
decl_stmt|;
name|char
name|TRANS
index|[
name|BUFLEN
index|]
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|20
index|]
decl_stmt|;
specifier|register
name|int
name|pid
decl_stmt|,
name|fd
decl_stmt|;
specifier|extern
name|char
name|firstbufname
index|[]
decl_stmt|;
comment|/* A:	afmt: the other machine runs an A news, so we xmit in A format */
name|int
name|afmt
init|=
operator|(
name|index
argument_list|(
name|sp
operator|->
name|s_flags
argument_list|,
literal|'A'
argument_list|)
operator|!=
name|NULL
operator|)
decl_stmt|;
comment|/* B:	use B format (this is the default - don't use this letter elsewise). */
comment|/* F:	append name to file */
name|int
name|appfile
init|=
operator|(
name|index
argument_list|(
name|sp
operator|->
name|s_flags
argument_list|,
literal|'F'
argument_list|)
operator|!=
name|NULL
operator|)
decl_stmt|;
comment|/* L:	local: don't send the article unless it was generated locally */
name|int
name|local
init|=
operator|(
name|index
argument_list|(
name|sp
operator|->
name|s_flags
argument_list|,
literal|'L'
argument_list|)
operator|!=
name|NULL
operator|)
decl_stmt|;
comment|/* N:	notify: don't send the article, just tell him we have it */
name|int
name|notify
init|=
name|maynotify
operator|&&
operator|(
name|index
argument_list|(
name|sp
operator|->
name|s_flags
argument_list|,
literal|'N'
argument_list|)
operator|!=
name|NULL
operator|)
decl_stmt|;
comment|/* S:	noshell: don't fork a shell to execute the xmit command */
name|int
name|noshell
init|=
operator|(
name|index
argument_list|(
name|sp
operator|->
name|s_flags
argument_list|,
literal|'S'
argument_list|)
operator|!=
name|NULL
operator|)
decl_stmt|;
comment|/* U:	useexist: use the -c option to uux to use the existing copy */
name|int
name|useexist
init|=
operator|(
name|index
argument_list|(
name|sp
operator|->
name|s_flags
argument_list|,
literal|'U'
argument_list|)
operator|!=
name|NULL
operator|)
decl_stmt|;
if|if
condition|(
name|local
operator|&&
name|mode
operator|==
name|PROC
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Transmitting to '%s'\n"
argument_list|,
name|sp
operator|->
name|s_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|appfile
operator|&&
operator|!
name|useexist
condition|)
block|{
if|if
condition|(
name|hread
argument_list|(
operator|&
name|hh
argument_list|,
name|ifp
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad header, not transmitting\n"
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"Bad header, not transmitting %s re %s to %s"
argument_list|,
name|hh
operator|.
name|ident
argument_list|,
name|hh
operator|.
name|title
argument_list|,
name|sp
operator|->
name|s_name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Taken out for obscure reasons - see the standard. 		ngsquash(hh.nbuf, sp->s_nbuf); 		*/
if|if
condition|(
name|hh
operator|.
name|nbuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Article not subscribed to by %s\n"
argument_list|,
name|sp
operator|->
name|s_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|sprintf
argument_list|(
name|TRANS
argument_list|,
literal|"%s/trXXXXXX"
argument_list|,
name|SPOOL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|notify
condition|)
block|{
name|char
name|oldid
index|[
literal|50
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|hh
operator|.
name|title
argument_list|,
literal|"ihave %s %s"
argument_list|,
name|hh
operator|.
name|ident
argument_list|,
name|FULLSYSNAME
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hh
operator|.
name|nbuf
argument_list|,
literal|"to.%s.ctl"
argument_list|,
name|sp
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|oldid
argument_list|,
name|hh
operator|.
name|ident
argument_list|)
expr_stmt|;
name|getident
argument_list|(
operator|&
name|hh
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"tell %s about %s, notif. id %s"
argument_list|,
name|sp
operator|->
name|s_name
argument_list|,
name|oldid
argument_list|,
name|hh
operator|.
name|ident
argument_list|)
expr_stmt|;
block|}
else|else
name|log
argument_list|(
literal|"xmit article %s to %s"
argument_list|,
name|hh
operator|.
name|ident
argument_list|,
name|sp
operator|->
name|s_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|appfile
condition|)
block|{
if|if
condition|(
name|firstbufname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|xerror
argument_list|(
literal|"No file name to xmit from"
argument_list|)
expr_stmt|;
name|ofp
operator|=
name|fopen
argument_list|(
name|sp
operator|->
name|s_xmit
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofp
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot append to %s"
argument_list|,
name|sp
operator|->
name|s_xmit
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"%s\n"
argument_list|,
name|firstbufname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
ifdef|#
directive|ifdef
name|UXMIT
if|if
condition|(
name|useexist
condition|)
block|{
if|if
condition|(
name|firstbufname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|xerror
argument_list|(
literal|"No file name to xmit from"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|->
name|s_xmit
operator|==
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
name|UXMIT
argument_list|,
name|sp
operator|->
name|s_name
argument_list|,
name|firstbufname
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|bfr
argument_list|,
name|sp
operator|->
name|s_xmit
argument_list|,
name|firstbufname
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|ofp
operator|=
name|xfopen
argument_list|(
name|mktemp
argument_list|(
name|TRANS
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|afmt
condition|)
name|ohwrite
argument_list|(
operator|&
name|hh
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
else|else
name|hwrite
argument_list|(
operator|&
name|hh
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|notify
condition|)
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|ifp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|->
name|s_xmit
operator|==
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|bfr
argument_list|,
name|DFTXMIT
argument_list|,
name|sp
operator|->
name|s_name
argument_list|,
name|TRANS
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"(%s)< %s"
argument_list|,
name|sp
operator|->
name|s_xmit
argument_list|,
name|TRANS
argument_list|)
expr_stmt|;
block|}
comment|/* At this point, the command to be executed is in bfr. */
if|if
condition|(
name|noshell
condition|)
block|{
if|if
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
name|fwait
argument_list|(
name|pid
argument_list|)
expr_stmt|;
else|else
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|open
argument_list|(
name|TRANS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|sp
operator|->
name|s_xmit
expr_stmt|;
for|for
control|(
name|pid
operator|=
literal|0
init|;
name|pid
operator|<
literal|19
condition|;
name|pid
operator|++
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
operator|*
name|ptr
operator|++
operator|=
literal|0
expr_stmt|;
name|argv
index|[
name|pid
index|]
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
operator|++
name|ptr
argument_list|)
operator|&&
operator|*
name|ptr
condition|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|ptr
condition|)
break|break;
block|}
name|argv
index|[
operator|++
name|pid
index|]
operator|=
literal|0
expr_stmt|;
name|execv
argument_list|(
name|sp
operator|->
name|s_xmit
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
literal|"Can't execv\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|system
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|appfile
operator|&&
operator|!
name|useexist
condition|)
name|unlink
argument_list|(
name|TRANS
argument_list|)
expr_stmt|;
block|}
end_block

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|dptr
decl_stmt|;
name|int
name|dsize
decl_stmt|;
block|}
name|datum
typedef|;
end_typedef

begin_comment
comment|/*  * Return TRUE if we have seen this file before, else FALSE.  */
end_comment

begin_macro
name|history
argument_list|(
argument|hp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|hfp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|datum
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|datum
name|fetch
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"history(%s)\n"
argument_list|,
name|hp
operator|->
name|ident
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|idlock
argument_list|(
name|hp
operator|->
name|ident
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBM
name|dbminit
argument_list|(
name|ARTFILE
argument_list|)
expr_stmt|;
name|lhs
operator|.
name|dptr
operator|=
name|hp
operator|->
name|ident
expr_stmt|;
name|lhs
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|lhs
operator|.
name|dptr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|rhs
operator|=
name|fetch
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|.
name|dptr
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|#
directive|else
name|hfp
operator|=
name|xfopen
argument_list|(
name|ARTFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|bfr
argument_list|,
name|BUFLEN
argument_list|,
name|hfp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|index
argument_list|(
name|bfr
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|index
argument_list|(
name|bfr
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
comment|/* can happen if nulls in file */
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|ident
argument_list|)
operator|==
literal|0
operator|||
name|hp
operator|->
name|oident
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|oident
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|hfp
argument_list|)
expr_stmt|;
name|idunlock
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"history returns true\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
name|fclose
argument_list|(
name|hfp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|addhist
argument_list|(
name|hp
operator|->
name|ident
argument_list|)
expr_stmt|;
name|addhist
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"history returns false\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|histline
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assumed initially zero */
end_comment

begin_macro
name|addhist
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|strcat
argument_list|(
name|histline
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|savehist
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|hfp
decl_stmt|;
name|datum
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|long
name|fpos
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|hfp
operator|=
name|xfopen
argument_list|(
name|ARTFILE
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|fpos
operator|=
name|ftell
argument_list|(
name|hfp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|hfp
argument_list|,
literal|"%s\n"
argument_list|,
name|histline
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|hfp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBM
comment|/* We assume that history has already been called, calling dbminit. */
name|p
operator|=
name|index
argument_list|(
name|histline
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|lhs
operator|.
name|dptr
operator|=
name|histline
expr_stmt|;
name|lhs
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|lhs
operator|.
name|dptr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|rhs
operator|.
name|dptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|fpos
expr_stmt|;
name|rhs
operator|.
name|dsize
operator|=
sizeof|sizeof
name|fpos
expr_stmt|;
name|store
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|histline
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|idunlock
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Save partial news.  */
end_comment

begin_macro
name|newssave
argument_list|(
argument|fd
argument_list|,
argument|dummy
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fd
decl_stmt|,
modifier|*
name|dummy
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|tofd
decl_stmt|,
modifier|*
name|fromfd
decl_stmt|;
name|char
name|sfname
index|[
name|BUFLEN
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|struct
name|hbuf
name|h
decl_stmt|;
name|time_t
name|tim
decl_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
name|fromfd
operator|=
name|xfopen
argument_list|(
name|INFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
name|fromfd
operator|=
name|fd
expr_stmt|;
name|umask
argument_list|(
name|savmask
argument_list|)
expr_stmt|;
name|setgid
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sfname
argument_list|,
literal|"%s/%s"
argument_list|,
name|userhome
argument_list|,
name|PARTIAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tofd
operator|=
name|fopen
argument_list|(
name|sfname
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot save partial news"
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|tim
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tofd
argument_list|,
literal|"----- News saved at %s\n"
argument_list|,
name|arpadate
argument_list|(
operator|&
name|tim
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fromfd
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|tofd
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fromfd
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tofd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"News saved in %s\n"
argument_list|,
name|sfname
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Handle dates in header.  */
end_comment

begin_macro
name|dates
argument_list|(
argument|hp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|edt
decl_stmt|;
name|time
argument_list|(
operator|&
name|hp
operator|->
name|rectime
argument_list|)
expr_stmt|;
name|nstrip
argument_list|(
name|strcpy
argument_list|(
name|hp
operator|->
name|recdate
argument_list|,
name|arpadate
argument_list|(
operator|&
name|hp
operator|->
name|rectime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|subdate
condition|)
block|{
if|if
condition|(
name|cgtdate
argument_list|(
name|hp
operator|->
name|subdate
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
literal|"Bad sub date '%s'"
argument_list|,
name|hp
operator|->
name|subdate
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
literal|"Cannot parse submittal date"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|strcpy
argument_list|(
name|hp
operator|->
name|subdate
argument_list|,
name|hp
operator|->
name|recdate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|expdate
condition|)
block|{
if|if
condition|(
operator|(
name|edt
operator|=
name|cgtdate
argument_list|(
name|hp
operator|->
name|expdate
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|xerror
argument_list|(
literal|"Cannot parse expiration date"
argument_list|)
expr_stmt|;
name|nstrip
argument_list|(
name|strcpy
argument_list|(
name|hp
operator|->
name|expdate
argument_list|,
name|arpadate
argument_list|(
operator|&
name|edt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|defexp
operator|=
name|TRUE
expr_stmt|;
comment|/* 		 * Default is now applied in expire.c 		hp->exptime = hp->rectime + DFLTEXP; 		nstrip(strcpy(hp->expdate, arpadate(&hp->exptime))); 		*/
block|}
block|}
end_block

begin_comment
comment|/*  *	Exit and cleanup.  */
end_comment

begin_macro
name|xxit
argument_list|(
argument|status
argument_list|)
end_macro

begin_decl_stmt
name|int
name|status
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unlink
argument_list|(
name|INFILE
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|ARTICLE
argument_list|)
expr_stmt|;
while|while
condition|(
name|lockcount
operator|>
literal|0
condition|)
name|unlock
argument_list|()
expr_stmt|;
name|idunlock
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|xerror
argument_list|(
argument|message
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buffer
index|[
literal|128
index|]
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|message
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"inews: %s.\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_define
define|#
directive|define
name|SUBLOCK
value|"/tmp/netnews.lck.1"
end_define

begin_comment
comment|/*  * Newsystem locking.  * These routines are different for VMS because we can not  * effectively simulate links, and VMS supports multiple  * version numbers of files  */
end_comment

begin_macro
name|lock
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|lockcount
operator|++
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|DEADTIME
expr_stmt|;
while|while
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|SUBLOCK
argument_list|,
literal|0444
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
block|{
name|unlink
argument_list|(
name|SUBLOCK
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"News system locked up"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
operator|-
literal|3
condition|)
name|xerror
argument_list|(
literal|"Unable to unlock news system"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|unlock
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|--
name|lockcount
operator|==
literal|0
condition|)
name|unlink
argument_list|(
name|SUBLOCK
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
else|VMS
end_else

begin_comment
comment|/*  * Newsystem locking.  */
end_comment

begin_macro
name|lock
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|lockcount
operator|++
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|DEADTIME
expr_stmt|;
while|while
condition|(
name|link
argument_list|(
name|SUBFILE
argument_list|,
name|LOCKFILE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
name|xerror
argument_list|(
literal|"News system locked up"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|unlock
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|--
name|lockcount
operator|==
literal|0
condition|)
name|unlink
argument_list|(
name|LOCKFILE
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|VMS
end_endif

begin_decl_stmt
name|char
name|lockname
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|idlock
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|tempname
index|[
literal|80
index|]
decl_stmt|;
name|long
name|now
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|int
name|fd
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|sprintf
argument_list|(
name|lockname
argument_list|,
literal|"/tmp/%s.l.1"
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|lockname
argument_list|,
literal|0444
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
else|#
directive|else
else|VMS
name|sprintf
argument_list|(
name|tempname
argument_list|,
literal|"/tmp/LTMP.%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|lockname
argument_list|,
literal|"/tmp/L%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FOURTEENMAX
name|lockname
index|[
literal|5
comment|/* /tmp/ */
operator|+
literal|14
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
name|close
argument_list|(
name|creat
argument_list|(
name|tempname
argument_list|,
literal|0666
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|link
argument_list|(
name|tempname
argument_list|,
name|lockname
argument_list|)
condition|)
block|{
endif|#
directive|endif
endif|VMS
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|i
operator|=
name|stat
argument_list|(
name|lockname
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|xerror
argument_list|(
literal|"Directory permission problem in /tmp"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sbuf
operator|.
name|st_mtime
operator|+
literal|10
operator|*
literal|60
operator|<
name|now
condition|)
block|{
name|unlink
argument_list|(
name|lockname
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"Article %s locked up"
argument_list|,
name|str
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|log
argument_list|(
literal|"waiting on lock for %s"
argument_list|,
name|lockname
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|unsigned
operator|)
literal|60
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VMS
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
else|#
directive|else
name|unlink
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|unlink
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
block|}
name|idunlock
argument_list|()
block|{
name|unlink
argument_list|(
name|lockname
argument_list|)
expr_stmt|;
block|}
comment|/*  * Put a unique name into header.ident.  */
name|getident
argument_list|(
argument|hp
argument_list|)
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
block|{
name|long
name|seqn
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|lock
argument_list|()
expr_stmt|;
name|fp
operator|=
name|xfopen
argument_list|(
name|SEQFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|bfr
argument_list|,
name|BUFLEN
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|seqn
operator|=
name|atol
argument_list|(
name|bfr
argument_list|)
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|unlink
argument_list|(
name|SEQFILE
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|VMS
name|fp
operator|=
name|xfopen
argument_list|(
name|SEQFILE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%ld\n"
argument_list|,
name|seqn
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|unlock
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|hp
operator|->
name|ident
argument_list|,
literal|"<%ld@%s%s>"
argument_list|,
name|seqn
argument_list|,
name|FULLSYSNAME
argument_list|,
name|MYDOMAIN
argument_list|)
expr_stmt|;
block|}
comment|/*  * Log the given message, with printf strings and parameters allowed,  * on the log file, if it can be written.  The date and an attempt at  * figuring out the remote system name are also logged.  */
name|log
argument_list|(
argument|fmt
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|,
argument|a6
argument_list|,
argument|a7
argument_list|,
argument|a8
argument_list|,
argument|a9
argument_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
block|{
name|FILE
modifier|*
name|logfile
decl_stmt|;
name|char
name|msg
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|logtime
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|rmtsys
index|[
literal|256
index|]
decl_stmt|;
name|char
name|c
decl_stmt|;
name|long
name|t
decl_stmt|;
if|if
condition|(
name|header
operator|.
name|relayversion
index|[
literal|0
index|]
condition|)
block|{
for|for
control|(
name|p
operator|=
name|header
operator|.
name|relayversion
init|;
name|p
condition|;
name|p
operator|=
name|index
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|'s'
argument_list|)
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"site "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|crackpath
goto|;
name|p
operator|+=
literal|4
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|&&
operator|*
name|q
operator|!=
literal|' '
operator|&&
operator|*
name|q
operator|!=
literal|'\t'
condition|;
name|q
operator|++
control|)
empty_stmt|;
name|c
operator|=
operator|*
name|q
expr_stmt|;
name|strcpy
argument_list|(
name|rmtsys
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|crackpath
label|:
name|strcpy
argument_list|(
name|rmtsys
argument_list|,
name|header
operator|.
name|path
argument_list|)
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|rmtsys
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|index
argument_list|(
name|rmtsys
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|p
operator|=
name|rindex
argument_list|(
name|rmtsys
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|strcpy
argument_list|(
name|rmtsys
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|rmtsys
argument_list|,
literal|"local"
argument_list|)
expr_stmt|;
block|}
block|}
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|logtime
operator|=
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|logtime
index|[
literal|16
index|]
operator|=
literal|0
expr_stmt|;
name|logtime
operator|+=
literal|4
expr_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
name|fmt
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|)
expr_stmt|;
name|lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|logfname
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|unlock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|logfile
operator|=
name|fopen
argument_list|(
name|logfname
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile
operator|==
name|NULL
condition|)
block|{
name|unlock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|logfile
argument_list|,
literal|"%s %s\t%s\n"
argument_list|,
name|logtime
argument_list|,
name|rmtsys
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|/*  * Check if header.nbuf contains only valid newsgroup names;  * exit with error if not valid.  *  * a == TRUE means header.nbuf is subscription list  * a == FALSE means header.nbuf is newsgroup list  */
name|ngfcheck
argument_list|(
argument|a
argument_list|)
name|int
name|a
decl_stmt|;
block|{
name|char
name|ngcheck
index|[
name|NGFSIZ
index|]
decl_stmt|;
comment|/* Hold NGFILE newsgroups */
name|char
name|tbuf
index|[
name|BUFLEN
index|]
decl_stmt|;
comment|/* hold single header.nbuf news group */
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|s1
operator|=
name|ngcheck
expr_stmt|;
name|f
operator|=
name|xfopen
argument_list|(
name|NGFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|bfr
argument_list|,
name|BUFLEN
argument_list|,
name|f
argument_list|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|s2
operator|=
name|bfr
init|;
operator|*
name|s2
operator|!=
literal|'\0'
operator|&&
operator|*
name|s2
operator|!=
literal|' '
operator|&&
operator|*
name|s2
operator|!=
literal|'\t'
operator|&&
operator|*
name|s2
operator|!=
literal|':'
operator|&&
operator|*
name|s2
operator|!=
literal|'\n'
condition|;
control|)
block|{
if|if
condition|(
name|s1
operator|>=
operator|&
name|ngcheck
index|[
name|NGFSIZ
operator|-
literal|2
index|]
condition|)
name|xerror
argument_list|(
literal|"NGFILE too long"
argument_list|)
expr_stmt|;
operator|*
name|s1
operator|++
operator|=
operator|*
name|s2
operator|++
expr_stmt|;
block|}
operator|*
name|s1
operator|++
operator|=
name|NGDELIM
expr_stmt|;
block|}
operator|*
name|s1
operator|=
literal|'\0'
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
for|for
control|(
name|s1
operator|=
name|header
operator|.
name|nbuf
init|;
operator|*
name|s1
operator|!=
literal|'\0'
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|s1
operator|==
name|NEGCHAR
condition|)
name|s1
operator|++
expr_stmt|;
name|s2
operator|=
name|tbuf
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|s2
operator|++
operator|=
operator|*
name|s1
operator|++
operator|)
operator|!=
name|NGDELIM
condition|)
if|if
condition|(
name|s1
index|[
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
name|xerror
argument_list|(
literal|"Newsgroup cannot contain ':'"
argument_list|)
expr_stmt|;
operator|*
name|s2
operator|=
literal|'\0'
expr_stmt|;
name|s2
operator|=
name|tbuf
expr_stmt|;
if|if
condition|(
operator|!
name|ngmatch
argument_list|(
name|s2
argument_list|,
name|ngcheck
argument_list|)
operator|&&
operator|(
operator|!
name|a
operator|||
operator|!
name|ngmatch
argument_list|(
name|ngcheck
argument_list|,
name|s2
argument_list|)
operator|)
condition|)
block|{
name|ngdel
argument_list|(
name|s2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"Bad news group \"%s\""
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|newssave
argument_list|(
name|stdin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*  * Figure out who posted the article (which is locally entered).  * The results are placed in the header structure hp.  */
name|gensender
argument_list|(
argument|hp
argument_list|,
argument|logname
argument_list|)
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|logname
decl_stmt|;
block|{
name|char
modifier|*
name|fn
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|char
name|buf2
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|fullname
argument_list|()
decl_stmt|,
modifier|*
name|getenv
argument_list|()
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|fn
operator|=
name|getenv
argument_list|(
literal|"NAME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
argument_list|,
literal|".name"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|read
argument_list|(
name|fd
argument_list|,
name|buf2
argument_list|,
sizeof|sizeof
name|buf2
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf2
index|[
literal|0
index|]
operator|>=
literal|'A'
condition|)
name|fn
operator|=
name|buf2
expr_stmt|;
for|for
control|(
name|p
operator|=
name|fn
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|<
literal|' '
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fn
operator|==
name|NULL
condition|)
name|fn
operator|=
name|fullname
argument_list|(
name|logname
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hp
operator|->
name|path
argument_list|,
literal|"%s"
argument_list|,
name|logname
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hp
operator|->
name|from
argument_list|,
literal|"%s@%s%s (%s)"
argument_list|,
name|logname
argument_list|,
name|FULLSYSNAME
argument_list|,
name|MYDOMAIN
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
comment|/*  * Trap interrupts.  */
name|onsig
argument_list|(
argument|n
argument_list|)
name|int
name|n
decl_stmt|;
block|{
specifier|static
name|int
name|numsigs
init|=
literal|0
decl_stmt|;
comment|/* 	 * Most UNIX systems reset caught signals to SIG_DFL. 	 * This bad design requires that the trap be set again here. 	 * Unfortunately, if the signal recurs before the trap is set, 	 * the program will die, possibly leaving the lock in place. 	 */
if|if
condition|(
operator|++
name|numsigs
operator|>
literal|100
condition|)
block|{
name|log
argument_list|(
literal|"readnews ran away looping on signal %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|n
argument_list|,
name|onsig
argument_list|)
expr_stmt|;
name|sigtrap
operator|=
name|n
expr_stmt|;
block|}
comment|/*  * If the stdin begins with "#", we assume we have been fed a batched  * shell script which looks like this:  *	#! rnews 1234  *	article with 1234 chars  *	#! rnews 4321  *	article with 4321 chars  *  * In this case we just exec the unbatcher and let it unpack and call us back.  *  * Note that there is a potential security hole here.  If the batcher is  * /bin/sh, someone could ship you arbitrary stuff to run as shell commands.  * The main protection you have is that the effective uid will be news, not  * uucp and not the super user.  (That, plus the fact that BATCH is set to  * "unbatch" as the system is distributed.)  If you want to run a batched link  * and you are security concious, do not use /bin/sh as the unbatcher.  * the thing to do is to change BATCH in your localize.sh file from /bin/sh  * to some restricted shell which can only run rnews.  */
name|checkbatch
argument_list|()
block|{
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|BATCH
name|c
operator|=
name|getc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
name|reset_stdin
argument_list|()
expr_stmt|;
name|execl
argument_list|(
name|BATCH
argument_list|,
literal|"news-unpack"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
literal|"Unable to exec shell to unpack news.\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/*  * We've already done a read on stdin, and we want to seek back to the  * beginning.  We want the real file descriptor (beyond buffers) to  * reflect the true beginning.  Do whatever is necessary.  */
name|reset_stdin
argument_list|()
block|{
specifier|register
name|FILE
modifier|*
name|ofd
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|ofdname
decl_stmt|;
comment|/* First try to seek back - if so, it's a cheap way back. */
if|if
condition|(
name|lseek
argument_list|(
literal|0
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Can't seek, so have to copy input to a file and use that. */
name|ofdname
operator|=
literal|"/tmp/inewsXXXXX"
expr_stmt|;
name|mktemp
argument_list|(
name|ofdname
argument_list|)
expr_stmt|;
name|ofd
operator|=
name|fopen
argument_list|(
name|ofdname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|stdin
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|ofd
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
comment|/* Now for a few lower level hacks to reopen stdin and make 	 * absolutely sure that the right fd's are done for the exec. 	 */
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* to make sure stdin is really closed. */
name|open
argument_list|(
name|ofdname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* returns zero */
name|unlink
argument_list|(
name|ofdname
argument_list|)
expr_stmt|;
comment|/* to avoid cleaning it up later. */
block|}
end_block

end_unit

