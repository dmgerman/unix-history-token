begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * rfuncs - functions for readnews.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)rfuncs.c	2.9	3/7/83"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"rparams.h"
end_include

begin_decl_stmt
name|long
name|nngsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The next upcoming value of ngsize. */
end_comment

begin_macro
name|nextng
argument_list|()
end_macro

begin_block
block|{
name|long
name|curpos
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nextng()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|curpos
operator|=
name|ftell
argument_list|(
name|actfp
argument_list|)
expr_stmt|;
name|next
label|:
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"next:\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|actdirect
operator|==
name|BACKWARD
condition|)
block|{
if|if
condition|(
name|back
argument_list|()
condition|)
block|{
name|fseek
argument_list|(
name|actfp
argument_list|,
name|curpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|back
argument_list|()
condition|)
block|{
name|fseek
argument_list|(
name|actfp
argument_list|,
name|curpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|fgets
argument_list|(
name|afline
argument_list|,
name|BUFLEN
argument_list|,
name|actfp
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|sscanf
argument_list|(
name|afline
argument_list|,
literal|"%s %ld"
argument_list|,
name|bfr
argument_list|,
operator|&
name|nngsize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bfr = '%s'\n"
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ngcat
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ngmatch
argument_list|(
name|bfr
argument_list|,
name|header
operator|.
name|nbuf
argument_list|)
condition|)
goto|goto
name|next
goto|;
name|ngdel
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
if|if
condition|(
name|xflag
condition|)
name|readmode
operator|=
name|SPEC
expr_stmt|;
else|else
name|readmode
operator|=
name|NEXT
expr_stmt|;
if|if
condition|(
name|selectng
argument_list|(
name|bfr
argument_list|)
condition|)
goto|goto
name|next
goto|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|selectng
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|,
name|punct
init|=
literal|','
decl_stmt|;
specifier|register
name|int
name|cur
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|next
init|=
literal|0
decl_stmt|;
name|char
name|oldptr
decl_stmt|;
name|long
name|findngsize
parameter_list|()
function_decl|;
if|if
condition|(
operator|*
name|groupdir
condition|)
name|updaterc
argument_list|()
expr_stmt|;
name|last
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|bfr
argument_list|)
condition|)
name|ngsize
operator|=
name|findngsize
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|ngsize
operator|=
name|nngsize
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"selectng(%s) sets ngsize to %ld\n"
argument_list|,
name|name
argument_list|,
name|ngsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|groupdir
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xflag
condition|)
block|{
name|i
operator|=
name|findrcline
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
name|rcline
index|[
name|i
index|]
argument_list|,
literal|'!'
argument_list|)
condition|)
block|{
name|groupdir
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|sprintf
argument_list|(
name|rcbuf
argument_list|,
literal|"%s,%ld"
argument_list|,
name|rcline
index|[
name|i
index|]
argument_list|,
name|ngsize
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|rcbuf
argument_list|,
literal|"ng: %ld"
argument_list|,
name|ngsize
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fast check for common case: 1-### 	 */
name|p
operator|=
name|rcbuf
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'1'
operator|&&
operator|*
name|p
operator|++
operator|==
literal|'-'
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|i
operator|=
literal|10
operator|*
name|i
operator|+
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|','
operator|&&
name|i
operator|>=
name|ngsize
condition|)
block|{
name|groupdir
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/*  * The key to understanding this piece of code is that a bit is set iff  * that article has NOT been read.  Thus, we fill in the holes when  * commas are found (e.g. 1-20,30-35 will result in filling in the 21-29  * hold), and so we assume the newsrc file is properly ordered, the way  * we write it out.   */
name|cur
operator|=
literal|0
expr_stmt|;
comment|/* Zero out the bitmap */
name|p
operator|=
operator|&
name|bitmap
index|[
name|ngsize
operator|/
literal|8
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|bitmap
init|;
name|ptr
operator|<=
name|p
condition|;
name|ptr
control|)
operator|*
name|ptr
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* Decode the .newsrc line indicating what we have read. */
for|for
control|(
name|ptr
operator|=
name|rcbuf
init|;
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|!=
literal|':'
condition|;
name|ptr
operator|++
control|)
empty_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
while|while
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
operator|*
name|ptr
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ptr
condition|)
break|break;
name|sscanf
argument_list|(
name|ptr
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|punct
operator|==
literal|','
condition|)
block|{
while|while
condition|(
operator|++
name|cur
operator|<
name|next
condition|)
block|{
name|set
argument_list|(
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
name|cur
operator|=
name|next
expr_stmt|;
while|while
condition|(
operator|!
name|ispunct
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
operator|*
name|ptr
condition|)
name|ptr
operator|++
expr_stmt|;
name|punct
operator|=
operator|*
name|ptr
expr_stmt|;
block|}
if|if
condition|(
name|rflag
condition|)
name|bit
operator|=
name|ngsize
operator|+
literal|1
expr_stmt|;
else|else
name|bit
operator|=
literal|0
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
name|ngrp
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Figure out the number of the largest article in newsgroup ng,  * and return that value.  */
end_comment

begin_function
name|long
name|findngsize
parameter_list|(
name|ng
parameter_list|)
name|char
modifier|*
name|ng
decl_stmt|;
block|{
name|FILE
modifier|*
name|af
decl_stmt|;
name|long
name|s
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|,
name|n
index|[
literal|100
index|]
decl_stmt|;
name|af
operator|=
name|xfopen
argument_list|(
name|ACTIVE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|af
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%s %ld"
argument_list|,
name|n
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|n
argument_list|,
name|ng
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|af
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TMAIL
end_ifdef

begin_macro
name|catchterm
argument_list|()
end_macro

begin_block
block|{
name|unlink
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The -M (Mail) interface.  This code is a reasonably simple model for  * writing other interfaces.  We write out all relavent articles to  * a temp file, then invoke Mail with an option to have it tell us which  * articles it read.  Finally we count those articles as really read.  */
end_comment

begin_macro
name|Mail
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|,
modifier|*
name|ofp
decl_stmt|;
name|struct
name|hbuf
name|h
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
name|int
name|news
init|=
literal|0
decl_stmt|;
name|ofp
operator|=
name|xfopen
argument_list|(
name|mktemp
argument_list|(
name|outfile
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
operator|&&
operator|*
name|datebuf
condition|)
if|if
condition|(
operator|(
name|atime
operator|=
name|cgtdate
argument_list|(
name|datebuf
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|xerror
argument_list|(
literal|"Cannot parse date string"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|nextng
argument_list|()
condition|)
while|while
condition|(
name|bit
operator|<=
name|ngsize
condition|)
block|{
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s/%d"
argument_list|,
name|dirname
argument_list|(
name|groupdir
argument_list|)
argument_list|,
name|bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|filename
argument_list|,
literal|4
argument_list|)
operator|||
operator|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|hread
argument_list|(
operator|&
name|h
argument_list|,
name|fp
argument_list|,
name|TRUE
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|!
name|select
argument_list|(
operator|&
name|h
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad article '%s'\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
name|clear
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|fname
operator|=
name|ptr
operator|=
name|index
argument_list|(
name|h
operator|.
name|from
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
condition|)
block|{
while|while
condition|(
name|ptr
operator|&&
name|ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|ptr
operator|--
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
name|fname
operator|++
expr_stmt|;
name|ptr
operator|=
name|fname
operator|+
name|strlen
argument_list|(
name|fname
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|')'
condition|)
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
name|h
operator|.
name|subtime
operator|=
name|cgtdate
argument_list|(
name|h
operator|.
name|subdate
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"From %s %s"
argument_list|,
ifdef|#
directive|ifdef
name|INTERNET
name|h
operator|.
name|from
index|[
literal|0
index|]
condition|?
name|h
operator|.
name|from
else|:
endif|#
directive|endif
name|h
operator|.
name|path
argument_list|,
name|ctime
argument_list|(
operator|&
name|h
operator|.
name|subtime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
condition|)
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Full-Name: %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Newsgroups: %s\n"
argument_list|,
name|h
operator|.
name|nbuf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Subject: %s\n"
argument_list|,
name|h
operator|.
name|title
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ofp
argument_list|,
literal|"Article-ID: %s/%d\n\n"
argument_list|,
name|groupdir
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|tprint
argument_list|(
name|fp
argument_list|,
name|ofp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|news
operator|=
name|TRUE
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
name|nextbit
argument_list|()
expr_stmt|;
block|}
name|updaterc
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|news
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No news.\n"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
return|return;
block|}
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|catchterm
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|catchterm
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"%s -f %s -T %s"
argument_list|,
name|TMAIL
argument_list|,
name|outfile
argument_list|,
name|mktemp
argument_list|(
name|infile
argument_list|)
argument_list|)
expr_stmt|;
name|fwait
argument_list|(
name|fsubr
argument_list|(
name|ushell
argument_list|,
name|bfr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|ofp
operator|=
name|xfopen
argument_list|(
name|infile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|actfp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|afline
argument_list|,
name|BUFLEN
argument_list|,
name|actfp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|last
operator|=
literal|0
expr_stmt|;
name|sscanf
argument_list|(
name|afline
argument_list|,
literal|"%s %ld"
argument_list|,
name|bfr
argument_list|,
operator|&
name|nngsize
argument_list|)
expr_stmt|;
name|ngcat
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ngmatch
argument_list|(
name|bfr
argument_list|,
name|header
operator|.
name|nbuf
argument_list|)
condition|)
continue|continue;
name|ngdel
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
operator|*
name|groupdir
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|selectng
argument_list|(
name|bfr
argument_list|)
condition|)
continue|continue;
name|fseek
argument_list|(
name|ofp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|groupdir
argument_list|,
name|BUFLEN
argument_list|,
name|ofp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|nstrip
argument_list|(
name|groupdir
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|index
argument_list|(
name|groupdir
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfr
argument_list|,
name|groupdir
argument_list|)
condition|)
continue|continue;
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|clear
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last
condition|)
block|{
name|strcpy
argument_list|(
name|groupdir
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|updaterc
argument_list|()
expr_stmt|;
block|}
block|}
name|unlink
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|updaterc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|cur
init|=
literal|1
decl_stmt|,
name|next
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
name|oldptr
decl_stmt|;
name|sprintf
argument_list|(
name|rcbuf
argument_list|,
literal|"%s%c "
argument_list|,
name|groupdir
argument_list|,
name|zapng
condition|?
literal|'!'
else|:
literal|':'
argument_list|)
expr_stmt|;
name|zapng
operator|=
name|FALSE
expr_stmt|;
name|again
label|:
name|ptr
operator|=
operator|&
name|rcbuf
index|[
name|strlen
argument_list|(
name|rcbuf
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|get
argument_list|(
name|next
argument_list|)
condition|)
name|next
operator|++
expr_stmt|;
name|cur
operator|=
name|next
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|get
argument_list|(
name|next
argument_list|)
operator|)
operator|&&
name|next
operator|<=
name|ngsize
condition|)
name|next
operator|++
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|next
condition|)
block|{
name|next
operator|=
literal|8193
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
name|cur
operator|+
literal|1
operator|==
name|next
condition|)
name|sprintf
argument_list|(
name|ptr
argument_list|,
literal|"%d,"
argument_list|,
name|cur
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|ptr
argument_list|,
literal|"%d-%d,"
argument_list|,
name|cur
argument_list|,
name|next
operator|-
literal|1
argument_list|)
expr_stmt|;
name|skip
label|:
if|if
condition|(
operator|(
name|long
operator|)
name|next
operator|>
name|ngsize
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
name|rcbuf
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
condition|)
name|ngdel
argument_list|(
name|rcbuf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|index
argument_list|(
name|rcbuf
argument_list|,
literal|'!'
argument_list|)
operator|==
name|NULL
condition|)
return|return;
name|ptr
operator|=
name|index
argument_list|(
name|rcbuf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|ptr
operator|--
expr_stmt|;
name|oldptr
operator|=
operator|*
name|ptr
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
literal|':'
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
name|findrcline
argument_list|(
name|groupdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|ptr
index|[
literal|0
index|]
operator|=
name|oldptr
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|rcline
index|[
name|i
index|]
operator|=
name|realloc
argument_list|(
name|rcline
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|rcbuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcline
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Cannot realloc"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rcline
index|[
name|i
index|]
argument_list|,
name|rcbuf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|++
name|line
operator|>
name|LINES
condition|)
name|xerror
argument_list|(
literal|"Too many newsgroups\n"
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
name|oldptr
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|(
name|rcline
index|[
name|line
index|]
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|rcbuf
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|xerror
argument_list|(
literal|"Not enough memory"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rcline
index|[
name|line
index|]
argument_list|,
name|rcbuf
argument_list|)
expr_stmt|;
return|return;
block|}
name|cur
operator|=
name|next
expr_stmt|;
goto|goto
name|again
goto|;
block|}
end_block

begin_macro
name|newrc
argument_list|(
argument|rcname
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|close
argument_list|(
name|creat
argument_list|(
name|rcname
argument_list|,
literal|0666
argument_list|)
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|bfr
argument_list|,
literal|"Cannot create %s"
argument_list|,
name|newsrc
argument_list|)
expr_stmt|;
name|xerror
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|USERS
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|username
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|USERS
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|xerror
argument_list|(
argument|message
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|message
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"readnews: %s.\n"
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|xxit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|nextbit
argument_list|()
end_macro

begin_block
block|{
name|last
operator|=
name|bit
expr_stmt|;
if|if
condition|(
name|readmode
operator|==
name|SPEC
operator|||
name|xflag
condition|)
block|{
if|if
condition|(
name|rflag
condition|)
name|bit
operator|--
expr_stmt|;
else|else
name|bit
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rflag
condition|)
while|while
condition|(
operator|--
name|bit
operator|,
operator|!
name|get
argument_list|(
name|bit
argument_list|)
operator|&&
name|bit
operator|>
literal|0
condition|)
empty_stmt|;
else|else
while|while
condition|(
operator|++
name|bit
operator|,
operator|!
name|get
argument_list|(
name|bit
argument_list|)
operator|&&
name|bit
operator|<=
name|ngsize
condition|)
empty_stmt|;
block|}
end_block

begin_macro
name|xxit
argument_list|(
argument|status
argument_list|)
end_macro

begin_decl_stmt
name|int
name|status
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unlink
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Return TRUE if the user has not ruled out this article.  */
end_comment

begin_expr_stmt
name|select
argument_list|(
name|hp
argument_list|,
name|insist
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|insist
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|insist
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|tflag
operator|&&
operator|!
name|titmat
argument_list|(
name|hp
argument_list|,
name|header
operator|.
name|title
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|aflag
operator|&&
name|cgtdate
argument_list|(
name|hp
operator|->
name|recdate
argument_list|)
operator|<
name|atime
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|index
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|,
literal|','
argument_list|)
operator|&&
name|seenbefore
argument_list|(
name|hp
operator|->
name|ident
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fflag
operator|&&
name|isfol
argument_list|(
name|hp
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/*  * Return TRUE if this article is a followup to something.  */
end_comment

begin_expr_stmt
name|isfol
argument_list|(
name|hp
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|hp
operator|->
name|followid
index|[
literal|0
index|]
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|hp
operator|->
name|title
argument_list|,
literal|"Re:"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_block

begin_comment
comment|/*  * Given an article ID, return TRUE if we have already seen that article ID  * in this readnews session.  This should only be called for articles  * with commas in the newsgroup name, and prevents the same article, which  * was submitted to multiple newsgroups, from being shown to the same  * person more than once.  Bug: if the user quits after seeing the first  * copy, he'll see it again next time in the other newsgroup.  */
end_comment

begin_define
define|#
directive|define
name|NART
value|100
end_define

begin_comment
comment|/* max # articles on multiple newsgroups */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nbef
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|histbuf
index|[
name|NART
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|nextabuf
index|[
name|BUFLEN
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|seenbefore
argument_list|(
argument|artid
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|artid
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbef
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|histbuf
index|[
name|i
index|]
argument_list|,
name|artid
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|nbef
operator|>=
name|NART
operator|-
literal|1
condition|)
block|{
return|return
name|FALSE
return|;
block|}
comment|/* Remember the name, but don't record it as saved yet. */
name|strcpy
argument_list|(
name|nextabuf
argument_list|,
name|artid
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_block

begin_comment
comment|/*  * The current article has actually been looked at, so record it as such.  */
end_comment

begin_macro
name|itsbeenseen
argument_list|(
argument|artid
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|artid
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|nextabuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|artid
argument_list|,
name|nextabuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|histbuf
index|[
name|nbef
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|artid
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|histbuf
index|[
name|nbef
operator|++
index|]
argument_list|,
name|artid
argument_list|)
expr_stmt|;
block|}
name|nextabuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_macro
name|back
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|fseek
argument_list|(
name|actfp
argument_list|,
operator|-
literal|2L
argument_list|,
literal|1
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|ftell
argument_list|(
name|actfp
argument_list|)
operator|>
literal|0L
condition|)
block|{
if|if
condition|(
name|getc
argument_list|(
name|actfp
argument_list|)
operator|==
literal|'\n'
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ftell
argument_list|(
name|actfp
argument_list|)
operator|==
literal|0L
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * Copy from one header structure to another.  * Really should just copy memory, if we had a memcpy.  */
end_comment

begin_expr_stmt
name|hbufcp
argument_list|(
name|hbuf2
argument_list|,
name|hbuf1
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hbuf1
operator|,
operator|*
name|hbuf2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|strcpy
argument_list|(
name|hbuf2
operator|->
name|path
argument_list|,
name|hbuf1
operator|->
name|path
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hbuf2
operator|->
name|from
argument_list|,
name|hbuf1
operator|->
name|from
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hbuf2
operator|->
name|replyto
argument_list|,
name|hbuf1
operator|->
name|replyto
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hbuf2
operator|->
name|nbuf
argument_list|,
name|hbuf1
operator|->
name|nbuf
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hbuf2
operator|->
name|title
argument_list|,
name|hbuf1
operator|->
name|title
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hbuf2
operator|->
name|ident
argument_list|,
name|hbuf1
operator|->
name|ident
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hbuf2
operator|->
name|subdate
argument_list|,
name|hbuf1
operator|->
name|subdate
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hbuf2
operator|->
name|recdate
argument_list|,
name|hbuf1
operator|->
name|recdate
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hbuf2
operator|->
name|expdate
argument_list|,
name|hbuf1
operator|->
name|expdate
argument_list|)
expr_stmt|;
name|hbuf2
operator|->
name|subtime
operator|=
name|hbuf1
operator|->
name|subtime
expr_stmt|;
name|hbuf2
operator|->
name|rectime
operator|=
name|hbuf1
operator|->
name|rectime
expr_stmt|;
name|hbuf2
operator|->
name|exptime
operator|=
name|hbuf1
operator|->
name|exptime
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Trap interrupts.  */
end_comment

begin_macro
name|onsig
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|signal
argument_list|(
name|n
argument_list|,
name|onsig
argument_list|)
expr_stmt|;
name|sigtrap
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|rcreadok
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Aborted early\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * finds the line in your .newsrc file (actually the in-core "rcline"  * copy of it) and returns the index into the array where it was found.  * -1 means it didn't find it.  *  * We play clever games here to make this faster.  It's inherently  * quadratic - we spend lots of CPU time here because we search through  * the whole .newsrc for each line.  The "prev" variable remembers where  * the last match was found; we start the search there and loop around  * to the beginning, in the hopes that the calls will be roughly in order.  */
end_comment

begin_function
name|int
name|findrcline
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|int
name|cur
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|top
decl_stmt|;
specifier|static
name|int
name|prev
init|=
literal|0
decl_stmt|;
name|top
operator|=
name|line
expr_stmt|;
name|i
operator|=
name|prev
expr_stmt|;
name|loop
label|:
for|for
control|(
init|;
name|i
operator|<=
name|top
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|p
operator|=
name|name
operator|,
name|ptr
operator|=
name|rcline
index|[
name|i
index|]
init|;
operator|(
name|cur
operator|=
operator|*
name|p
operator|++
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|cur
operator|!=
operator|*
name|ptr
operator|++
condition|)
goto|goto
name|contin2
goto|;
block|}
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|':'
operator|&&
operator|*
name|ptr
operator|!=
literal|'!'
condition|)
continue|continue;
name|prev
operator|=
name|i
expr_stmt|;
return|return
name|i
return|;
name|contin2
label|:
empty_stmt|;
block|}
if|if
condition|(
name|i
operator|>
name|line
operator|&&
name|line
operator|>
name|prev
operator|-
literal|1
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|prev
operator|-
literal|1
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

end_unit

