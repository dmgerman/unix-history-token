begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This function initializes all the strings used for the various  * filenames.  They cannot be compiled into the program, since that  * would be non-portable.  With this convention, the netnews sub-system  * can be owned by any non-priviledged user.  It is also possible  * to work when the administration randomly moves users from one  * filesystem to another.  The convention is that a particular user  * (HOME, see Makefile) is searched for in /etc/passwd and all files  * are presumed relative to there.  This method also allows one copy  * of the object code to be used on ANY machine.  (this code runs  * un-modified on 50+ machines at IH!!)  *  * The disadvantage to using this method is that all netnews programs  * (inews, readnews, rnews, checknews) must first search /etc/passwd  * before they can start up.  This can cause significant overhead if  * you have a big password file.  *  * Some games are played with ifdefs to get three .o files out of this  * one source file.  INEW is defined for inews, READ for readnews,  * and CHKN for checknews.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)pathinit.c	1.2	3/30/83"
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INEW
end_ifdef

begin_include
include|#
directive|include
file|"iparams.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|READ
end_ifdef

begin_include
include|#
directive|include
file|"rparams.h"
end_include

begin_decl_stmt
specifier|extern
name|char
name|MAILPARSER
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CHKN
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_decl_stmt
specifier|extern
name|char
name|SPOOL
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|LIB
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|ACTIVE
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EXP
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_decl_stmt
specifier|extern
name|char
name|SPOOL
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|LIB
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|ACTIVE
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|OLDNEWS
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|pathinit
argument_list|()
end_macro

begin_block
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
comment|/* struct for pw lookup			*/
name|FILE
modifier|*
name|nfd
decl_stmt|;
comment|/* notify file descriptor		*/
name|char
modifier|*
name|p
decl_stmt|;
if|#
directive|if
name|INEW
operator|||
name|READ
name|struct
name|utsname
name|ubuf
decl_stmt|;
name|uname
argument_list|(
operator|&
name|ubuf
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|FULLSYSNAME
argument_list|,
name|ubuf
operator|.
name|nodename
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|SYSNAME
argument_list|,
name|ubuf
operator|.
name|nodename
argument_list|)
expr_stmt|;
name|SYSNAME
index|[
name|SNLN
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HOME
comment|/* Relative to the home directory of user HOME */
name|sprintf
argument_list|(
name|SPOOL
argument_list|,
literal|"%s/%s"
argument_list|,
name|logdir
argument_list|(
name|HOME
argument_list|)
argument_list|,
name|SPOOLDIR
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|LIB
argument_list|,
literal|"%s/%s"
argument_list|,
name|logdir
argument_list|(
name|HOME
argument_list|)
argument_list|,
name|LIBDIR
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Fixed paths defined in Makefile */
name|strcpy
argument_list|(
name|SPOOL
argument_list|,
name|SPOOLDIR
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|LIB
argument_list|,
name|LIBDIR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|ACTIVE
argument_list|,
literal|"%s/active"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXP
name|strcpy
argument_list|(
name|OLDNEWS
argument_list|,
name|SPOOL
argument_list|)
expr_stmt|;
name|p
operator|=
name|rindex
argument_list|(
name|OLDNEWS
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|strcpy
argument_list|(
operator|++
name|p
argument_list|,
literal|"oldnews"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|INEW
operator|||
name|READ
name|sprintf
argument_list|(
name|LOCKFILE
argument_list|,
literal|"%s/LOCK"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|SEQFILE
argument_list|,
literal|"%s/seq"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|NGFILE
argument_list|,
literal|"%s/ngfile"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|SUBFILE
argument_list|,
literal|"%s/sys"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ARTFILE
argument_list|,
literal|"%s/history"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INEW
name|sprintf
argument_list|(
name|ARTICLE
argument_list|,
literal|"%s/.arXXXXXX"
argument_list|,
name|SPOOL
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|INFILE
argument_list|,
literal|"%s/.inXXXXXX"
argument_list|,
name|SPOOL
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|logfname
argument_list|,
literal|"%s/log"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|STASH
argument_list|,
literal|"%s/junk"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|READ
name|sprintf
argument_list|(
name|HELPFILE
argument_list|,
literal|"%s/help"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|CAESAR
argument_list|,
literal|"%s/caesar"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|USERS
argument_list|,
literal|"%s/users"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SENDMAIL
name|strcpy
argument_list|(
name|MAILPARSER
argument_list|,
name|SENDMAIL
argument_list|)
expr_stmt|;
comment|/* SENDMAIL includes -t */
else|#
directive|else
name|sprintf
argument_list|(
name|MAILPARSER
argument_list|,
literal|"%s/recmail"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/*  * The person notified by the netnews sub-system.  Again, no name is  * compiled in, but instead the information is taken from a file.  * If the file does not exist, a "default" person will get the mail.  * If the file exists, but is empty, nobody will get the mail.  This  * may seem backwards, but is a better fail-safe.  */
ifdef|#
directive|ifdef
name|NOTIFY
name|sprintf
argument_list|(
name|TELLFILE
argument_list|,
literal|"%s/notify"
argument_list|,
name|LIB
argument_list|)
expr_stmt|;
name|nfd
operator|=
name|fopen
argument_list|(
name|TELLFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfd
operator|==
name|NULL
condition|)
name|sprintf
argument_list|(
name|TELLME
argument_list|,
literal|"%s"
argument_list|,
name|NOTIFY
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fscanf
argument_list|(
name|nfd
argument_list|,
literal|"%s"
argument_list|,
name|TELLME
argument_list|)
operator|==
name|EOF
condition|)
name|strcpy
argument_list|(
name|TELLME
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  * Since the netnews owner's id number is different on different  * systems, we'll extract it from the /etc/passwd file.  If no entry,  * default to root.  This id number seems to only be used to control who  * can input certain control messages or cancel any message.  Note that  * entry is the name from the "notify" file as found above if possible.  * Defining ROOTID in defs.h hardwires in a number and avoids  * another search of /etc/passwd.  */
ifndef|#
directive|ifndef
name|ROOTID
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwname
argument_list|(
name|TELLME
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ROOTID
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwname
argument_list|(
name|HOME
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ROOTID
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
else|else
name|ROOTID
operator|=
literal|0
expr_stmt|;
comment|/* nobody left, let only root */
endif|#
directive|endif
endif|ROOTID
endif|#
directive|endif
endif|INEW || READ
block|}
end_block

end_unit

