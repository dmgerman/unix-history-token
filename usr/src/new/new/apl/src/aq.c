begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|Sccsid
index|[]
init|=
literal|"aq.c @(#)aq.c	1.1	10/1/82 Berkeley "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      malloc/free/afreset -- dynamic memory allocation  *  *  * This source file is a slight modificattion of the alloc/free system  * described by Kernighan and Ritchie in "The C Programming Language",  * pp. 174-177.  *  * The modifications include allocation by a bestfit (rather than  * firstfit) strategy, and ability to reset memory completely.  */
end_comment

begin_comment
comment|/* NOTE: the "afnfree" and "afnused" values are not precise.  They  * do not currently refect the allocation and release of headers.  * This will be changed soon (I hope).  * --J. Bruner  */
end_comment

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_comment
comment|/* null value */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|vax
end_ifndef

begin_define
define|#
directive|define
name|NALLOC
value|128
end_define

begin_comment
comment|/* # of units requested on each "sbrk" */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NALLOC
value|1024
end_define

begin_comment
comment|/* lots of memory each time for vaxes */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|int
name|ALIGN
typedef|;
end_typedef

begin_comment
comment|/* force alignment on PDP-11 and VAX */
end_comment

begin_union
union|union
name|header
block|{
comment|/* free block header structure */
struct|struct
block|{
name|union
name|header
modifier|*
name|ptr
decl_stmt|;
comment|/* next free block */
name|unsigned
name|size
decl_stmt|;
comment|/* size of this free block */
block|}
name|s
struct|;
name|ALIGN
name|x
decl_stmt|;
comment|/* force alignment of blocks */
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|header
name|HEADER
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|HEADER
name|base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* empty list to get started */
end_comment

begin_decl_stmt
specifier|static
name|HEADER
modifier|*
name|allocp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last allocated block */
end_comment

begin_decl_stmt
name|int
name|aftrace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|afnfree
decl_stmt|,
name|afnused
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|malloc
parameter_list|(
name|nbytes
parameter_list|)
name|unsigned
name|nbytes
decl_stmt|;
block|{
name|HEADER
modifier|*
name|morecore
parameter_list|()
function_decl|;
specifier|register
name|HEADER
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|rp
decl_stmt|;
name|HEADER
modifier|*
name|rq
decl_stmt|;
specifier|register
name|unsigned
name|nunits
decl_stmt|;
comment|/* malloc is a general-purpose memory allocator.  It is called 	 * with the desired number of bytes, expressed as an unsigned 	 * integer, and it returns the address of the allocated memory. 	 * If "aftrace" is non-zero, a trace of the allocation will 	 * be printed.  If it is not possible to alloate what is 	 * requested, the error "workspace exceeded" will result. 	 * 	 * This routine was originally called "alloc" but was changed 	 * to "malloc" because an increasing number of library routines 	 * perform dynamic memory allocation.  A macro in "apl.h" 	 * converts calls on "alloc" to calls on "malloc". 	 */
name|nunits
operator|=
literal|1
operator|+
operator|(
name|nbytes
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|allocp
operator|)
operator|==
name|NULL
condition|)
block|{
name|base
operator|.
name|s
operator|.
name|ptr
operator|=
name|allocp
operator|=
name|q
operator|=
operator|&
name|base
expr_stmt|;
comment|/* start list */
name|base
operator|.
name|s
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Search list for smallest free block */
name|rp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|q
operator|->
name|s
operator|.
name|ptr
init|;
condition|;
name|q
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|s
operator|.
name|ptr
control|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|s
operator|.
name|size
operator|>=
name|nunits
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|rp
operator|)
operator|||
name|p
operator|->
name|s
operator|.
name|size
operator|<
name|rp
operator|->
name|s
operator|.
name|size
condition|)
block|{
name|rp
operator|=
name|p
expr_stmt|;
name|rq
operator|=
name|q
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|s
operator|.
name|size
operator|==
name|nunits
condition|)
break|break;
block|}
if|if
condition|(
name|p
operator|==
name|allocp
condition|)
break|break;
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|s
operator|.
name|ptr
expr_stmt|;
block|}
if|if
condition|(
name|rp
condition|)
break|break;
if|if
condition|(
operator|(
name|p
operator|=
name|morecore
argument_list|(
name|nunits
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"workspace exceeded"
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate memory as needed */
if|if
condition|(
name|rp
operator|->
name|s
operator|.
name|size
operator|==
name|nunits
condition|)
name|rq
operator|->
name|s
operator|.
name|ptr
operator|=
name|rp
operator|->
name|s
operator|.
name|ptr
expr_stmt|;
else|else
block|{
name|rp
operator|->
name|s
operator|.
name|size
operator|-=
name|nunits
expr_stmt|;
name|rp
operator|+=
name|rp
operator|->
name|s
operator|.
name|size
expr_stmt|;
name|rp
operator|->
name|s
operator|.
name|size
operator|=
name|nunits
expr_stmt|;
block|}
name|allocp
operator|=
name|rq
expr_stmt|;
if|if
condition|(
name|aftrace
condition|)
name|printf
argument_list|(
literal|"[alloc: %d at %o]\n"
argument_list|,
operator|(
name|int
operator|)
name|nunits
operator|*
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|afnfree
operator|-=
name|nunits
expr_stmt|;
name|afnused
operator|+=
name|nunits
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|rp
operator|+
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|HEADER
modifier|*
name|morecore
parameter_list|(
name|nu
parameter_list|)
name|unsigned
name|nu
decl_stmt|;
block|{
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|up
decl_stmt|;
specifier|register
name|int
name|rnu
decl_stmt|;
comment|/* Ask system for more memory.  Requests are made in blocks 	 * of NALLOC header units.  Returns NULL if request fails, 	 * "allocp" on success. 	 */
name|rnu
operator|=
name|NALLOC
operator|*
operator|(
operator|(
name|nu
operator|+
name|NALLOC
operator|-
literal|1
operator|)
operator|/
name|NALLOC
operator|)
expr_stmt|;
name|cp
operator|=
name|sbrk
argument_list|(
name|rnu
operator|*
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|cp
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* no more space */
if|if
condition|(
name|aftrace
condition|)
name|printf
argument_list|(
literal|"[morecore: %d at %o]\n"
argument_list|,
name|rnu
operator|*
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|up
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|cp
expr_stmt|;
name|up
operator|->
name|s
operator|.
name|size
operator|=
name|rnu
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|up
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|allocp
operator|)
return|;
block|}
end_function

begin_macro
name|free
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|HEADER
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|unsigned
name|fsize
decl_stmt|;
comment|/* Put block into free list.  Used by "morecore" to put a newly- 	 * allocated block of memory into the freelist -- also used to 	 * return a previously allocated block to the freelist. 	 */
name|p
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|ap
operator|-
literal|1
expr_stmt|;
comment|/* point to header */
name|fsize
operator|=
name|p
operator|->
name|s
operator|.
name|size
expr_stmt|;
for|for
control|(
name|q
operator|=
name|allocp
init|;
operator|!
operator|(
name|p
operator|>
name|q
operator|&&
name|p
operator|<
name|q
operator|->
name|s
operator|.
name|ptr
operator|)
condition|;
name|q
operator|=
name|q
operator|->
name|s
operator|.
name|ptr
control|)
if|if
condition|(
name|q
operator|>=
name|q
operator|->
name|s
operator|.
name|ptr
operator|&&
operator|(
name|p
operator|>
name|q
operator|||
name|p
operator|<
name|q
operator|->
name|s
operator|.
name|ptr
operator|)
condition|)
break|break;
if|if
condition|(
name|p
operator|+
name|p
operator|->
name|s
operator|.
name|size
operator|==
name|q
operator|->
name|s
operator|.
name|ptr
condition|)
block|{
comment|/* join to upper nbr */
name|p
operator|->
name|s
operator|.
name|size
operator|+=
name|q
operator|->
name|s
operator|.
name|ptr
operator|->
name|s
operator|.
name|size
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|ptr
operator|=
name|q
operator|->
name|s
operator|.
name|ptr
operator|->
name|s
operator|.
name|ptr
expr_stmt|;
block|}
else|else
name|p
operator|->
name|s
operator|.
name|ptr
operator|=
name|q
operator|->
name|s
operator|.
name|ptr
expr_stmt|;
if|if
condition|(
name|q
operator|+
name|q
operator|->
name|s
operator|.
name|size
operator|==
name|p
condition|)
block|{
comment|/* join to lower nbr */
name|q
operator|->
name|s
operator|.
name|size
operator|+=
name|p
operator|->
name|s
operator|.
name|size
expr_stmt|;
name|q
operator|->
name|s
operator|.
name|ptr
operator|=
name|p
operator|->
name|s
operator|.
name|ptr
expr_stmt|;
block|}
else|else
name|q
operator|->
name|s
operator|.
name|ptr
operator|=
name|p
expr_stmt|;
name|allocp
operator|=
name|q
expr_stmt|;
name|afnfree
operator|+=
name|fsize
expr_stmt|;
name|afnused
operator|-=
name|fsize
expr_stmt|;
if|if
condition|(
name|aftrace
condition|)
name|printf
argument_list|(
literal|"[free: %d at %o]\n"
argument_list|,
name|fsize
operator|*
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|afreset
argument_list|()
end_macro

begin_block
block|{
extern|extern end;
comment|/* Zap all dynamic allocation by resettting the lists and 	 * releasing all additional memory. 	 */
name|allocp
operator|=
name|NULL
expr_stmt|;
name|brk
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|end
argument_list|)
expr_stmt|;
name|afnfree
operator|=
name|afnused
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aftrace
condition|)
name|printf
argument_list|(
literal|"[afreset: dynamic allocation released]\n"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

