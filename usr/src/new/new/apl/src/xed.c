begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|Sccsid
index|[]
init|=
literal|"xed.c @(#)xed.c	1.1	10/1/82 Berkeley "
decl_stmt|;
end_decl_stmt

begin_empty
empty|#
end_empty

begin_comment
comment|/*  *	V7.15 81/09/16 14:22	Fixed bug causing bus errors occasionally  *	V7.14 81/09/10 21:50	-B dynamically allocated line buffer  *	V7.13 81/07/25 22:51	added -O and "long" pointers  *  * Editor  *  *	Major additions beginning	77/04  *	Conversion to version 7		79/12  *	Conversion to VAX		80/11  *  *	Purdue University, Engineering Computer Network  *  *	Tgi -- Room 337A  *	Electrical Engineering Dept  *	Purdue University  *	West Lafayette, Indiana  *	47907  *	317/49-41592  */
end_comment

begin_define
define|#
directive|define
name|XED
end_define

begin_comment
comment|/* enable powerful stuff */
end_comment

begin_define
define|#
directive|define
name|V7
end_define

begin_comment
comment|/* enable environment stuff for protocol */
end_comment

begin_comment
comment|/*  *	At the entry to a function (PDP-11) the following sequence  *	of instructions is executed:  *		func:	jsr	r5,csv  *		csv:	mov	r5,r0  *		csv+2:	mov	sp,r5  *	If a signal occurs between the first and second, or between the  *	second and third instructions, r5 will NOT contain a valid  *	stack address.  Hence, when longjmp() attempts to validate  *	the environment pointer (r5) links, an instruction will be  *	fetched instead of a valid pointer, and will generally cause  *	one of "memory fault", "bus error", or "illegal instruction"  *	resulting in the loss of the editing session.  *  *	Due to this wonderful feature of version 7 ingenuity, I have  *	reverted to using setexit/reset, since they are simpler and  *	do not assume that I do not know what I am doing.  *  *	80/11/10 V7.01 Tgi  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|pdp11
end_ifndef

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_decl_stmt
name|jmp_buf
name|_env_rst
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|setexit
parameter_list|()
value|setjmp(_env_rst)
end_define

begin_define
define|#
directive|define
name|reset
parameter_list|()
value|longjmp(_env_rst,1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/*  * Machine-dependent definitions  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|pdp11
end_ifdef

begin_define
define|#
directive|define
name|BPB
value|8
end_define

begin_comment
comment|/* bits per byte */
end_comment

begin_define
define|#
directive|define
name|BPW
value|(BPB*sizeof(int))
end_define

begin_comment
comment|/* bits per word */
end_comment

begin_define
define|#
directive|define
name|BPWC
value|4
end_define

begin_comment
comment|/* log2(BPW) */
end_comment

begin_define
define|#
directive|define
name|BPWM
value|017
end_define

begin_comment
comment|/* mask of BPWC bits */
end_comment

begin_typedef
typedef|typedef
name|short
name|block
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|short
name|charac
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|short
name|filedes
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|short
name|flag
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|short
name|linep
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_define
define|#
directive|define
name|BPB
value|8
end_define

begin_comment
comment|/* bits per byte */
end_comment

begin_define
define|#
directive|define
name|BPW
value|(BPB*sizeof(int))
end_define

begin_comment
comment|/* bits per word */
end_comment

begin_define
define|#
directive|define
name|BPWC
value|5
end_define

begin_comment
comment|/* log2(BPW) */
end_comment

begin_define
define|#
directive|define
name|BPWM
value|037
end_define

begin_comment
comment|/* mask of BPWC bits */
end_comment

begin_typedef
typedef|typedef
name|long
name|block
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|charac
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|short
name|filedes
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|char
name|flag
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|long
name|linep
typedef|;
end_typedef

begin_comment
comment|/* NEW */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * conditional compilation  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XED
end_ifdef

begin_define
define|#
directive|define
name|AGAIN
end_define

begin_comment
comment|/* enable "o" "again" command */
end_comment

begin_define
define|#
directive|define
name|ALLOC
value|1024
end_define

begin_comment
comment|/* line buffer size */
end_comment

begin_define
define|#
directive|define
name|APLMAP
end_define

begin_comment
comment|/* enable Apl character mapping */
end_comment

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_comment
comment|/* enable "du" command */
end_comment

begin_define
define|#
directive|define
name|DUMB
value|0
end_define

begin_comment
comment|/* enable command to disable spcl chars */
end_comment

begin_define
define|#
directive|define
name|EOL
end_define

begin_comment
comment|/* enable special eol stuff */
end_comment

begin_define
define|#
directive|define
name|EXTMARK
end_define

begin_comment
comment|/* extended "k" capability */
end_comment

begin_define
define|#
directive|define
name|G_VFY
end_define

begin_comment
comment|/* enable verifying on "g" command */
end_comment

begin_define
define|#
directive|define
name|HELP
value|"/etc/xed.doc"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|pdp11
end_ifdef

begin_comment
comment|/* only needed on 16-bit machines */
end_comment

begin_define
define|#
directive|define
name|HUGE
end_define

begin_comment
comment|/* enable "huge" file stuff */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PAGE
end_define

begin_comment
comment|/* enable proper line counting on ":" */
end_comment

begin_define
define|#
directive|define
name|PARENS
end_define

begin_comment
comment|/* enable "b" suffix to count parentheses */
end_comment

begin_define
define|#
directive|define
name|PIPE
end_define

begin_comment
comment|/* enable | command to pipe to process */
end_comment

begin_define
define|#
directive|define
name|PROMPT
value|">"
end_define

begin_define
define|#
directive|define
name|STRLEN
end_define

begin_comment
comment|/* enable string-length counting code */
end_comment

begin_define
define|#
directive|define
name|TABS
value|((LBSIZE+sizeof(int)-1)/sizeof(int))
end_define

begin_comment
comment|/* words for tab stops */
end_comment

begin_define
define|#
directive|define
name|TTL
value|"XED\tV7.15"
end_define

begin_comment
comment|/* #define TTL_NL	9	/* location of newline in TTL */
end_comment

begin_define
define|#
directive|define
name|UNDO
end_define

begin_comment
comment|/* enable "u"ndo command */
end_comment

begin_define
define|#
directive|define
name|USE
end_define

begin_comment
comment|/* enable "@" command */
end_comment

begin_define
define|#
directive|define
name|XDEL
end_define

begin_comment
comment|/* enable undelete stuff */
end_comment

begin_define
define|#
directive|define
name|YINT
end_define

begin_comment
comment|/* enable special interrupt processing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * stuff for EED, instead of XED  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|XED
end_ifndef

begin_define
define|#
directive|define
name|HELP
value|"/etc/eed.doc"
end_define

begin_define
define|#
directive|define
name|PROMPT
value|"*"
end_define

begin_define
define|#
directive|define
name|TTL
value|"EED"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EEDHELP
value|"/etc/eed.doc"
end_define

begin_define
define|#
directive|define
name|EEDPROMPT
value|"*"
end_define

begin_define
define|#
directive|define
name|EEDTTL
value|"EED"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * stuff normally enabled  */
end_comment

begin_define
define|#
directive|define
name|CLEAR
value|"\33:\33H\33J\32\14"
end_define

begin_comment
comment|/* HP-2640A, Lear ADM-3A */
end_comment

begin_define
define|#
directive|define
name|CMDS
value|"edsav"
end_define

begin_comment
comment|/* all commands written if exists */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DUMB
end_ifndef

begin_define
define|#
directive|define
name|DUMB
value|1
end_define

begin_comment
comment|/* enable command to disable spcl chars */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * special stuff, occasionally enabled  */
end_comment

begin_define
define|#
directive|define
name|LOG
value|"/a/tgi/etc/xed.log"
end_define

begin_comment
comment|/* feature use logging */
end_comment

begin_comment
comment|/*  * data #defines  */
end_comment

begin_define
define|#
directive|define
name|BAK
value|4
end_define

begin_comment
comment|/* file.bak - backup() */
end_comment

begin_define
define|#
directive|define
name|BLKSIZE
value|512
end_define

begin_comment
comment|/* disk block size (bytes) */
end_comment

begin_define
define|#
directive|define
name|BS1
value|0100000
end_define

begin_comment
comment|/* stty() */
end_comment

begin_define
define|#
directive|define
name|CBACK
value|14
end_define

begin_comment
comment|/* back-reference: \(blah\)more\1 */
end_comment

begin_define
define|#
directive|define
name|CBRA
value|1
end_define

begin_comment
comment|/* \( */
end_comment

begin_define
define|#
directive|define
name|CCHR
value|2
end_define

begin_comment
comment|/* literal character */
end_comment

begin_define
define|#
directive|define
name|CCL
value|6
end_define

begin_comment
comment|/* character class [x...y] */
end_comment

begin_define
define|#
directive|define
name|CCOUNT
value|(80-1)
end_define

begin_comment
comment|/* terminal width */
end_comment

begin_define
define|#
directive|define
name|CDOL
value|10
end_define

begin_comment
comment|/* ...$ */
end_comment

begin_define
define|#
directive|define
name|CDOT
value|4
end_define

begin_comment
comment|/*  .  */
end_comment

begin_define
define|#
directive|define
name|CEOF
value|11
end_define

begin_comment
comment|/* end of pattern */
end_comment

begin_define
define|#
directive|define
name|CKET
value|12
end_define

begin_comment
comment|/* \) */
end_comment

begin_define
define|#
directive|define
name|EOF
value|-1
end_define

begin_comment
comment|/* end of file */
end_comment

begin_define
define|#
directive|define
name|ESIZE
value|128
end_define

begin_comment
comment|/* regular expression size */
end_comment

begin_define
define|#
directive|define
name|FILE
value|0
end_define

begin_comment
comment|/* no extension - backup() */
end_comment

begin_define
define|#
directive|define
name|FNSIZE
value|64
end_define

begin_comment
comment|/* max size of pathname to file */
end_comment

begin_define
define|#
directive|define
name|GBSIZE
value|256
end_define

begin_comment
comment|/* max global command length */
end_comment

begin_define
define|#
directive|define
name|HUP
value|3
end_define

begin_comment
comment|/* file.hup - backup() */
end_comment

begin_define
define|#
directive|define
name|INT
value|2
end_define

begin_comment
comment|/* file.int - backup() */
end_comment

begin_define
define|#
directive|define
name|LBSIZE
value|512
end_define

begin_comment
comment|/* max line length */
end_comment

begin_define
define|#
directive|define
name|LMASK
value|077
end_define

begin_comment
comment|/* mask for "locked" file */
end_comment

begin_define
define|#
directive|define
name|LMODE
value|(MODE&~LMASK)
end_define

begin_comment
comment|/* mode for "locked" file */
end_comment

begin_define
define|#
directive|define
name|MODCNT
value|35
end_define

begin_comment
comment|/* default mod count before auto-write */
end_comment

begin_define
define|#
directive|define
name|MODE
value|0666
end_define

begin_comment
comment|/* mode for normal files */
end_comment

begin_define
define|#
directive|define
name|NBRA
value|9
end_define

begin_comment
comment|/* number of \( \) pairs */
end_comment

begin_define
define|#
directive|define
name|NCCL
value|8
end_define

begin_comment
comment|/* not in character class: [^x...y] */
end_comment

begin_define
define|#
directive|define
name|PAGSIZ
value|22
end_define

begin_comment
comment|/* page size for ":" command */
end_comment

begin_define
define|#
directive|define
name|READ
value|0
end_define

begin_comment
comment|/* getblock: read function */
end_comment

begin_define
define|#
directive|define
name|SIGBUS
value|10
end_define

begin_comment
comment|/* Bus error */
end_comment

begin_define
define|#
directive|define
name|SIGEMT
value|7
end_define

begin_comment
comment|/* EMT trap */
end_comment

begin_define
define|#
directive|define
name|SIGFPE
value|8
end_define

begin_comment
comment|/* Floating Point Exception */
end_comment

begin_define
define|#
directive|define
name|SIGHUP
value|1
end_define

begin_comment
comment|/* Hangup signal */
end_comment

begin_define
define|#
directive|define
name|SIGILL
value|4
end_define

begin_comment
comment|/* Illegal instruction */
end_comment

begin_define
define|#
directive|define
name|SIGINT
value|2
end_define

begin_comment
comment|/* Interrupt signal */
end_comment

begin_define
define|#
directive|define
name|SIGIOT
value|6
end_define

begin_comment
comment|/* IOT trap */
end_comment

begin_define
define|#
directive|define
name|SIGPIP
value|13
end_define

begin_comment
comment|/* Broken pipe for ! stuff */
end_comment

begin_define
define|#
directive|define
name|SIGQIT
value|3
end_define

begin_comment
comment|/* Quit signal */
end_comment

begin_define
define|#
directive|define
name|SIGSEGV
value|11
end_define

begin_comment
comment|/* Memory fault */
end_comment

begin_define
define|#
directive|define
name|SIGSYS
value|12
end_define

begin_comment
comment|/* Bad system call */
end_comment

begin_define
define|#
directive|define
name|SIGTRC
value|5
end_define

begin_comment
comment|/* Trace/BPT for mail stuff */
end_comment

begin_define
define|#
directive|define
name|SIGTRM
value|15
end_define

begin_comment
comment|/* Termination */
end_comment

begin_define
define|#
directive|define
name|STAR
value|1
end_define

begin_comment
comment|/*  *  */
end_comment

begin_define
define|#
directive|define
name|TABFILL
value|'\t'
end_define

begin_comment
comment|/* fill character for tab expansion */
end_comment

begin_define
define|#
directive|define
name|TMP
value|1
end_define

begin_comment
comment|/* file.edt - backup() */
end_comment

begin_define
define|#
directive|define
name|TRM
value|5
end_define

begin_comment
comment|/* file.trm - backup() */
end_comment

begin_define
define|#
directive|define
name|TTSIZE
value|(512+4)
end_define

begin_comment
comment|/* terminal output buffer size */
end_comment

begin_define
define|#
directive|define
name|WRITE
value|1
end_define

begin_comment
comment|/* getblock: write function */
end_comment

begin_define
define|#
directive|define
name|ever
value|(;;)
end_define

begin_define
define|#
directive|define
name|error
value|errfunc
end_define

begin_define
define|#
directive|define
name|ctrl
parameter_list|(
name|x
parameter_list|)
value|((x)&037)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|AGAIN
end_ifdef

begin_decl_stmt
name|char
name|agbuf
index|[
name|GBSIZE
index|]
decl_stmt|,
comment|/* save area for "again" command */
modifier|*
name|agp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "again" command pointer */
end_comment

begin_decl_stmt
name|flag
name|agf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "again" flag  (executing the command) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ALLOC
end_ifdef

begin_decl_stmt
name|int
name|lbsize
init|=
name|LBSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line buffer size */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|APLMAP
end_ifdef

begin_decl_stmt
name|flag
name|aplmap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Apl character mapping */
end_comment

begin_include
include|#
directive|include
file|"aplmap.h"
end_include

begin_comment
comment|/* apl ADM-3A char set mapping tables */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CKPT
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|cfname
init|=
literal|"/tmp/ce00000"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* filename for checkpoint */
end_comment

begin_decl_stmt
name|int
name|recovry
init|=
literal|0
decl_stmt|,
comment|/* non-zero to recover checkpointed session */
name|tfnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index into tfname for "00000" string */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CLEAR
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|clears
init|=
name|CLEAR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* screen-clear sequence */
end_comment

begin_decl_stmt
name|flag
name|zflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if "stty bs1" not set */
end_comment

begin_comment
comment|/* bs1 displays ctrl-z as ^Z on tty */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CMDS
end_ifdef

begin_decl_stmt
name|filedes
name|cmd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file des for command-save file */
end_comment

begin_decl_stmt
name|char
name|cmdfil
index|[]
init|=
name|CMDS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* command-save file */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|flag
name|tflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tracing flag */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DUMB
end_ifdef

begin_decl_stmt
name|flag
name|dumbf
init|=
name|DUMB
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 = disable special chars in patterns */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EOL
end_ifdef

begin_decl_stmt
name|charac
name|eol
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "end-of-line" char for multiple commands */
end_comment

begin_comment
comment|/*   per line */
end_comment

begin_decl_stmt
name|flag
name|prompt3
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* disable prompts for "eol" stuff */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|G_VFY
end_ifdef

begin_decl_stmt
name|flag
name|gaskf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* verify mode on global command */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HELP
end_ifdef

begin_decl_stmt
name|filedes
name|doc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "help" file descriptor */
end_comment

begin_decl_stmt
name|char
modifier|*
name|help
init|=
name|HELP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "help" file name */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_decl_stmt
name|char
name|logfile
index|[]
init|=
name|LOG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* logging use of features */
end_comment

begin_decl_stmt
name|filedes
name|lfile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* logging file descriptor */
end_comment

begin_decl_stmt
name|short
name|logamp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* since s/x/&/ may be done many times */
end_comment

begin_struct
struct|struct
name|logstat
block|{
name|short
name|l_uid
decl_stmt|;
comment|/* user id of caller */
name|char
name|l_xed
decl_stmt|,
comment|/* 1 if xed, 0 if eed, 2 if apled */
name|l_inter
decl_stmt|;
comment|/* 1 if interactive */
comment|/* command features */
name|short
name|lc_shell
decl_stmt|,
comment|/*  !  */
name|lc_pipe
decl_stmt|,
comment|/*  |  */
name|lc_piplus
decl_stmt|,
comment|/*  |+  */
name|lc_piminus
decl_stmt|,
comment|/*  |-  */
name|lc_dpipe
decl_stmt|,
comment|/*  ||  */
name|lc_pfrom
decl_stmt|,
comment|/*  |<  */
name|lc_pto
decl_stmt|,
comment|/*  |>  */
name|lc_at
decl_stmt|,
comment|/*  @  */
name|lc_colon
decl_stmt|,
comment|/*  :  */
name|lc_star
decl_stmt|,
comment|/*  *  */
name|lc_clnminus
decl_stmt|,
comment|/*  :-  */
name|lc_comment
decl_stmt|,
comment|/*  : stuff  or  * stuff  */
name|lc_append
decl_stmt|,
comment|/*  a  */
name|lc_abort
decl_stmt|,
comment|/*  abort  */
name|lc_aspace
decl_stmt|,
comment|/*  a line  */
name|lc_aslash
decl_stmt|,
comment|/*  a/string/  */
name|lc_browse
decl_stmt|,
comment|/*  bN  */
name|lc_change
decl_stmt|,
comment|/*  c  */
name|lc_cslash
decl_stmt|,
comment|/*  c/s1/s2/  */
name|lc_copy
decl_stmt|,
comment|/*  coNN  */
name|lc_delete
decl_stmt|,
comment|/*  d  */
name|lc_depth
decl_stmt|,
comment|/*  d=NN  */
name|lc_directory
decl_stmt|,
comment|/*  d path  */
name|lc_edit
decl_stmt|,
comment|/*  e file  */
name|lc_eol
decl_stmt|,
comment|/*  e=C  */
name|lc_errmsg
decl_stmt|,
comment|/*  eNN  */
name|lc_exp
decl_stmt|,
comment|/*  exp  */
name|lc_eplus
decl_stmt|,
comment|/*  e+  */
name|lc_eminus
decl_stmt|,
comment|/*  e-  */
name|lc_fshow
decl_stmt|,
comment|/*  f  */
name|lc_fset
decl_stmt|,
comment|/*  f file  */
name|lc_fillset
decl_stmt|,
comment|/*  f=C  */
name|lc_global
decl_stmt|,
comment|/*  g/str/cmd  */
name|lc_gvfy
decl_stmt|,
comment|/*  g/str/vcmd  */
name|lc_header
decl_stmt|,
comment|/*  h  */
name|lc_help
decl_stmt|,
comment|/*  help  */
name|lc_insert
decl_stmt|,
comment|/*  i  */
name|lc_islash
decl_stmt|,
comment|/*  i/string/  */
name|lc_join
decl_stmt|,
comment|/*  j  */
name|lc_jglue
decl_stmt|,
comment|/*  j/glue/  */
name|lc_klist
decl_stmt|,
comment|/*  k  */
name|lc_kset
decl_stmt|,
comment|/*  kC  */
name|lc_list
decl_stmt|,
comment|/*  l  */
name|lc_move
decl_stmt|,
comment|/*  mNN  */
name|lc_moove
decl_stmt|,
comment|/*  moNN  */
name|lc_magic
decl_stmt|,
comment|/*  m  */
name|lc_numbers
decl_stmt|,
comment|/*  n  */
name|lc_numinus
decl_stmt|,
comment|/*  n-  */
name|lc_numplus
decl_stmt|,
comment|/*  n+  */
name|lc_o
decl_stmt|,
comment|/*  o ^Q  */
name|lc_print
decl_stmt|,
comment|/*  p  */
name|lc_pprint
decl_stmt|,
comment|/*  pp  */
name|lc_quit
decl_stmt|,
comment|/*  q  */
name|lc_qimm
decl_stmt|,
comment|/*  qi  */
name|lc_quote
decl_stmt|,
comment|/*  q=C  */
name|lc_read
decl_stmt|,
comment|/*  r  */
name|lc_substitute
decl_stmt|,
comment|/*  s/s1/s2/  */
name|lc_stop
decl_stmt|,
comment|/*  s  */
name|lc_savecount
decl_stmt|,
comment|/*  saNN  */
name|lc_tablist
decl_stmt|,
comment|/*  t  */
name|lc_tabset
decl_stmt|,
comment|/*  t,NN  */
name|lc_tabchar
decl_stmt|,
comment|/*  t=C  */
name|lc_transfer
decl_stmt|,
comment|/*  tNN  */
name|lc_undo
decl_stmt|,
comment|/*  u  */
name|lc_vglobal
decl_stmt|,
comment|/*  v/str/cmd  */
name|lc_write
decl_stmt|,
comment|/*  w  */
name|lc_wonto
decl_stmt|,
comment|/*  w>  */
name|lc_wimm
decl_stmt|,
comment|/*  wi  */
name|lc_width
decl_stmt|,
comment|/*  w=NN  */
name|lc_xundelete
decl_stmt|,
comment|/*  x  */
name|lc_yintr
decl_stmt|,
comment|/*  y  */
name|lc_yminus
decl_stmt|,
comment|/*  y-  */
name|lc_yplus
decl_stmt|,
comment|/*  y+  */
comment|/* address features */
name|la_dot
decl_stmt|,
comment|/*  .  */
name|la_dotdot
decl_stmt|,
comment|/*  ..  */
name|la_dol
decl_stmt|,
comment|/*  $  */
name|la_num
decl_stmt|,
comment|/*  NN  */
name|la_plus
decl_stmt|,
comment|/*  +  */
name|la_minus
decl_stmt|,
comment|/*  -  */
name|la_caret
decl_stmt|,
comment|/*  ^  */
name|la_quote
decl_stmt|,
comment|/*  'a  */
name|la_letter
decl_stmt|,
comment|/*  A  */
name|la_slash
decl_stmt|,
comment|/*  /str/  */
name|la_query
decl_stmt|,
comment|/*  ?str?  */
name|la_equal
decl_stmt|,
comment|/*  =  */
comment|/* pattern features */
name|lp_caret
decl_stmt|,
comment|/*  ^  */
name|lp_dol
decl_stmt|,
comment|/*  $  */
name|lp_dot
decl_stmt|,
comment|/*  .  */
name|lp_star
decl_stmt|,
comment|/*  *  */
name|lp_ccl
decl_stmt|,
comment|/*  [ ]  */
name|lp_nccl
decl_stmt|,
comment|/*  [^ ]  */
name|lp_paren
decl_stmt|,
comment|/*  \( \)  */
name|lp_digit
decl_stmt|,
comment|/*  \1 \2 \3 ...  */
comment|/* substitution features */
name|lp_amp
decl_stmt|,
comment|/*&  */
comment|/* miscellaneous features */
name|lm_quote
decl_stmt|,
comment|/*  ...q  */
name|lm_bracket
decl_stmt|,
comment|/*  ...b  */
name|lm_overwrite
decl_stmt|;
comment|/*  -O,wi  */
comment|/* resources */
name|long
name|lt_start
decl_stmt|,
comment|/* starting time */
name|lt_end
decl_stmt|,
comment|/* elapsed time */
name|lt_usercpu
decl_stmt|,
comment|/* user cpu time */
name|lt_syscpu
decl_stmt|,
comment|/* system cpu time */
name|lt_kidscpu
decl_stmt|,
comment|/* total ! kids time */
name|lt_rlines
decl_stmt|,
comment|/* total lines read */
name|lt_wlines
decl_stmt|;
comment|/* total lines written */
block|}
name|logstats
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PAGE
end_ifdef

begin_decl_stmt
name|int
name|ccount
init|=
name|CCOUNT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminal width */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PARENS
end_ifdef

begin_decl_stmt
name|int
name|parenc
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* parentheses counts */
end_comment

begin_decl_stmt
name|flag
name|parenf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count parentheses and brackets */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PIPE
end_ifdef

begin_decl_stmt
name|filedes
name|pfile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "pipe" file descriptor */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pfname
init|=
literal|"/tmp/ep00000"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for "double-piping" */
end_comment

begin_decl_stmt
name|flag
name|piperr
init|=
literal|0
decl_stmt|,
comment|/* pipe error flag - shell() */
name|pno
init|=
operator|-
literal|1
decl_stmt|,
comment|/* piping line numbering flag (default n-) */
name|strict
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* strict exit status checking for | */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STRLEN
end_ifdef

begin_decl_stmt
name|charac
name|quotec
init|=
literal|'\0'
decl_stmt|,
comment|/* quote character other than " or ' */
name|quotec2
init|=
literal|'\0'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* closing quote */
end_comment

begin_decl_stmt
name|int
name|quotef
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of strings within " or ' chars */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TABS
end_ifdef

begin_decl_stmt
name|charac
name|tabfill
init|=
name|TABFILL
decl_stmt|,
comment|/* fill character */
name|tabc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tab character - if 0 no tab processing */
end_comment

begin_decl_stmt
name|int
name|maxtab
init|=
operator|-
literal|1
decl_stmt|,
comment|/* last column number with tab stop */
name|tabs
index|[
name|TABS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* each bit on = tab stop */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UNDO
end_ifdef

begin_decl_stmt
name|linep
name|undo_oldp
decl_stmt|,
comment|/* original line pointer */
name|undo_newp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* replacement line */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE
end_ifdef

begin_decl_stmt
name|filedes
name|alt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* alternate command input file */
end_comment

begin_decl_stmt
name|char
name|altfile
index|[
name|FNSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|flag
name|eflg2
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* another kludge */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XDEL
end_ifdef

begin_decl_stmt
name|linep
name|deleted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to deleted line pointers */
end_comment

begin_decl_stmt
name|int
name|ndeleted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of lines */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|YINT
end_ifdef

begin_decl_stmt
name|flag
name|yflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* page upon interrupt */
end_comment

begin_decl_stmt
name|linep
modifier|*
name|yplus
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* page from this line - if zero, from dot */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * globals  */
end_comment

begin_decl_stmt
name|block
name|iblock
init|=
operator|-
literal|1
decl_stmt|,
comment|/* block number of input buffer */
name|oblock
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output buffer block number */
end_comment

begin_decl_stmt
name|char
modifier|*
name|braelist
index|[
name|NBRA
index|]
decl_stmt|,
comment|/* bracket \( \) end list */
modifier|*
name|braslist
index|[
name|NBRA
index|]
decl_stmt|,
comment|/* bracket \( \) start list */
name|dotbak
index|[]
init|=
literal|".bak"
decl_stmt|,
name|dotedt
index|[]
init|=
literal|".edt"
decl_stmt|,
comment|/* "file saved" file */
name|dothup
index|[]
init|=
literal|".hup"
decl_stmt|,
name|dotint
index|[]
init|=
literal|".int"
decl_stmt|,
name|dottrm
index|[]
init|=
literal|".trm"
decl_stmt|,
modifier|*
name|dots
index|[]
init|=
block|{
name|dothup
block|,
name|dottrm
block|,
name|dotedt
block|,
name|dotint
block|,
literal|0
block|}
decl_stmt|,
name|expbuf
index|[
name|ESIZE
operator|+
literal|4
index|]
decl_stmt|,
comment|/* expression buffer */
name|file
index|[
name|FNSIZE
index|]
decl_stmt|,
comment|/* filename buffer */
ifndef|#
directive|ifndef
name|ALLOC
name|genbuf
index|[
name|LBSIZE
index|]
decl_stmt|,
comment|/* generated line buffer */
else|#
directive|else
modifier|*
name|genbuf
decl_stmt|,
comment|/* generated line buffer pointer */
endif|#
directive|endif
name|ibuff
index|[
name|BLKSIZE
index|]
decl_stmt|,
comment|/* input tmpfile buffer */
name|line
index|[
name|TTSIZE
operator|+
literal|4
index|]
decl_stmt|,
comment|/* terminal output buffer */
ifndef|#
directive|ifndef
name|ALLOC
name|linebuf
index|[
name|LBSIZE
index|]
decl_stmt|,
comment|/* line buffer for getline()/putline() */
else|#
directive|else
modifier|*
name|linebuf
decl_stmt|,
comment|/* line buffer for getline()/putline() */
endif|#
directive|endif
name|no
index|[]
init|=
literal|"no "
decl_stmt|,
name|null
index|[]
init|=
literal|""
decl_stmt|,
comment|/* "" */
name|obuff
index|[
name|BLKSIZE
index|]
decl_stmt|,
comment|/* output tmpfile buffer */
name|off
index|[]
init|=
literal|"off"
decl_stmt|,
name|on
index|[]
init|=
literal|"on"
decl_stmt|,
name|prcntu
index|[]
init|=
literal|"%u\n"
decl_stmt|,
comment|/* %u */
name|quote_s
index|[]
init|=
literal|"s"
decl_stmt|,
comment|/* "s" */
name|rhsbuf
index|[
name|LBSIZE
operator|/
literal|2
index|]
decl_stmt|,
comment|/* right-hand-side expression buffer */
name|savedfile
index|[
name|FNSIZE
index|]
decl_stmt|,
comment|/* saved filename */
name|tempfile
index|[
name|FNSIZE
index|]
decl_stmt|,
comment|/* scratch area for filename */
modifier|*
name|editor
decl_stmt|,
comment|/* argv[0] */
modifier|*
name|e_prompt
init|=
name|PROMPT
decl_stmt|,
comment|/* editor command prompt */
modifier|*
name|fmtlno
init|=
literal|"%7u="
decl_stmt|,
comment|/* format for line-number output */
modifier|*
name|globp
decl_stmt|,
comment|/* global command pointer */
modifier|*
name|linp
init|=
name|line
decl_stmt|,
comment|/* line pointer */
modifier|*
name|linebp
decl_stmt|,
modifier|*
name|loc1
decl_stmt|,
comment|/* start pointer of& string */
modifier|*
name|loc2
decl_stmt|,
comment|/* end pointer of& string */
modifier|*
name|locs
decl_stmt|,
modifier|*
name|nextip
decl_stmt|,
modifier|*
name|overfile
decl_stmt|,
comment|/* filename mode was changed on */
modifier|*
name|tfname
init|=
literal|"/tmp/e00000"
decl_stmt|,
comment|/* "buffer" name */
modifier|*
name|ver
init|=
name|TTL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ID message */
end_comment

begin_decl_stmt
name|charac
name|lastc
init|=
literal|0
decl_stmt|,
comment|/* peekc set to lastc on interrupt */
name|peekc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* one character pushback */
end_comment

begin_decl_stmt
name|int
name|brcount
init|=
literal|1
decl_stmt|,
comment|/* number of lines to output on "newline" */
name|col
init|=
literal|0
decl_stmt|,
comment|/* column counter for calculating line wraps */
name|line_num
decl_stmt|,
comment|/* integer for line number on output */
name|modcount
init|=
name|MODCNT
decl_stmt|,
comment|/* number of mods before auto-write */
name|overmode
decl_stmt|,
comment|/* mode of overridden file */
name|mods
init|=
literal|0
decl_stmt|,
comment|/* number of mods */
name|nbra
init|=
literal|0
decl_stmt|,
comment|/* count of currently defined \( \) pairs */
name|ninbuf
decl_stmt|,
comment|/* bytes in tmpfile input buffer */
name|nleft
decl_stmt|,
comment|/* bytes remaining in tmpfile output buffer */
name|num_reads
init|=
literal|0
decl_stmt|,
comment|/* indicator to aid text_modified-- */
comment|/* first read isn't really a modify */
name|pcount
init|=
name|PAGSIZ
operator|-
literal|1
decl_stmt|,
comment|/* number of lines to display on ":" command */
name|s_cnt
init|=
literal|0
decl_stmt|,
comment|/* counter for "s/str1/str2/nn" */
name|s_tmp
init|=
literal|0
decl_stmt|,
comment|/* scratch var for same */
name|savf
decl_stmt|,
comment|/* counter for auto-write stuff */
name|text_modified
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag--on if text was modified */
end_comment

begin_decl_stmt
name|filedes
name|fout
init|=
literal|1
decl_stmt|,
comment|/* putchar() writes on this fildes */
name|io
init|=
literal|0
decl_stmt|,
comment|/* file descriptor for "r", "w", "e" */
name|tfile
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file des for "buffer" */
end_comment

begin_decl_stmt
name|flag
name|aflg
init|=
literal|0
decl_stmt|,
comment|/* "apl mode" flag */
name|appflg
init|=
literal|0
decl_stmt|,
comment|/* append flag (if "w>file") */
name|badf
init|=
literal|0
decl_stmt|,
comment|/* bad read on temp file */
name|bflg
init|=
literal|0
decl_stmt|,
comment|/* "back-up" flag -- Generate back-up file */
name|bflg2
init|=
literal|0
decl_stmt|,
comment|/* Secondary "back-up" flag */
name|circfl
decl_stmt|,
comment|/* reg expr started with ^ */
name|curt
init|=
literal|0
decl_stmt|,
comment|/* short error messages -- ie: '?' */
name|deltflg
init|=
literal|0
decl_stmt|,
comment|/* don't delete .edt file upon exit */
name|eflg
init|=
literal|0
decl_stmt|,
comment|/* echo input flag */
name|eof
init|=
literal|0
decl_stmt|,
comment|/* eof was last char typed */
name|fflg
init|=
literal|0
decl_stmt|,
comment|/* "create" flag */
name|globf2
init|=
literal|0
decl_stmt|,
comment|/* kludge for -f */
ifdef|#
directive|ifdef
name|HUGE
name|hugef
init|=
literal|0
decl_stmt|,
comment|/* -h is process huge file */
name|hugef2
init|=
literal|0
decl_stmt|,
comment|/* getblock() conversion to huge */
endif|#
directive|endif
name|hupflag
init|=
literal|0
decl_stmt|,
comment|/* hangup signal has been caught */
name|ichanged
decl_stmt|,
comment|/* ibuf has been changed */
name|iflg
init|=
literal|0
decl_stmt|,
comment|/* file.int and exit on interrupt */
name|immflg
init|=
literal|0
decl_stmt|,
comment|/* immediate flag -- q and e */
name|io_w
init|=
literal|0
decl_stmt|,
comment|/* writing in progress */
name|listf
init|=
literal|0
decl_stmt|,
comment|/* list control chars explicitly */
name|noshell
init|=
literal|0
decl_stmt|,
comment|/* true if no ! command allowed */
name|over
init|=
literal|0
decl_stmt|,
comment|/* override permissions on write if possible */
name|pflag
decl_stmt|,
comment|/* print line after doing command */
name|pipef
init|=
literal|0
decl_stmt|,
comment|/* for talking to pipes */
name|prompt1
init|=
literal|1
decl_stmt|,
comment|/* flag--enable or disable line-num prompts */
name|prompt2
init|=
literal|1
decl_stmt|,
comment|/* flag--enable or disable ALL prompting */
name|reading
init|=
literal|0
decl_stmt|,
comment|/* waiting on tty read */
name|seekf
init|=
literal|0
decl_stmt|,
comment|/* no seek to EOF on error on fd 0 */
name|termflg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if termination signal (15) occurred */
end_comment

begin_decl_stmt
name|linep
modifier|*
name|addr1
decl_stmt|,
comment|/* lower line bound */
modifier|*
name|addr2
decl_stmt|,
comment|/* upper line bound */
modifier|*
name|dol
decl_stmt|,
comment|/* last line in file */
modifier|*
name|dot
decl_stmt|,
comment|/* "current" line */
modifier|*
name|dotdot
decl_stmt|,
comment|/* last different "dot" */
modifier|*
name|endcore
decl_stmt|,
comment|/* current end of memory */
modifier|*
name|fendcore
decl_stmt|,
comment|/* start of dynamic area */
modifier|*
name|lastdot
decl_stmt|,
comment|/* last "dot" */
name|names
index|[
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
index|]
decl_stmt|,
comment|/* "k" command markers */
ifdef|#
directive|ifdef
name|EXTMARK
name|names2
index|[
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
index|]
decl_stmt|,
comment|/* "k" command markers */
endif|#
directive|endif
modifier|*
name|old_a1
decl_stmt|,
comment|/* previous address bounds */
modifier|*
name|old_a2
decl_stmt|,
name|tline
decl_stmt|,
comment|/* pointer to next available pos in tmpfile */
modifier|*
name|zero
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* anchor line for all other lines */
end_comment

begin_comment
comment|/*  * magic constants used in many places  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|pdp11
end_ifdef

begin_define
define|#
directive|define
name|_1a
value|~0377
end_define

begin_define
define|#
directive|define
name|_2a
value|0400
end_define

begin_define
define|#
directive|define
name|_3a
value|0377
end_define

begin_define
define|#
directive|define
name|_4a
value|0774
end_define

begin_define
define|#
directive|define
name|_5a
value|255
end_define

begin_define
define|#
directive|define
name|_6a
value|077776
end_define

begin_define
define|#
directive|define
name|_1b
value|~0177
end_define

begin_define
define|#
directive|define
name|_2b
value|0200
end_define

begin_define
define|#
directive|define
name|_3b
value|0777
end_define

begin_define
define|#
directive|define
name|_4b
value|0774
end_define

begin_define
define|#
directive|define
name|_5b
value|511
end_define

begin_define
define|#
directive|define
name|_6b
value|077777
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_define
define|#
directive|define
name|_1a
value|~0377
end_define

begin_define
define|#
directive|define
name|_2a
value|0400
end_define

begin_define
define|#
directive|define
name|_3a
value|077777777
end_define

begin_define
define|#
directive|define
name|_4a
value|0774
end_define

begin_define
define|#
directive|define
name|_5a
value|65535
end_define

begin_define
define|#
directive|define
name|_6a
value|077777776
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HUGE
end_ifdef

begin_decl_stmt
name|int
name|_1
index|[]
init|=
block|{
name|_1a
block|,
name|_1b
block|}
decl_stmt|,
comment|/* tl&= _1; getline() */
name|_2
index|[]
init|=
block|{
name|_2a
block|,
name|_2b
block|}
decl_stmt|,
comment|/* tl += _2; getline()... */
name|_3
index|[]
init|=
block|{
name|_3a
block|,
name|_3b
block|}
decl_stmt|,
comment|/* bno = ...& _3; getblock() */
name|_4
index|[]
init|=
block|{
name|_4a
block|,
name|_4b
block|}
decl_stmt|,
comment|/* off = ...& _4; getblock() */
name|_5
index|[]
init|=
block|{
name|_5a
block|,
name|_5b
block|}
decl_stmt|,
comment|/* if (bno>= _5)... getblock() */
name|_6
index|[]
init|=
block|{
name|_6a
block|,
name|_6b
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tline += ...& _6; */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_1
value|_1a
end_define

begin_define
define|#
directive|define
name|_2
value|_2a
end_define

begin_define
define|#
directive|define
name|_3
value|_3a
end_define

begin_define
define|#
directive|define
name|_4
value|_4a
end_define

begin_define
define|#
directive|define
name|_5
value|_5a
end_define

begin_define
define|#
directive|define
name|_6
value|_6a
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * error messages  *  *	(there are more than these)  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|errtext
index|[]
init|=
block|{
comment|/*  0 */
literal|"syntax is k[a-z]"
block|,
comment|/*  1 */
literal|"illegal command format"
block|,
comment|/*  2 */
literal|"no command"
block|,
comment|/*  3 */
literal|"no tab character"
block|,
comment|/*  4 */
literal|"can't change filename"
block|,
comment|/*  5 */
literal|"file name syntax"
block|,
comment|/*  6 */
literal|"recursive \"@\" command"
block|,
comment|/*  7 */
literal|"null file name illegal"
block|,
comment|/*  8 */
literal|"unrecognized command"
block|,
comment|/*  9 */
literal|"no tabs set"
block|,
comment|/* 10 */
literal|"global command not allowed with huge file"
block|,
comment|/* 11 */
literal|"file name too long"
block|,
comment|/* 12 */
literal|"expanded line too long"
block|,
comment|/* 13 */
literal|"no such line"
block|,
comment|/* 14 */
literal|"can't fork"
block|,
comment|/* 15 */
literal|"can't write to process"
block|,
comment|/* 16 */
literal|"no lines"
block|,
comment|/* 17 */
literal|"backup(FILE) error (?)"
block|,
comment|/* 18 */
literal|"string not found"
block|,
comment|/* 19 */
literal|"  '  must be followed by [a-z]"
block|,
comment|/* 20 */
literal|"address syntax error"
block|,
comment|/* 21 */
literal|"lower address bound> upper one"
block|,
comment|/* 22 */
literal|"address illegal here"
block|,
comment|/* 23 */
literal|"non-existent line number"
block|,
comment|/* 24 */
literal|"bottom of file reached"
block|,
comment|/* 25 */
literal|"command syntax error"
block|,
comment|/* 26 */
literal|"\"advance\" error (?)"
block|,
comment|/* 27 */
literal|"null string illegal"
block|,
comment|/* 28 */
literal|"destination not found"
block|,
comment|/* 29 */
literal|"INTERRUPT!"
block|,
comment|/* 30 */
literal|"line too long"
block|,
comment|/* 31 */
literal|"missing destination address"
block|,
comment|/* 32 */
literal|"I/O error--file not saved!"
block|,
comment|/* 33 */
literal|"file overflows available memory"
block|,
comment|/* 34 */
literal|"file too large (TMPERR)"
block|,
comment|/* 35 */
literal|"I/O error on temp file (TMPERR)"
block|,
comment|/* 36 */
literal|"open error on temp file (TMPERR)"
block|,
comment|/* 37 */
literal|"recursive global command"
block|,
comment|/* 38 */
literal|"global command list too long"
block|,
comment|/* 39 */
literal|"substitute pattern not found"
block|,
comment|/* 40 */
literal|"missing substring"
block|,
comment|/* 41 */
literal|"string2 too long"
block|,
comment|/* 42 */
literal|"substring too long"
block|,
comment|/* 43 */
literal|"substituted string too long"
block|,
comment|/* 44 */
literal|"too many  \\("
block|,
comment|/* 45 */
literal|"unbalanced  \\(  \\)"
block|,
comment|/* 46 */
literal|"\\n  illegal"
block|,
comment|/* 47 */
literal|"unimplemented feature"
block|,
comment|/* 48 */
literal|"[nothing written]"
block|,
comment|/* 49 */
literal|"pattern too complicated"
block|,
comment|/* 50 */
literal|"can't create temp file (TMPERR)"
block|,
comment|/* 51 */
literal|"bad directory"
block|,
comment|/* 52 */
literal|"no ! allowed"
block|,
comment|/* 53 */
literal|"can't read "
block|,
comment|/* 54 */
literal|"can't create "
block|,
comment|/* 55 */
literal|"%u line%s\n"
block|,
comment|/* 56 */
literal|"[file saved]"
block|,
comment|/* 57 */
literal|"\nHangup!\n"
block|,
comment|/* 58 */
literal|"\nTerminated...\n"
block|,
comment|/* 59 */
literal|"EOF illegal here"
block|,
comment|/* 60 */
literal|"can't join to line 0"
block|,
comment|/* 61 */
literal|"! not allowed with global command"
block|,
comment|/* 62 */
literal|"no filename specified"
block|,
comment|/* 63 */
literal|"not enough  \\( \\)  pairs"
block|,
comment|/* 64 */
literal|"can't create pipe file (PIPERR)"
block|,
comment|/* 65 */
literal|"open error on pipe file (PIPERR)"
block|,
comment|/* 66 */
literal|"can't checkpoint"
block|,
comment|/* 67 */
literal|"can't recover"
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NERR
value|(sizeof errtext / sizeof errtext[0])
end_define

begin_comment
comment|/*  * ! error strings  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|status
index|[]
init|=
block|{
comment|/*  0 */
literal|0
block|,
comment|/*  1 */
literal|"hangup"
block|,
comment|/*  2 */
literal|"interrupt"
block|,
comment|/*  3 */
literal|"quit"
block|,
comment|/*  4 */
literal|"illegal instruction"
block|,
comment|/*  5 */
literal|"bpt"
block|,
comment|/*  6 */
literal|"iot"
block|,
comment|/*  7 */
literal|"emt"
block|,
comment|/*  8 */
literal|"fpp"
block|,
comment|/*  9 */
literal|"killed"
block|,
comment|/* 10 */
literal|"bus error"
block|,
comment|/* 11 */
literal|"memory fault"
block|,
comment|/* 12 */
literal|"bad sys call"
block|,
comment|/* 13 */
literal|"broken pipe"
block|,
comment|/* 14 */
literal|"alarm"
block|,
comment|/* 15 */
literal|"terminated"
block|,
ifdef|#
directive|ifdef
name|pdp11
comment|/* 16 */
literal|"time limit"
block|,
else|#
directive|else
comment|/* 16 */
literal|0
block|,
comment|/* 17 */
literal|"stopped"
block|,
comment|/* 18 */
literal|"terminal stop"
block|,
comment|/* 19 */
literal|"continue"
block|,
comment|/* 20 */
literal|"child status changed"
block|,
comment|/* 21 */
literal|"terminal input"
block|,
comment|/* 22 */
literal|"terminal output"
block|,
comment|/* 23 */
literal|"terminal input ready"
block|,
comment|/* 24 */
literal|"cpu timelimit exceeded"
block|,
comment|/* 25 */
literal|"filesize limit exceeded"
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NSTR
value|(sizeof status / sizeof status[0])
end_define

begin_define
define|#
directive|define
name|putsn
parameter_list|(
name|x
parameter_list|)
value|(puts2((x)),putchar('\n'))
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)<(y)?(x):(y))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)>(y)?(x):(y))
end_define

begin_comment
comment|/*  * function declarations  */
end_comment

begin_function_decl
name|linep
modifier|*
name|findmark
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getblock
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|func
name|signal
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|CKPT
end_ifndef

begin_decl_stmt
name|int
name|badsig
argument_list|()
decl_stmt|,
else|#
directive|else
name|int
name|checkpoint
argument_list|()
decl_stmt|,
endif|#
directive|endif
name|hangup
argument_list|()
decl_stmt|,
name|mail
argument_list|()
decl_stmt|,
name|onintr
argument_list|()
decl_stmt|,
name|term
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * signals  */
end_comment

begin_struct
struct|struct
name|sigtab
block|{
name|int
name|s_sig
decl_stmt|,
name|s_func
decl_stmt|;
block|}
name|sigtab1
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|CKPT
name|SIGILL
block|,
name|checkpoint
block|,
name|SIGIOT
block|,
name|checkpoint
block|,
name|SIGEMT
block|,
name|checkpoint
block|,
name|SIGFPE
block|,
name|checkpoint
block|,
name|SIGBUS
block|,
name|checkpoint
block|,
name|SIGSEGV
block|,
name|checkpoint
block|,
name|SIGSYS
block|,
name|checkpoint
block|,
else|#
directive|else
name|SIGILL
block|,
name|badsig
block|,
name|SIGIOT
block|,
name|badsig
block|,
name|SIGEMT
block|,
name|badsig
block|,
name|SIGFPE
block|,
name|badsig
block|,
name|SIGBUS
block|,
name|badsig
block|,
name|SIGSEGV
block|,
name|badsig
block|,
name|SIGSYS
block|,
name|badsig
block|,
endif|#
directive|endif
literal|0
block|,
literal|0
block|, }
struct|,
name|sigtab2
index|[]
init|=
block|{
name|SIGTRC
block|,
name|mail
block|,
name|SIGHUP
block|,
name|hangup
block|,
name|SIGTRM
block|,
name|term
block|,
name|SIGINT
block|,
name|onintr
block|,
literal|0
block|,
literal|0
block|, }
struct|;
end_struct

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|CKPT
extern|extern checkpoint(
block|)
function|;
end_function

begin_else
else|#
directive|else
end_else

begin_extern
extern|extern badsig(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_extern
extern|extern onintr(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|hangup
argument_list|()
operator|,
name|mail
argument_list|()
operator|,
name|term
argument_list|()
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|EXPDMP
end_ifdef

begin_extern
extern|extern expdmp(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|register
name|n
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|func
name|savint
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|signal
argument_list|(
name|SIGQIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|savint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ep
operator|=
operator|*
name|argv
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|XED
end_ifdef

begin_expr_stmt
name|p1
operator|=
name|ep
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|p2
operator|=
name|p1
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|*
name|p1
condition|)
if|if
condition|(
operator|*
name|p1
operator|++
operator|==
literal|'/'
operator|&&
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|!=
literal|'/'
condition|)
name|p2
operator|=
name|p1
expr_stmt|;
end_while

begin_expr_stmt
name|p1
operator|=
name|p2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|argv
operator|=
name|p2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|n
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|*
name|p1
condition|)
if|if
condition|(
operator|*
name|p1
operator|++
operator|==
literal|'x'
condition|)
block|{
comment|/* xed .vs. eed */
operator|++
name|n
expr_stmt|;
break|break;
block|}
end_while

begin_if
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|e_prompt
operator|=
name|EEDPROMPT
expr_stmt|;
name|ver
operator|=
name|EEDTTL
expr_stmt|;
name|help
operator|=
name|EEDHELP
expr_stmt|;
name|dumbf
operator|=
literal|1
expr_stmt|;
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_expr_stmt
name|logstats
operator|.
name|l_xed
operator|=
name|n
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|prompt2
operator|=
name|istty
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|V7
end_ifdef

begin_if
if|if
condition|(
name|getenv
argument_list|(
literal|"_OVERWRITE_"
argument_list|)
condition|)
operator|++
name|over
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_while
while|while
condition|(
operator|--
name|argc
condition|)
if|if
condition|(
operator|*
operator|*
operator|++
name|argv
operator|==
literal|'-'
condition|)
block|{
while|while
condition|(
operator|*
operator|++
operator|*
name|argv
condition|)
block|{
switch|switch
condition|(
operator|*
operator|*
name|argv
condition|)
block|{
case|case
literal|'!'
case|:
comment|/* no ! allowed */
name|noshell
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|APLMAP
case|case
literal|'A'
case|:
comment|/* apl char mapping */
name|aplmap
operator|=
literal|1
expr_stmt|;
name|errtext
index|[
literal|29
index|]
operator|=
literal|"G interrupt G"
expr_stmt|;
name|p1
operator|=
name|ver
expr_stmt|;
while|while
condition|(
operator|*
name|p1
condition|)
block|{
if|if
condition|(
literal|'A'
operator|<=
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|<=
literal|'Z'
condition|)
operator|*
name|p1
operator||=
literal|040
expr_stmt|;
operator|++
name|p1
expr_stmt|;
block|}
endif|#
directive|endif
case|case
literal|'a'
case|:
comment|/* apl mode */
name|aflg
operator|=
literal|1
expr_stmt|;
name|fmtlno
operator|=
literal|"[ %u ]\t"
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMB
name|dumbf
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XED
ifdef|#
directive|ifdef
name|TTL_NL
name|ver
index|[
name|TTL_NL
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
break|break;
case|case
literal|'b'
case|:
comment|/* file.bak on entry */
name|bflg
operator|=
literal|1
expr_stmt|;
name|bflg2
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|PAGE
case|case
literal|'c'
case|:
comment|/* crt depth in lines */
operator|++
operator|*
name|argv
expr_stmt|;
name|n
operator|=
name|argnum
argument_list|(
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
name|pcount
operator|=
name|n
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'d'
case|:
comment|/* don't delete .edt file */
name|deltflg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* echo input commands */
name|eflg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* create mode */
name|fflg
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HUGE
case|case
literal|'h'
case|:
comment|/* edit "huge" file */
name|hugef
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'i'
case|:
comment|/* file.int on interrupt */
name|iflg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* kill verbose messages */
name|curt
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|EOL
case|case
literal|'l'
case|:
comment|/* set eol char to "x" */
if|if
condition|(
operator|*
operator|++
operator|*
name|argv
condition|)
name|eol
operator|=
operator|*
operator|*
name|argv
expr_stmt|;
else|else
operator|--
operator|*
name|argv
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'m'
case|:
comment|/* mod cnt for autosave */
operator|++
operator|*
name|argv
expr_stmt|;
name|n
operator|=
name|argnum
argument_list|(
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
name|modcount
operator|=
name|n
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* no line num */
name|prompt1
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* no seek to EOF on error */
name|seekf
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* force prompts for pipe */
name|pipef
operator|=
literal|1
expr_stmt|;
name|prompt2
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* don't inhibit quits */
name|signal
argument_list|(
name|SIGQIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DUMB
case|case
literal|'r'
case|:
comment|/* spcl char meaning */
name|dumbf
operator|^=
literal|01
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'s'
case|:
comment|/* silent mode */
name|prompt2
operator|=
literal|0
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|TABS
case|case
literal|'t'
case|:
comment|/* tab char */
if|if
condition|(
operator|*
operator|++
operator|*
name|argv
condition|)
name|tabc
operator|=
operator|*
operator|*
name|argv
expr_stmt|;
else|else
operator|--
operator|*
name|argv
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TABS
case|case
literal|'v'
case|:
comment|/* tab fill char */
if|if
condition|(
operator|*
operator|++
operator|*
name|argv
condition|)
name|tabfill
operator|=
operator|*
operator|*
name|argv
expr_stmt|;
else|else
operator|--
operator|*
name|argv
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PAGE
case|case
literal|'w'
case|:
comment|/* crt width */
operator|++
operator|*
name|argv
expr_stmt|;
name|n
operator|=
name|argnum
argument_list|(
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|n
operator|>=
literal|2
condition|)
name|ccount
operator|=
name|n
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|YINT
case|case
literal|'y'
case|:
comment|/* page on interrupt */
name|yflg
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE
case|case
literal|'@'
case|:
comment|/* set "@" filename */
name|p2
operator|=
name|altfile
expr_stmt|;
name|p1
operator|=
operator|++
operator|*
name|argv
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|&&
name|p2
operator|<
operator|&
name|altfile
index|[
name|FNSIZE
operator|-
literal|2
index|]
condition|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
condition|)
block|{
name|p2
operator|=
name|altfile
expr_stmt|;
name|putsn
argument_list|(
name|errtext
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
block|}
operator|*
name|p2
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|argv
operator|=
operator|&
name|p1
index|[
operator|-
literal|1
index|]
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ALLOC
case|case
literal|'B'
case|:
comment|/* line buffer size */
operator|++
operator|*
name|argv
expr_stmt|;
name|n
operator|=
name|argnum
argument_list|(
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|LBSIZE
condition|)
name|lbsize
operator|=
name|n
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'D'
case|:
comment|/* trace mode -- debug */
name|tflg
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|EXPDMP
case|case
literal|'Q'
case|:
comment|/* show pattern on quit */
name|signal
argument_list|(
name|SIGQIT
argument_list|,
name|expdmp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XED
case|case
literal|'I'
case|:
comment|/* suppress ID message */
name|ver
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* prompt */
name|p1
operator|=
operator|*
name|argv
expr_stmt|;
name|e_prompt
operator|=
operator|++
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|++
condition|)
empty_stmt|;
operator|*
name|argv
operator|=
operator|&
name|p1
index|[
operator|-
literal|2
index|]
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* line number prompt */
name|p1
operator|=
operator|*
name|argv
expr_stmt|;
name|fmtlno
operator|=
operator|++
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|++
condition|)
empty_stmt|;
operator|*
name|argv
operator|=
operator|&
name|p1
index|[
operator|-
literal|2
index|]
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* screen-clear */
name|p1
operator|=
operator|*
name|argv
expr_stmt|;
name|clears
operator|=
operator|++
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|++
condition|)
empty_stmt|;
operator|*
name|argv
operator|=
operator|&
name|p1
index|[
operator|-
literal|2
index|]
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|CKPT
case|case
literal|'R'
case|:
comment|/* recover */
operator|++
operator|*
name|argv
expr_stmt|;
if|if
condition|(
operator|(
name|recovry
operator|=
name|argnum
argument_list|(
name|argv
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|recovry
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'O'
case|:
comment|/* over-ride write perm */
name|over
operator|^=
literal|01
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* temp filename */
name|p1
operator|=
operator|*
name|argv
expr_stmt|;
name|tfname
operator|=
operator|++
name|p1
expr_stmt|;
ifdef|#
directive|ifdef
name|PIPE
while|while
condition|(
operator|*
name|p1
condition|)
if|if
condition|(
operator|*
name|p1
operator|++
operator|==
literal|':'
condition|)
block|{
name|p1
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pfname
operator|=
name|p1
expr_stmt|;
ifdef|#
directive|ifdef
name|CKPT
break|break;
endif|#
directive|endif
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CKPT
while|while
condition|(
operator|*
name|p1
condition|)
if|if
condition|(
operator|*
name|p1
operator|++
operator|==
literal|':'
condition|)
block|{
name|p1
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cfname
operator|=
name|p1
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|argv
operator|=
operator|&
name|p1
index|[
operator|-
literal|1
index|]
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* tabs stops/illegals */
if|if
condition|(
operator|!
operator|*
operator|*
name|argv
operator|||
operator|*
operator|*
name|argv
operator|==
literal|'-'
ifdef|#
directive|ifdef
name|TABS
operator|||
operator|*
operator|*
name|argv
operator|==
literal|','
endif|#
directive|endif
condition|)
break|break;
ifdef|#
directive|ifdef
name|TABS
if|if
condition|(
operator|*
operator|*
name|argv
operator|<
literal|'0'
operator|||
operator|*
operator|*
name|argv
operator|>
literal|'9'
condition|)
block|{
endif|#
directive|endif
name|printf
argument_list|(
literal|"bad flag: -%c\n"
argument_list|,
operator|*
operator|*
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TABS
block|}
name|n
operator|=
name|argnum
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|settab
argument_list|(
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
else|else
block|{
name|p1
operator|=
operator|*
name|argv
expr_stmt|;
name|p2
operator|=
name|savedfile
expr_stmt|;
while|while
condition|(
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
condition|)
if|if
condition|(
name|p2
operator|>=
operator|&
name|savedfile
index|[
name|FNSIZE
operator|-
literal|2
index|]
condition|)
block|{
name|putsn
argument_list|(
name|errtext
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|globf2
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fflg
condition|)
name|globp
operator|=
literal|"a\n"
expr_stmt|;
else|else
name|globp
operator|=
literal|"r\n"
expr_stmt|;
block|}
end_while

begin_ifdef
ifdef|#
directive|ifdef
name|YINT
end_ifdef

begin_if
if|if
condition|(
name|iflg
condition|)
name|yflg
operator|=
literal|0
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ALLOC
end_ifdef

begin_expr_stmt
name|linebuf
operator|=
name|sbrk
argument_list|(
name|lbsize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|genbuf
operator|=
name|sbrk
argument_list|(
name|lbsize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|fendcore
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CKPT
end_ifdef

begin_if
if|if
condition|(
operator|(
name|n
operator|=
name|recovry
operator|)
operator|==
literal|0
condition|)
endif|#
directive|endif
name|n
operator|=
name|getpid
argument_list|()
expr_stmt|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|PIPE
end_ifdef

begin_expr_stmt
name|tmpname
argument_list|(
name|pfname
argument_list|,
name|n
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CKPT
end_ifdef

begin_expr_stmt
name|tmpname
argument_list|(
name|cfname
argument_list|,
name|n
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|tmpname
argument_list|(
name|tfname
argument_list|,
name|n
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* MUST be last call to tmpname */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_expr_stmt
name|logstats
operator|.
name|l_uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|time
argument_list|(
operator|&
name|logstats
operator|.
name|lt_start
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|prompt2
condition|)
operator|++
name|logstats
operator|.
name|l_inter
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|aflg
condition|)
name|logstats
operator|.
name|l_xed
operator|=
literal|2
expr_stmt|;
end_if

begin_comment
comment|/* magic num for apled */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CKPT
end_ifdef

begin_if
if|if
condition|(
name|recovry
condition|)
name|recover
argument_list|()
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|editor
operator|=
name|ep
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|prompt2
condition|)
block|{
ifdef|#
directive|ifdef
name|CMDS
if|if
condition|(
operator|(
name|cmd
operator|=
name|open
argument_list|(
name|cmdfil
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|lseek
argument_list|(
name|cmd
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|cmd
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ver
condition|)
name|putsn
argument_list|(
name|ver
argument_list|)
expr_stmt|;
comment|/* XED V0.00 ... */
name|flush_buf
argument_list|()
expr_stmt|;
block|}
else|else
name|modcount
operator|=
literal|0
expr_stmt|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|CMDS
end_ifdef

begin_if
if|if
condition|(
name|cmd
operator|&&
operator|*
name|savedfile
condition|)
block|{
name|write
argument_list|(
name|cmd
argument_list|,
literal|"e,"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|p1
operator|=
name|savedfile
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|++
condition|)
empty_stmt|;
name|write
argument_list|(
name|cmd
argument_list|,
name|savedfile
argument_list|,
operator|--
name|p1
operator|-
name|savedfile
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|cmd
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|signals
argument_list|(
name|sigtab1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setexit
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|savint
operator|&
literal|01
operator|)
operator|==
literal|0
condition|)
name|signals
argument_list|(
name|sigtab2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|YINT
else|else
name|yflg
operator|=
literal|0
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CKPT
end_ifdef

begin_if
if|if
condition|(
operator|!
name|recovry
condition|)
endif|#
directive|endif
name|init
argument_list|()
expr_stmt|;
end_if

begin_expr_stmt
name|setexit
argument_list|()
expr_stmt|;
end_expr_stmt

begin_label
name|cant
label|:
end_label

begin_do
do|do
block|{
name|commands
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|are_you_sure
argument_list|()
condition|)
do|;
end_do

begin_if
if|if
condition|(
name|immflg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fflg
condition|)
if|if
condition|(
name|backup
argument_list|(
name|FILE
argument_list|)
condition|)
name|text_modified
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|cant
goto|;
if|if
condition|(
name|text_modified
operator|==
literal|0
condition|)
name|backup
argument_list|(
operator|-
name|TMP
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|modcount
operator|&&
name|eof
condition|)
if|if
condition|(
name|backup
argument_list|(
name|TMP
argument_list|)
operator|&&
name|prompt2
condition|)
if|if
condition|(
operator|!
name|curt
condition|)
name|putsn
argument_list|(
name|errtext
index|[
literal|56
index|]
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|delexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  abort
operator|(
operator|)
block|{
specifier|register
name|char
operator|*
name|p
block|;
specifier|register
name|charac
name|c
block|;
name|setnoaddr
argument_list|()
block|;
name|peekc
operator|=
literal|0
block|;
name|p
operator|=
literal|"ort\n"
block|;
while|while
condition|(
operator|*
name|p
condition|)
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
operator|*
name|p
operator|++
condition|)
block|{
name|peekc
operator|=
name|c
expr_stmt|;
name|errmsg
argument_list|(
literal|25
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_abort
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|delexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  linep
operator|*
name|address
argument_list|()
block|{
specifier|register
name|minus
block|;
specifier|register
name|charac
name|c
block|;
specifier|register
name|linep
operator|*
name|a1
block|,
operator|*
name|start
block|;
specifier|register
name|n
block|,
name|relerr
block|;
name|minus
operator|=
literal|0
block|;
name|a1
operator|=
literal|0
block|;
for|for ever
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|peekc
operator|=
name|c
expr_stmt|;
name|n
operator|=
name|getnum
argument_list|()
expr_stmt|;
if|if
condition|(
name|a1
operator|==
literal|0
condition|)
block|{
name|a1
operator|=
name|zero
expr_stmt|;
name|n
operator|+=
name|aflg
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
operator|!
name|globp
condition|)
operator|++
name|logstats
operator|.
name|la_num
expr_stmt|;
endif|#
directive|endif
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|minus
operator|<
literal|0
condition|)
name|n
operator|=
operator|-
name|n
expr_stmt|;
end_if

begin_expr_stmt
name|a1
operator|+=
name|n
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|minus
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_continue
continue|continue;
end_continue

begin_expr_stmt
unit|} 		relerr
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|a1
operator|||
name|minus
condition|)
name|relerr
operator|++
expr_stmt|;
end_if

begin_switch
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
continue|continue;
case|case
literal|'+'
case|:
name|minus
operator|+=
name|brcount
expr_stmt|;
if|if
condition|(
name|a1
operator|==
literal|0
condition|)
name|a1
operator|=
name|dot
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
operator|!
name|globp
condition|)
operator|++
name|logstats
operator|.
name|la_plus
expr_stmt|;
endif|#
directive|endif
continue|continue;
case|case
literal|'-'
case|:
case|case
literal|'^'
case|:
comment|/* for upwards compatibility */
name|minus
operator|-=
name|brcount
expr_stmt|;
if|if
condition|(
name|a1
operator|==
literal|0
condition|)
name|a1
operator|=
name|dot
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
operator|!
name|globp
condition|)
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
operator|++
name|logstats
operator|.
name|la_caret
expr_stmt|;
else|else
operator|++
name|logstats
operator|.
name|la_minus
expr_stmt|;
endif|#
directive|endif
continue|continue;
comment|/* search:	*/
case|case
literal|'?'
case|:
name|minus
operator|++
expr_stmt|;
case|case
literal|'/'
case|:
name|compile
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|a1
operator|==
literal|0
condition|)
name|a1
operator|=
name|dot
expr_stmt|;
if|if
condition|(
name|a1
operator|<
name|zero
condition|)
name|a1
operator|=
name|zero
expr_stmt|;
if|if
condition|(
name|a1
operator|>
name|dol
condition|)
name|a1
operator|=
name|dol
expr_stmt|;
name|start
operator|=
name|a1
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
operator|!
name|globp
condition|)
if|if
condition|(
name|minus
condition|)
operator|++
name|logstats
operator|.
name|la_query
expr_stmt|;
else|else
operator|++
name|logstats
operator|.
name|la_slash
expr_stmt|;
endif|#
directive|endif
for|for ever
block|{
if|if
condition|(
name|minus
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|a1
operator|>
name|dol
condition|)
name|a1
operator|=
name|zero
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|--
name|a1
operator|<
name|zero
condition|)
name|a1
operator|=
name|dol
expr_stmt|;
block|}
if|if
condition|(
name|execute
argument_list|(
literal|0
argument_list|,
name|a1
argument_list|)
condition|)
block|{
name|minus
operator|=
literal|0
expr_stmt|;
name|relerr
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|a1
operator|==
name|start
condition|)
name|errmsg
argument_list|(
literal|18
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'$'
case|:
name|a1
operator|=
name|dol
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
operator|!
name|globp
condition|)
operator|++
name|logstats
operator|.
name|la_dol
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'.'
case|:
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'.'
condition|)
block|{
name|peekc
operator|=
literal|0
expr_stmt|;
name|a1
operator|=
name|dotdot
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
operator|!
name|globp
condition|)
operator|++
name|logstats
operator|.
name|la_dotdot
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|a1
operator|=
name|dot
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
operator|!
name|globp
condition|)
operator|++
name|logstats
operator|.
name|la_dot
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
literal|'\''
case|:
if|if
condition|(
operator|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator||
literal|040
operator|)
operator|<
literal|'a'
operator|||
operator|(
name|c
operator||
literal|040
operator|)
operator|>
literal|'z'
condition|)
block|{
name|peekc
operator|=
name|c
expr_stmt|;
name|errmsg
argument_list|(
literal|19
argument_list|)
expr_stmt|;
block|}
name|c
operator||=
literal|040
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
operator|!
name|globp
condition|)
operator|++
name|logstats
operator|.
name|la_quote
expr_stmt|;
endif|#
directive|endif
name|casemark
label|:
ifdef|#
directive|ifdef
name|EXTMARK
name|n
operator|=
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'^'
condition|)
block|{
name|n
operator|=
literal|1
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peekc
operator|==
literal|'$'
condition|)
block|{
name|n
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|names2
index|[
name|c
operator|-
literal|'a'
index|]
operator|==
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|&
literal|01
condition|)
if|if
condition|(
operator|(
name|a1
operator|=
name|findmark
argument_list|(
name|names
index|[
name|c
operator|-
literal|'a'
index|]
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|a1
operator|=
name|dol
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|1
operator|&&
name|names2
index|[
name|c
operator|-
literal|'a'
index|]
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|addr1
operator|||
name|addr2
condition|)
name|errmsg
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|addr1
operator|=
name|a1
expr_stmt|;
block|}
name|a1
operator|=
name|findmark
argument_list|(
name|names2
index|[
name|c
operator|-
literal|'a'
index|]
argument_list|,
name|dol
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|2
condition|)
break|break;
name|addr2
operator|=
name|a1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
name|a1
operator|=
name|findmark
argument_list|(
name|names
index|[
name|c
operator|-
literal|'a'
index|]
argument_list|,
name|dol
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'='
case|:
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
operator|!
name|globp
condition|)
operator|++
name|logstats
operator|.
name|la_equal
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'^'
condition|)
name|a1
operator|=
name|old_a1
expr_stmt|;
elseif|else
if|if
condition|(
name|peekc
operator|==
literal|'$'
condition|)
name|a1
operator|=
name|old_a2
expr_stmt|;
else|else
block|{
if|if
condition|(
name|addr1
operator|||
name|addr2
operator|||
name|a1
condition|)
name|errmsg
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|addr1
operator|=
name|old_a1
expr_stmt|;
name|addr2
operator|=
name|old_a2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|peekc
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
literal|'A'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
block|{
name|c
operator||=
literal|040
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
operator|!
name|globp
condition|)
operator|++
name|logstats
operator|.
name|la_letter
expr_stmt|;
endif|#
directive|endif
goto|goto
name|casemark
goto|;
block|}
name|peekc
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|a1
operator|==
literal|0
condition|)
if|if
condition|(
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|';'
condition|)
if|if
condition|(
name|dot
operator|+
literal|1
operator|>
name|dol
condition|)
return|return
operator|(
name|dol
operator|)
return|;
else|else
return|return
operator|(
name|dot
operator|+
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
name|a1
operator|+=
name|minus
expr_stmt|;
if|if
condition|(
name|a1
operator|<
name|zero
condition|)
name|a1
operator|=
name|zero
operator|+
operator|(
name|zero
operator|!=
name|dol
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|a1
operator|>
name|dol
condition|)
name|a1
operator|=
name|dol
expr_stmt|;
return|return
operator|(
name|a1
operator|)
return|;
block|}
end_switch

begin_if
if|if
condition|(
name|relerr
condition|)
name|errmsg
argument_list|(
literal|20
argument_list|)
expr_stmt|;
end_if

begin_macro
unit|} }
name|advance
argument_list|(
argument|alp
argument_list|,
argument|aep
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|lp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|curlp
decl_stmt|;
specifier|register
name|s_sav
operator|,
name|i
expr_stmt|;
name|lp
operator|=
name|alp
expr_stmt|;
name|ep
operator|=
name|aep
expr_stmt|;
for|for ever switch
control|(
operator|*
name|ep
operator|++
control|)
block|{
case|case
name|CCHR
case|:
if|if
condition|(
operator|*
name|ep
operator|++
operator|==
operator|*
name|lp
operator|++
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CDOT
case|:
if|if
condition|(
operator|*
name|lp
operator|++
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CDOL
case|:
if|if
condition|(
operator|*
name|lp
operator|==
literal|0
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CEOF
case|:
name|loc2
operator|=
name|lp
expr_stmt|;
if|if
condition|(
operator|--
name|s_tmp
operator|>
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|CCL
case|:
case|case
name|NCCL
case|:
if|if
condition|(
name|cclass
argument_list|(
name|ep
argument_list|,
operator|*
name|lp
operator|++
argument_list|,
name|ep
index|[
operator|-
literal|1
index|]
operator|==
name|CCL
argument_list|)
condition|)
block|{
name|ep
operator|+=
operator|*
name|ep
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CBRA
case|:
name|braslist
index|[
operator|*
name|ep
operator|++
index|]
operator|=
name|lp
expr_stmt|;
continue|continue;
case|case
name|CKET
case|:
name|braelist
index|[
operator|*
name|ep
operator|++
index|]
operator|=
name|lp
expr_stmt|;
continue|continue;
case|case
name|CBACK
case|:
if|if
condition|(
name|braelist
index|[
name|i
operator|=
operator|*
name|ep
operator|++
index|]
operator|==
literal|0
condition|)
name|errmsg
argument_list|(
literal|63
argument_list|)
expr_stmt|;
if|if
condition|(
name|backref
argument_list|(
name|i
argument_list|,
name|lp
argument_list|)
condition|)
block|{
name|lp
operator|+=
name|braelist
index|[
name|i
index|]
operator|-
name|braslist
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CBACK
operator||
name|STAR
case|:
if|if
condition|(
name|braelist
index|[
name|i
operator|=
operator|*
name|ep
operator|++
index|]
operator|==
literal|0
condition|)
name|errmsg
argument_list|(
literal|63
argument_list|)
expr_stmt|;
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
name|backref
argument_list|(
name|i
argument_list|,
name|lp
argument_list|)
condition|)
name|lp
operator|+=
name|braelist
index|[
name|i
index|]
operator|-
name|braslist
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|lp
operator|>=
name|curlp
condition|)
block|{
if|if
condition|(
name|advance
argument_list|(
name|lp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|lp
operator|-=
name|braelist
index|[
name|i
index|]
operator|-
name|braslist
index|[
name|i
index|]
expr_stmt|;
block|}
continue|continue;
case|case
name|CDOT
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
condition|)
empty_stmt|;
goto|goto
name|star
goto|;
case|case
name|CCHR
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
operator|==
operator|*
name|ep
condition|)
empty_stmt|;
name|ep
operator|++
expr_stmt|;
goto|goto
name|star
goto|;
case|case
name|CCL
operator||
name|STAR
case|:
case|case
name|NCCL
operator||
name|STAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
name|cclass
argument_list|(
name|ep
argument_list|,
operator|*
name|lp
operator|++
argument_list|,
name|ep
index|[
operator|-
literal|1
index|]
operator|==
operator|(
name|CCL
operator||
name|STAR
operator|)
argument_list|)
condition|)
empty_stmt|;
name|ep
operator|+=
operator|*
name|ep
expr_stmt|;
comment|/* goto star; */
name|star
label|:
name|s_sav
operator|=
name|s_tmp
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|--
name|lp
operator|==
name|locs
condition|)
break|break;
if|if
condition|(
name|advance
argument_list|(
name|lp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|s_tmp
operator|=
name|s_sav
expr_stmt|;
block|}
do|while
condition|(
name|lp
operator|>
name|curlp
condition|)
do|;
operator|--
name|s_tmp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|errmsg
argument_list|(
operator|-
literal|26
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|linep
modifier|*
name|append
parameter_list|(
name|f
parameter_list|,
name|a
parameter_list|,
name|single
parameter_list|,
name|bkpf
parameter_list|)
name|func
name|f
decl_stmt|;
name|linep
modifier|*
name|a
decl_stmt|;
block|{
specifier|register
name|linep
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|,
modifier|*
name|rdot
decl_stmt|;
specifier|register
name|nline
operator|,
name|tl
expr_stmt|;
name|nline
operator|=
literal|0
expr_stmt|;
name|dot
operator|=
name|a
expr_stmt|;
while|while
condition|(
call|(
modifier|*
name|f
call|)
argument_list|(
name|single
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dol
operator|>=
name|endcore
condition|)
block|{
if|if
condition|(
name|sbrk
argument_list|(
literal|1024
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errmsg
argument_list|(
literal|33
argument_list|)
expr_stmt|;
name|endcore
operator|=
operator|(
name|int
operator|)
name|endcore
operator|+
literal|1024
expr_stmt|;
block|}
name|tl
operator|=
name|putline
argument_list|()
expr_stmt|;
name|nline
operator|++
expr_stmt|;
name|a1
operator|=
operator|++
name|dol
expr_stmt|;
name|a2
operator|=
name|a1
operator|+
literal|1
expr_stmt|;
name|rdot
operator|=
operator|++
name|dot
expr_stmt|;
while|while
condition|(
name|a1
operator|>
name|rdot
condition|)
operator|*
operator|--
name|a2
operator|=
operator|*
operator|--
name|a1
expr_stmt|;
operator|*
name|rdot
operator|=
name|tl
expr_stmt|;
if|if
condition|(
name|bkpf
condition|)
block|{
name|mods
operator|++
expr_stmt|;
name|backchk
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|single
condition|)
break|break;
block|}
return|return
operator|(
name|nline
operator|)
return|;
block|}
end_function

begin_macro
name|are_you_sure
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|USE
if|if
condition|(
name|alt
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|text_modified
operator|||
name|fflg
operator|||
name|immflg
operator|||
name|zero
operator|==
name|dol
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|yes_no
argument_list|(
name|curt
condition|?
literal|"?forget"
else|:
literal|"did you forget to save your text"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|argnum
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|n
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|*
name|ap
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|'0'
operator|<=
operator|*
name|p
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
operator|*
name|ap
operator|=
operator|--
name|p
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|backchk
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|modcount
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|mods
operator|>=
name|modcount
condition|)
block|{
name|mods
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|EOL
if|if
condition|(
name|backup
argument_list|(
name|TMP
argument_list|)
operator|&&
name|prompt2
operator|&&
name|prompt3
condition|)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|EOL
if|if
condition|(
name|backup
argument_list|(
name|TMP
argument_list|)
operator|&&
name|prompt2
condition|)
endif|#
directive|endif
if|if
condition|(
operator|!
name|curt
condition|)
name|putsn
argument_list|(
name|errtext
index|[
literal|56
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|backref
argument_list|(
argument|an
argument_list|,
argument|alp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|alp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|n
expr_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|n
operator|=
name|an
expr_stmt|;
name|bp
operator|=
name|braslist
index|[
name|n
index|]
expr_stmt|;
name|lp
operator|=
name|alp
expr_stmt|;
while|while
condition|(
operator|*
name|bp
operator|++
operator|==
operator|*
name|lp
operator|++
condition|)
if|if
condition|(
name|bp
operator|>=
name|braelist
index|[
name|n
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|backup
argument_list|(
argument|af
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
specifier|register
name|linep
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|;
specifier|register
name|func
name|savint
decl_stmt|,
name|savhup
decl_stmt|;
if|if
condition|(
name|io
condition|)
block|{
name|putsn
argument_list|(
literal|"******** backup: I/O in progress"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|flush_buf
argument_list|()
expr_stmt|;
name|p1
operator|=
name|savedfile
expr_stmt|;
name|t2
operator|=
name|p2
operator|=
name|file
expr_stmt|;
while|while
condition|(
operator|*
name|p2
operator|=
operator|*
name|p1
operator|++
condition|)
if|if
condition|(
operator|*
name|p2
operator|++
operator|==
literal|'/'
condition|)
name|t2
operator|=
name|p2
expr_stmt|;
if|if
condition|(
name|p2
operator|>
name|t2
operator|+
literal|10
condition|)
name|p2
operator|=
name|t2
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|af
operator|!=
name|FILE
operator|&&
name|p2
operator|>=
operator|&
name|file
index|[
name|FNSIZE
operator|-
literal|6
index|]
condition|)
name|errmsg
argument_list|(
literal|11
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|af
operator|<
literal|0
condition|?
operator|-
name|af
else|:
name|af
condition|)
block|{
case|case
name|FILE
case|:
name|p1
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TMP
case|:
name|p1
operator|=
name|dotedt
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|p1
operator|=
name|dotint
expr_stmt|;
break|break;
case|case
name|HUP
case|:
name|p1
operator|=
name|dothup
expr_stmt|;
break|break;
case|case
name|BAK
case|:
name|p1
operator|=
name|dotbak
expr_stmt|;
break|break;
case|case
name|TRM
case|:
name|p1
operator|=
name|dottrm
expr_stmt|;
break|break;
default|default:
name|errmsg
argument_list|(
operator|-
literal|17
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p1
condition|)
while|while
condition|(
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
condition|)
empty_stmt|;
if|if
condition|(
name|af
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|deltflg
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
operator|!
name|unlink
argument_list|(
name|file
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|dol
operator|==
name|zero
operator|&&
operator|!
name|fflg
condition|)
block|{
if|if
condition|(
name|af
operator|==
name|FILE
condition|)
if|if
condition|(
name|curt
condition|)
name|putsn
argument_list|(
literal|"?48"
argument_list|)
expr_stmt|;
else|else
name|putsn
argument_list|(
name|errtext
index|[
literal|48
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dol
operator|==
name|zero
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|iflg
condition|)
block|{
name|savhup
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|savint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|over
operator|&&
name|af
operator|==
name|FILE
condition|)
name|override
argument_list|()
expr_stmt|;
name|io
operator|=
name|create
argument_list|(
name|file
argument_list|,
operator|(
name|af
operator|==
name|FILE
condition|?
name|MODE
else|:
name|LMODE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|overfile
condition|)
block|{
name|chmod
argument_list|(
name|overfile
argument_list|,
name|overmode
argument_list|)
expr_stmt|;
name|overfile
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|io
operator|<
literal|0
condition|)
block|{
name|io
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|af
operator|!=
name|TMP
condition|)
block|{
if|if
condition|(
name|curt
condition|)
name|putsn
argument_list|(
literal|"?54"
argument_list|)
expr_stmt|;
else|else
block|{
name|puts2
argument_list|(
name|errtext
index|[
literal|54
index|]
argument_list|)
expr_stmt|;
name|putsn
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|iflg
condition|)
block|{
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|savhup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|savint
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|io_w
operator|++
expr_stmt|;
name|a1
operator|=
name|addr1
expr_stmt|;
name|a2
operator|=
name|addr2
expr_stmt|;
name|addr1
operator|=
name|zero
operator|+
literal|1
expr_stmt|;
name|addr2
operator|=
name|dol
expr_stmt|;
name|putfile
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|io
operator|=
literal|0
expr_stmt|;
name|io_w
operator|=
literal|0
expr_stmt|;
name|addr1
operator|=
name|a1
expr_stmt|;
name|addr2
operator|=
name|a2
expr_stmt|;
if|if
condition|(
operator|!
name|iflg
condition|)
block|{
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|savhup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|savint
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|CKPT
end_ifndef

begin_macro
name|badsig
argument_list|(
argument|an
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|=
name|backup
argument_list|(
name|TMP
argument_list|)
condition|)
name|putsn
argument_list|(
name|errtext
index|[
literal|56
index|]
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  Fatal Signal: "
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|an
operator|&&
name|an
operator|<
name|NSTR
operator|&&
name|status
index|[
name|an
index|]
condition|)
name|putsn
argument_list|(
name|status
index|[
name|an
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|an
argument_list|)
expr_stmt|;
name|flush_buf
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|error
argument_list|()
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|blkio
argument_list|(
argument|b
argument_list|,
argument|buf
argument_list|,
argument|iofcn
argument_list|)
end_macro

begin_decl_stmt
name|func
name|iofcn
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lseek
argument_list|(
name|tfile
argument_list|,
literal|512L
operator|*
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|iofcn
call|)
argument_list|(
name|tfile
argument_list|,
name|buf
argument_list|,
name|BLKSIZE
argument_list|)
operator|!=
name|BLKSIZE
condition|)
block|{
name|badf
operator|++
expr_stmt|;
name|errmsg
argument_list|(
operator|-
literal|35
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|cclass
argument_list|(
argument|aset
argument_list|,
argument|ac
argument_list|,
argument|af
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|aset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|charac
name|ac
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|set
decl_stmt|;
specifier|register
name|n
expr_stmt|;
specifier|register
name|charac
name|c
decl_stmt|,
name|m
decl_stmt|;
name|set
operator|=
name|aset
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|ac
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|n
operator|=
operator|*
name|set
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|n
condition|)
if|if
condition|(
name|set
index|[
literal|1
index|]
operator|==
literal|'-'
operator|&&
name|n
operator|>
literal|2
condition|)
block|{
name|c
operator|=
name|min
argument_list|(
name|set
index|[
literal|0
index|]
argument_list|,
name|set
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|m
operator|=
name|max
argument_list|(
name|set
index|[
literal|0
index|]
argument_list|,
name|set
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|c
operator|==
name|ac
condition|)
return|return
operator|(
name|af
operator|)
return|;
block|}
do|while
condition|(
operator|++
name|c
operator|!=
name|m
condition|)
do|;
name|set
operator|+=
literal|2
expr_stmt|;
name|c
operator|=
name|ac
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|set
operator|++
operator|==
name|c
condition|)
return|return
operator|(
name|af
operator|)
return|;
return|return
operator|(
operator|!
name|af
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|CKPT
end_ifdef

begin_macro
name|checkpoint
argument_list|(
argument|asig
argument_list|)
end_macro

begin_block
block|{
extern|extern etext;
specifier|register
name|filedes
name|f
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|func
name|savint
decl_stmt|,
name|savqit
decl_stmt|;
name|int
name|n
decl_stmt|;
name|savint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|savqit
operator|=
name|signal
argument_list|(
name|SIGQIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|etext
expr_stmt|;
comment|/* won't work for -n, -i, or -z */
name|n
operator|=
operator|(
name|char
operator|*
operator|)
name|dol
operator|-
name|p
expr_stmt|;
name|n
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|create
argument_list|(
name|cfname
argument_list|,
name|LMODE
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|write
argument_list|(
name|f
argument_list|,
operator|&
name|n
argument_list|,
sizeof|sizeof
name|n
argument_list|)
operator|!=
sizeof|sizeof
name|n
condition|)
block|{
name|n
operator|=
literal|66
expr_stmt|;
goto|goto
name|cerror
goto|;
block|}
ifdef|#
directive|ifdef
name|pdp11
comment|/* 16 bit byte count only */
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|f
argument_list|,
name|etext
argument_list|,
literal|32256
argument_list|)
operator|!=
literal|32256
condition|)
block|{
name|n
operator|=
literal|66
expr_stmt|;
goto|goto
name|cerror
goto|;
block|}
name|n
operator|-=
literal|32256
expr_stmt|;
comment|/* 63 blocks, since 64 is< 0 */
name|p
operator|+=
literal|32256
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|write
argument_list|(
name|f
argument_list|,
name|p
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
name|n
operator|=
literal|66
expr_stmt|;
else|else
name|n
operator|=
literal|0
expr_stmt|;
name|cerror
label|:
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|savint
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQIT
argument_list|,
name|savqit
argument_list|)
expr_stmt|;
name|recovry
operator|=
literal|0
expr_stmt|;
name|errmsg
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asig
condition|)
block|{
name|puts2
argument_list|(
name|status
index|[
name|asig
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|curt
condition|)
name|puts
argument_list|(
literal|": Fatal error"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curt
condition|)
name|puts2
argument_list|(
literal|"?CKPT "
argument_list|)
expr_stmt|;
else|else
block|{
name|puts2
argument_list|(
literal|"Editing session checkpointed to \""
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
name|cfname
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\".\nTo recover your work, type:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|editor
operator|&&
operator|*
name|editor
condition|)
name|puts2
argument_list|(
name|editor
argument_list|)
expr_stmt|;
else|else
name|puts2
argument_list|(
literal|"edit"
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
literal|" -R"
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
operator|&
name|tfname
index|[
name|tfnum
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|chk
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|charac
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|t2
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
specifier|register
name|charac
name|oldc
decl_stmt|;
name|long
name|t
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
if|if
condition|(
operator|*
name|savedfile
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|t2
operator|=
name|p2
operator|=
name|file
expr_stmt|;
name|p1
operator|=
name|savedfile
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|p1
argument_list|,
operator|&
name|s
argument_list|)
operator|>=
literal|0
condition|)
name|t
operator|=
name|s
operator|.
name|st_mtime
expr_stmt|;
else|else
name|t
operator|=
literal|0L
expr_stmt|;
while|while
condition|(
operator|*
name|p2
operator|=
operator|*
name|p1
operator|++
condition|)
if|if
condition|(
operator|*
name|p2
operator|++
operator|==
literal|'/'
condition|)
name|t2
operator|=
name|p2
expr_stmt|;
if|if
condition|(
name|p2
operator|>
name|t2
operator|+
literal|10
condition|)
name|p2
operator|=
name|t2
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|p2
operator|>=
operator|&
name|file
index|[
name|FNSIZE
operator|-
literal|6
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|t2
operator|=
name|p2
expr_stmt|;
name|p
operator|=
name|dots
expr_stmt|;
while|while
condition|(
name|p1
operator|=
operator|*
name|p
operator|++
condition|)
block|{
name|p2
operator|=
name|t2
expr_stmt|;
while|while
condition|(
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
condition|)
empty_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|s
argument_list|)
operator|>=
literal|0
operator|&&
name|s
operator|.
name|st_mtime
operator|>=
name|t
condition|)
block|{
if|if
condition|(
name|curt
condition|)
block|{
name|puts2
argument_list|(
literal|"?\""
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
literal|"\"  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putsn
argument_list|(
literal|"When you were last editing this file"
argument_list|)
expr_stmt|;
name|putsn
argument_list|(
literal|"you did not exit the editor normally,"
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
literal|"leaving the file:  \""
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|dotedt
condition|)
block|{
name|putsn
argument_list|(
literal|"\".\nIt contains your file up to the last \"[file saved]\""
argument_list|)
expr_stmt|;
name|putsn
argument_list|(
literal|"message.  This file will be deleted if you do"
argument_list|)
expr_stmt|;
name|putsn
argument_list|(
literal|"not read it into the editor now.  If you read"
argument_list|)
expr_stmt|;
name|putsn
argument_list|(
literal|"it, then decide not to use it, exit the editor"
argument_list|)
expr_stmt|;
name|putsn
argument_list|(
literal|"with \"qi\"."
argument_list|)
expr_stmt|;
block|}
else|else
name|putsn
argument_list|(
literal|"\"."
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|yes_no
argument_list|(
name|curt
condition|?
literal|"read"
else|:
literal|"Do you wish to read it"
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|_cleanup
argument_list|()
end_macro

begin_block
block|{
name|flush_buf
argument_list|()
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|CLEAR
end_ifdef

begin_macro
name|clear
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|l
operator|,
name|i
expr_stmt|;
name|l
operator|=
name|listf
expr_stmt|;
name|listf
operator|=
literal|0
expr_stmt|;
name|puts2
argument_list|(
name|clears
argument_list|)
expr_stmt|;
comment|/* clear sequence */
name|flush_buf
argument_list|()
expr_stmt|;
name|i
operator|=
literal|5
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|putchar
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* ADM-3A's need padding at 19.2 */
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|listf
operator|=
name|l
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|commands
argument_list|(
argument|baseflg
argument_list|)
end_macro

begin_block
block|{
extern|extern getfile(
block|)
end_block

begin_operator
operator|,
end_operator

begin_expr_stmt
name|gettty
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|linep
modifier|*
name|a1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|charac
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|r
operator|,
name|num
expr_stmt|;
end_expr_stmt

begin_for
for|for ever
block|{
ifdef|#
directive|ifdef
name|AGAIN
if|if
condition|(
name|agp
condition|)
block|{
operator|*
name|agp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|agp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|agf
operator|=
literal|0
expr_stmt|;
name|agp
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|immflg
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|logamp
condition|)
block|{
operator|++
name|logstats
operator|.
name|lp_amp
expr_stmt|;
name|logamp
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|globp
operator|&&
operator|(
name|hupflag
operator|||
name|termflg
operator|)
condition|)
block|{
if|if
condition|(
name|hupflag
condition|)
block|{
name|backup
argument_list|(
name|HUP
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
name|errtext
index|[
literal|57
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|backup
argument_list|(
name|TRM
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
name|errtext
index|[
literal|58
index|]
argument_list|)
expr_stmt|;
block|}
name|delexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pflag
condition|)
block|{
name|pflag
operator|=
literal|0
expr_stmt|;
name|addr1
operator|=
name|addr2
operator|=
name|dot
expr_stmt|;
goto|goto
name|print
goto|;
block|}
if|if
condition|(
operator|!
name|globp
condition|)
block|{
ifdef|#
directive|ifdef
name|USE
if|if
condition|(
operator|!
name|alt
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|modcount
condition|)
block|{
if|if
condition|(
name|text_modified
operator|>
name|savf
condition|)
name|mods
operator|++
expr_stmt|;
name|savf
operator|=
name|text_modified
expr_stmt|;
name|backchk
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EOL
ifdef|#
directive|ifdef
name|USE
if|if
condition|(
name|prompt2
operator|&&
name|prompt3
operator|&&
operator|!
name|eflg2
condition|)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|USE
if|if
condition|(
name|prompt2
operator|&&
name|prompt3
condition|)
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|EOL
ifdef|#
directive|ifdef
name|USE
if|if
condition|(
name|prompt2
operator|&&
operator|!
name|eflg2
condition|)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|USE
if|if
condition|(
name|prompt2
condition|)
endif|#
directive|endif
endif|#
directive|endif
block|{
name|puts2
argument_list|(
name|e_prompt
argument_list|)
expr_stmt|;
name|flush_buf
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE
block|}
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|globp
condition|)
block|{
if|if
condition|(
name|dotdot
operator|>
name|dol
condition|)
name|dotdot
operator|=
name|dol
expr_stmt|;
if|if
condition|(
name|dotdot
operator|<
name|zero
condition|)
name|dotdot
operator|=
name|zero
expr_stmt|;
if|if
condition|(
name|dot
operator|!=
name|lastdot
condition|)
block|{
name|dotdot
operator|=
name|lastdot
expr_stmt|;
name|lastdot
operator|=
name|dot
expr_stmt|;
block|}
block|}
name|addr1
operator|=
literal|0
expr_stmt|;
name|addr2
operator|=
literal|0
expr_stmt|;
name|s_tmp
operator|=
literal|0
expr_stmt|;
name|s_cnt
operator|=
literal|0
expr_stmt|;
name|r
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|addr1
operator|=
name|addr2
expr_stmt|;
if|if
condition|(
operator|(
name|a1
operator|=
name|address
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
break|break;
block|}
name|addr2
operator|=
name|a1
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|';'
condition|)
block|{
name|c
operator|=
literal|','
expr_stmt|;
name|dot
operator|=
name|a1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
operator|&&
operator|--
name|r
operator|>=
literal|0
condition|)
do|;
if|if
condition|(
name|addr1
operator|==
literal|0
condition|)
name|addr1
operator|=
name|addr2
expr_stmt|;
if|if
condition|(
operator|!
name|globp
operator|&&
operator|!
name|baseflg
condition|)
block|{
if|if
condition|(
name|addr1
condition|)
block|{
name|old_a1
operator|=
name|addr1
expr_stmt|;
name|old_a2
operator|=
name|addr2
expr_stmt|;
block|}
block|}
name|line_num
operator|=
operator|(
name|addr1
condition|?
name|addr1
else|:
name|dot
operator|)
operator|-
name|zero
expr_stmt|;
ifdef|#
directive|ifdef
name|AGAIN
if|if
condition|(
name|c
operator|==
literal|'o'
operator|||
name|c
operator|==
name|ctrl
argument_list|(
literal|'Q'
argument_list|)
condition|)
block|{
comment|/* again command "o" */
if|if
condition|(
name|c
operator|!=
name|ctrl
argument_list|(
literal|'Q'
argument_list|)
operator|&&
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
name|errmsg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|ctrl
argument_list|(
literal|'Q'
argument_list|)
condition|)
name|putchar
argument_list|(
name|lastc
operator|=
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|agbuf
operator|==
literal|0
condition|)
name|errmsg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|agf
operator|++
expr_stmt|;
name|agp
operator|=
name|agbuf
expr_stmt|;
name|c
operator|=
operator|*
name|agp
operator|++
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_o
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|baseflg
operator|==
literal|0
operator|&&
name|globp
operator|==
literal|0
condition|)
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|agp
operator|=
name|agbuf
expr_stmt|;
operator|*
name|agp
operator|++
operator|=
name|c
expr_stmt|;
comment|/* first char not yet saved */
block|}
endif|#
directive|endif
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'b'
condition|)
name|abort
argument_list|()
expr_stmt|;
name|setdot
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|XED
if|if
condition|(
name|peekc
operator|!=
literal|' '
operator|&&
name|peekc
operator|!=
literal|'\n'
condition|)
block|{
name|c
operator|=
name|peekc
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tack
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
condition|)
name|text_modified
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_aslash
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
endif|#
directive|endif
name|line_num
operator|++
expr_stmt|;
name|num
operator|=
name|addr2
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_append
expr_stmt|;
endif|#
directive|endif
name|caseadd
label|:
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|' '
condition|)
block|{
name|r
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_aspace
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|XED
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|peekc
operator|=
name|c
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|r
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|append
argument_list|(
name|gettty
argument_list|,
name|num
argument_list|,
name|r
argument_list|,
literal|1
argument_list|)
condition|)
name|text_modified
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
name|setnoaddr
argument_list|()
expr_stmt|;
name|white_space
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|brcount
operator|=
name|setnum
argument_list|(
literal|1
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|brcount
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_browse
expr_stmt|;
endif|#
directive|endif
continue|continue;
case|case
literal|'c'
case|:
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'o'
condition|)
block|{
comment|/* co == t */
name|peekc
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_copy
expr_stmt|;
endif|#
directive|endif
goto|goto
name|casecopy
goto|;
block|}
if|if
condition|(
name|peekc
operator|!=
literal|'\n'
condition|)
goto|goto
name|casesub
goto|;
name|newline
argument_list|()
expr_stmt|;
name|setdot
argument_list|()
expr_stmt|;
name|nonzero
argument_list|()
expr_stmt|;
name|delete
argument_list|()
expr_stmt|;
name|text_modified
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_change
expr_stmt|;
endif|#
directive|endif
name|append
argument_list|(
name|gettty
argument_list|,
name|addr1
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
ifdef|#
directive|ifdef
name|DEBUG
comment|/*		*du	Dump command (testing only)	*/
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'u'
condition|)
block|{
name|peekc
operator|=
literal|0
expr_stmt|;
name|dump
argument_list|()
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|peekc
operator|==
literal|','
condition|)
block|{
name|peekc
operator|=
literal|0
expr_stmt|;
name|white_space
argument_list|()
expr_stmt|;
name|p
operator|=
name|linebuf
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
name|errmsg
argument_list|(
literal|51
argument_list|)
expr_stmt|;
do|do
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
ifndef|#
directive|ifndef
name|ALLOC
if|if
condition|(
name|p
operator|>=
operator|&
name|linebuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
condition|)
else|#
directive|else
if|if
condition|(
name|p
operator|>=
operator|&
name|linebuf
index|[
name|lbsize
operator|-
literal|2
index|]
condition|)
endif|#
directive|endif
name|errmsg
argument_list|(
literal|11
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|>=
literal|0
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
do|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_directory
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|chdir
argument_list|(
name|linebuf
argument_list|)
operator|<
literal|0
condition|)
name|errmsg
argument_list|(
literal|51
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|PAGE
if|if
condition|(
name|peekc
operator|==
literal|'='
condition|)
block|{
comment|/* d=<depth> */
name|peekc
operator|=
literal|0
expr_stmt|;
name|setnoaddr
argument_list|()
expr_stmt|;
name|pcount
operator|=
name|setnum
argument_list|(
name|PAGSIZ
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_depth
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
endif|#
directive|endif
name|newline
argument_list|()
expr_stmt|;
name|setdot
argument_list|()
expr_stmt|;
name|nonzero
argument_list|()
expr_stmt|;
name|delete
argument_list|()
expr_stmt|;
name|text_modified
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_delete
expr_stmt|;
endif|#
directive|endif
continue|continue;
case|case
literal|'e'
case|:
name|eagain
label|:
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
block|{
ifdef|#
directive|ifdef
name|EOL
if|if
condition|(
name|peekc
operator|==
literal|'='
condition|)
block|{
comment|/* e=c - set eol to 'c' */
name|peekc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|immflg
condition|)
name|errmsg
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|setnoaddr
argument_list|()
expr_stmt|;
name|eol
operator|=
name|setchar
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_eol
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TABS
if|if
condition|(
name|peekc
operator|==
literal|'x'
condition|)
block|{
name|peekc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|immflg
condition|)
name|errmsg
argument_list|(
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'p'
condition|)
name|errmsg
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|tabc
condition|)
name|errmsg
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxtab
operator|<
literal|0
condition|)
name|errmsg
argument_list|(
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
argument_list|()
condition|)
name|text_modified
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_exp
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
literal|'0'
operator|<=
name|peekc
operator|&&
name|peekc
operator|<=
literal|'9'
condition|)
block|{
name|c
operator|=
name|getnum
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|c
operator|&&
name|c
operator|<
name|NERR
condition|)
name|printf
argument_list|(
literal|"%3d: %s\n"
argument_list|,
name|c
argument_list|,
name|errtext
index|[
name|c
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_errmsg
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|peekc
operator|==
literal|'+'
operator|||
name|peekc
operator|==
literal|'-'
condition|)
block|{
name|c
operator|=
name|peekc
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|curt
operator|=
name|c
operator|==
literal|'-'
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|curt
condition|)
operator|++
name|logstats
operator|.
name|lc_eminus
expr_stmt|;
else|else
operator|++
name|logstats
operator|.
name|lc_eplus
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|peekc
operator|==
literal|'i'
condition|)
block|{
name|peekc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|immflg
condition|)
name|errmsg
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|immflg
operator|++
expr_stmt|;
goto|goto
name|eagain
goto|;
block|}
name|setnoaddr
argument_list|()
expr_stmt|;
if|if
condition|(
name|fflg
condition|)
name|errmsg
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|peekc
operator|!=
literal|' '
operator|&&
name|peekc
operator|!=
literal|','
condition|)
name|illfnm
label|:
name|errmsg
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|scopy
argument_list|(
name|savedfile
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero
operator|==
name|dol
operator|||
name|text_modified
operator|==
literal|0
condition|)
name|backup
argument_list|(
operator|-
name|TMP
argument_list|)
expr_stmt|;
name|savedfile
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|filename
argument_list|()
expr_stmt|;
if|if
condition|(
name|text_modified
operator|&&
name|are_you_sure
argument_list|()
condition|)
block|{
name|scopy
argument_list|(
name|tempfile
argument_list|,
name|savedfile
argument_list|)
expr_stmt|;
name|error
argument_list|()
expr_stmt|;
block|}
name|peekc
operator|=
literal|'\n'
expr_stmt|;
block|}
else|else
block|{
name|setnoaddr
argument_list|()
expr_stmt|;
if|if
condition|(
name|text_modified
condition|)
block|{
name|r
operator|=
name|peekc
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|are_you_sure
argument_list|()
condition|)
block|{
name|peekc
operator|=
name|r
expr_stmt|;
name|error
argument_list|()
expr_stmt|;
block|}
name|peekc
operator|=
name|r
expr_stmt|;
block|}
if|if
condition|(
name|zero
operator|==
name|dol
operator|||
name|text_modified
operator|==
literal|0
condition|)
name|backup
argument_list|(
operator|-
name|TMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init
argument_list|()
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_edit
expr_stmt|;
endif|#
directive|endif
goto|goto
name|caseread
goto|;
case|case
literal|'f'
case|:
name|setnoaddr
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TABS
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'='
condition|)
block|{
comment|/* f=c fill char */
name|peekc
operator|=
literal|0
expr_stmt|;
name|tabfill
operator|=
name|setchar
argument_list|(
name|TABFILL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_fillset
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|fflg
condition|)
name|errmsg
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|peekc
operator|=
name|c
expr_stmt|;
name|filename
argument_list|()
expr_stmt|;
name|scopy
argument_list|(
name|file
argument_list|,
name|savedfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_fset
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|prompt2
operator|==
literal|0
condition|)
continue|continue;
block|}
ifdef|#
directive|ifdef
name|LOG
else|else
operator|++
name|logstats
operator|.
name|lc_fshow
expr_stmt|;
endif|#
directive|endif
name|putsn
argument_list|(
name|savedfile
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'g'
case|:
name|global
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'h'
case|:
ifdef|#
directive|ifdef
name|HELP
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'e'
condition|)
block|{
comment|/* he[lp] */
name|peekc
operator|=
literal|0
expr_stmt|;
name|setnoaddr
argument_list|()
expr_stmt|;
name|skip_rest
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_help
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|doc
operator|=
name|open
argument_list|(
name|help
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|read
argument_list|(
name|doc
argument_list|,
name|linebuf
argument_list|,
ifndef|#
directive|ifndef
name|ALLOC
name|LBSIZE
argument_list|)
operator|)
operator|>
literal|0
condition|)
else|#
directive|else
name|lbsize
block|)
block|)
operator|>
literal|0
block|)
endif|#
directive|endif
name|write
argument_list|(
literal|1
argument_list|,
name|linebuf
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|doc
argument_list|)
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|doc
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_continue
continue|continue;
end_continue

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_expr_stmt
unit|if
operator|(
name|zero
operator|!=
name|dol
operator|)
block|{
name|setdot
argument_list|()
block|;
name|nonzero
argument_list|()
block|; 		}
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_header
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|header
argument_list|()
expr_stmt|;
end_expr_stmt

begin_continue
continue|continue;
end_continue

begin_case
case|case
literal|'i'
case|:
end_case

begin_expr_stmt
name|setdot
argument_list|()
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|XED
end_ifdef

begin_if
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|' '
operator|&&
name|peekc
operator|!=
literal|'\n'
condition|)
block|{
name|c
operator|=
name|peekc
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tack
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
condition|)
name|text_modified
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_islash
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|nonzero
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|num
operator|=
name|addr2
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_expr_stmt
operator|++
name|logstats
operator|.
name|lc_insert
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_goto
goto|goto
name|caseadd
goto|;
end_goto

begin_ifdef
ifdef|#
directive|ifdef
name|XED
end_ifdef

begin_case
case|case
literal|'j'
case|:
end_case

begin_expr_stmt
name|setdot
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nonzero
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|join
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|text_modified
operator|++
expr_stmt|;
end_expr_stmt

begin_continue
continue|continue;
end_continue

begin_endif
endif|#
directive|endif
end_endif

begin_case
case|case
literal|'k'
case|:
end_case

begin_if
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
block|{
name|setnoaddr
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_klist
expr_stmt|;
endif|#
directive|endif
name|printmarks
argument_list|()
expr_stmt|;
continue|continue;
block|}
end_if

begin_if
if|if
condition|(
literal|'A'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
name|c
operator||=
literal|040
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|c
operator|<
literal|'a'
operator|||
name|c
operator|>
literal|'z'
condition|)
name|errmsg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|newline
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setdot
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nonzero
argument_list|()
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HUGE
end_ifdef

begin_expr_stmt
name|r
operator|=
name|hugef
operator|^
literal|01
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|r
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EXTMARK
end_ifdef

begin_if
if|if
condition|(
name|addr1
operator|!=
name|addr2
condition|)
block|{
name|names
index|[
name|c
operator|-
literal|'a'
index|]
operator|=
operator|*
name|addr1
operator||
name|r
expr_stmt|;
name|names2
index|[
name|c
operator|-
literal|'a'
index|]
operator|=
operator|*
name|addr2
operator||
name|r
expr_stmt|;
block|}
else|else
block|{
name|names
index|[
name|c
operator|-
literal|'a'
index|]
operator|=
operator|*
name|addr2
operator||
name|r
expr_stmt|;
name|names2
index|[
name|c
operator|-
literal|'a'
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|names
index|[
name|c
operator|-
literal|'a'
index|]
operator|=
operator|*
name|addr2
operator||
name|r
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_expr_stmt
operator|++
name|logstats
operator|.
name|lc_kset
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_continue
continue|continue;
end_continue

begin_ifndef
ifndef|#
directive|ifndef
name|HUGE
end_ifndef

begin_undef
undef|#
directive|undef
name|r
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_case
case|case
literal|'m'
case|:
end_case

begin_ifdef
ifdef|#
directive|ifdef
name|DUMB
end_ifdef

begin_if
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
block|{
name|setnoaddr
argument_list|()
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
name|dumbf
operator|^=
literal|01
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_magic
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|curt
condition|)
name|putsn
argument_list|(
name|dumbf
condition|?
name|off
else|:
name|on
argument_list|)
expr_stmt|;
else|else
block|{
name|puts2
argument_list|(
literal|"\"$&[^.*\\(\\)\" have "
argument_list|)
expr_stmt|;
if|if
condition|(
name|dumbf
condition|)
name|puts2
argument_list|(
name|no
argument_list|)
expr_stmt|;
name|putsn
argument_list|(
literal|"special meaning"
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'o'
condition|)
block|{
comment|/* mo == m */
name|peekc
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_moove
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|LOG
else|else
operator|++
name|logstats
operator|.
name|lc_move
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|move
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|text_modified
operator|++
expr_stmt|;
end_expr_stmt

begin_continue
continue|continue;
end_continue

begin_case
case|case
literal|'n'
case|:
end_case

begin_expr_stmt
name|setnoaddr
argument_list|()
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PIPE
end_ifdef

begin_if
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'+'
condition|)
block|{
name|peekc
operator|=
literal|0
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|pno
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_numplus
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
end_if

begin_if
if|if
condition|(
name|peekc
operator|==
literal|'-'
condition|)
block|{
name|peekc
operator|=
literal|0
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|pno
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_numinus
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|newline
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|prompt1
operator|^=
literal|01
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_expr_stmt
operator|++
name|logstats
operator|.
name|lc_numbers
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|curt
condition|)
name|putsn
argument_list|(
name|prompt1
condition|?
name|on
else|:
name|off
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|prompt1
operator|==
literal|0
condition|)
name|puts2
argument_list|(
name|no
argument_list|)
expr_stmt|;
name|putsn
argument_list|(
literal|"line numbers"
argument_list|)
expr_stmt|;
block|}
end_if

begin_continue
continue|continue;
end_continue

begin_case
case|case
literal|'\n'
case|:
end_case

begin_if
if|if
condition|(
name|globp
operator|||
name|addr2
operator|>
name|dol
condition|)
continue|continue;
end_if

begin_if
if|if
condition|(
name|addr2
operator|==
literal|0
condition|)
block|{
name|addr1
operator|=
name|addr2
operator|=
name|dot
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|addr2
operator|<=
name|dol
condition|)
name|line_num
operator|++
expr_stmt|;
if|if
condition|(
name|brcount
operator|!=
literal|1
condition|)
block|{
name|addr2
operator|=
name|dot
operator|+
name|brcount
expr_stmt|;
if|if
condition|(
name|addr1
operator|>
name|dol
condition|)
continue|continue;
if|if
condition|(
name|addr2
operator|>
name|dol
condition|)
name|addr2
operator|=
name|dol
expr_stmt|;
if|if
condition|(
name|addr2
operator|<
name|zero
condition|)
name|addr2
operator|=
name|zero
expr_stmt|;
ifdef|#
directive|ifdef
name|CLEAR
if|if
condition|(
name|zflg
operator|&&
name|addr2
operator|-
name|addr1
operator|>
name|pcount
operator|/
literal|2
condition|)
name|clear
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_if

begin_if
if|if
condition|(
name|addr2
operator|<=
name|dol
condition|)
block|{
name|pflag
operator|=
literal|0
expr_stmt|;
goto|goto
name|print
goto|;
block|}
end_if

begin_continue
continue|continue;
end_continue

begin_case
case|case
literal|'l'
case|:
end_case

begin_expr_stmt
name|listf
operator|++
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_expr_stmt
operator|++
name|logstats
operator|.
name|lc_list
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_case
case|case
literal|'p'
case|:
end_case

begin_if
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'a'
condition|)
block|{
name|peekc
operator|=
literal|0
expr_stmt|;
case|case
literal|':'
case|:
case|case
literal|'*'
case|:
name|num
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
operator|||
name|c
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|peekc
operator|==
literal|'\t'
condition|)
block|{
name|skip_rest
argument_list|()
expr_stmt|;
comment|/* comments */
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_comment
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
name|r
operator|=
name|peekc
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|r
operator|==
literal|'-'
operator|||
name|r
operator|==
literal|'+'
condition|)
operator|++
name|logstats
operator|.
name|lc_clnminus
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
operator|++
name|logstats
operator|.
name|lc_star
expr_stmt|;
else|else
operator|++
name|logstats
operator|.
name|lc_colon
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|r
operator|==
literal|'-'
operator|||
name|r
operator|==
literal|'^'
operator|||
name|r
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|r
operator|==
literal|'+'
condition|)
operator|++
name|num
expr_stmt|;
else|else
operator|--
name|num
expr_stmt|;
name|r
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
name|peekc
operator|=
name|r
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LOG
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'p'
condition|)
operator|++
name|logstats
operator|.
name|lc_print
expr_stmt|;
endif|#
directive|endif
name|newline
argument_list|()
expr_stmt|;
name|pflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|addr1
operator|==
name|addr2
condition|)
block|{
if|if
condition|(
name|num
operator|==
operator|-
literal|1
operator|&&
name|c
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|addr2
operator|==
literal|0
condition|)
name|addr2
operator|=
name|dot
expr_stmt|;
name|addr1
operator|=
name|addr2
operator|-
name|pcount
expr_stmt|;
if|if
condition|(
name|addr1
operator|<=
name|zero
condition|)
name|addr1
operator|=
name|zero
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|CLEAR
if|if
condition|(
name|zflg
condition|)
name|clear
argument_list|()
expr_stmt|;
endif|#
directive|endif
goto|goto
name|print
goto|;
block|}
name|num
operator|*=
name|pcount
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
name|num
operator|-=
operator|(
name|pcount
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|addr1
operator|==
literal|0
condition|)
name|a1
operator|=
name|dot
operator|+
operator|(
name|num
condition|?
name|num
else|:
literal|1
operator|)
expr_stmt|;
else|else
name|a1
operator|=
name|addr1
operator|+
name|num
expr_stmt|;
if|if
condition|(
name|a1
operator|<=
name|zero
condition|)
name|a1
operator|=
name|zero
operator|+
literal|1
expr_stmt|;
name|addr1
operator|=
name|addr2
operator|=
name|a1
expr_stmt|;
block|}
name|nonzero
argument_list|()
expr_stmt|;
if|if
condition|(
name|addr1
operator|==
name|addr2
operator|||
name|addr2
operator|>
name|dol
operator|||
name|addr2
operator|<=
name|zero
condition|)
name|addr2
operator|=
name|dol
expr_stmt|;
name|setdot
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CLEAR
if|if
condition|(
name|zflg
operator|&&
name|addr2
operator|-
name|addr1
operator|>
name|pcount
operator|/
literal|2
condition|)
name|clear
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PAGE
if|if
condition|(
name|addr2
operator|>
name|addr1
operator|+
name|pcount
condition|)
name|addr2
operator|=
name|addr1
operator|+
name|pcount
expr_stmt|;
goto|goto
name|print
goto|;
else|#
directive|else
name|page
argument_list|()
expr_stmt|;
name|listf
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PARENS
name|parenf
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STRLEN
name|quotef
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
continue|continue;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|peekc
operator|==
literal|'p'
operator|||
name|peekc
operator|==
literal|'l'
condition|)
block|{
name|peekc
operator|=
literal|0
expr_stmt|;
name|addr1
operator|=
name|zero
operator|+
literal|1
expr_stmt|;
name|addr2
operator|=
name|dol
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_pprint
expr_stmt|;
endif|#
directive|endif
block|}
end_if

begin_expr_stmt
name|newline
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pflag
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_label
name|print
label|:
end_label

begin_expr_stmt
name|setdot
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nonzero
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|a1
operator|=
name|addr1
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PARENS
end_ifdef

begin_expr_stmt
name|parenc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|parenc
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|parenc
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_do
do|do
block|{
name|col
operator|=
literal|0
expr_stmt|;
name|printlno
argument_list|(
name|line_num
operator|=
name|a1
operator|-
name|zero
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|getline
argument_list|(
operator|*
name|a1
operator|++
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|a1
operator|<=
name|addr2
condition|)
do|;
end_do

begin_expr_stmt
name|dot
operator|=
name|addr2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|listf
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PARENS
end_ifdef

begin_expr_stmt
name|parenf
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STRLEN
end_ifdef

begin_expr_stmt
name|quotef
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_continue
continue|continue;
end_continue

begin_case
case|case
literal|'q'
case|:
end_case

begin_if
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'i'
condition|)
block|{
comment|/* qi - immediate */
name|peekc
operator|=
literal|0
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|immflg
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_qimm
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|STRLEN
end_ifdef

begin_if
if|if
condition|(
name|peekc
operator|==
literal|'='
condition|)
block|{
comment|/* q=cc  set quote chars */
name|peekc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|quotec
operator|=
name|quotec2
operator|=
name|c
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_quote
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
continue|continue;
name|quotec2
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|quotec
operator|=
literal|0
expr_stmt|;
name|quotec2
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|newline
argument_list|()
expr_stmt|;
continue|continue;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|setnoaddr
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
name|errmsg
argument_list|(
literal|25
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|peekc
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_expr_stmt
operator|++
name|logstats
operator|.
name|lc_quit
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return;
end_return

begin_case
case|case
literal|'r'
case|:
end_case

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_expr_stmt
operator|++
name|logstats
operator|.
name|lc_read
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_label
name|caseread
label|:
end_label

begin_expr_stmt
name|filename
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|io
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|io
operator|=
literal|0
expr_stmt|;
name|lastc
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|curt
condition|)
name|errmsg
argument_list|(
literal|53
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
name|errtext
index|[
literal|53
index|]
argument_list|)
expr_stmt|;
name|putsn
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|error
argument_list|()
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|setall
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ninbuf
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|r
operator|=
name|append
argument_list|(
name|getfile
argument_list|,
name|addr2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|prompt2
condition|)
name|printf
argument_list|(
operator|(
name|curt
condition|?
name|prcntu
else|:
name|errtext
index|[
literal|55
index|]
operator|)
argument_list|,
name|r
argument_list|,
operator|(
name|r
operator|==
literal|1
condition|?
name|null
else|:
name|quote_s
operator|)
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|close
argument_list|(
name|io
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|io
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_expr_stmt
name|logstats
operator|.
name|lt_rlines
operator|+=
name|r
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|num_reads
operator|++
operator|||
name|fflg
condition|)
block|{
if|if
condition|(
name|r
condition|)
name|text_modified
operator|++
expr_stmt|;
block|}
end_if

begin_comment
comment|/* else 			text_modified = 0; */
end_comment

begin_if
if|if
condition|(
operator|(
name|c
operator|==
literal|'e'
operator|&&
name|bflg
operator|==
literal|1
operator|)
operator|||
name|bflg2
operator|==
literal|1
condition|)
block|{
name|bflg2
operator|=
literal|0
expr_stmt|;
name|backup
argument_list|(
name|BAK
argument_list|)
expr_stmt|;
block|}
end_if

begin_continue
continue|continue;
end_continue

begin_case
case|case
literal|'s'
case|:
end_case

begin_if
if|if
condition|(
operator|!
name|globp
operator|&&
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
block|{
comment|/* w;q */
name|setnoaddr
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_stop
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|text_modified
operator|&&
operator|!
name|fflg
condition|)
if|if
condition|(
name|backup
argument_list|(
name|FILE
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|()
expr_stmt|;
comment|/* errmsg(10) */
name|peekc
operator|=
name|text_modified
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
name|logstats
operator|.
name|lt_wlines
operator|+=
name|dol
operator|-
name|zero
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_if

begin_if
if|if
condition|(
name|peekc
operator|==
literal|'a'
condition|)
block|{
comment|/* sa - count before auto-save */
name|setnoaddr
argument_list|()
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
name|modcount
operator|=
name|setnum
argument_list|(
name|MODCNT
argument_list|)
expr_stmt|;
name|mods
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_savecount
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
end_if

begin_label
name|casesub
label|:
end_label

begin_expr_stmt
name|setdot
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nonzero
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|substitute
argument_list|(
name|globp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|text_modified
operator|++
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_if
if|if
condition|(
name|c
operator|==
literal|'s'
condition|)
operator|++
name|logstats
operator|.
name|lc_substitute
expr_stmt|;
else|else
operator|++
name|logstats
operator|.
name|lc_cslash
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_continue
continue|continue;
end_continue

begin_case
case|case
literal|'t'
case|:
end_case

begin_ifdef
ifdef|#
directive|ifdef
name|TABS
end_ifdef

begin_if
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'='
condition|)
block|{
comment|/* t=c tab char */
name|setnoaddr
argument_list|()
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
name|tabc
operator|=
name|setchar
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_tabchar
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
elseif|else
if|if
condition|(
name|peekc
operator|==
literal|','
condition|)
block|{
comment|/* t,nn  set tabs */
name|setnoaddr
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_tabset
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|','
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|','
condition|)
empty_stmt|;
if|if
condition|(
operator|(
name|c
operator|<
literal|'0'
operator|||
name|c
operator|>
literal|'9'
operator|)
operator|&&
name|c
operator|!=
literal|'-'
condition|)
break|break;
name|peekc
operator|=
name|c
expr_stmt|;
name|settab
argument_list|(
name|getsnum
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|peekc
operator|=
name|c
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|peekc
operator|==
literal|'\n'
condition|)
block|{
comment|/* list tabs */
name|setnoaddr
argument_list|()
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_tablist
expr_stmt|;
endif|#
directive|endif
name|listabs
argument_list|()
expr_stmt|;
continue|continue;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_expr_stmt
operator|++
name|logstats
operator|.
name|lc_transfer
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_label
name|casecopy
label|:
end_label

begin_expr_stmt
name|move
argument_list|(
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|text_modified
operator|++
expr_stmt|;
end_expr_stmt

begin_continue
continue|continue;
end_continue

begin_ifdef
ifdef|#
directive|ifdef
name|UNDO
end_ifdef

begin_case
case|case
literal|'u'
case|:
end_case

begin_expr_stmt
name|setnoaddr
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|newline
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|undo
argument_list|()
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_expr_stmt
operator|++
name|logstats
operator|.
name|lc_undo
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_continue
continue|continue;
end_continue

begin_endif
endif|#
directive|endif
end_endif

begin_case
case|case
literal|'v'
case|:
end_case

begin_expr_stmt
name|global
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_continue
continue|continue;
end_continue

begin_case
case|case
literal|'w'
case|:
end_case

begin_ifdef
ifdef|#
directive|ifdef
name|PAGE
end_ifdef

begin_if
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'='
condition|)
block|{
comment|/* w=<width> */
name|peekc
operator|=
literal|0
expr_stmt|;
name|ccount
operator|=
name|setnum
argument_list|(
name|CCOUNT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_width
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'i'
condition|)
block|{
comment|/* wi over-ride */
operator|++
name|immflg
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_wimm
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|LOG
else|else
operator|++
name|logstats
operator|.
name|lc_write
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|filename
argument_list|()
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_if
if|if
condition|(
name|appflg
condition|)
block|{
operator|--
name|logstats
operator|.
name|lc_write
expr_stmt|;
operator|++
name|logstats
operator|.
name|lc_wonto
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|globp
condition|)
block|{
name|setdot
argument_list|()
expr_stmt|;
name|appflg
operator|++
expr_stmt|;
block|}
else|else
name|setall
argument_list|()
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|dol
operator|==
name|zero
condition|)
block|{
if|if
condition|(
name|curt
condition|)
name|putsn
argument_list|(
literal|"?48"
argument_list|)
expr_stmt|;
else|else
name|putsn
argument_list|(
name|errtext
index|[
literal|48
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fflg
operator|||
name|appflg
condition|)
continue|continue;
block|}
end_if

begin_if
if|if
condition|(
name|over
operator|||
name|immflg
condition|)
name|override
argument_list|()
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|appflg
condition|)
name|io
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|!
name|appflg
operator|||
name|io
operator|<
literal|0
condition|)
name|io
operator|=
name|creat
argument_list|(
name|file
argument_list|,
name|MODE
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|overfile
condition|)
block|{
name|chmod
argument_list|(
name|overfile
argument_list|,
name|overmode
argument_list|)
expr_stmt|;
name|overfile
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|io
operator|<
literal|0
condition|)
block|{
name|io
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|curt
condition|)
name|errmsg
argument_list|(
literal|54
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
name|errtext
index|[
literal|54
index|]
argument_list|)
expr_stmt|;
name|putsn
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|error
argument_list|()
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|io_w
operator|++
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|appflg
condition|)
name|lseek
argument_list|(
name|io
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* append onto file */
end_comment

begin_expr_stmt
name|putfile
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|close
argument_list|(
name|io
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|io
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|io_w
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|addr1
operator|==
name|zero
operator|+
literal|1
operator|&&
name|addr2
operator|==
name|dol
condition|)
name|text_modified
operator|=
literal|0
expr_stmt|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_expr_stmt
name|logstats
operator|.
name|lt_wlines
operator|+=
name|dol
operator|-
name|zero
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_continue
continue|continue;
end_continue

begin_ifdef
ifdef|#
directive|ifdef
name|USE
end_ifdef

begin_case
case|case
literal|'@'
case|:
end_case

begin_expr_stmt
name|setnoaddr
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|alt
condition|)
name|errmsg
argument_list|(
literal|6
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'p'
condition|)
name|peekc
operator|=
literal|0
expr_stmt|;
else|else
name|eflg2
operator|++
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\n'
operator|&&
name|altfile
index|[
literal|0
index|]
condition|)
block|{
name|peekc
operator|=
literal|0
expr_stmt|;
goto|goto
name|altname
goto|;
block|}
end_if

begin_if
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|','
condition|)
name|errmsg
argument_list|(
literal|5
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|white_space
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
name|errmsg
argument_list|(
literal|7
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|p
operator|=
name|altfile
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|errmsg
argument_list|(
literal|59
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
end_while

begin_expr_stmt
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
end_expr_stmt

begin_label
name|altname
label|:
end_label

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_expr_stmt
operator|++
name|logstats
operator|.
name|lc_at
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
operator|(
name|alt
operator|=
name|open
argument_list|(
name|altfile
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|alt
operator|=
literal|0
expr_stmt|;
comment|/* this MUST be 0 */
name|lastc
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|curt
condition|)
name|errmsg
argument_list|(
literal|53
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
name|errtext
index|[
literal|53
index|]
argument_list|)
expr_stmt|;
name|putsn
argument_list|(
name|altfile
argument_list|)
expr_stmt|;
name|error
argument_list|()
expr_stmt|;
block|}
end_if

begin_continue
continue|continue;
end_continue

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_case
case|case
literal|'#'
case|:
end_case

begin_comment
comment|/* toggle debug flag */
end_comment

begin_if
if|if
condition|(
name|addr1
operator|!=
name|addr2
operator|||
name|addr1
operator|!=
name|zero
condition|)
goto|goto
name|illcmd
goto|;
end_if

begin_expr_stmt
name|newline
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tflg
operator|^=
literal|01
expr_stmt|;
end_expr_stmt

begin_continue
continue|continue;
end_continue

begin_ifdef
ifdef|#
directive|ifdef
name|XDEL
end_ifdef

begin_case
case|case
literal|'`'
case|:
end_case

begin_expr_stmt
name|setnoaddr
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|newline
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ndeleted
operator|==
literal|0
condition|)
name|errmsg
argument_list|(
literal|16
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|printf
argument_list|(
literal|"deleted = %o  ndeleted = %d\n"
argument_list|,
name|deleted
argument_list|,
name|ndeleted
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|n
operator|,
operator|*
name|bp
operator|,
name|nl
expr_stmt|;
name|int
name|tl
decl_stmt|;
name|tl
operator|=
name|deleted
expr_stmt|;
name|bp
operator|=
name|getblock
argument_list|(
name|tl
argument_list|,
name|READ
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HUGE
name|tl
operator|&=
name|_1
index|[
name|hugef
index|]
expr_stmt|;
else|#
directive|else
name|tl
operator|&=
name|_1
expr_stmt|;
endif|#
directive|endif
name|nl
operator|=
name|nleft
operator|/
sizeof|sizeof
argument_list|(
name|linep
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ndeleted
condition|;
name|n
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%7d: %6o\n"
argument_list|,
name|n
operator|+
literal|1
argument_list|,
operator|*
name|bp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|nl
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HUGE
name|bp
operator|=
name|getblock
argument_list|(
name|tl
operator|+=
name|_2
index|[
name|hugef
index|]
argument_list|,
name|READ
argument_list|)
expr_stmt|;
else|#
directive|else
name|bp
operator|=
name|getblock
argument_list|(
name|tl
operator|+=
name|_2
argument_list|,
name|READ
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nl
operator|=
name|nleft
operator|/
sizeof|sizeof
argument_list|(
name|linep
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_continue
continue|continue;
end_continue

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XDEL
end_ifdef

begin_case
case|case
literal|'x'
case|:
end_case

begin_expr_stmt
name|newline
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|r
operator|=
name|undelete
argument_list|()
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_expr_stmt
operator|++
name|logstats
operator|.
name|lc_xundelete
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|prompt2
condition|)
name|printf
argument_list|(
operator|(
name|curt
condition|?
name|prcntu
else|:
name|errtext
index|[
literal|55
index|]
operator|)
argument_list|,
name|r
argument_list|,
operator|(
name|r
operator|==
literal|1
condition|?
name|null
else|:
name|quote_s
operator|)
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|text_modified
operator|++
expr_stmt|;
end_expr_stmt

begin_continue
continue|continue;
end_continue

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|YINT
end_ifdef

begin_case
case|case
literal|'y'
case|:
end_case

begin_if
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'+'
condition|)
block|{
name|setdot
argument_list|()
expr_stmt|;
name|nonzero
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
if|if
condition|(
name|zero
operator|==
name|dol
condition|)
name|yplus
operator|=
literal|0
expr_stmt|;
else|else
name|yplus
operator|=
operator|*
name|addr2
operator||
literal|01
expr_stmt|;
name|yflg
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_yplus
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
name|setnoaddr
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|yflg
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_yminus
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|setnoaddr
argument_list|()
expr_stmt|;
name|peekc
operator|=
name|c
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|yflg
operator|=
literal|1
expr_stmt|;
name|yplus
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_yintr
expr_stmt|;
endif|#
directive|endif
block|}
end_if

begin_continue
continue|continue;
end_continue

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PIPE
end_ifdef

begin_case
case|case
literal|'|'
case|:
end_case

begin_ifndef
ifndef|#
directive|ifndef
name|XED
end_ifndef

begin_if
if|if
condition|(
name|globp
condition|)
comment|/* turkeys will be turkeys */
name|errmsg
argument_list|(
literal|61
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|noshell
condition|)
name|errmsg
argument_list|(
literal|52
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'+'
condition|)
block|{
name|peekc
operator|=
literal|0
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|setnoaddr
argument_list|()
expr_stmt|;
name|strict
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_piplus
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
elseif|else
if|if
condition|(
name|peekc
operator|==
literal|'-'
condition|)
block|{
name|peekc
operator|=
literal|0
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|setnoaddr
argument_list|()
expr_stmt|;
name|strict
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_piminus
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
end_if

begin_expr_stmt
name|setdot
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|shell
argument_list|()
expr_stmt|;
end_expr_stmt

begin_continue
continue|continue;
end_continue

begin_endif
endif|#
directive|endif
end_endif

begin_case
case|case
literal|'!'
case|:
end_case

begin_ifndef
ifndef|#
directive|ifndef
name|XED
end_ifndef

begin_if
if|if
condition|(
name|globp
condition|)
name|errmsg
argument_list|(
literal|61
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|noshell
condition|)
name|errmsg
argument_list|(
literal|52
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|setnoaddr
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|shell
argument_list|()
expr_stmt|;
end_expr_stmt

begin_continue
continue|continue;
end_continue

begin_ifdef
ifdef|#
directive|ifdef
name|CKPT
end_ifdef

begin_case
case|case
literal|'z'
case|:
end_case

begin_expr_stmt
name|newline
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setnoaddr
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|checkpoint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* doesn't return */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_case
case|case
name|EOF
case|:
end_case

begin_ifdef
ifdef|#
directive|ifdef
name|USE
end_ifdef

begin_if
if|if
condition|(
operator|!
name|baseflg
operator|&&
name|alt
condition|)
block|{
name|close
argument_list|(
name|alt
argument_list|)
expr_stmt|;
name|alt
operator|=
literal|0
expr_stmt|;
name|eflg2
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return;
end_return

begin_expr_stmt
unit|}     illcmd:
name|errmsg
argument_list|(
literal|8
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* nothing lasts "for ever" */
end_comment

begin_macro
unit|}
name|compile
argument_list|(
argument|aeof
argument_list|)
end_macro

begin_decl_stmt
name|charac
name|aeof
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|charac
name|eof
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
name|lastep
decl_stmt|,
modifier|*
name|bracketp
decl_stmt|;
specifier|register
name|cclcnt
expr_stmt|;
name|char
name|bracket
index|[
name|NBRA
index|]
decl_stmt|;
name|ep
operator|=
name|expbuf
expr_stmt|;
name|lastep
operator|=
literal|0
expr_stmt|;
name|eof
operator|=
name|aeof
expr_stmt|;
name|bracketp
operator|=
name|bracket
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|eof
operator|||
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|*
name|ep
operator|==
literal|0
condition|)
name|errmsg
argument_list|(
literal|27
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|peekc
operator|=
name|c
expr_stmt|;
return|return;
block|}
name|circfl
operator|=
literal|0
expr_stmt|;
name|nbra
operator|=
literal|0
expr_stmt|;
if|if
condition|(
ifdef|#
directive|ifdef
name|DUMB
operator|!
name|dumbf
operator|&&
endif|#
directive|endif
name|c
operator|==
literal|'^'
condition|)
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|circfl
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lp_caret
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*	if (c == '*') {		/* if first = *, then quote it */
comment|/*		*ep++ = CCHR;	*/
comment|/*		*ep++ = c;	*/
comment|/*		c = 0;	*/
comment|/*	}	*/
name|peekc
operator|=
name|c
expr_stmt|;
for|for ever
block|{
if|if
condition|(
name|ep
operator|>=
operator|&
name|expbuf
index|[
name|ESIZE
operator|-
literal|2
operator|-
operator|(
name|bracketp
operator|-
name|bracket
operator|)
operator|*
literal|2
index|]
condition|)
break|break;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|eof
operator|||
name|c
operator|==
literal|'\n'
condition|)
block|{
while|while
condition|(
name|bracketp
operator|>
name|bracket
condition|)
block|{
operator|*
name|ep
operator|++
operator|=
name|CKET
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
operator|*
operator|--
name|bracketp
expr_stmt|;
block|}
operator|*
name|ep
operator|++
operator|=
name|CEOF
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|prompt2
condition|)
name|pflag
operator|++
expr_stmt|;
name|peekc
operator|=
name|c
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|c
operator|!=
literal|'*'
condition|)
name|lastep
operator|=
name|ep
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMB
if|if
condition|(
name|dumbf
operator|&&
name|c
operator|>=
literal|0
condition|)
goto|goto
name|defchar
goto|;
endif|#
directive|endif
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'('
condition|)
block|{
if|if
condition|(
name|nbra
operator|>=
name|NBRA
condition|)
block|{
name|c
operator|=
literal|44
expr_stmt|;
goto|goto
name|cerror
goto|;
block|}
operator|*
name|bracketp
operator|++
operator|=
name|nbra
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|CBRA
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|nbra
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lp_paren
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
name|bracketp
operator|<=
name|bracket
condition|)
block|{
name|c
operator|=
literal|45
expr_stmt|;
goto|goto
name|cerror
goto|;
block|}
operator|*
name|ep
operator|++
operator|=
name|CKET
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
operator|*
operator|--
name|bracketp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
literal|'1'
operator|<=
name|c
operator|&&
name|c
operator|<
literal|'1'
operator|+
name|nbra
condition|)
block|{
operator|*
name|ep
operator|++
operator|=
name|CBACK
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|c
operator|-
literal|'1'
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lp_digit
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|c
operator|=
literal|46
expr_stmt|;
goto|goto
name|cerror
goto|;
block|}
name|defchar
label|:
default|default:
operator|*
name|ep
operator|++
operator|=
name|CCHR
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
case|case
literal|'.'
case|:
operator|*
name|ep
operator|++
operator|=
name|CDOT
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lp_dot
expr_stmt|;
endif|#
directive|endif
continue|continue;
case|case
literal|'*'
case|:
if|if
condition|(
name|lastep
operator|==
literal|0
operator|||
operator|*
name|lastep
operator|==
name|CBRA
operator|||
operator|*
name|lastep
operator|==
name|CKET
condition|)
goto|goto
name|defchar
goto|;
operator|*
name|lastep
operator||=
name|STAR
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lp_star
expr_stmt|;
endif|#
directive|endif
continue|continue;
case|case
literal|'$'
case|:
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|eof
operator|&&
name|peekc
operator|!=
literal|'\n'
condition|)
goto|goto
name|defchar
goto|;
operator|*
name|ep
operator|++
operator|=
name|CDOL
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lp_dol
expr_stmt|;
endif|#
directive|endif
continue|continue;
case|case
literal|'['
case|:
operator|*
name|ep
operator|++
operator|=
name|CCL
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
literal|0
expr_stmt|;
name|cclcnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'^'
condition|)
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|ep
index|[
operator|-
literal|2
index|]
operator|=
name|NCCL
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lp_nccl
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|LOG
else|else
operator|++
name|logstats
operator|.
name|lp_ccl
expr_stmt|;
endif|#
directive|endif
do|do
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|peekc
operator|=
name|c
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
name|c
operator|=
literal|59
expr_stmt|;
goto|goto
name|cerror
goto|;
block|}
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
name|cclcnt
operator|++
expr_stmt|;
if|if
condition|(
name|ep
operator|>=
operator|&
name|expbuf
index|[
name|ESIZE
operator|-
literal|2
index|]
condition|)
block|{
name|c
operator|=
literal|49
expr_stmt|;
goto|goto
name|cerror
goto|;
block|}
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|']'
condition|)
do|;
name|lastep
index|[
literal|1
index|]
operator|=
name|cclcnt
expr_stmt|;
continue|continue;
case|case
name|EOF
case|:
name|c
operator|=
literal|59
expr_stmt|;
goto|goto
name|cerror
goto|;
block|}
block|}
name|c
operator|=
literal|42
expr_stmt|;
name|cerror
label|:
name|expbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nbra
operator|=
literal|0
expr_stmt|;
name|errmsg
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|compsub
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|charac
name|seof
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|seof
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
name|errmsg
argument_list|(
literal|40
argument_list|)
expr_stmt|;
name|compile
argument_list|(
name|seof
argument_list|)
expr_stmt|;
name|p
operator|=
name|rhsbuf
expr_stmt|;
for|for ever
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|errmsg
argument_list|(
literal|59
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|getchar
argument_list|()
operator||
literal|0200
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prompt2
condition|)
name|pflag
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|seof
condition|)
break|break;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|p
operator|>=
operator|&
name|rhsbuf
index|[
name|LBSIZE
operator|/
literal|2
operator|-
literal|2
index|]
condition|)
name|errmsg
argument_list|(
literal|41
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'g'
condition|)
block|{
comment|/* if in 'glob' */
name|peekc
operator|=
literal|0
expr_stmt|;
name|p
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|'0'
operator|<=
name|peekc
operator|&&
name|peekc
operator|<=
literal|'9'
condition|)
if|if
condition|(
operator|(
name|s_cnt
operator|=
name|getnum
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|s_cnt
operator|=
literal|0
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_macro
name|create
argument_list|(
argument|as
argument_list|,
argument|am
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|as
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|savmask
expr_stmt|;
specifier|register
name|func
name|savint
decl_stmt|,
name|savqit
decl_stmt|;
specifier|register
name|ret
expr_stmt|;
if|if
condition|(
name|am
operator|==
name|LMODE
condition|)
block|{
name|savint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|savqit
operator|=
name|signal
argument_list|(
name|SIGQIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|savmask
operator|=
name|umask
argument_list|(
name|LMASK
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|creat
argument_list|(
name|as
argument_list|,
name|am
argument_list|)
expr_stmt|;
if|if
condition|(
name|am
operator|==
name|LMODE
condition|)
block|{
name|umask
argument_list|(
name|savmask
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|savint
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQIT
argument_list|,
name|savqit
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_block

begin_macro
name|delete
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|linep
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|,
modifier|*
name|a3
decl_stmt|;
name|a1
operator|=
name|addr1
expr_stmt|;
name|a2
operator|=
name|addr2
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|XDEL
if|if
condition|(
operator|!
name|globp
condition|)
name|saveline
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|a3
operator|=
name|dol
expr_stmt|;
name|dol
operator|-=
name|a2
operator|-
name|a1
expr_stmt|;
do|do
block|{
operator|*
name|a1
operator|++
operator|=
operator|*
name|a2
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|a2
operator|<=
name|a3
condition|)
do|;
name|a1
operator|=
name|addr1
expr_stmt|;
if|if
condition|(
name|a1
operator|>
name|dol
condition|)
name|a1
operator|=
name|dol
expr_stmt|;
name|dot
operator|=
name|a1
expr_stmt|;
block|}
end_block

begin_macro
name|delexit
argument_list|(
argument|aretcode
argument_list|)
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|LOG
include|#
directive|include
file|<sys/times.h>
name|struct
name|tms
name|t
decl_stmt|;
endif|#
directive|endif
name|unlink
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
operator|(
name|io
operator|=
name|open
argument_list|(
name|LOG
argument_list|,
literal|1
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|time
argument_list|(
operator|&
name|logstats
operator|.
name|lt_end
argument_list|)
expr_stmt|;
name|times
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|logstats
operator|.
name|lt_usercpu
operator|=
name|t
operator|.
name|tms_utime
expr_stmt|;
name|logstats
operator|.
name|lt_syscpu
operator|=
name|t
operator|.
name|tms_stime
expr_stmt|;
name|logstats
operator|.
name|lt_kidscpu
operator|=
name|t
operator|.
name|tms_cutime
operator|+
name|t
operator|.
name|tms_cstime
expr_stmt|;
name|lseek
argument_list|(
name|io
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|io
argument_list|,
operator|&
name|logstats
argument_list|,
sizeof|sizeof
name|logstats
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|exit
argument_list|(
name|aretcode
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dosub
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|lp
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
specifier|register
name|charac
name|c
decl_stmt|;
name|lp
operator|=
name|linebuf
expr_stmt|;
name|sp
operator|=
name|genbuf
expr_stmt|;
name|rp
operator|=
name|rhsbuf
expr_stmt|;
while|while
condition|(
name|lp
operator|<
name|loc1
condition|)
operator|*
name|sp
operator|++
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|rp
operator|++
condition|)
block|{
ifdef|#
directive|ifdef
name|DUMB
if|if
condition|(
operator|!
name|dumbf
condition|)
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'&'
condition|)
block|{
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logamp
expr_stmt|;
endif|#
directive|endif
name|sp
operator|=
name|place
argument_list|(
name|sp
argument_list|,
name|loc1
argument_list|,
name|loc2
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0
operator|&&
operator|(
name|c
operator|&=
literal|0177
operator|)
operator|>=
literal|'1'
operator|&&
name|c
operator|<
name|nbra
operator|+
literal|'1'
condition|)
block|{
name|c
operator|-=
literal|'1'
expr_stmt|;
name|sp
operator|=
name|place
argument_list|(
name|sp
argument_list|,
name|braslist
index|[
name|c
index|]
argument_list|,
name|braelist
index|[
name|c
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|sp
operator|++
operator|=
name|c
operator|&
literal|0177
expr_stmt|;
ifndef|#
directive|ifndef
name|ALLOC
if|if
condition|(
name|sp
operator|>=
operator|&
name|genbuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
condition|)
else|#
directive|else
if|if
condition|(
name|sp
operator|>=
operator|&
name|genbuf
index|[
name|lbsize
operator|-
literal|2
index|]
condition|)
endif|#
directive|endif
name|errmsg
argument_list|(
literal|42
argument_list|)
expr_stmt|;
block|}
name|lp
operator|=
name|loc2
expr_stmt|;
name|loc2
operator|=
name|sp
operator|+
operator|(
name|linebuf
operator|-
name|genbuf
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|++
operator|=
operator|*
name|lp
operator|++
condition|)
ifndef|#
directive|ifndef
name|ALLOC
if|if
condition|(
name|sp
operator|>=
operator|&
name|genbuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
condition|)
else|#
directive|else
if|if
condition|(
name|sp
operator|>=
operator|&
name|genbuf
index|[
name|lbsize
operator|-
literal|2
index|]
condition|)
endif|#
directive|endif
name|errmsg
argument_list|(
literal|43
argument_list|)
expr_stmt|;
name|lp
operator|=
name|linebuf
expr_stmt|;
name|sp
operator|=
name|genbuf
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
operator|=
operator|*
name|sp
operator|++
condition|)
empty_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|dump
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|linep
modifier|*
name|i
decl_stmt|;
specifier|register
name|b
operator|,
name|o
expr_stmt|;
name|setdot
argument_list|()
expr_stmt|;
name|nonzero
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|line_num
operator|=
name|addr1
operator|-
name|zero
expr_stmt|;
for|for
control|(
name|i
operator|=
name|addr1
init|;
name|i
operator|<=
name|addr2
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|HUGE
name|b
operator|=
operator|(
operator|*
name|i
operator|>>
operator|(
literal|8
operator|-
name|hugef
operator|)
operator|)
operator|&
name|_3
index|[
name|hugef
index|]
expr_stmt|;
name|o
operator|=
operator|(
operator|*
name|i
operator|<<
operator|(
literal|1
operator|+
name|hugef
operator|)
operator|)
operator|&
name|_4
index|[
name|hugef
index|]
expr_stmt|;
else|#
directive|else
name|b
operator|=
operator|(
operator|*
name|i
operator|>>
literal|8
operator|)
operator|&
name|_3
expr_stmt|;
name|o
operator|=
operator|(
operator|*
name|i
operator|<<
literal|1
operator|)
operator|&
name|_4
expr_stmt|;
endif|#
directive|endif
name|printlno
argument_list|(
name|line_num
operator|++
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|pdp11
name|printf
argument_list|(
literal|"%6o:%7o%6d/%d\n"
argument_list|,
name|i
argument_list|,
operator|*
name|i
argument_list|,
name|b
argument_list|,
name|o
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%6o:%7o%6d/%d\n"
argument_list|,
name|i
argument_list|,
operator|*
name|i
operator|&
operator|(
name|unsigned
operator|)
operator|(
name|unsigned
name|short
operator|)
operator|-
literal|1
argument_list|,
name|b
argument_list|,
name|o
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|dot
operator|=
name|addr2
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|echo
argument_list|(
argument|ch
argument_list|)
end_macro

begin_decl_stmt
name|charac
name|ch
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|AGAIN
specifier|static
name|charac
name|lastchar
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE
if|if
condition|(
name|eflg
operator|||
name|alt
operator|&&
operator|!
name|eflg2
condition|)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|USE
if|if
condition|(
name|eflg
condition|)
endif|#
directive|endif
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AGAIN
if|if
condition|(
operator|!
name|agf
operator|&&
name|agp
condition|)
block|{
comment|/* save current command for "again" */
if|if
condition|(
name|agp
operator|>=
operator|&
name|agbuf
index|[
name|GBSIZE
operator|-
literal|2
index|]
condition|)
name|agp
operator|=
name|agbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|agp
operator|++
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|&&
name|lastchar
operator|!=
literal|'\\'
condition|)
name|agp
operator|=
operator|*
name|agp
operator|=
literal|0
expr_stmt|;
block|}
name|lastchar
operator|=
name|ch
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_block

begin_macro
name|errfunc
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|io
condition|)
block|{
name|close
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|io
operator|=
literal|0
expr_stmt|;
name|io_w
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|overfile
condition|)
block|{
name|chmod
argument_list|(
name|overfile
argument_list|,
name|overmode
argument_list|)
expr_stmt|;
name|overfile
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HELP
if|if
condition|(
name|doc
condition|)
block|{
name|close
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|doc
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PIPE
if|if
condition|(
name|pfile
condition|)
block|{
name|close
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|pfname
argument_list|)
expr_stmt|;
name|pfile
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*	puts("?");	*/
if|if
condition|(
operator|!
name|seekf
condition|)
name|lseek
argument_list|(
literal|0
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pflag
operator|=
literal|0
expr_stmt|;
name|listf
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PARENS
name|parenf
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STRLEN
name|quotef
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|globp
condition|)
block|{
name|lastc
operator|=
literal|'\n'
expr_stmt|;
name|globp
operator|=
literal|0
expr_stmt|;
block|}
name|peekc
operator|=
name|lastc
expr_stmt|;
name|skip_rest
argument_list|()
expr_stmt|;
name|eflg2
operator|=
literal|0
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|errmsg
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
extern|extern errno;
name|listf
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PARENS
name|parenf
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STRLEN
name|quotef
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|col
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|puts2
argument_list|(
literal|"\7******** "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|n
operator|=
operator|-
name|n
expr_stmt|;
block|}
if|if
condition|(
name|curt
condition|)
name|printf
argument_list|(
literal|"?%d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|<=
name|n
operator|&&
name|n
operator|<
name|NERR
condition|)
name|putsn
argument_list|(
name|errtext
index|[
name|n
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"bad error number: %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|error
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|execute
argument_list|(
argument|gf
argument_list|,
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|linep
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|charac
name|c
decl_stmt|;
if|if
condition|(
name|gf
condition|)
block|{
if|if
condition|(
name|circfl
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p1
operator|=
name|linebuf
expr_stmt|;
name|p2
operator|=
name|genbuf
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|++
operator|=
operator|*
name|p2
operator|++
condition|)
empty_stmt|;
name|locs
operator|=
name|p1
operator|=
name|loc2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|addr
operator|==
name|zero
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p1
operator|=
name|getline
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
name|locs
operator|=
literal|0
expr_stmt|;
block|}
name|p2
operator|=
name|expbuf
expr_stmt|;
name|c
operator|=
name|NBRA
expr_stmt|;
while|while
condition|(
operator|--
name|c
operator|>=
literal|0
condition|)
block|{
name|braslist
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
name|braelist
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|circfl
condition|)
block|{
name|loc1
operator|=
name|p1
expr_stmt|;
return|return
operator|(
name|advance
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
operator|)
return|;
block|}
comment|/* fast check for first character */
if|if
condition|(
operator|*
name|p2
operator|==
name|CCHR
condition|)
block|{
name|c
operator|=
name|p2
index|[
literal|1
index|]
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|p1
operator|!=
name|c
condition|)
continue|continue;
if|if
condition|(
name|advance
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
block|{
name|loc1
operator|=
name|p1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|*
name|p1
operator|++
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* regular algorithm */
do|do
block|{
if|if
condition|(
name|advance
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
block|{
name|loc1
operator|=
name|p1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|*
name|p1
operator|++
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|TABS
end_ifdef

begin_macro
name|exp
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|n
expr_stmt|;
specifier|register
name|linep
name|p
decl_stmt|,
modifier|*
name|a1
decl_stmt|;
name|setdot
argument_list|()
expr_stmt|;
name|nonzero
argument_list|()
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|a1
operator|=
name|addr1
init|;
name|a1
operator|<=
name|addr2
condition|;
name|a1
operator|++
control|)
block|{
name|getline
argument_list|(
operator|*
name|a1
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand
argument_list|()
condition|)
block|{
name|n
operator|++
expr_stmt|;
name|p
operator|=
operator|*
name|a1
expr_stmt|;
operator|*
name|a1
operator|=
name|putline
argument_list|()
expr_stmt|;
name|savemark
argument_list|(
name|p
argument_list|,
operator|*
name|a1
argument_list|)
expr_stmt|;
block|}
block|}
name|dot
operator|=
name|addr2
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|expand
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p2
decl_stmt|;
specifier|register
name|charac
name|c
decl_stmt|;
specifier|register
name|n
expr_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
specifier|register
name|cnt
operator|,
name|i
expr_stmt|;
specifier|register
name|flag
name|tabflg
decl_stmt|;
name|p1
operator|=
name|linebuf
expr_stmt|;
name|p2
operator|=
name|genbuf
expr_stmt|;
while|while
condition|(
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
condition|)
empty_stmt|;
name|p2
operator|=
name|linebuf
expr_stmt|;
name|p1
operator|=
name|genbuf
expr_stmt|;
name|cnt
operator|=
name|col
operator|=
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p1
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|tabc
operator|&&
name|col
operator|<
name|maxtab
condition|)
block|{
name|n
operator|=
name|col
expr_stmt|;
name|c
operator|=
name|tabfill
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|n
operator|=
name|col
expr_stmt|;
name|tabflg
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|maxtab
condition|)
block|{
if|if
condition|(
operator|(
operator|++
name|n
operator|&
literal|07
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|p2
operator|++
operator|=
name|c
expr_stmt|;
name|tabflg
operator|++
expr_stmt|;
if|if
condition|(
name|p2
operator|>=
ifndef|#
directive|ifndef
name|ALLOC
operator|&
name|linebuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
else|#
directive|else
operator|&
name|linebuf
index|[
name|lbsize
operator|-
literal|2
index|]
endif|#
directive|endif
operator|||
name|n
operator|>=
name|TABS
operator|*
name|BPW
condition|)
goto|goto
name|experr
goto|;
block|}
if|if
condition|(
name|tabs
index|[
name|n
operator|>>
name|BPWC
index|]
operator|>>
operator|(
name|n
operator|&
name|BPWM
operator|)
operator|&
literal|01
condition|)
if|if
condition|(
operator|*
name|p1
operator|==
name|tabc
operator|&&
name|n
operator|<
name|maxtab
condition|)
block|{
name|p1
operator|++
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
name|i
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|tabflg
condition|)
name|n
operator|&=
literal|07
expr_stmt|;
else|else
name|n
operator|-=
name|col
expr_stmt|;
name|col
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
operator|*
name|p2
operator|++
operator|=
literal|' '
expr_stmt|;
ifndef|#
directive|ifndef
name|ALLOC
if|if
condition|(
name|p2
operator|>=
operator|&
name|linebuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
condition|)
else|#
directive|else
if|if
condition|(
name|p2
operator|>=
operator|&
name|linebuf
index|[
name|lbsize
operator|-
literal|2
index|]
condition|)
endif|#
directive|endif
goto|goto
name|experr
goto|;
block|}
name|cnt
operator|++
expr_stmt|;
continue|continue;
block|}
do|do
block|{
operator|*
name|p2
operator|++
operator|=
name|c
expr_stmt|;
ifndef|#
directive|ifndef
name|ALLOC
if|if
condition|(
name|p2
operator|>=
operator|&
name|linebuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
else|#
directive|else
if|if
condition|(
name|p2
operator|>=
operator|&
name|linebuf
index|[
name|lbsize
operator|-
literal|2
index|]
endif|#
directive|endif
operator|||
name|n
operator|>=
name|TABS
operator|*
name|BPW
condition|)
goto|goto
name|experr
goto|;
name|n
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|tabs
index|[
name|n
operator|>>
name|BPWC
index|]
operator|>>
operator|(
name|n
operator|&
name|BPWM
operator|)
operator|&
literal|01
operator|)
condition|)
do|;
name|col
operator|=
name|n
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
literal|'\0'
operator|<
name|c
operator|&&
name|c
operator|<
literal|' '
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\b'
case|:
name|col
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|col
operator|+=
literal|7
operator|-
operator|(
name|col
operator|&
literal|07
operator|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|col
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|col
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
condition|)
block|{
operator|*
name|p2
operator|++
operator|=
name|c
expr_stmt|;
name|col
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|ALLOC
if|if
condition|(
name|p2
operator|>=
operator|&
name|linebuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
operator|||
else|#
directive|else
if|if
condition|(
name|p2
operator|>=
operator|&
name|linebuf
index|[
name|lbsize
operator|-
literal|2
index|]
operator|||
endif|#
directive|endif
name|col
operator|>=
name|TABS
operator|*
name|BPW
condition|)
name|experr
label|:
name|errmsg
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|p2
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|EXPDMP
end_ifdef

begin_macro
name|expdmp
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|n
expr_stmt|;
specifier|register
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
specifier|register
name|flag
name|star
decl_stmt|;
name|signal
argument_list|(
name|SIGQIT
argument_list|,
name|expdmp
argument_list|)
expr_stmt|;
name|ep
operator|=
name|expbuf
expr_stmt|;
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|circfl
condition|)
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ep
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
name|star
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|ep
operator|++
condition|)
block|{
case|case
name|CCHR
operator||
name|STAR
case|:
name|star
operator|++
expr_stmt|;
case|case
name|CCHR
case|:
name|putchar
argument_list|(
operator|*
name|ep
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDOT
operator||
name|STAR
case|:
name|star
operator|++
expr_stmt|;
case|case
name|CDOT
case|:
name|putchar
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDOL
case|:
name|putchar
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
break|break;
case|case
name|CEOF
case|:
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|NCCL
operator||
name|STAR
case|:
name|star
operator|++
expr_stmt|;
case|case
name|NCCL
case|:
name|n
operator|++
expr_stmt|;
goto|goto
name|ccl
goto|;
case|case
name|CCL
operator||
name|STAR
case|:
name|star
operator|++
expr_stmt|;
case|case
name|CCL
case|:
name|ccl
label|:
name|putchar
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|putchar
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|n
operator|=
operator|*
name|ep
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|n
condition|)
name|putchar
argument_list|(
operator|*
name|ep
operator|++
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
break|break;
case|case
name|CBRA
case|:
name|putchar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|ep
operator|++
expr_stmt|;
break|break;
case|case
name|CKET
case|:
name|putchar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
name|ep
operator|++
expr_stmt|;
break|break;
case|case
name|CBACK
operator||
name|STAR
case|:
name|star
operator|++
expr_stmt|;
case|case
name|CBACK
case|:
name|putchar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|ep
operator|++
operator|+
literal|'1'
argument_list|)
expr_stmt|;
break|break;
default|default:
name|putchar
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|star
condition|)
name|putchar
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|reading
condition|)
name|reset
argument_list|()
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|filename
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|charac
name|c
decl_stmt|;
name|appflg
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|errmsg
argument_list|(
literal|59
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|noname
label|:
if|if
condition|(
name|savedfile
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|errmsg
argument_list|(
literal|62
argument_list|)
expr_stmt|;
name|scopy
argument_list|(
name|savedfile
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|'>'
condition|)
name|errmsg
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|','
condition|)
name|peekc
operator|=
name|c
expr_stmt|;
name|white_space
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'>'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'>'
condition|)
empty_stmt|;
name|appflg
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
goto|goto
name|noname
goto|;
name|peekc
operator|=
name|c
expr_stmt|;
name|white_space
argument_list|()
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|errmsg
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|p1
operator|=
name|file
expr_stmt|;
do|do
block|{
operator|*
name|p1
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
operator|&
name|file
index|[
name|FNSIZE
operator|-
literal|2
index|]
condition|)
name|errmsg
argument_list|(
literal|11
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
do|;
operator|*
name|p1
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|savedfile
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|scopy
argument_list|(
name|file
argument_list|,
name|savedfile
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|linep
modifier|*
name|findmark
parameter_list|(
name|alp
parameter_list|,
name|adflt
parameter_list|)
name|linep
name|alp
decl_stmt|,
decl|*
name|adflt
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|linep
modifier|*
name|a
decl_stmt|,
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|HUGE
specifier|register
name|i
expr_stmt|;
name|i
operator|=
name|hugef
operator|^
literal|01
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|alp
expr_stmt|;
for|for
control|(
name|a
operator|=
name|zero
operator|+
literal|1
init|;
name|a
operator|<=
name|dol
condition|;
name|a
operator|++
control|)
if|if
condition|(
name|v
operator|==
operator|(
operator|*
name|a
operator||
ifdef|#
directive|ifdef
name|HUGE
name|i
else|#
directive|else
literal|1
endif|#
directive|endif
operator|)
condition|)
return|return
operator|(
name|a
operator|)
return|;
return|return
operator|(
name|adflt
operator|)
return|;
block|}
end_block

begin_macro
name|flush_buf
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|=
name|linp
operator|-
name|line
condition|)
block|{
name|linp
operator|=
name|line
expr_stmt|;
name|write
argument_list|(
name|fout
argument_list|,
name|line
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|G_VFY
end_ifdef

begin_macro
name|gask
argument_list|(
argument|a1
argument_list|)
end_macro

begin_decl_stmt
name|linep
modifier|*
name|a1
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|charac
name|c
decl_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
name|printlno
argument_list|(
name|line_num
operator|=
name|a1
operator|-
name|zero
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
literal|"Ok? "
argument_list|)
expr_stmt|;
name|flush_buf
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|skip_rest
argument_list|()
expr_stmt|;
return|return
operator|(
name|c
operator|!=
literal|'n'
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
name|getblock
parameter_list|(
name|atl
parameter_list|,
name|iof
parameter_list|)
block|{
extern|extern read(
block|)
operator|,
function|write
parameter_list|()
function|;
end_function

begin_expr_stmt
specifier|register
name|bno
operator|,
name|off
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|linep
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HUGE
end_ifdef

begin_decl_stmt
specifier|register
name|flag
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|func
name|savint
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|bno
operator|=
operator|(
name|atl
operator|>>
operator|(
literal|8
operator|-
name|hugef
operator|)
operator|)
operator|&
name|_3
index|[
name|hugef
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|off
operator|=
operator|(
name|atl
operator|<<
operator|(
literal|1
operator|+
name|hugef
operator|)
operator|)
operator|&
name|_4
index|[
name|hugef
index|]
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|bno
operator|=
operator|(
name|atl
operator|>>
literal|8
operator|)
operator|&
name|_3
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|off
operator|=
operator|(
name|atl
operator|<<
literal|1
operator|)
operator|&
name|_4
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|bno
operator|>=
ifdef|#
directive|ifdef
name|HUGE
name|_5
index|[
name|hugef
index|]
else|#
directive|else
name|_5
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|HUGE
if|if
condition|(
operator|!
name|hugef
operator|&&
operator|!
name|globp
condition|)
block|{
comment|/* let's try converting to huge */
if|if
condition|(
operator|!
name|curt
condition|)
block|{
name|putsn
argument_list|(
literal|"File too large for normal editing."
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
literal|"Conversion to \"huge\" mode disallows "
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
literal|"use of the global command."
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|yes_no
argument_list|(
name|curt
condition|?
literal|"?huge"
else|:
literal|"Do you wish to convert"
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
name|savint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|zero
operator|+
literal|1
init|;
name|a
operator|<=
name|dol
condition|;
name|a
operator|++
control|)
operator|*
name|a
operator|=
operator|(
operator|(
name|unsigned
operator|)
operator|*
name|a
operator|)
operator|>>
literal|1
expr_stmt|;
name|hugef
operator|++
expr_stmt|;
name|hugef2
operator|++
expr_stmt|;
comment|/* conversion occurred */
name|atl
operator|=
operator|(
name|atl
operator|>>
literal|1
operator|)
operator|&
name|_6
index|[
name|hugef
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|XDEL
name|ndeleted
operator|=
literal|0
expr_stmt|;
comment|/* useless pointers */
name|deleted
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|savint
argument_list|)
expr_stmt|;
goto|goto
name|huger
goto|;
block|}
block|}
endif|#
directive|endif
name|errmsg
argument_list|(
literal|34
argument_list|)
expr_stmt|;
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HUGE
end_ifdef

begin_label
name|huger
label|:
end_label

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|nleft
operator|=
name|BLKSIZE
operator|-
name|off
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|bno
operator|==
name|iblock
operator|&&
operator|!
name|badf
condition|)
block|{
name|ichanged
operator||=
name|iof
expr_stmt|;
return|return
operator|(
name|ibuff
operator|+
name|off
operator|)
return|;
block|}
end_if

begin_if
if|if
condition|(
name|bno
operator|==
name|oblock
condition|)
return|return
operator|(
name|obuff
operator|+
name|off
operator|)
return|;
end_if

begin_if
if|if
condition|(
name|iof
operator|==
name|READ
condition|)
block|{
if|if
condition|(
name|ichanged
condition|)
block|{
name|blkio
argument_list|(
name|iblock
argument_list|,
name|ibuff
argument_list|,
name|write
argument_list|)
expr_stmt|;
name|ichanged
operator|=
literal|0
expr_stmt|;
block|}
name|iblock
operator|=
name|bno
expr_stmt|;
name|blkio
argument_list|(
name|bno
argument_list|,
name|ibuff
argument_list|,
name|read
argument_list|)
expr_stmt|;
return|return
operator|(
name|ibuff
operator|+
name|off
operator|)
return|;
block|}
end_if

begin_if
if|if
condition|(
name|oblock
operator|>=
literal|0
condition|)
name|blkio
argument_list|(
name|oblock
argument_list|,
name|obuff
argument_list|,
name|write
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|oblock
operator|=
name|bno
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|obuff
operator|+
name|off
operator|)
return|;
end_return

begin_macro
unit|}  charac
name|getchar
argument_list|()
end_macro

begin_block
block|{
name|flush_buf
argument_list|()
expr_stmt|;
name|eof
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lastc
operator|=
name|peekc
condition|)
block|{
name|peekc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|lastc
operator|)
return|;
block|}
if|if
condition|(
name|globp
condition|)
block|{
if|if
condition|(
name|lastc
operator|=
operator|*
name|globp
operator|++
condition|)
block|{
if|if
condition|(
name|globf2
operator|&&
operator|*
name|globp
operator|==
literal|0
condition|)
name|globp
operator|=
name|globf2
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|lastc
operator|)
return|;
block|}
name|globp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EOF
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|AGAIN
if|if
condition|(
name|agf
ifdef|#
directive|ifdef
name|USE
operator|&&
operator|!
name|alt
endif|#
directive|endif
condition|)
block|{
comment|/* "again" stuff */
if|if
condition|(
name|lastc
operator|=
operator|*
name|agp
operator|++
condition|)
return|return
operator|(
name|lastc
operator|)
return|;
name|agf
operator|=
name|agp
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|reading
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|USE
if|if
condition|(
name|read
argument_list|(
name|alt
argument_list|,
operator|&
name|lastc
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
block|{
endif|#
directive|endif
ifndef|#
directive|ifndef
name|USE
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|lastc
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
block|{
endif|#
directive|endif
name|reading
operator|=
literal|0
expr_stmt|;
name|eof
operator|++
expr_stmt|;
return|return
operator|(
name|lastc
operator|=
name|EOF
operator|)
return|;
block|}
name|reading
operator|=
literal|0
expr_stmt|;
name|lastc
operator|&=
literal|0177
expr_stmt|;
ifdef|#
directive|ifdef
name|APLMAP
if|if
condition|(
name|aplmap
operator|&&
name|lastc
operator|>
literal|' '
condition|)
name|lastc
operator|=
name|map_ascii
index|[
name|lastc
operator|-
operator|(
literal|' '
operator|+
literal|1
operator|)
index|]
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EOL
if|if
condition|(
name|lastc
operator|==
literal|'\n'
condition|)
name|prompt3
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|eol
operator|&&
name|lastc
operator|==
name|eol
condition|)
block|{
name|lastc
operator|=
literal|'\n'
expr_stmt|;
name|prompt3
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CMDS
if|if
condition|(
name|cmd
condition|)
name|write
argument_list|(
name|cmd
argument_list|,
operator|&
name|lastc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|eof
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|echo
argument_list|(
name|lastc
argument_list|)
operator|)
return|;
block|}
name|getcopy
argument_list|()
block|{
if|if
condition|(
name|addr1
operator|>
name|addr2
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
name|getline
argument_list|(
operator|*
name|addr1
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|getfile
argument_list|()
block|{
specifier|register
name|charac
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|lp
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
name|lp
operator|=
name|linebuf
expr_stmt|;
name|fp
operator|=
name|nextip
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|--
name|ninbuf
operator|<
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|ALLOC
if|if
condition|(
operator|(
name|ninbuf
operator|=
name|read
argument_list|(
name|io
argument_list|,
name|genbuf
argument_list|,
name|LBSIZE
argument_list|)
operator|-
literal|1
operator|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|ninbuf
operator|=
name|read
argument_list|(
name|io
argument_list|,
name|genbuf
argument_list|,
name|lbsize
argument_list|)
operator|-
literal|1
operator|)
operator|<
literal|0
condition|)
endif|#
directive|endif
if|if
condition|(
name|lp
operator|==
name|linebuf
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
else|else
block|{
name|lp
operator|++
expr_stmt|;
break|break;
block|}
name|fp
operator|=
name|genbuf
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|ALLOC
if|if
condition|(
name|lp
operator|>=
operator|&
name|linebuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
operator|&&
operator|(
operator|*
name|fp
operator|&
literal|0177
operator|)
operator|!=
literal|'\n'
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|lp
operator|>=
operator|&
name|linebuf
index|[
name|lbsize
operator|-
literal|2
index|]
operator|&&
operator|(
operator|*
name|fp
operator|&
literal|0177
operator|)
operator|!=
literal|'\n'
condition|)
block|{
endif|#
directive|endif
name|printf
argument_list|(
operator|(
name|curt
condition|?
literal|"?long%u\n"
else|:
literal|"line %u in file too long\n"
operator|)
argument_list|,
name|dot
operator|-
name|zero
operator|+
literal|1
argument_list|)
expr_stmt|;
name|flush_buf
argument_list|()
expr_stmt|;
name|lp
operator|++
expr_stmt|;
name|ninbuf
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|*
name|lp
operator|++
operator|=
name|c
operator|=
operator|*
name|fp
operator|++
operator|&
literal|0177
operator|)
operator|==
literal|0
condition|)
block|{
name|lp
operator|--
expr_stmt|;
continue|continue;
block|}
block|}
while|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
operator|*
operator|--
name|lp
operator|=
literal|0
expr_stmt|;
name|nextip
operator|=
name|fp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
do|getline(tl
block|)
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
specifier|register
name|nl
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tflg
condition|)
name|printf
argument_list|(
literal|"getline:\t%o\n"
argument_list|,
name|tl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lp
operator|=
name|linebuf
expr_stmt|;
name|bp
operator|=
name|getblock
argument_list|(
name|tl
argument_list|,
name|READ
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HUGE
if|if
condition|(
name|hugef2
condition|)
block|{
name|hugef2
operator|=
literal|0
expr_stmt|;
name|tl
operator|=
operator|(
name|tl
operator|>>
literal|1
operator|)
operator|&
name|_6
index|[
name|hugef
index|]
expr_stmt|;
block|}
name|tl
operator|&=
name|_1
index|[
name|hugef
index|]
expr_stmt|;
else|#
directive|else
name|tl
operator|&=
name|_1
expr_stmt|;
endif|#
directive|endif
name|nl
operator|=
name|nleft
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
operator|=
operator|*
name|bp
operator|++
condition|)
if|if
condition|(
operator|--
name|nl
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HUGE
name|bp
operator|=
name|getblock
argument_list|(
name|tl
operator|+=
name|_2
index|[
name|hugef
index|]
argument_list|,
name|READ
argument_list|)
expr_stmt|;
else|#
directive|else
name|bp
operator|=
name|getblock
argument_list|(
name|tl
operator|+=
name|_2
argument_list|,
name|READ
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nl
operator|=
name|nleft
expr_stmt|;
block|}
return|return
operator|(
name|linebuf
operator|)
return|;
block|}
name|getnum
argument_list|()
block|{
specifier|register
name|n
expr_stmt|;
specifier|register
name|charac
name|c
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|'0'
operator|<=
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|peekc
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
name|getsnum
argument_list|()
block|{
specifier|register
name|sign
expr_stmt|;
if|if
condition|(
name|sign
operator|=
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'-'
condition|)
name|peekc
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|sign
condition|?
operator|-
name|getnum
argument_list|()
else|:
name|getnum
argument_list|()
operator|)
return|;
block|}
name|getsub
argument_list|()
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|p1
operator|=
name|linebuf
expr_stmt|;
if|if
condition|(
operator|(
name|p2
operator|=
name|linebp
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
while|while
condition|(
operator|*
name|p1
operator|++
operator|=
operator|*
name|p2
operator|++
condition|)
empty_stmt|;
name|linebp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|gettty
argument_list|(
argument|single
argument_list|)
block|{
specifier|register
name|charac
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|gf
decl_stmt|;
ifdef|#
directive|ifdef
name|TABS
name|int
name|tabf
decl_stmt|;
name|tabf
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|linebuf
expr_stmt|;
name|gf
operator|=
name|globp
expr_stmt|;
ifdef|#
directive|ifdef
name|EOL
if|if
condition|(
name|prompt2
operator|&&
name|prompt3
operator|&&
operator|!
name|single
condition|)
block|{
endif|#
directive|endif
ifndef|#
directive|ifndef
name|EOL
if|if
condition|(
name|prompt2
operator|&&
operator|!
name|single
condition|)
block|{
endif|#
directive|endif
name|printlno
argument_list|(
name|line_num
argument_list|)
expr_stmt|;
name|flush_buf
argument_list|()
expr_stmt|;
block|}
name|line_num
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|gf
condition|)
name|peekc
operator|=
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|prompt2
operator|&&
operator|(
name|prompt1
operator|||
operator|!
name|zflg
operator|)
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|linebuf
condition|)
break|break;
return|return
operator|(
name|c
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|c
operator|&=
literal|0177
operator|)
operator|==
literal|0
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|TABS
if|if
condition|(
name|tabc
operator|&&
name|c
operator|==
name|tabc
condition|)
name|tabf
operator|++
expr_stmt|;
endif|#
directive|endif
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
ifndef|#
directive|ifndef
name|ALLOC
if|if
condition|(
name|p
operator|>=
operator|&
name|linebuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
condition|)
else|#
directive|else
if|if
condition|(
name|p
operator|>=
operator|&
name|linebuf
index|[
name|lbsize
operator|-
literal|2
index|]
condition|)
endif|#
directive|endif
name|errmsg
argument_list|(
literal|30
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TABS
if|if
condition|(
name|tabf
condition|)
name|expand
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|single
operator|&&
name|linebuf
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|linebuf
index|[
literal|1
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|global
argument_list|(
argument|k
argument_list|)
block|{
specifier|register
name|char
modifier|*
name|gp
decl_stmt|;
specifier|register
name|charac
name|c
decl_stmt|;
specifier|register
name|linep
modifier|*
name|a1
decl_stmt|;
specifier|register
name|flag
name|globpf
decl_stmt|;
name|char
name|globuf
index|[
name|GBSIZE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|HUGE
if|if
condition|(
name|hugef
condition|)
name|errmsg
argument_list|(
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|globp
condition|)
name|errmsg
argument_list|(
literal|37
argument_list|)
expr_stmt|;
name|setall
argument_list|()
expr_stmt|;
name|nonzero
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
name|peekc
operator|=
name|c
expr_stmt|;
name|compile
argument_list|(
name|c
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|G_VFY
name|gaskf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'v'
condition|)
block|{
name|gaskf
operator|++
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|globpf
operator|=
name|pflag
expr_stmt|;
if|if
condition|(
name|peekc
operator|==
literal|'\n'
condition|)
name|globpf
operator|=
literal|0
expr_stmt|;
name|pflag
operator|=
literal|0
expr_stmt|;
name|gp
operator|=
name|globuf
expr_stmt|;
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|errmsg
argument_list|(
literal|59
argument_list|)
expr_stmt|;
if|if
condition|(
name|peekc
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|gp
operator|++
operator|=
literal|'p'
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
operator|*
name|gp
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|errmsg
argument_list|(
literal|59
argument_list|)
expr_stmt|;
operator|*
name|gp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|gp
operator|>=
operator|&
name|globuf
index|[
name|GBSIZE
operator|-
literal|2
index|]
condition|)
name|errmsg
argument_list|(
literal|38
argument_list|)
expr_stmt|;
block|}
operator|*
name|gp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|gp
operator|=
literal|0
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
ifdef|#
directive|ifdef
name|G_VFY
if|if
condition|(
name|gaskf
condition|)
operator|++
name|logstats
operator|.
name|lc_gvfy
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|k
condition|)
operator|++
name|logstats
operator|.
name|lc_global
expr_stmt|;
else|else
operator|++
name|logstats
operator|.
name|lc_vglobal
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|a1
operator|=
name|zero
operator|+
literal|1
init|;
name|a1
operator|<=
name|dol
condition|;
name|a1
operator|++
control|)
block|{
operator|*
name|a1
operator|&=
operator|~
literal|01
expr_stmt|;
name|s_tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|a1
operator|>=
name|addr1
operator|&&
name|a1
operator|<=
name|addr2
operator|&&
name|execute
argument_list|(
literal|0
argument_list|,
name|a1
argument_list|)
operator|==
name|k
condition|)
ifdef|#
directive|ifdef
name|G_VFY
if|if
condition|(
operator|!
name|gaskf
operator|||
operator|(
name|c
operator|=
name|gask
argument_list|(
name|a1
argument_list|)
operator|)
condition|)
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|addr2
operator|=
name|a1
expr_stmt|;
else|else
endif|#
directive|endif
operator|*
name|a1
operator||=
literal|01
expr_stmt|;
block|}
for|for
control|(
name|a1
operator|=
name|zero
operator|+
literal|1
init|;
name|a1
operator|<=
name|dol
condition|;
name|a1
operator|++
control|)
if|if
condition|(
operator|*
name|a1
operator|&
literal|01
condition|)
block|{
operator|*
name|a1
operator|&=
operator|~
literal|01
expr_stmt|;
name|dot
operator|=
name|a1
expr_stmt|;
name|globp
operator|=
name|globuf
expr_stmt|;
name|pflag
operator|=
name|globpf
expr_stmt|;
name|commands
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|a1
operator|=
name|zero
expr_stmt|;
block|}
block|}
name|hangup
argument_list|()
block|{
name|signal
argument_list|(
name|SIGHUP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reading
condition|)
block|{
name|backup
argument_list|(
name|HUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|fout
operator|!=
literal|1
condition|)
block|{
name|flush_buf
argument_list|()
expr_stmt|;
name|fout
operator|=
literal|1
expr_stmt|;
block|}
name|puts2
argument_list|(
name|errtext
index|[
literal|57
index|]
argument_list|)
expr_stmt|;
name|delexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hupflag
operator|++
expr_stmt|;
block|}
name|header
argument_list|()
block|{
specifier|register
name|colnum
operator|,
name|number
expr_stmt|;
specifier|register
name|flag
name|lf
decl_stmt|;
name|number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
block|{
name|white_space
argument_list|()
expr_stmt|;
name|number
operator|=
name|getnum
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|number
condition|)
name|number
operator|=
name|ccount
operator|-
operator|(
name|prompt1
condition|?
literal|8
else|:
literal|0
operator|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
if|if
condition|(
name|zero
operator|!=
name|dol
condition|)
name|dot
operator|=
name|addr2
expr_stmt|;
name|lf
operator|=
name|listf
expr_stmt|;
name|listf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prompt1
condition|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
for|for
control|(
name|colnum
operator|=
literal|0
init|;
name|colnum
operator|<
name|number
operator|/
literal|10
condition|;
name|colnum
operator|++
control|)
name|printf
argument_list|(
literal|"%10d"
argument_list|,
name|colnum
operator|+
literal|1
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|prompt1
condition|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
for|for
control|(
name|colnum
operator|=
literal|1
init|;
name|colnum
operator|<=
name|number
condition|;
name|colnum
operator|++
control|)
ifdef|#
directive|ifdef
name|TABS
if|if
condition|(
name|colnum
operator|<
operator|(
name|TABS
operator|<<
name|BPWC
operator|)
operator|&&
operator|(
name|tabs
index|[
operator|(
name|colnum
operator|-
literal|1
operator|)
operator|>>
name|BPWC
index|]
operator|>>
operator|(
operator|(
name|colnum
operator|-
literal|1
operator|)
operator|&
name|BPWM
operator|)
operator|&
literal|01
operator|)
condition|)
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|putchar
argument_list|(
name|colnum
operator|%
literal|10
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|listf
operator|=
name|lf
expr_stmt|;
block|}
name|init
argument_list|()
block|{
specifier|register
name|n
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|tfile
operator|>
literal|0
condition|)
name|close
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
condition|)
block|{
name|close
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|io
operator|=
literal|0
expr_stmt|;
name|io_w
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HELP
if|if
condition|(
name|doc
condition|)
block|{
name|close
argument_list|(
name|doc
argument_list|)
expr_stmt|;
name|doc
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE
if|if
condition|(
name|alt
condition|)
block|{
name|close
argument_list|(
name|alt
argument_list|)
expr_stmt|;
name|alt
operator|=
literal|0
expr_stmt|;
name|eflg2
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PIPE
if|if
condition|(
name|pfile
condition|)
block|{
name|close
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|pfname
argument_list|)
expr_stmt|;
name|pfile
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|tline
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|XDEL
name|deleted
operator|=
literal|0
expr_stmt|;
name|ndeleted
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|num_reads
operator|=
literal|0
expr_stmt|;
name|text_modified
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|YINT
name|yplus
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UNDO
name|undo_oldp
operator|=
literal|0
expr_stmt|;
name|undo_newp
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|V7
if|if
condition|(
name|overfile
condition|)
block|{
name|chmod
argument_list|(
name|overfile
argument_list|,
name|overmode
argument_list|)
expr_stmt|;
name|overfile
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|iblock
operator|=
name|oblock
operator|=
operator|-
literal|1
expr_stmt|;
name|badf
operator|=
literal|0
expr_stmt|;
name|ichanged
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|create
argument_list|(
name|tfname
argument_list|,
name|LMODE
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|putsn
argument_list|(
name|errtext
index|[
literal|50
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tfile
operator|=
name|open
argument_list|(
name|tfname
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|putsn
argument_list|(
name|errtext
index|[
literal|36
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|addr1
operator|=
name|addr2
operator|=
name|dot
operator|=
name|dotdot
operator|=
name|lastdot
operator|=
name|zero
operator|=
name|dol
operator|=
name|fendcore
expr_stmt|;
name|endcore
operator|=
name|fendcore
operator|-
literal|2
expr_stmt|;
name|brk
argument_list|(
name|fendcore
argument_list|)
expr_stmt|;
name|n
operator|=
literal|26
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
comment|/* kill marks */
name|names
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTMARK
name|names2
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|p
operator|=
name|globp
expr_stmt|;
name|globp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chk
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|io
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|io
operator|=
literal|0
expr_stmt|;
name|lastc
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|curt
condition|)
name|putsn
argument_list|(
literal|"?53"
argument_list|)
expr_stmt|;
else|else
block|{
name|puts2
argument_list|(
name|errtext
index|[
literal|53
index|]
argument_list|)
expr_stmt|;
name|putsn
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|flush_buf
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|append
argument_list|(
name|getfile
argument_list|,
name|addr1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|prompt2
condition|)
name|printf
argument_list|(
operator|(
name|curt
condition|?
name|prcntu
else|:
name|errtext
index|[
literal|55
index|]
operator|)
argument_list|,
name|n
argument_list|,
operator|(
name|n
operator|==
literal|1
condition|?
name|null
else|:
name|quote_s
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|num_reads
operator|++
expr_stmt|;
name|text_modified
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|io
condition|)
block|{
name|close
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|io
operator|=
literal|0
expr_stmt|;
name|io_w
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|globp
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|istty
argument_list|(
argument|fd
argument_list|)
block|{
specifier|register
name|r
expr_stmt|;
name|short
name|buf
index|[
literal|3
index|]
decl_stmt|;
comment|/* naughty int's */
name|buf
index|[
literal|2
index|]
operator|=
name|BS1
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gtty
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|)
operator|>=
literal|0
condition|)
operator|++
name|r
expr_stmt|;
ifdef|#
directive|ifdef
name|CLEAR
name|zflg
operator|=
operator|(
name|buf
index|[
literal|2
index|]
operator|&
name|BS1
operator|)
operator|==
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pipef
ifdef|#
directive|ifdef
name|V7
operator|||
name|getenv
argument_list|(
literal|"_NO_STDIO_BUF"
argument_list|)
endif|#
directive|endif
condition|)
operator|++
name|r
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|XED
name|join
argument_list|()
block|{
specifier|register
name|linep
modifier|*
name|a1
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|charac
name|c
decl_stmt|,
name|ceof
decl_stmt|;
name|setdot
argument_list|()
expr_stmt|;
name|nonzero
argument_list|()
expr_stmt|;
if|if
condition|(
name|addr1
operator|==
name|addr2
condition|)
operator|--
name|addr1
expr_stmt|;
if|if
condition|(
name|addr1
operator|<=
name|zero
condition|)
name|errmsg
argument_list|(
literal|60
argument_list|)
expr_stmt|;
name|p2
operator|=
name|rhsbuf
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|errmsg
argument_list|(
literal|59
argument_list|)
expr_stmt|;
name|ceof
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|peekc
operator|!=
literal|'\n'
operator|&&
name|peekc
operator|!=
literal|'p'
operator|&&
name|peekc
operator|!=
literal|'l'
ifdef|#
directive|ifdef
name|PARENS
operator|&&
name|peekc
operator|!=
literal|'b'
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STRLEN
operator|&&
name|peekc
operator|!=
literal|'q'
endif|#
directive|endif
condition|)
block|{
name|ceof
operator|=
name|peekc
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|ceof
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|errmsg
argument_list|(
literal|59
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
name|errmsg
argument_list|(
literal|46
argument_list|)
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|p2
operator|>=
operator|&
name|rhsbuf
index|[
name|LBSIZE
operator|/
literal|2
operator|-
literal|2
index|]
condition|)
name|errmsg
argument_list|(
literal|42
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|c
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
name|prompt2
condition|)
name|pflag
operator|++
expr_stmt|;
if|if
condition|(
name|p2
operator|!=
name|rhsbuf
condition|)
operator|*
name|p2
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|rhsbuf
operator|==
literal|0
condition|)
name|errmsg
argument_list|(
literal|27
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_jglue
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|LOG
else|else
operator|++
name|logstats
operator|.
name|lc_join
expr_stmt|;
endif|#
directive|endif
name|peekc
operator|=
name|c
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
name|p1
operator|=
name|rhsbuf
expr_stmt|;
while|while
condition|(
operator|*
name|p1
condition|)
if|if
condition|(
operator|*
name|p1
operator|++
operator|==
literal|'\n'
condition|)
name|errmsg
argument_list|(
literal|46
argument_list|)
expr_stmt|;
name|p2
operator|=
name|genbuf
expr_stmt|;
name|a1
operator|=
name|addr1
expr_stmt|;
while|while
condition|(
name|a1
operator|<=
name|addr2
condition|)
block|{
name|p1
operator|=
name|getline
argument_list|(
operator|*
name|a1
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
condition|)
ifndef|#
directive|ifndef
name|ALLOC
if|if
condition|(
name|p2
operator|>=
operator|&
name|genbuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
condition|)
else|#
directive|else
if|if
condition|(
name|p2
operator|>=
operator|&
name|genbuf
index|[
name|lbsize
operator|-
literal|2
index|]
condition|)
endif|#
directive|endif
name|errmsg
argument_list|(
literal|12
argument_list|)
expr_stmt|;
operator|--
name|p2
expr_stmt|;
if|if
condition|(
name|ceof
operator|&&
name|a1
operator|<=
name|addr2
condition|)
block|{
name|p1
operator|=
name|rhsbuf
expr_stmt|;
while|while
condition|(
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
condition|)
ifndef|#
directive|ifndef
name|ALLOC
if|if
condition|(
name|p2
operator|>=
operator|&
name|genbuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
condition|)
else|#
directive|else
if|if
condition|(
name|p2
operator|>=
operator|&
name|genbuf
index|[
name|lbsize
operator|-
literal|2
index|]
condition|)
endif|#
directive|endif
name|errmsg
argument_list|(
literal|12
argument_list|)
expr_stmt|;
operator|--
name|p2
expr_stmt|;
block|}
block|}
operator|*
name|p2
operator|=
literal|'\0'
expr_stmt|;
name|p1
operator|=
name|genbuf
expr_stmt|;
name|p2
operator|=
name|linebuf
expr_stmt|;
while|while
condition|(
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
condition|)
empty_stmt|;
name|a1
operator|=
name|putline
argument_list|()
expr_stmt|;
name|savemark
argument_list|(
operator|*
name|addr1
argument_list|,
name|a1
argument_list|)
expr_stmt|;
operator|*
name|addr1
operator|++
operator|=
name|a1
expr_stmt|;
name|delete
argument_list|()
expr_stmt|;
name|dot
operator|=
operator|--
name|addr1
expr_stmt|;
if|if
condition|(
name|dot
operator|>
name|dol
condition|)
name|dot
operator|=
name|dol
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TABS
name|listabs
argument_list|()
block|{
specifier|register
name|n
expr_stmt|;
if|if
condition|(
name|maxtab
operator|<
literal|0
condition|)
name|errmsg
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|n
operator|=
name|next_tab
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"tabs: %d"
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|next_tab
argument_list|(
name|n
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|",%d"
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mail
argument_list|()
block|{
name|delexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|move
argument_list|(
argument|cflag
argument_list|)
block|{
extern|extern getcopy(
block|)
empty_stmt|;
specifier|register
name|linep
modifier|*
name|adt
decl_stmt|,
modifier|*
name|ad1
decl_stmt|,
modifier|*
name|ad2
decl_stmt|;
name|setdot
argument_list|()
expr_stmt|;
name|nonzero
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|adt
operator|=
name|address
argument_list|()
operator|)
operator|==
literal|0
condition|)
name|errmsg
argument_list|(
literal|31
argument_list|)
expr_stmt|;
name|ad1
operator|=
name|addr1
expr_stmt|;
name|ad2
operator|=
name|addr2
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
if|if
condition|(
name|cflag
condition|)
block|{
name|ad1
operator|=
name|dol
expr_stmt|;
name|append
argument_list|(
name|getcopy
argument_list|,
name|ad1
operator|++
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ad2
operator|=
name|dol
expr_stmt|;
block|}
name|ad2
operator|++
expr_stmt|;
if|if
condition|(
name|adt
operator|<
name|ad1
condition|)
block|{
name|dot
operator|=
name|adt
operator|+
operator|(
name|ad2
operator|-
name|ad1
operator|)
expr_stmt|;
if|if
condition|(
operator|++
name|adt
operator|==
name|ad1
condition|)
return|return;
name|reverse
argument_list|(
name|adt
argument_list|,
name|ad1
argument_list|)
expr_stmt|;
name|reverse
argument_list|(
name|ad1
argument_list|,
name|ad2
argument_list|)
expr_stmt|;
name|reverse
argument_list|(
name|adt
argument_list|,
name|ad2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adt
operator|>=
name|ad2
condition|)
block|{
name|dot
operator|=
name|adt
operator|++
expr_stmt|;
name|reverse
argument_list|(
name|ad1
argument_list|,
name|ad2
argument_list|)
expr_stmt|;
name|reverse
argument_list|(
name|ad2
argument_list|,
name|adt
argument_list|)
expr_stmt|;
name|reverse
argument_list|(
name|ad1
argument_list|,
name|adt
argument_list|)
expr_stmt|;
block|}
else|else
name|errmsg
argument_list|(
literal|28
argument_list|)
expr_stmt|;
block|}
name|newline
argument_list|()
block|{
specifier|register
name|charac
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
return|return;
if|if
condition|(
name|c
operator|==
literal|'p'
operator|||
name|c
operator|==
literal|'l'
ifdef|#
directive|ifdef
name|PARENS
operator|||
name|c
operator|==
literal|'b'
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STRLEN
operator|||
name|c
operator|==
literal|'q'
endif|#
directive|endif
condition|)
block|{
name|pflag
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'l'
condition|)
name|listf
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|PARENS
elseif|else
if|if
condition|(
name|c
operator|==
literal|'b'
condition|)
name|parenf
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STRLEN
elseif|else
if|if
condition|(
name|c
operator|==
literal|'q'
condition|)
name|quotef
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|getchar
argument_list|()
operator|==
literal|'\n'
condition|)
return|return;
block|}
name|errmsg
argument_list|(
literal|25
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TABS
name|next_tab
argument_list|(
argument|acol
argument_list|)
block|{
specifier|register
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|acol
operator|)
operator|<
name|maxtab
condition|)
block|{
do|do
block|{
name|n
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|tabs
index|[
name|n
operator|>>
name|BPWC
index|]
operator|>>
operator|(
name|n
operator|&
name|BPWM
operator|)
operator|&
literal|01
operator|)
condition|)
do|;
return|return
operator|(
name|n
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
name|nonzero
argument_list|()
block|{
if|if
condition|(
name|addr1
operator|<=
name|zero
condition|)
name|errmsg
argument_list|(
literal|23
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr2
operator|>
name|dol
condition|)
name|errmsg
argument_list|(
literal|24
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PIPE
name|oil_spilled
argument_list|()
block|{
if|if
condition|(
operator|!
name|iflg
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGPIP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|piperr
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|onintr
argument_list|()
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE
if|if
condition|(
name|alt
condition|)
block|{
name|close
argument_list|(
name|alt
argument_list|)
expr_stmt|;
name|alt
operator|=
literal|0
expr_stmt|;
name|eflg2
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|io
condition|)
block|{
if|if
condition|(
name|curt
condition|)
name|putsn
argument_list|(
literal|"?intI/O"
argument_list|)
expr_stmt|;
else|else
block|{
name|puts2
argument_list|(
literal|"\7Interrupted I/O!!!\7\nWarning: \""
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_w
condition|)
block|{
name|putsn
argument_list|(
literal|"\" is probably truncated."
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
literal|"You should probably re-write it."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putsn
argument_list|(
literal|"\" was not read entirely."
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
literal|"If you write the buffer, "
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
literal|"part of the file may be lost."
argument_list|)
expr_stmt|;
block|}
block|}
name|flush_buf
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EOL
name|prompt3
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fout
operator|!=
literal|1
condition|)
block|{
name|close
argument_list|(
name|fout
argument_list|)
expr_stmt|;
name|fout
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|YINT
if|if
condition|(
operator|!
name|globp
operator|&&
name|reading
operator|&&
name|yflg
condition|)
block|{
name|globp
operator|=
literal|".:\n"
expr_stmt|;
if|if
condition|(
name|yplus
condition|)
block|{
name|dot
operator|=
name|findmark
argument_list|(
name|yplus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|globp
operator|++
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|commands
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|iflg
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|backup
argument_list|(
name|INT
argument_list|)
expr_stmt|;
name|delexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
name|lastc
operator|=
literal|'\n'
argument_list|)
expr_stmt|;
name|errmsg
argument_list|(
literal|29
argument_list|)
expr_stmt|;
block|}
name|override
argument_list|()
block|{
name|struct
name|stat
name|s
decl_stmt|;
if|if
condition|(
name|access
argument_list|(
name|file
argument_list|,
literal|02
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|s
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|s
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
condition|)
block|{
name|overmode
operator|=
name|s
operator|.
name|st_mode
operator|&
literal|07777
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|file
argument_list|,
name|overmode
argument_list|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|immflg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|curt
condition|)
block|{
name|puts2
argument_list|(
literal|"?\""
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
literal|"\"  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|puts2
argument_list|(
literal|"The file \""
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
literal|"\" is write-protected."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yes_no
argument_list|(
name|curt
condition|?
literal|"override"
else|:
literal|"Do you wish to over-ride the permission"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
block|}
name|overfile
operator|=
name|file
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|overfile
argument_list|,
name|overmode
operator||
literal|0200
argument_list|)
operator|<
literal|0
condition|)
name|overfile
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|putsn
argument_list|(
literal|"[over-riding]"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lm_overwrite
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|PAGE
name|page
argument_list|()
block|{
specifier|register
name|cl
operator|,
name|n
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
specifier|register
name|linep
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
specifier|register
name|l
expr_stmt|;
name|a
operator|=
name|addr1
expr_stmt|;
if|if
condition|(
name|addr2
operator|!=
name|addr1
condition|)
name|b
operator|=
name|addr2
expr_stmt|;
else|else
name|b
operator|=
name|dol
expr_stmt|;
ifdef|#
directive|ifdef
name|PARENS
name|parenc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|parenc
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|parenc
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|n
operator|=
name|pcount
init|;
name|n
operator|>=
literal|0
operator|&&
name|a
operator|<=
name|b
condition|;
name|n
operator|--
control|)
block|{
name|pp
operator|=
name|p
operator|=
name|getline
argument_list|(
operator|*
name|a
argument_list|)
expr_stmt|;
name|cl
operator|=
name|prompt1
condition|?
literal|8
else|:
literal|0
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|<
literal|' '
operator|||
operator|*
name|p
operator|>
literal|'~'
condition|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\b'
case|:
if|if
condition|(
name|listf
condition|)
name|cl
operator|++
expr_stmt|;
else|else
block|{
name|cl
operator|--
expr_stmt|;
if|if
condition|(
name|aflg
ifdef|#
directive|ifdef
name|PARENS
operator|&&
operator|!
name|parenf
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STRLEN
operator|&&
operator|!
name|quotef
endif|#
directive|endif
condition|)
name|l
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\t'
case|:
if|if
condition|(
name|listf
condition|)
name|cl
operator|++
expr_stmt|;
else|else
name|cl
operator|+=
literal|8
operator|-
name|cl
operator|%
literal|8
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
if|if
condition|(
name|listf
condition|)
name|cl
operator|+=
literal|2
expr_stmt|;
else|else
name|cl
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ctrl
argument_list|(
literal|'L'
argument_list|)
case|:
comment|/* ADM-3A's */
if|if
condition|(
name|listf
condition|)
name|cl
operator|++
expr_stmt|;
name|cl
operator|++
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|listf
operator|||
name|zflg
condition|)
name|cl
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|cl
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|PARENS
if|if
condition|(
name|parenf
operator|&&
name|paren
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|l
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STRLEN
comment|/* if (quotef&& (*p == '"' || *p == '\'')) */
if|if
condition|(
name|quotef
operator|&&
operator|(
name|quotec
condition|?
operator|*
name|p
operator|==
name|quotec
else|:
operator|*
name|p
operator|==
literal|'"'
operator|||
operator|*
name|p
operator|==
literal|'\''
operator|)
condition|)
name|l
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cl
operator|<
literal|0
condition|)
name|cl
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|cl
operator|>
name|ccount
condition|)
block|{
name|cl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|--
name|n
operator|<
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|l
condition|)
if|if
condition|(
operator|--
name|n
operator|<
literal|0
condition|)
goto|goto
name|done
goto|;
name|col
operator|=
literal|0
expr_stmt|;
name|printlno
argument_list|(
name|line_num
operator|=
name|a
operator|-
name|zero
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|a
operator|++
expr_stmt|;
block|}
name|done
label|:
name|dot
operator|=
name|a
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PARENS
name|paren
argument_list|(
argument|ac
argument_list|)
block|{
switch|switch
condition|(
name|ac
condition|)
block|{
case|case
literal|'('
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|'['
case|:
return|return
operator|(
literal|2
operator|)
return|;
case|case
literal|'{'
case|:
return|return
operator|(
literal|3
operator|)
return|;
case|case
literal|')'
case|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
literal|']'
case|:
return|return
operator|(
operator|-
literal|2
operator|)
return|;
case|case
literal|'}'
case|:
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
name|place
argument_list|(
argument|asp
argument_list|,
argument|al1
argument_list|,
argument|al2
argument_list|)
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|l1
decl_stmt|,
modifier|*
name|l2
decl_stmt|;
name|sp
operator|=
name|asp
expr_stmt|;
name|l1
operator|=
name|al1
expr_stmt|;
name|l2
operator|=
name|al2
expr_stmt|;
while|while
condition|(
name|l1
operator|<
name|l2
condition|)
block|{
operator|*
name|sp
operator|++
operator|=
operator|*
name|l1
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|ALLOC
if|if
condition|(
name|sp
operator|>=
operator|&
name|genbuf
index|[
name|LBSIZE
operator|-
literal|2
index|]
condition|)
else|#
directive|else
if|if
condition|(
name|sp
operator|>=
operator|&
name|genbuf
index|[
name|lbsize
operator|-
literal|2
index|]
condition|)
endif|#
directive|endif
name|errmsg
argument_list|(
literal|42
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|sp
operator|)
return|;
block|}
comment|/*VARARGS*/
name|printf
argument_list|(
argument|as
argument_list|,
argument|aarglist
argument_list|)
name|char
modifier|*
name|as
decl_stmt|;
block|{
specifier|register
operator|*
name|args
operator|,
name|w
expr_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|flag
name|f
decl_stmt|;
name|args
operator|=
operator|&
name|aarglist
expr_stmt|;
while|while
condition|(
operator|*
name|as
condition|)
block|{
if|if
condition|(
operator|*
name|as
operator|!=
literal|'%'
condition|)
block|{
name|putchar
argument_list|(
operator|*
name|as
operator|++
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
operator|++
name|as
operator|==
literal|'\0'
condition|)
return|return;
name|w
operator|=
literal|0
expr_stmt|;
comment|/* no default width */
name|f
operator|=
literal|0
expr_stmt|;
comment|/* unsigned default */
while|while
condition|(
literal|'0'
operator|<=
operator|*
name|as
operator|&&
operator|*
name|as
operator|<=
literal|'9'
condition|)
name|w
operator|=
name|w
operator|*
literal|10
operator|+
operator|*
name|as
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|as
operator|==
literal|'\0'
condition|)
return|return;
switch|switch
condition|(
operator|*
name|as
operator|++
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* char */
name|putchar
argument_list|(
operator|*
name|args
operator|++
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
comment|/* signed decimal */
name|f
operator|=
literal|1
expr_stmt|;
comment|/* signed */
case|case
literal|'u'
case|:
comment|/* unsigned decimal */
name|printfn
argument_list|(
operator|*
name|args
operator|++
argument_list|,
literal|10
argument_list|,
name|f
argument_list|,
name|w
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'o'
case|:
comment|/* unsigned octal */
name|printfn
argument_list|(
operator|*
name|args
operator|++
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
name|w
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
comment|/* string */
name|q
operator|=
operator|*
name|args
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|q
condition|)
block|{
name|putchar
argument_list|(
operator|*
name|q
operator|++
argument_list|)
expr_stmt|;
operator|--
name|w
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|w
operator|>
literal|0
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|putchar
argument_list|(
name|as
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|printfn
argument_list|(
argument|an
argument_list|,
argument|ab
argument_list|,
argument|af
argument_list|,
argument|aw
argument_list|)
block|{
specifier|register
name|w
expr_stmt|;
specifier|register
name|unsigned
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|!=
literal|2
condition|?
literal|10
else|:
literal|6
operator|)
operator|+
literal|2
index|]
decl_stmt|;
name|w
operator|=
name|aw
expr_stmt|;
name|p
operator|=
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
index|]
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|=
name|an
expr_stmt|;
if|if
condition|(
name|af
condition|)
if|if
condition|(
name|an
operator|<
literal|0
condition|)
name|n
operator|=
operator|-
name|an
expr_stmt|;
else|else
name|af
operator|=
literal|0
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|p
operator|=
name|n
operator|%
name|ab
operator|+
literal|'0'
expr_stmt|;
operator|--
name|w
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|/=
name|ab
condition|)
do|;
if|if
condition|(
name|af
condition|)
block|{
operator|*
operator|--
name|p
operator|=
literal|'-'
expr_stmt|;
operator|--
name|w
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|w
operator|>=
literal|0
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|putchar
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
name|printlno
argument_list|(
argument|an
argument_list|)
block|{
specifier|register
name|flag
name|l
decl_stmt|;
if|if
condition|(
name|prompt1
condition|)
block|{
name|l
operator|=
name|listf
expr_stmt|;
name|listf
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
name|fmtlno
argument_list|,
name|an
operator|-
name|aflg
argument_list|)
expr_stmt|;
name|col
operator|=
literal|8
expr_stmt|;
name|listf
operator|=
name|l
expr_stmt|;
block|}
block|}
name|printmarks
argument_list|()
block|{
specifier|register
name|linep
modifier|*
name|a1
decl_stmt|;
specifier|register
name|charac
name|c
decl_stmt|;
specifier|register
name|n
operator|,
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|HUGE
name|i
operator|=
name|hugef
operator|^
literal|01
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|c
operator|=
literal|'a'
operator|-
literal|'a'
init|;
name|c
operator|<=
literal|'z'
operator|-
literal|'a'
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|names
index|[
name|c
index|]
operator|==
literal|0
condition|)
comment|/* zap marks to deleted lines */
continue|continue;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|a1
operator|=
name|zero
operator|+
literal|1
init|;
name|a1
operator|<=
name|dol
condition|;
name|a1
operator|++
control|)
if|if
condition|(
name|names
index|[
name|c
index|]
operator|==
operator|(
operator|*
name|a1
operator||
ifdef|#
directive|ifdef
name|HUGE
name|i
else|#
directive|else
literal|01
endif|#
directive|endif
operator|)
condition|)
block|{
name|n
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%c=%u"
argument_list|,
name|c
operator|+
literal|'a'
argument_list|,
name|a1
operator|-
name|zero
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTMARK
if|if
condition|(
name|names2
index|[
name|c
index|]
condition|)
block|{
for|for
control|(
name|a1
operator|++
init|;
name|a1
operator|<=
name|dol
condition|;
name|a1
operator|++
control|)
if|if
condition|(
name|names2
index|[
name|c
index|]
operator|==
operator|(
operator|*
name|a1
operator||
literal|01
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|",%u"
argument_list|,
name|a1
operator|-
name|zero
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|names
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
comment|/* clear unknown marks */
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
argument|ac
argument_list|)
name|charac
name|ac
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
specifier|register
name|charac
name|c
decl_stmt|;
name|lp
operator|=
name|linp
expr_stmt|;
name|c
operator|=
name|ac
expr_stmt|;
ifdef|#
directive|ifdef
name|APLMAP
if|if
condition|(
name|aplmap
operator|&&
name|fout
operator|==
literal|1
operator|&&
name|c
operator|>
literal|' '
condition|)
name|c
operator|=
name|map_apl
index|[
name|c
operator|-
operator|(
literal|' '
operator|+
literal|1
operator|)
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|listf
condition|)
block|{
if|if
condition|(
operator|++
name|col
operator|>=
name|ccount
operator|-
literal|1
condition|)
block|{
name|col
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
operator|*
name|lp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|c
operator|=
literal|'>'
expr_stmt|;
goto|goto
name|esc
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
block|{
name|c
operator|=
literal|'<'
expr_stmt|;
name|esc
label|:
operator|*
name|lp
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
literal|'\b'
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
name|c
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|c
operator|<
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
operator|||
name|c
operator|==
literal|0177
condition|)
block|{
operator|*
name|lp
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
name|c
operator|^
literal|0100
expr_stmt|;
name|col
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
operator|*
name|lp
operator|++
operator|=
name|c
expr_stmt|;
name|out
label|:
if|if
condition|(
name|lp
operator|>=
operator|&
name|line
index|[
name|TTSIZE
index|]
condition|)
block|{
name|linp
operator|=
name|line
expr_stmt|;
name|write
argument_list|(
name|fout
argument_list|,
name|line
argument_list|,
name|lp
operator|-
name|line
argument_list|)
expr_stmt|;
return|return;
block|}
name|linp
operator|=
name|lp
expr_stmt|;
block|}
name|putfile
argument_list|()
block|{
specifier|register
name|char
modifier|*
name|fp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
specifier|register
name|nib
expr_stmt|;
specifier|register
name|linep
modifier|*
name|a1
decl_stmt|;
name|nib
operator|=
name|BLKSIZE
expr_stmt|;
name|fp
operator|=
name|genbuf
expr_stmt|;
name|a1
operator|=
name|addr1
expr_stmt|;
do|do
block|{
name|lp
operator|=
name|getline
argument_list|(
operator|*
name|a1
operator|++
argument_list|)
expr_stmt|;
for|for ever
block|{
if|if
condition|(
operator|--
name|nib
operator|<
literal|0
condition|)
block|{
name|wte
argument_list|(
name|io
argument_list|,
name|genbuf
argument_list|,
name|fp
operator|-
name|genbuf
argument_list|)
expr_stmt|;
name|nib
operator|=
name|BLKSIZE
operator|-
literal|1
expr_stmt|;
name|fp
operator|=
name|genbuf
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|fp
operator|++
operator|=
operator|*
name|lp
operator|++
operator|)
operator|==
literal|0
condition|)
block|{
name|fp
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|a1
operator|<=
name|addr2
condition|)
do|;
name|wte
argument_list|(
name|io
argument_list|,
name|genbuf
argument_list|,
name|fp
operator|-
name|genbuf
argument_list|)
expr_stmt|;
block|}
name|putline
argument_list|()
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
specifier|register
name|nl
operator|,
name|tl
expr_stmt|;
name|lp
operator|=
name|linebuf
expr_stmt|;
name|tl
operator|=
name|tline
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tflg
condition|)
name|printf
argument_list|(
literal|"putline:\t%o\n"
argument_list|,
name|tl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|=
name|getblock
argument_list|(
name|tl
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HUGE
if|if
condition|(
name|hugef2
condition|)
block|{
name|hugef2
operator|=
literal|0
expr_stmt|;
name|tl
operator|=
name|tline
operator|=
operator|(
name|tline
operator|>>
literal|1
operator|)
operator|&
name|_6
index|[
name|hugef
index|]
expr_stmt|;
block|}
name|tl
operator|&=
name|_1
index|[
name|hugef
index|]
expr_stmt|;
else|#
directive|else
name|tl
operator|&=
name|_1
expr_stmt|;
endif|#
directive|endif
name|nl
operator|=
name|nleft
expr_stmt|;
while|while
condition|(
operator|*
name|bp
operator|=
operator|*
name|lp
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|++
operator|==
literal|'\n'
condition|)
block|{
operator|*
operator|--
name|bp
operator|=
literal|0
expr_stmt|;
name|linebp
operator|=
name|lp
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|--
name|nl
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HUGE
name|bp
operator|=
name|getblock
argument_list|(
name|tl
operator|+=
name|_2
index|[
name|hugef
index|]
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
else|#
directive|else
name|bp
operator|=
name|getblock
argument_list|(
name|tl
operator|+=
name|_2
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nl
operator|=
name|nleft
expr_stmt|;
block|}
block|}
name|nl
operator|=
name|tline
expr_stmt|;
ifdef|#
directive|ifdef
name|HUGE
name|tline
operator|+=
operator|(
operator|(
operator|(
name|lp
operator|-
name|linebuf
operator|)
operator|+
literal|03
operator|)
operator|>>
operator|(
literal|1
operator|+
name|hugef
operator|)
operator|)
operator|&
name|_6
index|[
name|hugef
index|]
expr_stmt|;
else|#
directive|else
name|tline
operator|+=
operator|(
operator|(
operator|(
name|lp
operator|-
name|linebuf
operator|)
operator|+
literal|03
operator|)
operator|>>
literal|1
operator|)
operator|&
name|_6
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|nl
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|PARENS
name|putparen
argument_list|(
argument|an
argument_list|)
block|{
specifier|register
name|c
expr_stmt|;
name|an
operator|%=
literal|10
operator|+
literal|26
operator|+
literal|26
expr_stmt|;
if|if
condition|(
name|an
operator|<
literal|0
condition|)
name|an
operator|+=
literal|10
operator|+
literal|26
operator|+
literal|26
expr_stmt|;
name|c
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|an
operator|>
literal|9
operator|+
literal|26
condition|)
name|c
operator|=
literal|'a'
operator|-
operator|(
literal|10
operator|+
literal|26
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|an
operator|>
literal|9
condition|)
name|c
operator|=
literal|'A'
operator|-
literal|10
expr_stmt|;
name|putchar
argument_list|(
name|c
operator|+
name|an
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|puts
argument_list|(
argument|as
argument_list|)
block|{
specifier|register
name|n
expr_stmt|;
specifier|register
name|flag
name|ovp
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|sp
operator|=
name|as
expr_stmt|;
name|ovp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
block|{
if|if
condition|(
name|aflg
operator|&&
ifdef|#
directive|ifdef
name|PARENS
operator|!
name|parenf
operator|&&
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STRLEN
operator|!
name|quotef
operator|&&
endif|#
directive|endif
operator|!
name|listf
operator|&&
operator|*
name|sp
operator|==
literal|'\b'
condition|)
block|{
name|ovp
operator|=
literal|1
expr_stmt|;
name|sp
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|PARENS
if|if
condition|(
operator|!
name|ovp
operator|&&
name|parenf
operator|&&
operator|!
name|listf
operator|&&
name|paren
argument_list|(
operator|*
name|sp
argument_list|)
condition|)
name|ovp
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STRLEN
comment|/* if (!ovp&& quotef&& !listf&& (*sp == '"' || *sp == '\'')) */
if|if
condition|(
operator|!
name|ovp
operator|&&
name|quotef
operator|&&
operator|!
name|listf
operator|&&
operator|(
name|quotec
condition|?
operator|*
name|sp
operator|==
name|quotec
else|:
operator|*
name|sp
operator|==
literal|'"'
operator|||
operator|*
name|sp
operator|==
literal|'\''
operator|)
condition|)
name|ovp
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|putchar
argument_list|(
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
block|}
name|sp
operator|=
name|as
expr_stmt|;
if|if
condition|(
name|aflg
operator|&&
name|ovp
operator|&&
ifdef|#
directive|ifdef
name|PARENS
operator|!
name|parenf
operator|&&
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STRLEN
operator|!
name|quotef
operator|&&
endif|#
directive|endif
operator|!
name|listf
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|prompt1
condition|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
index|[
literal|1
index|]
operator|==
literal|'\b'
operator|&&
name|sp
index|[
literal|2
index|]
condition|)
block|{
name|putchar
argument_list|(
name|sp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|sp
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\t'
condition|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|sp
operator|>=
literal|' '
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|ovp
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PARENS
if|if
condition|(
name|parenf
operator|&&
name|ovp
operator|&&
operator|!
name|listf
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|prompt1
condition|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|n
operator|=
name|paren
argument_list|(
operator|*
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|n
operator|=
operator|-
name|n
operator|-
literal|1
expr_stmt|;
name|putparen
argument_list|(
name|parenc
index|[
name|n
index|]
operator|--
argument_list|)
expr_stmt|;
block|}
else|else
name|putparen
argument_list|(
operator|++
name|parenc
index|[
operator|--
name|n
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\t'
operator|||
operator|*
name|sp
operator|>=
literal|' '
condition|)
name|putchar
argument_list|(
operator|*
name|sp
operator|==
literal|'\t'
condition|?
literal|'\t'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|ovp
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STRLEN
if|if
condition|(
name|quotef
operator|&&
name|ovp
operator|&&
operator|!
name|listf
condition|)
block|{
name|s
operator|=
name|null
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|ovp
operator|=
literal|0
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|prompt1
condition|)
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|sp
condition|;
name|sp
operator|++
control|)
block|{
comment|/* if (n == 0&& (*sp == '"' || *sp == '\'') || */
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
operator|(
name|quotec
condition|?
operator|*
name|sp
operator|==
operator|(
name|ovp
condition|?
name|quotec
else|:
name|quotec2
operator|)
else|:
operator|*
name|sp
operator|==
literal|'"'
operator|||
operator|*
name|sp
operator|==
literal|'\''
operator|)
operator|||
operator|*
name|sp
operator|==
name|n
condition|)
block|{
if|if
condition|(
name|ovp
condition|)
block|{
name|ovp
operator|=
literal|0
expr_stmt|;
goto|goto
name|not
goto|;
block|}
if|if
condition|(
name|n
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|s
operator|=
name|sp
operator|++
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|&&
operator|*
name|sp
operator|!=
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
literal|'0'
operator|<=
operator|*
operator|++
name|sp
operator|&&
operator|*
name|sp
operator|<=
literal|'7'
condition|)
block|{
if|if
condition|(
literal|'0'
operator|<=
operator|*
operator|++
name|sp
operator|&&
operator|*
name|sp
operator|<=
literal|'7'
condition|)
if|if
condition|(
literal|'0'
operator|<=
operator|*
operator|++
name|sp
operator|&&
operator|*
name|sp
operator|<=
literal|'7'
condition|)
name|sp
operator|++
expr_stmt|;
block|}
else|else
name|sp
operator|++
expr_stmt|;
block|}
else|else
name|sp
operator|++
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|sp
operator|=
name|s
expr_stmt|;
name|s
operator|=
operator|&
literal|"00000"
index|[
literal|5
index|]
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|s
operator|=
name|n
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|/=
literal|10
condition|)
do|;
name|n
operator|=
operator|*
name|sp
expr_stmt|;
block|}
block|}
name|not
label|:
if|if
condition|(
operator|*
name|s
condition|)
name|putchar
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
operator|*
name|sp
operator|==
literal|'\t'
condition|?
literal|'\t'
else|:
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\\'
condition|)
name|ovp
operator|^=
literal|01
expr_stmt|;
block|}
name|ovp
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|puts2
argument_list|(
argument|as
argument_list|)
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|as
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
name|putchar
argument_list|(
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CKPT
name|recover
argument_list|()
block|{
extern|extern etext;
specifier|register
name|filedes
name|f
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|func
name|savint
decl_stmt|,
name|savqit
decl_stmt|;
name|int
name|n
decl_stmt|;
name|savint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|savqit
operator|=
name|signal
argument_list|(
name|SIGQIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|cfname
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|read
argument_list|(
name|f
argument_list|,
operator|&
name|n
argument_list|,
sizeof|sizeof
name|n
argument_list|)
operator|!=
sizeof|sizeof
name|n
condition|)
block|{
name|n
operator|=
literal|67
expr_stmt|;
goto|goto
name|cerror
goto|;
block|}
name|p
operator|=
operator|&
name|etext
expr_stmt|;
if|if
condition|(
name|brk
argument_list|(
name|p
operator|+
name|n
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|n
operator|=
literal|67
expr_stmt|;
goto|goto
name|cerror
goto|;
block|}
ifdef|#
directive|ifdef
name|pdp11
comment|/* 16 bit byte count only */
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
name|f
argument_list|,
name|p
argument_list|,
literal|32256
argument_list|)
operator|!=
literal|32256
condition|)
block|{
name|n
operator|=
literal|67
expr_stmt|;
goto|goto
name|cerror
goto|;
block|}
name|n
operator|-=
literal|32256
expr_stmt|;
comment|/* 63 blocks, since 64 is< 0 */
name|p
operator|+=
literal|32256
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|read
argument_list|(
name|f
argument_list|,
name|p
argument_list|,
name|n
argument_list|)
operator|!=
name|n
operator|||
operator|(
name|tfile
operator|=
name|open
argument_list|(
name|tfname
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|n
operator|=
literal|67
expr_stmt|;
else|else
name|n
operator|=
literal|0
expr_stmt|;
name|recovry
operator|=
literal|1
expr_stmt|;
comment|/* overwritten by reading data space */
name|cerror
label|:
if|if
condition|(
name|n
condition|)
block|{
name|puts
argument_list|(
name|errtext
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|>
literal|0
condition|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* 	 * "initialize" special stuff to restore order 	 */
name|globp
operator|=
literal|0
expr_stmt|;
name|io
operator|=
literal|0
expr_stmt|;
name|io_w
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HELP
name|doc
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE
name|alt
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AGAIN
name|agf
operator|=
literal|0
expr_stmt|;
name|agp
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EOL
name|prompt3
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PIPE
if|if
condition|(
name|pfile
condition|)
block|{
name|unlink
argument_list|(
name|pfname
argument_list|)
expr_stmt|;
name|pfile
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|savint
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQIT
argument_list|,
name|savqit
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|reverse
argument_list|(
argument|aa1
argument_list|,
argument|aa2
argument_list|)
block|{
specifier|register
name|linep
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|,
name|t
decl_stmt|;
name|a1
operator|=
name|aa1
expr_stmt|;
name|a2
operator|=
name|aa2
expr_stmt|;
for|for ever
block|{
name|t
operator|=
operator|*
operator|--
name|a2
expr_stmt|;
if|if
condition|(
name|a2
operator|<=
name|a1
condition|)
return|return;
operator|*
name|a2
operator|=
operator|*
name|a1
expr_stmt|;
operator|*
name|a1
operator|++
operator|=
name|t
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|XDEL
name|saveline
argument_list|()
block|{
specifier|register
name|linep
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
specifier|register
name|nl
operator|,
name|tl
expr_stmt|;
name|a1
operator|=
name|addr1
expr_stmt|;
name|a2
operator|=
name|addr2
expr_stmt|;
name|ndeleted
operator|=
name|a2
operator|-
name|a1
operator|+
literal|1
expr_stmt|;
name|tl
operator|=
name|tline
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tflg
condition|)
name|printf
argument_list|(
literal|"saveline:\t%o\n"
argument_list|,
name|tl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|=
name|getblock
argument_list|(
name|tl
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HUGE
if|if
condition|(
name|hugef2
condition|)
block|{
name|hugef2
operator|=
literal|0
expr_stmt|;
name|tl
operator|=
operator|(
name|tl
operator|>>
literal|1
operator|)
operator|&
name|_6
index|[
name|hugef
index|]
expr_stmt|;
block|}
name|tl
operator|&=
name|_1
index|[
name|hugef
index|]
expr_stmt|;
else|#
directive|else
name|tl
operator|&=
name|_1
expr_stmt|;
endif|#
directive|endif
name|nl
operator|=
name|nleft
operator|/
sizeof|sizeof
argument_list|(
name|linep
argument_list|)
expr_stmt|;
while|while
condition|(
name|a1
operator|<=
name|a2
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
operator|*
name|a1
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|nl
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HUGE
name|bp
operator|=
name|getblock
argument_list|(
name|tl
operator|+=
name|_2
index|[
name|hugef
index|]
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hugef2
condition|)
block|{
name|hugef2
operator|=
literal|0
expr_stmt|;
name|tl
operator|=
operator|(
name|tl
operator|>>
literal|1
operator|)
operator|&
name|_6
index|[
name|hugef
index|]
expr_stmt|;
block|}
else|#
directive|else
name|bp
operator|=
name|getblock
argument_list|(
name|tl
operator|+=
name|_2
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nl
operator|=
name|nleft
operator|/
sizeof|sizeof
argument_list|(
name|linep
argument_list|)
expr_stmt|;
block|}
block|}
name|deleted
operator|=
name|tline
expr_stmt|;
ifdef|#
directive|ifdef
name|HUGE
name|tline
operator|+=
operator|(
operator|(
name|a2
operator|-
name|addr1
operator|+
literal|1
operator|)
operator|<<
operator|(
literal|1
operator|-
name|hugef
operator|)
operator|)
operator|&
name|_6
index|[
name|hugef
index|]
expr_stmt|;
else|#
directive|else
name|tline
operator|+=
operator|(
operator|(
name|a2
operator|-
name|addr1
operator|+
literal|1
operator|)
operator|<<
literal|1
operator|)
operator|&
name|_6
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
name|savemark
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|)
name|linep
name|p1
decl_stmt|,
name|p2
decl_stmt|;
block|{
specifier|register
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|HUGE
specifier|register
name|i
expr_stmt|;
name|i
operator|=
name|hugef
operator|^
literal|01
expr_stmt|;
name|p1
operator||=
name|i
expr_stmt|;
name|p2
operator||=
name|i
expr_stmt|;
else|#
directive|else
name|p1
operator||=
literal|01
expr_stmt|;
name|p2
operator||=
literal|01
expr_stmt|;
endif|#
directive|endif
comment|/* save "marks" on lines so marked */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
literal|'z'
operator|-
literal|'a'
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|names
index|[
name|n
index|]
operator|==
literal|0
condition|)
comment|/* zap marks to deleted lines */
continue|continue;
if|if
condition|(
name|names
index|[
name|n
index|]
operator|==
name|p1
condition|)
name|names
index|[
name|n
index|]
operator|=
name|p2
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTMARK
if|if
condition|(
name|names2
index|[
name|n
index|]
operator|&&
name|names2
index|[
name|n
index|]
operator|==
name|p1
condition|)
name|names2
index|[
name|n
index|]
operator|=
name|p2
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|YINT
comment|/* don't lose "y+" line either */
if|if
condition|(
name|yplus
operator|==
name|p1
condition|)
name|yplus
operator|=
name|p2
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UNDO
comment|/* and remember the line for "undo" */
name|undo_oldp
operator|=
name|p1
expr_stmt|;
name|undo_newp
operator|=
name|p2
expr_stmt|;
endif|#
directive|endif
block|}
name|scopy
argument_list|(
argument|ass
argument_list|,
argument|ads
argument_list|)
name|char
modifier|*
name|ass
decl_stmt|,
modifier|*
name|ads
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|ass
expr_stmt|;
name|q
operator|=
name|ads
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
condition|)
empty_stmt|;
return|return
operator|(
name|ads
operator|)
return|;
block|}
name|setall
argument_list|()
block|{
if|if
condition|(
name|addr2
operator|==
literal|0
condition|)
block|{
name|addr1
operator|=
name|zero
operator|+
operator|(
name|zero
operator|!=
name|dol
operator|)
expr_stmt|;
name|addr2
operator|=
name|dol
expr_stmt|;
block|}
name|setdot
argument_list|()
expr_stmt|;
block|}
name|setchar
argument_list|(
argument|adflt
argument_list|)
block|{
specifier|register
name|charac
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|errmsg
argument_list|(
literal|59
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
operator|(
name|adflt
operator|)
return|;
name|newline
argument_list|()
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
name|setdot
argument_list|()
block|{
if|if
condition|(
name|addr2
operator|==
literal|0
condition|)
name|addr1
operator|=
name|addr2
operator|=
name|dot
expr_stmt|;
if|if
condition|(
name|addr1
operator|>
name|addr2
condition|)
name|errmsg
argument_list|(
literal|21
argument_list|)
expr_stmt|;
block|}
name|setnoaddr
argument_list|()
block|{
if|if
condition|(
name|addr2
condition|)
name|errmsg
argument_list|(
literal|22
argument_list|)
expr_stmt|;
block|}
name|setnum
argument_list|(
argument|adflt
argument_list|)
block|{
specifier|register
name|n
expr_stmt|;
name|white_space
argument_list|()
expr_stmt|;
name|n
operator|=
name|adflt
expr_stmt|;
if|if
condition|(
literal|'0'
operator|<=
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|&&
name|peekc
operator|<=
literal|'9'
condition|)
name|n
operator|=
name|getnum
argument_list|()
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|TABS
name|settab
argument_list|(
argument|acs
argument_list|)
block|{
specifier|register
operator|*
name|p
operator|,
name|i
operator|,
name|n
expr_stmt|;
if|if
condition|(
name|acs
operator|==
literal|0
condition|)
block|{
name|maxtab
operator|=
operator|-
literal|1
expr_stmt|;
name|n
operator|=
name|TABS
expr_stmt|;
name|p
operator|=
name|tabs
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acs
operator|<
literal|0
condition|)
block|{
name|acs
operator|=
operator|-
name|acs
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|acs
operator|<
name|TABS
operator|*
name|BPW
condition|)
block|{
name|p
operator|=
operator|&
name|tabs
index|[
name|acs
operator|>>
name|BPWC
index|]
expr_stmt|;
operator|*
name|p
operator||=
literal|01
operator|<<
operator|(
name|n
operator|=
name|acs
operator|&
name|BPWM
operator|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
operator|*
name|p
operator|^=
literal|01
operator|<<
name|n
expr_stmt|;
if|if
condition|(
name|acs
operator|==
name|maxtab
condition|)
block|{
comment|/* find new maxtab */
for|for
control|(
name|n
operator|=
name|TABS
operator|-
literal|1
init|;
name|n
operator|>=
literal|0
condition|;
operator|--
name|n
control|)
if|if
condition|(
name|tabs
index|[
name|n
operator|>>
name|BPWC
index|]
operator|>>
operator|(
name|n
operator|&
name|BPWM
operator|)
operator|&
literal|01
condition|)
break|break;
name|maxtab
operator|=
name|n
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|acs
operator|>
name|maxtab
condition|)
name|maxtab
operator|=
name|acs
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|shell
argument_list|()
block|{
ifdef|#
directive|ifdef
name|PIPE
extern|extern oil_spilled(
block|)
empty_stmt|;
endif|#
directive|endif
specifier|register
name|pid
operator|,
name|wpid
expr_stmt|;
specifier|register
name|linep
modifier|*
name|a
decl_stmt|;
specifier|register
name|dp
operator|,
name|df
operator|,
name|nopipe
operator|,
name|c
operator|,
name|e
operator|,
name|savint
operator|,
name|savqit
expr_stmt|;
specifier|register
name|linep
modifier|*
name|dest
decl_stmt|;
name|int
name|retcode
decl_stmt|,
name|p
index|[
literal|2
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|PIPE
name|dp
operator|=
literal|0
expr_stmt|;
name|df
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|addr2
condition|)
block|{
ifdef|#
directive|ifdef
name|LOG
operator|++
name|logstats
operator|.
name|lc_pipe
expr_stmt|;
endif|#
directive|endif
name|dest
operator|=
literal|0
expr_stmt|;
name|nopipe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'|'
condition|)
block|{
name|nonzero
argument_list|()
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|df
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|--
name|logstats
operator|.
name|lc_pipe
expr_stmt|;
operator|++
name|logstats
operator|.
name|lc_dpipe
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'>'
condition|)
block|{
name|nonzero
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|--
name|logstats
operator|.
name|lc_pipe
expr_stmt|;
operator|++
name|logstats
operator|.
name|lc_pto
expr_stmt|;
endif|#
directive|endif
goto|goto
name|pi
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'<'
condition|)
block|{
name|nopipe
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
operator|--
name|logstats
operator|.
name|lc_pipe
expr_stmt|;
operator|++
name|logstats
operator|.
name|lc_pfrom
expr_stmt|;
endif|#
directive|endif
name|pi
label|:
name|peekc
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
name|dest
operator|=
name|addr2
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|&&
literal|'0'
operator|<=
operator|(
name|peekc
operator|=
name|getchar
argument_list|()
operator|)
operator|&&
name|peekc
operator|<=
literal|'9'
condition|)
block|{
name|c
operator|=
name|getnum
argument_list|()
expr_stmt|;
name|dest
operator|=
name|zero
operator|+
name|c
expr_stmt|;
if|if
condition|(
name|dest
operator|<
name|zero
condition|)
name|dest
operator|=
name|zero
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|dest
operator|>
name|dol
condition|)
name|dest
operator|=
name|dol
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|LOG
else|else
operator|++
name|logstats
operator|.
name|lc_shell
expr_stmt|;
endif|#
directive|endif
name|piperr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|iflg
condition|)
if|if
condition|(
name|addr2
condition|)
block|{
name|savint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|oil_spilled
argument_list|)
expr_stmt|;
name|savqit
operator|=
name|signal
argument_list|(
name|SIGQIT
argument_list|,
name|oil_spilled
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|savint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|savqit
operator|=
name|signal
argument_list|(
name|SIGQIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIPE
block|}
if|if
condition|(
name|addr2
operator|&&
name|pipe
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
block|{
name|c
operator|=
literal|15
expr_stmt|;
name|errm
label|:
if|if
condition|(
operator|!
name|iflg
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|savint
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQIT
argument_list|,
name|savqit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
condition|)
name|errmsg
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|error
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dp
condition|)
block|{
if|if
condition|(
operator|(
name|pfile
operator|=
name|create
argument_list|(
name|pfname
argument_list|,
name|LMODE
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|pfile
operator|=
literal|0
expr_stmt|;
name|c
operator|=
literal|64
expr_stmt|;
goto|goto
name|errm
goto|;
block|}
if|if
condition|(
operator|(
name|io
operator|=
name|open
argument_list|(
name|pfname
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|io
operator|=
literal|0
expr_stmt|;
name|c
operator|=
literal|65
expr_stmt|;
goto|goto
name|errm
goto|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PIPE
if|if
condition|(
name|addr2
condition|)
block|{
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|c
operator|=
literal|14
expr_stmt|;
goto|goto
name|errm
goto|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* kid */
if|if
condition|(
operator|!
name|iflg
condition|)
block|{
comment|/* kid */
name|signal
argument_list|(
name|SIGHUP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* kid */
name|signal
argument_list|(
name|SIGINT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* kid */
name|signal
argument_list|(
name|SIGQIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* kid */
block|}
ifdef|#
directive|ifdef
name|PIPE
comment|/* kid */
if|if
condition|(
name|addr2
condition|)
block|{
comment|/* kid */
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* kid */
name|dup
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* kid */
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* kid */
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* kid */
if|if
condition|(
name|dp
condition|)
block|{
comment|/* kid */
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* kid */
name|dup
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* kid */
name|close
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* kid */
block|}
comment|/* kid */
block|}
endif|#
directive|endif
comment|/* kid */
name|execl
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"!sh"
argument_list|,
literal|"-t"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* kid */
name|write
argument_list|(
literal|2
argument_list|,
literal|"No shell!\n"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* kid */
name|exit
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CMDS
if|if
condition|(
name|cmd
operator|&&
operator|!
name|addr2
condition|)
name|write
argument_list|(
name|cmd
argument_list|,
literal|"<UNIX>\n"
argument_list|,
literal|7
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PIPE
if|if
condition|(
name|addr2
condition|)
block|{
name|signal
argument_list|(
name|SIGPIP
argument_list|,
name|oil_spilled
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|e
operator|=
name|eflg2
expr_stmt|;
name|eflg2
operator|++
expr_stmt|;
name|fout
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|>=
literal|0
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nopipe
condition|)
block|{
name|line_num
operator|=
operator|(
name|a
operator|=
name|addr1
operator|)
operator|-
name|zero
operator|-
name|aflg
expr_stmt|;
do|do
block|{
if|if
condition|(
name|pno
operator|>=
literal|0
condition|)
name|printlno
argument_list|(
name|line_num
operator|++
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|getline
argument_list|(
operator|*
name|a
operator|++
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|a
operator|<=
name|addr2
operator|&&
operator|!
name|piperr
condition|)
do|;
block|}
name|flush_buf
argument_list|()
expr_stmt|;
name|fout
operator|=
literal|1
expr_stmt|;
name|eflg2
operator|=
name|e
expr_stmt|;
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iflg
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
while|while
condition|(
operator|(
name|wpid
operator|=
name|wait
argument_list|(
operator|&
name|retcode
argument_list|)
operator|)
operator|!=
name|pid
operator|&&
name|wpid
operator|>=
literal|0
condition|)
empty_stmt|;
ifdef|#
directive|ifdef
name|CMDS
if|if
condition|(
name|cmd
condition|)
name|lseek
argument_list|(
name|cmd
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PIPE
if|if
condition|(
name|addr2
condition|)
name|signal
argument_list|(
name|SIGPIP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|=
name|retcode
operator|&
literal|0177
condition|)
block|{
if|if
condition|(
literal|0
operator|<
name|c
operator|&&
name|c
operator|<
name|NSTR
operator|&&
name|status
index|[
name|c
index|]
condition|)
name|puts2
argument_list|(
name|status
index|[
name|c
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"signal %d"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|&
literal|0200
condition|)
name|puts2
argument_list|(
literal|" -- core dumped"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|lastc
operator|=
literal|'\n'
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
goto|goto
name|errm
goto|;
block|}
elseif|else
if|if
condition|(
name|df
operator|&&
name|strict
operator|&&
name|retcode
operator|>>
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"exit status %d\n"
argument_list|,
name|retcode
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
goto|goto
name|errm
goto|;
block|}
ifdef|#
directive|ifdef
name|PIPE
elseif|else
if|if
condition|(
name|addr2
condition|)
block|{
if|if
condition|(
name|piperr
condition|)
block|{
name|putsn
argument_list|(
name|status
index|[
name|SIGPIP
index|]
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
goto|goto
name|errm
goto|;
block|}
if|if
condition|(
name|dp
condition|)
block|{
if|if
condition|(
name|df
condition|)
block|{
name|c
operator|=
name|addr2
operator|!=
name|dol
expr_stmt|;
name|delete
argument_list|()
expr_stmt|;
if|if
condition|(
name|dest
operator|==
literal|0
condition|)
name|dest
operator|=
name|dot
operator|-
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dest
operator|==
literal|0
condition|)
name|dest
operator|=
name|addr2
expr_stmt|;
if|if
condition|(
name|dest
operator|<
name|zero
condition|)
name|dest
operator|=
name|zero
expr_stmt|;
if|if
condition|(
name|c
operator|=
name|append
argument_list|(
name|getfile
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|text_modified
operator|++
expr_stmt|;
if|if
condition|(
name|prompt2
condition|)
name|printf
argument_list|(
operator|(
name|curt
condition|?
name|prcntu
else|:
name|errtext
index|[
literal|55
index|]
operator|)
argument_list|,
name|c
argument_list|,
operator|(
name|c
operator|==
literal|1
condition|?
name|null
else|:
name|quote_s
operator|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|io
operator|=
literal|0
expr_stmt|;
name|unlink
argument_list|(
name|pfname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|iflg
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|savint
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQIT
argument_list|,
name|savqit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|addr2
condition|)
name|putsn
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLEAR
name|istty
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* in case bs1 changed */
endif|#
directive|endif
block|}
end_block

begin_macro
name|signals
argument_list|(
argument|ast
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sigtab
modifier|*
name|ast
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|n
expr_stmt|;
specifier|register
name|struct
name|sigtab
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|ast
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|n
operator|=
operator|(
operator|++
name|s
operator|)
operator|->
name|s_sig
condition|)
name|signal
argument_list|(
name|n
argument_list|,
name|s
operator|->
name|s_func
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|skip_rest
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|charac
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|>=
literal|0
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
block|}
end_block

begin_macro
name|substitute
argument_list|(
argument|inglob
argument_list|)
end_macro

begin_block
block|{
extern|extern getsub(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|register
name|linep
modifier|*
name|a1
decl_stmt|,
name|p
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|nl
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|flag
name|gsubf
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|gsubf
operator|=
name|compsub
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 0 or 1 depending on 'g' */
end_comment

begin_for
for|for
control|(
name|a1
operator|=
name|addr1
init|;
name|a1
operator|<=
name|addr2
condition|;
name|a1
operator|++
control|)
block|{
name|s_tmp
operator|=
name|s_cnt
expr_stmt|;
if|if
condition|(
name|execute
argument_list|(
literal|0
argument_list|,
name|a1
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|inglob
operator||=
literal|01
expr_stmt|;
name|dosub
argument_list|()
expr_stmt|;
if|if
condition|(
name|gsubf
condition|)
while|while
condition|(
operator|*
name|loc2
condition|)
block|{
if|if
condition|(
name|execute
argument_list|(
literal|1
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|dosub
argument_list|()
expr_stmt|;
block|}
name|p
operator|=
operator|*
name|a1
expr_stmt|;
operator|*
name|a1
operator|=
name|putline
argument_list|()
expr_stmt|;
name|savemark
argument_list|(
name|p
argument_list|,
operator|*
name|a1
argument_list|)
expr_stmt|;
name|nl
operator|=
name|append
argument_list|(
name|getsub
argument_list|,
name|a1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|a1
operator|+=
name|nl
expr_stmt|;
name|addr2
operator|+=
name|nl
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
name|inglob
operator|==
literal|0
condition|)
name|errmsg
argument_list|(
literal|39
argument_list|)
expr_stmt|;
end_if

begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|XED
end_ifdef

begin_expr_stmt
unit|tack
operator|(
name|aeof
operator|,
name|aflag
operator|)
name|char
name|aeof
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|n
expr_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|linep
modifier|*
name|a
decl_stmt|;
specifier|register
name|charac
name|c
decl_stmt|;
name|nonzero
argument_list|()
expr_stmt|;
name|setdot
argument_list|()
expr_stmt|;
name|p1
operator|=
name|rhsbuf
expr_stmt|;
comment|/* i/TEXT screwed for long lines */
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|aeof
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|errmsg
argument_list|(
literal|59
argument_list|)
expr_stmt|;
operator|*
name|p1
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
operator|&
name|rhsbuf
index|[
name|LBSIZE
operator|/
literal|2
operator|-
literal|2
index|]
condition|)
name|errmsg
argument_list|(
literal|42
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|rhsbuf
operator|==
literal|0
condition|)
name|errmsg
argument_list|(
literal|27
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|prompt2
condition|)
name|pflag
operator|++
expr_stmt|;
block|}
else|else
name|newline
argument_list|()
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|rhsbuf
condition|)
operator|*
name|p1
operator|=
literal|0
expr_stmt|;
else|else
while|while
condition|(
operator|*
name|p1
condition|)
name|p1
operator|++
expr_stmt|;
name|n
operator|=
name|p1
operator|-
name|rhsbuf
expr_stmt|;
for|for
control|(
name|a
operator|=
name|addr1
init|;
name|a
operator|<=
name|addr2
condition|;
name|a
operator|++
control|)
block|{
name|getline
argument_list|(
operator|*
name|a
argument_list|)
expr_stmt|;
for|for
control|(
name|p2
operator|=
name|linebuf
init|;
operator|*
name|p2
condition|;
name|p2
operator|++
control|)
empty_stmt|;
ifndef|#
directive|ifndef
name|ALLOC
if|if
condition|(
name|p2
operator|+
name|n
operator|>=
operator|&
name|linebuf
index|[
name|LBSIZE
operator|/
literal|2
operator|-
literal|2
index|]
condition|)
else|#
directive|else
if|if
condition|(
name|p2
operator|+
name|n
operator|>=
operator|&
name|linebuf
index|[
name|lbsize
operator|/
literal|2
operator|-
literal|2
index|]
condition|)
endif|#
directive|endif
name|errmsg
argument_list|(
literal|30
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
block|{
comment|/* $ */
name|p1
operator|=
name|rhsbuf
expr_stmt|;
while|while
condition|(
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
condition|)
empty_stmt|;
block|}
else|else
block|{
comment|/* ^ */
name|p1
operator|=
name|p2
operator|+
name|n
expr_stmt|;
operator|*
name|p1
operator|=
operator|*
name|p2
expr_stmt|;
while|while
condition|(
name|p2
operator|>
name|linebuf
condition|)
operator|*
operator|--
name|p1
operator|=
operator|*
operator|--
name|p2
expr_stmt|;
name|p1
operator|=
name|linebuf
expr_stmt|;
name|p2
operator|=
name|rhsbuf
expr_stmt|;
while|while
condition|(
operator|*
name|p2
condition|)
operator|*
name|p1
operator|++
operator|=
operator|*
name|p2
operator|++
expr_stmt|;
block|}
name|p2
operator|=
operator|*
name|a
expr_stmt|;
operator|*
name|a
operator|=
name|putline
argument_list|()
expr_stmt|;
name|savemark
argument_list|(
name|p2
argument_list|,
operator|*
name|a
argument_list|)
expr_stmt|;
block|}
name|dot
operator|=
name|addr2
expr_stmt|;
return|return
operator|(
name|addr2
operator|-
name|addr1
operator|+
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|term
argument_list|()
end_macro

begin_block
block|{
name|signal
argument_list|(
name|SIGTRM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reading
condition|)
block|{
name|backup
argument_list|(
name|TRM
argument_list|)
expr_stmt|;
if|if
condition|(
name|fout
operator|!=
literal|1
condition|)
block|{
name|flush_buf
argument_list|()
expr_stmt|;
name|fout
operator|=
literal|1
expr_stmt|;
block|}
name|puts2
argument_list|(
name|errtext
index|[
literal|58
index|]
argument_list|)
expr_stmt|;
name|delexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|termflg
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|tmpname
argument_list|(
argument|as
argument_list|,
argument|an
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|as
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
name|c
decl_stmt|;
name|p
operator|=
name|as
expr_stmt|;
name|n
operator|=
name|an
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|p
operator|>=
name|as
condition|)
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|==
literal|'0'
operator|||
operator|(
name|c
operator||
literal|040
operator|)
operator|==
literal|'x'
condition|)
block|{
operator|*
name|p
operator|=
name|n
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|n
operator|/=
literal|10
expr_stmt|;
ifdef|#
directive|ifdef
name|CKPT
name|tfnum
operator|=
name|p
operator|-
name|as
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|as
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|XDEL
end_ifdef

begin_macro
name|undelete
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|linep
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
specifier|register
name|tl
operator|,
name|nl
operator|,
name|num
expr_stmt|;
if|if
condition|(
operator|(
name|tl
operator|=
name|deleted
operator|)
operator|==
literal|0
condition|)
name|errmsg
argument_list|(
literal|16
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tflg
condition|)
name|printf
argument_list|(
literal|"undelete:\t%o\n"
argument_list|,
name|tl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|setdot
argument_list|()
expr_stmt|;
name|a1
operator|=
name|dol
operator|+
literal|1
expr_stmt|;
name|a2
operator|=
name|a1
operator|+
name|ndeleted
expr_stmt|;
name|bp
operator|=
name|addr2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|dol
operator|+
name|ndeleted
operator|>
name|endcore
condition|)
block|{
name|num
operator|=
operator|(
operator|(
name|ndeleted
operator|*
literal|2
operator|)
operator|+
literal|1023
operator|)
operator|&
operator|~
literal|01777
expr_stmt|;
if|if
condition|(
name|sbrk
argument_list|(
name|num
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errmsg
argument_list|(
literal|33
argument_list|)
expr_stmt|;
name|endcore
operator|=
operator|(
name|int
operator|)
name|endcore
operator|+
name|num
expr_stmt|;
block|}
while|while
condition|(
name|a1
operator|>
name|bp
condition|)
operator|*
operator|--
name|a2
operator|=
operator|*
operator|--
name|a1
expr_stmt|;
name|dol
operator|+=
name|ndeleted
expr_stmt|;
name|a1
operator|=
name|addr2
operator|+
literal|1
expr_stmt|;
name|a2
operator|=
name|a1
operator|+
name|ndeleted
expr_stmt|;
name|bp
operator|=
name|getblock
argument_list|(
name|tl
argument_list|,
name|READ
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HUGE
name|tl
operator|&=
name|_1
index|[
name|hugef
index|]
expr_stmt|;
else|#
directive|else
name|tl
operator|&=
name|_1
expr_stmt|;
endif|#
directive|endif
name|nl
operator|=
name|nleft
operator|/
sizeof|sizeof
argument_list|(
name|linep
argument_list|)
expr_stmt|;
while|while
condition|(
name|a1
operator|<
name|a2
condition|)
block|{
operator|*
name|a1
operator|++
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|nl
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HUGE
name|bp
operator|=
name|getblock
argument_list|(
name|tl
operator|+=
name|_2
index|[
name|hugef
index|]
argument_list|,
name|READ
argument_list|)
expr_stmt|;
else|#
directive|else
name|bp
operator|=
name|getblock
argument_list|(
name|tl
operator|+=
name|_2
argument_list|,
name|READ
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nl
operator|=
name|nleft
operator|/
sizeof|sizeof
argument_list|(
name|linep
argument_list|)
expr_stmt|;
block|}
block|}
name|dot
operator|=
name|a2
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|ndeleted
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UNDO
end_ifdef

begin_macro
name|undo
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|linep
modifier|*
name|a
decl_stmt|,
name|t
decl_stmt|,
name|o
decl_stmt|;
if|if
condition|(
name|undo_newp
operator|==
literal|0
operator|||
operator|(
name|a
operator|=
name|findmark
argument_list|(
name|undo_newp
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|errmsg
argument_list|(
literal|13
argument_list|)
expr_stmt|;
name|t
operator|=
operator|*
name|a
operator||
ifdef|#
directive|ifdef
name|HUGE
name|hugef
operator|^
endif|#
directive|endif
literal|01
expr_stmt|;
name|o
operator|=
name|undo_oldp
expr_stmt|;
name|savemark
argument_list|(
operator|*
name|a
argument_list|,
name|o
argument_list|)
expr_stmt|;
operator|*
name|a
operator|=
name|o
expr_stmt|;
name|undo_newp
operator|=
name|o
expr_stmt|;
name|undo_oldp
operator|=
name|t
expr_stmt|;
name|dot
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|text_modified
operator|==
literal|0
condition|)
name|text_modified
operator|++
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|white_space
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|charac
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
empty_stmt|;
name|peekc
operator|=
name|c
expr_stmt|;
block|}
end_block

begin_macro
name|wte
argument_list|(
argument|fd
argument_list|,
argument|buf
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
name|buf
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
name|errmsg
argument_list|(
operator|-
literal|32
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * as	a prompt string  * ay	yes response, !no response  * ad	default (\n) response,<0 means no default allowed  * aef	end-of-file response  */
end_comment

begin_macro
name|yes_no
argument_list|(
argument|as
argument_list|,
argument|ay
argument_list|,
argument|ad
argument_list|,
argument|aef
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|as
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|charac
name|c
decl_stmt|,
name|p
decl_stmt|;
specifier|register
name|n
expr_stmt|;
specifier|register
name|flag
name|l
decl_stmt|;
name|l
operator|=
name|listf
expr_stmt|;
name|listf
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|peekc
expr_stmt|;
name|peekc
operator|=
literal|0
expr_stmt|;
for|for ever
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|puts2
argument_list|(
literal|"? "
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|5
condition|;
name|n
operator|++
control|)
block|{
name|flush_buf
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|n
operator|=
name|aef
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|skip_rest
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|ad
operator|>=
literal|0
condition|)
block|{
name|n
operator|=
name|ad
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'y'
operator|||
name|c
operator|==
literal|'n'
condition|)
block|{
name|n
operator|=
name|ay
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'y'
condition|)
name|n
operator|^=
literal|01
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|puts2
argument_list|(
literal|"yes or no? "
argument_list|)
expr_stmt|;
block|}
block|}
name|ret
label|:
name|listf
operator|=
name|l
expr_stmt|;
name|peekc
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

end_unit

