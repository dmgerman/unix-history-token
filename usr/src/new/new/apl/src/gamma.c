begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|Sccsid
index|[]
init|=
literal|"gamma.c @(#)gamma.c	1.1	10/1/82 Berkeley "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	C program for floating point log gamma function  	gamma(x) computes the log of the absolute 	value of the gamma function. 	The sign of the gamma function is returned in the 	external quantity signgam.  	The coefficients for expansion around zero 	are #5243 from Hart& Cheney; for expansion 	around infinity they are #5404.  	Calls log and sin. */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_decl_stmt
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|signgam
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|goobie
init|=
literal|0.9189385332046727417803297
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|pi
init|=
literal|3.1415926535897932384626434
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|M
value|6
end_define

begin_define
define|#
directive|define
name|N
value|8
end_define

begin_decl_stmt
specifier|static
name|double
name|p1
index|[]
init|=
block|{
literal|0.83333333333333101837e-1
block|,
operator|-
literal|.277777777735865004e-2
block|,
literal|0.793650576493454e-3
block|,
operator|-
literal|.5951896861197e-3
block|,
literal|0.83645878922e-3
block|,
operator|-
literal|.1633436431e-2
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|p2
index|[]
init|=
block|{
operator|-
literal|.42353689509744089647e5
block|,
operator|-
literal|.20886861789269887364e5
block|,
operator|-
literal|.87627102978521489560e4
block|,
operator|-
literal|.20085274013072791214e4
block|,
operator|-
literal|.43933044406002567613e3
block|,
operator|-
literal|.50108693752970953015e2
block|,
operator|-
literal|.67449507245925289918e1
block|,
literal|0.0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|q2
index|[]
init|=
block|{
operator|-
literal|.42353689509744090010e5
block|,
operator|-
literal|.29803853309256649932e4
block|,
literal|0.99403074150827709015e4
block|,
operator|-
literal|.15286072737795220248e4
block|,
operator|-
literal|.49902852662143904834e3
block|,
literal|0.18949823415702801641e3
block|,
operator|-
literal|.23081551524580124562e2
block|,
literal|0.10000000000000000000e1
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|double
name|gamma
parameter_list|(
name|arg
parameter_list|)
name|double
name|arg
decl_stmt|;
block|{
name|double
name|log
argument_list|()
decl_stmt|,
name|pos
argument_list|()
decl_stmt|,
name|neg
argument_list|()
decl_stmt|,
name|asym
argument_list|()
decl_stmt|;
name|signgam
operator|=
literal|1.
expr_stmt|;
if|if
condition|(
name|arg
operator|<=
literal|0.
condition|)
return|return
operator|(
name|neg
argument_list|(
name|arg
argument_list|)
operator|)
return|;
if|if
condition|(
name|arg
operator|>
literal|8.
condition|)
return|return
operator|(
name|asym
argument_list|(
name|arg
argument_list|)
operator|)
return|;
return|return
operator|(
name|log
argument_list|(
name|pos
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|double
name|asym
parameter_list|(
name|arg
parameter_list|)
name|double
name|arg
decl_stmt|;
block|{
name|double
name|log
parameter_list|()
function_decl|;
name|double
name|n
decl_stmt|,
name|argsq
decl_stmt|;
name|int
name|i
decl_stmt|;
name|argsq
operator|=
literal|1.
operator|/
operator|(
name|arg
operator|*
name|arg
operator|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|i
operator|=
name|M
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|n
operator|=
name|n
operator|*
name|argsq
operator|+
name|p1
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|arg
operator|-
literal|.5
operator|)
operator|*
name|log
argument_list|(
name|arg
argument_list|)
operator|-
name|arg
operator|+
name|goobie
operator|+
name|n
operator|/
name|arg
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|double
name|neg
parameter_list|(
name|arg
parameter_list|)
name|double
name|arg
decl_stmt|;
block|{
name|double
name|temp
decl_stmt|;
name|double
name|log
argument_list|()
decl_stmt|,
name|sin
argument_list|()
decl_stmt|,
name|pos
argument_list|()
decl_stmt|;
name|arg
operator|=
operator|-
name|arg
expr_stmt|;
name|temp
operator|=
name|sin
argument_list|(
name|pi
operator|*
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0.
condition|)
block|{
name|errno
operator|=
name|EDOM
expr_stmt|;
return|return
operator|(
name|HUGE
operator|)
return|;
block|}
if|if
condition|(
name|temp
operator|<
literal|0.
condition|)
name|temp
operator|=
operator|-
name|temp
expr_stmt|;
else|else
name|signgam
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
operator|-
name|log
argument_list|(
name|arg
operator|*
name|pos
argument_list|(
name|arg
argument_list|)
operator|*
name|temp
operator|/
name|pi
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|double
name|pos
parameter_list|(
name|arg
parameter_list|)
name|double
name|arg
decl_stmt|;
block|{
name|double
name|n
decl_stmt|,
name|d
decl_stmt|,
name|s
decl_stmt|;
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|arg
operator|<
literal|2.
condition|)
return|return
operator|(
name|pos
argument_list|(
name|arg
operator|+
literal|1.
argument_list|)
operator|/
name|arg
operator|)
return|;
if|if
condition|(
name|arg
operator|>
literal|3.
condition|)
return|return
operator|(
operator|(
name|arg
operator|-
literal|1.
operator|)
operator|*
name|pos
argument_list|(
name|arg
operator|-
literal|1.
argument_list|)
operator|)
return|;
name|s
operator|=
name|arg
operator|-
literal|2.
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|d
operator|=
literal|0
operator|,
name|i
operator|=
name|N
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|n
operator|=
name|n
operator|*
name|s
operator|+
name|p2
index|[
name|i
index|]
expr_stmt|;
name|d
operator|=
name|d
operator|*
name|s
operator|+
name|q2
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|/
name|d
operator|)
return|;
block|}
end_function

end_unit

