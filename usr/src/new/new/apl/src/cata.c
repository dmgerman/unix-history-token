begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|Sccsid
index|[]
init|=
literal|"cata.c @(#)cata.c	1.1	10/1/82 Berkeley "
decl_stmt|;
end_decl_stmt

begin_empty
empty|#
end_empty

begin_comment
comment|/*  cata.c	-- cat files in apl format  Usage:  cata file1 file2 file3... 	catb file1 file2 file3..... 	cata [-bl] file1 file2 file3... can also be used as a filter, i.e.  cat file ^ cata ^ opr  cat? copies each line from the input file to the output file, preceding each line with the line number in brackets. the first line of each file is assumed to be the function name and is printed without a line number.  cata performs overprints by backspacing and printing the overprint character directly on top of the base character. catb captures each overprinted character and prints it on the line after its occurance, underneath the character that formed the base of the overprint.  cata.c is the program used to generate the binary: the binary is linked to two file names: cata and catb the program checks to detemine which one was called and executes accordingly. cata and catb are generated by compiling cata.c : 	cc cata.c -m -O ; mv a.out cata 	ln cata catb note:   cata and catb must be linked together  flags: Two flags are currently available to cata. -l disables the printing of line numbers. -b puts cata into the catb mode of printing lines. examples: 	cata -l w1	print w1 in cata mode without line numbers 	cata -b w1	print w1 in catb mode 	cata -bl w1	print w1 in catb mode without line numbers 	cata w1		print w1 in cata mode  as of 10/23/78 cata and catb are linked together. using catb is equivilent to typing:  cata  -b default argument is to print line numbers and use cata mode. hopefully at the beginning of spring 79 semester, catb will be removed and apl users will use cata -b  to perform the same function.   author:  a.p. reeves 10/21/78 modified for buffered i/o and fixed 'blank line' bug added dual link ability added -l and -b flags. r.l. reeves  01/15/79 modified for standard i/o package John Bruner */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_decl_stmt
name|FILE
modifier|*
name|infile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file pointer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|,
name|line
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* overprint buffer for catb mode */
end_comment

begin_comment
comment|/* buf will be called newprint buffer */
end_comment

begin_decl_stmt
name|int
name|catb
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* catb mode if non-zero */
end_comment

begin_decl_stmt
name|int
name|lflg
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list line numbers if non-zero */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|iarg
decl_stmt|;
comment|/* index of string being processed from argument list */
specifier|register
name|int
name|frstim
decl_stmt|;
comment|/* first time flag--on if first time */
comment|/* through main printing loop */
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
comment|/* point to char in flag argument */
specifier|extern
name|char
name|_sobuf
index|[]
decl_stmt|;
comment|/* force buffering */
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|_sobuf
argument_list|)
expr_stmt|;
comment|/* set up newprint buffer to have leading tab */
operator|*
name|line
operator|=
literal|'\t'
expr_stmt|;
name|buf
operator|=
operator|&
name|line
index|[
literal|1
index|]
expr_stmt|;
comment|/* 	* detect which file is being run of the two 	* possible file links. 	* set catb if file 'catb' is running 	*/
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|==
literal|'b'
condition|)
name|catb
operator|++
expr_stmt|;
name|iarg
operator|=
literal|1
expr_stmt|;
comment|/* 	* check for flag argument 	*/
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
operator|*
name|argv
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|ap
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|ap
condition|)
switch|switch
condition|(
operator|*
name|ap
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* set catb mode */
name|catb
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* no line numbers */
name|lflg
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|iarg
operator|++
expr_stmt|;
block|}
name|frstim
operator|=
literal|1
expr_stmt|;
comment|/* first time through main loop, print std input */
comment|/* in case no files given */
while|while
condition|(
name|argc
operator|>
name|iarg
operator|||
name|frstim
condition|)
block|{
if|if
condition|(
name|argc
operator|>
name|iarg
condition|)
block|{
comment|/* process argument list of files */
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|open
argument_list|(
name|argv
index|[
name|iarg
index|]
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"can't open input file: %s\n"
argument_list|,
name|argv
index|[
name|iarg
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|catfil
argument_list|()
expr_stmt|;
comment|/* print file */
name|frstim
operator|=
literal|0
expr_stmt|;
comment|/* advance to next file in argument list */
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|iarg
operator|++
expr_stmt|;
block|}
comment|/* end while */
comment|/* dump buffers and exit */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end main */
end_comment

begin_comment
comment|/* * catfil -- routine to print current file to standard output */
end_comment

begin_macro
name|catfil
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|new
decl_stmt|,
name|orig
decl_stmt|;
comment|/* index into newprint buffer */
comment|/* and original input buffer */
name|int
name|lincnt
decl_stmt|;
comment|/* line counter */
specifier|register
name|char
name|c
decl_stmt|;
comment|/* character read in from input */
comment|/* copy first line in file verbatim -- this is function name */
name|printf
argument_list|(
literal|"\n\n\t"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|putchar
argument_list|(
name|c
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return;
comment|/* * copy remainder of file placing line numbers in front * of each line. */
name|lincnt
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
block|{
name|new
operator|=
name|orig
operator|=
literal|0
expr_stmt|;
comment|/* print line number */
if|if
condition|(
name|lflg
condition|)
name|printf
argument_list|(
literal|" [%d]\t%c"
argument_list|,
name|lincnt
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\t%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* if not end of line, copy until then */
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|catb
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\b'
condition|)
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|orig
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|new
operator|<
name|orig
condition|)
name|buf
index|[
name|new
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|c
operator|=
name|buf
index|[
name|new
operator|++
index|]
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* perform newprint if needed */
if|if
condition|(
name|catb
operator|&&
name|new
condition|)
block|{
name|buf
index|[
name|new
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buf
index|[
name|new
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return;
comment|/* increment line counter */
name|lincnt
operator|++
expr_stmt|;
block|}
return|return;
block|}
end_block

end_unit

