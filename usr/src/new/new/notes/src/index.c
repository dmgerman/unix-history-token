begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"%W%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * INPUT KEY PROCESSING FOR INDEX PHASE   *  *	Process all keystrokes while the index page is on the screen.  *	invokes director options also (if user qualified)  *	Returns:>=0 read note with that number ( 0 is policy)  *		 -1	reprint the index page  *		 -2	leave notefiles, update sequencer time  *		 -3	leave notefile, dont update sequencer  *		 -4	Universal leave notefiles  *			(-2 and -3 leave single notefile, -4 leaves  *			entire package, aborting rest of notefiles.  *  *	Original Coding:	Rob Kolstad	Winter 1980  *	modifications:		Ray Essick	December 1981  *	modifications:		Lou Salkind	March 1983  */
end_comment

begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_include
include|#
directive|include
file|"newsgate.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_macro
name|indx
argument_list|(
argument|io
argument_list|,
argument|firstdis
argument_list|,
argument|lastdis
argument_list|,
argument|respnum
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|firstdis
decl_stmt|,
modifier|*
name|lastdis
decl_stmt|,
modifier|*
name|respnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|io_f
name|io2
decl_stmt|;
comment|/* for nested notefiles */
name|struct
name|when_f
name|whendump
decl_stmt|;
name|char
name|nfname
index|[
name|NNLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* for nested nfs */
name|char
name|cmdline
index|[
name|CMDLEN
index|]
decl_stmt|;
name|int
name|num
decl_stmt|;
comment|/* note number */
name|int
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|znote
decl_stmt|,
name|zresp
decl_stmt|;
comment|/* for asearch */
name|int
name|temp
decl_stmt|;
name|int
name|retstat
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|notesenv
name|oldenv
decl_stmt|;
operator|*
name|respnum
operator|=
literal|0
expr_stmt|;
comment|/* init response */
name|ignsigs
operator|=
literal|0
expr_stmt|;
name|replot
operator|=
literal|1
expr_stmt|;
name|oldenv
operator|=
name|curenv
expr_stmt|;
name|setjmp
argument_list|(
name|jenv
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|replot
condition|)
block|{
name|replot
operator|=
literal|0
expr_stmt|;
name|prntind
argument_list|(
name|io
argument_list|,
name|firstdis
argument_list|,
name|lastdis
argument_list|)
expr_stmt|;
block|}
name|cmdprompt
argument_list|()
expr_stmt|;
name|c
operator|=
name|gchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* what to do? */
case|case
literal|'z'
case|:
comment|/* update sequencer and exit, RLS */
name|retstat
operator|=
name|QUITUPD
expr_stmt|;
goto|goto
name|out
goto|;
case|case
literal|'u'
case|:
comment|/* unsubscribe from this notesgroup, RLS */
if|if
condition|(
name|unsubscribe
argument_list|(
name|io
operator|->
name|nf
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
name|retstat
operator|=
name|QUITSEQ
expr_stmt|;
goto|goto
name|out
goto|;
case|case
literal|'?'
case|:
case|case
literal|'h'
case|:
name|help
argument_list|(
name|INDXHLP
argument_list|)
expr_stmt|;
comment|/* put the help on screen */
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
comment|/* replot the index page */
case|case
literal|'\014'
case|:
comment|/* everyone else uses ^L, might as well */
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'W'
case|:
comment|/* this too shall write a note */
case|case
literal|'w'
case|:
comment|/* write a note */
name|temp
operator|=
name|addnote
argument_list|(
name|io
argument_list|,
name|NULL
argument_list|,
literal|"Edit Note text:"
argument_list|,
literal|"Note Title: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
operator|-
literal|1
condition|)
block|{
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|NEWS
comment|/* 			 * fix to allow the user to specify whether 			 * the article should be local or net'ed 			 */
if|if
condition|(
operator|(
name|io
operator|->
name|descr
operator|.
name|d_stat
operator|&
name|NETWRKD
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				    prompt("(Not networked)"); 				    fflush(stdout); 				    sleep(2); 				*/
name|retstat
operator|=
name|temp
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|prompt
argument_list|(
literal|"Send to news? "
argument_list|)
expr_stmt|;
if|if
condition|(
name|askyn
argument_list|()
operator|==
literal|'y'
condition|)
block|{
ifdef|#
directive|ifdef
name|DEMANDNEWS
comment|/* send it to the news */
name|sprintf
argument_list|(
name|cmdline
argument_list|,
literal|"%s/%s/newsoutput"
argument_list|,
name|MSTDIR
argument_list|,
name|UTILITY
argument_list|)
expr_stmt|;
name|dounix
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|cmdline
argument_list|,
name|io
operator|->
name|nf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEMANDNEWS
block|}
else|else
block|{
comment|/* don't send it to the network */
name|gettime
argument_list|(
operator|&
name|whendump
argument_list|)
expr_stmt|;
name|fixlast
argument_list|(
operator|&
name|whendump
argument_list|,
name|io
operator|->
name|nf
argument_list|,
literal|1
argument_list|,
name|NEWSSYS
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|NEWS
name|retstat
operator|=
name|temp
expr_stmt|;
goto|goto
name|out
goto|;
case|case
literal|'B'
case|:
comment|/* bitch, bitch, bitch */
if|if
condition|(
name|init
argument_list|(
operator|&
name|io2
argument_list|,
name|GRIPES
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* no gripe file */
name|warn
argument_list|(
literal|"Gripe file not available"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|temp
operator|=
name|addnote
argument_list|(
operator|&
name|io2
argument_list|,
name|NULL
argument_list|,
literal|"Edit Gripe text:"
argument_list|,
literal|"Gripe Header: "
argument_list|)
expr_stmt|;
comment|/* let him put the note in */
name|finish
argument_list|(
operator|&
name|io2
argument_list|)
expr_stmt|;
comment|/* close up the gripe file */
if|if
condition|(
name|temp
operator|==
operator|-
literal|1
condition|)
block|{
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|replot
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
case|case
literal|'-'
case|:
comment|/* back up a little */
case|case
literal|'\b'
case|:
comment|/* add backspace also */
if|if
condition|(
operator|*
name|firstdis
operator|!=
literal|1
condition|)
block|{
operator|*
name|firstdis
operator|-=
name|nindex
operator|-
literal|1
expr_stmt|;
name|replot
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|warn
argument_list|(
literal|"On first page"
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'='
case|:
comment|/* back up a lot */
if|if
condition|(
operator|*
name|firstdis
operator|!=
literal|1
condition|)
block|{
operator|*
name|firstdis
operator|=
literal|1
expr_stmt|;
name|replot
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|warn
argument_list|(
literal|"On first page"
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'+'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
case|case
literal|' '
case|:
if|if
condition|(
operator|*
name|lastdis
operator|<
name|io
operator|->
name|descr
operator|.
name|d_nnote
condition|)
block|{
operator|*
name|firstdis
operator|=
operator|*
name|lastdis
expr_stmt|;
name|replot
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|warn
argument_list|(
literal|"On last page"
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'*'
case|:
comment|/* skip to last page */
if|if
condition|(
operator|*
name|lastdis
operator|<
name|io
operator|->
name|descr
operator|.
name|d_nnote
condition|)
block|{
operator|*
name|firstdis
operator|=
name|io
operator|->
name|descr
operator|.
name|d_nnote
operator|-
name|nindex
operator|+
literal|1
expr_stmt|;
name|replot
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|warn
argument_list|(
literal|"Already on last page"
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'q'
case|:
case|case
literal|'k'
case|:
comment|/* so can use just right hand */
name|retstat
operator|=
name|QUITSEQ
expr_stmt|;
goto|goto
name|out
goto|;
case|case
literal|'\04'
case|:
comment|/* control D */
name|retstat
operator|=
name|QUITFAST
expr_stmt|;
goto|goto
name|out
goto|;
case|case
literal|'Q'
case|:
comment|/* exit without update of sequencer */
case|case
literal|'K'
case|:
comment|/* so can use just right hand */
name|retstat
operator|=
name|QUITNOSEQ
expr_stmt|;
goto|goto
name|out
goto|;
case|case
literal|'n'
case|:
comment|/* nest notesfiles - a stack */
name|prompt
argument_list|(
literal|"New notesfile: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|gline
argument_list|(
name|nfname
argument_list|,
name|NNLEN
argument_list|)
operator|==
literal|1
condition|)
continue|continue;
name|closenf
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|/* save fids */
name|i
operator|=
name|control
argument_list|(
name|nfname
argument_list|,
name|NOSEQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|opennf
argument_list|(
name|io
argument_list|,
name|io
operator|->
name|nf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Couldn't reopen notesfile"
argument_list|)
expr_stmt|;
name|wfchar
argument_list|()
expr_stmt|;
name|retstat
operator|=
name|QUITNOSEQ
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|i
operator|==
name|QUITNEX
operator|||
name|i
operator|==
name|QUITBAD
condition|)
block|{
name|warn
argument_list|(
literal|"Can not open notesfile `%s'"
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|i
operator|==
name|QUITFAST
operator|||
name|i
operator|==
name|QUITUPD
condition|)
block|{
name|retstat
operator|=
name|i
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
comment|/* to read note 0 */
if|if
condition|(
name|io
operator|->
name|descr
operator|.
name|d_plcy
condition|)
block|{
name|retstat
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|warn
argument_list|(
literal|"There is no policy note"
argument_list|)
expr_stmt|;
continue|continue;
comment|/* grab another key */
block|}
case|case
literal|'d'
case|:
comment|/* to director options */
if|if
condition|(
name|allow
argument_list|(
name|io
argument_list|,
name|DRCTOK
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|direct
argument_list|(
name|io
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|retstat
operator|=
name|i
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 			 * fix the allow the user to see things 			 * the director can see 			 */
name|prompt
argument_list|(
literal|"Anonymous: %s 	  Networked: %s"
argument_list|,
operator|(
name|io
operator|->
name|descr
operator|.
name|d_stat
operator|&
name|ANONOK
operator|)
condition|?
literal|"YES"
else|:
literal|"NO"
argument_list|,
operator|(
name|io
operator|->
name|descr
operator|.
name|d_stat
operator|&
name|NETWRKD
operator|)
condition|?
literal|"YES"
else|:
literal|"NO"
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|i
operator|=
name|tsearch
argument_list|(
name|io
argument_list|,
operator|*
name|lastdis
argument_list|,
name|c
operator|==
literal|'x'
argument_list|)
expr_stmt|;
comment|/* assume lies before here */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|retstat
operator|=
name|i
expr_stmt|;
goto|goto
name|out
goto|;
block|}
continue|continue;
comment|/* otherwise get another key */
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
comment|/* author search from current spot */
name|znote
operator|=
operator|*
name|lastdis
expr_stmt|;
name|zresp
operator|=
literal|0
expr_stmt|;
comment|/* start at the correct place */
name|i
operator|=
name|asearch
argument_list|(
name|io
argument_list|,
operator|&
name|znote
argument_list|,
operator|&
name|zresp
argument_list|,
operator|(
name|c
operator|==
literal|'a'
operator|)
argument_list|)
expr_stmt|;
comment|/* look */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
operator|*
name|respnum
operator|=
name|zresp
expr_stmt|;
comment|/* return correct value */
name|retstat
operator|=
name|znote
expr_stmt|;
goto|goto
name|out
goto|;
block|}
continue|continue;
comment|/* get another command */
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|prompt
argument_list|(
literal|"Read note> "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|num
operator|=
name|getnum
argument_list|(
name|c
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|retstat
operator|=
name|num
expr_stmt|;
goto|goto
name|out
goto|;
case|case
literal|'j'
case|:
case|case
literal|'J'
case|:
comment|/* goto first unread article */
case|case
literal|'l'
case|:
comment|/* universal seq, RLS */
case|case
literal|'L'
case|:
name|i
operator|=
name|nxtnote
argument_list|(
name|io
argument_list|,
literal|0
argument_list|,
operator|&
name|io
operator|->
name|stime
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
block|{
name|retstat
operator|=
name|i
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'l'
operator|||
name|c
operator|==
literal|'L'
condition|)
block|{
name|retstat
operator|=
name|QUITSEQ
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'o'
case|:
comment|/* modify sequencer time */
name|gdate
argument_list|(
operator|&
name|io
operator|->
name|stime
argument_list|)
expr_stmt|;
comment|/* let him hack on the time */
continue|continue;
comment|/* and go back */
case|case
literal|'O'
case|:
comment|/* set it for today's notes */
name|gettime
argument_list|(
operator|&
name|io
operator|->
name|stime
argument_list|)
expr_stmt|;
comment|/* grab current date */
name|io
operator|->
name|stime
operator|.
name|w_hours
operator|=
literal|0
expr_stmt|;
comment|/* beginning of day */
name|io
operator|->
name|stime
operator|.
name|w_mins
operator|=
literal|0
expr_stmt|;
name|prompt
argument_list|(
literal|"Set to read notes since: "
argument_list|)
expr_stmt|;
name|prdate
argument_list|(
operator|&
name|io
operator|->
name|stime
argument_list|)
expr_stmt|;
continue|continue;
comment|/* and get the next command */
case|case
literal|'!'
case|:
name|gshell
argument_list|()
expr_stmt|;
comment|/* give him a shell in right directory */
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
default|default:
name|warn
argument_list|(
literal|"? for help, q to quit"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|out
label|:
name|ignsigs
operator|++
expr_stmt|;
name|curenv
operator|=
name|oldenv
expr_stmt|;
name|ignsigs
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|retstat
operator|)
return|;
block|}
end_block

end_unit

