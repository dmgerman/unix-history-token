begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"%W% %G"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Routines to expand notesgroups specifications  *  *	Rick L Spickelmier, UC Berkeley  *	Lou Salkind, NYU  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|seqtyp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * set the sequencer type (external interface)  */
end_comment

begin_macro
name|setseq
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
name|seqtyp
operator|=
name|i
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * add a notesfile to the active list  */
end_comment

begin_macro
name|addgrp
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* see if it already exists */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_group
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmpn
argument_list|(
name|group
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|string
argument_list|,
literal|14
argument_list|)
operator|==
literal|0
condition|)
block|{
name|group
index|[
name|i
index|]
operator|.
name|lookat
operator|=
literal|1
expr_stmt|;
name|group
index|[
name|i
index|]
operator|.
name|seqtyp
operator|=
name|seqtyp
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|last_group
operator|>=
name|MAXGROUPS
condition|)
block|{
name|printf
argument_list|(
literal|"addgrp: ignoring %s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
name|group
index|[
name|last_group
index|]
operator|.
name|lookat
operator|=
literal|1
expr_stmt|;
name|group
index|[
name|last_group
index|]
operator|.
name|seqtyp
operator|=
name|seqtyp
expr_stmt|;
name|group
index|[
name|last_group
operator|++
index|]
operator|.
name|name
operator|=
name|strsave
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * delete the notesfile from the active list  */
end_comment

begin_macro
name|delete
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last_group
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmpn
argument_list|(
name|group
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|string
argument_list|,
literal|14
argument_list|)
operator|==
literal|0
condition|)
block|{
name|group
index|[
name|i
index|]
operator|.
name|lookat
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * given a command line argument, expand it into  * the appropriate sequence command or notesfile  * specification  */
end_comment

begin_macro
name|expand
argument_list|(
argument|argp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|argp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|endp
decl_stmt|;
name|again
label|:
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|argp
argument_list|)
condition|)
name|argp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|argp
operator|==
literal|'\0'
condition|)
return|return;
name|endp
operator|=
name|argp
expr_stmt|;
while|while
condition|(
operator|*
name|endp
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|endp
argument_list|)
operator|||
operator|*
name|endp
operator|==
literal|','
condition|)
block|{
operator|*
name|endp
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|endp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argp
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* sequencing options */
switch|switch
condition|(
name|argp
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* -S-equencer */
name|seqtyp
operator|=
name|NORMSEQ
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* e-X-tended sequencer */
name|seqtyp
operator|=
name|EXTSEQ
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* indexing sequencer */
name|seqtyp
operator|=
name|INDXSEQ
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* -N-o sequencer */
name|seqtyp
operator|=
name|NOSEQ
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* newsgroup specification */
if|if
condition|(
name|argp
index|[
literal|0
index|]
operator|==
literal|'!'
condition|)
block|{
comment|/* handle not's */
if|if
condition|(
name|patcheck
argument_list|(
operator|&
name|argp
index|[
literal|1
index|]
argument_list|)
condition|)
comment|/* wildcard */
name|dopat
argument_list|(
operator|&
name|argp
index|[
literal|1
index|]
argument_list|,
name|delete
argument_list|)
expr_stmt|;
else|else
name|delete
argument_list|(
operator|&
name|argp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|patcheck
argument_list|(
name|argp
argument_list|)
condition|)
name|dopat
argument_list|(
name|argp
argument_list|,
name|addgrp
argument_list|)
expr_stmt|;
else|else
name|addgrp
argument_list|(
name|argp
argument_list|)
expr_stmt|;
block|}
block|}
name|argp
operator|=
name|endp
expr_stmt|;
goto|goto
name|again
goto|;
comment|/*NOT REACHED*/
block|}
end_block

begin_comment
comment|/*  * read a file which contains the command line arguments  */
end_comment

begin_macro
name|readrc
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|s
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
operator|-
literal|1
argument_list|,
name|f
argument_list|)
condition|)
name|expand
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * unsubscribe to a notesfile  */
end_comment

begin_macro
name|unsubscribe
argument_list|(
argument|nfile
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|nfile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pid
decl_stmt|,
name|rpid
decl_stmt|;
name|int
name|retstat
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
function_decl|(
modifier|*
name|oint
function_decl|)
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|oquit
function_decl|)
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|ohup
function_decl|)
parameter_list|()
function_decl|;
comment|/* 	 * append the notesgroup name to thes 	 * end of the notesrc file 	 */
if|if
condition|(
name|notesrc
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"No notesrc file"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* fork off a child that can write the users notesrc */
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|x
argument_list|(
name|setuid
argument_list|(
name|globuid
argument_list|)
operator|<
literal|0
argument_list|,
literal|"readem: setuid/forked"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|notesrc
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"!%s\n"
argument_list|,
name|nfile
argument_list|)
expr_stmt|;
comment|/* append a not */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|ohup
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|oint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|oquit
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* wait here for the son to finish */
while|while
condition|(
operator|(
name|rpid
operator|=
name|wait
argument_list|(
operator|&
name|retstat
argument_list|)
operator|)
operator|!=
name|pid
operator|&&
name|rpid
operator|!=
operator|-
literal|1
condition|)
continue|continue;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|ohup
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|oint
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|oquit
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpid
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"unsubscribe: error in wait"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|retstat
condition|)
block|{
name|warn
argument_list|(
literal|"Can not open %s"
argument_list|,
name|notesrc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

