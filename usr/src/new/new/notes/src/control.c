begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"%W%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Code in this module ( control.c) is designed to process  *	a single notefile. Its paramters include the name of  *	the notefile to process and whether to use the sequencer.  *  *	Original author: Rob Kolstad	Winter, 1980.  *	Modifications:	Ray Essick	December, 1981.  */
end_comment

begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_macro
name|control
argument_list|(
argument|nfname
argument_list|,
argument|seqon
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|nfname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|io_f
name|io
decl_stmt|;
name|struct
name|note_f
name|note
decl_stmt|;
name|struct
name|when_f
name|entered
decl_stmt|;
comment|/* entry into notefile package */
name|struct
name|auth_f
name|whoami
decl_stmt|;
comment|/* for sequencer */
name|int
name|ret
decl_stmt|;
name|int
name|firstdis
decl_stmt|,
name|lastdis
decl_stmt|;
comment|/* display counters */
name|int
name|readnum
decl_stmt|;
comment|/* where to start reading notes */
name|int
name|respnum
decl_stmt|;
comment|/* response to be on */
comment|/* currently 0 always */
name|gettime
argument_list|(
operator|&
name|entered
argument_list|)
expr_stmt|;
comment|/* get the entry time */
if|if
condition|(
operator|(
name|ret
operator|=
name|init
argument_list|(
operator|&
name|io
argument_list|,
name|nfname
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|allow
argument_list|(
operator|&
name|io
argument_list|,
name|READOK
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|seqon
operator|==
name|NOSEQ
condition|)
block|{
comment|/* if sequencing, jus skip the thing */
name|printf
argument_list|(
literal|"You aren't allowed to read %s\n"
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|.
name|descr
operator|.
name|d_plcy
condition|)
block|{
name|prompt
argument_list|(
literal|"Do you wish to see the policy note? "
argument_list|)
expr_stmt|;
if|if
condition|(
name|askyn
argument_list|()
operator|==
literal|'y'
condition|)
block|{
comment|/* show the policy */
name|getnrec
argument_list|(
operator|&
name|io
argument_list|,
literal|0
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
name|dspnote
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|allow
argument_list|(
operator|&
name|io
argument_list|,
name|WRITOK
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"You may leave a note in the notefile\n"
argument_list|)
expr_stmt|;
name|prompt
argument_list|(
literal|"Do you wish to leave a note? "
argument_list|)
expr_stmt|;
if|if
condition|(
name|askyn
argument_list|()
operator|==
literal|'y'
condition|)
block|{
name|addnote
argument_list|(
operator|&
name|io
argument_list|,
name|NULL
argument_list|,
literal|"Edit Note Text:"
argument_list|,
literal|"Note title: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Your note has been registered\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|wfchar
argument_list|()
expr_stmt|;
block|}
name|finish
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|io
operator|.
name|descr
operator|.
name|d_stat
operator|&
name|OPEN
operator|)
operator|==
literal|0
condition|)
name|readnum
operator|=
name|QUITBAD
expr_stmt|;
if|if
condition|(
name|io
operator|.
name|descr
operator|.
name|d_stat
operator|&
name|OPEN
operator|||
name|allow
argument_list|(
operator|&
name|io
argument_list|,
name|DRCTOK
argument_list|)
condition|)
block|{
name|getname
argument_list|(
operator|&
name|whoami
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* grab his name */
name|getlast
argument_list|(
operator|&
name|io
operator|.
name|stime
argument_list|,
name|nfname
argument_list|,
name|seqon
argument_list|,
name|whoami
operator|.
name|aname
argument_list|)
expr_stmt|;
comment|/* find out last time he was here */
name|firstdis
operator|=
name|io
operator|.
name|descr
operator|.
name|d_nnote
operator|-
name|nindex
operator|+
literal|1
expr_stmt|;
name|respnum
operator|=
literal|0
expr_stmt|;
comment|/* make sure go to base note */
comment|/* 		 * if sequencer is off, stime is jan 1 1970, 		 * so will enter notefile 		 */
if|if
condition|(
name|inorder
argument_list|(
operator|&
name|io
operator|.
name|descr
operator|.
name|d_lastm
argument_list|,
operator|&
name|io
operator|.
name|stime
argument_list|)
operator|&&
operator|(
name|seqon
operator|==
name|NORMSEQ
operator|||
name|seqon
operator|==
name|INDXSEQ
operator|)
condition|)
block|{
name|finish
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|seqon
operator|==
name|NORMSEQ
operator|||
name|seqon
operator|==
name|EXTSEQ
condition|)
block|{
if|if
condition|(
operator|(
name|readnum
operator|=
name|nxtnote
argument_list|(
operator|&
name|io
argument_list|,
literal|0
argument_list|,
operator|&
name|io
operator|.
name|stime
argument_list|)
operator|)
operator|>
literal|0
condition|)
goto|goto
name|seqenter
goto|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|readnum
operator|=
name|indx
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|firstdis
argument_list|,
operator|&
name|lastdis
argument_list|,
operator|&
name|respnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|readnum
operator|<
operator|-
literal|1
condition|)
break|break;
name|seqenter
label|:
comment|/* if sequencer is on, we start here */
name|readnum
operator|=
name|readem
argument_list|(
operator|&
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|firstdis
argument_list|,
name|respnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|readnum
operator|<
operator|-
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|readnum
operator|==
name|QUITSEQ
operator|||
name|readnum
operator|==
name|QUITUPD
condition|)
comment|/* update his access list */
name|fixlast
argument_list|(
operator|&
name|entered
argument_list|,
name|nfname
argument_list|,
name|seqon
argument_list|,
name|whoami
operator|.
name|aname
argument_list|)
expr_stmt|;
comment|/* COULD CHECK FOR FAST TERMINATION HERE AND LONGJMP */
block|}
name|finish
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
return|return
operator|(
name|readnum
operator|)
return|;
comment|/* return the termination flag */
block|}
end_block

end_unit

