begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)miscio.c	1.3 2/3/83"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * miscio stuff:  *  * ttystrt/ttystop	switch back and forth to character-at-a-time mode  * catchem		makes our program ignore kills and coredumps.  * getnum		is a char at a time input routine  * gchar		sucks in 1 character and masks off parity.  */
end_comment

begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX4
name|.0
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #include<sys/ioctl.h> */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|modeset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* == 1 if ttyflags messed with */
end_comment

begin_decl_stmt
specifier|static
name|char
name|t_erase
decl_stmt|,
name|t_kill
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for tputs padding */
end_comment

begin_decl_stmt
name|int
name|replot
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX4
name|.0
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|termio
name|tty
decl_stmt|,
name|otty
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|oldmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prev mode bits */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|tty
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|ttystrt
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
ifdef|#
directive|ifdef
name|UNIX4
name|.0
name|x
argument_list|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|tty
argument_list|)
operator|<
literal|0
argument_list|,
literal|"ttystrt: gtty"
argument_list|)
expr_stmt|;
name|otty
operator|=
name|tty
expr_stmt|;
name|t_erase
operator|=
name|tty
operator|.
name|c_cc
index|[
name|VERASE
index|]
expr_stmt|;
name|t_kill
operator|=
name|tty
operator|.
name|c_cc
index|[
name|VKILL
index|]
expr_stmt|;
name|ospeed
operator|=
name|tty
operator|.
name|c_cflag
operator|&
name|CBAUD
expr_stmt|;
else|#
directive|else
else|UNIX4.0
ifdef|#
directive|ifdef
name|V6
name|x
argument_list|(
name|gtty
argument_list|(
literal|0
argument_list|,
operator|&
name|tty
argument_list|)
operator|<
literal|0
argument_list|,
literal|"ttystrt: gtty"
argument_list|)
expr_stmt|;
else|#
directive|else
else|V6
name|x
argument_list|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|tty
argument_list|)
operator|<
literal|0
argument_list|,
literal|"ttystrt: gtty"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|V6
name|oldmode
operator|=
name|tty
operator|.
name|sg_flags
expr_stmt|;
name|t_erase
operator|=
name|tty
operator|.
name|sg_erase
expr_stmt|;
name|t_kill
operator|=
name|tty
operator|.
name|sg_kill
expr_stmt|;
name|ospeed
operator|=
name|tty
operator|.
name|sg_ospeed
expr_stmt|;
endif|#
directive|endif
endif|UNIX4.0
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|modeset
condition|)
block|{
ifdef|#
directive|ifdef
name|UNIX4
name|.0
name|tty
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|ICANON
operator|)
expr_stmt|;
name|tty
operator|.
name|c_cc
index|[
name|VEOF
index|]
operator|=
literal|1
expr_stmt|;
name|tty
operator|.
name|c_cc
index|[
name|VEOL
index|]
operator|=
literal|1
expr_stmt|;
name|x
argument_list|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|tty
argument_list|)
operator|<
literal|0
argument_list|,
literal|"ttystrt: stty"
argument_list|)
expr_stmt|;
else|#
directive|else
else|UNIX4.0
name|tty
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
name|tty
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
ifdef|#
directive|ifdef
name|V6
name|x
argument_list|(
name|stty
argument_list|(
literal|0
argument_list|,
operator|&
name|tty
argument_list|)
operator|<
literal|0
argument_list|,
literal|"ttystrt: stty"
argument_list|)
expr_stmt|;
else|#
directive|else
else|V6
name|x
argument_list|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|tty
argument_list|)
operator|<
literal|0
argument_list|,
literal|"ttystrt: stty"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|V6
endif|#
directive|endif
endif|UNIX4.0
name|replot
operator|=
literal|1
expr_stmt|;
name|modeset
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|ttystop
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|modeset
condition|)
block|{
ifndef|#
directive|ifndef
name|UNIX4
name|.0
name|tty
operator|.
name|sg_flags
operator|=
name|oldmode
expr_stmt|;
ifdef|#
directive|ifdef
name|V6
if|if
condition|(
name|stty
argument_list|(
literal|0
argument_list|,
operator|&
name|tty
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
else|V6
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|tty
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
endif|V6
else|#
directive|else
else|UNIX4.0
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|otty
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
endif|UNIX4.0
name|printf
argument_list|(
literal|"ttystop: stty"
argument_list|)
expr_stmt|;
comment|/* can't use x() cause it calls us */
name|modeset
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * return 1 if there is input from the terminal,  * 0 otherwise.  systems without the appropriate  * call should always return 0.  */
end_comment

begin_macro
name|isinput
argument_list|()
end_macro

begin_block
block|{
ifndef|#
directive|ifndef
name|UNIX4
name|.0
name|long
name|retval
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|retval
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|retval
operator|!=
literal|0
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|ignsigs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|notesenv
name|curenv
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|osigint
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|osigquit
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* hold signal status */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|osigtstp
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* control-z job stop */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * the new fancy signal catcher.  * for interrupts and quits.  */
end_comment

begin_macro
name|catchint
argument_list|(
argument|signo
argument_list|)
end_macro

begin_block
block|{
name|signal
argument_list|(
name|signo
argument_list|,
name|catchint
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignsigs
condition|)
return|return;
if|if
condition|(
name|replot
operator|==
literal|0
condition|)
name|warn
argument_list|(
literal|"Interrupt"
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|jenv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_comment
comment|/*  * the new fancy signal handler  * for ^Z/SIGTSTP  */
end_comment

begin_macro
name|catchz
argument_list|()
end_macro

begin_block
block|{
name|int
name|wasset
decl_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|catchz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignsigs
condition|)
return|return;
if|if
condition|(
operator|(
name|wasset
operator|=
name|modeset
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* want assignment */
name|ttystop
argument_list|()
expr_stmt|;
comment|/* fix it up for user */
name|at
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* make sure it nabs us */
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* halt myself */
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|catchz
argument_list|)
expr_stmt|;
comment|/* ready to catch again */
if|if
condition|(
name|wasset
condition|)
name|ttystrt
argument_list|()
expr_stmt|;
comment|/* fix his tty */
name|longjmp
argument_list|(
name|jenv
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|catchem
argument_list|()
end_macro

begin_block
block|{
name|osigint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|catchint
argument_list|)
expr_stmt|;
comment|/* interrupts */
name|osigquit
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|catchint
argument_list|)
expr_stmt|;
comment|/* quits */
ifdef|#
directive|ifdef
name|SIGTSTP
name|osigtstp
operator|=
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|catchz
argument_list|)
expr_stmt|;
comment|/* control Z */
endif|#
directive|endif
block|}
end_block

begin_macro
name|uncatchem
argument_list|()
end_macro

begin_block
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|osigint
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|osigquit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|osigtstp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * get the next character from the terminal,  * stripping the parity bit  */
end_comment

begin_macro
name|gchar
argument_list|()
end_macro

begin_block
block|{
name|char
name|c
decl_stmt|;
name|int
name|ret
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* get rid of what's there */
while|while
condition|(
operator|(
name|ret
operator|=
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|)
operator|<=
literal|0
condition|)
comment|/* try again only if interrupted */
name|x
argument_list|(
name|ret
operator|==
literal|0
operator|||
name|errno
operator|!=
name|EINTR
argument_list|,
literal|"gchar: read error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|&
literal|0177
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * get a number from the user.  * c is the first digit (already typed).  */
end_comment

begin_macro
name|getnum
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|num
decl_stmt|,
name|numin
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|num
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|curpos
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
name|numin
operator|=
literal|1
expr_stmt|;
name|putch
argument_list|(
name|c
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|gchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\r'
condition|)
return|return
operator|(
name|num
operator|)
return|;
comment|/* done */
if|if
condition|(
name|c
operator|==
name|t_erase
condition|)
block|{
if|if
condition|(
name|numin
operator|>
literal|0
condition|)
block|{
name|num
operator|/=
literal|10
expr_stmt|;
name|numin
operator|--
expr_stmt|;
name|putstr
argument_list|(
literal|"\b \b"
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
name|t_kill
condition|)
block|{
name|num
operator|=
literal|0
expr_stmt|;
name|numin
operator|=
literal|0
expr_stmt|;
name|at
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
comment|/* valid character */
name|putch
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|numin
operator|++
expr_stmt|;
name|num
operator|=
literal|10
operator|*
name|num
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
else|else
name|putch
argument_list|(
literal|'\07'
argument_list|)
expr_stmt|;
block|}
comment|/*NOT REACHED*/
block|}
end_block

begin_comment
comment|/*  * gline( p, i) - suck a maximum of i characters from the tty.  * do erase and kill processing.  * The line is terminated by the user typing a<cr> or<nl>. This  * character is converted to null and left on the end of the  * string returned. The count of characters (including the null  * terminator) is returned.  * The array passed in is assumed to have i+1 elements  * (enough for the characters plus the terminator)  *  * Original Coding:	Ray Essick	December 1981  */
end_comment

begin_macro
name|gline
argument_list|(
argument|p
argument_list|,
argument|max
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|numin
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|q
operator|=
name|p
expr_stmt|;
name|numin
operator|=
literal|0
expr_stmt|;
name|curpos
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|gchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|t_erase
condition|)
block|{
if|if
condition|(
name|numin
operator|>
literal|0
condition|)
block|{
name|numin
operator|--
expr_stmt|;
name|q
operator|--
expr_stmt|;
name|putstr
argument_list|(
literal|"\b \b"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|<
literal|040
operator|||
operator|*
name|q
operator|==
literal|0177
condition|)
name|putstr
argument_list|(
literal|"\b \b"
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
name|t_kill
condition|)
block|{
name|at
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
name|numin
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
if|if
condition|(
name|numin
operator|>=
name|max
condition|)
block|{
name|p
index|[
name|max
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|max
operator|+
literal|1
operator|)
return|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|numin
operator|++
expr_stmt|;
return|return
operator|(
name|numin
operator|)
return|;
case|case
literal|'V'
operator|&
literal|037
case|:
comment|/* ^V */
case|case
literal|'\\'
case|:
comment|/* escape character */
name|putstr
argument_list|(
literal|"^\b"
argument_list|)
expr_stmt|;
comment|/* back space to it */
name|c
operator|=
name|gchar
argument_list|()
expr_stmt|;
comment|/* grab escaped character */
comment|/* FALL INTO ... */
default|default:
if|if
condition|(
name|numin
operator|<
name|max
condition|)
block|{
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
name|numin
operator|++
expr_stmt|;
name|mapch
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|putch
argument_list|(
literal|'\007'
argument_list|)
expr_stmt|;
comment|/* show him I ignored char */
break|break;
block|}
block|}
comment|/*NOT REACHED*/
block|}
end_block

begin_comment
comment|/*  * returns y or n to the asked question  */
end_comment

begin_macro
name|askyn
argument_list|()
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|curpos
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|gchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'y'
operator|||
name|c
operator|==
literal|'n'
condition|)
block|{
name|putch
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"  (working)"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
name|putchar
argument_list|(
literal|'\007'
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"  (y/n)"
argument_list|)
expr_stmt|;
name|at
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
comment|/*NOT REACHED*/
block|}
end_block

begin_macro
name|wfchar
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"--Hit any key to continue--"
argument_list|)
expr_stmt|;
name|gchar
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|warn
argument_list|(
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|at
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
expr_stmt|;
name|standout
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|standout
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|prompt
argument_list|(
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|at
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|cmdprompt
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|BERKELEY
name|int
name|set
init|=
name|LFLUSHO
decl_stmt|;
comment|/* fflush(stdout);	/* sigh... want a synchronous write here */
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCLBIC
argument_list|,
operator|&
name|set
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BERKELEY
name|at
argument_list|(
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMPT
name|putstr
argument_list|(
name|PROMPT
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PROMPT
block|}
end_block

begin_macro
name|putstr
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s
condition|)
name|putch
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * a putchar with all the fancy control  * character mapping  */
end_comment

begin_macro
name|mapch
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|c
operator|<
literal|040
operator|||
name|c
operator|==
literal|0177
condition|)
block|{
name|putch
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|040
condition|)
name|c
operator||=
literal|0100
expr_stmt|;
else|else
name|c
operator|=
literal|'?'
expr_stmt|;
block|}
name|putch
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

