begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"%W%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	this particular collection of junk handles the basic idea  *	of what to do when you are showing a note.  *	It displays the note, and then manages to collect enough info  *	from the terminal to either progress to the next note or  *	show some of the responses.  *  *	original author : rob kolstad  *	modified	: ray essick  *	yet again	: lou salkind  */
end_comment

begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_include
include|#
directive|include
file|"newsgate.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_macro
name|readem
argument_list|(
argument|io
argument_list|,
argument|readnum
argument_list|,
argument|firstdis
argument_list|,
argument|resp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|firstdis
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|note_f
name|note
decl_stmt|;
name|struct
name|resp_f
name|rsprec
decl_stmt|;
name|struct
name|io_f
name|io2
decl_stmt|;
name|struct
name|when_f
name|whendump
decl_stmt|;
name|FILE
modifier|*
name|txtfile
decl_stmt|;
name|FILE
modifier|*
name|ptxtfile
decl_stmt|;
name|FILE
modifier|*
name|pipeopen
parameter_list|()
function_decl|;
name|int
name|rrecnum
decl_stmt|,
name|roffset
decl_stmt|;
name|char
name|tonf
index|[
name|NNLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* for forwarding */
name|char
name|ntitle
index|[
name|TITLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* scratch space */
name|char
name|author
index|[
name|NAMESZ
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|system
index|[
name|SYSSZ
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|cmdline
index|[
name|CMDLEN
index|]
decl_stmt|;
comment|/* build-a-command */
name|char
name|tmpfile
index|[
name|CMDLEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* input char */
name|int
name|forward
decl_stmt|;
comment|/* scroll forward/backward on deleted note */
name|int
name|toauth
decl_stmt|;
comment|/* send to author */
name|int
name|znum
decl_stmt|;
comment|/* forward as resp to this note */
name|int
name|znote
decl_stmt|,
name|zresp
decl_stmt|;
comment|/* scratch for asearch */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|wtext
decl_stmt|;
comment|/* send mail with text */
name|int
name|retcode
decl_stmt|;
name|int
name|retstat
decl_stmt|;
name|struct
name|notesenv
name|oldenv
decl_stmt|;
name|char
modifier|*
name|delfile
decl_stmt|;
specifier|extern
name|char
modifier|*
name|myshell
decl_stmt|;
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* init so grabs character */
name|retstat
operator|=
literal|0
expr_stmt|;
comment|/* default return code */
name|forward
operator|=
literal|1
expr_stmt|;
comment|/* default to scroll forward */
name|ignsigs
operator|=
literal|0
expr_stmt|;
name|delfile
operator|=
name|NULL
expr_stmt|;
name|txtfile
operator|=
name|NULL
expr_stmt|;
name|replot
operator|=
literal|1
expr_stmt|;
name|oldenv
operator|=
name|curenv
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|jenv
argument_list|)
condition|)
block|{
comment|/* KLUDGE */
if|if
condition|(
name|txtfile
condition|)
block|{
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
name|txtfile
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|delfile
condition|)
block|{
name|unlink
argument_list|(
name|delfile
argument_list|)
expr_stmt|;
name|delfile
operator|=
name|NULL
expr_stmt|;
block|}
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|x
argument_list|(
name|readnum
operator|<
literal|0
argument_list|,
literal|"readem: given bad readnum"
argument_list|)
expr_stmt|;
if|if
condition|(
name|readnum
operator|>
name|io
operator|->
name|descr
operator|.
name|d_nnote
condition|)
block|{
comment|/* HMM... THIS SHOULD REALLY BE AN ERROR */
name|readnum
operator|=
name|io
operator|->
name|descr
operator|.
name|d_nnote
expr_stmt|;
block|}
if|if
condition|(
name|readnum
operator|==
literal|0
operator|&&
name|io
operator|->
name|descr
operator|.
name|d_plcy
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* empty notesfile */
name|getnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|.
name|n_stat
operator|&
name|DELETED
condition|)
block|{
if|if
condition|(
name|forward
condition|)
goto|goto
name|nextnt
goto|;
comment|/* forward scroll */
else|else
goto|goto
name|prevnt
goto|;
comment|/* backward scroll */
block|}
if|if
condition|(
name|replot
condition|)
block|{
name|replot
operator|=
literal|0
expr_stmt|;
comment|/* set later if want replot */
if|if
condition|(
name|resp
condition|)
block|{
comment|/* response */
if|if
condition|(
name|resp
operator|>
name|note
operator|.
name|n_nresp
condition|)
name|resp
operator|=
name|note
operator|.
name|n_nresp
expr_stmt|;
comment|/* set to the end */
if|if
condition|(
name|lrsp
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
name|resp
argument_list|,
operator|&
name|rsprec
argument_list|,
operator|&
name|roffset
argument_list|,
operator|&
name|rrecnum
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* bad response chain - print note instead */
name|resp
operator|=
literal|0
expr_stmt|;
name|getnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|dspnote
argument_list|(
name|io
argument_list|,
operator|&
name|note
argument_list|,
name|readnum
argument_list|)
expr_stmt|;
block|}
else|else
name|retcode
operator|=
name|dspresp
argument_list|(
name|io
argument_list|,
operator|&
name|note
argument_list|,
operator|&
name|rsprec
argument_list|,
name|roffset
argument_list|,
name|resp
argument_list|,
name|readnum
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* show the note if we need new one */
name|retcode
operator|=
name|dspnote
argument_list|(
name|io
argument_list|,
operator|&
name|note
argument_list|,
name|readnum
argument_list|)
expr_stmt|;
block|}
name|forward
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|retcode
operator|<
literal|0
condition|)
block|{
name|cmdprompt
argument_list|()
expr_stmt|;
comment|/* no previous command */
name|c
operator|=
name|gchar
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|retcode
expr_stmt|;
comment|/* previous command */
name|retcode
operator|=
operator|-
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'z'
case|:
comment|/* update sequencer and exit, RLS */
name|retstat
operator|=
name|QUITUPD
expr_stmt|;
goto|goto
name|out
goto|;
case|case
literal|'u'
case|:
comment|/* unsubscribe from this notesgroup, RLS */
if|if
condition|(
name|unsubscribe
argument_list|(
name|io
operator|->
name|nf
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
name|retstat
operator|=
name|QUITSEQ
expr_stmt|;
goto|goto
name|out
goto|;
case|case
literal|'?'
case|:
comment|/* if he doesn't know what to type */
case|case
literal|'h'
case|:
name|help
argument_list|(
name|RDMHLP
argument_list|)
expr_stmt|;
comment|/* print the pseudo-man page */
continue|continue;
case|case
literal|'D'
case|:
comment|/* delete this note/response */
if|if
condition|(
name|resp
condition|)
block|{
comment|/* check to see if his note */
if|if
condition|(
operator|(
name|rsprec
operator|.
name|r_auth
index|[
name|roffset
index|]
operator|.
name|aid
operator|&
name|UIDMASK
operator|)
operator|!=
name|globuid
operator|&&
operator|(
name|allow
argument_list|(
name|io
argument_list|,
name|DRCTOK
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|warn
argument_list|(
literal|"Not your response"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|note
operator|.
name|n_auth
operator|.
name|aid
operator|&
name|UIDMASK
operator|)
operator|!=
name|globuid
operator|&&
operator|(
name|allow
argument_list|(
name|io
argument_list|,
name|DRCTOK
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|warn
argument_list|(
literal|"Not your note"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Use 'Z' to delete policy"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|prompt
argument_list|(
literal|"Delete? "
argument_list|)
expr_stmt|;
if|if
condition|(
name|askyn
argument_list|()
operator|==
literal|'n'
condition|)
continue|continue;
name|lock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
comment|/* this should catch most */
name|getnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* and an up to date descriptor */
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
condition|)
block|{
comment|/* go about deleting it */
if|if
condition|(
name|resp
operator|==
name|note
operator|.
name|n_nresp
operator|&&
name|inorder
argument_list|(
operator|&
name|io
operator|->
name|descr
operator|.
name|d_lstxmit
argument_list|,
operator|&
name|rsprec
operator|.
name|r_when
index|[
name|roffset
index|]
argument_list|)
condition|)
block|{
name|delresp
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
name|rrecnum
argument_list|,
name|roffset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* adjust note response count */
name|note
operator|.
name|n_nresp
operator|--
expr_stmt|;
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
comment|/* show next response */
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|warn
argument_list|(
literal|"Can't delete: networked, or not last response"
argument_list|)
expr_stmt|;
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* it's a note */
if|if
condition|(
name|note
operator|.
name|n_nresp
operator|||
name|inorder
argument_list|(
operator|&
name|note
operator|.
name|n_date
argument_list|,
operator|&
name|io
operator|->
name|descr
operator|.
name|d_lstxmit
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"Can't delete; note has responses or is networked"
argument_list|)
expr_stmt|;
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|delnote
argument_list|(
name|io
argument_list|,
name|readnum
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|resp
operator|=
literal|0
expr_stmt|;
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'E'
case|:
comment|/* edit an article */
if|if
condition|(
name|resp
condition|)
block|{
comment|/* check to see if his note */
if|if
condition|(
operator|(
name|rsprec
operator|.
name|r_auth
index|[
name|roffset
index|]
operator|.
name|aid
operator|&
name|UIDMASK
operator|)
operator|!=
name|globuid
operator|&&
operator|(
name|allow
argument_list|(
name|io
argument_list|,
name|DRCTOK
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|warn
argument_list|(
literal|"Not your response"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|note
operator|.
name|n_auth
operator|.
name|aid
operator|&
name|UIDMASK
operator|)
operator|!=
name|globuid
operator|&&
operator|(
name|allow
argument_list|(
name|io
argument_list|,
name|DRCTOK
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|warn
argument_list|(
literal|"Not your note"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Sorry, E doesn't work for policy notes yet"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|lock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
name|getnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* this should catch most */
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* and an up to date descriptor */
if|if
condition|(
name|resp
condition|)
block|{
comment|/* go about deleting it */
if|if
condition|(
name|resp
operator|==
name|note
operator|.
name|n_nresp
operator|&&
name|inorder
argument_list|(
operator|&
name|io
operator|->
name|descr
operator|.
name|d_lstxmit
argument_list|,
operator|&
name|rsprec
operator|.
name|r_when
index|[
name|roffset
index|]
argument_list|)
condition|)
block|{
name|delresp
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
name|rrecnum
argument_list|,
name|roffset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* adjust note response count */
name|note
operator|.
name|n_nresp
operator|--
expr_stmt|;
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpfile
argument_list|,
literal|"/tmp/nfe%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|delfile
operator|=
name|tmpfile
expr_stmt|;
comment|/* build scr file */
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|tmpfile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem: scrfile"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|chmod
argument_list|(
name|tmpfile
argument_list|,
literal|0666
argument_list|)
operator|<
literal|0
argument_list|,
literal|"readem: chmod"
argument_list|)
expr_stmt|;
name|pageout
argument_list|(
name|io
argument_list|,
operator|&
name|rsprec
operator|.
name|r_addr
index|[
name|roffset
index|]
argument_list|,
name|txtfile
argument_list|)
expr_stmt|;
comment|/* dump it */
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
comment|/* also flushes it */
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|tmpfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem: edit reopen"
argument_list|)
expr_stmt|;
name|resp
operator|=
name|addresp
argument_list|(
name|io
argument_list|,
name|txtfile
argument_list|,
name|readnum
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
name|txtfile
operator|=
name|NULL
expr_stmt|;
comment|/* up to date */
name|getnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* add it back in ! */
name|x
argument_list|(
name|unlink
argument_list|(
name|tmpfile
argument_list|)
operator|<
literal|0
argument_list|,
literal|"readem: edit unlink"
argument_list|)
expr_stmt|;
name|delfile
operator|=
name|NULL
expr_stmt|;
continue|continue;
comment|/* show next response */
block|}
name|warn
argument_list|(
literal|"Can't edit: networked, or not last response"
argument_list|)
expr_stmt|;
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* its a note */
if|if
condition|(
name|note
operator|.
name|n_nresp
operator|||
name|inorder
argument_list|(
operator|&
name|note
operator|.
name|n_date
argument_list|,
operator|&
name|io
operator|->
name|descr
operator|.
name|d_lstxmit
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"Can't edit; note has responses or is networked"
argument_list|)
expr_stmt|;
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|delnote
argument_list|(
name|io
argument_list|,
name|readnum
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|resp
operator|=
literal|0
expr_stmt|;
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpfile
argument_list|,
literal|"/tmp/nfe%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|delfile
operator|=
name|tmpfile
expr_stmt|;
comment|/* build scr file */
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|tmpfile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem: scrfile"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|chmod
argument_list|(
name|tmpfile
argument_list|,
literal|0666
argument_list|)
operator|<
literal|0
argument_list|,
literal|"readem: chmod"
argument_list|)
expr_stmt|;
name|pageout
argument_list|(
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|,
name|txtfile
argument_list|)
expr_stmt|;
comment|/* dump it */
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
comment|/* also flushes it */
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|tmpfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem: edit reopen"
argument_list|)
expr_stmt|;
name|znum
operator|=
name|addnote
argument_list|(
name|io
argument_list|,
name|txtfile
argument_list|,
literal|"Edit note text:"
argument_list|,
literal|"Note title: "
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
name|txtfile
operator|=
name|NULL
expr_stmt|;
name|x
argument_list|(
name|unlink
argument_list|(
name|tmpfile
argument_list|)
operator|<
literal|0
argument_list|,
literal|"readem: edit unlink"
argument_list|)
expr_stmt|;
name|delfile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|znum
operator|>
literal|0
condition|)
name|readnum
operator|=
name|znum
expr_stmt|;
comment|/* this is the one */
continue|continue;
case|case
literal|'Z'
case|:
comment|/* zap notes/responses - directors only */
comment|/* kills any note/response */
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* up to date descriptor */
if|if
condition|(
name|allow
argument_list|(
name|io
argument_list|,
name|DRCTOK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Not a director"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|prompt
argument_list|(
literal|"Delete? "
argument_list|)
expr_stmt|;
if|if
condition|(
name|askyn
argument_list|()
operator|==
literal|'n'
condition|)
continue|continue;
comment|/* 			 *	should log the deletion here, so the 			 *	"meta-director" can watch for fascist 			 *	directors preying on the peasants. 			 */
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
block|{
comment|/* deleting policy */
name|lock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* grab up-to-date */
name|io
operator|->
name|descr
operator|.
name|d_plcy
operator|=
literal|0
expr_stmt|;
comment|/* its gone now */
comment|/* replace descriptor */
name|putdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|resp
condition|)
block|{
comment|/* delete a response */
name|delresp
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
name|rrecnum
argument_list|,
name|roffset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* kill it */
name|note
operator|.
name|n_nresp
operator|--
expr_stmt|;
comment|/* and response count */
block|}
else|else
name|delnote
argument_list|(
name|io
argument_list|,
name|readnum
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
comment|/* replot the current note/response */
case|case
literal|'\014'
case|:
comment|/* everyone else uses ^L, might as well */
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'\r'
case|:
comment|/* wants the next note */
case|case
literal|'\n'
case|:
goto|goto
name|nextnt
goto|;
case|case
literal|'m'
case|:
comment|/* mail a note/response via Unix mail */
name|toauth
operator|=
literal|0
expr_stmt|;
name|wtext
operator|=
literal|0
expr_stmt|;
comment|/* to others and no text */
goto|goto
name|sendmail
goto|;
case|case
literal|'M'
case|:
comment|/* same as 'm' but with text */
name|toauth
operator|=
literal|0
expr_stmt|;
name|wtext
operator|=
literal|1
expr_stmt|;
comment|/* to others with text */
goto|goto
name|sendmail
goto|;
case|case
literal|'P'
case|:
name|toauth
operator|=
literal|1
expr_stmt|;
name|wtext
operator|=
literal|1
expr_stmt|;
comment|/* to author with text */
goto|goto
name|sendmail
goto|;
case|case
literal|'p'
case|:
name|toauth
operator|=
literal|1
expr_stmt|;
name|wtext
operator|=
literal|0
expr_stmt|;
comment|/* to author, no text */
name|sendmail
label|:
comment|/* jump to here once set mail parms */
if|if
condition|(
name|resp
condition|)
block|{
name|mailit
argument_list|(
name|io
argument_list|,
operator|&
name|rsprec
operator|.
name|r_addr
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_auth
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_id
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_when
index|[
name|roffset
index|]
argument_list|,
name|io
operator|->
name|nf
argument_list|,
name|toauth
argument_list|,
name|wtext
argument_list|)
expr_stmt|;
block|}
else|else
name|mailit
argument_list|(
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|,
operator|&
name|note
operator|.
name|n_auth
argument_list|,
operator|&
name|note
operator|.
name|n_id
argument_list|,
operator|&
name|note
operator|.
name|n_date
argument_list|,
name|io
operator|->
name|nf
argument_list|,
name|toauth
argument_list|,
name|wtext
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'!'
case|:
comment|/* wants to fork a shell */
name|gshell
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'q'
case|:
comment|/* quit this, maybe whole system */
case|case
literal|'k'
case|:
name|retstat
operator|=
name|QUITSEQ
expr_stmt|;
goto|goto
name|out
goto|;
case|case
literal|'\04'
case|:
comment|/* control D */
name|retstat
operator|=
name|QUITFAST
expr_stmt|;
goto|goto
name|out
goto|;
case|case
literal|'Q'
case|:
comment|/* exit system without updating sequencer */
case|case
literal|'K'
case|:
name|retstat
operator|=
name|QUITNOSEQ
expr_stmt|;
goto|goto
name|out
goto|;
case|case
literal|'i'
case|:
comment|/* go back to note index */
operator|*
name|firstdis
operator|=
name|readnum
expr_stmt|;
goto|goto
name|out
goto|;
case|case
literal|'\010'
case|:
case|case
literal|'-'
case|:
comment|/* display previous response */
name|resp
operator|--
expr_stmt|;
if|if
condition|(
name|resp
operator|>=
literal|0
condition|)
block|{
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
comment|/* show the base note */
block|}
goto|goto
name|prevnt
goto|;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|retcode
operator|=
name|tsearch
argument_list|(
name|io
argument_list|,
name|readnum
operator|-
literal|1
argument_list|,
name|c
operator|==
literal|'x'
argument_list|)
expr_stmt|;
comment|/* look it up */
if|if
condition|(
name|retcode
operator|>
literal|0
condition|)
block|{
name|readnum
operator|=
name|retcode
expr_stmt|;
name|resp
operator|=
literal|0
expr_stmt|;
name|replot
operator|=
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
comment|/* author search from current spot */
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|znote
operator|=
name|readnum
expr_stmt|;
name|zresp
operator|=
name|resp
expr_stmt|;
if|if
condition|(
name|zresp
operator|==
literal|0
condition|)
name|znote
operator|--
expr_stmt|;
else|else
name|zresp
operator|++
expr_stmt|;
comment|/* select 'next' */
if|if
condition|(
name|asearch
argument_list|(
name|io
argument_list|,
operator|&
name|znote
argument_list|,
operator|&
name|zresp
argument_list|,
operator|(
name|c
operator|==
literal|'a'
operator|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|readnum
operator|=
name|znote
expr_stmt|;
name|resp
operator|=
name|zresp
expr_stmt|;
comment|/* set returned values */
comment|/* grab right descriptor */
name|getnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'d'
case|:
comment|/* toggle a notes director status */
if|if
condition|(
name|allow
argument_list|(
name|io
argument_list|,
name|DRCTOK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|prompt
argument_list|(
literal|"Anonymous: %s	Networked: %s"
argument_list|,
operator|(
name|io
operator|->
name|descr
operator|.
name|d_stat
operator|&
name|ANONOK
operator|)
condition|?
literal|"YES"
else|:
literal|"NO"
argument_list|,
operator|(
name|io
operator|->
name|descr
operator|.
name|d_stat
operator|&
name|NETWRKD
operator|)
condition|?
literal|"YES"
else|:
literal|"NO"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|resp
operator|==
literal|0
condition|)
block|{
comment|/* toggle a note */
name|lock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
name|getnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|.
name|n_stat
operator|&
name|DIRMES
condition|)
name|note
operator|.
name|n_stat
operator|&=
name|NOT
name|DIRMES
expr_stmt|;
else|else
name|note
operator|.
name|n_stat
operator||=
name|DIRMES
expr_stmt|;
name|putnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* replace */
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* toggle a response */
name|lock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
comment|/* grab that block */
name|getrrec
argument_list|(
name|io
argument_list|,
name|rrecnum
argument_list|,
operator|&
name|rsprec
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsprec
operator|.
name|r_stat
index|[
name|roffset
index|]
operator|&
name|DIRMES
condition|)
name|rsprec
operator|.
name|r_stat
index|[
name|roffset
index|]
operator|&=
name|NOT
name|DIRMES
expr_stmt|;
else|else
name|rsprec
operator|.
name|r_stat
index|[
name|roffset
index|]
operator||=
name|DIRMES
expr_stmt|;
name|putrrec
argument_list|(
name|io
argument_list|,
name|rrecnum
argument_list|,
operator|&
name|rsprec
argument_list|)
expr_stmt|;
comment|/* replace */
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'e'
case|:
comment|/* allow him to edit his title */
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
continue|continue;
comment|/* don't touch */
if|if
condition|(
name|resp
condition|)
block|{
name|warn
argument_list|(
literal|"Not reading note"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|allow
argument_list|(
name|io
argument_list|,
name|DRCTOK
argument_list|)
operator|==
literal|0
operator|&&
comment|/* check uid */
operator|(
name|globuid
operator|!=
operator|(
name|note
operator|.
name|n_auth
operator|.
name|aid
operator|&
name|UIDMASK
operator|)
operator|||
name|strcmp
argument_list|(
name|SYSTEM
argument_list|,
name|note
operator|.
name|n_id
operator|.
name|sys
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* other sys */
name|warn
argument_list|(
literal|"Not your note"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|prompt
argument_list|(
literal|"New Title: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|gline
argument_list|(
name|ntitle
argument_list|,
name|TITLEN
argument_list|)
operator|)
operator|==
literal|1
condition|)
comment|/* empty title, leave alone */
continue|continue;
name|lock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
name|getnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* well, update it */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
operator|-
literal|1
operator|&&
name|j
operator|<
name|TITLEN
condition|;
name|j
operator|++
control|)
name|note
operator|.
name|ntitle
index|[
name|j
index|]
operator|=
name|ntitle
index|[
name|j
index|]
expr_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|TITLEN
condition|;
name|j
operator|++
control|)
name|note
operator|.
name|ntitle
index|[
name|j
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* space fill */
name|putnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* and replace */
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'F'
case|:
comment|/* change author and system, RLS */
if|if
condition|(
name|allow
argument_list|(
name|io
argument_list|,
name|DRCTOK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Not a director"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|prompt
argument_list|(
literal|"New Author: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|gline
argument_list|(
name|author
argument_list|,
name|NAMESZ
argument_list|)
operator|)
operator|==
literal|1
condition|)
continue|continue;
name|prompt
argument_list|(
literal|"New System: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|gline
argument_list|(
name|system
argument_list|,
name|SYSSZ
argument_list|)
operator|)
operator|==
literal|1
condition|)
continue|continue;
name|lock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
literal|0
condition|)
block|{
comment|/* well, update it */
name|getnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|note
operator|.
name|n_auth
operator|.
name|aname
argument_list|,
name|author
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|note
operator|.
name|n_from
argument_list|,
name|system
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|note
operator|.
name|n_id
operator|.
name|sys
argument_list|,
name|system
argument_list|)
expr_stmt|;
name|note
operator|.
name|n_auth
operator|.
name|aid
operator|=
literal|0
expr_stmt|;
name|putnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* and replace */
block|}
else|else
block|{
comment|/* grab that block */
name|getrrec
argument_list|(
name|io
argument_list|,
name|rrecnum
argument_list|,
operator|&
name|rsprec
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rsprec
operator|.
name|r_auth
index|[
name|roffset
index|]
operator|.
name|aname
argument_list|,
name|author
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rsprec
operator|.
name|r_from
index|[
name|roffset
index|]
argument_list|,
name|system
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rsprec
operator|.
name|r_id
index|[
name|roffset
index|]
operator|.
name|sys
argument_list|,
name|system
argument_list|)
expr_stmt|;
name|rsprec
operator|.
name|r_auth
index|[
name|roffset
index|]
operator|.
name|aid
operator|=
literal|0
expr_stmt|;
name|putrrec
argument_list|(
name|io
argument_list|,
name|rrecnum
argument_list|,
operator|&
name|rsprec
argument_list|)
expr_stmt|;
comment|/* replace */
block|}
name|unlock
argument_list|(
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'t'
case|:
comment|/* talk to the author of a note */
if|if
condition|(
name|resp
condition|)
name|replot
operator|=
name|talkto
argument_list|(
operator|&
name|rsprec
operator|.
name|r_auth
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_id
index|[
name|roffset
index|]
argument_list|)
expr_stmt|;
else|else
name|replot
operator|=
name|talkto
argument_list|(
operator|&
name|note
operator|.
name|n_auth
argument_list|,
operator|&
name|note
operator|.
name|n_id
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'W'
case|:
comment|/* write a response with the text */
case|case
literal|'w'
case|:
comment|/* let him write a response */
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* get up to date */
if|if
condition|(
name|allow
argument_list|(
name|io
argument_list|,
name|RESPOK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Sorry, you are not allowed to write"
argument_list|)
expr_stmt|;
continue|continue;
comment|/* back to key processing */
block|}
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"No responses allowed to policy note"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'w'
condition|)
block|{
name|txtfile
operator|=
name|NULL
expr_stmt|;
comment|/* no preface text */
block|}
else|else
block|{
name|sprintf
argument_list|(
name|tmpfile
argument_list|,
literal|"/tmp/nfx%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|delfile
operator|=
name|tmpfile
expr_stmt|;
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|tmpfile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem: bad scrfile"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|chmod
argument_list|(
name|tmpfile
argument_list|,
literal|0666
argument_list|)
operator|<
literal|0
argument_list|,
literal|"readem: chmod failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
condition|)
block|{
name|preptxt
argument_list|(
name|io
argument_list|,
name|txtfile
argument_list|,
name|io
operator|->
name|nf
argument_list|,
operator|&
name|rsprec
operator|.
name|r_auth
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_id
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_when
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_addr
index|[
name|roffset
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|preptxt
argument_list|(
name|io
argument_list|,
name|txtfile
argument_list|,
name|io
operator|->
name|nf
argument_list|,
operator|&
name|note
operator|.
name|n_auth
argument_list|,
operator|&
name|note
operator|.
name|n_id
argument_list|,
operator|&
name|note
operator|.
name|n_date
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|tmpfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem: reopen"
argument_list|)
expr_stmt|;
block|}
name|zresp
operator|=
name|addresp
argument_list|(
name|io
argument_list|,
name|txtfile
argument_list|,
name|readnum
argument_list|)
expr_stmt|;
comment|/* put it in */
if|if
condition|(
name|zresp
operator|>
literal|0
condition|)
block|{
comment|/* update descriptor */
name|getnrec
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|txtfile
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
comment|/* toss out scratch */
name|txtfile
operator|=
name|NULL
expr_stmt|;
name|x
argument_list|(
name|unlink
argument_list|(
name|tmpfile
argument_list|)
operator|<
literal|0
argument_list|,
literal|"readem: couldnt unlink scratch"
argument_list|)
expr_stmt|;
name|delfile
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|zresp
condition|)
name|resp
operator|=
name|zresp
expr_stmt|;
comment|/* show the new */
if|if
condition|(
name|zresp
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|io
operator|->
name|descr
operator|.
name|d_stat
operator|&
name|NETWRKD
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				prompt("Not networked"); 				fflush(stdout); 				sleep(2); 			*/
continue|continue;
block|}
ifdef|#
directive|ifdef
name|NEWS
name|prompt
argument_list|(
literal|"Send to news? "
argument_list|)
expr_stmt|;
if|if
condition|(
name|askyn
argument_list|()
operator|==
literal|'y'
condition|)
block|{
ifdef|#
directive|ifdef
name|DEMANDNEWS
comment|/* send it to the news */
name|sprintf
argument_list|(
name|cmdline
argument_list|,
literal|"%s/%s/newsoutput"
argument_list|,
name|MSTDIR
argument_list|,
name|UTILITY
argument_list|)
expr_stmt|;
name|dounix
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|cmdline
argument_list|,
name|io
operator|->
name|nf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEMANDNEWS
block|}
else|else
block|{
comment|/* don't send it to the network */
name|gettime
argument_list|(
operator|&
name|whendump
argument_list|)
expr_stmt|;
name|fixlast
argument_list|(
operator|&
name|whendump
argument_list|,
name|io
operator|->
name|nf
argument_list|,
literal|1
argument_list|,
name|NEWSSYS
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|NEWS
continue|continue;
case|case
literal|'B'
case|:
comment|/* bitch, bitch, bitch */
comment|/* check gripe file */
if|if
condition|(
name|init
argument_list|(
operator|&
name|io2
argument_list|,
name|GRIPES
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"No gripe file"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|addnote
argument_list|(
operator|&
name|io2
argument_list|,
name|NULL
argument_list|,
literal|"Edit Gripe text:"
argument_list|,
literal|"Gripe Header: "
argument_list|)
expr_stmt|;
comment|/* let him put the note in */
name|finish
argument_list|(
operator|&
name|io2
argument_list|)
expr_stmt|;
comment|/* close up the gripe file */
continue|continue;
case|case
literal|'C'
case|:
comment|/* copy to other notefile with text */
case|case
literal|'c'
case|:
comment|/* copy to other notefile without text */
if|if
condition|(
name|c
operator|==
literal|'C'
condition|)
name|wtext
operator|=
literal|1
expr_stmt|;
else|else
name|wtext
operator|=
literal|0
expr_stmt|;
comment|/* determine which */
name|prompt
argument_list|(
literal|"Forward to: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|gline
argument_list|(
name|tonf
argument_list|,
name|NNLEN
argument_list|)
operator|==
literal|1
condition|)
continue|continue;
if|if
condition|(
name|init
argument_list|(
operator|&
name|io2
argument_list|,
name|tonf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Can't find notesfile %s"
argument_list|,
name|tonf
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|wtext
operator|==
literal|0
condition|)
block|{
name|txtfile
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|tmpfile
argument_list|,
literal|"/tmp/nfx%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|delfile
operator|=
name|tmpfile
expr_stmt|;
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|tmpfile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem:creat scratch failed"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|chmod
argument_list|(
name|tmpfile
argument_list|,
literal|0666
argument_list|)
operator|<
literal|0
argument_list|,
literal|"readem: chmod failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
condition|)
block|{
name|preptxt
argument_list|(
name|io
argument_list|,
name|txtfile
argument_list|,
name|io
operator|->
name|nf
argument_list|,
operator|&
name|rsprec
operator|.
name|r_auth
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_id
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_when
index|[
name|roffset
index|]
argument_list|,
operator|&
name|rsprec
operator|.
name|r_addr
index|[
name|roffset
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|preptxt
argument_list|(
name|io
argument_list|,
name|txtfile
argument_list|,
name|io
operator|->
name|nf
argument_list|,
operator|&
name|note
operator|.
name|n_auth
argument_list|,
operator|&
name|note
operator|.
name|n_id
argument_list|,
operator|&
name|note
operator|.
name|n_date
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
comment|/* close it */
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|tmpfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"readem: couldnt reopen"
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
literal|'n'
expr_stmt|;
comment|/* default to note */
if|if
condition|(
name|allow
argument_list|(
operator|&
name|io2
argument_list|,
name|WRITOK
argument_list|)
operator|&&
name|allow
argument_list|(
operator|&
name|io2
argument_list|,
name|READOK
argument_list|)
operator|&&
name|allow
argument_list|(
operator|&
name|io2
argument_list|,
name|RESPOK
argument_list|)
condition|)
block|{
name|prompt
argument_list|(
literal|"Forward as response? "
argument_list|)
expr_stmt|;
name|c
operator|=
name|askyn
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'n'
operator|&&
name|allow
argument_list|(
operator|&
name|io2
argument_list|,
name|WRITOK
argument_list|)
condition|)
block|{
name|addnote
argument_list|(
operator|&
name|io2
argument_list|,
name|txtfile
argument_list|,
literal|"Edit forwarded text:"
argument_list|,
literal|"Forwarded Title: "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'y'
condition|)
block|{
if|if
condition|(
name|znum
operator|=
name|limindx
argument_list|(
operator|&
name|io2
argument_list|)
condition|)
block|{
name|addresp
argument_list|(
operator|&
name|io2
argument_list|,
name|txtfile
argument_list|,
name|znum
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|warn
argument_list|(
literal|"You haven't permission"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|io
operator|->
name|nf
argument_list|,
name|io2
operator|.
name|nf
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* if was this notefile */
comment|/* get new descriptor */
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
block|}
name|finish
argument_list|(
operator|&
name|io2
argument_list|)
expr_stmt|;
comment|/* close up that notefile */
if|if
condition|(
name|txtfile
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
comment|/* throw it away */
name|txtfile
operator|=
name|NULL
expr_stmt|;
name|x
argument_list|(
name|unlink
argument_list|(
name|tmpfile
argument_list|)
operator|<
literal|0
argument_list|,
literal|"readem: couldnt unlink scratch"
argument_list|)
expr_stmt|;
name|delfile
operator|=
name|NULL
expr_stmt|;
block|}
continue|continue;
case|case
literal|'n'
case|:
comment|/* nest notesfiles - a stack */
name|prompt
argument_list|(
literal|"New notesfile: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|gline
argument_list|(
name|tonf
argument_list|,
name|NNLEN
argument_list|)
operator|==
literal|1
condition|)
continue|continue;
name|closenf
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|/* save fids */
name|i
operator|=
name|control
argument_list|(
name|tonf
argument_list|,
name|NOSEQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|opennf
argument_list|(
name|io
argument_list|,
name|io
operator|->
name|nf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Couldn't reopen notesfile"
argument_list|)
expr_stmt|;
name|wfchar
argument_list|()
expr_stmt|;
name|retstat
operator|=
name|QUITNOSEQ
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|i
operator|==
name|QUITBAD
operator|||
name|i
operator|==
name|QUITNEX
condition|)
block|{
name|warn
argument_list|(
literal|"Can not open notesfile `%s'"
argument_list|,
name|tonf
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|i
operator|==
name|QUITFAST
operator|||
name|i
operator|==
name|QUITUPD
condition|)
block|{
name|retstat
operator|=
name|i
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
comment|/* place text at end of 'nfsave' */
case|case
literal|'S'
case|:
comment|/* place the whole string */
case|case
literal|'|'
case|:
comment|/* pipe into command */
case|case
literal|'^'
case|:
comment|/* whole string into command */
case|case
literal|'%'
case|:
comment|/* joke translator */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prompt
argument_list|(
literal|"File name: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|znum
operator|=
name|gline
argument_list|(
name|tmpfile
argument_list|,
name|CMDLEN
argument_list|)
operator|)
operator|==
literal|1
condition|)
continue|continue;
name|prompt
argument_list|(
literal|"Saving..."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cmdline
argument_list|,
literal|"cat>> %s"
argument_list|,
name|tmpfile
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
case|case
literal|'^'
case|:
name|prompt
argument_list|(
literal|"Command: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|znum
operator|=
name|gline
argument_list|(
name|cmdline
argument_list|,
name|CMDLEN
argument_list|)
operator|)
operator|==
literal|1
condition|)
continue|continue;
name|printf
argument_list|(
literal|"\nStarting up...\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|prompt
argument_list|(
literal|"Translation..."
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cmdline
argument_list|,
literal|"tr 'A-Za-z' 'N-ZA-Mn-za-m'"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ptxtfile
operator|=
name|pipeopen
argument_list|(
name|cmdline
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"pipe open failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'S'
operator|||
name|c
operator|==
literal|'^'
condition|)
block|{
comment|/* save whole string */
name|znum
operator|=
name|savnote
argument_list|(
name|io
argument_list|,
name|ptxtfile
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|note
operator|.
name|n_nresp
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lrsp
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
name|i
argument_list|,
operator|&
name|rsprec
argument_list|,
operator|&
name|roffset
argument_list|,
operator|&
name|rrecnum
argument_list|)
operator|==
operator|-
literal|1
condition|)
comment|/* hit end of chain */
continue|continue;
name|znum
operator|+=
name|savresp
argument_list|(
name|io
argument_list|,
name|ptxtfile
argument_list|,
operator|&
name|rsprec
argument_list|,
name|roffset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* save single page */
if|if
condition|(
name|resp
condition|)
name|znum
operator|=
name|savresp
argument_list|(
name|io
argument_list|,
name|ptxtfile
argument_list|,
operator|&
name|rsprec
argument_list|,
name|roffset
argument_list|)
expr_stmt|;
else|else
name|znum
operator|=
name|savnote
argument_list|(
name|io
argument_list|,
name|ptxtfile
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|pipeclose
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|(
name|c
operator|==
literal|'s'
operator|||
name|c
operator|==
literal|'S'
operator|)
condition|)
block|{
name|prompt
argument_list|(
literal|"Saved %d lines"
argument_list|,
name|znum
argument_list|)
expr_stmt|;
name|replot
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|wfchar
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'j'
case|:
comment|/* go on to next note/resp */
case|case
literal|'l'
case|:
comment|/* universal seq, RLS */
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|resp
operator|!=
name|note
operator|.
name|n_nresp
condition|)
block|{
if|if
condition|(
operator|(
name|resp
operator|=
name|nxtresp
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
name|resp
argument_list|,
operator|&
name|io
operator|->
name|stime
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* fall into ... */
case|case
literal|'L'
case|:
case|case
literal|'J'
case|:
comment|/* next unread note */
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|resp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|readnum
operator|=
name|nxtnote
argument_list|(
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|io
operator|->
name|stime
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'l'
operator|||
name|c
operator|==
literal|'L'
condition|)
name|retstat
operator|=
name|QUITSEQ
expr_stmt|;
else|else
comment|/* put him on last page */
operator|*
name|firstdis
operator|=
name|io
operator|->
name|descr
operator|.
name|d_nnote
expr_stmt|;
goto|goto
name|out
goto|;
case|case
literal|'+'
case|:
case|case
literal|';'
case|:
case|case
literal|' '
case|:
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
comment|/* such is the fate of policy notes */
goto|goto
name|out
goto|;
name|resp
operator|++
expr_stmt|;
if|if
condition|(
name|resp
operator|>
name|note
operator|.
name|n_nresp
condition|)
goto|goto
name|nextnt
goto|;
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'='
case|:
comment|/* go back to the base note */
if|if
condition|(
name|resp
operator|==
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Already on base note"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|resp
operator|=
literal|0
expr_stmt|;
comment|/* reset index into responses */
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'1'
case|:
comment|/* skip n responses */
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|note
operator|.
name|n_nresp
operator|<
literal|1
condition|)
goto|goto
name|nextnt
goto|;
comment|/* let him skip all over responses */
name|resp
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
default|default:
comment|/* something we haven't covered */
comment|/* so can jump down here */
name|warn
argument_list|(
literal|"q to quit, ? for help"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nextnt
label|:
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|++
name|readnum
operator|>
name|io
operator|->
name|descr
operator|.
name|d_nnote
condition|)
block|{
operator|*
name|firstdis
operator|=
name|io
operator|->
name|descr
operator|.
name|d_nnote
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|resp
operator|=
literal|0
expr_stmt|;
comment|/* reset response index */
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
name|prevnt
label|:
comment|/* display previous note */
if|if
condition|(
name|readnum
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* set to scroll backwards on deleted note */
name|forward
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|--
name|readnum
operator|<
literal|1
condition|)
block|{
comment|/* zero is policy, so stop at 1 */
name|readnum
operator|=
literal|1
expr_stmt|;
name|forward
operator|=
literal|1
expr_stmt|;
comment|/* bounce off bottom end */
block|}
name|resp
operator|=
literal|0
expr_stmt|;
comment|/* was else resp = 0; */
name|replot
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|out
label|:
name|ignsigs
operator|++
expr_stmt|;
name|curenv
operator|=
name|oldenv
expr_stmt|;
name|ignsigs
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|retstat
operator|)
return|;
block|}
end_block

end_unit

