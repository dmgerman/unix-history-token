begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)bnewsinput.c	1.2 2/2/83"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_include
include|#
directive|include
file|"globs.h"
end_include

begin_include
include|#
directive|include
file|"newsgate.h"
end_include

begin_include
include|#
directive|include
file|"bnews.h"
end_include

begin_comment
comment|/*  *	bnewsinput.c  *  *	This program will accept an article according the the  *	'B' protocol for news(I).  The article will then be inserted in  *	the notefile(s) which match the newsgroup(s).    *  *	Modified April 1982:  *	The newer version is somewhat more streamlined.  *	So, the other major difference in the new version is that if the  *	title is of the form:  *		some title - (nf)  *	(or if the suffix is "- (nf)"  *	we decide that it has been generated by notesfiles. This means that  *	we are allowed to skip text up to a # and then we have a special   *	ALMOST generic notesfile format. The header information is   *	slightly different.  *	see canon.h for the new format examples  *  *	Original Coding:	Ray Essick		Feb 1982  *	Modified extensively:	Ray Essick		April 1982  *	Modified to add some neat things  *				Malcolm Slaney 		July 1982  *	added code to catch misformed articles  *				Ray Essick		July 27, 1982  *	Modified to add even more neat things  *				Rick L Spickelmier, UCB 1982  *	Added the B news parser and multiple groups  *				Rick L Spickelmier  *  */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|longtitle
index|[
name|WDLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* storage for titles longer the TITLEN */
end_comment

begin_define
define|#
directive|define
name|min
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)> (B) ? (B) : (A))
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|io_f
name|io
decl_stmt|;
name|char
name|title
index|[
name|TITLEN
operator|+
literal|40
index|]
decl_stmt|;
comment|/* title */
name|char
name|nf
index|[
name|NNLEN
index|]
decl_stmt|;
comment|/* the notefile */
name|char
name|fname
index|[
name|WDLEN
index|]
decl_stmt|;
comment|/* hold scratch file name */
name|char
name|ngroup
index|[
name|WDLEN
index|]
index|[
name|NUMGROUPS
index|]
decl_stmt|;
comment|/* newsgroups name */
name|char
name|fromsys
index|[
name|SYSSZ
index|]
decl_stmt|,
name|origsys
index|[
name|SYSSZ
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|suffix
decl_stmt|;
name|int
name|count
decl_stmt|,
name|atcount
decl_stmt|,
comment|/* count ARPA hosts */
name|status
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|stat
decl_stmt|,
name|length
decl_stmt|,
comment|/* of title */
name|notenum
decl_stmt|;
name|struct
name|note_f
name|note
decl_stmt|;
name|struct
name|note_f
name|note2
decl_stmt|;
name|struct
name|auth_f
name|auth
decl_stmt|;
name|long
name|newsseq
decl_stmt|;
name|struct
name|id_f
name|respid
decl_stmt|;
name|struct
name|when_f
name|entered
decl_stmt|,
name|whentime
decl_stmt|;
name|struct
name|id_f
name|newsid
decl_stmt|;
name|char
name|line
index|[
name|CMDLEN
index|]
decl_stmt|;
comment|/* scratch */
name|struct
name|daddr_f
name|where
decl_stmt|;
name|FILE
modifier|*
name|rawnews
decl_stmt|;
comment|/* raw news read from here */
name|FILE
modifier|*
name|scr
decl_stmt|;
comment|/* scratch file for holding article */
name|FILE
modifier|*
name|hread
parameter_list|()
function_decl|;
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
include|#
directive|include
file|"main.i"
comment|/* common init code and such */
name|rawnews
operator|=
name|stdin
expr_stmt|;
comment|/* read from the right file */
comment|/* Parse the header */
name|hp
operator|=
operator|(
expr|struct
name|hbuf
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hbuf
argument_list|)
argument_list|)
expr_stmt|;
name|rawnews
operator|=
name|hread
argument_list|(
name|hp
argument_list|,
name|rawnews
argument_list|)
expr_stmt|;
comment|/* get origsys and newsseq */
name|sscanf
argument_list|(
name|hp
operator|->
name|ident
argument_list|,
literal|"%[^.].%ld"
argument_list|,
name|origsys
argument_list|,
operator|&
name|newsseq
argument_list|)
expr_stmt|;
comment|/* get the fromsys and author line */
name|strcpy
argument_list|(
name|line
argument_list|,
name|hp
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* parse the path */
name|i
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* start at rhs */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|line
index|[
name|j
index|]
operator|==
literal|' '
condition|)
break|break;
while|while
condition|(
name|j
operator|&&
operator|(
name|line
index|[
name|j
index|]
operator|!=
literal|'!'
operator|)
operator|&&
operator|(
name|line
index|[
name|j
index|]
operator|!=
literal|':'
operator|)
operator|&&
operator|(
name|line
index|[
name|j
index|]
operator|!=
literal|'.'
operator|)
condition|)
block|{
name|j
operator|--
expr_stmt|;
comment|/* back to sys */
block|}
name|atcount
operator|=
literal|0
expr_stmt|;
comment|/* count ARPA hosts parsed */
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|j
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|++
init|;
operator|(
name|i
operator|<
name|NAMESZ
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|auth
operator|.
name|aname
index|[
name|i
index|]
operator|=
name|line
index|[
name|j
operator|+
name|i
index|]
operator|)
operator|==
literal|'@'
operator|&&
name|atcount
operator|++
condition|)
block|{
name|auth
operator|.
name|aname
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
comment|/* only parse 1 ARPA host */
block|}
else|else
block|{
if|if
condition|(
name|auth
operator|.
name|aname
index|[
name|i
index|]
operator|==
literal|' '
condition|)
block|{
name|auth
operator|.
name|aname
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminate */
break|break;
comment|/* and get out of here */
block|}
else|else
block|{
if|if
condition|(
name|auth
operator|.
name|aname
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
comment|/* build the from system */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|SYSSZ
operator|-
literal|1
operator|)
operator|&&
name|line
index|[
name|i
index|]
operator|!=
literal|'!'
operator|&&
name|line
index|[
name|i
index|]
operator|!=
literal|':'
operator|&&
name|line
index|[
name|i
index|]
operator|!=
literal|'.'
condition|;
name|i
operator|++
control|)
block|{
name|fromsys
index|[
name|i
index|]
operator|=
name|line
index|[
name|i
index|]
expr_stmt|;
block|}
name|fromsys
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* get the title and longtitle */
name|strcpy
argument_list|(
name|longtitle
argument_list|,
name|hp
operator|->
name|title
argument_list|)
expr_stmt|;
name|strcpyn
argument_list|(
name|title
argument_list|,
name|longtitle
argument_list|,
name|TITLEN
operator|+
literal|39
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|longtitle
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
name|title
index|[
name|min
argument_list|(
name|TITLEN
operator|+
literal|39
argument_list|,
name|strlen
argument_list|(
name|longtitle
argument_list|)
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* get the date */
name|getdate
argument_list|(
name|hp
operator|->
name|subdate
argument_list|,
operator|&
name|entered
argument_list|)
expr_stmt|;
comment|/* get the newsgroups */
name|sscanf
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|,
literal|"%[^,\n]"
argument_list|,
name|ngroup
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/*      * The header is now parsed, all left is text.      * Check existence of the notesfile, permission      * to write and other things like that      */
name|newsgroup
argument_list|(
name|ngroup
index|[
literal|0
index|]
argument_list|,
name|nf
argument_list|,
name|NEWSNF
argument_list|)
expr_stmt|;
comment|/* alias the bugger */
if|if
condition|(
name|init
argument_list|(
operator|&
name|io
argument_list|,
name|nf
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* well is it there? */
name|printf
argument_list|(
literal|"Non-existant notesfile: %s\n"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTOCREATE
comment|/* try to create the notes file - RLS */
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s/%s/mknf -on %s"
argument_list|,
name|MSTDIR
argument_list|,
name|UTILITY
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
argument_list|(
operator|&
name|io
argument_list|,
name|nf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"notesfile: %s, newsgroup %s\n"
argument_list|,
name|ngroup
index|[
literal|0
index|]
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|nfcomment
argument_list|(
name|NOSUCHWARN
argument_list|,
name|line
argument_list|,
literal|"Failure"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"Created: %s\n"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|nfcomment
argument_list|(
name|NOSUCHWARN
argument_list|,
name|line
argument_list|,
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"notesfile: %s, newsgroup %s\n"
argument_list|,
name|ngroup
index|[
literal|0
index|]
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|nfcomment
argument_list|(
name|NOSUCHWARN
argument_list|,
name|line
argument_list|,
literal|"Failure"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|io
operator|.
name|descr
operator|.
name|d_stat
operator|&
name|NETWRKD
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* networked ? */
name|printf
argument_list|(
literal|"Notesfile %s is not networked\n"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|q
operator|=
name|title
expr_stmt|;
while|while
condition|(
operator|*
name|r
condition|)
block|{
comment|/* look for last '-' */
if|if
condition|(
operator|*
name|r
operator|==
literal|'-'
condition|)
block|{
name|q
operator|=
name|r
expr_stmt|;
comment|/* this is new last */
block|}
name|r
operator|++
expr_stmt|;
comment|/* on to the next */
block|}
name|suffix
operator|=
name|q
expr_stmt|;
comment|/* save the pointer for possible later use */
comment|/* like misformed articles with "- (nf)" */
name|length
operator|=
name|q
operator|-
name|title
expr_stmt|;
comment|/* non-nulls before '-' */
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
name|NFSUFFIX
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|q
argument_list|,
name|OLDSUFFIX
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* so is not nf generated */
comment|/*  *	we come back up to here if the article had the notesfile  *	suffix and was not properly formatted.  *	This is a stopgap measure due to the fact that I misdesigned  *	the system so that notes used a right associative rule  *	to determine its articles, while news programs used a  *	left associative rule. Oh well.   *		- Ray Essick	July 27, 1982  */
name|badform
label|:
comment|/* come here if no "#" in a "- (nf)" article */
name|getperms
argument_list|(
operator|&
name|io
argument_list|,
literal|1
argument_list|,
name|origsys
argument_list|)
expr_stmt|;
if|if
condition|(
name|allow
argument_list|(
operator|&
name|io
argument_list|,
name|WRITOK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"System %s not allowed to write notes\n"
argument_list|,
name|origsys
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
name|strmove
argument_list|(
name|origsys
argument_list|,
name|newsid
operator|.
name|sys
argument_list|)
expr_stmt|;
comment|/* build uniq id */
name|newsid
operator|.
name|uniqid
operator|=
operator|(
operator|-
name|newsseq
operator|*
literal|100
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* is not there yet */
name|strmove
argument_list|(
name|origsys
argument_list|,
name|note
operator|.
name|n_id
operator|.
name|sys
argument_list|)
expr_stmt|;
name|note
operator|.
name|n_id
operator|.
name|uniqid
operator|=
operator|(
operator|-
literal|100
operator|*
name|newsseq
operator|)
expr_stmt|;
comment|/* build the note descriptor */
name|copydate
argument_list|(
operator|&
name|entered
argument_list|,
operator|&
name|note
operator|.
name|n_date
argument_list|)
expr_stmt|;
name|strmove
argument_list|(
name|fromsys
argument_list|,
name|note
operator|.
name|n_from
argument_list|)
expr_stmt|;
name|stat
operator|=
name|FRMNEWS
expr_stmt|;
comment|/* came from news system */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* fix up the title */
while|while
condition|(
name|title
index|[
name|i
operator|++
index|]
condition|)
empty_stmt|;
comment|/* get to the end */
for|for
control|(
name|i
operator|--
init|;
name|i
operator|<
name|TITLEN
condition|;
name|i
operator|++
control|)
block|{
name|title
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* space pad */
block|}
name|lock
argument_list|(
operator|&
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|notenum
operator|=
name|chknote
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_id
argument_list|,
operator|&
name|note2
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|title
argument_list|,
literal|"Re:"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
comment|/* see if a "followup" */
name|p
operator|=
name|title
expr_stmt|;
do|do
block|{
name|p
operator|+=
literal|3
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Skip Spaces */
block|}
do|while
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"Re:"
argument_list|,
literal|3
argument_list|)
condition|)
do|;
comment|/* get all re's */
name|strcpy
argument_list|(
name|io
operator|.
name|xstring
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|notenum
operator|=
name|findtitle
argument_list|(
operator|&
name|io
argument_list|,
name|io
operator|.
name|descr
operator|.
name|d_nnote
argument_list|)
expr_stmt|;
if|if
condition|(
name|notenum
operator|>
literal|0
operator|&&
operator|!
name|chkresp
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|newsid
argument_list|,
operator|&
name|note2
argument_list|,
name|notenum
argument_list|)
condition|)
block|{
name|longtitle
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pagein
argument_list|(
operator|&
name|io
argument_list|,
name|rawnews
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|whentime
argument_list|)
expr_stmt|;
name|putresp
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|where
argument_list|,
name|stat
argument_list|,
name|notenum
argument_list|,
operator|&
name|entered
argument_list|,
operator|&
name|auth
argument_list|,
operator|&
name|note
argument_list|,
name|NOLOCKIT
argument_list|,
operator|&
name|newsid
argument_list|,
name|NOADDID
argument_list|,
name|fromsys
argument_list|,
name|ADDTIME
argument_list|,
operator|&
name|whentime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|notenum
operator|<
literal|1
condition|)
block|{
name|pagein
argument_list|(
operator|&
name|io
argument_list|,
name|rawnews
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|notenum
operator|=
name|putnote
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|where
argument_list|,
name|title
argument_list|,
name|stat
argument_list|,
operator|&
name|note
argument_list|,
operator|&
name|auth
argument_list|,
name|NOPOLICY
argument_list|,
name|NOLOCKIT
argument_list|,
name|NOADDID
argument_list|,
name|fromsys
argument_list|,
name|ADDTIME
argument_list|)
expr_stmt|;
name|io
operator|.
name|nnotrcvd
operator|++
expr_stmt|;
comment|/* count as networked in */
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Duplicate Response handed back by news\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|pagein
argument_list|(
operator|&
name|io
argument_list|,
name|rawnews
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|notenum
operator|=
name|putnote
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|where
argument_list|,
name|title
argument_list|,
name|stat
argument_list|,
operator|&
name|note
argument_list|,
operator|&
name|auth
argument_list|,
name|NOPOLICY
argument_list|,
name|NOLOCKIT
argument_list|,
name|NOADDID
argument_list|,
name|fromsys
argument_list|,
name|ADDTIME
argument_list|)
expr_stmt|;
name|io
operator|.
name|nnotrcvd
operator|++
expr_stmt|;
comment|/* count as networked in */
block|}
block|}
elseif|else
if|if
condition|(
name|note2
operator|.
name|n_stat
operator|&
name|ORPHND
condition|)
block|{
comment|/* replace foster parent */
name|pagein
argument_list|(
operator|&
name|io
argument_list|,
name|rawnews
argument_list|,
operator|&
name|note2
operator|.
name|n_addr
argument_list|)
expr_stmt|;
comment|/* collect text */
name|gettime
argument_list|(
operator|&
name|note2
operator|.
name|n_rcvd
argument_list|)
expr_stmt|;
comment|/* current tod */
name|gettime
argument_list|(
operator|&
name|note2
operator|.
name|n_lmod
argument_list|)
expr_stmt|;
comment|/* last touched */
name|copyauth
argument_list|(
operator|&
name|auth
argument_list|,
operator|&
name|note2
operator|.
name|n_auth
argument_list|)
expr_stmt|;
comment|/* fill in the author */
name|note2
operator|.
name|n_stat
operator||=
name|FRMNEWS
expr_stmt|;
comment|/* brand it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TITLEN
condition|;
name|i
operator|++
control|)
block|{
name|note2
operator|.
name|ntitle
index|[
name|i
index|]
operator|=
name|title
index|[
name|i
index|]
expr_stmt|;
comment|/* move new title */
block|}
name|copydate
argument_list|(
operator|&
name|entered
argument_list|,
operator|&
name|note2
operator|.
name|n_date
argument_list|)
expr_stmt|;
comment|/* written date */
name|strcpy
argument_list|(
name|note2
operator|.
name|n_from
argument_list|,
name|fromsys
argument_list|)
expr_stmt|;
comment|/* and who gave it to us */
name|putnrec
argument_list|(
operator|&
name|io
argument_list|,
name|notenum
argument_list|,
operator|&
name|note2
argument_list|)
expr_stmt|;
comment|/* and replace */
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Duplicate news article received\n"
argument_list|)
expr_stmt|;
block|}
name|unlock
argument_list|(
operator|&
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* nf generated article */
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"/tmp/nfn%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* generate name */
name|scr
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
comment|/* open scratch file */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|rawnews
argument_list|)
operator|)
operator|!=
literal|'#'
operator|&&
name|c
operator|!=
name|EOF
condition|)
block|{
comment|/* find start */
if|if
condition|(
name|scr
operator|!=
name|NULL
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|scr
argument_list|)
expr_stmt|;
comment|/* hold it in the scratch file */
block|}
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|fclose
argument_list|(
name|scr
argument_list|)
expr_stmt|;
comment|/* flush what is there */
if|if
condition|(
operator|(
name|rawnews
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Article lost in file system: %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|fname
argument_list|)
expr_stmt|;
comment|/* remove the file */
name|closenf
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
comment|/* close the notesfile */
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
operator|*
operator|--
name|suffix
operator|=
literal|'\0'
expr_stmt|;
comment|/* remove " - (nf)" suffix */
name|unlink
argument_list|(
name|fname
argument_list|)
expr_stmt|;
comment|/* only link is the file descriptor */
goto|goto
name|badform
goto|;
comment|/* reparse as a news article */
block|}
name|fclose
argument_list|(
name|scr
argument_list|)
expr_stmt|;
comment|/* close and */
name|unlink
argument_list|(
name|fname
argument_list|)
expr_stmt|;
comment|/* toss the scratch file */
switch|switch
condition|(
name|getc
argument_list|(
name|rawnews
argument_list|)
condition|)
block|{
case|case
literal|'N'
case|:
comment|/* base note coming through news */
if|if
condition|(
name|fscanf
argument_list|(
name|rawnews
argument_list|,
literal|":%[^:]:%ld:%o:%d"
argument_list|,
name|note
operator|.
name|n_id
operator|.
name|sys
argument_list|,
operator|&
name|note
operator|.
name|n_id
operator|.
name|uniqid
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
literal|4
condition|)
goto|goto
name|toobad
goto|;
comment|/* bad form */
while|while
condition|(
name|getc
argument_list|(
name|rawnews
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
comment|/* skip eol */
for|for
control|(
name|i
operator|=
name|length
init|;
name|i
operator|<
name|TITLEN
condition|;
name|i
operator|++
control|)
block|{
name|title
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* space fill */
block|}
comment|/* skip sys name, got elsewhere */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|rawnews
argument_list|)
operator|)
operator|!=
literal|'!'
condition|)
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|NAMESZ
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|rawnews
argument_list|)
operator|)
operator|!=
literal|' '
operator|)
condition|;
name|i
operator|++
control|)
name|auth
operator|.
name|aname
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
comment|/* get the author */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|line
index|[
name|i
index|]
operator|=
name|getc
argument_list|(
name|rawnews
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
comment|/* grab date */
name|getdate
argument_list|(
name|line
argument_list|,
operator|&
name|note
operator|.
name|n_date
argument_list|)
expr_stmt|;
comment|/* loop in case trash on line */
comment|/* in theory this line is empty */
while|while
condition|(
name|getc
argument_list|(
name|rawnews
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|getperms
argument_list|(
operator|&
name|io
argument_list|,
literal|1
argument_list|,
name|note
operator|.
name|n_id
operator|.
name|sys
argument_list|)
expr_stmt|;
comment|/* see if he's allowed */
if|if
condition|(
name|allow
argument_list|(
operator|&
name|io
argument_list|,
name|WRITOK
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* not a chance */
name|closenf
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
name|lock
argument_list|(
operator|&
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|notenum
operator|=
name|chknote
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_id
argument_list|,
operator|&
name|note2
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* is it there? */
name|pagein
argument_list|(
operator|&
name|io
argument_list|,
name|rawnews
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
comment|/* grab text */
name|status
operator||=
name|FRMNEWS
expr_stmt|;
comment|/* came through news! */
name|strmove
argument_list|(
name|fromsys
argument_list|,
name|note
operator|.
name|n_from
argument_list|)
expr_stmt|;
name|putnote
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|where
argument_list|,
name|title
argument_list|,
name|status
argument_list|,
operator|&
name|note
argument_list|,
operator|&
name|auth
argument_list|,
name|NOPOLICY
argument_list|,
name|NOLOCKIT
argument_list|,
name|NOADDID
argument_list|,
name|fromsys
argument_list|,
name|ADDTIME
argument_list|)
expr_stmt|;
name|io
operator|.
name|nnotrcvd
operator|++
expr_stmt|;
comment|/* count it */
block|}
else|else
block|{
if|if
condition|(
operator|(
name|note2
operator|.
name|n_stat
operator|&
name|ORPHND
operator|)
operator|&&
name|NOT
argument_list|(
name|status
operator|&
name|ORPHND
argument_list|)
condition|)
block|{
comment|/* extant is orphan, new isnt */
name|pagein
argument_list|(
operator|&
name|io
argument_list|,
name|rawnews
argument_list|,
operator|&
name|note2
operator|.
name|n_addr
argument_list|)
expr_stmt|;
comment|/* grab text */
name|gettime
argument_list|(
operator|&
name|note2
operator|.
name|n_rcvd
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|note2
operator|.
name|n_lmod
argument_list|)
expr_stmt|;
comment|/* time stamp it */
name|copyauth
argument_list|(
operator|&
name|auth
argument_list|,
operator|&
name|note2
operator|.
name|n_auth
argument_list|)
expr_stmt|;
comment|/* put correct author */
name|note2
operator|.
name|n_stat
operator|=
name|status
operator|+
name|FRMNEWS
expr_stmt|;
comment|/* correct status */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TITLEN
condition|;
name|i
operator|++
control|)
block|{
name|note2
operator|.
name|ntitle
index|[
name|i
index|]
operator|=
name|title
index|[
name|i
index|]
expr_stmt|;
block|}
name|copydate
argument_list|(
operator|&
name|entered
argument_list|,
operator|&
name|note2
operator|.
name|n_date
argument_list|)
expr_stmt|;
name|strmove
argument_list|(
name|fromsys
argument_list|,
name|note2
operator|.
name|n_from
argument_list|)
expr_stmt|;
name|putnrec
argument_list|(
operator|&
name|io
argument_list|,
name|notenum
argument_list|,
operator|&
name|note2
argument_list|)
expr_stmt|;
comment|/* and replace */
block|}
else|else
block|{
comment|/* duplicate */
name|printf
argument_list|(
literal|"Duplicate note handed back by news\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|unlock
argument_list|(
operator|&
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* response coming through news */
if|if
condition|(
name|fscanf
argument_list|(
name|rawnews
argument_list|,
literal|":%[^:]:%ld:%[^:]:%ld:%o:%d"
argument_list|,
name|note
operator|.
name|n_id
operator|.
name|sys
argument_list|,
operator|&
name|note
operator|.
name|n_id
operator|.
name|uniqid
argument_list|,
name|respid
operator|.
name|sys
argument_list|,
operator|&
name|respid
operator|.
name|uniqid
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
literal|6
condition|)
goto|goto
name|toobad
goto|;
comment|/* bad form */
while|while
condition|(
name|getc
argument_list|(
name|rawnews
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
comment|/* skip eol */
name|getperms
argument_list|(
operator|&
name|io
argument_list|,
literal|1
argument_list|,
name|respid
operator|.
name|sys
argument_list|)
expr_stmt|;
comment|/* see if he's allowed */
if|if
condition|(
name|allow
argument_list|(
operator|&
name|io
argument_list|,
name|RESPOK
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* not a chance */
name|closenf
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
comment|/* skip sys name, got elsewhere */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|rawnews
argument_list|)
operator|)
operator|!=
literal|'!'
condition|)
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|NAMESZ
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|rawnews
argument_list|)
operator|)
operator|!=
literal|' '
operator|)
condition|;
name|i
operator|++
control|)
name|auth
operator|.
name|aname
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
comment|/* get the author */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* grab date */
while|while
condition|(
operator|(
name|line
index|[
name|i
index|]
operator|=
name|getc
argument_list|(
name|rawnews
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|getdate
argument_list|(
name|line
argument_list|,
operator|&
name|entered
argument_list|)
expr_stmt|;
comment|/* loop in case trash on line */
comment|/* in theory this line is empty */
while|while
condition|(
name|getc
argument_list|(
name|rawnews
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|lock
argument_list|(
operator|&
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
name|notenum
operator|=
name|chknote
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_id
argument_list|,
operator|&
name|note2
argument_list|)
expr_stmt|;
if|if
condition|(
name|notenum
operator|==
literal|0
condition|)
block|{
comment|/* build foster parent */
name|printf
argument_list|(
literal|"Orphaned response handed in by news\n"
argument_list|)
expr_stmt|;
name|strmove
argument_list|(
name|fromsys
argument_list|,
name|note
operator|.
name|n_from
argument_list|)
expr_stmt|;
name|note
operator|.
name|n_nresp
operator|=
literal|0
expr_stmt|;
name|note
operator|.
name|n_auth
operator|.
name|aid
operator|=
name|ANONUID
expr_stmt|;
name|strcpy
argument_list|(
name|note
operator|.
name|n_auth
operator|.
name|aname
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
name|copydate
argument_list|(
operator|&
name|entered
argument_list|,
operator|&
name|note
operator|.
name|n_date
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|whentime
argument_list|)
expr_stmt|;
comment|/* get current time */
name|status
operator|=
name|ORPHND
operator|+
name|FRMNEWS
expr_stmt|;
comment|/* combo there */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
literal|"Orphaned Response"
init|;
operator|(
name|i
operator|<
name|TITLEN
operator|)
operator|&&
operator|*
name|p
condition|;
name|p
operator|++
operator|,
name|i
operator|++
control|)
name|note
operator|.
name|ntitle
index|[
name|i
index|]
operator|=
operator|*
name|p
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|TITLEN
condition|;
name|i
operator|++
control|)
block|{
name|note
operator|.
name|ntitle
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* pad */
block|}
name|where
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
comment|/* no text */
name|notenum
operator|=
name|putnote
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|where
argument_list|,
name|note
operator|.
name|ntitle
argument_list|,
name|status
argument_list|,
operator|&
name|note
argument_list|,
operator|&
name|note
operator|.
name|n_auth
argument_list|,
name|NOPOLICY
argument_list|,
name|NOLOCKIT
argument_list|,
name|NOADDID
argument_list|,
name|fromsys
argument_list|,
name|ADDTIME
argument_list|)
expr_stmt|;
name|io
operator|.
name|norphans
operator|++
expr_stmt|;
comment|/* census of orphans */
name|getnrec
argument_list|(
operator|&
name|io
argument_list|,
name|notenum
argument_list|,
operator|&
name|note2
argument_list|)
expr_stmt|;
comment|/* get good one */
block|}
if|if
condition|(
name|chkresp
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|respid
argument_list|,
operator|&
name|note2
argument_list|,
name|notenum
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* none, insert it */
name|longtitle
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|status
operator||=
name|FRMNEWS
expr_stmt|;
name|pagein
argument_list|(
operator|&
name|io
argument_list|,
name|rawnews
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|putresp
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|where
argument_list|,
name|status
argument_list|,
name|notenum
argument_list|,
operator|&
name|entered
argument_list|,
operator|&
name|auth
argument_list|,
operator|&
name|note
argument_list|,
name|NOLOCKIT
argument_list|,
operator|&
name|respid
argument_list|,
name|NOADDID
argument_list|,
name|fromsys
argument_list|,
name|ADDTIME
argument_list|,
operator|&
name|whentime
argument_list|)
expr_stmt|;
name|io
operator|.
name|nrsprcvd
operator|++
expr_stmt|;
comment|/* count him in */
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Duplicate response handed back by news\n"
argument_list|)
expr_stmt|;
block|}
name|unlock
argument_list|(
operator|&
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* bad news coming through news */
name|toobad
label|:
comment|/* label for bad format jumps */
name|printf
argument_list|(
literal|"Some sort of failure caused jump to toobad\n"
argument_list|)
expr_stmt|;
name|closenf
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end of nf coming back in */
name|lock
argument_list|(
operator|&
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
name|getdscr
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|io
operator|.
name|descr
argument_list|)
expr_stmt|;
name|io
operator|.
name|descr
operator|.
name|netwrkins
operator|++
expr_stmt|;
comment|/* count as net in */
name|putdscr
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|io
operator|.
name|descr
argument_list|)
expr_stmt|;
name|unlock
argument_list|(
operator|&
name|io
argument_list|,
literal|'n'
argument_list|)
expr_stmt|;
name|finish
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|GOOD
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

