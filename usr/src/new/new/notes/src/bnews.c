begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)bnews.c	1.1\t1/23/83"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * bnews.c - routines to parse the bnews header  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#) header.c	2.9	6/5/82"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_include
include|#
directive|include
file|"newsgate.h"
end_include

begin_include
include|#
directive|include
file|"bnews.h"
end_include

begin_decl_stmt
name|char
name|bfr
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|time_t
name|defexp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read header from file dir/name into *hp.  * Return (FILE *) if header okay, else NULL.  */
end_comment

begin_function
name|FILE
modifier|*
name|hread
parameter_list|(
name|hp
parameter_list|,
name|fp
parameter_list|)
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
comment|/* clear the necessary parts of hp */
name|strcpy
argument_list|(
name|hp
operator|->
name|path
argument_list|,
literal|"\0"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|,
literal|"\0"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hp
operator|->
name|title
argument_list|,
literal|"\0"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hp
operator|->
name|ident
argument_list|,
literal|"\0"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hp
operator|->
name|subdate
argument_list|,
literal|"\0"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|fgets
argument_list|(
name|bfr
argument_list|,
name|WDLEN
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|bfr
operator|>=
literal|'A'
operator|&&
operator|*
name|bfr
operator|<=
literal|'Z'
operator|)
operator|&&
name|index
argument_list|(
name|bfr
argument_list|,
literal|':'
argument_list|)
operator|)
operator|||
operator|!
name|strncmp
argument_list|(
name|bfr
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
condition|)
if|if
condition|(
name|frmread
argument_list|(
name|fp
argument_list|,
name|hp
argument_list|)
condition|)
goto|goto
name|strip
goto|;
if|if
condition|(
operator|*
name|bfr
operator|!=
name|PROTO
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* handle A news protocol */
name|strncpy
argument_list|(
name|hp
operator|->
name|ident
argument_list|,
operator|&
operator|(
name|bfr
index|[
literal|1
index|]
operator|)
argument_list|,
name|WDLEN
argument_list|)
expr_stmt|;
comment|/* file name */
if|if
condition|(
operator|!
name|nstrip
argument_list|(
name|hp
operator|->
name|ident
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|fgets
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|,
name|WDLEN
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* newsgroup list */
if|if
condition|(
operator|!
name|nstrip
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ngcat
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|hp
operator|->
name|path
argument_list|,
name|WDLEN
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* source path */
if|if
condition|(
operator|!
name|nstrip
argument_list|(
name|hp
operator|->
name|path
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|fgets
argument_list|(
name|hp
operator|->
name|subdate
argument_list|,
name|DATELEN
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* date */
if|if
condition|(
operator|!
name|nstrip
argument_list|(
name|hp
operator|->
name|subdate
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|fgets
argument_list|(
name|hp
operator|->
name|title
argument_list|,
name|WDLEN
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* title */
if|if
condition|(
operator|!
name|nstrip
argument_list|(
name|hp
operator|->
name|title
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|strip
label|:
comment|/* strip off sys! from front of path. */
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|SYSTEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|path
argument_list|,
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|bfr
argument_list|)
operator|)
argument_list|)
operator|==
literal|0
operator|&&
name|index
argument_list|(
name|NETCHRS
argument_list|,
name|hp
operator|->
name|path
index|[
name|len
index|]
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|hp
operator|->
name|path
argument_list|,
operator|&
operator|(
name|hp
operator|->
name|path
index|[
name|len
operator|+
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|lcase
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get header info from mail-format file.  * Return non-zero on success.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|FROM
value|1
end_define

begin_define
define|#
directive|define
name|NEWSGROUP
value|2
end_define

begin_define
define|#
directive|define
name|TITLE
value|3
end_define

begin_define
define|#
directive|define
name|SUBMIT
value|4
end_define

begin_define
define|#
directive|define
name|RECEIVE
value|5
end_define

begin_define
define|#
directive|define
name|EXPIRE
value|6
end_define

begin_define
define|#
directive|define
name|ARTICLEID
value|7
end_define

begin_define
define|#
directive|define
name|REPLYTO
value|8
end_define

begin_define
define|#
directive|define
name|FOLLOWID
value|9
end_define

begin_define
define|#
directive|define
name|CONTROL
value|10
end_define

begin_define
define|#
directive|define
name|OTHER
value|99
end_define

begin_expr_stmt
name|frmread
argument_list|(
name|fp
argument_list|,
name|hp
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fromflag
init|=
name|FALSE
decl_stmt|,
name|groupflag
init|=
name|FALSE
decl_stmt|,
name|subflag
init|=
name|FALSE
decl_stmt|;
name|int
name|titleflag
init|=
name|FALSE
decl_stmt|,
name|fileflag
init|=
name|FALSE
decl_stmt|,
name|recflag
init|=
name|FALSE
decl_stmt|,
name|i
decl_stmt|;
name|int
name|exprflag
init|=
name|FALSE
decl_stmt|,
name|replyflag
init|=
name|FALSE
decl_stmt|,
name|followflag
init|=
name|FALSE
decl_stmt|;
name|int
name|ctlflag
init|=
name|FALSE
decl_stmt|;
name|int
name|unreccnt
init|=
literal|0
decl_stmt|;
comment|/* long curpos; */
name|char
name|wordfrom
index|[
literal|100
index|]
decl_stmt|,
name|uname
index|[
literal|100
index|]
decl_stmt|,
name|at
index|[
literal|100
index|]
decl_stmt|,
name|site
index|[
literal|100
index|]
decl_stmt|;
name|i
operator|=
name|type
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* curpos = ftell(fp); */
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|FROM
case|:
if|if
condition|(
operator|!
name|fromflag
condition|)
block|{
ifdef|#
directive|ifdef
name|ATSIGN
comment|/* 				 * This old code understood the "user at site" 				 * notation but threw away all but the first 				 * word of names (like your full name) so has 				 * been taken out. 				 */
name|sscanf
argument_list|(
name|bfr
argument_list|,
literal|"%s %s %s %s"
argument_list|,
name|wordfrom
argument_list|,
name|uname
argument_list|,
name|at
argument_list|,
name|site
argument_list|)
expr_stmt|;
if|if
condition|(
name|isat
argument_list|(
name|at
argument_list|)
condition|)
name|sprintf
argument_list|(
name|hp
operator|->
name|path
argument_list|,
literal|"%s@%s"
argument_list|,
name|uname
argument_list|,
name|site
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|hp
operator|->
name|path
argument_list|,
name|uname
argument_list|)
expr_stmt|;
else|#
directive|else
name|getfield
argument_list|(
operator|&
name|fromflag
argument_list|,
name|hp
operator|->
name|path
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fromflag
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|NEWSGROUP
case|:
if|if
condition|(
operator|!
name|groupflag
condition|)
name|getfield
argument_list|(
operator|&
name|groupflag
argument_list|,
name|hp
operator|->
name|nbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|TITLE
case|:
if|if
condition|(
operator|!
name|titleflag
condition|)
name|getfield
argument_list|(
operator|&
name|titleflag
argument_list|,
name|hp
operator|->
name|title
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBMIT
case|:
if|if
condition|(
operator|!
name|subflag
condition|)
name|getfield
argument_list|(
operator|&
name|subflag
argument_list|,
name|hp
operator|->
name|subdate
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECEIVE
case|:
if|if
condition|(
operator|!
name|recflag
condition|)
name|getfield
argument_list|(
operator|&
name|recflag
argument_list|,
name|hp
operator|->
name|recdate
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPIRE
case|:
if|if
condition|(
operator|!
name|exprflag
condition|)
name|getfield
argument_list|(
operator|&
name|exprflag
argument_list|,
name|hp
operator|->
name|expdate
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARTICLEID
case|:
if|if
condition|(
operator|!
name|fileflag
condition|)
name|getfield
argument_list|(
operator|&
name|fileflag
argument_list|,
name|hp
operator|->
name|ident
argument_list|)
expr_stmt|;
break|break;
case|case
name|REPLYTO
case|:
if|if
condition|(
operator|!
name|replyflag
condition|)
name|getfield
argument_list|(
operator|&
name|replyflag
argument_list|,
name|hp
operator|->
name|replyto
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOLLOWID
case|:
if|if
condition|(
operator|!
name|followflag
condition|)
name|getfield
argument_list|(
operator|&
name|followflag
argument_list|,
name|hp
operator|->
name|followid
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONTROL
case|:
if|if
condition|(
operator|!
name|ctlflag
condition|)
name|getfield
argument_list|(
operator|&
name|ctlflag
argument_list|,
name|hp
operator|->
name|ctlmsg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OTHER
case|:
if|if
condition|(
name|unreccnt
operator|<
name|NUNREC
condition|)
block|{
name|strcpy
argument_list|(
operator|&
name|hp
operator|->
name|unrec
index|[
name|unreccnt
index|]
index|[
literal|0
index|]
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|unreccnt
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|i
operator|=
name|type
argument_list|(
name|fgets
argument_list|(
name|bfr
argument_list|,
name|WDLEN
argument_list|,
name|fp
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
do|;
comment|/* 	if (*bfr != '\n') 		fseek(fp, curpos, 0); 	*/
if|if
condition|(
name|fromflag
operator|&&
name|subflag
operator|&&
name|fileflag
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_block

begin_macro
name|isat
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"@"
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"at"
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"AT"
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_block

begin_macro
name|getfield
argument_list|(
argument|flag
argument_list|,
argument|hpfield
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|hpfield
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|index
argument_list|(
name|bfr
argument_list|,
literal|':'
argument_list|)
init|;
name|isspace
argument_list|(
operator|*
operator|++
name|ptr
argument_list|)
condition|;
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
operator|*
name|flag
operator|=
name|TRUE
expr_stmt|;
name|strcpy
argument_list|(
name|hpfield
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|nstrip
argument_list|(
name|hpfield
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|type
argument_list|(
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|colon
decl_stmt|,
modifier|*
name|space
decl_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|colon
operator|=
name|index
argument_list|(
name|ptr
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|space
operator|=
name|index
argument_list|(
name|ptr
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|colon
operator|||
name|colon
operator|+
literal|1
operator|!=
name|space
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"From: "
argument_list|,
literal|6
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"Path: "
argument_list|,
literal|6
argument_list|)
condition|)
return|return
name|FROM
return|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"To: "
argument_list|,
literal|4
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"Newsgroups: "
argument_list|,
literal|12
argument_list|)
condition|)
return|return
name|NEWSGROUP
return|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"Subject: "
argument_list|,
literal|9
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"Title: "
argument_list|,
literal|7
argument_list|)
condition|)
return|return
name|TITLE
return|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"Posted: "
argument_list|,
literal|8
argument_list|)
condition|)
return|return
name|SUBMIT
return|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"Received: "
argument_list|,
literal|10
argument_list|)
condition|)
return|return
name|RECEIVE
return|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"Expires: "
argument_list|,
literal|9
argument_list|)
condition|)
return|return
name|EXPIRE
return|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"Article-I.D.: "
argument_list|,
literal|14
argument_list|)
condition|)
return|return
name|ARTICLEID
return|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"Reply-To: "
argument_list|,
literal|10
argument_list|)
condition|)
return|return
name|REPLYTO
return|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"References: "
argument_list|,
literal|12
argument_list|)
condition|)
return|return
name|FOLLOWID
return|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"Control: "
argument_list|,
literal|9
argument_list|)
condition|)
return|return
name|CONTROL
return|;
return|return
name|OTHER
return|;
block|}
end_block

begin_comment
comment|/*  * Write header at 'hp' on stream 'fp' in B format.  */
end_comment

begin_expr_stmt
name|hwrite
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ihwrite
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Same as above, except include receival date for local usage and  * an extra \n for looks.  */
end_comment

begin_expr_stmt
name|lhwrite
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ihwrite
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Write header at 'hp' on stream 'fp' in B format.  Include received date  * if wr is 1.  Leave off sysname if wr is 2.  */
end_comment

begin_expr_stmt
name|ihwrite
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|,
name|wr
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|iu
decl_stmt|;
name|ngdel
argument_list|(
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|nbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
literal|2
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"From: %s\nNewsgroups: %s\n"
argument_list|,
name|hp
operator|->
name|path
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"From: %s!%s\nNewsgroups: %s\n"
argument_list|,
name|SYSTEM
argument_list|,
name|hp
operator|->
name|path
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Title: %s\nArticle-I.D.: %s\n"
argument_list|,
name|hp
operator|->
name|title
argument_list|,
name|hp
operator|->
name|ident
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Posted: %s\n"
argument_list|,
name|hp
operator|->
name|subdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Received: %s\n"
argument_list|,
name|hp
operator|->
name|recdate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|expdate
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Expires: %s\n"
argument_list|,
name|hp
operator|->
name|expdate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|replyto
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Reply-To: %s\n"
argument_list|,
name|hp
operator|->
name|replyto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|followid
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"References: %s\n"
argument_list|,
name|hp
operator|->
name|followid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|ctlmsg
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Control: %s\n"
argument_list|,
name|hp
operator|->
name|ctlmsg
argument_list|)
expr_stmt|;
for|for
control|(
name|iu
operator|=
literal|0
init|;
name|iu
operator|<
name|NUNREC
condition|;
name|iu
operator|++
control|)
block|{
if|if
condition|(
name|hp
operator|->
name|unrec
index|[
name|iu
index|]
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
operator|&
name|hp
operator|->
name|unrec
index|[
name|iu
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

