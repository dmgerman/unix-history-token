begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)subnet.c	1.2	(Berkeley) 10/15/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|"../common/conf.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SUBNET
end_ifdef

begin_comment
comment|/*  * The following routines provide a general interface for  * subnet support.  Like the library function "inet_netof",  * which returns the standard (i.e., non-subnet) network  * portion of an internet address, "inet_snetof" returns  * the subnetwork portion -- if there is one.  If there  * isn't, it returns 0.  *  * Subnets, under 4.3, are specific to a given set of  * machines -- right down to the network interfaces.  * Because of this, the function "getifconf" must be  * called first.  This routine builds a table listing  * all the (internet) interfaces present on a machine,  * along with their subnet masks.  Then when inet_snetof  * is called, it can quickly scan this table.  *  * Unfortunately, there "ain't no graceful way" to handle  * certain situations.  For example, the kernel permits  * arbitrary subnet bits -- that is, you could have a  * 22 bit network field and a 10 bit subnet field.  * However, due to braindamage at the user level, in  * such sterling routines as getnetbyaddr, you need to  * have a subnet mask which is an even multiple of 8.  * Unless you are running with class C subnets, in which  * case it should be a multiple of 4.  Because of this rot,  * if you have non-multiples of 4 bits of subnet, you should  * define DAMAGED_NETMASK when you compile.  This will round  * things off to a multiple of 8 bits.  *  * And even that may not work.  */
end_comment

begin_comment
comment|/*  * One structure for each interface, containing  * the network number and subnet mask, stored in HBO.  */
end_comment

begin_struct
struct|struct
name|in_if
block|{
name|u_long
name|i_net
decl_stmt|;
comment|/* Network number, shifted right */
name|u_long
name|i_subnetmask
decl_stmt|;
comment|/* Subnet mask for this if */
name|int
name|i_bitshift
decl_stmt|;
comment|/* How many bits right for outside */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Table (eventually, once we malloc) of  * internet interface subnet informaiton.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|in_if
modifier|*
name|in_ifsni
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|if_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Get the network interface configuration,  * and squirrel away the network numbers and  * subnet masks of each interface.  Return  * number of interfaces found, or -1 on error.  * N.B.: don't call this more than once...  */
end_comment

begin_macro
name|getifconf
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|ifconf
name|ifc
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
specifier|register
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|u_long
name|inet_netof
parameter_list|()
function_decl|;
comment|/* 	 * Find out how many interfaces we have, and malloc 	 * room for information about each one. 	 */
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|buf
expr_stmt|;
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|&
name|ifc
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * if_count here is the count of possible 	 * interfaces we may be interested in... actual 	 * interfaces may be less (some may not be internet, 	 * not all are necessarily up, etc.) 	 */
name|if_count
operator|=
name|ifc
operator|.
name|ifc_len
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
expr_stmt|;
name|in_ifsni
operator|=
operator|(
expr|struct
name|in_if
operator|*
operator|)
name|malloc
argument_list|(
name|if_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|in_if
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_ifsni
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|if_count
condition|;
operator|++
name|i
control|)
block|{
name|ifr
operator|=
operator|&
name|ifc
operator|.
name|ifc_req
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
name|ifr
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ifr
operator|->
name|ifr_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFADDR
argument_list|,
name|ifr
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ifr
operator|->
name|ifr_addr
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
continue|continue;
name|in_ifsni
index|[
name|j
index|]
operator|.
name|i_net
operator|=
name|inet_netof
argument_list|(
operator|(
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifr
operator|->
name|ifr_addr
operator|)
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFNETMASK
argument_list|,
name|ifr
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
name|in_ifsni
index|[
name|j
index|]
operator|.
name|i_subnetmask
operator|=
name|ntohl
argument_list|(
operator|(
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifr
operator|->
name|ifr_addr
operator|)
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
comment|/* 		 * The following should "never happen".  But under SunOs 		 * 3.4, along with the rest of their broken networking code, 		 * SIOCGIFNETMASK can get a netmask which is 0.  There 		 * really isn't anything that "right" that we can do 		 * about it, so we'll set their subnet mask to be a class 		 * B subnet.  Which may or may not be right. 		 */
if|if
condition|(
name|in_ifsni
index|[
name|j
index|]
operator|.
name|i_subnetmask
operator|==
literal|0
condition|)
name|in_ifsni
index|[
name|j
index|]
operator|.
name|i_subnetmask
operator|=
name|IN_CLASSB_NET
expr_stmt|;
name|in_ifsni
index|[
name|j
index|]
operator|.
name|i_bitshift
operator|=
name|bsr
argument_list|(
name|in_ifsni
index|[
name|j
index|]
operator|.
name|i_subnetmask
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|if_count
operator|=
name|j
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|if_count
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Return the (sub)network number from an internet address.  * "in" is in NBO, return value in host byte order.  * If "in" is not a subnet, return 0.  */
end_comment

begin_function
name|u_long
name|inet_snetof
parameter_list|(
name|in
parameter_list|)
name|u_long
name|in
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|u_long
name|i
init|=
name|ntohl
argument_list|(
name|in
argument_list|)
decl_stmt|;
specifier|register
name|u_long
name|net
decl_stmt|;
name|u_long
name|inet_netof
argument_list|()
decl_stmt|,
name|inet_lnaof
argument_list|()
decl_stmt|;
name|net
operator|=
name|inet_netof
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|/* 	 * Check whether network is a subnet; 	 * if so, return subnet number. 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|if_count
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|net
operator|==
name|in_ifsni
index|[
name|j
index|]
operator|.
name|i_net
condition|)
block|{
name|net
operator|=
name|i
operator|&
name|in_ifsni
index|[
name|j
index|]
operator|.
name|i_subnetmask
expr_stmt|;
if|if
condition|(
name|inet_lnaof
argument_list|(
name|htonl
argument_list|(
name|net
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|net
operator|>>
name|in_ifsni
index|[
name|j
index|]
operator|.
name|i_bitshift
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of bits required to  * shift right a mask into a getnetent-able entitity.  */
end_comment

begin_expr_stmt
name|bsr
argument_list|(
name|mask
argument_list|)
specifier|register
name|int
name|mask
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
comment|/* "never happen", except with SunOs 3.4 */
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|(
name|mask
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
operator|++
name|count
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DAMAGED_NETMASK
name|count
operator|/=
literal|8
expr_stmt|;
comment|/* XXX gag retch puke barf */
name|count
operator|*=
literal|8
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|count
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

