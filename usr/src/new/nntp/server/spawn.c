begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)spawn.c	1.1	(Berkeley) 10/15/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../common/conf.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XFER_TIMEOUT
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|xfer_lines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|old_xfer_lines
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|tempfile
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * spawn -- create a child process with the input from the client  * as stdin.  *  *	Parameters:	"path" is the path of the program to invoke.  *			"name" is the name to call the program.  *			"flag" is a single flag to be passed to the program.  *			"cont_code" is the response code to transmit  *			on successful startup.  *			"err_code" is the response code to transmit when  *			something goes wrong.  *  *	Returns:	-1 on non-zero return from child,  *			0 on error before fork/exec,  *			1 otherwise.  *  *	Side effects:	Creates and removes temporary file;  *			accepts input from client; forks and execs.  *			Can time out if XFER_TIMEOUT is defined.  */
end_comment

begin_macro
name|spawn
argument_list|(
argument|path
argument_list|,
argument|name
argument_list|,
argument|flag
argument_list|,
argument|cont_code
argument_list|,
argument|err_code
argument_list|,
argument|errbuf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|path
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cont_code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|err_code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|errbuf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|line
index|[
name|MAX_STRLEN
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|;
name|int
name|fds
index|[
literal|2
index|]
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|npid
decl_stmt|;
name|int
name|exit_status
decl_stmt|;
ifdef|#
directive|ifdef
name|XFER_TIMEOUT
name|int
name|xfer_timeout
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|otimeout
function_decl|)
parameter_list|()
function_decl|;
endif|#
directive|endif
name|union
name|wait
name|status
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tempfile
argument_list|,
literal|"/tmp/rpostXXXXXX"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|tempfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%d Cannot create temporary file.\r\n"
argument_list|,
name|err_code
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%d Enter news, period on a line by itself to end.\r\n"
argument_list|,
name|cont_code
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|XFER_TIMEOUT
name|xfer_lines
operator|=
name|old_xfer_lines
operator|=
literal|0
expr_stmt|;
name|otimeout
operator|=
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|xfer_timeout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
name|XFER_TIMEOUT
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|XFER_TIMEOUT
name|xfer_lines
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|line
argument_list|,
literal|'\r'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|line
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
name|fputs
argument_list|(
name|line
operator|+
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|line
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XFER_TIMEOUT
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|otimeout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* See if the connection got closed somehow... */
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|&&
name|line
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSLOG
ifdef|#
directive|ifdef
name|LOG
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s spawn: EOF before period on line by itself"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
else|#
directive|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spawn: EOF before period on line by itself"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|POSTER
operator|(
name|void
operator|)
name|chown
argument_list|(
name|tempfile
argument_list|,
name|uid_poster
argument_list|,
name|gid_poster
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set up a pipe so we can see errors from rnews */
if|if
condition|(
name|pipe
argument_list|(
name|fds
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SYSLOG
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spawn: pipe: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Ok, now we have the article in "tempfile".  We 	 * should be able to fork off, close fd's 0 to 31 (or 	 * whatever), open "tempfile" for input, thus making 	 * it stdin, and then execl the inews.  We think. 	 */
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* We're in child */
ifdef|#
directive|ifdef
name|POSTER
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|uid_poster
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|gid_poster
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set up stdout and stderr for child */
if|if
condition|(
name|fds
index|[
literal|1
index|]
operator|!=
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
literal|10
condition|;
operator|++
name|i
control|)
comment|/* XXX but getdtablesize is too big */
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|tempfile
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|execl
argument_list|(
name|path
argument_list|,
name|name
argument_list|,
name|flag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"spawn: execl "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Error */
block|}
else|else
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fdopen
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%d Cannot fdopen %s pipe\r\n"
argument_list|,
name|err_code
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSLOG
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spawn: pipe: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|errbuf
condition|)
operator|*
name|errbuf
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|errbuf
condition|)
block|{
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|errbuf
argument_list|,
name|line
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|errbuf
argument_list|,
literal|"\\"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SYSLOG
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %s"
argument_list|,
name|path
argument_list|,
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
while|while
condition|(
operator|(
name|npid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|npid
operator|==
name|pid
condition|)
block|{
name|exit_status
operator|=
name|status
operator|.
name|w_T
operator|.
name|w_Retcode
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|npid
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SYSLOG
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spawn: wait pid %d: %m"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SYSLOG
if|if
condition|(
name|exit_status
operator|!=
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"spawn: %s exit status %d"
argument_list|,
name|path
argument_list|,
name|exit_status
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|exit_status
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|XFER_TIMEOUT
end_ifdef

begin_macro
name|xfer_timeout
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|old_xfer_lines
operator|<
name|xfer_lines
condition|)
block|{
name|old_xfer_lines
operator|=
name|xfer_lines
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
name|XFER_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Timed out. */
name|printf
argument_list|(
literal|"%d timeout after %d seconds, closing connection.\r\n"
argument_list|,
name|ERR_FAULT
argument_list|,
name|XFER_TIMEOUT
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s transfer_timeout"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|XFER_TIMEOUT
end_endif

end_unit

