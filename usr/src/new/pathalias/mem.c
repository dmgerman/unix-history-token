begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pathalias -- by steve bellovin, as told to peter honeyman */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)mem.c	8.1 (down!honey) 86/01/19"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"def.h"
end_include

begin_comment
comment|/* imported */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|link
modifier|*
name|newlink
parameter_list|()
block|{
name|link
modifier|*
name|rval
decl_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
operator|(
name|link
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|link
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
name|node
modifier|*
name|newnode
parameter_list|()
block|{
name|node
modifier|*
name|rval
decl_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
operator|(
name|node
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|node
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|Ncount
operator|++
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|strsave
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|r
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|strclear
end_ifndef

begin_function
name|void
name|strclear
parameter_list|(
name|dst
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
operator|*
name|dst
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*strclear*/
end_comment

begin_function
name|node
modifier|*
modifier|*
name|newtable
parameter_list|(
name|size
parameter_list|)
name|long
name|size
decl_stmt|;
block|{
name|node
modifier|*
modifier|*
name|rval
decl_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
operator|(
name|node
operator|*
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rval
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|nomem
argument_list|()
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_macro
name|freetable
argument_list|(
argument|t
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|node
modifier|*
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|MYMALLOC
name|addtoheap
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|,
call|(
name|long
call|)
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|nomem
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Out of memory (%ldk allocated)\n"
argument_list|,
name|ProgName
argument_list|,
name|allocation
argument_list|()
argument_list|)
expr_stmt|;
name|badmagic
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* data space allocation -- main sets End very early */
end_comment

begin_macro
name|allocation
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|char
modifier|*
name|dataspace
decl_stmt|;
if|if
condition|(
name|dataspace
operator|==
literal|0
condition|)
block|{
comment|/* first time */
name|dataspace
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*&end? */
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|sbrk
argument_list|(
literal|0
argument_list|)
operator|-
name|dataspace
operator|)
operator|/
literal|1024
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|MYMALLOC
end_ifdef

begin_comment
comment|/* use c library malloc/calloc here, and here only */
end_comment

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_undef
undef|#
directive|undef
name|calloc
end_undef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|calloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* allocate in MBUFSIZ chunks.  4k works ok (less 16 for malloc quirks). */
end_comment

begin_define
define|#
directive|define
name|MBUFSIZ
value|(4 * 1024 - 16)
end_define

begin_comment
comment|/*   * mess with ALIGN at your peril.  longword (== 0 mod 4)  * alignment seems to work everywhere.  */
end_comment

begin_define
define|#
directive|define
name|ALIGN
value|2
end_define

begin_typedef
typedef|typedef
name|struct
name|heap
name|heap
typedef|;
end_typedef

begin_struct
struct|struct
name|heap
block|{
name|heap
modifier|*
name|h_next
decl_stmt|;
name|long
name|h_size
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|heap
modifier|*
name|Mheap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* not to be confused with a priority queue */
end_comment

begin_macro
name|addtoheap
argument_list|(
argument|p
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|adjustment
decl_stmt|;
name|heap
modifier|*
name|pheap
decl_stmt|;
comment|/* p is aligned, but it doesn't hurt to check */
name|adjustment
operator|=
name|align
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|adjustment
expr_stmt|;
name|size
operator|-=
name|adjustment
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1024
condition|)
return|return;
comment|/* can't happen */
name|pheap
operator|=
operator|(
name|heap
operator|*
operator|)
name|p
expr_stmt|;
comment|/* pheap is shorthand */
name|pheap
operator|->
name|h_next
operator|=
name|Mheap
expr_stmt|;
name|pheap
operator|->
name|h_size
operator|=
name|size
expr_stmt|;
name|Mheap
operator|=
name|pheap
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * buffered malloc()  *	returns space initialized to 0.  calloc isn't used, since  *	strclear can be faster.  *  * free is ignored, except for very large objects,  * which are returned to the heap with addtoheap().   */
end_comment

begin_function
name|char
modifier|*
name|mymalloc
parameter_list|(
name|n
parameter_list|)
specifier|register
name|unsigned
name|int
name|n
decl_stmt|;
block|{
specifier|static
name|long
name|size
decl_stmt|;
comment|/* how much do we have on hand? */
specifier|static
name|char
modifier|*
name|mstash
decl_stmt|;
comment|/* where is it?  (kept aligned) */
specifier|register
name|char
modifier|*
name|rval
decl_stmt|;
name|n
operator|+=
name|align
argument_list|(
operator|(
name|char
operator|*
operator|)
name|n
argument_list|)
expr_stmt|;
comment|/* keep everything aligned */
if|if
condition|(
name|n
operator|>=
literal|1024
condition|)
block|{
comment|/* from hash table */
name|rval
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* aligned */
name|strclear
argument_list|(
name|rval
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|>
name|size
condition|)
block|{
comment|/* look in the heap (already aligned) */
if|if
condition|(
name|Mheap
condition|)
block|{
name|mstash
operator|=
operator|(
name|char
operator|*
operator|)
name|Mheap
expr_stmt|;
name|size
operator|=
name|Mheap
operator|->
name|h_size
expr_stmt|;
name|Mheap
operator|=
name|Mheap
operator|->
name|h_next
expr_stmt|;
block|}
else|else
block|{
name|mstash
operator|=
name|malloc
argument_list|(
name|MBUFSIZ
argument_list|)
expr_stmt|;
comment|/* aligned */
if|if
condition|(
name|mstash
operator|==
literal|0
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|size
operator|=
name|MBUFSIZ
expr_stmt|;
block|}
name|strclear
argument_list|(
name|mstash
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|rval
operator|=
name|mstash
expr_stmt|;
name|mstash
operator|+=
name|n
expr_stmt|;
name|size
operator|-=
name|n
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* what's the (mis-)alignment of n?  return the complement of (n mod 2^ALIGN) */
end_comment

begin_macro
name|align
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|abits
decl_stmt|;
comment|/* misalignment bits in n */
name|abits
operator|=
operator|(
name|int
operator|)
name|n
operator|&
operator|~
operator|(
literal|0xff
operator|<<
name|ALIGN
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|abits
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|(
literal|1
operator|<<
name|ALIGN
operator|)
operator|-
name|abits
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*MYMALLOC*/
end_comment

end_unit

