begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header$ */
end_comment

begin_comment
comment|/*  * Author: Peter J. Nicklin  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"date.h"
end_include

begin_include
include|#
directive|include
file|"from.h"
end_include

begin_include
include|#
directive|include
file|"null.h"
end_include

begin_include
include|#
directive|include
file|"yesno.h"
end_include

begin_define
define|#
directive|define
name|INCRFROM
value|1000
end_define

begin_comment
comment|/* amount to increase From ptr array */
end_comment

begin_define
define|#
directive|define
name|MAXFROM
value|1000
end_define

begin_comment
comment|/* initial size of From pointer array */
end_comment

begin_decl_stmt
specifier|static
name|FROM
modifier|*
modifier|*
name|Fromp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to "From " pointer array */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Ifrom
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current "From " ptr array index */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Maxfrom
init|=
name|MAXFROM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum number of "From " lines */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Nfrom
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of "From " lines */
end_comment

begin_comment
comment|/*  * fromcmp() compares the dates of two "From " lines and returns an integer  * less than, equal to, or greater than zero, according to the chronological  * order of the dates.  */
end_comment

begin_function
specifier|static
name|int
name|fromcmp
parameter_list|(
name|f1
parameter_list|,
name|f2
parameter_list|)
specifier|register
name|FROM
modifier|*
modifier|*
name|f1
decl_stmt|;
comment|/* FROM struct pointer */
specifier|register
name|FROM
modifier|*
modifier|*
name|f2
decl_stmt|;
comment|/* FROM struct pointer */
block|{
specifier|register
name|int
name|d
decl_stmt|;
comment|/* relative time */
if|if
condition|(
operator|(
name|d
operator|=
operator|(
operator|*
name|f1
operator|)
operator|->
name|bdt
operator|.
name|t_year
operator|-
operator|(
operator|*
name|f2
operator|)
operator|->
name|bdt
operator|.
name|t_year
operator|)
operator|<
literal|0
operator|||
name|d
operator|>
literal|0
condition|)
return|return
operator|(
name|d
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|d
operator|=
operator|(
operator|*
name|f1
operator|)
operator|->
name|bdt
operator|.
name|t_mon
operator|-
operator|(
operator|*
name|f2
operator|)
operator|->
name|bdt
operator|.
name|t_mon
operator|)
operator|<
literal|0
operator|||
name|d
operator|>
literal|0
condition|)
return|return
operator|(
name|d
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|d
operator|=
operator|(
operator|*
name|f1
operator|)
operator|->
name|bdt
operator|.
name|t_day
operator|-
operator|(
operator|*
name|f2
operator|)
operator|->
name|bdt
operator|.
name|t_day
operator|)
operator|<
literal|0
operator|||
name|d
operator|>
literal|0
condition|)
return|return
operator|(
name|d
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|d
operator|=
operator|(
operator|*
name|f1
operator|)
operator|->
name|bdt
operator|.
name|t_hour
operator|-
operator|(
operator|*
name|f2
operator|)
operator|->
name|bdt
operator|.
name|t_hour
operator|)
operator|<
literal|0
operator|||
name|d
operator|>
literal|0
condition|)
return|return
operator|(
name|d
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|d
operator|=
operator|(
operator|*
name|f1
operator|)
operator|->
name|bdt
operator|.
name|t_min
operator|-
operator|(
operator|*
name|f2
operator|)
operator|->
name|bdt
operator|.
name|t_min
operator|)
operator|<
literal|0
operator|||
name|d
operator|>
literal|0
condition|)
return|return
operator|(
name|d
operator|)
return|;
return|return
operator|(
operator|(
operator|*
name|f1
operator|)
operator|->
name|bdt
operator|.
name|t_sec
operator|-
operator|(
operator|*
name|f2
operator|)
operator|->
name|bdt
operator|.
name|t_sec
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * isfrom() returns a pointer to a "From " line struct if a "From " line,  * otherwise NULL.  */
end_comment

begin_function
name|FROM
modifier|*
name|isfrom
parameter_list|(
name|linebuf
parameter_list|)
name|char
modifier|*
name|linebuf
decl_stmt|;
comment|/* line to be examined */
block|{
specifier|static
name|FROM
name|from
decl_stmt|;
comment|/* "From " line struct */
specifier|static
name|char
name|frombuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* parsed "From " line buffer */
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
comment|/* string copy */
name|int
name|isdate
parameter_list|()
function_decl|;
comment|/* is string a ctime(3) date? */
name|int
name|strncmp
parameter_list|()
function_decl|;
comment|/* compare strings for n chars */
name|void
name|parsefrom
parameter_list|()
function_decl|;
comment|/* parse "From " line */
if|if
condition|(
name|strncmp
argument_list|(
name|linebuf
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * save a copy of linebuf in frombuf because parsefrom() 	 * breaks up the buffer into several strings and assigns 	 * from struct pointers to those strings 	 */
name|strcpy
argument_list|(
name|frombuf
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|parsefrom
argument_list|(
name|frombuf
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdate
argument_list|(
name|from
operator|.
name|date
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|from
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * initfrom() creates a "From " pointer array and initializes it with  * a dummy from struct to take care of spurious lines of information  * before the first "From " line in the file. Returns a pointer to the  * from struct, or NULL if out of memory.  */
end_comment

begin_function
name|FROM
modifier|*
name|initfrom
parameter_list|()
block|{
name|char
modifier|*
name|calloc
parameter_list|()
function_decl|;
comment|/* zeroed memory allocation */
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
comment|/* memory allocator */
if|if
condition|(
operator|(
name|Fromp
operator|=
operator|(
name|FROM
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|Maxfrom
operator|*
sizeof|sizeof
argument_list|(
name|FROM
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|FROM
operator|*
operator|)
name|NULL
operator|)
return|;
name|Ifrom
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|Fromp
index|[
name|Ifrom
index|]
operator|=
operator|(
name|FROM
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|FROM
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|FROM
operator|*
operator|)
name|NULL
operator|)
return|;
name|Nfrom
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|Fromp
index|[
name|Ifrom
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nextword() collects a liberal (blank, tab delimited) word and returns a  * pointer to the next word or string.  */
end_comment

begin_function
name|char
modifier|*
name|nextword
parameter_list|(
name|word
parameter_list|,
name|bp
parameter_list|)
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
comment|/* buffer pointer */
name|char
modifier|*
modifier|*
name|word
decl_stmt|;
comment|/* word or string */
block|{
for|for
control|(
init|;
operator|*
name|bp
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
operator|*
name|bp
argument_list|)
condition|;
name|bp
operator|++
control|)
continue|continue;
operator|*
name|word
operator|=
name|bp
expr_stmt|;
for|for
control|(
init|;
operator|*
name|bp
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|bp
argument_list|)
condition|;
name|bp
operator|++
control|)
continue|continue;
operator|*
name|bp
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
operator|*
name|bp
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
operator|*
name|bp
argument_list|)
condition|;
name|bp
operator|++
control|)
continue|continue;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * outfrom() copies an input stream to an output stream in chronological  * order of "From " messages. Returns YES if successful, otherwise NO.  */
end_comment

begin_expr_stmt
name|outfrom
argument_list|(
name|ifp
argument_list|,
name|ofp
argument_list|)
specifier|register
name|FILE
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* input stream */
end_comment

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|ofp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output stream */
end_comment

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* current character */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* "From " pointer array index */
specifier|register
name|int
name|n
decl_stmt|;
comment|/* character counter */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Nfrom
condition|;
name|i
operator|++
control|)
block|{
name|fseek
argument_list|(
name|ifp
argument_list|,
name|Fromp
index|[
name|i
index|]
operator|->
name|m_seek
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|Fromp
index|[
name|i
index|]
operator|->
name|m_len
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|putc
argument_list|(
name|c
argument_list|,
name|ofp
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|NO
operator|)
return|;
block|}
block|}
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * parsefrom splits a "From " line into its components and sets from  * struct pointers into frombuf.  */
end_comment

begin_function
name|void
name|parsefrom
parameter_list|(
name|frombuf
parameter_list|,
name|from
parameter_list|)
name|char
modifier|*
name|frombuf
decl_stmt|;
comment|/* "From " line buffer */
name|FROM
modifier|*
name|from
decl_stmt|;
comment|/* "From " line struct */
block|{
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
comment|/* date pointer */
specifier|register
name|char
modifier|*
name|fb
decl_stmt|;
comment|/* frombuf pointer */
name|char
modifier|*
name|nextword
parameter_list|()
function_decl|;
comment|/* get word& go to next word */
name|char
modifier|*
name|skipword
parameter_list|()
function_decl|;
comment|/* skip to next word */
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
comment|/* string copy */
name|int
name|strncmp
parameter_list|()
function_decl|;
comment|/* compare strings for n chars */
name|fb
operator|=
name|frombuf
expr_stmt|;
name|fb
operator|=
name|nextword
argument_list|(
operator|&
name|from
operator|->
name|from
argument_list|,
name|skipword
argument_list|(
name|fb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
literal|"tty"
argument_list|,
name|fb
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|fb
operator|=
name|nextword
argument_list|(
operator|&
name|from
operator|->
name|tty
argument_list|,
name|skipword
argument_list|(
name|fb
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|->
name|date
operator|=
name|fb
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|fb
init|;
operator|*
name|dp
operator|!=
literal|'\n'
operator|&&
operator|*
name|dp
operator|!=
literal|'\0'
condition|;
name|dp
operator|++
control|)
continue|continue;
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * savefrom() saves a "From " struct somewhere and appends it to the From  * pointer array. The array is extended if necessary. Returns a pointer  * to the somewhere, or NULL if out of memory.  */
end_comment

begin_function
name|FROM
modifier|*
name|savefrom
parameter_list|(
name|f
parameter_list|)
name|FROM
modifier|*
name|f
decl_stmt|;
comment|/* "From " line struct */
block|{
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
comment|/* memory allocator */
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
comment|/* reallocate memory block */
if|if
condition|(
name|Nfrom
operator|>
name|Maxfrom
condition|)
block|{
name|Maxfrom
operator|+=
name|INCRFROM
expr_stmt|;
if|if
condition|(
operator|(
name|Fromp
operator|=
operator|(
name|FROM
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Fromp
argument_list|,
operator|(
name|unsigned
operator|)
name|Maxfrom
operator|*
sizeof|sizeof
argument_list|(
name|FROM
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|FROM
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|Fromp
index|[
operator|++
name|Ifrom
index|]
operator|=
operator|(
name|FROM
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FROM
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|FROM
operator|*
operator|)
name|NULL
operator|)
return|;
name|Nfrom
operator|++
expr_stmt|;
name|Fromp
index|[
name|Ifrom
index|]
operator|->
name|bdt
operator|.
name|t_sec
operator|=
name|f
operator|->
name|bdt
operator|.
name|t_sec
expr_stmt|;
name|Fromp
index|[
name|Ifrom
index|]
operator|->
name|bdt
operator|.
name|t_min
operator|=
name|f
operator|->
name|bdt
operator|.
name|t_min
expr_stmt|;
name|Fromp
index|[
name|Ifrom
index|]
operator|->
name|bdt
operator|.
name|t_hour
operator|=
name|f
operator|->
name|bdt
operator|.
name|t_hour
expr_stmt|;
name|Fromp
index|[
name|Ifrom
index|]
operator|->
name|bdt
operator|.
name|t_day
operator|=
name|f
operator|->
name|bdt
operator|.
name|t_day
expr_stmt|;
name|Fromp
index|[
name|Ifrom
index|]
operator|->
name|bdt
operator|.
name|t_mon
operator|=
name|f
operator|->
name|bdt
operator|.
name|t_mon
expr_stmt|;
name|Fromp
index|[
name|Ifrom
index|]
operator|->
name|bdt
operator|.
name|t_year
operator|=
name|f
operator|->
name|bdt
operator|.
name|t_year
expr_stmt|;
name|Fromp
index|[
name|Ifrom
index|]
operator|->
name|m_seek
operator|=
name|f
operator|->
name|m_seek
expr_stmt|;
name|Fromp
index|[
name|Ifrom
index|]
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|Fromp
index|[
name|Ifrom
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * sortfrom() sorts "From " lines chronologically.  */
end_comment

begin_function
name|void
name|sortfrom
parameter_list|()
block|{
name|int
name|fromcmp
parameter_list|()
function_decl|;
comment|/* compare "From " lines by date */
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Fromp
argument_list|,
name|Nfrom
argument_list|,
sizeof|sizeof
argument_list|(
name|FROM
operator|*
argument_list|)
argument_list|,
name|fromcmp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

