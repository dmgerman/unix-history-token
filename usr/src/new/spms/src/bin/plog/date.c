begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header$ */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"date.h"
end_include

begin_include
include|#
directive|include
file|"null.h"
end_include

begin_include
include|#
directive|include
file|"yesno.h"
end_include

begin_comment
comment|/*  * date template character codes  */
end_comment

begin_define
define|#
directive|define
name|L
value|1
end_define

begin_comment
comment|/* a lower case chararacter */
end_comment

begin_define
define|#
directive|define
name|U
value|2
end_define

begin_comment
comment|/* an upper case character */
end_comment

begin_define
define|#
directive|define
name|S
value|3
end_define

begin_comment
comment|/* a space */
end_comment

begin_define
define|#
directive|define
name|D
value|4
end_define

begin_comment
comment|/* a digit */
end_comment

begin_define
define|#
directive|define
name|O
value|5
end_define

begin_comment
comment|/* an optional digit or space */
end_comment

begin_define
define|#
directive|define
name|C
value|6
end_define

begin_comment
comment|/* a colon */
end_comment

begin_define
define|#
directive|define
name|N
value|7
end_define

begin_comment
comment|/* a newline */
end_comment

begin_comment
comment|/*  * date templates  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|ctypes
index|[]
init|=
block|{
name|U
block|,
name|L
block|,
name|L
block|,
name|S
block|,
name|U
block|,
name|L
block|,
name|L
block|,
name|S
block|,
name|O
block|,
name|D
block|,
name|S
block|,
name|D
block|,
name|D
block|,
name|C
block|,
name|D
block|,
name|D
block|,
name|C
block|,
name|D
block|,
name|D
block|,
name|S
block|,
name|D
block|,
name|D
block|,
name|D
block|,
name|D
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|tmztypes
index|[]
init|=
block|{
name|U
block|,
name|L
block|,
name|L
block|,
name|S
block|,
name|U
block|,
name|L
block|,
name|L
block|,
name|S
block|,
name|O
block|,
name|D
block|,
name|S
block|,
name|D
block|,
name|D
block|,
name|C
block|,
name|D
block|,
name|D
block|,
name|C
block|,
name|D
block|,
name|D
block|,
name|S
block|,
name|U
block|,
name|U
block|,
name|U
block|,
name|S
block|,
name|D
block|,
name|D
block|,
name|D
block|,
name|D
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mon_tab
index|[]
init|=
block|{
literal|"illegal month"
block|,
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * cmatch() matchs a date against a given template. Returns constant 1 if  * there is a match, otherwise 0.  */
end_comment

begin_expr_stmt
specifier|static
name|cmatch
argument_list|(
name|date
argument_list|,
name|template
argument_list|)
specifier|register
name|char
operator|*
name|date
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* date string */
end_comment

begin_decl_stmt
specifier|register
name|char
modifier|*
name|template
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* template array */
end_comment

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* comparison character */
for|for
control|(
name|c
operator|=
operator|*
name|date
operator|++
init|;
name|c
operator|!=
literal|'\0'
operator|&&
operator|*
name|template
operator|!=
literal|0
condition|;
name|c
operator|=
operator|*
name|date
operator|++
control|)
switch|switch
condition|(
operator|*
name|template
operator|++
condition|)
block|{
case|case
name|L
case|:
if|if
condition|(
operator|!
name|islower
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|U
case|:
if|if
condition|(
operator|!
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|S
case|:
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|D
case|:
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|O
case|:
if|if
condition|(
name|c
operator|!=
literal|' '
operator|&&
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|C
case|:
if|if
condition|(
name|c
operator|!=
literal|':'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|N
case|:
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
if|if
condition|(
name|c
operator|!=
literal|'\0'
operator|||
operator|*
name|template
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * isdate() tests if date is a ctime(3) generated date string.  * The ctypes template is used as the criterion of correctness. Also  * a possible trailing timezone is checked by the tmztype template.  * Returns constant 1 if valid, otherwise 0.  */
end_comment

begin_macro
name|isdate
argument_list|(
argument|date
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|date
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* date string */
end_comment

begin_block
block|{
name|int
name|cmatch
parameter_list|()
function_decl|;
comment|/* match date against template */
if|if
condition|(
name|cmatch
argument_list|(
name|date
argument_list|,
name|ctypes
argument_list|)
operator|==
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|cmatch
argument_list|(
name|date
argument_list|,
name|tmztypes
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * parsedate() breaks down the time returned by ctime(3) into a DATE  * struct. Returns constant NO if a bad date, otherwise YES.  */
end_comment

begin_macro
name|parsedate
argument_list|(
argument|cdate
argument_list|,
argument|dt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cdate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ctime(3) generated date string */
end_comment

begin_decl_stmt
name|DATE
modifier|*
name|dt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to broken-down time struct */
end_comment

begin_block
block|{
name|int
name|atoi
parameter_list|()
function_decl|;
comment|/* convert alpha string to integer */
name|int
name|cmatch
parameter_list|()
function_decl|;
comment|/* match date against template */
name|int
name|strncmp
parameter_list|()
function_decl|;
comment|/* compare n characters in string */
if|if
condition|(
name|cmatch
argument_list|(
name|cdate
argument_list|,
name|ctypes
argument_list|)
operator|==
literal|1
condition|)
block|{
name|dt
operator|->
name|t_year
operator|=
name|atoi
argument_list|(
name|cdate
operator|+
literal|20
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmatch
argument_list|(
name|cdate
argument_list|,
name|tmztypes
argument_list|)
operator|==
literal|1
condition|)
block|{
name|dt
operator|->
name|t_year
operator|=
name|atoi
argument_list|(
name|cdate
operator|+
literal|24
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|NO
operator|)
return|;
block|}
for|for
control|(
name|dt
operator|->
name|t_mon
operator|=
literal|12
init|;
name|dt
operator|->
name|t_mon
operator|>
literal|0
condition|;
name|dt
operator|->
name|t_mon
operator|--
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|mon_tab
index|[
name|dt
operator|->
name|t_mon
index|]
argument_list|,
name|cdate
operator|+
literal|4
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|dt
operator|->
name|t_mon
operator|<=
literal|0
condition|)
return|return
operator|(
name|NO
operator|)
return|;
name|dt
operator|->
name|t_day
operator|=
name|atoi
argument_list|(
name|cdate
operator|+
literal|8
argument_list|)
expr_stmt|;
name|dt
operator|->
name|t_hour
operator|=
name|atoi
argument_list|(
name|cdate
operator|+
literal|11
argument_list|)
expr_stmt|;
name|dt
operator|->
name|t_min
operator|=
name|atoi
argument_list|(
name|cdate
operator|+
literal|14
argument_list|)
expr_stmt|;
name|dt
operator|->
name|t_sec
operator|=
name|atoi
argument_list|(
name|cdate
operator|+
literal|17
argument_list|)
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

end_unit

