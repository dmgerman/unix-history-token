begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: Xtextlib.c,v 10.6 86/04/23 12:03:28 jg Rel $ */
end_comment

begin_comment
comment|/* Library of routines for creating a simple text output window.  *  * Routines in the library are:  *  *	TextCreate		Creates a new instance of a text window  *	TextDestroy		Destroys the window  *	TextClear		Clears a text window  *	TextRedisplay		Redisplays one or all windows  *	TextEvent		Handles exposure and unmapping events  *	TextFlush		Flush and handle all outstanding events for  *				one or all TextWindows.  *	TextPutString		Displays a string in a text window  *	TextPutChar		Displays a character in a text window  *	TextPrintf		Does a printf in a text window  *  * Most of these routines pass around a pointer to a TextWindow data structure:  *  * typedef struct _TextWindow {  *	Window w;		Window to use  *	FontInfo *font;		Font to use for text  *	short num_lines;	Number of lines in the window  *	short num_chars;	The length of each line  *	short mapped;		Whether or not the window is mapped  *	short height;		Height of window in pixels  *	short width;		Width of window in pixels  *	short first_line;	The index of the first line  *	char **lines;		Ptr to array of text lines  *	short *line_length;	Ptr to array of line lengths (in pixels)  *	short *line_chars;	Ptr to array of line lengths in chars  *	short last_line;	Which line is the last  *	short last_char;	Length of the last line  *	short next_x;		X-coord for next character  *	short next_y;		Y-coord for next character  *	unsigned int eventmask;	List of events we're interested in  *	char *scroll_history;	Ptr to list of scroll amounts  *	short scroll_count;	Number of outstanding scrolls  *	short scroll_start;	Where in the history the history starts  *	short old_scrolls;	Number of ignorable outstanding scrolls  *	short fastscroll;	Whether or not to use fast scrolling  * } TextWindow;   *  * Applications should not modify anything in this data structure, obviously!  * They may, however, have reason to get information out of it. (Such as the  * window id for mapping).  *  * Information about the first line of the window is stored in the array  * entries subscripted by [first_line]; the arrays wrap back up at the end.  * Last_char should always be the same as line_chars[last_line].   * Similarly, next_x should always be the same as line_length[last_line];  *  * The only complicated thing about these procedures is the way they keep  * track of scrolling.  When a scroll is done, X sends ExposeRegions for  * every region that needs to be patched up and then an ExposeCopy event.  * The ExposeCopy comes even if there were no regions.  The only problem  * is that more scrolls may have been done in the meantime.  So we keep a  * history of how much cumulative scrolling has been done in the  * scroll_history list.  scroll_start tells which one to start with, and  * scroll_count tells how many there are (they wrap around).  The list is  * num_lines long since anything that's scrolled away longer ago than that  * has scrolled off the screen.  The old_scrolls field gets set whenever the  * screen is fully updated for some reason or other; it means that that  * many ExposeCopy events can be completely ignored since the screen has  * been fully updated.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"Xtext.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define the width of the left margin */
end_comment

begin_define
define|#
directive|define
name|mar_width
value|2
end_define

begin_decl_stmt
name|char
modifier|*
name|calloc
argument_list|()
decl_stmt|,
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable is sometimes set by TextPutString to temporarily    disable screen updating. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dont_update
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  * the following variable is the head pointer to a list of TextWindows  */
end_comment

begin_decl_stmt
specifier|static
name|TextWindow
modifier|*
name|head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * add a new TextWindow to the list of TextWindows created for this  * process.  */
end_comment

begin_expr_stmt
specifier|static
name|AddTextWindow
argument_list|(
argument|t
argument_list|)
name|TextWindow
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|TextWindow
modifier|*
name|p
decl_stmt|;
name|t
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|head
condition|)
block|{
name|p
operator|=
name|head
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|next
condition|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
name|head
operator|=
name|t
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * delete a TextWindow from the list of TextWindows created for this  * process.  */
end_comment

begin_expr_stmt
specifier|static
name|DelTextWindow
argument_list|(
argument|t
argument_list|)
name|TextWindow
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|TextWindow
modifier|*
name|p
init|=
name|head
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return;
comment|/* shouldn't happen! no list. */
if|if
condition|(
name|p
operator|==
name|t
condition|)
block|{
name|head
operator|=
name|t
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|p
operator|->
name|next
operator|&&
operator|(
name|t
operator|!=
name|p
operator|->
name|next
operator|)
condition|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|p
operator|->
name|next
condition|)
return|return;
comment|/* shouldn't happen! not found */
name|p
operator|->
name|next
operator|=
name|t
operator|->
name|next
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* TextCreate creates a new window which will use the  * specified font.  The window is height lines high and width  * characters wide.  Note that since a variable-width font may be  * used, the width is calculated using the average width of the font.  * Colors are used as specified.  */
end_comment

begin_function
name|TextWindow
modifier|*
name|TextCreate
parameter_list|(
name|width
parameter_list|,
name|height
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|parent
parameter_list|,
name|fontname
parameter_list|,
name|bwidth
parameter_list|,
name|fgpixel
parameter_list|,
name|bgpixel
parameter_list|,
name|bordercolor
parameter_list|,
name|fastscroll
parameter_list|)
name|int
name|height
decl_stmt|,
name|width
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|bwidth
decl_stmt|,
name|fastscroll
decl_stmt|;
name|Window
name|parent
decl_stmt|;
name|char
modifier|*
name|fontname
decl_stmt|;
name|int
name|fgpixel
decl_stmt|,
name|bgpixel
decl_stmt|;
name|Pixmap
name|bordercolor
decl_stmt|;
block|{
specifier|register
name|TextWindow
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|FontInfo
modifier|*
name|f
decl_stmt|;
name|Window
name|XCreateWindow
parameter_list|()
function_decl|;
name|Pixmap
name|bgpixmap
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
operator|(
name|TextWindow
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TextWindow
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|AddTextWindow
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* add to list of TextWindows */
if|if
condition|(
operator|(
name|f
operator|=
name|t
operator|->
name|font
operator|=
name|XOpenFont
argument_list|(
name|fontname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|TextDestroy
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|t
operator|->
name|fgpixel
operator|=
name|fgpixel
expr_stmt|;
name|t
operator|->
name|bgpixel
operator|=
name|bgpixel
expr_stmt|;
if|if
condition|(
operator|(
name|bgpixmap
operator|=
name|XMakeTile
argument_list|(
name|bgpixel
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|TextDestroy
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|t
operator|->
name|width
operator|=
name|width
operator|*
name|f
operator|->
name|width
operator|+
name|mar_width
expr_stmt|;
name|t
operator|->
name|height
operator|=
name|height
operator|*
name|f
operator|->
name|height
expr_stmt|;
name|t
operator|->
name|w
operator|=
name|XCreateWindow
argument_list|(
name|parent
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|t
operator|->
name|width
argument_list|,
name|t
operator|->
name|height
argument_list|,
name|bwidth
argument_list|,
name|bordercolor
argument_list|,
name|bgpixmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|w
operator|==
name|NULL
condition|)
block|{
name|TextDestroy
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|XFreePixmap
argument_list|(
name|bgpixmap
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|XFreePixmap
argument_list|(
name|bgpixmap
argument_list|)
expr_stmt|;
name|t
operator|->
name|eventmask
operator|=
name|ExposeRegion
operator||
name|ExposeWindow
operator||
name|ExposeCopy
operator||
name|UnmapWindow
expr_stmt|;
comment|/* (ExposeRegion automatically selects ExposeWindow) */
name|XSelectInput
argument_list|(
name|t
operator|->
name|w
argument_list|,
name|t
operator|->
name|eventmask
argument_list|)
expr_stmt|;
name|XSetResizeHint
argument_list|(
name|t
operator|->
name|w
argument_list|,
name|mar_width
argument_list|,
literal|0
argument_list|,
name|f
operator|->
name|width
argument_list|,
name|f
operator|->
name|height
argument_list|)
expr_stmt|;
name|t
operator|->
name|fastscroll
operator|=
name|fastscroll
expr_stmt|;
name|t
operator|->
name|mapped
operator|=
name|FALSE
expr_stmt|;
name|t
operator|->
name|num_lines
operator|=
name|height
expr_stmt|;
name|t
operator|->
name|num_chars
operator|=
name|width
expr_stmt|;
name|t
operator|->
name|first_line
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|lines
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|height
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|TextDestroy
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|line_length
operator|=
operator|(
name|short
operator|*
operator|)
name|calloc
argument_list|(
name|height
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|TextDestroy
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|line_chars
operator|=
operator|(
name|short
operator|*
operator|)
name|calloc
argument_list|(
name|height
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|TextDestroy
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|t
operator|->
name|lines
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|width
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|TextDestroy
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|scroll_history
operator|=
name|calloc
argument_list|(
name|height
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|TextDestroy
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|t
operator|->
name|scroll_count
operator|=
name|t
operator|->
name|scroll_start
operator|=
name|t
operator|->
name|old_scrolls
operator|=
literal|0
expr_stmt|;
name|TextClear
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Free all the storage associated with a textwindow */
end_comment

begin_expr_stmt
name|TextDestroy
argument_list|(
name|t
argument_list|)
specifier|register
name|TextWindow
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Free things in the order we allocated them.  If something doesn't 	   exist, don't free it!) */
if|if
condition|(
name|t
operator|->
name|font
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|font
operator|->
name|fixedwidth
operator|==
literal|0
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|font
operator|->
name|widths
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|font
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|w
condition|)
name|XDestroyWindow
argument_list|(
name|t
operator|->
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|lines
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|num_lines
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|t
operator|->
name|lines
index|[
name|i
index|]
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|lines
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|lines
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|line_length
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|line_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|line_chars
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|line_chars
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|scroll_history
condition|)
name|free
argument_list|(
name|t
operator|->
name|scroll_history
argument_list|)
expr_stmt|;
name|DelTextWindow
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* remove from list of TextWindows */
comment|/* And finally the data structure itself! */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Clear out a text window and redisplay */
end_comment

begin_expr_stmt
name|TextClear
argument_list|(
name|t
argument_list|)
specifier|register
name|TextWindow
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|num_lines
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|->
name|lines
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|t
operator|->
name|line_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|line_length
index|[
name|i
index|]
operator|=
name|mar_width
expr_stmt|;
comment|/* Allow a left margin */
block|}
name|t
operator|->
name|last_line
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|last_char
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|next_x
operator|=
name|mar_width
expr_stmt|;
comment|/* Allow a left margin */
name|t
operator|->
name|next_y
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|first_line
operator|=
literal|0
expr_stmt|;
name|TextRedisplay
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Redisplays a text window */
end_comment

begin_expr_stmt
name|TextRedisplay
argument_list|(
name|t
argument_list|)
specifier|register
name|TextWindow
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|t
operator|=
name|head
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|TextRedisplay
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|t
operator|->
name|mapped
condition|)
return|return;
comment|/* Clear the border area */
name|XPixSet
argument_list|(
name|t
operator|->
name|w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mar_width
argument_list|,
name|t
operator|->
name|height
argument_list|,
name|t
operator|->
name|bgpixel
argument_list|)
expr_stmt|;
name|Redisplay_lines
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|t
operator|->
name|num_lines
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Any outstanding copies from scrolls can now be ignored */
name|t
operator|->
name|old_scrolls
operator|=
name|t
operator|->
name|scroll_count
expr_stmt|;
name|t
operator|->
name|scroll_count
operator|=
name|t
operator|->
name|scroll_start
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|Redisplay_lines
argument_list|(
name|t
argument_list|,
name|start
argument_list|,
name|finish
argument_list|)
specifier|register
name|TextWindow
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|start
decl_stmt|,
name|finish
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|y
decl_stmt|,
name|height
init|=
name|t
operator|->
name|font
operator|->
name|height
decl_stmt|,
name|x
decl_stmt|,
name|width
decl_stmt|;
if|if
condition|(
name|finish
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|=
literal|0
expr_stmt|;
name|y
operator|=
name|start
operator|*
name|height
expr_stmt|;
name|j
operator|=
name|start
operator|+
name|t
operator|->
name|first_line
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<=
name|finish
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
name|t
operator|->
name|num_lines
condition|)
name|j
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|line_chars
index|[
name|j
index|]
condition|)
block|{
name|XText
argument_list|(
name|t
operator|->
name|w
argument_list|,
name|mar_width
argument_list|,
name|y
argument_list|,
name|t
operator|->
name|lines
index|[
name|j
index|]
argument_list|,
name|t
operator|->
name|line_chars
index|[
name|j
index|]
argument_list|,
name|t
operator|->
name|font
operator|->
name|id
argument_list|,
name|t
operator|->
name|fgpixel
argument_list|,
name|t
operator|->
name|bgpixel
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|t
operator|->
name|line_length
index|[
name|j
index|]
expr_stmt|;
name|width
operator|=
name|t
operator|->
name|width
operator|-
name|x
expr_stmt|;
if|if
condition|(
name|width
operator|>
literal|0
condition|)
name|XPixSet
argument_list|(
name|t
operator|->
name|w
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|t
operator|->
name|bgpixel
argument_list|)
expr_stmt|;
name|y
operator|+=
name|height
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Handles an event.  If it's not an event it knows how to deal with,    returns TRUE, otherwise FALSE. */
end_comment

begin_function
name|int
name|TextEvent
parameter_list|(
name|t
parameter_list|,
name|e
parameter_list|)
specifier|register
name|TextWindow
modifier|*
name|t
decl_stmt|;
name|XEvent
modifier|*
name|e
decl_stmt|;
block|{
name|XExposeEvent
modifier|*
name|ee
init|=
operator|(
name|XExposeEvent
operator|*
operator|)
name|e
decl_stmt|;
name|int
name|offset
decl_stmt|;
switch|switch
condition|(
name|e
operator|->
name|type
condition|)
block|{
case|case
name|ExposeWindow
case|:
if|if
condition|(
name|ee
operator|->
name|height
operator|!=
name|t
operator|->
name|height
operator|||
name|ee
operator|->
name|width
operator|!=
name|t
operator|->
name|width
condition|)
block|{
name|Change_text_window_size
argument_list|(
name|t
argument_list|,
name|ee
operator|->
name|height
operator|/
name|t
operator|->
name|font
operator|->
name|height
argument_list|,
name|ee
operator|->
name|width
operator|/
name|t
operator|->
name|font
operator|->
name|width
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|mapped
operator|=
name|TRUE
expr_stmt|;
name|TextRedisplay
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|ExposeRegion
case|:
comment|/* If there have been more scrolls than there are lines, 		   this stuff has already scrolled off! */
if|if
condition|(
name|t
operator|->
name|scroll_count
operator|>
name|t
operator|->
name|num_lines
condition|)
return|return
name|FALSE
return|;
comment|/* If this is for an old scroll, ignore it */
if|if
condition|(
name|ee
operator|->
name|detail
operator|==
name|ExposeCopy
operator|&&
name|t
operator|->
name|old_scrolls
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|t
operator|->
name|scroll_count
operator|>
literal|0
condition|)
block|{
name|offset
operator|=
name|t
operator|->
name|scroll_history
index|[
name|t
operator|->
name|scroll_start
index|]
expr_stmt|;
block|}
else|else
name|offset
operator|=
literal|0
expr_stmt|;
name|Redisplay_lines
argument_list|(
name|t
argument_list|,
name|ee
operator|->
name|y
operator|/
name|t
operator|->
name|font
operator|->
name|height
operator|-
name|offset
argument_list|,
operator|(
name|ee
operator|->
name|y
operator|+
name|ee
operator|->
name|height
operator|-
literal|1
operator|)
operator|/
name|t
operator|->
name|font
operator|->
name|height
operator|-
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|UnmapWindow
case|:
name|t
operator|->
name|mapped
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|ExposeCopy
case|:
comment|/* We've finished the events for one scroll */
comment|/* If there are old scrolls, just decrement the count and 		   return */
if|if
condition|(
name|t
operator|->
name|old_scrolls
condition|)
block|{
name|t
operator|->
name|old_scrolls
operator|--
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|t
operator|->
name|scroll_count
operator|--
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|scroll_count
operator|<
name|t
operator|->
name|num_lines
condition|)
block|{
name|t
operator|->
name|scroll_start
operator|++
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|scroll_start
operator|>=
name|t
operator|->
name|num_lines
condition|)
name|t
operator|->
name|scroll_start
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Flush all outstanding events for all existent TextWindows.  */
end_comment

begin_macro
name|TextFlush
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|TextWindow
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|XEvent
name|e
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|t
operator|=
name|head
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|TextFlush
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|XSync
argument_list|(
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|XCheckWindowEvent
argument_list|(
name|t
operator|->
name|w
argument_list|,
name|t
operator|->
name|eventmask
operator||
name|ExposeWindow
argument_list|,
operator|&
name|e
argument_list|)
condition|)
block|{
if|if
condition|(
name|TextEvent
argument_list|(
name|t
argument_list|,
operator|&
name|e
argument_list|)
condition|)
block|{
comment|/*  			 * We should never get here. Accordingly, we 			 * don't do anything if we do, somehow, get here.   			 */
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
name|Change_text_window_size
argument_list|(
name|t
argument_list|,
name|new_h
argument_list|,
name|new_w
argument_list|)
specifier|register
name|TextWindow
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|new_h
decl_stmt|,
name|new_w
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|curline
decl_stmt|;
name|Normalize
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Rearrange lines so that first_line = 0 */
comment|/* First free up any now extraneous lines */
for|for
control|(
name|i
operator|=
name|new_h
init|;
name|i
operator|<
name|t
operator|->
name|num_lines
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|lines
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|lines
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|lines
argument_list|,
name|new_h
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|line_length
operator|=
operator|(
name|short
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|line_length
argument_list|,
name|new_h
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|line_chars
operator|=
operator|(
name|short
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|line_chars
argument_list|,
name|new_h
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|scroll_history
operator|=
name|realloc
argument_list|(
name|t
operator|->
name|scroll_history
argument_list|,
name|new_h
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new_h
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|t
operator|->
name|num_lines
condition|)
block|{
if|if
condition|(
operator|(
name|curline
operator|=
name|t
operator|->
name|lines
index|[
name|i
index|]
operator|=
name|realloc
argument_list|(
name|t
operator|->
name|lines
index|[
name|i
index|]
argument_list|,
name|new_w
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|t
operator|->
name|line_chars
index|[
name|i
index|]
operator|>
name|new_w
condition|)
block|{
name|t
operator|->
name|line_chars
index|[
name|i
index|]
operator|=
name|new_w
expr_stmt|;
name|curline
index|[
name|new_w
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Truncate the line */
name|t
operator|->
name|line_length
index|[
name|i
index|]
operator|=
name|mar_width
operator|+
name|XStringWidth
argument_list|(
name|curline
argument_list|,
name|t
operator|->
name|font
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|t
operator|->
name|lines
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
name|new_w
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|t
operator|->
name|lines
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|t
operator|->
name|line_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|line_length
index|[
name|i
index|]
operator|=
name|mar_width
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|->
name|last_line
operator|>=
name|new_h
condition|)
block|{
name|t
operator|->
name|last_line
operator|=
name|new_h
operator|-
literal|1
expr_stmt|;
name|t
operator|->
name|last_char
operator|=
name|t
operator|->
name|line_chars
index|[
name|t
operator|->
name|last_line
index|]
expr_stmt|;
name|t
operator|->
name|next_x
operator|=
name|t
operator|->
name|line_length
index|[
name|t
operator|->
name|last_line
index|]
expr_stmt|;
name|t
operator|->
name|next_y
operator|=
name|t
operator|->
name|last_line
operator|*
name|t
operator|->
name|font
operator|->
name|height
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|last_char
operator|>
name|new_w
condition|)
block|{
name|t
operator|->
name|last_char
operator|=
name|t
operator|->
name|line_chars
index|[
name|t
operator|->
name|last_line
index|]
expr_stmt|;
name|t
operator|->
name|next_x
operator|=
name|t
operator|->
name|line_length
index|[
name|t
operator|->
name|last_line
index|]
expr_stmt|;
block|}
name|t
operator|->
name|num_lines
operator|=
name|new_h
expr_stmt|;
name|t
operator|->
name|num_chars
operator|=
name|new_w
expr_stmt|;
name|t
operator|->
name|height
operator|=
name|new_h
operator|*
name|t
operator|->
name|font
operator|->
name|height
expr_stmt|;
name|t
operator|->
name|width
operator|=
name|new_w
operator|*
name|t
operator|->
name|font
operator|->
name|width
operator|+
name|mar_width
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Routine to re-arrange the lines in a window structure so that first_line    is equal to 0. */
end_comment

begin_expr_stmt
name|Normalize
argument_list|(
name|t
argument_list|)
specifier|register
name|TextWindow
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|t
operator|->
name|first_line
operator|==
literal|0
condition|)
return|return;
name|t
operator|->
name|last_line
operator|-=
name|t
operator|->
name|first_line
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|last_line
operator|<
literal|0
condition|)
name|t
operator|->
name|last_line
operator|+=
name|t
operator|->
name|num_lines
expr_stmt|;
name|Spin_lines
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|t
operator|->
name|num_lines
operator|-
literal|1
argument_list|,
name|t
operator|->
name|first_line
argument_list|)
expr_stmt|;
name|t
operator|->
name|first_line
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Spin lines rotates the m through n lines of the arrays    forward offset places.  For example, 012345 spun forward 2 is 234501.    It's straightforward to spin the first part of the arrays; and we    call Spin_lines recursively to do the last offset elements */
end_comment

begin_comment
comment|/* Actually, it's tail-recursive, so I just use a loop.  But I can    pretend, can't I? */
end_comment

begin_expr_stmt
name|Spin_lines
argument_list|(
name|t
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|offset
argument_list|)
specifier|register
name|TextWindow
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|m
decl_stmt|,
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
comment|/* Temporaries */
specifier|register
name|char
modifier|*
name|tempc
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|offset
operator|==
literal|0
operator|||
name|offset
operator|>
name|n
operator|-
name|m
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|m
init|;
name|i
operator|<=
name|n
operator|-
name|offset
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|t
operator|->
name|line_length
index|[
name|i
index|]
expr_stmt|;
name|t
operator|->
name|line_length
index|[
name|i
index|]
operator|=
name|t
operator|->
name|line_length
index|[
name|offset
operator|+
name|i
index|]
expr_stmt|;
name|t
operator|->
name|line_length
index|[
name|offset
operator|+
name|i
index|]
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|t
operator|->
name|line_chars
index|[
name|i
index|]
expr_stmt|;
name|t
operator|->
name|line_chars
index|[
name|i
index|]
operator|=
name|t
operator|->
name|line_chars
index|[
name|offset
operator|+
name|i
index|]
expr_stmt|;
name|t
operator|->
name|line_chars
index|[
name|offset
operator|+
name|i
index|]
operator|=
name|temp
expr_stmt|;
name|tempc
operator|=
name|t
operator|->
name|lines
index|[
name|i
index|]
expr_stmt|;
name|t
operator|->
name|lines
index|[
name|i
index|]
operator|=
name|t
operator|->
name|lines
index|[
name|offset
operator|+
name|i
index|]
expr_stmt|;
name|t
operator|->
name|lines
index|[
name|offset
operator|+
name|i
index|]
operator|=
name|tempc
expr_stmt|;
block|}
comment|/*	    Spin_lines(t, n-offset+1, n, offset - ((n-m+1) % offset)); */
name|temp
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|n
operator|-
name|offset
operator|+
literal|1
expr_stmt|;
name|offset
operator|-=
operator|(
name|n
operator|-
name|temp
operator|+
literal|1
operator|)
operator|%
name|offset
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Routine to put a string in a text window.  If fastscroll is    set in the TextWindow structure, a single block scroll is done instead    of scrolling at each newline. */
end_comment

begin_define
define|#
directive|define
name|verybig
value|10000
end_define

begin_comment
comment|/* Amount to scroll if we should refresh instead */
end_comment

begin_expr_stmt
name|TextPutString
argument_list|(
name|t
argument_list|,
name|str
argument_list|)
specifier|register
name|TextWindow
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ch
init|=
name|str
decl_stmt|;
specifier|register
name|char
name|oldch
decl_stmt|;
name|int
name|jump
init|=
name|t
operator|->
name|fastscroll
decl_stmt|;
comment|/* Whether to do jump scrolling */
name|int
name|newlines
decl_stmt|,
name|scroll
decl_stmt|;
if|if
condition|(
name|jump
condition|)
name|jump
operator|=
name|Count_lines
argument_list|(
name|t
argument_list|,
name|str
argument_list|,
operator|&
name|newlines
argument_list|,
operator|&
name|scroll
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|*
name|ch
operator|!=
literal|'\0'
operator|&&
operator|*
name|ch
operator|!=
literal|'\n'
condition|)
name|ch
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
name|str
condition|)
block|{
name|oldch
operator|=
operator|*
name|ch
expr_stmt|;
operator|*
name|ch
operator|=
literal|'\0'
expr_stmt|;
name|Do_text_string
argument_list|(
name|t
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|ch
operator|=
name|oldch
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ch
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|jump
operator|&&
name|newlines
operator|==
name|scroll
condition|)
block|{
name|Clear_lines
argument_list|(
name|t
argument_list|,
name|newlines
argument_list|)
expr_stmt|;
name|dont_update
operator|=
name|TRUE
expr_stmt|;
comment|/* Stop updating now */
block|}
name|newlines
operator|--
expr_stmt|;
name|TextPutChar
argument_list|(
name|t
argument_list|,
operator|*
name|ch
argument_list|)
expr_stmt|;
name|str
operator|=
operator|++
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|mapped
operator|&&
name|jump
condition|)
block|{
if|if
condition|(
name|scroll
operator|!=
name|verybig
condition|)
name|Scroll_text_window
argument_list|(
name|t
argument_list|,
name|scroll
argument_list|)
expr_stmt|;
else|else
name|TextRedisplay
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|dont_update
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Count the number of lines in str, calculate how much scrolling    will be needed, and return whether this amount is positive */
end_comment

begin_function
name|int
name|Count_lines
parameter_list|(
name|t
parameter_list|,
name|str
parameter_list|,
name|newlines
parameter_list|,
name|scroll
parameter_list|)
specifier|register
name|TextWindow
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
name|int
modifier|*
name|newlines
decl_stmt|,
decl|*
name|scroll
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|num_lines
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|lines_left
decl_stmt|,
name|height
init|=
name|t
operator|->
name|num_lines
decl_stmt|;
operator|*
name|scroll
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|++
operator|==
literal|'\n'
condition|)
name|num_lines
operator|++
expr_stmt|;
block|}
operator|*
name|newlines
operator|=
name|num_lines
expr_stmt|;
if|if
condition|(
name|num_lines
operator|<=
literal|1
condition|)
return|return
name|FALSE
return|;
comment|/* Don't bother jump scrolling */
comment|/* Would this fill the screen? */
if|if
condition|(
name|num_lines
operator|>=
name|height
condition|)
block|{
operator|*
name|scroll
operator|=
name|verybig
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Calculate the number of lines left in the window */
name|lines_left
operator|=
name|height
operator|-
operator|(
name|t
operator|->
name|last_line
operator|-
name|t
operator|->
name|first_line
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|lines_left
operator|>=
name|height
condition|)
name|lines_left
operator|-=
name|height
expr_stmt|;
comment|/* Figure out how many lines to scroll */
name|num_lines
operator|-=
name|lines_left
expr_stmt|;
if|if
condition|(
name|num_lines
operator|<=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Enough room already */
operator|*
name|scroll
operator|=
name|num_lines
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Clear a number of lines in the window data structure */
end_comment

begin_expr_stmt
name|Clear_lines
argument_list|(
name|t
argument_list|,
name|scroll
argument_list|)
specifier|register
name|TextWindow
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|scroll
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|start
init|=
name|t
operator|->
name|first_line
decl_stmt|;
specifier|register
name|int
name|height
init|=
name|t
operator|->
name|num_lines
decl_stmt|;
comment|/* If this would fill the screen, clear it instead */
if|if
condition|(
name|scroll
operator|>=
name|t
operator|->
name|height
condition|)
block|{
name|TextClear
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Shift the contents */
name|t
operator|->
name|first_line
operator|+=
name|scroll
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|first_line
operator|>=
name|height
condition|)
name|t
operator|->
name|first_line
operator|-=
name|height
expr_stmt|;
comment|/* Now clear the blank lines */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scroll
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|->
name|lines
index|[
name|start
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|t
operator|->
name|line_chars
index|[
name|start
index|]
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|line_length
index|[
name|start
index|]
operator|=
name|mar_width
expr_stmt|;
comment|/* Allow a left margin */
name|start
operator|++
expr_stmt|;
if|if
condition|(
name|start
operator|>=
name|height
condition|)
name|start
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Store the characters of a string in the window and update the screen,    but only if dont_update isn't set */
end_comment

begin_expr_stmt
name|Do_text_string
argument_list|(
name|t
argument_list|,
name|str
argument_list|)
specifier|register
name|TextWindow
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ch
init|=
name|str
decl_stmt|;
specifier|register
name|char
modifier|*
name|curline
init|=
name|t
operator|->
name|lines
index|[
name|t
operator|->
name|last_line
index|]
decl_stmt|;
specifier|register
name|int
name|curchar
init|=
name|t
operator|->
name|last_char
decl_stmt|;
specifier|register
name|int
name|x
init|=
name|t
operator|->
name|next_x
decl_stmt|;
specifier|register
name|FontInfo
modifier|*
name|f
init|=
name|t
operator|->
name|font
decl_stmt|;
name|int
name|start_x
init|=
name|t
operator|->
name|next_x
decl_stmt|,
name|start
init|=
name|curchar
decl_stmt|,
name|minch
init|=
name|f
operator|->
name|firstchar
decl_stmt|,
name|maxch
init|=
name|f
operator|->
name|lastchar
decl_stmt|;
comment|/* First store the characters in the line */
while|while
condition|(
operator|*
name|ch
operator|!=
literal|'\0'
operator|&&
name|curchar
operator|<
name|t
operator|->
name|num_chars
condition|)
block|{
name|curline
index|[
name|curchar
index|]
operator|=
operator|*
name|ch
expr_stmt|;
if|if
condition|(
operator|*
name|ch
operator|>=
name|minch
operator|&&
operator|*
name|ch
operator|<=
name|maxch
condition|)
block|{
name|x
operator|+=
name|f
operator|->
name|fixedwidth
condition|?
name|f
operator|->
name|width
else|:
name|f
operator|->
name|widths
index|[
operator|*
name|ch
operator|-
name|minch
index|]
expr_stmt|;
block|}
name|curchar
operator|++
expr_stmt|;
name|ch
operator|++
expr_stmt|;
block|}
name|curline
index|[
name|curchar
index|]
operator|=
literal|'\0'
expr_stmt|;
name|t
operator|->
name|line_chars
index|[
name|t
operator|->
name|last_line
index|]
operator|=
name|t
operator|->
name|last_char
operator|=
name|curchar
expr_stmt|;
name|t
operator|->
name|line_length
index|[
name|t
operator|->
name|last_line
index|]
operator|=
name|t
operator|->
name|next_x
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|dont_update
operator|||
operator|!
name|t
operator|->
name|mapped
condition|)
return|return;
comment|/* And then update the screen */
if|if
condition|(
name|start
operator|<
name|t
operator|->
name|num_chars
condition|)
block|{
name|XText
argument_list|(
name|t
operator|->
name|w
argument_list|,
name|start_x
argument_list|,
name|t
operator|->
name|next_y
argument_list|,
name|str
argument_list|,
name|curchar
operator|-
name|start
argument_list|,
name|f
operator|->
name|id
argument_list|,
name|t
operator|->
name|fgpixel
argument_list|,
name|t
operator|->
name|bgpixel
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Textputchar displays a character in the text window.  It  * responds to \n as a special character and just displays anything else.  */
end_comment

begin_expr_stmt
name|TextPutChar
argument_list|(
name|t
argument_list|,
name|ch
argument_list|)
specifier|register
name|TextWindow
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|ch
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|height
init|=
name|t
operator|->
name|num_lines
decl_stmt|;
specifier|register
name|char
modifier|*
name|curline
init|=
name|t
operator|->
name|lines
index|[
name|t
operator|->
name|last_line
index|]
decl_stmt|;
specifier|register
name|FontInfo
modifier|*
name|f
init|=
name|t
operator|->
name|font
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\0'
case|:
comment|/* NULL */
break|break;
case|case
literal|'\n'
case|:
comment|/* newline */
if|if
condition|(
name|t
operator|->
name|last_line
operator|==
name|t
operator|->
name|first_line
operator|-
literal|1
operator|||
operator|(
name|t
operator|->
name|last_line
operator|==
name|height
operator|-
literal|1
operator|&&
name|t
operator|->
name|first_line
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* The screen is full...clear out the first line */
name|t
operator|->
name|lines
index|[
name|t
operator|->
name|first_line
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|t
operator|->
name|line_chars
index|[
name|t
operator|->
name|first_line
index|]
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|line_length
index|[
name|t
operator|->
name|first_line
index|]
operator|=
name|mar_width
expr_stmt|;
name|t
operator|->
name|first_line
operator|++
expr_stmt|;
comment|/* And advance it */
if|if
condition|(
name|t
operator|->
name|first_line
operator|==
name|height
condition|)
name|t
operator|->
name|first_line
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|dont_update
operator|&&
name|t
operator|->
name|mapped
condition|)
name|Scroll_text_window
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|dont_update
condition|)
name|t
operator|->
name|next_y
operator|+=
name|f
operator|->
name|height
expr_stmt|;
name|t
operator|->
name|last_line
operator|++
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|last_line
operator|==
name|height
condition|)
name|t
operator|->
name|last_line
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|last_char
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|next_x
operator|=
name|mar_width
expr_stmt|;
break|break;
default|default:
comment|/* Just insert the character */
name|t
operator|->
name|last_char
operator|++
expr_stmt|;
name|t
operator|->
name|line_chars
index|[
name|t
operator|->
name|last_line
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|last_char
operator|>
name|t
operator|->
name|num_chars
condition|)
break|break;
name|curline
index|[
name|t
operator|->
name|last_char
index|]
operator|=
name|ch
expr_stmt|;
name|curline
index|[
name|t
operator|->
name|last_char
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|dont_update
operator|&&
name|t
operator|->
name|mapped
condition|)
block|{
name|XText
argument_list|(
name|t
operator|->
name|w
argument_list|,
name|t
operator|->
name|next_x
argument_list|,
name|t
operator|->
name|next_y
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|,
name|f
operator|->
name|id
argument_list|,
name|t
operator|->
name|fgpixel
argument_list|,
name|t
operator|->
name|bgpixel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|<=
name|f
operator|->
name|firstchar
operator|&&
name|ch
operator|>=
name|f
operator|->
name|lastchar
condition|)
block|{
name|t
operator|->
name|line_length
index|[
name|t
operator|->
name|last_line
index|]
operator|=
name|t
operator|->
name|next_x
operator|+=
operator|(
name|f
operator|->
name|fixedwidth
condition|?
name|f
operator|->
name|width
else|:
name|f
operator|->
name|widths
index|[
name|ch
operator|-
name|f
operator|->
name|lastchar
index|]
operator|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This procedure moves the contents of a text window up n lines.  */
end_comment

begin_expr_stmt
name|Scroll_text_window
argument_list|(
name|t
argument_list|,
name|n
argument_list|)
specifier|register
name|TextWindow
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|y
decl_stmt|,
name|x
decl_stmt|,
name|width
decl_stmt|,
name|j
decl_stmt|;
name|int
name|height
init|=
name|t
operator|->
name|font
operator|->
name|height
decl_stmt|;
name|int
name|scrollsize
init|=
name|n
operator|*
name|height
decl_stmt|;
comment|/* First shift up the contents */
name|XMoveArea
argument_list|(
name|t
operator|->
name|w
argument_list|,
literal|0
argument_list|,
name|scrollsize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|t
operator|->
name|width
argument_list|,
name|t
operator|->
name|height
operator|-
name|scrollsize
argument_list|)
expr_stmt|;
comment|/* Now redisplay the bottom n lines */
name|y
operator|=
name|height
operator|*
operator|(
name|t
operator|->
name|num_lines
operator|-
name|n
operator|)
expr_stmt|;
name|i
operator|=
name|t
operator|->
name|first_line
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|+=
name|t
operator|->
name|num_lines
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|t
operator|->
name|line_chars
index|[
name|i
index|]
condition|)
block|{
name|XText
argument_list|(
name|t
operator|->
name|w
argument_list|,
name|mar_width
argument_list|,
name|y
argument_list|,
name|t
operator|->
name|lines
index|[
name|i
index|]
argument_list|,
name|t
operator|->
name|line_chars
index|[
name|i
index|]
argument_list|,
name|t
operator|->
name|font
operator|->
name|id
argument_list|,
name|t
operator|->
name|fgpixel
argument_list|,
name|t
operator|->
name|bgpixel
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|t
operator|->
name|line_length
index|[
name|i
index|]
expr_stmt|;
name|width
operator|=
name|t
operator|->
name|width
operator|-
name|x
expr_stmt|;
if|if
condition|(
name|width
operator|>
literal|0
condition|)
name|XPixSet
argument_list|(
name|t
operator|->
name|w
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|t
operator|->
name|bgpixel
argument_list|)
expr_stmt|;
name|y
operator|+=
name|height
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|t
operator|->
name|num_lines
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Add the current scroll to all values in the scroll history, 	   then add a new entry at the end (the history wraps!) */
name|i
operator|=
name|t
operator|->
name|scroll_start
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|t
operator|->
name|scroll_count
condition|;
name|j
operator|++
control|)
block|{
name|t
operator|->
name|scroll_history
index|[
name|i
index|]
operator|+=
name|n
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|t
operator|->
name|num_lines
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|t
operator|->
name|scroll_count
operator|++
expr_stmt|;
name|t
operator|->
name|scroll_history
index|[
name|i
index|]
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|scroll_count
operator|>
name|t
operator|->
name|num_lines
condition|)
name|t
operator|->
name|scroll_start
operator|++
expr_stmt|;
comment|/* trash one */
block|}
end_block

begin_escape
end_escape

begin_define
define|#
directive|define
name|TEXT_BUFSIZE
value|2048
end_define

begin_macro
name|TextPrintf
argument_list|(
argument|t
argument_list|,
argument|format
argument_list|,
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|TextWindow
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buffer
index|[
name|TEXT_BUFSIZE
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|_iobuf
name|_strbuf
decl_stmt|;
name|_strbuf
operator|.
name|_flag
operator|=
name|_IOWRT
operator|+
name|_IOSTRG
expr_stmt|;
name|_strbuf
operator|.
name|_ptr
operator|=
name|buffer
expr_stmt|;
name|_strbuf
operator|.
name|_cnt
operator|=
name|TEXT_BUFSIZE
expr_stmt|;
name|_doprnt
argument_list|(
name|format
argument_list|,
operator|&
name|args
argument_list|,
operator|&
name|_strbuf
argument_list|)
expr_stmt|;
name|_strbuf
operator|.
name|_cnt
operator|++
expr_stmt|;
comment|/* Be sure there's room for the \0 */
name|putc
argument_list|(
literal|'\0'
argument_list|,
operator|&
name|_strbuf
argument_list|)
expr_stmt|;
name|TextPutString
argument_list|(
name|t
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

