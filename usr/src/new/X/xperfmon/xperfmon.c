begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 1985, Massachusetts Institute of Technology */
end_comment

begin_comment
comment|/*  * X Unix performance monitor.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_xperfmon_c
init|=
literal|"$Header: xperfmon.c,v 10.13 86/11/25 18:31:37 jg Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/*  * Simple graphical performance monitor for system-wide data.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/vm.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_include
include|#
directive|include
file|<vaxuba/ubavar.h>
end_include

begin_include
include|#
directive|include
file|<vaxmba/mbavar.h>
end_include

begin_endif
endif|#
directive|endif
endif|vax
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_include
include|#
directive|include
file|<sundev/mbvar.h>
end_include

begin_endif
endif|#
directive|endif
endif|sun
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ibm032
end_ifdef

begin_comment
comment|/* IBM RT/PC */
end_comment

begin_include
include|#
directive|include
file|<caio/ioccvar.h>
end_include

begin_endif
endif|#
directive|endif
endif|ibm032
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|tahoe
end_ifdef

begin_include
include|#
directive|include
file|<tahoevba/vbavar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<X/Xlib.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_define
define|#
directive|define
name|USEC_INC
value|50000
end_define

begin_define
define|#
directive|define
name|SEC_INC
value|1
end_define

begin_struct
struct|struct
name|packet
block|{
name|int
name|input
decl_stmt|,
name|output
decl_stmt|,
name|collisions
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|packet
name|packets
decl_stmt|,
name|old_packets
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_VALS_PER
value|1000
end_define

begin_struct
struct|struct
name|statistic
block|{
name|int
name|min_val
decl_stmt|,
name|max_val
decl_stmt|;
name|int
name|value
index|[
name|NUM_VALS_PER
index|]
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|,
modifier|*
name|label2
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SECS_PER_TIME_TICK
value|10
end_define

begin_decl_stmt
specifier|static
name|char
name|do_time
index|[
name|NUM_VALS_PER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|current_time
decl_stmt|,
name|saved_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timezone
name|dummy_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|gray_bits
index|[
literal|16
index|]
init|=
block|{
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|,
literal|0xaaaa
block|,
literal|0x5555
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The array stats always has valid info for stats[i], 0<= i< num_stats.  * For each valid stats[i], stats[i].value[j] is valid for 0<= j< num_of_val.  * The info for the k-th possible statistic of interest is recorded, if it is  *   recorded at all, in stats[possible_stats[k]].  */
end_comment

begin_define
define|#
directive|define
name|NO_STAT
value|-1
end_define

begin_define
define|#
directive|define
name|USER_CPU_PERCENTAGE
value|0
end_define

begin_define
define|#
directive|define
name|SYSTEM_CPU_PERCENTAGE
value|1
end_define

begin_define
define|#
directive|define
name|IDLE_CPU_PERCENTAGE
value|2
end_define

begin_define
define|#
directive|define
name|FREE_MEM
value|3
end_define

begin_define
define|#
directive|define
name|DISK_TRANSFERS
value|4
end_define

begin_define
define|#
directive|define
name|INTERRUPTS
value|5
end_define

begin_define
define|#
directive|define
name|INPUT_PACKETS
value|6
end_define

begin_define
define|#
directive|define
name|OUTPUT_PACKETS
value|7
end_define

begin_define
define|#
directive|define
name|COLLISION_PACKETS
value|8
end_define

begin_define
define|#
directive|define
name|NUM_POSSIBLE_STATS
value|9
end_define

begin_decl_stmt
specifier|static
name|int
name|possible_stats
index|[
name|NUM_POSSIBLE_STATS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WANT_STAT
parameter_list|(
name|x
parameter_list|)
value|(possible_stats[(x)] != NO_STAT)
end_define

begin_define
define|#
directive|define
name|MAX_STATS
value|10
end_define

begin_define
define|#
directive|define
name|DEFAULT_BORDER_WIDTH
value|3
end_define

begin_define
define|#
directive|define
name|DEFAULT_POSITION
value|"=%dx%d-0+0"
end_define

begin_decl_stmt
specifier|static
name|struct
name|statistic
name|stats
index|[
name|MAX_STATS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|timeout
init|=
block|{
name|SEC_INC
block|,
name|USEC_INC
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_stats
decl_stmt|,
name|num_of_val
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|graph_x_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|WindowInfo
name|WInfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Window
name|Win
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Host
index|[
literal|40
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|font_name
init|=
literal|"6x10"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|background
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* color of background */
end_comment

begin_decl_stmt
name|int
name|foreground
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* color of graph */
end_comment

begin_decl_stmt
name|int
name|highlight
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* color of text, scale */
end_comment

begin_decl_stmt
name|FontInfo
modifier|*
name|finfo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* font information needed */
end_comment

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a>b ? a:b)
end_define

begin_decl_stmt
name|OpaqueFrame
name|win
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FORALLPOSSIBLESTATS
parameter_list|(
name|stat
parameter_list|)
define|\
value|for (stat = 0; stat< NUM_POSSIBLE_STATS; stat++)
end_define

begin_define
define|#
directive|define
name|FORALLSTATS
parameter_list|(
name|stat
parameter_list|)
value|for (stat = 0; stat< num_stats; stat++)
end_define

begin_decl_stmt
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
define|#
directive|define
name|X_CPTIME
value|0
block|{
literal|"_cp_time"
block|}
block|,
define|#
directive|define
name|X_RATE
value|1
block|{
literal|"_rate"
block|}
block|,
define|#
directive|define
name|X_TOTAL
value|2
block|{
literal|"_total"
block|}
block|,
define|#
directive|define
name|X_DEFICIT
value|3
block|{
literal|"_deficit"
block|}
block|,
define|#
directive|define
name|X_FORKSTAT
value|4
block|{
literal|"_forkstat"
block|}
block|,
define|#
directive|define
name|X_SUM
value|5
block|{
literal|"_sum"
block|}
block|,
define|#
directive|define
name|X_FIRSTFREE
value|6
block|{
literal|"_firstfree"
block|}
block|,
define|#
directive|define
name|X_MAXFREE
value|7
block|{
literal|"_maxfree"
block|}
block|,
define|#
directive|define
name|X_BOOTTIME
value|8
block|{
literal|"_boottime"
block|}
block|,
define|#
directive|define
name|X_DKXFER
value|9
block|{
literal|"_dk_xfer"
block|}
block|,
define|#
directive|define
name|X_REC
value|10
block|{
literal|"_rectime"
block|}
block|,
define|#
directive|define
name|X_PGIN
value|11
block|{
literal|"_pgintime"
block|}
block|,
define|#
directive|define
name|X_HZ
value|12
block|{
literal|"_hz"
block|}
block|,
define|#
directive|define
name|X_MBDINIT
value|13
block|{
literal|"_mbdinit"
block|}
block|,
define|#
directive|define
name|N_IFNET
value|14
block|{
literal|"_ifnet"
block|}
block|,
define|#
directive|define
name|X_UBDINIT
value|15
block|{
literal|"_ubdinit"
block|}
block|,
define|#
directive|define
name|X_IOCINIT
value|16
block|{
literal|"_ioccdinit"
block|}
block|,
define|#
directive|define
name|X_VBDINIT
value|17
block|{
literal|"_vbdinit"
block|}
block|,
block|{
literal|""
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|dr_name
index|[
name|DK_NDRIVE
index|]
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|dr_unit
index|[
name|DK_NDRIVE
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|double
name|stat1
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|maxfree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hz
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
block|{
name|int
name|busy
decl_stmt|;
name|long
name|time
index|[
name|CPUSTATES
index|]
decl_stmt|;
name|long
name|xfer
index|[
name|DK_NDRIVE
index|]
decl_stmt|;
name|struct
name|vmmeter
name|Rate
decl_stmt|;
name|struct
name|vmtotal
name|Total
decl_stmt|;
name|struct
name|vmmeter
name|Sum
decl_stmt|;
name|struct
name|forkstat
name|Forkstat
decl_stmt|;
name|unsigned
name|rectime
decl_stmt|;
name|unsigned
name|pgintime
decl_stmt|;
block|}
name|s
struct|,
name|s1
struct|;
end_struct

begin_define
define|#
directive|define
name|rate
value|s.Rate
end_define

begin_define
define|#
directive|define
name|total
value|s.Total
end_define

begin_define
define|#
directive|define
name|sum
value|s.Sum
end_define

begin_define
define|#
directive|define
name|forkstat
value|s.Forkstat
end_define

begin_decl_stmt
name|struct
name|vmmeter
name|osum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|deficit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|etime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|swflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nintv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|t
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|steal
parameter_list|(
name|where
parameter_list|,
name|var
parameter_list|)
value|lseek(mf, where, 0); read(mf,&var, sizeof var);
end_define

begin_define
define|#
directive|define
name|pgtok
parameter_list|(
name|a
parameter_list|)
value|((a)*NBPG/1024)
end_define

begin_decl_stmt
name|char
modifier|*
name|options
index|[
name|NUM_POSSIBLE_STATS
operator|+
literal|1
index|]
init|=
block|{
literal|"user"
block|,
literal|"system"
block|,
literal|"idle"
block|,
literal|"free"
block|,
literal|"disk"
block|,
literal|"interrupts"
block|,
literal|"input"
block|,
literal|"output"
block|,
literal|"collision"
block|,
literal|0
comment|/* Terminator! */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|arrow
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x0020
block|,
literal|0x0070
block|,
literal|0x00f8
block|,
literal|0x01fc
block|,
literal|0x03fe
block|,
literal|0x0070
block|,
literal|0x0070
block|,
literal|0x0070
block|,
literal|0x0070
block|,
literal|0x0070
block|,
literal|0x0070
block|,
literal|0x0070
block|,
literal|0x0000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|mask
index|[]
init|=
block|{
literal|0x0020
block|,
literal|0x0070
block|,
literal|0x00f8
block|,
literal|0x01fc
block|,
literal|0x03fe
block|,
literal|0x07ff
block|,
literal|0x07ff
block|,
literal|0x00f8
block|,
literal|0x00f8
block|,
literal|0x00f8
block|,
literal|0x00f8
block|,
literal|0x00f8
block|,
literal|0x00f8
block|,
literal|0x00f8
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|stat
decl_stmt|;
name|int
name|have_disk
decl_stmt|;
name|struct
name|timeval
name|timeleft
decl_stmt|;
name|char
name|display
index|[
literal|40
index|]
decl_stmt|;
name|char
modifier|*
name|strind
decl_stmt|;
name|int
name|Select_mask
decl_stmt|,
name|select_mask
init|=
literal|0
decl_stmt|;
name|int
name|maxplus1
decl_stmt|,
name|n
decl_stmt|;
name|Cursor
name|cursor
decl_stmt|;
name|char
modifier|*
name|geometry
init|=
name|NULL
decl_stmt|;
comment|/* location of window */
name|char
name|def
index|[
literal|32
index|]
decl_stmt|;
name|int
name|reverse
init|=
literal|0
decl_stmt|;
name|double
name|update
init|=
operator|-
literal|1.
decl_stmt|;
name|double
name|atof
parameter_list|()
function_decl|;
name|char
modifier|*
name|border_color
decl_stmt|;
name|char
modifier|*
name|fore_color
decl_stmt|;
name|char
modifier|*
name|back_color
decl_stmt|;
name|char
modifier|*
name|high_color
decl_stmt|;
name|Pixmap
name|border_pixmap
decl_stmt|;
name|char
modifier|*
name|option
decl_stmt|;
name|int
name|opt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|minheight
decl_stmt|,
name|minwidth
decl_stmt|;
name|Color
name|cdef
decl_stmt|;
name|int
name|border_width
init|=
name|DEFAULT_BORDER_WIDTH
decl_stmt|;
name|display
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"ReverseVideo"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|reverse
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"BorderWidth"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|border_width
operator|=
name|atoi
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"BodyFont"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|font_name
operator|=
name|option
expr_stmt|;
if|if
condition|(
operator|(
name|border_color
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"Border"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|border_color
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"BorderColor"
argument_list|)
expr_stmt|;
name|back_color
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"Background"
argument_list|)
expr_stmt|;
name|fore_color
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"Foreground"
argument_list|)
expr_stmt|;
name|high_color
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"Highlight"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|option
operator|=
name|XGetDefault
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"Update"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|update
operator|=
name|atof
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|nintv
operator|=
name|get_namelist
argument_list|(
literal|"/vmunix"
argument_list|,
literal|"/dev/kmem"
argument_list|)
expr_stmt|;
name|collect_stats
argument_list|()
expr_stmt|;
name|etime
operator|=
literal|1.0
expr_stmt|;
name|have_disk
operator|=
operator|(
name|total_disk_transfers
argument_list|()
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* Initialize stats */
name|FORALLPOSSIBLESTATS
argument_list|(
argument|stat
argument_list|)
name|possible_stats
index|[
name|stat
index|]
operator|=
name|NO_STAT
expr_stmt|;
name|num_stats
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|/* Parse line */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'='
condition|)
block|{
name|geometry
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|index
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* host:display */
name|strncpy
argument_list|(
name|display
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|display
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-rv"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-reverse"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* black on white */
name|reverse
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-fw"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-forward"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* white on black */
name|reverse
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-bw"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-border"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* border width */
if|if
condition|(
operator|++
name|i
operator|>=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|border_width
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-fn"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-font"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* host name font */
if|if
condition|(
operator|++
name|i
operator|>=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|font_name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-bd"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-color"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* border color */
if|if
condition|(
operator|++
name|i
operator|>=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|border_color
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-fg"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-foreground"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* foreground color */
if|if
condition|(
operator|++
name|i
operator|>=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|fore_color
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-bg"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-background"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* background color */
if|if
condition|(
operator|++
name|i
operator|>=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|back_color
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-hl"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-highlight"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* highlight color */
if|if
condition|(
operator|++
name|i
operator|>=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|high_color
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-u"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-update"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* update interval */
if|if
condition|(
operator|++
name|i
operator|>=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|update
operator|=
name|atof
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|opt
operator|=
name|getcmd
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|>=
literal|0
operator|&&
name|opt
operator|<
name|NUM_POSSIBLE_STATS
condition|)
block|{
if|if
condition|(
name|num_stats
operator|==
name|MAX_STATS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"MAX_STATS exceeded, please recompile!\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|possible_stats
index|[
name|opt
index|]
operator|=
name|num_stats
operator|++
expr_stmt|;
continue|continue;
block|}
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|num_stats
operator|==
literal|0
condition|)
name|FORALLPOSSIBLESTATS
argument_list|(
argument|stat
argument_list|)
block|{
if|if
condition|(
operator|(
name|stat
operator|==
name|DISK_TRANSFERS
operator|)
operator|&&
operator|(
name|have_disk
operator|==
literal|0
operator|)
condition|)
continue|continue;
name|possible_stats
index|[
name|stat
index|]
operator|=
name|num_stats
operator|++
expr_stmt|;
if|if
condition|(
name|num_stats
operator|==
name|MAX_STATS
condition|)
break|break;
block|}
name|have_disk
operator|=
literal|0
expr_stmt|;
comment|/* so max # of packets = 40 */
name|init_stat
argument_list|(
name|USER_CPU_PERCENTAGE
argument_list|,
literal|100
argument_list|,
literal|"User"
argument_list|,
literal|" CPU"
argument_list|)
expr_stmt|;
name|init_stat
argument_list|(
name|SYSTEM_CPU_PERCENTAGE
argument_list|,
literal|100
argument_list|,
literal|"System"
argument_list|,
literal|" CPU"
argument_list|)
expr_stmt|;
name|init_stat
argument_list|(
name|IDLE_CPU_PERCENTAGE
argument_list|,
literal|100
argument_list|,
literal|"Idle"
argument_list|,
literal|" CPU"
argument_list|)
expr_stmt|;
name|init_stat
argument_list|(
name|FREE_MEM
argument_list|,
name|pgtok
argument_list|(
name|maxfree
argument_list|)
argument_list|,
literal|"Free"
argument_list|,
literal|" memory"
argument_list|)
expr_stmt|;
name|init_stat
argument_list|(
name|DISK_TRANSFERS
argument_list|,
literal|40
argument_list|,
literal|"Disk"
argument_list|,
literal|" transfers"
argument_list|)
expr_stmt|;
name|init_stat
argument_list|(
name|INTERRUPTS
argument_list|,
literal|60
argument_list|,
literal|"Interrupts"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|init_stat
argument_list|(
name|INPUT_PACKETS
argument_list|,
operator|(
name|have_disk
condition|?
literal|20
else|:
literal|40
operator|)
argument_list|,
literal|"Input"
argument_list|,
literal|" packets"
argument_list|)
expr_stmt|;
name|init_stat
argument_list|(
name|OUTPUT_PACKETS
argument_list|,
operator|(
name|have_disk
condition|?
literal|20
else|:
literal|40
operator|)
argument_list|,
literal|"Output"
argument_list|,
literal|" packets"
argument_list|)
expr_stmt|;
name|init_stat
argument_list|(
name|COLLISION_PACKETS
argument_list|,
literal|10
argument_list|,
literal|"Collision"
argument_list|,
literal|" packets"
argument_list|)
expr_stmt|;
if|if
condition|(
name|border_width
operator|<
literal|0
condition|)
name|border_width
operator|=
name|DEFAULT_BORDER_WIDTH
expr_stmt|;
if|if
condition|(
name|update
operator|>
literal|.09
condition|)
block|{
name|timeout
operator|.
name|tv_sec
operator|=
name|update
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
operator|(
name|update
operator|-
call|(
name|double
call|)
argument_list|(
operator|(
name|int
operator|)
name|update
argument_list|)
operator|)
operator|*
literal|1000000.
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|XOpenDisplay
argument_list|(
name|display
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open display '%s'\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|XDisplayName
argument_list|(
name|display
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|finfo
operator|=
name|XOpenFont
argument_list|(
name|font_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't load font %s!\n"
argument_list|,
name|font_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|gethostname
argument_list|(
name|Host
argument_list|,
sizeof|sizeof
argument_list|(
name|Host
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|Host
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|FORALLSTATS
argument_list|(
argument|stat
argument_list|)
block|{
name|int
name|s_width
decl_stmt|;
name|s_width
operator|=
name|XStringWidth
argument_list|(
name|stats
index|[
name|stat
index|]
operator|.
name|label
argument_list|,
name|finfo
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|graph_x_offset
operator|=
name|max
argument_list|(
name|graph_x_offset
argument_list|,
name|s_width
argument_list|)
expr_stmt|;
name|s_width
operator|=
name|XStringWidth
argument_list|(
name|stats
index|[
name|stat
index|]
operator|.
name|label2
argument_list|,
name|finfo
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|graph_x_offset
operator|=
name|max
argument_list|(
name|graph_x_offset
argument_list|,
name|s_width
argument_list|)
expr_stmt|;
block|}
name|graph_x_offset
operator|+=
literal|15
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"graph_x_offset=%d\n"
argument_list|,
name|graph_x_offset
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|saved_time
argument_list|,
operator|&
name|dummy_zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|border_color
operator|&&
name|DisplayCells
argument_list|()
operator|>
literal|2
operator|&&
name|XParseColor
argument_list|(
name|border_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|cdef
argument_list|)
condition|)
name|border_pixmap
operator|=
name|XMakeTile
argument_list|(
name|cdef
operator|.
name|pixel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|border_color
operator|&&
name|strcmp
argument_list|(
name|border_color
argument_list|,
literal|"black"
argument_list|)
operator|==
literal|0
condition|)
name|border_pixmap
operator|=
name|BlackPixmap
expr_stmt|;
elseif|else
if|if
condition|(
name|border_color
operator|&&
name|strcmp
argument_list|(
name|border_color
argument_list|,
literal|"white"
argument_list|)
operator|==
literal|0
condition|)
name|border_pixmap
operator|=
name|WhitePixmap
expr_stmt|;
else|else
name|border_pixmap
operator|=
name|XMakePixmap
argument_list|(
operator|(
name|Bitmap
operator|)
name|XStoreBitmap
argument_list|(
literal|16
argument_list|,
literal|16
argument_list|,
name|gray_bits
argument_list|)
argument_list|,
name|BlackPixel
argument_list|,
name|WhitePixel
argument_list|)
expr_stmt|;
if|if
condition|(
name|back_color
operator|&&
name|DisplayCells
argument_list|()
operator|>
literal|2
operator|&&
name|XParseColor
argument_list|(
name|back_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|cdef
argument_list|)
condition|)
block|{
name|background
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|back_color
operator|&&
operator|(
name|strcmp
argument_list|(
name|back_color
argument_list|,
literal|"white"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|background
operator|=
name|WhitePixel
expr_stmt|;
name|reverse
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|back_color
operator|&&
operator|(
name|strcmp
argument_list|(
name|back_color
argument_list|,
literal|"black"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|background
operator|=
name|BlackPixel
expr_stmt|;
name|reverse
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|background
operator|=
name|BlackPixel
expr_stmt|;
if|if
condition|(
name|fore_color
operator|&&
name|DisplayCells
argument_list|()
operator|>
literal|2
operator|&&
name|XParseColor
argument_list|(
name|fore_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|cdef
argument_list|)
condition|)
block|{
name|foreground
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fore_color
operator|&&
operator|(
name|strcmp
argument_list|(
name|fore_color
argument_list|,
literal|"black"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|foreground
operator|=
name|BlackPixel
expr_stmt|;
name|reverse
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fore_color
operator|&&
operator|(
name|strcmp
argument_list|(
name|fore_color
argument_list|,
literal|"white"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|foreground
operator|=
name|WhitePixel
expr_stmt|;
name|reverse
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|foreground
operator|=
name|WhitePixel
expr_stmt|;
if|if
condition|(
name|high_color
operator|&&
name|DisplayCells
argument_list|()
operator|>
literal|2
operator|&&
name|XParseColor
argument_list|(
name|high_color
argument_list|,
operator|&
name|cdef
argument_list|)
operator|&&
name|XGetHardwareColor
argument_list|(
operator|&
name|cdef
argument_list|)
condition|)
block|{
name|highlight
operator|=
name|cdef
operator|.
name|pixel
expr_stmt|;
block|}
else|else
name|highlight
operator|=
name|foreground
expr_stmt|;
if|if
condition|(
name|reverse
condition|)
block|{
name|highlight
operator|=
name|background
expr_stmt|;
name|background
operator|=
name|foreground
expr_stmt|;
name|foreground
operator|=
name|highlight
expr_stmt|;
block|}
name|win
operator|.
name|bdrwidth
operator|=
name|border_width
expr_stmt|;
name|win
operator|.
name|border
operator|=
name|border_pixmap
expr_stmt|;
name|win
operator|.
name|background
operator|=
name|XMakeTile
argument_list|(
name|background
argument_list|)
expr_stmt|;
name|minheight
operator|=
operator|(
name|finfo
operator|->
name|height
operator|*
literal|2
operator|+
literal|2
operator|)
operator|*
name|num_stats
expr_stmt|;
name|minwidth
operator|=
name|graph_x_offset
operator|+
literal|100
expr_stmt|;
name|sprintf
argument_list|(
name|def
argument_list|,
name|DEFAULT_POSITION
argument_list|,
name|minwidth
operator|+
literal|100
argument_list|,
operator|(
name|finfo
operator|->
name|height
operator|*
literal|3
operator|+
literal|3
operator|)
operator|*
name|num_stats
argument_list|)
expr_stmt|;
name|Win
operator|=
name|XCreate
argument_list|(
literal|"Performance Monitor"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|geometry
argument_list|,
name|def
argument_list|,
operator|&
name|win
argument_list|,
name|minwidth
argument_list|,
name|minheight
argument_list|)
expr_stmt|;
name|win
operator|.
name|height
operator|-=
literal|10
expr_stmt|;
name|XMapWindow
argument_list|(
name|Win
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|XCreateCursor
argument_list|(
literal|11
argument_list|,
literal|14
argument_list|,
name|arrow
argument_list|,
name|mask
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|GXcopyInverted
argument_list|)
expr_stmt|;
name|XDefineCursor
argument_list|(
name|Win
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
name|redisplay
argument_list|(
name|Win
argument_list|)
expr_stmt|;
name|timeleft
operator|=
name|timeout
expr_stmt|;
name|Select_mask
operator|=
literal|1
operator|<<
name|dpyno
argument_list|()
expr_stmt|;
name|maxplus1
operator|=
literal|1
operator|+
name|dpyno
argument_list|()
expr_stmt|;
name|XSelectInput
argument_list|(
name|Win
argument_list|,
name|KeyPressed
operator||
name|ExposeWindow
operator||
name|ExposeCopy
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|select_mask
operator|=
name|Select_mask
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"time=[%d,%d]\n"
argument_list|,
name|timeleft
operator|.
name|tv_sec
argument_list|,
name|timeleft
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|XFlush
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|select
argument_list|(
name|maxplus1
argument_list|,
operator|&
name|select_mask
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|timeleft
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|exit
argument_list|(
literal|46
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"selected n=%d mask=0x%x, time=[%d,%d]\n"
argument_list|,
name|n
argument_list|,
name|select_mask
argument_list|,
name|timeleft
operator|.
name|tv_sec
argument_list|,
name|timeleft
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
if|if
condition|(
name|perf_mon_selected
argument_list|(
name|Win
argument_list|,
name|n
argument_list|,
name|select_mask
argument_list|,
operator|&
name|timeleft
argument_list|)
operator|<
literal|0
condition|)
break|break;
block|}
block|}
end_function

begin_expr_stmt
name|getcmd
argument_list|(
name|to_match
argument_list|,
name|table
argument_list|)
comment|/* Modified from ucb/lpr/lpc.c */
specifier|register
name|char
operator|*
name|to_match
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|found
decl_stmt|,
name|index
decl_stmt|,
name|nmatches
decl_stmt|,
name|longest
decl_stmt|;
name|longest
operator|=
name|nmatches
operator|=
literal|0
expr_stmt|;
name|found
operator|=
name|index
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|table
init|;
name|p
condition|;
name|p
operator|=
operator|*
operator|(
operator|++
name|table
operator|)
control|)
block|{
name|index
operator|++
expr_stmt|;
for|for
control|(
name|q
operator|=
name|to_match
init|;
operator|*
name|q
operator|==
operator|*
name|p
operator|++
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
literal|0
condition|)
comment|/* exact match? */
return|return
operator|(
name|index
operator|)
return|;
if|if
condition|(
operator|!
operator|*
name|q
condition|)
block|{
comment|/* the to_match was a prefix */
if|if
condition|(
name|q
operator|-
name|to_match
operator|>
name|longest
condition|)
block|{
name|longest
operator|=
name|q
operator|-
name|to_match
expr_stmt|;
name|nmatches
operator|=
literal|1
expr_stmt|;
name|found
operator|=
name|index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|-
name|to_match
operator|==
name|longest
condition|)
name|nmatches
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nmatches
operator|>
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|found
operator|)
return|;
block|}
end_block

begin_macro
name|init_stat
argument_list|(
argument|index
argument_list|,
argument|maxval
argument_list|,
argument|label_1
argument_list|,
argument|label_2
argument_list|)
end_macro

begin_decl_stmt
name|int
name|index
decl_stmt|,
name|maxval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|label_1
decl_stmt|,
modifier|*
name|label_2
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if WANT_STAT
condition|(
name|index
condition|)
block|{
name|index
operator|=
name|possible_stats
index|[
name|index
index|]
expr_stmt|;
name|stats
index|[
name|index
index|]
operator|.
name|max_val
operator|=
name|maxval
expr_stmt|;
name|stats
index|[
name|index
index|]
operator|.
name|label
operator|=
name|label_1
expr_stmt|;
name|stats
index|[
name|index
index|]
operator|.
name|label2
operator|=
name|label_2
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|TIMER_EXPIRED
parameter_list|(
name|timer
parameter_list|)
define|\
value|(*timer&& ((*timer)->tv_sec == 0)&& ((*timer)->tv_usec == 0))
end_define

begin_function
name|int
name|perf_mon_selected
parameter_list|(
name|w
parameter_list|,
name|number
parameter_list|,
name|mask
parameter_list|,
name|timer
parameter_list|)
name|int
name|mask
decl_stmt|,
name|number
decl_stmt|;
name|Window
name|w
decl_stmt|;
name|struct
name|timeval
modifier|*
name|timer
decl_stmt|;
block|{
if|if
condition|(
name|number
operator|==
literal|0
condition|)
block|{
comment|/*timer expired */
name|int
modifier|*
name|target
index|[
name|CPUSTATES
operator|-
literal|1
index|]
decl_stmt|,
name|trash
decl_stmt|;
name|collect_stats
argument_list|()
expr_stmt|;
for|for
control|(
name|trash
operator|=
literal|0
init|;
name|trash
operator|<
name|CPUSTATES
operator|-
literal|1
condition|;
name|trash
operator|++
control|)
name|target
index|[
name|trash
index|]
operator|=
operator|&
name|trash
expr_stmt|;
if|if WANT_STAT
condition|(
name|USER_CPU_PERCENTAGE
condition|)
name|target
index|[
literal|0
index|]
operator|=
operator|&
name|stats
index|[
name|possible_stats
index|[
name|USER_CPU_PERCENTAGE
index|]
index|]
operator|.
name|value
index|[
name|num_of_val
index|]
expr_stmt|;
if|if WANT_STAT
condition|(
name|SYSTEM_CPU_PERCENTAGE
condition|)
name|target
index|[
literal|1
index|]
operator|=
operator|&
name|stats
index|[
name|possible_stats
index|[
name|SYSTEM_CPU_PERCENTAGE
index|]
index|]
operator|.
name|value
index|[
name|num_of_val
index|]
expr_stmt|;
if|if WANT_STAT
condition|(
name|IDLE_CPU_PERCENTAGE
condition|)
name|target
index|[
literal|2
index|]
operator|=
operator|&
name|stats
index|[
name|possible_stats
index|[
name|IDLE_CPU_PERCENTAGE
index|]
index|]
operator|.
name|value
index|[
name|num_of_val
index|]
expr_stmt|;
name|copy_cpu_stats
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if WANT_STAT
condition|(
name|FREE_MEM
condition|)
name|stats
index|[
name|possible_stats
index|[
name|FREE_MEM
index|]
index|]
operator|.
name|value
index|[
name|num_of_val
index|]
operator|=
name|pgtok
argument_list|(
name|total
operator|.
name|t_free
argument_list|)
expr_stmt|;
if|if WANT_STAT
condition|(
name|DISK_TRANSFERS
condition|)
name|stats
index|[
name|possible_stats
index|[
name|DISK_TRANSFERS
index|]
index|]
operator|.
name|value
index|[
name|num_of_val
index|]
operator|=
name|total_disk_transfers
argument_list|()
expr_stmt|;
if|if WANT_STAT
condition|(
name|INTERRUPTS
condition|)
name|stats
index|[
name|possible_stats
index|[
name|INTERRUPTS
index|]
index|]
operator|.
name|value
index|[
name|num_of_val
index|]
operator|=
operator|(
name|rate
operator|.
name|v_intr
operator|/
name|nintv
operator|)
operator|-
name|hz
expr_stmt|;
if|if WANT_STAT
condition|(
name|INPUT_PACKETS
condition|)
name|stats
index|[
name|possible_stats
index|[
name|INPUT_PACKETS
index|]
index|]
operator|.
name|value
index|[
name|num_of_val
index|]
operator|=
name|packets
operator|.
name|input
operator|-
name|old_packets
operator|.
name|input
expr_stmt|;
if|if WANT_STAT
condition|(
name|OUTPUT_PACKETS
condition|)
name|stats
index|[
name|possible_stats
index|[
name|OUTPUT_PACKETS
index|]
index|]
operator|.
name|value
index|[
name|num_of_val
index|]
operator|=
name|packets
operator|.
name|output
operator|-
name|old_packets
operator|.
name|output
expr_stmt|;
if|if WANT_STAT
condition|(
name|COLLISION_PACKETS
condition|)
name|stats
index|[
name|possible_stats
index|[
name|COLLISION_PACKETS
index|]
index|]
operator|.
name|value
index|[
name|num_of_val
index|]
operator|=
name|packets
operator|.
name|collisions
operator|-
name|old_packets
operator|.
name|collisions
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|current_time
argument_list|,
operator|&
name|dummy_zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_time
operator|.
name|tv_sec
operator|<
name|saved_time
operator|.
name|tv_sec
condition|)
block|{
comment|/* Super-user must have set the clock back */
name|saved_time
operator|=
name|current_time
expr_stmt|;
name|saved_time
operator|.
name|tv_sec
operator|-=
name|SECS_PER_TIME_TICK
expr_stmt|;
block|}
if|if
condition|(
name|saved_time
operator|.
name|tv_sec
operator|+
name|SECS_PER_TIME_TICK
operator|<=
name|current_time
operator|.
name|tv_sec
condition|)
block|{
name|saved_time
operator|=
name|current_time
expr_stmt|;
name|do_time
index|[
name|num_of_val
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|do_time
index|[
name|num_of_val
index|]
operator|=
literal|0
expr_stmt|;
name|next_display
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|dpyno
argument_list|()
operator|)
condition|)
block|{
name|XEvent
name|event
decl_stmt|;
name|XEvent
name|pevent
decl_stmt|;
name|XExposeWindowEvent
modifier|*
name|exp_event
decl_stmt|;
name|int
name|key
decl_stmt|;
if|if
condition|(
operator|!
name|XPending
argument_list|()
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* end of file on connection */
while|while
condition|(
name|XPending
argument_list|()
condition|)
block|{
name|XNextEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|.
name|type
condition|)
block|{
case|case
name|KeyPressed
case|:
if|if
condition|(
operator|(
name|key
operator|=
name|mapkey
argument_list|(
operator|(
operator|(
name|XKeyPressedEvent
operator|*
operator|)
operator|&
name|event
operator|)
operator|->
name|detail
argument_list|)
operator|)
operator|>
literal|0
condition|)
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* faster usec timeout */
if|if
condition|(
name|timeout
operator|.
name|tv_usec
operator|>=
name|USEC_INC
condition|)
name|timeout
operator|.
name|tv_usec
operator|-=
name|USEC_INC
expr_stmt|;
else|else
block|{
if|if
condition|(
name|timeout
operator|.
name|tv_sec
operator|>=
name|SEC_INC
condition|)
block|{
name|timeout
operator|.
name|tv_sec
operator|-=
name|SEC_INC
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|1000000
operator|-
name|USEC_INC
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* slower usec timeout */
if|if
condition|(
name|timeout
operator|.
name|tv_usec
operator|<
literal|1000000
operator|-
name|USEC_INC
condition|)
name|timeout
operator|.
name|tv_usec
operator|+=
name|USEC_INC
expr_stmt|;
else|else
block|{
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* faster sec timeout */
if|if
condition|(
name|timeout
operator|.
name|tv_sec
operator|>=
name|SEC_INC
condition|)
name|timeout
operator|.
name|tv_sec
operator|-=
name|SEC_INC
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* slower sec timeout */
name|timeout
operator|.
name|tv_sec
operator|+=
name|SEC_INC
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* reset */
name|timeout
operator|.
name|tv_sec
operator|=
name|SEC_INC
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
name|USEC_INC
expr_stmt|;
name|num_of_val
operator|=
literal|0
expr_stmt|;
name|redisplay
argument_list|(
name|w
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
case|case
literal|'?'
case|:
comment|/* Help */
name|printf
argument_list|(
literal|"%s\n%s\n%s\n%s\n%s\n%s\n"
argument_list|,
literal|"'s' slower usec timeout"
argument_list|,
literal|"'f' faster usec timeout"
argument_list|,
literal|"'S' slower sec timeout"
argument_list|,
literal|"'F' faster sec timeout"
argument_list|,
literal|"'R' reset timeout and display"
argument_list|,
literal|"'q' or 'Q' quit"
argument_list|)
expr_stmt|;
comment|/* 						 * Don't reset timeout 						 */
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* switch(key) */
break|break;
case|case
name|ExposeWindow
case|:
name|XSync
argument_list|(
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|XPending
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|XPeekEvent
argument_list|(
operator|&
name|pevent
argument_list|)
expr_stmt|;
if|if
condition|(
name|pevent
operator|.
name|type
operator|!=
name|ExposeWindow
condition|)
break|break;
name|XNextEvent
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
block|}
name|exp_event
operator|=
operator|(
name|XExposeWindowEvent
operator|*
operator|)
operator|&
name|event
expr_stmt|;
name|win
operator|.
name|x
operator|=
name|exp_event
operator|->
name|x
expr_stmt|;
name|win
operator|.
name|y
operator|=
name|exp_event
operator|->
name|y
expr_stmt|;
name|win
operator|.
name|width
operator|=
name|exp_event
operator|->
name|width
expr_stmt|;
name|win
operator|.
name|height
operator|=
name|exp_event
operator|->
name|height
operator|-
literal|10
expr_stmt|;
name|redisplay
argument_list|(
name|w
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
operator|*
name|timer
operator|=
name|timeout
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|total_disk_transfers
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|total_xfers
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DK_NDRIVE
condition|;
name|i
operator|++
control|)
name|total_xfers
operator|+=
name|s
operator|.
name|xfer
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
name|total_xfers
operator|/
name|etime
operator|)
return|;
block|}
end_function

begin_macro
name|copy_cpu_stats
argument_list|(
argument|stat
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|stat
index|[
name|CPUSTATES
operator|-
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CPUSTATES
condition|;
name|i
operator|++
control|)
block|{
name|float
name|f
init|=
name|stat1
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* US+NI */
name|i
operator|++
expr_stmt|;
name|f
operator|+=
name|stat1
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
operator|*
name|stat
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|f
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|collect_stats
argument_list|()
end_macro

begin_block
block|{
name|off_t
name|ifnetaddr
init|=
operator|(
name|long
operator|)
name|nl
index|[
name|N_IFNET
index|]
operator|.
name|n_value
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|lseek
argument_list|(
name|mf
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|X_CPTIME
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|mf
argument_list|,
name|s
operator|.
name|time
argument_list|,
sizeof|sizeof
name|s
operator|.
name|time
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|mf
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|X_DKXFER
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|mf
argument_list|,
name|s
operator|.
name|xfer
argument_list|,
sizeof|sizeof
name|s
operator|.
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|nintv
operator|!=
literal|1
condition|)
block|{
name|steal
argument_list|(
operator|(
name|long
operator|)
name|nl
index|[
name|X_SUM
index|]
operator|.
name|n_value
argument_list|,
name|rate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|steal
argument_list|(
operator|(
name|long
operator|)
name|nl
index|[
name|X_RATE
index|]
operator|.
name|n_value
argument_list|,
name|rate
argument_list|)
expr_stmt|;
block|}
name|steal
argument_list|(
operator|(
name|long
operator|)
name|nl
index|[
name|X_TOTAL
index|]
operator|.
name|n_value
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|osum
operator|=
name|sum
expr_stmt|;
name|steal
argument_list|(
operator|(
name|long
operator|)
name|nl
index|[
name|X_SUM
index|]
operator|.
name|n_value
argument_list|,
name|sum
argument_list|)
expr_stmt|;
name|steal
argument_list|(
operator|(
name|long
operator|)
name|nl
index|[
name|X_DEFICIT
index|]
operator|.
name|n_value
argument_list|,
name|deficit
argument_list|)
expr_stmt|;
name|etime
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DK_NDRIVE
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
name|s
operator|.
name|xfer
index|[
name|i
index|]
expr_stmt|;
name|s
operator|.
name|xfer
index|[
name|i
index|]
operator|-=
name|s1
operator|.
name|xfer
index|[
name|i
index|]
expr_stmt|;
name|s1
operator|.
name|xfer
index|[
name|i
index|]
operator|=
name|t
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CPUSTATES
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
name|s
operator|.
name|time
index|[
name|i
index|]
expr_stmt|;
name|s
operator|.
name|time
index|[
name|i
index|]
operator|-=
name|s1
operator|.
name|time
index|[
name|i
index|]
expr_stmt|;
name|s1
operator|.
name|time
index|[
name|i
index|]
operator|=
name|t
expr_stmt|;
name|etime
operator|+=
name|s
operator|.
name|time
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|etime
operator|==
literal|0.
condition|)
name|etime
operator|=
literal|1.
expr_stmt|;
name|etime
operator|/=
literal|60.
expr_stmt|;
name|nintv
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nl
index|[
name|N_IFNET
index|]
operator|.
name|n_value
operator|!=
literal|0
condition|)
block|{
name|struct
name|ifnet
name|ifnet
decl_stmt|;
name|steal
argument_list|(
operator|(
name|long
operator|)
name|nl
index|[
name|N_IFNET
index|]
operator|.
name|n_value
argument_list|,
name|ifnetaddr
argument_list|)
expr_stmt|;
name|old_packets
operator|=
name|packets
expr_stmt|;
name|packets
operator|.
name|input
operator|=
name|packets
operator|.
name|output
operator|=
name|packets
operator|.
name|collisions
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ifnetaddr
condition|)
block|{
name|steal
argument_list|(
name|ifnetaddr
argument_list|,
name|ifnet
argument_list|)
expr_stmt|;
name|packets
operator|.
name|input
operator|+=
name|ifnet
operator|.
name|if_ipackets
expr_stmt|;
name|packets
operator|.
name|output
operator|+=
name|ifnet
operator|.
name|if_opackets
expr_stmt|;
name|packets
operator|.
name|collisions
operator|+=
name|ifnet
operator|.
name|if_collisions
expr_stmt|;
name|ifnetaddr
operator|=
operator|(
name|off_t
operator|)
name|ifnet
operator|.
name|if_next
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|min
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|a
operator|<
name|b
condition|?
name|a
else|:
name|b
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|YORIGIN_FOR_STAT
parameter_list|(
name|num
parameter_list|)
value|((((num)*win.height)/num_stats)+3)
end_define

begin_define
define|#
directive|define
name|YMIDPOINT_FOR_STAT
parameter_list|(
name|num
parameter_list|)
value|((((num)*win.height+win.height/2)/num_stats) + 5)
end_define

begin_define
define|#
directive|define
name|Y_FOR_STAT_VAL
parameter_list|(
name|stat
parameter_list|,
name|num_of_val
parameter_list|)
define|\
value|y_base - min(height_of_stat, (	\ 		height_of_stat*(					\ 		  stats[stat].value[num_of_val]-stats[stat].min_val)/(	\ 		  stats[stat].max_val-stats[stat].min_val)))
end_define

begin_define
define|#
directive|define
name|First_Point
parameter_list|(
name|v
parameter_list|,
name|xv
parameter_list|,
name|yv
parameter_list|)
value|{v->x = xv; v->y = yv;\ 		v++->flags = VertexDontDraw; }
end_define

begin_define
define|#
directive|define
name|Next_Point
parameter_list|(
name|v
parameter_list|,
name|xv
parameter_list|,
name|yv
parameter_list|)
value|{v->x = xv; v->y = yv;\ 		v++->flags = VertexRelative | VertexDrawLastPoint; }
end_define

begin_macro
name|display_dividers
argument_list|(
argument|w
argument_list|,
argument|clear_first
argument_list|)
end_macro

begin_decl_stmt
name|int
name|clear_first
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Window
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|stat
decl_stmt|;
specifier|register
name|int
name|lwidth
init|=
name|win
operator|.
name|width
operator|-
name|graph_x_offset
decl_stmt|;
name|Vertex
name|v
index|[
name|NUM_VALS_PER
index|]
decl_stmt|;
specifier|register
name|Vertex
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"num_of_val=%d\n"
argument_list|,
name|num_of_val
argument_list|)
expr_stmt|;
name|FORALLSTATS
argument_list|(
argument|stat
argument_list|)
block|{
specifier|register
name|int
name|y_org
init|=
name|YORIGIN_FOR_STAT
argument_list|(
name|stat
operator|+
literal|1
argument_list|)
decl_stmt|;
name|vp
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|clear_first
condition|)
name|XPixSet
argument_list|(
name|w
argument_list|,
name|graph_x_offset
argument_list|,
name|y_org
operator|-
literal|2
argument_list|,
name|lwidth
argument_list|,
literal|5
argument_list|,
name|background
argument_list|)
expr_stmt|;
comment|/* Draw the horizontal line and then add the tick marks */
name|XLine
argument_list|(
name|w
argument_list|,
name|graph_x_offset
argument_list|,
name|y_org
argument_list|,
name|win
operator|.
name|width
argument_list|,
name|y_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|foreground
argument_list|,
name|GXcopy
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_of_val
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|do_time
index|[
name|i
index|]
condition|)
block|{
name|First_Point
argument_list|(
name|vp
argument_list|,
name|graph_x_offset
operator|+
name|i
argument_list|,
name|y_org
operator|-
literal|2
argument_list|)
expr_stmt|;
name|Next_Point
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vp
operator|!=
name|v
condition|)
name|XDraw
argument_list|(
name|w
argument_list|,
name|v
argument_list|,
name|vp
operator|-
name|v
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|foreground
argument_list|,
name|GXcopy
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|redisplay
argument_list|(
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|Window
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|height_of_stat
decl_stmt|,
name|stat
decl_stmt|;
name|XClear
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|display_dividers
argument_list|(
name|w
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|height_of_stat
operator|=
name|YORIGIN_FOR_STAT
argument_list|(
literal|1
argument_list|)
operator|-
name|YORIGIN_FOR_STAT
argument_list|(
literal|0
argument_list|)
operator|-
literal|10
expr_stmt|;
name|XTextMask
argument_list|(
name|w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|Host
argument_list|,
name|strlen
argument_list|(
name|Host
argument_list|)
argument_list|,
name|finfo
operator|->
name|id
argument_list|,
name|highlight
argument_list|)
expr_stmt|;
name|FORALLSTATS
argument_list|(
argument|stat
argument_list|)
block|{
specifier|register
name|int
name|y_origin_of_stat
init|=
name|YORIGIN_FOR_STAT
argument_list|(
name|stat
argument_list|)
decl_stmt|;
name|int
name|text_size
decl_stmt|;
name|char
name|temp
index|[
literal|20
index|]
decl_stmt|;
name|XTextMask
argument_list|(
name|w
argument_list|,
literal|0
argument_list|,
name|YMIDPOINT_FOR_STAT
argument_list|(
name|stat
argument_list|)
argument_list|,
name|stats
index|[
name|stat
index|]
operator|.
name|label
argument_list|,
name|strlen
argument_list|(
name|stats
index|[
name|stat
index|]
operator|.
name|label
argument_list|)
argument_list|,
name|finfo
operator|->
name|id
argument_list|,
name|highlight
argument_list|)
expr_stmt|;
name|XTextMask
argument_list|(
name|w
argument_list|,
literal|0
argument_list|,
name|YMIDPOINT_FOR_STAT
argument_list|(
name|stat
argument_list|)
operator|+
literal|10
argument_list|,
name|stats
index|[
name|stat
index|]
operator|.
name|label2
argument_list|,
name|strlen
argument_list|(
name|stats
index|[
name|stat
index|]
operator|.
name|label2
argument_list|)
argument_list|,
name|finfo
operator|->
name|id
argument_list|,
name|highlight
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d"
argument_list|,
name|stats
index|[
name|stat
index|]
operator|.
name|max_val
argument_list|)
expr_stmt|;
name|text_size
operator|=
name|XStringWidth
argument_list|(
name|temp
argument_list|,
name|finfo
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XTextMask
argument_list|(
name|w
argument_list|,
name|graph_x_offset
operator|-
literal|5
operator|-
name|text_size
argument_list|,
name|y_origin_of_stat
operator|+
literal|5
argument_list|,
name|temp
argument_list|,
name|strlen
argument_list|(
name|temp
argument_list|)
argument_list|,
name|finfo
operator|->
name|id
argument_list|,
name|highlight
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d"
argument_list|,
name|stats
index|[
name|stat
index|]
operator|.
name|min_val
argument_list|)
expr_stmt|;
name|text_size
operator|=
name|XStringWidth
argument_list|(
name|temp
argument_list|,
name|finfo
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XTextMask
argument_list|(
name|w
argument_list|,
name|graph_x_offset
operator|-
literal|5
operator|-
name|text_size
argument_list|,
name|y_origin_of_stat
operator|-
literal|1
operator|+
name|height_of_stat
argument_list|,
name|temp
argument_list|,
name|strlen
argument_list|(
name|temp
argument_list|)
argument_list|,
name|finfo
operator|->
name|id
argument_list|,
name|highlight
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_of_val
operator|>
literal|0
condition|)
name|FORALLSTATS
argument_list|(
argument|stat
argument_list|)
name|redisplay_stat_values
argument_list|(
name|w
argument_list|,
name|height_of_stat
argument_list|,
name|stat
argument_list|,
name|num_of_val
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|redisplay_stat_values
argument_list|(
argument|w
argument_list|,
argument|height_of_stat
argument_list|,
argument|stat
argument_list|,
argument|stop_plus_one
argument_list|)
end_macro

begin_decl_stmt
name|Window
name|w
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|height_of_stat
decl_stmt|,
name|stat
decl_stmt|,
name|stop_plus_one
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|,
name|newY
decl_stmt|;
name|Vertex
name|v
index|[
name|NUM_VALS_PER
index|]
decl_stmt|;
specifier|register
name|Vertex
modifier|*
name|vp
init|=
name|v
decl_stmt|;
name|int
name|y_base
init|=
name|YORIGIN_FOR_STAT
argument_list|(
name|stat
operator|+
literal|1
argument_list|)
operator|-
literal|5
decl_stmt|;
name|newY
operator|=
name|Y_FOR_STAT_VAL
argument_list|(
name|stat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|First_Point
argument_list|(
name|vp
argument_list|,
name|graph_x_offset
argument_list|,
name|newY
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|stop_plus_one
condition|;
control|)
block|{
specifier|register
name|int
name|npts
init|=
literal|0
decl_stmt|,
name|oldY
init|=
name|newY
decl_stmt|;
do|do
block|{
name|newY
operator|=
name|Y_FOR_STAT_VAL
argument_list|(
name|stat
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|npts
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|oldY
operator|==
name|newY
operator|)
operator|&&
operator|(
name|j
operator|<
name|stop_plus_one
operator|)
condition|)
do|;
if|if
condition|(
operator|--
name|npts
condition|)
name|Next_Point
argument_list|(
name|vp
argument_list|,
name|npts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Next_Point
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|,
name|newY
operator|-
name|oldY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|!=
name|v
condition|)
name|XDraw
argument_list|(
name|w
argument_list|,
name|v
argument_list|,
name|vp
operator|-
name|v
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|foreground
argument_list|,
name|GXcopy
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|next_display
argument_list|(
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|Window
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|stat
decl_stmt|,
name|height_of_stat
decl_stmt|,
name|redisp
init|=
literal|0
decl_stmt|;
name|height_of_stat
operator|=
name|YORIGIN_FOR_STAT
argument_list|(
literal|1
argument_list|)
operator|-
name|YORIGIN_FOR_STAT
argument_list|(
literal|0
argument_list|)
operator|-
literal|10
expr_stmt|;
name|FORALLSTATS
argument_list|(
argument|stat
argument_list|)
block|{
name|int
name|newY
decl_stmt|,
name|oldY
decl_stmt|;
name|int
name|y_base
init|=
name|YORIGIN_FOR_STAT
argument_list|(
name|stat
operator|+
literal|1
argument_list|)
operator|-
literal|5
decl_stmt|;
name|newY
operator|=
name|Y_FOR_STAT_VAL
argument_list|(
name|stat
argument_list|,
name|num_of_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_of_val
operator|==
literal|0
condition|)
name|oldY
operator|=
name|newY
expr_stmt|;
else|else
name|oldY
operator|=
name|Y_FOR_STAT_VAL
argument_list|(
name|stat
argument_list|,
name|num_of_val
operator|-
literal|1
argument_list|)
expr_stmt|;
name|XLine
argument_list|(
name|w
argument_list|,
name|graph_x_offset
operator|+
name|num_of_val
argument_list|,
name|oldY
argument_list|,
name|graph_x_offset
operator|+
name|num_of_val
operator|+
literal|1
argument_list|,
name|newY
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|foreground
argument_list|,
name|GXcopy
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_time
index|[
name|num_of_val
index|]
condition|)
block|{
name|y_base
operator|+=
literal|5
expr_stmt|;
name|XLine
argument_list|(
name|w
argument_list|,
name|graph_x_offset
operator|+
name|num_of_val
argument_list|,
name|y_base
operator|-
literal|2
argument_list|,
name|graph_x_offset
operator|+
name|num_of_val
argument_list|,
name|y_base
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|foreground
argument_list|,
name|GXcopy
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|++
name|num_of_val
operator|>=
name|NUM_VALS_PER
operator|||
name|num_of_val
operator|>=
name|win
operator|.
name|width
operator|-
name|graph_x_offset
condition|)
block|{
name|int
name|num_shift_left
init|=
operator|(
name|win
operator|.
name|width
operator|-
name|graph_x_offset
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|width
init|=
operator|(
name|win
operator|.
name|width
operator|-
name|graph_x_offset
operator|)
operator|-
name|num_shift_left
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|num_shift_left
init|;
name|j
operator|<
name|num_of_val
condition|;
name|j
operator|++
control|)
name|do_time
index|[
name|j
operator|-
name|num_shift_left
index|]
operator|=
name|do_time
index|[
name|j
index|]
expr_stmt|;
name|FORALLSTATS
argument_list|(
argument|stat
argument_list|)
block|{
specifier|register
name|int
name|ys
init|=
name|YORIGIN_FOR_STAT
argument_list|(
name|stat
argument_list|)
operator|+
literal|5
decl_stmt|,
name|nmax
init|=
literal|1
decl_stmt|,
name|t
decl_stmt|;
for|for
control|(
name|j
operator|=
name|num_shift_left
init|;
name|j
operator|<
name|num_of_val
condition|;
name|j
operator|++
control|)
block|{
name|t
operator|=
name|stats
index|[
name|stat
index|]
operator|.
name|value
index|[
name|j
operator|-
name|num_shift_left
index|]
operator|=
name|stats
index|[
name|stat
index|]
operator|.
name|value
index|[
name|j
index|]
expr_stmt|;
name|nmax
operator|=
name|nmax
operator|>
name|t
condition|?
name|nmax
else|:
name|t
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|>=
name|FREE_MEM
operator|&&
name|stat
operator|<
name|COLLISION_PACKETS
operator|&&
name|nmax
operator|!=
name|stats
index|[
name|stat
index|]
operator|.
name|max_val
condition|)
block|{
name|stats
index|[
name|stat
index|]
operator|.
name|max_val
operator|=
name|nmax
expr_stmt|;
name|redisp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|redisp
condition|)
block|{
name|XMoveArea
argument_list|(
name|w
argument_list|,
name|graph_x_offset
operator|+
name|num_shift_left
argument_list|,
name|ys
argument_list|,
name|graph_x_offset
argument_list|,
name|ys
argument_list|,
name|width
argument_list|,
name|height_of_stat
operator|+
literal|2
argument_list|)
expr_stmt|;
name|XPixSet
argument_list|(
name|w
argument_list|,
name|graph_x_offset
operator|+
name|num_shift_left
argument_list|,
name|ys
argument_list|,
name|width
argument_list|,
name|height_of_stat
operator|+
literal|2
argument_list|,
name|background
argument_list|)
expr_stmt|;
block|}
block|}
name|num_of_val
operator|-=
name|num_shift_left
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|redisp
condition|)
name|redisplay
argument_list|(
name|w
argument_list|)
expr_stmt|;
else|else
name|display_dividers
argument_list|(
name|w
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|int
name|get_namelist
parameter_list|(
name|kernel_name
parameter_list|,
name|memory_name
parameter_list|)
name|char
modifier|*
name|kernel_name
decl_stmt|,
decl|*
name|memory_name
decl_stmt|;
end_function

begin_block
block|{
name|time_t
name|now
decl_stmt|;
name|time_t
name|boottime
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|nintv
decl_stmt|;
name|nlist
argument_list|(
name|kernel_name
argument_list|,
name|nl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
index|[
literal|0
index|]
operator|.
name|n_type
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no %s namelist\n"
argument_list|,
name|kernel_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|mf
operator|=
name|open
argument_list|(
name|memory_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mf
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot open %s\n"
argument_list|,
name|memory_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|steal
argument_list|(
operator|(
name|long
operator|)
name|nl
index|[
name|X_MAXFREE
index|]
operator|.
name|n_value
argument_list|,
name|maxfree
argument_list|)
expr_stmt|;
name|steal
argument_list|(
operator|(
name|long
operator|)
name|nl
index|[
name|X_BOOTTIME
index|]
operator|.
name|n_value
argument_list|,
name|boottime
argument_list|)
expr_stmt|;
name|steal
argument_list|(
operator|(
name|long
operator|)
name|nl
index|[
name|X_HZ
index|]
operator|.
name|n_value
argument_list|,
name|hz
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DK_NDRIVE
condition|;
name|i
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|dr_name
index|[
name|i
index|]
argument_list|,
literal|"xx"
argument_list|)
expr_stmt|;
name|dr_unit
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|read_names
argument_list|()
expr_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|nintv
operator|=
name|now
operator|-
name|boottime
expr_stmt|;
if|if
condition|(
name|nintv
operator|<=
literal|0
operator|||
name|nintv
operator|>
literal|60
operator|*
literal|60
operator|*
literal|24
operator|*
literal|365
operator|*
literal|10
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Time makes no sense... namelist must be wrong.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nintv
operator|)
return|;
block|}
end_block

begin_function
name|double
name|stat1
parameter_list|(
name|row
parameter_list|)
block|{
name|double
name|t
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CPUSTATES
condition|;
name|i
operator|++
control|)
name|t
operator|+=
name|s
operator|.
name|time
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0.
condition|)
name|t
operator|=
literal|1.
expr_stmt|;
return|return
operator|(
name|s
operator|.
name|time
index|[
name|row
index|]
operator|*
literal|100.
operator|/
name|t
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_macro
name|read_names
argument_list|()
end_macro

begin_block
block|{
name|struct
name|mba_device
name|mdev
decl_stmt|;
specifier|register
name|struct
name|mba_device
modifier|*
name|mp
decl_stmt|;
name|struct
name|mba_driver
name|mdrv
decl_stmt|;
name|short
name|two_char
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|two_char
decl_stmt|;
name|struct
name|uba_device
name|udev
decl_stmt|,
modifier|*
name|up
decl_stmt|;
name|struct
name|uba_driver
name|udrv
decl_stmt|;
name|mp
operator|=
operator|(
expr|struct
name|mba_device
operator|*
operator|)
name|nl
index|[
name|X_MBDINIT
index|]
operator|.
name|n_value
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|uba_device
operator|*
operator|)
name|nl
index|[
name|X_UBDINIT
index|]
operator|.
name|n_value
expr_stmt|;
if|if
condition|(
name|up
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"perfmon: Disk init info not in namelist\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mp
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|steal
argument_list|(
name|mp
operator|++
argument_list|,
name|mdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdev
operator|.
name|mi_driver
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|mdev
operator|.
name|mi_dk
operator|<
literal|0
operator|||
name|mdev
operator|.
name|mi_alive
operator|==
literal|0
condition|)
continue|continue;
name|steal
argument_list|(
name|mdev
operator|.
name|mi_driver
argument_list|,
name|mdrv
argument_list|)
expr_stmt|;
name|steal
argument_list|(
name|mdrv
operator|.
name|md_dname
argument_list|,
name|two_char
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|dr_name
index|[
name|mdev
operator|.
name|mi_dk
index|]
argument_list|,
literal|"%c%c"
argument_list|,
name|cp
index|[
literal|0
index|]
argument_list|,
name|cp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dr_unit
index|[
name|mdev
operator|.
name|mi_dk
index|]
operator|=
name|mdev
operator|.
name|mi_unit
expr_stmt|;
block|}
if|if
condition|(
name|up
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|steal
argument_list|(
name|up
operator|++
argument_list|,
name|udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|.
name|ui_driver
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|udev
operator|.
name|ui_dk
operator|<
literal|0
operator|||
name|udev
operator|.
name|ui_alive
operator|==
literal|0
condition|)
continue|continue;
name|steal
argument_list|(
name|udev
operator|.
name|ui_driver
argument_list|,
name|udrv
argument_list|)
expr_stmt|;
name|steal
argument_list|(
name|udrv
operator|.
name|ud_dname
argument_list|,
name|two_char
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|dr_name
index|[
name|udev
operator|.
name|ui_dk
index|]
argument_list|,
literal|"%c%c"
argument_list|,
name|cp
index|[
literal|0
index|]
argument_list|,
name|cp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dr_unit
index|[
name|udev
operator|.
name|ui_dk
index|]
operator|=
name|udev
operator|.
name|ui_unit
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|vax
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_macro
name|read_names
argument_list|()
end_macro

begin_block
block|{
name|struct
name|mb_device
name|mdev
decl_stmt|;
specifier|register
name|struct
name|mb_device
modifier|*
name|mp
decl_stmt|;
name|struct
name|mb_driver
name|mdrv
decl_stmt|;
name|short
name|two_char
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|two_char
decl_stmt|;
name|mp
operator|=
operator|(
expr|struct
name|mb_device
operator|*
operator|)
name|nl
index|[
name|X_MBDINIT
index|]
operator|.
name|n_value
expr_stmt|;
if|if
condition|(
name|mp
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vmstat: Disk init info not in namelist\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|steal
argument_list|(
name|mp
operator|++
argument_list|,
name|mdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdev
operator|.
name|md_driver
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|mdev
operator|.
name|md_dk
operator|<
literal|0
operator|||
name|mdev
operator|.
name|md_alive
operator|==
literal|0
condition|)
continue|continue;
name|steal
argument_list|(
name|mdev
operator|.
name|md_driver
argument_list|,
name|mdrv
argument_list|)
expr_stmt|;
name|steal
argument_list|(
name|mdrv
operator|.
name|mdr_dname
argument_list|,
name|two_char
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|dr_name
index|[
name|mdev
operator|.
name|md_dk
index|]
argument_list|,
literal|"%c%c"
argument_list|,
name|cp
index|[
literal|0
index|]
argument_list|,
name|cp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dr_unit
index|[
name|mdev
operator|.
name|md_dk
index|]
operator|=
name|mdev
operator|.
name|md_unit
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|sun
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ibm032
end_ifdef

begin_macro
name|read_names
argument_list|()
end_macro

begin_block
block|{
name|struct
name|iocc_device
name|mdev
decl_stmt|;
specifier|register
name|struct
name|iocc_device
modifier|*
name|mp
decl_stmt|;
name|struct
name|iocc_driver
name|mdrv
decl_stmt|;
name|short
name|two_char
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|two_char
decl_stmt|;
name|mp
operator|=
operator|(
expr|struct
name|iocc_device
operator|*
operator|)
name|nl
index|[
name|X_IOCINIT
index|]
operator|.
name|n_value
expr_stmt|;
if|if
condition|(
name|mp
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vmstat: Disk init info not in namelist\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|steal
argument_list|(
name|mp
operator|++
argument_list|,
name|mdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdev
operator|.
name|iod_driver
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|mdev
operator|.
name|iod_dk
operator|<
literal|0
operator|||
name|mdev
operator|.
name|iod_alive
operator|==
literal|0
condition|)
continue|continue;
name|steal
argument_list|(
name|mdev
operator|.
name|iod_driver
argument_list|,
name|mdrv
argument_list|)
expr_stmt|;
name|steal
argument_list|(
name|mdrv
operator|.
name|idr_dname
argument_list|,
name|two_char
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|dr_name
index|[
name|mdev
operator|.
name|iod_dk
index|]
argument_list|,
literal|"%c%c"
argument_list|,
name|cp
index|[
literal|0
index|]
argument_list|,
name|cp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dr_unit
index|[
name|mdev
operator|.
name|iod_dk
index|]
operator|=
name|mdev
operator|.
name|iod_unit
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|ibm032
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|tahoe
end_ifdef

begin_macro
name|read_names
argument_list|()
end_macro

begin_block
block|{
name|struct
name|vba_device
name|udev
decl_stmt|,
modifier|*
name|up
decl_stmt|;
name|struct
name|vba_driver
name|udrv
decl_stmt|;
name|short
name|two_char
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|two_char
decl_stmt|;
name|up
operator|=
operator|(
expr|struct
name|vba_device
operator|*
operator|)
name|nl
index|[
name|X_VBDINIT
index|]
operator|.
name|n_value
expr_stmt|;
if|if
condition|(
name|up
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vmstat: Disk init info not in namelist\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|steal
argument_list|(
name|up
operator|++
argument_list|,
name|udev
argument_list|)
expr_stmt|;
if|if
condition|(
name|udev
operator|.
name|ui_driver
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|udev
operator|.
name|ui_dk
operator|<
literal|0
operator|||
name|udev
operator|.
name|ui_alive
operator|==
literal|0
condition|)
continue|continue;
name|steal
argument_list|(
name|udev
operator|.
name|ui_driver
argument_list|,
name|udrv
argument_list|)
expr_stmt|;
name|steal
argument_list|(
name|udrv
operator|.
name|ud_dname
argument_list|,
name|two_char
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|dr_name
index|[
name|udev
operator|.
name|ui_dk
index|]
argument_list|,
literal|"%c%c%d"
argument_list|,
name|cp
index|[
literal|0
index|]
argument_list|,
name|cp
index|[
literal|1
index|]
argument_list|,
name|udev
operator|.
name|ui_unit
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: xperfmon [host:display] option option .....\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

