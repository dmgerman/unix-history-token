begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<X/mit-copyright.h>
end_include

begin_comment
comment|/* Copyright 1985 Massachusetts Institute of Technology	*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_xhost_c
init|=
literal|"$Header: xhost.c,v 10.12 86/11/19 19:24:01 jg Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DNETCONN
end_ifdef

begin_include
include|#
directive|include
file|<netdnet/dn.h>
end_include

begin_include
include|#
directive|include
file|<netdnet/dnetdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<X/Xlib.h>
end_include

begin_include
include|#
directive|include
file|<X/Xproto.h>
end_include

begin_function_decl
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|local_xerror
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NAMESERVER_TIMEOUT
value|5
end_define

begin_comment
comment|/* time to wait for nameserver */
end_comment

begin_decl_stmt
name|int
name|nameserver_timedout
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|Display
modifier|*
name|dpy
decl_stmt|;
name|char
name|host
index|[
literal|256
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|display
decl_stmt|,
name|i
decl_stmt|,
name|w
decl_stmt|,
name|nhosts
decl_stmt|;
name|char
modifier|*
name|address
decl_stmt|,
modifier|*
name|get_address
argument_list|()
decl_stmt|;
name|char
modifier|*
name|hostname
decl_stmt|,
modifier|*
name|get_hostname
argument_list|()
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|list
decl_stmt|,
modifier|*
name|XGetHosts
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|DNETCONN
name|char
modifier|*
name|dnet_htoa
parameter_list|()
function_decl|;
name|struct
name|nodeent
modifier|*
name|np
decl_stmt|;
name|struct
name|dn_naddr
modifier|*
name|nlist
decl_stmt|,
name|dnaddr
decl_stmt|,
modifier|*
name|dnaddrp
decl_stmt|,
modifier|*
name|XGetNodes
argument_list|()
decl_stmt|,
modifier|*
name|dnet_addr
argument_list|()
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|dpy
operator|=
name|XOpenDisplay
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open display '%s'\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|XDisplayName
argument_list|(
literal|"\0"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|XErrorHandler
argument_list|(
name|local_xerror
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
comment|/* 		 * Get all the INET host names 		 */
name|list
operator|=
name|XGetHosts
argument_list|(
operator|&
name|nhosts
argument_list|)
expr_stmt|;
if|if
condition|(
name|nhosts
operator|!=
literal|0
condition|)
block|{
name|sethostent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* don't close the data base each time */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nhosts
condition|;
name|i
operator|++
control|)
block|{
name|hostname
operator|=
name|get_hostname
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\t"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameserver_timedout
condition|)
name|printf
argument_list|(
literal|"(nameserver did not respond in %d seconds)\n"
argument_list|,
name|NAMESERVER_TIMEOUT
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|endhostent
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DNETCONN
comment|/* 		 * Get all the DECnet node names 		 */
name|nlist
operator|=
name|XGetNodes
argument_list|(
operator|&
name|nhosts
argument_list|)
expr_stmt|;
if|if
condition|(
name|nhosts
operator|!=
literal|0
condition|)
block|{
name|setnodeent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* keep the database accessed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nhosts
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%s::\n"
argument_list|,
name|dnet_htoa
argument_list|(
operator|&
name|nlist
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|arg
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
block|{
name|arg
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DNETCONN
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|arg
argument_list|,
literal|':'
argument_list|)
operator|)
operator|&&
operator|(
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|==
literal|':'
operator|)
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dnaddrp
operator|=
name|dnet_addr
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|XRemoveNode
argument_list|(
name|dnaddrp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|np
operator|=
name|getnodebyname
argument_list|(
name|arg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"xhost:bad node: %s::\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dnaddr
operator|.
name|a_len
operator|=
name|np
operator|->
name|n_length
expr_stmt|;
name|bcopy
argument_list|(
name|np
operator|->
name|n_addr
argument_list|,
name|dnaddr
operator|.
name|a_addr
argument_list|,
name|np
operator|->
name|n_length
argument_list|)
expr_stmt|;
name|XRemoveNode
argument_list|(
operator|&
name|dnaddr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
endif|#
directive|endif
if|if
condition|(
operator|(
name|address
operator|=
name|get_address
argument_list|(
name|arg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad host: %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|XRemoveHost
argument_list|(
name|address
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DNETCONN
block|}
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
operator|*
name|arg
operator|==
literal|'+'
condition|)
name|arg
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DNETCONN
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|arg
argument_list|,
literal|':'
argument_list|)
operator|)
operator|&&
operator|(
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|==
literal|':'
operator|)
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dnaddrp
operator|=
name|dnet_addr
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|XAddNode
argument_list|(
name|dnaddrp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|np
operator|=
name|getnodebyname
argument_list|(
name|arg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"xhost:bad node: %s::\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dnaddr
operator|.
name|a_len
operator|=
name|np
operator|->
name|n_length
expr_stmt|;
name|bcopy
argument_list|(
name|np
operator|->
name|n_addr
argument_list|,
name|dnaddr
operator|.
name|a_addr
argument_list|,
name|np
operator|->
name|n_length
argument_list|)
expr_stmt|;
name|XAddNode
argument_list|(
operator|&
name|dnaddr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
endif|#
directive|endif
if|if
condition|(
operator|(
name|address
operator|=
name|get_address
argument_list|(
name|arg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad host: %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|XAddHost
argument_list|(
name|address
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DNETCONN
block|}
endif|#
directive|endif
block|}
block|}
name|XSync
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get_address - return a pointer to an internet address given  * either a name (CHARON.MIT.EDU) or a string with the raw  * address (18.58.0.13)  */
end_comment

begin_function
name|char
modifier|*
name|get_address
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|static
name|unsigned
name|long
name|address
decl_stmt|;
comment|/*    * First see if inet_addr() can grok the name; if so, then use it.    */
if|if
condition|(
operator|(
name|address
operator|=
name|inet_addr
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|address
operator|)
return|;
comment|/* Found it */
block|}
comment|/*    * Is it in the namespace?    */
elseif|else
if|if
condition|(
operator|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|name
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|NULL
operator|)
operator|||
name|hp
operator|->
name|h_addrtype
operator|!=
name|AF_INET
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Sorry, you lose */
block|}
else|else
block|{
return|return
operator|(
name|hp
operator|->
name|h_addr
operator|)
return|;
comment|/* Found it. */
block|}
block|}
end_function

begin_comment
comment|/*  * get_hostname - Given an internet address, return a name (CHARON.MIT.EDU)  * or a string representing the address (18.58.0.13) if the name cannot  * be found.  */
end_comment

begin_decl_stmt
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|get_hostname
parameter_list|(
name|address
parameter_list|)
name|struct
name|in_addr
modifier|*
name|address
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|hp
init|=
name|NULL
decl_stmt|;
name|int
name|nameserver_lost
parameter_list|()
function_decl|;
name|char
modifier|*
name|inet_ntoa
parameter_list|()
function_decl|;
comment|/* gethostbyaddr can take a LONG time if the host does not exist.      Assume that if it does not respond in NAMESERVER_TIMEOUT seconds      that something is wrong and do not make the user wait.      gethostbyaddr will continue after a signal, so we have to      jump out of it.     */
name|nameserver_timedout
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|nameserver_lost
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|&
name|address
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
condition|)
return|return
operator|(
name|hp
operator|->
name|h_name
operator|)
return|;
else|else
return|return
operator|(
name|inet_ntoa
argument_list|(
name|address
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|nameserver_lost
argument_list|()
end_macro

begin_block
block|{
name|nameserver_timedout
operator|=
literal|1
expr_stmt|;
name|longjmp
argument_list|(
name|env
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * local_xerror - local non-fatal error handling routine. If the error was  * that an X_GetHosts request for an unknown address format was received, just  * return, otherwise call the default error handler _XError.  */
end_comment

begin_macro
name|local_xerror
argument_list|(
argument|dpy
argument_list|,
argument|rep
argument_list|)
end_macro

begin_decl_stmt
name|Display
modifier|*
name|dpy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|XErrorEvent
modifier|*
name|rep
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|rep
operator|->
name|error_code
operator|==
name|BadValue
operator|)
operator|&&
operator|(
name|rep
operator|->
name|request_code
operator|==
name|X_GetHosts
operator|)
condition|)
block|{
return|return;
block|}
else|else
block|{
name|_XError
argument_list|(
name|dpy
argument_list|,
name|rep
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

