begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_pathlist_c
init|=
literal|"$Header: pathlist.c,v 10.1 86/11/19 10:43:18 jg Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/* pathlist.c - Coverter for vertex list  *  *	PathListConverter	Convert a list of vertices   *				into absolute striaght lines  *	Spline			Generates a series of line segments  *				that make up a smooth curve  *	Matrix			Utility rtn used by Spline to interpolate  *				points along the curve  *  *	Author:  *	    Scott Bates  *	    Brown University  *	    IRIS, Box 1946  *	    Providence, RI 02912  *  *  *		Copyright (c) 1986 Brown University  *  * Permission to use, copy, modify and distribute this software and its  * documentation for any purpose and without fee is hereby granted, provided  * that the above copyright notice appear in all copies, and that both  * that copyright notice and this permission notice appear in supporting  * documentation, and that the name of Brown University not be used in  * advertising or publicity pertaining to distribution of the software  * without specific, written prior permission. Brown University makes no  * representations about the suitability of this software for any purpose.  * It is provided "as-is" without express or implied warranty.  */
end_comment

begin_include
include|#
directive|include
file|"private.h"
end_include

begin_include
include|#
directive|include
file|"pathlist.h"
end_include

begin_comment
comment|/*  * Convert vertex list  */
end_comment

begin_expr_stmt
name|PathListConverter
argument_list|(
name|verts
argument_list|,
name|vertcount
argument_list|,
name|xbase
argument_list|,
name|ybase
argument_list|,
name|newverts
argument_list|,
name|newvertcount
argument_list|,
name|type
argument_list|)
specifier|register
name|Vertex
operator|*
name|verts
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|vertcount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|xbase
decl_stmt|,
name|ybase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Vertex
modifier|*
modifier|*
name|newverts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|newvertcount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Vertex
modifier|*
name|ThisVertex
init|=
name|verts
decl_stmt|;
specifier|register
name|Vertex
modifier|*
name|LastVertex
decl_stmt|;
specifier|register
name|Vertex
modifier|*
name|NewVerts
decl_stmt|;
specifier|register
name|Segment
modifier|*
name|CurrentSegment
decl_stmt|;
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|int
name|VertexCount
decl_stmt|;
name|int
name|VertexIndex
init|=
literal|0
decl_stmt|;
name|int
name|SegmentIndex
init|=
literal|0
decl_stmt|;
name|int
name|CurvedSegments
init|=
literal|0
decl_stmt|;
name|int
name|MaxSegments
init|=
name|INITIAL_SEGMENTS
decl_stmt|;
name|int
name|TotalVertexCount
init|=
name|vertcount
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE_X
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In PathListConverter\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRACE_X
comment|/*      * Perform initial allocation of segment table      */
name|CurrentSegment
operator|=
name|SegmentTable
operator|=
operator|(
name|Segment
operator|*
operator|)
name|malloc
argument_list|(
name|MaxSegments
operator|*
sizeof|sizeof
argument_list|(
name|Segment
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SegmentTable
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*      * Prime first segment table entry      */
name|ThisVertex
operator|->
name|x
operator|+=
name|xbase
expr_stmt|;
name|ThisVertex
operator|->
name|y
operator|+=
name|ybase
expr_stmt|;
name|CurrentSegment
operator|->
name|Index
operator|=
literal|0
expr_stmt|;
name|CurrentSegment
operator|->
name|Count
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|ThisVertex
operator|->
name|flags
operator|&
name|VERTEX_TYPE_MASK
condition|)
block|{
case|case
operator|(
name|LINE
operator|)
case|:
comment|/* First segment is a line */
name|CurrentSegment
operator|->
name|Type
operator|=
name|LINE_SEGMENT
expr_stmt|;
break|break;
case|case
operator|(
name|START_CLOSED_CURVE
operator|)
case|:
comment|/* First segment is a closed curve */
name|CurrentSegment
operator|->
name|Type
operator|=
name|CLOSED_CURVE_SEGMENT
expr_stmt|;
name|CurvedSegments
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* First segment is a line */
comment|/* 	 * turn off bogus flags and make this first segment a line 	 */
name|ThisVertex
operator|->
name|flags
operator|&=
operator|~
operator|(
name|START_CLOSED_CURVE
operator||
name|END_CLOSED_CURVE
operator|)
expr_stmt|;
name|CurrentSegment
operator|->
name|Type
operator|=
name|LINE_SEGMENT
expr_stmt|;
block|}
comment|/*      * Convert remaining vertices to absolute coordinates and      * divide them up into there appropriate segemnts.      */
do|do
block|{
if|if
condition|(
operator|++
name|VertexIndex
operator|<
name|vertcount
condition|)
block|{
comment|/* 	     * Move on to next vertex and save current vertex 	     */
name|LastVertex
operator|=
name|ThisVertex
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Conversion has completed. If the last segment was a 	     * curved segment verify it before exiting loop. 	     */
if|if
condition|(
name|CurrentSegment
operator|->
name|Type
operator|==
name|CLOSED_CURVE_SEGMENT
operator|&&
operator|(
operator|(
name|ThisVertex
operator|->
name|flags
operator|&
name|VERTEX_TYPE_MASK
operator|)
operator|!=
name|END_CLOSED_CURVE
operator|||
name|CurrentSegment
operator|->
name|Count
operator|<
literal|3
operator|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|CurrentSegment
operator|->
name|Type
operator|==
name|OPEN_CURVE_SEGMENT
operator|&&
name|CurrentSegment
operator|->
name|Count
operator|<
literal|3
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
block|}
comment|/* 	 * Make Vertex an absolute coordinate 	 */
if|if
condition|(
name|ThisVertex
operator|->
name|flags
operator|&
name|VertexRelative
condition|)
block|{
name|ThisVertex
operator|->
name|x
operator|+=
name|LastVertex
operator|->
name|x
expr_stmt|;
name|ThisVertex
operator|->
name|y
operator|+=
name|LastVertex
operator|->
name|y
expr_stmt|;
block|}
else|else
block|{
name|ThisVertex
operator|->
name|x
operator|+=
name|xbase
expr_stmt|;
name|ThisVertex
operator|->
name|y
operator|+=
name|ybase
expr_stmt|;
block|}
comment|/* 	 * If this is the last vertex turn off any bogus flags 	 * before processing it 	 */
if|if
condition|(
operator|(
name|VertexIndex
operator|+
literal|1
operator|)
operator|==
name|vertcount
operator|&&
name|CurrentSegment
operator|->
name|Type
operator|!=
name|CLOSED_CURVE_SEGMENT
condition|)
block|{
name|ThisVertex
operator|->
name|flags
operator|&=
operator|~
operator|(
name|END_CLOSED_CURVE
operator|)
expr_stmt|;
block|}
comment|/* 	 * add this vertex to the current segement or start a new one. 	 */
switch|switch
condition|(
name|ThisVertex
operator|->
name|flags
operator|&
name|VERTEX_TYPE_MASK
condition|)
block|{
case|case
operator|(
name|LINE
operator|)
case|:
comment|/* This vertex is a LINE */
switch|switch
condition|(
name|LastVertex
operator|->
name|flags
operator|&
name|VERTEX_TYPE_MASK
condition|)
block|{
case|case
operator|(
name|LINE
operator|)
case|:
comment|/* Last vertex was a LINE */
comment|/* 		 * Add this vertex to the current segment 		 */
name|CurrentSegment
operator|->
name|Count
operator|++
expr_stmt|;
break|break;
case|case
operator|(
name|CURVE
operator|)
case|:
comment|/* Last vertex was a CURVE */
comment|/* 		 * If the current segment type is a closed curve 		 * convert it to an open curve segment. 		 */
if|if
condition|(
name|CurrentSegment
operator|->
name|Type
operator|==
name|CLOSED_CURVE_SEGMENT
condition|)
block|{
name|CurrentSegment
operator|->
name|Type
operator|=
name|OPEN_CURVE_SEGMENT
expr_stmt|;
if|if
condition|(
name|CurrentSegment
operator|->
name|Index
operator|>
literal|0
condition|)
block|{
name|CurrentSegment
operator|->
name|Index
operator|--
expr_stmt|;
name|CurrentSegment
operator|->
name|Count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|++
name|CurrentSegment
operator|->
name|Count
operator|<
literal|3
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
case|case
operator|(
name|END_CLOSED_CURVE
operator|)
case|:
comment|/* Last vertex was a END_CLOSED_CURVE */
comment|/* 		 * Start a line segment 		 */
name|StartNewSegment
argument_list|(
name|LINE_SEGMENT
argument_list|,
name|VertexIndex
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|START_CLOSED_CURVE
operator|)
case|:
comment|/* Last vertex was start closed curve */
comment|/* 		 * Convert the current segment to a line segment 		 */
name|CurrentSegment
operator|->
name|Type
operator|=
name|LINE_SEGMENT
expr_stmt|;
name|CurrentSegment
operator|->
name|Count
operator|++
expr_stmt|;
name|CurvedSegments
operator|--
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|CURVE
operator|)
case|:
comment|/* This vertex was a curve */
switch|switch
condition|(
name|LastVertex
operator|->
name|flags
operator|&
name|VERTEX_TYPE_MASK
condition|)
block|{
case|case
operator|(
name|LINE
operator|)
case|:
comment|/* Last vertex was a line or */
case|case
operator|(
name|END_CLOSED_CURVE
operator|)
case|:
comment|/* end closed curve	     */
comment|/* 		 * Start an open curve segment 		 */
name|StartNewSegment
argument_list|(
name|OPEN_CURVE_SEGMENT
argument_list|,
name|VertexIndex
operator|-
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CurvedSegments
operator|++
expr_stmt|;
break|break;
case|case
operator|(
name|CURVE
operator|)
case|:
comment|/* Last vertex was a curve or start */
case|case
operator|(
name|START_CLOSED_CURVE
operator|)
case|:
comment|/* closed curve			    */
comment|/* 		 * Add this vertex to current segment 		 */
name|CurrentSegment
operator|->
name|Count
operator|++
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|START_CLOSED_CURVE
operator|)
case|:
comment|/* This vertex is start closed curve */
switch|switch
condition|(
name|LastVertex
operator|->
name|flags
operator|&
name|VERTEX_TYPE_MASK
condition|)
block|{
case|case
operator|(
name|CURVE
operator|)
case|:
comment|/* Last vertex was a curve */
comment|/* If the current segment type is a closed curve 		 * convert it to a open curve segment. Then start  		 * a closed curve segment using this vertex. 		 */
if|if
condition|(
name|CurrentSegment
operator|->
name|Type
operator|==
name|CLOSED_CURVE_SEGMENT
condition|)
block|{
name|CurrentSegment
operator|->
name|Type
operator|=
name|OPEN_CURVE_SEGMENT
expr_stmt|;
if|if
condition|(
name|CurrentSegment
operator|->
name|Index
operator|>
literal|0
condition|)
block|{
name|CurrentSegment
operator|->
name|Index
operator|--
expr_stmt|;
name|CurrentSegment
operator|->
name|Count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|++
name|CurrentSegment
operator|->
name|Count
operator|<
literal|3
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
case|case
operator|(
name|LINE
operator|)
case|:
comment|/* Last vertex was a line or */
case|case
operator|(
name|END_CLOSED_CURVE
operator|)
case|:
comment|/* end closed curve	     */
comment|/* 		 * Start closed curve segemnt 		 */
name|StartNewSegment
argument_list|(
name|CLOSED_CURVE_SEGMENT
argument_list|,
name|VertexIndex
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CurvedSegments
operator|++
expr_stmt|;
break|break;
case|case
operator|(
name|START_CLOSED_CURVE
operator|)
case|:
comment|/* Last vertex was start closed curve */
comment|/* 		 * Indicate to caller that there was a 		 * path list error. 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
case|case
operator|(
name|END_CLOSED_CURVE
operator|)
case|:
comment|/* This vertex is end closed curve */
comment|/* 	     * Add this vertex to the current segment 	     */
operator|++
name|CurrentSegment
operator|->
name|Count
expr_stmt|;
comment|/* 	     * Last vertex was a curve 	     */
if|if
condition|(
operator|(
name|LastVertex
operator|->
name|flags
operator|&
name|VERTEX_TYPE_MASK
operator|)
operator|==
name|CURVE
condition|)
block|{
comment|/* 		 * Vaild vertex count of curved segment 		 */
if|if
condition|(
name|CurrentSegment
operator|->
name|Count
operator|<
literal|3
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 		 * If the current segment is a closed segment 		 * validate that the last vertex of the segment 		 * equals the first. 		 */
if|if
condition|(
name|CurrentSegment
operator|->
name|Type
operator|==
name|CLOSED_CURVE_SEGMENT
condition|)
block|{
if|if
condition|(
name|verts
index|[
name|CurrentSegment
operator|->
name|Index
index|]
operator|.
name|x
operator|!=
name|verts
index|[
name|VertexIndex
index|]
operator|.
name|x
operator|||
name|verts
index|[
name|CurrentSegment
operator|->
name|Index
index|]
operator|.
name|y
operator|!=
name|verts
index|[
name|VertexIndex
index|]
operator|.
name|y
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		     * Start a line segment using this vertex 		     */
name|StartNewSegment
argument_list|(
name|LINE_SEGMENT
argument_list|,
name|VertexIndex
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
comment|/* 	     * Indicate to caller that there was a 	     * path list error. 	     */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
comment|/*      * If there are curved segments in this path list      * then perform the required setup and call the spline       * rtn .       */
name|SplineUsed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CurvedSegments
condition|)
block|{
name|Vertex
modifier|*
name|Vertex_A
decl_stmt|;
name|Vertex
modifier|*
name|Vertex_B
decl_stmt|;
name|Vertex
modifier|*
name|Vertex_C
decl_stmt|;
name|Vertex
modifier|*
name|Vertex_D
decl_stmt|;
name|int
name|Count
decl_stmt|;
comment|/* 	* Initial allocating of the spline vertex buffer 	*/
name|SplineVertexIndex
operator|=
literal|0
expr_stmt|;
name|MaxSplineVerts
operator|=
name|INITIAL_SPLINE_VERTS
expr_stmt|;
name|SplineVertexBuffer
operator|=
operator|(
name|Vertex
operator|*
operator|)
name|malloc
argument_list|(
name|MaxSplineVerts
operator|*
sizeof|sizeof
argument_list|(
name|Vertex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SplineVertexBuffer
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SplineUsed
operator|++
expr_stmt|;
comment|/* 	* Loop thru all the path list segments looking  	* for all open and closed curve segments. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|SegmentIndex
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|(
name|CurrentSegment
operator|=
operator|&
name|SegmentTable
index|[
name|i
index|]
operator|)
operator|->
name|Type
condition|)
block|{
case|case
operator|(
name|LINE_SEGMENT
operator|)
case|:
comment|/* 	    * Ignore line segments 	    */
continue|continue;
case|case
operator|(
name|OPEN_CURVE_SEGMENT
operator|)
case|:
comment|/* 	     * Generate a series of line segments 	     * that represent the open curve defined 	     * by this segment. 	     */
name|Count
operator|=
literal|0
expr_stmt|;
name|Vertex_A
operator|=
operator|&
name|verts
index|[
name|CurrentSegment
operator|->
name|Index
operator|+
name|CurrentSegment
operator|->
name|Count
operator|-
literal|1
index|]
expr_stmt|;
name|Vertex_B
operator|=
operator|&
name|verts
index|[
name|CurrentSegment
operator|->
name|Index
index|]
expr_stmt|;
name|Vertex_C
operator|=
name|Vertex_B
operator|+
literal|1
expr_stmt|;
name|Vertex_D
operator|=
name|Vertex_C
operator|+
literal|1
expr_stmt|;
name|CurrentSegment
operator|->
name|Index
operator|=
name|SplineVertexIndex
expr_stmt|;
name|j
operator|=
name|CurrentSegment
operator|->
name|Count
operator|-
literal|2
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|Count
operator|+=
name|Spline
argument_list|(
name|Vertex_A
argument_list|,
name|Vertex_B
argument_list|,
name|Vertex_C
argument_list|,
name|Vertex_D
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|j
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|Vertex_A
operator|=
name|Vertex_B
expr_stmt|;
name|Vertex_B
operator|=
name|Vertex_C
expr_stmt|;
name|Vertex_C
operator|=
name|Vertex_D
operator|++
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|CLOSED_CURVE_SEGMENT
operator|)
case|:
comment|/* 	     * Generate a series of line segments 	     * that represent the closed curve defined 	     * by this segment. 	     */
name|Count
operator|=
literal|0
expr_stmt|;
name|LastVertex
operator|=
operator|&
name|verts
index|[
name|CurrentSegment
operator|->
name|Index
operator|+
literal|1
index|]
expr_stmt|;
name|Vertex_A
operator|=
operator|&
name|verts
index|[
name|CurrentSegment
operator|->
name|Index
operator|+
name|CurrentSegment
operator|->
name|Count
operator|-
literal|2
index|]
expr_stmt|;
name|Vertex_B
operator|=
operator|&
name|verts
index|[
name|CurrentSegment
operator|->
name|Index
index|]
expr_stmt|;
name|CurrentSegment
operator|->
name|Index
operator|=
name|SplineVertexIndex
expr_stmt|;
name|Vertex_C
operator|=
name|Vertex_B
operator|+
literal|1
expr_stmt|;
name|Vertex_D
operator|=
name|Vertex_C
expr_stmt|;
name|j
operator|=
name|CurrentSegment
operator|->
name|Count
operator|-
literal|2
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
block|{
name|Vertex_D
operator|++
expr_stmt|;
name|Count
operator|+=
name|Spline
argument_list|(
name|Vertex_A
argument_list|,
name|Vertex_B
argument_list|,
name|Vertex_C
argument_list|,
name|Vertex_D
argument_list|)
expr_stmt|;
name|Vertex_A
operator|=
name|Vertex_B
expr_stmt|;
name|Vertex_B
operator|=
name|Vertex_C
expr_stmt|;
name|Vertex_C
operator|=
name|Vertex_D
expr_stmt|;
block|}
name|Vertex_D
operator|=
name|LastVertex
expr_stmt|;
name|Count
operator|+=
name|Spline
argument_list|(
name|Vertex_A
argument_list|,
name|Vertex_B
argument_list|,
name|Vertex_C
argument_list|,
name|Vertex_D
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * Adjust the current segment count and 	     * increase the total vertex to reflect  	     * the new points generated by the spline rtn. 	     */
name|CurrentSegment
operator|->
name|Count
operator|=
name|Count
expr_stmt|;
name|TotalVertexCount
operator|+=
name|Count
expr_stmt|;
comment|/* 	     * If there are no more curved segments exit early 	     */
if|if
condition|(
operator|--
name|CurvedSegments
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
comment|/*      * Allocate space for new vertex list      */
name|NewVerts
operator|=
operator|*
name|newverts
operator|=
operator|(
name|Vertex
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|TotalVertexCount
operator|<<
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Vertex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NewVerts
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*      * Loop thru coordinate list      */
for|for
control|(
name|VertexCount
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|SegmentIndex
condition|;
name|i
operator|++
control|)
block|{
comment|/*  	 * If this segment is a line segment get verts from original 	 * vertex list else use the spline vertex list. 	 */
if|if
condition|(
operator|(
name|CurrentSegment
operator|=
operator|&
name|SegmentTable
index|[
name|i
index|]
operator|)
operator|->
name|Type
operator|==
name|LINE_SEGMENT
condition|)
block|{
name|ThisVertex
operator|=
operator|&
name|verts
index|[
name|CurrentSegment
operator|->
name|Index
index|]
expr_stmt|;
block|}
else|else
block|{
name|ThisVertex
operator|=
operator|&
name|SplineVertexBuffer
index|[
name|CurrentSegment
operator|->
name|Index
index|]
expr_stmt|;
block|}
comment|/* 	 * Get segment vertex count 	 */
name|j
operator|=
name|CurrentSegment
operator|->
name|Count
expr_stmt|;
comment|/* 	 * Convert path list to fill format 	 */
if|if
condition|(
name|type
operator|==
name|FILL_PATH_LIST
condition|)
block|{
do|do
block|{
comment|/* 		 * Something to draw ? 		 */
if|if
condition|(
name|ThisVertex
operator|->
name|flags
operator|&
name|VertexDontDraw
condition|)
block|{
comment|/* 		     * Indicate start of closed polygon 		     */
name|ThisVertex
operator|->
name|flags
operator||=
name|START_OF_CLOSED_POLY
expr_stmt|;
comment|/* 		     * Increment vertex pointers 		     */
name|LastVertex
operator|=
name|ThisVertex
operator|++
expr_stmt|;
comment|/* 		     * Continue processing of current segment 		     */
continue|continue;
block|}
comment|/* 		 * If this vertex is not a dup save the  		 * line segment represented by the last  		 * vertex and this one in NewVerts. 		 * If it is a dup ignore this vertex. 		 */
if|if
condition|(
name|ThisVertex
operator|->
name|x
operator|!=
name|LastVertex
operator|->
name|x
operator|||
name|ThisVertex
operator|->
name|y
operator|!=
name|LastVertex
operator|->
name|y
condition|)
block|{
comment|/* 		     * Save start and end points of 		     * visible line 		     */
operator|*
name|NewVerts
operator|++
operator|=
operator|*
name|LastVertex
expr_stmt|;
operator|*
name|NewVerts
operator|++
operator|=
operator|*
name|ThisVertex
expr_stmt|;
comment|/* 		     * Increment vertex count 		     */
name|VertexCount
operator|+=
literal|2
expr_stmt|;
comment|/* 		     * Increment vertex pointers 		     */
name|LastVertex
operator|=
name|ThisVertex
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     * Ignore this vertex 		     */
name|ThisVertex
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|j
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
comment|/* 		 * Something to draw ? 		 */
if|if
condition|(
name|ThisVertex
operator|->
name|flags
operator|&
name|VertexDontDraw
condition|)
block|{
comment|/* 		     * Increment vertex pointers 		     */
name|LastVertex
operator|=
name|ThisVertex
operator|++
expr_stmt|;
comment|/* 		     * Continue processing current segment 		     */
continue|continue;
block|}
if|if
condition|(
name|ThisVertex
operator|->
name|x
operator|!=
name|LastVertex
operator|->
name|x
operator|||
name|ThisVertex
operator|->
name|y
operator|!=
name|LastVertex
operator|->
name|y
condition|)
block|{
comment|/* 		     * Save start and end points of 		     * visible line 		     */
operator|*
name|NewVerts
operator|++
operator|=
operator|*
name|LastVertex
expr_stmt|;
operator|*
name|NewVerts
operator|=
operator|*
name|ThisVertex
expr_stmt|;
comment|/* 		     * Shorten line by one point if 		     * "VertexDrawLastPoint" flag is off 		     */
if|if
condition|(
operator|!
operator|(
name|ThisVertex
operator|->
name|flags
operator|&
name|VertexDrawLastPoint
operator|)
condition|)
block|{
name|int
name|DeltaX
decl_stmt|,
name|DeltaY
decl_stmt|;
name|int
name|SignX
init|=
literal|0
decl_stmt|,
name|SignY
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|DeltaX
operator|=
name|ThisVertex
operator|->
name|x
operator|-
name|LastVertex
operator|->
name|x
operator|)
operator|<
literal|0
condition|)
block|{
name|SignX
operator|=
operator|-
literal|1
expr_stmt|;
name|DeltaX
operator|=
operator|-
name|DeltaX
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|DeltaY
operator|=
name|ThisVertex
operator|->
name|y
operator|-
name|LastVertex
operator|->
name|y
operator|)
operator|<
literal|0
condition|)
block|{
name|SignY
operator|=
operator|-
literal|1
expr_stmt|;
name|DeltaY
operator|=
operator|-
name|DeltaY
expr_stmt|;
block|}
if|if
condition|(
name|DeltaX
operator|>
name|DeltaY
condition|)
block|{
name|SignX
operator|<
literal|0
condition|?
name|NewVerts
operator|->
name|x
operator|++
else|:
name|NewVerts
operator|->
name|x
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|DeltaX
operator|>>
literal|1
operator|)
operator|<=
name|DeltaY
condition|)
block|{
name|SignY
operator|<
literal|0
condition|?
name|NewVerts
operator|->
name|y
operator|++
else|:
name|NewVerts
operator|->
name|y
operator|--
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|DeltaX
operator|<
name|DeltaY
condition|)
block|{
name|SignY
operator|<
literal|0
condition|?
name|NewVerts
operator|->
name|y
operator|++
else|:
name|NewVerts
operator|->
name|y
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|DeltaY
operator|>>
literal|1
operator|)
operator|<=
name|DeltaX
condition|)
block|{
name|SignX
operator|<
literal|0
condition|?
name|NewVerts
operator|->
name|x
operator|++
else|:
name|NewVerts
operator|->
name|x
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|DeltaX
operator|>
literal|0
condition|)
block|{
name|SignX
operator|<
literal|0
condition|?
name|NewVerts
operator|->
name|x
operator|++
else|:
name|NewVerts
operator|->
name|x
operator|--
expr_stmt|;
name|SignY
operator|<
literal|0
condition|?
name|NewVerts
operator|->
name|y
operator|++
else|:
name|NewVerts
operator|->
name|y
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Line now has a length of zero 				 * so we skip this one. Back up the 				 * buffer pointer and move on to the 				 * next vertex 				 */
name|NewVerts
operator|--
expr_stmt|;
comment|/* 				 * Increment vertex pointers 				 */
name|LastVertex
operator|=
name|ThisVertex
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
block|}
comment|/* 		     * Advance buffer pointer 		     */
name|NewVerts
operator|++
expr_stmt|;
comment|/* 		     * Increment vertex count 		     */
name|VertexCount
operator|+=
literal|2
expr_stmt|;
comment|/* 		     * Increment vertex pointers 		     */
name|LastVertex
operator|=
name|ThisVertex
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     * Ignore this vertex 		     */
name|ThisVertex
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|j
condition|)
do|;
block|}
block|}
comment|/*      * Save final vertex count and free any resources used      * during path list conversion.      */
operator|*
name|newvertcount
operator|=
name|VertexCount
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|SegmentTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|SplineUsed
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|SplineVertexBuffer
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Generate a series of points that will form  * a curve between Vertex_B and Vertex_C.  */
end_comment

begin_expr_stmt
specifier|static
name|Spline
argument_list|(
name|Vertex_A
argument_list|,
name|Vertex_B
argument_list|,
name|Vertex_C
argument_list|,
name|Vertex_D
argument_list|)
specifier|register
name|Vertex
operator|*
name|Vertex_A
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Vertex
modifier|*
name|Vertex_B
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|Vertex
modifier|*
name|Vertex_C
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|Vertex
modifier|*
name|Vertex_D
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Vertex
modifier|*
name|Verts
init|=
operator|&
name|SplineVertexBuffer
index|[
name|SplineVertexIndex
index|]
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|int
name|nls
init|=
literal|1
decl_stmt|;
name|int
name|Delta_X
decl_stmt|,
name|Delta_Y
decl_stmt|;
name|long
name|Matrix
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|TRACE_X
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In Spline\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRACE_X
name|GrowSplineVertexBuffer
argument_list|(
name|Verts
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|*
name|Verts
operator|++
operator|=
operator|*
name|Vertex_B
expr_stmt|;
name|SplineVertexIndex
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|Vertex_C
operator|->
name|flags
operator|&
name|VertexDontDraw
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*  	 * Compute how many points to generate 	 * based on the largest delta change in either  	 * the X or Y direction. This number represents 	 * the maximum number of points to be generated 	 * and may be reduced by an increasing amount 	 * as the change (delta) gets larger. This allows 	 * us to generate fewer points and therefore  	 * improve performace and still generate 	 * quality smooth curve. 	 */
if|if
condition|(
operator|(
name|Delta_X
operator|=
name|Vertex_C
operator|->
name|x
operator|-
name|Vertex_B
operator|->
name|x
operator|)
operator|<
literal|0
condition|)
block|{
name|Delta_X
operator|=
operator|-
name|Delta_X
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|Delta_Y
operator|=
name|Vertex_C
operator|->
name|y
operator|-
name|Vertex_B
operator|->
name|y
operator|)
operator|<
literal|0
condition|)
block|{
name|Delta_Y
operator|=
operator|-
name|Delta_Y
expr_stmt|;
block|}
if|if
condition|(
name|Delta_X
operator|>
name|Delta_Y
condition|)
block|{
if|if
condition|(
name|Delta_X
operator|>
literal|64
condition|)
block|{
name|nls
operator|=
name|Delta_X
operator|>>
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Delta_X
operator|>
literal|32
condition|)
block|{
name|nls
operator|=
name|Delta_X
operator|>>
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Delta_X
operator|>
literal|16
condition|)
block|{
name|nls
operator|=
name|Delta_X
operator|>>
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nls
operator|=
name|Delta_X
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|Delta_Y
operator|>
literal|64
condition|)
block|{
name|nls
operator|=
name|Delta_Y
operator|>>
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Delta_Y
operator|>
literal|32
condition|)
block|{
name|nls
operator|=
name|Delta_Y
operator|>>
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Delta_Y
operator|>
literal|16
condition|)
block|{
name|nls
operator|=
name|Delta_Y
operator|>>
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nls
operator|=
name|Delta_Y
expr_stmt|;
block|}
block|}
comment|/* 	 * Generate the actual points 	 */
if|if
condition|(
name|nls
condition|)
block|{
name|GrowSplineVertexBuffer
argument_list|(
name|Verts
argument_list|,
name|nls
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nls
condition|;
name|i
operator|++
operator|,
name|Verts
operator|++
control|)
block|{
name|Verts
operator|->
name|x
operator|=
name|Matrix
argument_list|(
operator|(
name|long
operator|)
name|Vertex_A
operator|->
name|x
argument_list|,
operator|(
name|long
operator|)
name|Vertex_B
operator|->
name|x
argument_list|,
operator|(
name|long
operator|)
name|Vertex_C
operator|->
name|x
argument_list|,
operator|(
name|long
operator|)
name|Vertex_D
operator|->
name|x
argument_list|,
name|nls
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Verts
operator|->
name|y
operator|=
name|Matrix
argument_list|(
operator|(
name|long
operator|)
name|Vertex_A
operator|->
name|y
argument_list|,
operator|(
name|long
operator|)
name|Vertex_B
operator|->
name|y
argument_list|,
operator|(
name|long
operator|)
name|Vertex_C
operator|->
name|y
argument_list|,
operator|(
name|long
operator|)
name|Vertex_D
operator|->
name|y
argument_list|,
name|nls
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|Verts
operator|->
name|flags
operator|=
name|Vertex_C
operator|->
name|flags
operator|&
name|VertexDrawLastPoint
expr_stmt|;
block|}
name|SplineVertexIndex
operator|+=
name|nls
expr_stmt|;
block|}
else|else
block|{
name|nls
operator|=
literal|1
expr_stmt|;
name|SplineVertexIndex
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|SplineVertexIndex
operator|++
expr_stmt|;
block|}
operator|*
name|Verts
operator|=
operator|*
name|Vertex_C
expr_stmt|;
comment|/*      * Return the number of points generated       */
return|return
operator|(
name|nls
operator|+
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*   * This rtn performs the matrix math require to interpolate a  * point on the curve represented by a, b, c, and d. The generated   * point will be between points b and c.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|Matrix
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|nls
argument_list|,
name|i
argument_list|)
decl|register
name|long
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|nls
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|long
name|p
init|=
name|SHIFT_LEFT_16
argument_list|(
operator|-
name|a
operator|+
name|b
operator|-
name|c
operator|+
name|d
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE_X
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In Matrix\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRACE_X
name|p
operator|=
name|PERCENT_16
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|nls
argument_list|)
operator|+
name|SHIFT_LEFT_16
argument_list|(
operator|(
name|a
operator|<<
literal|1
operator|)
operator|-
operator|(
name|b
operator|<<
literal|1
operator|)
operator|+
name|c
operator|-
name|d
argument_list|)
expr_stmt|;
name|p
operator|=
name|PERCENT_16
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|nls
argument_list|)
operator|+
name|SHIFT_LEFT_16
argument_list|(
operator|-
name|a
operator|+
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROUND_16
argument_list|(
name|PERCENT_16
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|nls
argument_list|)
operator|+
name|SHIFT_LEFT_16
argument_list|(
name|b
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_block

end_unit

