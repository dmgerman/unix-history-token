begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_makemask_c
init|=
literal|"$Header: makemask.c,v 10.1 86/11/19 10:42:30 jg Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/* makemask.c -  builds a mask from vertex list  *  *	MakeMask     builds a mask from vertex list  *	AddEdge	     adds edges to edge table for fill operation  *	FillMask     fills mask using scan line algorithm  *  *  	Author:  *		Scott Bates  *		Brown University  *		IRIS, Box 1946  *      	Providence, RI 02912  *  *  *		Copyright (c) 1986 Brown University  *  * Permission to use, copy, modify and distribute this software and its  * documentation for any purpose and without fee is hereby granted, provided  * that the above copyright notice appear in all copies, and that both  * that copyright notice and this permission notice appear in supporting  * documentation, and that the name of Brown University not be used in  * advertising or publicity pertaining to distribution of the software  * without specific, written prior permission. Brown University makes no  * representations about the suitability of this software for any purpose.  * It is provided "as-is" without express or implied warranty.  */
end_comment

begin_include
include|#
directive|include
file|"private.h"
end_include

begin_include
include|#
directive|include
file|"makemask.h"
end_include

begin_include
include|#
directive|include
file|"pathlist.h"
end_include

begin_comment
comment|/*  * Build mask from vertex list  */
end_comment

begin_function
name|BITMAP
modifier|*
name|MakeMask
parameter_list|(
name|Verts
parameter_list|,
name|VertCount
parameter_list|)
name|Vertex
modifier|*
name|Verts
decl_stmt|;
name|int
name|VertCount
decl_stmt|;
block|{
specifier|register
name|Vertex
modifier|*
name|LastPoint
decl_stmt|;
specifier|register
name|Vertex
modifier|*
name|ThisPoint
decl_stmt|;
specifier|register
name|Vertex
modifier|*
name|NextPoint
decl_stmt|;
specifier|register
name|Vertex
modifier|*
name|Poly
decl_stmt|;
specifier|register
name|struct
name|Polygon
modifier|*
name|PolyData
decl_stmt|;
specifier|register
name|End
expr_stmt|;
name|int
name|Width
init|=
literal|0
decl_stmt|,
name|Height
init|=
literal|0
decl_stmt|;
name|int
name|FirstScanLine
init|=
literal|10240
decl_stmt|;
name|int
name|Index
decl_stmt|,
name|Size
decl_stmt|;
name|BITMAP
modifier|*
name|BitMap
decl_stmt|;
name|struct
name|Polygon
modifier|*
name|FirstPoly
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE_X
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In MakeMask\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRACE_X
comment|/* 	 * Allocate space for polygon pointers 	 */
name|FirstPoly
operator|=
operator|(
expr|struct
name|Polygon
operator|*
operator|)
name|calloc
argument_list|(
name|VertCount
operator|<<
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|Polygon
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FirstPoly
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Determine width and height of off-screen bitmap 	 * and the first scan line to be filled. 	 */
name|PolyData
operator|=
name|FirstPoly
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|VertCount
condition|;
name|Index
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|Width
operator|<
name|Verts
index|[
name|Index
index|]
operator|.
name|x
condition|)
name|Width
operator|=
name|Verts
index|[
name|Index
index|]
operator|.
name|x
expr_stmt|;
if|if
condition|(
name|Height
operator|<
name|Verts
index|[
name|Index
index|]
operator|.
name|y
condition|)
name|Height
operator|=
name|Verts
index|[
name|Index
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|FirstScanLine
operator|>
name|Verts
index|[
name|Index
index|]
operator|.
name|y
condition|)
name|FirstScanLine
operator|=
name|Verts
index|[
name|Index
index|]
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|Verts
index|[
name|Index
index|]
operator|.
name|flags
operator|&
name|START_OF_CLOSED_POLY
condition|)
block|{
operator|(
operator|++
name|PolyData
operator|)
operator|->
name|PolyPoints
operator|=
operator|&
name|Verts
index|[
name|Index
index|]
expr_stmt|;
name|PolyData
operator|->
name|PolyCount
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|PolyData
operator|->
name|PolyCount
operator|+=
literal|2
expr_stmt|;
block|}
block|}
operator|(
operator|++
name|PolyData
operator|)
operator|->
name|PolyPoints
operator|=
operator|(
name|Vertex
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/*          * Allocate space for bitmap structure          */
name|BitMap
operator|=
operator|(
name|BITMAP
operator|*
operator|)
name|Xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BITMAP
argument_list|)
argument_list|)
expr_stmt|;
comment|/*          * Fill in bitmap structure 	 * 	 * NOTE: The bitmaps width has been rounded up  	 *       to the nearest 32 bit bound. This was done 	 *       so that the mask could be fill 32 bits at 	 *       a time instead of the usual 16.          */
name|BitMap
operator|->
name|width
operator|=
name|Width
operator|=
operator|(
operator|(
name|Width
operator|+
literal|32
operator|)
operator|>>
literal|5
operator|)
operator|<<
literal|5
expr_stmt|;
name|BitMap
operator|->
name|height
operator|=
operator|++
name|Height
expr_stmt|;
comment|/*          * Allocated space to hold bitimage data          */
if|if
condition|(
operator|(
name|BitMap
operator|->
name|data
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|BitmapSize
argument_list|(
name|Width
argument_list|,
name|Height
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|BitMap
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Allocate space for edges and reset EdgeCount 	 */
name|Edges
operator|=
operator|(
expr|struct
name|edge
operator|*
operator|)
name|calloc
argument_list|(
name|VertCount
operator|<<
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|edge
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Edges
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|BitMap
operator|->
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|BitMap
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|EdgeTable
operator|=
operator|(
expr|struct
name|edge
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|Height
operator|+
literal|1
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|Edges
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|BitMap
operator|->
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|BitMap
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|EdgeCount
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Add the edges of all polygons to 	 * the edge table 	 */
name|Poly
operator|=
operator|(
name|PolyData
operator|=
name|FirstPoly
operator|)
operator|->
name|PolyPoints
expr_stmt|;
do|do
block|{
comment|/* 		 * Test for valid polygon 		 */
if|if
condition|(
name|PolyData
operator|->
name|PolyCount
operator|>
literal|5
condition|)
block|{
comment|/* 			 * AddEdge() initialization before adding 			 * each polygon 			 */
name|ShortenStartOfEdge
operator|=
literal|0
expr_stmt|;
name|Direction
operator|=
name|Poly
index|[
name|PolyData
operator|->
name|PolyCount
operator|-
literal|2
index|]
operator|.
name|y
operator|>
name|Poly
index|[
literal|0
index|]
operator|.
name|y
expr_stmt|;
name|End
operator|=
name|PolyData
operator|->
name|PolyCount
operator|-
literal|4
expr_stmt|;
name|LastPoint
operator|=
name|Poly
expr_stmt|;
name|ThisPoint
operator|=
name|NextPoint
operator|=
name|Poly
operator|+
literal|2
expr_stmt|;
comment|/* 	 	 	 * Add edges of this polygon to edge table 	 	 	 */
while|while
condition|(
name|End
condition|)
block|{
name|NextPoint
operator|+=
literal|2
expr_stmt|;
name|AddEdge
argument_list|(
name|LastPoint
argument_list|,
name|ThisPoint
argument_list|,
name|NextPoint
argument_list|)
expr_stmt|;
name|LastPoint
operator|=
name|ThisPoint
expr_stmt|;
name|ThisPoint
operator|=
name|NextPoint
expr_stmt|;
name|End
operator|-=
literal|2
expr_stmt|;
block|}
name|NextPoint
operator|=
operator|&
name|Poly
index|[
literal|0
index|]
expr_stmt|;
name|AddEdge
argument_list|(
name|LastPoint
argument_list|,
name|ThisPoint
argument_list|,
name|NextPoint
argument_list|)
expr_stmt|;
name|LastPoint
operator|=
name|ThisPoint
expr_stmt|;
name|ThisPoint
operator|=
name|NextPoint
expr_stmt|;
name|NextPoint
operator|+=
literal|2
expr_stmt|;
name|AddEdge
argument_list|(
name|LastPoint
argument_list|,
name|ThisPoint
argument_list|,
name|NextPoint
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Increment pointer to next polygon to add 		 */
name|Poly
operator|=
operator|(
operator|++
name|PolyData
operator|)
operator|->
name|PolyPoints
expr_stmt|;
block|}
do|while
condition|(
name|Poly
condition|)
do|;
if|if
condition|(
name|EdgeCount
condition|)
block|{
comment|/* 	 	 * Fill the mask 	 	 */
name|FillMask
argument_list|(
name|BitMap
argument_list|,
name|FirstScanLine
argument_list|)
expr_stmt|;
comment|/* 	 	 * Frame mask to remove any abnomalities 	 	 */
for|for
control|(
name|Index
operator|=
literal|0
init|;
name|Index
operator|<
name|VertCount
condition|;
name|Index
operator|+=
literal|2
control|)
block|{
name|SinglePixelLine
argument_list|(
name|BitMap
argument_list|,
name|Verts
index|[
name|Index
index|]
operator|.
name|x
argument_list|,
name|Verts
index|[
name|Index
index|]
operator|.
name|y
argument_list|,
name|Verts
index|[
name|Index
operator|+
literal|1
index|]
operator|.
name|x
argument_list|,
name|Verts
index|[
name|Index
operator|+
literal|1
index|]
operator|.
name|y
argument_list|,
operator|(
name|CLIP
operator|*
operator|)
literal|0
argument_list|,
name|GXor
argument_list|,
name|DrawSolidLine
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*  	 	 * Return mask bitmap 	 	 */
return|return
operator|(
name|BitMap
operator|)
return|;
block|}
comment|/* 	 * Indicate nothing to fill 	 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add edge to edge table  */
end_comment

begin_expr_stmt
specifier|static
name|AddEdge
argument_list|(
name|LastPoint
argument_list|,
name|ThisPoint
argument_list|,
name|NextPoint
argument_list|)
specifier|register
name|Vertex
operator|*
name|LastPoint
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Vertex
modifier|*
name|ThisPoint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|Vertex
modifier|*
name|NextPoint
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|edge
modifier|*
name|NewEdge
init|=
operator|&
name|Edges
index|[
name|EdgeCount
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE_X
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In AddEdge\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRACE_X
comment|/*      * Fill in new edge data      */
if|if
condition|(
name|ThisPoint
operator|->
name|y
operator|!=
name|LastPoint
operator|->
name|y
condition|)
block|{
specifier|register
name|Min_Y
expr_stmt|;
if|if
condition|(
name|ThisPoint
operator|->
name|y
operator|<
name|LastPoint
operator|->
name|y
condition|)
block|{
name|Min_Y
operator|=
name|ThisPoint
operator|->
name|y
expr_stmt|;
name|NewEdge
operator|->
name|Min_X
operator|=
name|SHIFT_LEFT_16
argument_list|(
name|ThisPoint
operator|->
name|x
argument_list|)
expr_stmt|;
name|NewEdge
operator|->
name|Max_Y
operator|=
name|LastPoint
operator|->
name|y
expr_stmt|;
name|NewEdge
operator|->
name|Delta_X
operator|=
name|SHIFT_LEFT_16
argument_list|(
name|LastPoint
operator|->
name|x
operator|-
name|ThisPoint
operator|->
name|x
argument_list|)
operator|/
operator|(
name|LastPoint
operator|->
name|y
operator|-
name|ThisPoint
operator|->
name|y
operator|)
expr_stmt|;
block|}
else|else
block|{
name|Min_Y
operator|=
name|LastPoint
operator|->
name|y
expr_stmt|;
name|NewEdge
operator|->
name|Min_X
operator|=
name|SHIFT_LEFT_16
argument_list|(
name|LastPoint
operator|->
name|x
argument_list|)
expr_stmt|;
name|NewEdge
operator|->
name|Max_Y
operator|=
name|ThisPoint
operator|->
name|y
expr_stmt|;
name|NewEdge
operator|->
name|Delta_X
operator|=
name|SHIFT_LEFT_16
argument_list|(
name|ThisPoint
operator|->
name|x
operator|-
name|LastPoint
operator|->
name|x
argument_list|)
operator|/
operator|(
name|ThisPoint
operator|->
name|y
operator|-
name|LastPoint
operator|->
name|y
operator|)
expr_stmt|;
block|}
comment|/* 	 * Shorten edge if not maxima or minima (shortens end of edge) 	 */
if|if
condition|(
operator|(
name|ThisPoint
operator|->
name|y
operator|>
name|LastPoint
operator|->
name|y
operator|)
condition|?
operator|(
name|NextPoint
operator|->
name|y
operator|>
name|ThisPoint
operator|->
name|y
operator|)
else|:
operator|(
name|NextPoint
operator|->
name|y
operator|<
name|ThisPoint
operator|->
name|y
operator|)
condition|)
block|{
if|if
condition|(
name|LastPoint
operator|->
name|y
operator|>
name|ThisPoint
operator|->
name|y
condition|)
block|{
name|Min_Y
operator|++
expr_stmt|;
name|NewEdge
operator|->
name|Min_X
operator|+=
name|NewEdge
operator|->
name|Delta_X
expr_stmt|;
block|}
else|else
block|{
name|NewEdge
operator|->
name|Max_Y
operator|--
expr_stmt|;
block|}
block|}
comment|/* 	 * Check to see if this edge needs to be shortened 	 * at its start. 	 */
if|if
condition|(
name|ShortenStartOfEdge
condition|)
block|{
if|if
condition|(
name|ThisPoint
operator|->
name|y
operator|>
name|LastPoint
operator|->
name|y
condition|)
block|{
name|Min_Y
operator|++
expr_stmt|;
name|NewEdge
operator|->
name|Min_X
operator|+=
name|NewEdge
operator|->
name|Delta_X
expr_stmt|;
block|}
else|else
block|{
name|NewEdge
operator|->
name|Max_Y
operator|--
expr_stmt|;
block|}
name|ShortenStartOfEdge
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Save direction of this edge 	 */
if|if
condition|(
name|NextPoint
operator|->
name|y
operator|==
name|ThisPoint
operator|->
name|y
condition|)
block|{
name|Direction
operator|=
name|LastPoint
operator|->
name|y
operator|>
name|ThisPoint
operator|->
name|y
expr_stmt|;
block|}
comment|/* 	 * Insert edge into edge table 	 */
if|if
condition|(
name|NewEdge
operator|->
name|Max_Y
operator|>=
name|Min_Y
condition|)
block|{
specifier|register
name|struct
name|edge
modifier|*
name|EdgeList
init|=
operator|(
expr|struct
name|edge
operator|*
operator|)
operator|&
name|EdgeTable
index|[
name|Min_Y
index|]
decl_stmt|;
while|while
condition|(
name|EdgeList
operator|->
name|NextEdge
condition|)
block|{
if|if
condition|(
name|EdgeList
operator|->
name|NextEdge
operator|->
name|Min_X
operator|>=
name|NewEdge
operator|->
name|Min_X
condition|)
break|break;
name|EdgeList
operator|=
name|EdgeList
operator|->
name|NextEdge
expr_stmt|;
block|}
name|NewEdge
operator|->
name|NextEdge
operator|=
name|EdgeList
operator|->
name|NextEdge
expr_stmt|;
name|EdgeList
operator|->
name|NextEdge
operator|=
name|NewEdge
expr_stmt|;
name|EdgeCount
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * This is a horizontal edge. Therefore, if there is 	 * a change of direction between the preceding edge and 	 * and the next edge the next edge must be shortened at its  	 * start. 	 */
if|if
condition|(
name|NextPoint
operator|->
name|y
operator|!=
name|ThisPoint
operator|->
name|y
operator|&&
operator|(
name|Direction
operator|!=
operator|(
name|NextPoint
operator|->
name|y
operator|>
name|ThisPoint
operator|->
name|y
operator|)
operator|)
condition|)
block|{
name|ShortenStartOfEdge
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Fill polygon(s) to create mask  */
end_comment

begin_expr_stmt
specifier|static
name|FillMask
argument_list|(
argument|BitMap
argument_list|,
argument|FirstScanLine
argument_list|)
name|BITMAP
operator|*
name|BitMap
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|FirstScanLine
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|long
modifier|*
name|Bits
decl_stmt|;
specifier|register
name|Start
operator|,
name|Stop
expr_stmt|;
specifier|register
name|FirstWord
operator|,
name|LastWord
expr_stmt|;
specifier|register
name|struct
name|edge
modifier|*
name|AET
decl_stmt|;
name|struct
name|edge
modifier|*
name|ActiveEdgeTable
decl_stmt|;
name|struct
name|edge
modifier|*
name|TempEdge
decl_stmt|;
name|int
name|NumberOfWords
decl_stmt|,
name|CurrentScanLine
decl_stmt|,
name|SortAgain
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE_X
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In FillMask\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRACE_X
name|NumberOfWords
operator|=
operator|(
name|BitMap
operator|->
name|width
operator|+
literal|31
operator|)
operator|>>
literal|5
expr_stmt|;
name|Bits
operator|=
operator|(
name|long
operator|*
operator|)
name|BitMap
operator|->
name|data
operator|+
name|FirstScanLine
operator|*
name|NumberOfWords
expr_stmt|;
name|ActiveEdgeTable
operator|=
name|EdgeTable
index|[
name|FirstScanLine
index|]
expr_stmt|;
name|CurrentScanLine
operator|=
name|FirstScanLine
expr_stmt|;
while|while
condition|(
name|EdgeCount
condition|)
block|{
comment|/* 	     * Fill all ranges for current scan line 	     */
name|AET
operator|=
operator|(
expr|struct
name|edge
operator|*
operator|)
operator|&
name|ActiveEdgeTable
expr_stmt|;
while|while
condition|(
name|AET
operator|->
name|NextEdge
operator|&&
name|AET
operator|->
name|NextEdge
operator|->
name|NextEdge
condition|)
block|{
name|Start
operator|=
name|ROUND_16
argument_list|(
name|AET
operator|->
name|NextEdge
operator|->
name|Min_X
argument_list|)
expr_stmt|;
name|Stop
operator|=
name|ROUND_16
argument_list|(
name|AET
operator|->
name|NextEdge
operator|->
name|NextEdge
operator|->
name|Min_X
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|FirstWord
operator|=
name|Start
operator|>>
literal|5
operator|)
operator|<
operator|(
name|LastWord
operator|=
name|Stop
operator|>>
literal|5
operator|)
condition|)
block|{
name|Bits
index|[
name|FirstWord
index|]
operator||=
name|RightMasks
index|[
name|Start
operator|&
literal|0x1F
index|]
expr_stmt|;
while|while
condition|(
operator|++
name|FirstWord
operator|<
name|LastWord
condition|)
name|Bits
index|[
name|FirstWord
index|]
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|Bits
index|[
name|LastWord
index|]
operator||=
name|LeftMasks
index|[
name|Stop
operator|&
literal|0x1F
index|]
expr_stmt|;
block|}
else|else
block|{
name|Bits
index|[
name|FirstWord
index|]
operator||=
operator|(
name|RightMasks
index|[
name|Start
operator|&
literal|0x1F
index|]
operator|&
name|LeftMasks
index|[
name|Stop
operator|&
literal|0x1F
index|]
operator|)
expr_stmt|;
block|}
name|AET
operator|=
name|AET
operator|->
name|NextEdge
operator|->
name|NextEdge
expr_stmt|;
block|}
name|Bits
operator|+=
name|NumberOfWords
expr_stmt|;
comment|/* 	     * Remove finished edges from active edge table  	     * and add any new edges for next scan line. 	     */
name|AET
operator|=
operator|(
expr|struct
name|edge
operator|*
operator|)
operator|&
name|ActiveEdgeTable
expr_stmt|;
while|while
condition|(
name|AET
operator|->
name|NextEdge
condition|)
block|{
if|if
condition|(
name|AET
operator|->
name|NextEdge
operator|->
name|Max_Y
operator|==
name|CurrentScanLine
condition|)
block|{
name|AET
operator|->
name|NextEdge
operator|=
name|AET
operator|->
name|NextEdge
operator|->
name|NextEdge
expr_stmt|;
name|EdgeCount
operator|--
expr_stmt|;
block|}
else|else
block|{
name|AET
operator|->
name|NextEdge
operator|->
name|Min_X
operator|+=
name|AET
operator|->
name|NextEdge
operator|->
name|Delta_X
expr_stmt|;
name|AET
operator|=
name|AET
operator|->
name|NextEdge
expr_stmt|;
block|}
block|}
name|AET
operator|->
name|NextEdge
operator|=
name|EdgeTable
index|[
operator|++
name|CurrentScanLine
index|]
expr_stmt|;
comment|/* 	     * Sort active edge table 	     */
do|do
block|{
name|SortAgain
operator|=
literal|0
expr_stmt|;
name|AET
operator|=
operator|(
expr|struct
name|edge
operator|*
operator|)
operator|&
name|ActiveEdgeTable
expr_stmt|;
while|while
condition|(
name|AET
operator|->
name|NextEdge
operator|&&
name|AET
operator|->
name|NextEdge
operator|->
name|NextEdge
condition|)
block|{
if|if
condition|(
name|AET
operator|->
name|NextEdge
operator|->
name|Min_X
operator|>
name|AET
operator|->
name|NextEdge
operator|->
name|NextEdge
operator|->
name|Min_X
condition|)
block|{
name|TempEdge
operator|=
name|AET
operator|->
name|NextEdge
expr_stmt|;
name|AET
operator|->
name|NextEdge
operator|=
name|AET
operator|->
name|NextEdge
operator|->
name|NextEdge
expr_stmt|;
name|TempEdge
operator|->
name|NextEdge
operator|=
name|AET
operator|->
name|NextEdge
operator|->
name|NextEdge
expr_stmt|;
name|AET
operator|->
name|NextEdge
operator|->
name|NextEdge
operator|=
name|TempEdge
expr_stmt|;
name|SortAgain
operator|=
literal|1
expr_stmt|;
block|}
name|AET
operator|=
name|AET
operator|->
name|NextEdge
expr_stmt|;
block|}
block|}
do|while
condition|(
name|SortAgain
condition|)
do|;
block|}
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|EdgeTable
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|Edges
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

