begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_copybits_c
init|=
literal|"$Header: copybits.c,v 10.1 86/11/19 10:40:50 jg Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/* copybits.c -  Interface routine to bitblt()  *  *   	CopyBits	Places "X" supplied data into blt structure before  *			calling bitblt() ounce for each clipping rectangle  *			in the cliplist.  *  *  	Author:  *		Scott Bates  *		Brown University  *		IRIS, Box 1946  *      	Providence, RI 02912  *  *  *		Copyright (c) 1986 Brown University  *  * Permission to use, copy, modify and distribute this software and its  * documentation for any purpose and without fee is hereby granted, provided  * that the above copyright notice appear in all copies, and that both  * that copyright notice and this permission notice appear in supporting  * documentation, and that the name of Brown University not be used in  * advertising or publicity pertaining to distribution of the software  * without specific, written prior permission. Brown University makes no  * representations about the suitability of this software for any purpose.  * It is provided "as-is" without express or implied warranty.  */
end_comment

begin_include
include|#
directive|include
file|"private.h"
end_include

begin_include
include|#
directive|include
file|"bitblt.h"
end_include

begin_comment
comment|/*  * General interface routine to bitblt()  */
end_comment

begin_macro
name|CopyBits
argument_list|(
argument|srcbits
argument_list|,
argument|srcwidth
argument_list|,
argument|srcheight
argument_list|,
argument|srcrect
argument_list|,
argument|dstbits
argument_list|,
argument|dstwidth
argument_list|,
argument|dstheight
argument_list|,
argument|dstrect
argument_list|,
argument|maskbits
argument_list|,
argument|maskwidth
argument_list|,
argument|maskheight
argument_list|,
argument|rule
argument_list|,
argument|clipcount
argument_list|,
argument|cliplist
argument_list|)
end_macro

begin_decl_stmt
name|u_short
modifier|*
name|srcbits
decl_stmt|,
modifier|*
name|dstbits
decl_stmt|,
modifier|*
name|maskbits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|Blt_Rectangle
modifier|*
name|srcrect
decl_stmt|,
modifier|*
name|dstrect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|srcwidth
decl_stmt|,
name|srcheight
decl_stmt|,
name|dstwidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maskwidth
decl_stmt|,
name|maskheight
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dstheight
decl_stmt|,
name|rule
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|clipcount
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|CLIP
modifier|*
name|cliplist
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Blt
modifier|*
name|blt
init|=
operator|&
name|bltdata
decl_stmt|;
specifier|register
name|Blt_Bitmap
modifier|*
name|dstbitmap
init|=
operator|&
name|blt
operator|->
name|dst_bitmap
decl_stmt|;
specifier|register
name|Blt_Rectangle
modifier|*
name|cliprect
init|=
operator|&
name|blt
operator|->
name|clp_rect
decl_stmt|;
ifdef|#
directive|ifdef
name|FULL_TRACE_X
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In CopyBits\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|FULL_TRACE_X
comment|/* 	 * Clear blt structure 	 */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|blt
argument_list|,
sizeof|sizeof
argument_list|(
name|Blt
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AED
comment|/* 	 * If this is the AED make sure this blt 	 * gets echoed 	 */
name|blt
operator|->
name|blt_flags
operator||=
name|BLT_ECHO
expr_stmt|;
endif|#
directive|endif
endif|AED
comment|/* 	 * Set up source bitmap or tile 	 */
if|if
condition|(
name|IS_RULE_TILE
argument_list|(
name|rule
argument_list|)
condition|)
block|{
comment|/* 		 * Srcbits is a tile 		 */
name|blt
operator|->
name|tile_ptr
operator|=
operator|(
name|Blt_Tile
operator|*
operator|)
name|srcbits
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|Blt_Bitmap
modifier|*
name|srcbitmap
init|=
operator|&
name|blt
operator|->
name|src_bitmap
decl_stmt|;
comment|/* 		 * Srcbits is a bitimage. Convert bitimage to bitmap 		 */
name|BitimageToBitmap
argument_list|(
name|srcbits
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|srcwidth
argument_list|,
name|srcheight
argument_list|,
name|srcbitmap
argument_list|)
expr_stmt|;
comment|/* 		 * Copy source rectangle to blt structure 		 */
name|blt
operator|->
name|src_rect
operator|=
operator|*
name|srcrect
expr_stmt|;
block|}
comment|/* 	 * Convert destination bitimage to a bitmap 	 */
name|BitimageToBitmap
argument_list|(
name|dstbits
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dstwidth
argument_list|,
name|dstheight
argument_list|,
name|dstbitmap
argument_list|)
expr_stmt|;
comment|/* 	 * Copy destination rectangle to blt structure 	 */
name|blt
operator|->
name|dst_rect
operator|=
operator|*
name|dstrect
expr_stmt|;
comment|/* 	 * Set combination rule in blt structure 	 */
name|blt
operator|->
name|comb_rule
operator|=
name|rule
expr_stmt|;
comment|/* 	 * Is there a clipping mask ? 	 */
if|if
condition|(
name|maskbits
condition|)
block|{
specifier|register
name|Blt_Bitmap
modifier|*
name|mskbitmap
init|=
operator|&
name|blt
operator|->
name|msk_bitmap
decl_stmt|;
comment|/* 		 * Indicate that there is a mask 		 */
name|blt
operator|->
name|blt_flags
operator||=
name|BLT_MASKON
expr_stmt|;
comment|/* 		 * Convert mask bitimage to bitmap 		 * 		 * NOTE: The clipping mask has the same origin 		 *       as the destination rectangle but can 		 *       be larger in width and height. 		 */
name|BitimageToBitmap
argument_list|(
name|maskbits
argument_list|,
name|dstrect
operator|->
name|origin_x
argument_list|,
name|dstrect
operator|->
name|origin_y
argument_list|,
name|maskwidth
argument_list|,
name|maskheight
argument_list|,
name|mskbitmap
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * No X clips specified ? 	 */
if|if
condition|(
name|clipcount
operator|==
literal|0
condition|)
block|{
comment|/*                  * Turn clipping off during this blt                  */
name|blt
operator|->
name|blt_flags
operator|&=
operator|~
name|BLT_CLIPON
expr_stmt|;
comment|/*                  * No X clips so blt and run                  */
name|bitblt
argument_list|(
name|blt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Perform same blt for each X clip 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Convert X clip to clipping rectangle 		 */
name|ClipToRect
argument_list|(
name|cliplist
argument_list|,
name|cliprect
argument_list|)
expr_stmt|;
comment|/* 		 * If destination lies inside of clipping rectangle 		 * turn off clipping flag during this blt otherwise  		 * turn it on. 		 */
if|if
condition|(
name|InsideBounds
argument_list|(
name|dstrect
argument_list|,
name|cliprect
argument_list|)
condition|)
block|{
name|blt
operator|->
name|blt_flags
operator|&=
operator|~
name|BLT_CLIPON
expr_stmt|;
block|}
else|else
block|{
name|blt
operator|->
name|blt_flags
operator||=
name|BLT_CLIPON
expr_stmt|;
block|}
comment|/* 		 * Lets go do the blt 		 */
name|bitblt
argument_list|(
name|blt
argument_list|)
expr_stmt|;
comment|/* 		 * Need to blt again ? 		 */
if|if
condition|(
operator|--
name|clipcount
operator|<=
literal|0
condition|)
block|{
comment|/* 			 * No more clips so lets leave 			 */
break|break;
block|}
comment|/* 		 * point to next X clip 		 */
name|cliplist
operator|++
expr_stmt|;
block|}
block|}
end_block

end_unit

