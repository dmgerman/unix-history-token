begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_spixline_c
init|=
literal|"$Header: spixline.c,v 10.1 86/11/19 10:44:12 jg Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/* spixline.c - single pixel wide line drawing routine  *  *	SinglePixelLine	draws solid, dashed and patterned lines  *			that are only one pixel wide  *  *  	Author:  *		Scott Bates  *		Brown University  *		IRIS, Box 1946  *      	Providence, RI 02912  *  *  *		Copyright (c) 1986 Brown University  *  * Permission to use, copy, modify and distribute this software and its  * documentation for any purpose and without fee is hereby granted, provided  * that the above copyright notice appear in all copies, and that both  * that copyright notice and this permission notice appear in supporting  * documentation, and that the name of Brown University not be used in  * advertising or publicity pertaining to distribution of the software  * without specific, written prior permission. Brown University makes no  * representations about the suitability of this software for any purpose.  * It is provided "as-is" without express or implied warranty.  */
end_comment

begin_include
include|#
directive|include
file|"private.h"
end_include

begin_include
include|#
directive|include
file|"bitblt.h"
end_include

begin_include
include|#
directive|include
file|"spixline.h"
end_include

begin_comment
comment|/*  * Draw single pixel wide line  */
end_comment

begin_macro
name|SinglePixelLine
argument_list|(
argument|BitMap
argument_list|,
argument|StartX
argument_list|,
argument|StartY
argument_list|,
argument|StopX
argument_list|,
argument|StopY
argument_list|,
argument|Clip
argument_list|,
argument|Rule
argument_list|,
argument|Mode
argument_list|,
argument|SrcPix
argument_list|,
argument|AltPix
argument_list|,
argument|Pattern
argument_list|,
argument|PatternLength
argument_list|,
argument|PatternMultiplier
argument_list|)
end_macro

begin_decl_stmt
name|BITMAP
modifier|*
name|BitMap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|StartX
decl_stmt|,
name|StartY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|StopX
decl_stmt|,
name|StopY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CLIP
modifier|*
name|Clip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Rule
decl_stmt|,
name|Mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|SrcPix
decl_stmt|,
name|AltPix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|Pattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|PatternLength
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|PatternMultiplier
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_short
name|MaskBit
decl_stmt|,
modifier|*
name|Destination
decl_stmt|,
name|Source
decl_stmt|;
specifier|register
name|BitsLeftToDraw
operator|,
name|Sentinel
operator|,
name|NumberOfBytes
expr_stmt|;
name|int
name|DeltaX
decl_stmt|,
name|DeltaY
decl_stmt|,
name|Temp
decl_stmt|,
name|RepeatCount
decl_stmt|;
name|u_short
name|AltSource
decl_stmt|,
name|PatternFirstBit
decl_stmt|,
name|PatternBit
decl_stmt|;
name|int
name|NumberOfShorts
decl_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|AED
argument_list|)
operator|||
name|defined
argument_list|(
name|APA8
argument_list|)
operator|||
name|defined
argument_list|(
name|APA8C
argument_list|)
operator|)
name|struct
name|Blt_Rectangle
name|Rect
decl_stmt|;
endif|#
directive|endif
endif|(AED || APA8 || APA8C)
if|#
directive|if
operator|(
name|defined
argument_list|(
name|APA8
argument_list|)
operator|||
name|defined
argument_list|(
name|APA8C
argument_list|)
operator|)
name|long
name|DestinationIncrement
decl_stmt|;
endif|#
directive|endif
endif|(APA8 || APA8C)
ifdef|#
directive|ifdef
name|AED
name|int
name|EchoLine
init|=
literal|1
decl_stmt|;
comment|/* 	 * If the destination is the screen and were not drawing a patterned 	 * line use the AED microcode to draw it. If the microcode is used  	 * then the blt does not have to be echoed to the AED to make visible. 	 * 	 * NOTE: If we are drawing a dashed line and the multiplier 	 *       is equal to one then use the AED microcode. Otherwise, 	 *       do it in software and then echo it to the AED. 	 */
if|if
condition|(
name|BitMap
operator|==
name|SCREEN_BITMAP
operator|&&
name|Mode
operator|!=
name|DrawPatternedLine
condition|)
block|{
if|if
condition|(
name|Mode
operator|==
name|DrawSolidLine
condition|)
block|{
name|ClipToRect
argument_list|(
name|Clip
argument_list|,
operator|&
name|Rect
argument_list|)
expr_stmt|;
name|aed_draw_line
argument_list|(
name|StartX
argument_list|,
name|StartY
argument_list|,
name|StopX
argument_list|,
name|StopY
argument_list|,
name|Rule
argument_list|,
literal|1
argument_list|,
operator|(
name|SrcPix
operator|&
literal|1
operator|)
argument_list|,
operator|(
name|u_short
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|Rect
argument_list|)
expr_stmt|;
name|EchoLine
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PatternMultiplier
operator|<
literal|2
condition|)
block|{
name|ClipToRect
argument_list|(
name|Clip
argument_list|,
operator|&
name|Rect
argument_list|)
expr_stmt|;
name|aed_draw_line
argument_list|(
name|StartX
argument_list|,
name|StartY
argument_list|,
name|StopX
argument_list|,
name|StopY
argument_list|,
name|Rule
argument_list|,
literal|1
argument_list|,
operator|(
name|SrcPix
operator|&
literal|1
operator|)
argument_list|,
name|Pattern
argument_list|,
name|PatternLength
argument_list|,
operator|&
name|Rect
argument_list|)
expr_stmt|;
name|EchoLine
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|AED
ifdef|#
directive|ifdef
name|TRACE_X
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In SinglePixelLine\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRACE_X
comment|/* 	 * Clip line. If nothing to draw after clip 	 * return to caller. 	 */
name|ClipLine
argument_list|(
name|StartX
argument_list|,
name|StartY
argument_list|,
name|StopX
argument_list|,
name|StopY
argument_list|,
name|Clip
argument_list|)
expr_stmt|;
comment|/* 	 * Always draw left to right 	 */
if|if
condition|(
name|StopX
operator|<
name|StartX
condition|)
block|{
name|Temp
operator|=
name|StopX
operator|,
name|StopX
operator|=
name|StartX
operator|,
name|StartX
operator|=
name|Temp
expr_stmt|;
name|Temp
operator|=
name|StopY
operator|,
name|StopY
operator|=
name|StartY
operator|,
name|StartY
operator|=
name|Temp
expr_stmt|;
block|}
comment|/* 	 * Compute delta values and bitmap width in shorts 	 */
name|DeltaX
operator|=
name|StopX
operator|-
name|StartX
expr_stmt|;
name|DeltaY
operator|=
name|StopY
operator|-
name|StartY
expr_stmt|;
name|NumberOfShorts
operator|=
operator|(
name|BitMap
operator|->
name|width
operator|+
literal|15
operator|)
operator|/
literal|16
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|APA8
argument_list|)
operator|||
name|defined
argument_list|(
name|APA8C
argument_list|)
operator|)
if|if
condition|(
name|DeltaY
operator|>
literal|0
condition|)
block|{
comment|/* drawing top to bottom */
if|if
condition|(
name|BitMap
operator|==
name|SCREEN_BITMAP
condition|)
name|NumberOfBytes
operator|=
name|NumberOfShorts
operator|<<
literal|2
expr_stmt|;
else|else
name|NumberOfBytes
operator|=
name|NumberOfShorts
operator|<<
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* drawing bottom to top */
if|if
condition|(
name|BitMap
operator|==
name|SCREEN_BITMAP
condition|)
name|NumberOfBytes
operator|=
operator|-
operator|(
name|NumberOfShorts
operator|<<
literal|2
operator|)
expr_stmt|;
else|else
name|NumberOfBytes
operator|=
operator|-
operator|(
name|NumberOfShorts
operator|<<
literal|1
operator|)
expr_stmt|;
name|DeltaY
operator|=
operator|-
name|DeltaY
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|DeltaY
operator|>
literal|0
condition|)
block|{
comment|/* drawing top to bottom */
name|NumberOfBytes
operator|=
name|NumberOfShorts
operator|<<
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* drawing bottom to top */
name|NumberOfBytes
operator|=
operator|-
operator|(
name|NumberOfShorts
operator|<<
literal|1
operator|)
expr_stmt|;
name|DeltaY
operator|=
operator|-
name|DeltaY
expr_stmt|;
block|}
endif|#
directive|endif
endif|(APA8 || APA8C)
comment|/* 	 * Get source and alternate tiles 	 */
name|Source
operator|=
operator|*
name|ConstantTiles
index|[
name|SrcPix
operator|&
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|Mode
operator|==
name|DrawPatternedLine
condition|)
name|AltSource
operator|=
operator|*
name|ConstantTiles
index|[
name|AltPix
operator|&
literal|1
index|]
expr_stmt|;
comment|/* 	 * Compute starting destination address 	 */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|APA8
argument_list|)
operator|||
name|defined
argument_list|(
name|APA8C
argument_list|)
operator|)
if|if
condition|(
name|BitMap
operator|==
name|SCREEN_BITMAP
condition|)
block|{
name|Destination
operator|=
operator|(
name|u_short
operator|*
operator|)
name|BitMap
operator|->
name|data
operator|+
operator|(
operator|(
name|StartX
operator|/
literal|16
operator|+
name|StartY
operator|*
name|NumberOfShorts
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|DestinationIncrement
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|Destination
operator|=
operator|(
name|u_short
operator|*
operator|)
name|BitMap
operator|->
name|data
operator|+
name|StartX
operator|/
literal|16
operator|+
name|StartY
operator|*
name|NumberOfShorts
expr_stmt|;
name|DestinationIncrement
operator|=
literal|2
expr_stmt|;
block|}
else|#
directive|else
name|Destination
operator|=
operator|(
name|u_short
operator|*
operator|)
name|BitMap
operator|->
name|data
operator|+
name|StartX
operator|/
literal|16
operator|+
name|StartY
operator|*
name|NumberOfShorts
expr_stmt|;
endif|#
directive|endif
endif|(APA8 || APA8C)
comment|/* 	 * set mask to select starting bit 	 */
name|MaskBit
operator|=
literal|0x8000
operator|>>
operator|(
name|StartX
operator|&
literal|0x0F
operator|)
expr_stmt|;
comment|/* 	 * If this is not a solid line setup pattern values 	 */
if|if
condition|(
name|Mode
operator|!=
name|DrawSolidLine
condition|)
block|{
name|RepeatCount
operator|=
name|PatternMultiplier
expr_stmt|;
name|PatternFirstBit
operator|=
literal|1
operator|<<
operator|(
name|PatternLength
operator|-
literal|1
operator|)
expr_stmt|;
name|PatternBit
operator|=
name|PatternFirstBit
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SOFTWARE_CURSOR
comment|/* 	 * Save cursor if blt is to screen 	 */
if|if
condition|(
name|BitMap
operator|==
name|SCREEN_BITMAP
condition|)
block|{
if|if
condition|(
name|save_cursor
argument_list|(
name|MIN
argument_list|(
name|StopX
argument_list|,
name|StartX
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|StopY
argument_list|,
name|StartY
argument_list|)
argument_list|,
name|MAX
argument_list|(
name|StopX
argument_list|,
name|StartX
argument_list|)
operator|+
literal|1
argument_list|,
name|MAX
argument_list|(
name|StopY
argument_list|,
name|StartY
argument_list|)
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DeviceError
argument_list|(
literal|"SinglePixelLine: ioctl QIOCHIDECUR failed.\n"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|SOFTWARE_CURSOR
comment|/* 	 * draw the line 	 */
if|if
condition|(
name|DeltaX
operator|>
name|DeltaY
condition|)
block|{
comment|/* This is a horizontal line */
name|Sentinel
operator|=
name|DeltaX
operator|>>
literal|1
expr_stmt|;
name|BitsLeftToDraw
operator|=
name|DeltaX
expr_stmt|;
switch|switch
condition|(
name|Rule
condition|)
block|{
case|case
operator|(
name|GXor
operator|)
case|:
name|HORIZONTAL_LINE
argument_list|(
argument|{*Destination |= (Source& MaskBit);}
argument_list|,
argument|{*Destination |= (AltSource& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXcopy
operator|)
case|:
name|HORIZONTAL_LINE
argument_list|(
argument|{*Destination = (*Destination& ~MaskBit) | 				(Source& MaskBit);}
argument_list|,
argument|{*Destination = (*Destination& ~MaskBit) | 				(AltSource& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXxor
operator|)
case|:
name|HORIZONTAL_LINE
argument_list|(
argument|{*Destination ^= (Source& MaskBit);}
argument_list|,
argument|{*Destination ^= (AltSource& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXset
operator|)
case|:
name|HORIZONTAL_LINE
argument_list|(
argument|{*Destination |= MaskBit;}
argument_list|,
argument|{*Destination |= MaskBit;}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXclear
operator|)
case|:
name|HORIZONTAL_LINE
argument_list|(
argument|{*Destination&= ~MaskBit;}
argument_list|,
argument|{*Destination&= ~MaskBit;}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXinvert
operator|)
case|:
name|HORIZONTAL_LINE
argument_list|(
argument|{*Destination ^= MaskBit;}
argument_list|,
argument|{*Destination ^= MaskBit;}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXcopyInverted
operator|)
case|:
name|HORIZONTAL_LINE
argument_list|(
argument|{*Destination = (*Destination& ~MaskBit) | 				(~Source& MaskBit);}
argument_list|,
argument|{*Destination = (*Destination& ~MaskBit) | 				(~AltSource& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXandInverted
operator|)
case|:
name|HORIZONTAL_LINE
argument_list|(
argument|{*Destination&= ~(Source& MaskBit);}
argument_list|,
argument|{*Destination&= ~(AltSource& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXorReverse
operator|)
case|:
name|HORIZONTAL_LINE
argument_list|(
argument|{*Destination = (*Destination& ~MaskBit) | 				((~*Destination | Source)& MaskBit);}
argument_list|,
argument|{*Destination = (*Destination& ~MaskBit) | 				((~*Destination | AltSource)& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXequiv
operator|)
case|:
name|HORIZONTAL_LINE
argument_list|(
argument|{*Destination = (*Destination& ~MaskBit) | 				((*Destination ^ ~Source)& MaskBit);}
argument_list|,
argument|{*Destination = (*Destination& ~MaskBit) | 				((*Destination ^ ~AltSource)& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXnand
operator|)
case|:
name|HORIZONTAL_LINE
argument_list|(
argument|{*Destination = (*Destination& ~MaskBit) | 				((~*Destination | ~Source)& MaskBit);}
argument_list|,
argument|{*Destination = (*Destination& ~MaskBit) | 				((~*Destination | ~AltSource)& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXnor
operator|)
case|:
name|HORIZONTAL_LINE
argument_list|(
argument|{*Destination = (*Destination& ~MaskBit) | 				((~*Destination& ~Source)& MaskBit);}
argument_list|,
argument|{*Destination = (*Destination& ~MaskBit) | 				((~*Destination& ~AltSource)& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXandReverse
operator|)
case|:
name|HORIZONTAL_LINE
argument_list|(
argument|{*Destination = (*Destination& ~MaskBit) | 				((~*Destination& Source)& MaskBit);}
argument_list|,
argument|{*Destination = (*Destination& ~MaskBit) | 				((~*Destination& AltSource)& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXand
operator|)
case|:
name|HORIZONTAL_LINE
argument_list|(
argument|{*Destination = (*Destination& ~MaskBit) | 				((*Destination& Source)& MaskBit);}
argument_list|,
argument|{*Destination = (*Destination& ~MaskBit) | 				((*Destination& AltSource)& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXorInverted
operator|)
case|:
name|HORIZONTAL_LINE
argument_list|(
argument|{*Destination = (*Destination& ~MaskBit) | 				((*Destination | ~Source)& MaskBit);}
argument_list|,
argument|{*Destination = (*Destination& ~MaskBit) | 				((*Destination | ~AltSource)& MaskBit);}
argument_list|)
empty_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is a vertical line */
name|Sentinel
operator|=
name|DeltaY
operator|>>
literal|1
expr_stmt|;
name|BitsLeftToDraw
operator|=
name|DeltaY
expr_stmt|;
switch|switch
condition|(
name|Rule
condition|)
block|{
case|case
operator|(
name|GXor
operator|)
case|:
name|VERTICAL_LINE
argument_list|(
argument|{*Destination |= (Source& MaskBit);}
argument_list|,
argument|{*Destination |= (AltSource& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXcopy
operator|)
case|:
name|VERTICAL_LINE
argument_list|(
argument|{*Destination = (*Destination& ~MaskBit) | 				(Source& MaskBit);}
argument_list|,
argument|{*Destination = (*Destination& ~MaskBit) | 				(AltSource& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXxor
operator|)
case|:
name|VERTICAL_LINE
argument_list|(
argument|{*Destination ^= (Source& MaskBit);}
argument_list|,
argument|{*Destination ^= (AltSource& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXset
operator|)
case|:
name|VERTICAL_LINE
argument_list|(
argument|{*Destination |= MaskBit;}
argument_list|,
argument|{*Destination |= MaskBit;}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXclear
operator|)
case|:
name|VERTICAL_LINE
argument_list|(
argument|{*Destination&= ~MaskBit;}
argument_list|,
argument|{*Destination&= ~MaskBit;}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXinvert
operator|)
case|:
name|VERTICAL_LINE
argument_list|(
argument|{*Destination ^= MaskBit;}
argument_list|,
argument|{*Destination ^= MaskBit;}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXcopyInverted
operator|)
case|:
name|VERTICAL_LINE
argument_list|(
argument|{*Destination = (*Destination& ~MaskBit) | 				(~Source& MaskBit);}
argument_list|,
argument|{*Destination = (*Destination& ~MaskBit) | 				(~AltSource& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXandInverted
operator|)
case|:
name|VERTICAL_LINE
argument_list|(
argument|{*Destination&= ~(Source& MaskBit);}
argument_list|,
argument|{*Destination&= ~(AltSource& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXorReverse
operator|)
case|:
name|VERTICAL_LINE
argument_list|(
argument|{*Destination = (*Destination& ~MaskBit) | 				((~*Destination | Source)& MaskBit);}
argument_list|,
argument|{*Destination = (*Destination& ~MaskBit) | 				((~*Destination | AltSource)& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXequiv
operator|)
case|:
name|VERTICAL_LINE
argument_list|(
argument|{*Destination = (*Destination& ~MaskBit) | 				((*Destination ^ ~Source)& MaskBit);}
argument_list|,
argument|{*Destination = (*Destination& ~MaskBit) | 				((*Destination ^ ~AltSource)& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXnand
operator|)
case|:
name|VERTICAL_LINE
argument_list|(
argument|{*Destination = (*Destination& ~MaskBit) | 				((~*Destination | ~Source)& MaskBit);}
argument_list|,
argument|{*Destination = (*Destination& ~MaskBit) | 				((~*Destination | ~AltSource)& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXnor
operator|)
case|:
name|VERTICAL_LINE
argument_list|(
argument|{*Destination = (*Destination& ~MaskBit) | 				((~*Destination& ~Source)& MaskBit);}
argument_list|,
argument|{*Destination = (*Destination& ~MaskBit) | 				((~*Destination& ~AltSource)& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXandReverse
operator|)
case|:
name|VERTICAL_LINE
argument_list|(
argument|{*Destination = (*Destination& ~MaskBit) | 				((~*Destination& Source)& MaskBit);}
argument_list|,
argument|{*Destination = (*Destination& ~MaskBit) | 				((~*Destination& AltSource)& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXand
operator|)
case|:
name|VERTICAL_LINE
argument_list|(
argument|{*Destination = (*Destination& ~MaskBit) | 				((*Destination& Source)& MaskBit);}
argument_list|,
argument|{*Destination = (*Destination& ~MaskBit) | 				((*Destination& AltSource)& MaskBit);}
argument_list|)
empty_stmt|;
break|break;
case|case
operator|(
name|GXorInverted
operator|)
case|:
name|VERTICAL_LINE
argument_list|(
argument|{*Destination = (*Destination& ~MaskBit) | 				((*Destination | ~Source)& MaskBit);}
argument_list|,
argument|{*Destination = (*Destination& ~MaskBit) | 				((*Destination | ~AltSource)& MaskBit);}
argument_list|)
empty_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SOFTWARE_CURSOR
comment|/* 	 * Restore cursor to screen 	 */
if|if
condition|(
name|BitMap
operator|==
name|SCREEN_BITMAP
condition|)
block|{
if|if
condition|(
name|restore_cursor
argument_list|()
operator|<
literal|0
condition|)
block|{
name|DeviceError
argument_list|(
literal|"SinglePixelLine: ioctl QIOCSHOWCUR failed.\n"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|SOFTWARE_CURSOR
ifdef|#
directive|ifdef
name|AED
comment|/* 	 * Unable to use microcode to draw the line. 	 * Therefore, it must be echoed to the 	 * AED screen to become visible. 	 */
if|if
condition|(
name|EchoLine
condition|)
block|{
name|changed_rect
operator|.
name|origin_y
operator|=
name|MIN
argument_list|(
name|StopY
argument_list|,
name|StartY
argument_list|)
expr_stmt|;
name|changed_rect
operator|.
name|origin_x
operator|=
name|MIN
argument_list|(
name|StopX
argument_list|,
name|StartX
argument_list|)
expr_stmt|;
name|changed_rect
operator|.
name|corner_y
operator|=
name|MAX
argument_list|(
name|StopY
argument_list|,
name|StartY
argument_list|)
operator|+
literal|1
expr_stmt|;
name|changed_rect
operator|.
name|corner_x
operator|=
name|MAX
argument_list|(
name|StopX
argument_list|,
name|StartX
argument_list|)
operator|+
literal|1
expr_stmt|;
name|aed_echo_rect
argument_list|(
operator|&
name|changed_rect
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|AED
block|}
end_block

end_unit

