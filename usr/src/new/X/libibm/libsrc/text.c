begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_text_c
init|=
literal|"$Header: text.c,v 10.1 86/11/19 10:44:22 jg Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/* Copyright 1985 Massachusetts Institute of Technology */
end_comment

begin_comment
comment|/* text.c - X text based functions  *  *      PrintText       Prints text with source font  *      PrintTextMask   Prints text with mask font  *      CopyText        Copy text to bitmap  *      TextWidth       Returns width of a piece of text in a font  *      CharWidth       Returns width of a character in a font  *	OffScreenText	Utility rtn to optimize text blts using   *			an offscreen buffer  *	CopyScreenBits	Utility rtn used to grab a rectangular area  *			of the screen and place it in an offscreen buffer.  *  *  	Authors:  *		Dan Stone& Scott Bates  *		Brown University  *		IRIS, Box 1946  *      	Providence, RI 02912  *  *  *		Copyright (c) 1986 Brown University  *  * Permission to use, copy, modify and distribute this software and its  * documentation for any purpose and without fee is hereby granted, provided  * that the above copyright notice appear in all copies, and that both  * that copyright notice and this permission notice appear in supporting  * documentation, and that the name of Brown University not be used in  * advertising or publicity pertaining to distribution of the software  * without specific, written prior permission. Brown University makes no  * representations about the suitability of this software for any purpose.  * It is provided "as-is" without express or implied warranty.  */
end_comment

begin_include
include|#
directive|include
file|"private.h"
end_include

begin_include
include|#
directive|include
file|"bitblt.h"
end_include

begin_include
include|#
directive|include
file|"text.h"
end_include

begin_comment
comment|/*  * Print text with font as source   */
end_comment

begin_expr_stmt
name|PrintText
argument_list|(
name|string
argument_list|,
name|strlen
argument_list|,
name|font
argument_list|,
name|fore
argument_list|,
name|back
argument_list|,
name|charpad
argument_list|,
name|spacepad
argument_list|,
name|dstx
argument_list|,
name|dsty
argument_list|,
name|clips
argument_list|,
name|clipcount
argument_list|,
name|func
argument_list|,
name|zmask
argument_list|)
specifier|register
name|char
operator|*
name|string
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FONT
modifier|*
name|font
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|strlen
operator|,
name|dstx
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|charpad
operator|,
name|spacepad
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fore
decl_stmt|,
name|back
decl_stmt|,
name|dsty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CLIP
modifier|*
name|clips
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|clipcount
decl_stmt|,
name|zmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|func
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FontPriv
modifier|*
name|fpriv
init|=
name|FDATA
argument_list|(
name|font
argument_list|)
decl_stmt|;
name|BITMAP
modifier|*
name|cbm
init|=
name|fpriv
operator|->
name|chrs
decl_stmt|;
specifier|register
name|c
expr_stmt|;
specifier|register
name|charwidth
expr_stmt|;
specifier|register
name|buf_wd
operator|,
name|buf_ht
expr_stmt|;
specifier|register
name|nchar
expr_stmt|;
specifier|register
name|srcOx
expr_stmt|;
name|int
name|srcCx
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE_X
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In PrintText\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRACE_X
comment|/* 	 * Limit text to one plane 	 */
if|if
condition|(
operator|(
name|zmask
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Change combination rule to reflect specified 	 * foreground and background colors 	 */
if|if
condition|(
name|fore
operator|&
literal|1
condition|)
name|func
operator|+=
literal|0x20
expr_stmt|;
if|if
condition|(
name|back
operator|&
literal|1
condition|)
name|func
operator|+=
literal|0x10
expr_stmt|;
name|func
operator|=
name|FBMap
index|[
name|func
index|]
expr_stmt|;
comment|/* 	 * While we have more than CH_THRESHOLD characters then we will put 	 * the text into an offscreen buffer then blow it up onto the screen. 	 * When it drops below this threshold then it is no longer efficient 	 * to go to an offscreen buffer and we will go directly to the screen 	 * with bitblt. 	 */
if|if
condition|(
name|fpriv
operator|->
name|offscr
operator|!=
name|NILBITMAP
condition|)
block|{
while|while
condition|(
name|strlen
operator|>
name|CH_THRESHOLD
condition|)
block|{
comment|/* 			 * Make sure that CopyScreenBits() stays on the screen. 			 * Note: We are assuming the destination bitmap and the 			 *	 screen bitmap are already zero based and we 			 *       are assuming that the txtbm is at least the 			 *       width of the screen.  			 */
if|if
condition|(
operator|(
name|buf_ht
operator|=
name|font
operator|->
name|height
operator|)
operator|>
operator|(
name|pbm
operator|.
name|height
operator|-
name|dsty
operator|)
condition|)
block|{
name|buf_ht
operator|=
name|pbm
operator|.
name|height
operator|-
name|dsty
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|buf_wd
operator|=
operator|(
operator|(
name|fpriv
operator|->
name|maxwidth
operator|+
name|charpad
operator|+
name|spacepad
operator|)
operator|*
name|strlen
operator|)
operator|)
operator|>
operator|(
name|pbm
operator|.
name|width
operator|-
name|dstx
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|buf_wd
operator|=
name|pbm
operator|.
name|width
operator|-
name|dstx
operator|)
operator|>
name|txtbm
operator|.
name|width
condition|)
block|{
name|buf_wd
operator|=
name|txtbm
operator|.
name|width
expr_stmt|;
block|}
block|}
comment|/* 			 * Make sure the sizes are non-zero. 			 */
if|if
condition|(
name|buf_ht
operator|<
literal|1
operator|||
name|buf_wd
operator|<
literal|1
condition|)
block|{
break|break;
block|}
comment|/* 			 * Bring area on the screen into the offscreen buffer. 			 */
name|CopyScreenBits
argument_list|(
name|dstx
argument_list|,
name|dsty
argument_list|,
name|buf_wd
argument_list|,
name|buf_ht
argument_list|,
operator|&
name|txtbm
argument_list|)
expr_stmt|;
comment|/* 			 * Blt as much text as one can into the offscreen 			 * buffer. NOTE: Because CopyScreenBits rounds over 			 * to a long word (4 bytes) boundary we must move 			 * the text over in the offscreen area by modulo 32. 			 * Also note that offscreen_text returns the source 			 * corner in srcCx. 			 */
name|srcOx
operator|=
name|dstx
operator|&
literal|0x1F
expr_stmt|;
if|if
condition|(
operator|(
name|nchar
operator|=
name|OffScreenText
argument_list|(
operator|&
name|txtbm
argument_list|,
name|font
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|,
name|charpad
argument_list|,
name|spacepad
argument_list|,
name|srcOx
argument_list|,
operator|&
name|srcCx
argument_list|,
name|func
argument_list|)
operator|)
operator|<
literal|1
condition|)
block|{
comment|/* 				 * Check nchar before going on and get out of 				 * the loop if its less than 1. 				 */
break|break;
block|}
comment|/* 			 * Move the string up and the char count down. 			 */
name|string
operator|+=
name|nchar
expr_stmt|;
name|strlen
operator|-=
name|nchar
expr_stmt|;
comment|/* 			 * Put the offscreen buffer back onto the screen using 			 * CopyBits(). 			 * 			 * Make source and destination rectangles. 			 */
name|FillInRect
argument_list|(
name|srcOx
argument_list|,
literal|0
argument_list|,
name|srcCx
operator|-
name|srcOx
argument_list|,
name|buf_ht
argument_list|,
operator|&
name|SrcRect
argument_list|)
expr_stmt|;
name|FillInRect
argument_list|(
name|dstx
argument_list|,
name|dsty
argument_list|,
operator|(
name|srcCx
operator|-
name|srcOx
operator|)
argument_list|,
name|buf_ht
argument_list|,
operator|&
name|DstRect
argument_list|)
expr_stmt|;
comment|/* 			 * Put the offscreen text buffer back onto the screen. 			 */
name|CopyBits
argument_list|(
operator|(
name|u_short
operator|*
operator|)
name|txtbm
operator|.
name|data
argument_list|,
name|txtbm
operator|.
name|width
argument_list|,
name|txtbm
operator|.
name|height
argument_list|,
operator|&
name|SrcRect
argument_list|,
operator|(
name|u_short
operator|*
operator|)
name|pbm
operator|.
name|data
argument_list|,
name|pbm
operator|.
name|width
argument_list|,
name|pbm
operator|.
name|height
argument_list|,
operator|&
name|DstRect
argument_list|,
name|NILMASK
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|GXcopy
argument_list|,
name|clipcount
argument_list|,
name|clips
argument_list|)
expr_stmt|;
comment|/* 			 * Adjust destination address (dstx) 			 */
name|dstx
operator|=
name|DstRect
operator|.
name|corner_x
operator|+
name|charpad
expr_stmt|;
block|}
block|}
comment|/* 	 * Now loop thru the string until we are finished..... 	 */
while|while
condition|(
operator|--
name|strlen
operator|>=
literal|0
condition|)
block|{
comment|/* 		 * Character we are working on 		 */
name|c
operator|=
call|(
name|int
call|)
argument_list|(
operator|*
name|string
operator|++
argument_list|)
expr_stmt|;
comment|/* 		 * Check for legal character. 		 */
if|if
condition|(
name|c
operator|<
name|font
operator|->
name|first
operator|||
name|c
operator|>
name|font
operator|->
name|last
condition|)
continue|continue;
comment|/* 		 * Get width of current character 		 */
if|if
condition|(
operator|(
name|charwidth
operator|=
name|fpriv
operator|->
name|widths
index|[
name|c
index|]
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Make source and destination rectangles 			 */
name|FillInRect
argument_list|(
literal|0
argument_list|,
name|font
operator|->
name|height
operator|*
operator|(
name|c
operator|-
name|font
operator|->
name|first
operator|)
argument_list|,
name|charwidth
argument_list|,
name|font
operator|->
name|height
argument_list|,
operator|&
name|SrcRect
argument_list|)
expr_stmt|;
name|FillInRect
argument_list|(
name|dstx
argument_list|,
name|dsty
argument_list|,
name|charwidth
argument_list|,
name|font
operator|->
name|height
argument_list|,
operator|&
name|DstRect
argument_list|)
expr_stmt|;
comment|/* 			 * Blt character to frame buffer 			 */
name|CopyBits
argument_list|(
operator|(
name|u_short
operator|*
operator|)
name|cbm
operator|->
name|data
argument_list|,
name|cbm
operator|->
name|width
argument_list|,
name|cbm
operator|->
name|height
argument_list|,
operator|&
name|SrcRect
argument_list|,
operator|(
name|u_short
operator|*
operator|)
name|pbm
operator|.
name|data
argument_list|,
name|pbm
operator|.
name|width
argument_list|,
name|pbm
operator|.
name|height
argument_list|,
operator|&
name|DstRect
argument_list|,
name|NILMASK
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|func
argument_list|,
name|clipcount
argument_list|,
name|clips
argument_list|)
expr_stmt|;
comment|/* 			 * Adjust destination address (dstx) 			 */
name|dstx
operator|+=
name|charwidth
operator|+
name|charpad
expr_stmt|;
block|}
comment|/* 		 * Adjust destination address by size of space character 		 */
if|if
condition|(
name|c
operator|==
name|font
operator|->
name|space
condition|)
name|dstx
operator|+=
name|spacepad
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Print text with font as mask  */
end_comment

begin_expr_stmt
name|PrintTextMask
argument_list|(
name|string
argument_list|,
name|strlen
argument_list|,
name|font
argument_list|,
name|srcpix
argument_list|,
name|charpad
argument_list|,
name|spacepad
argument_list|,
name|dstx
argument_list|,
name|dsty
argument_list|,
name|clips
argument_list|,
name|clipcount
argument_list|,
name|func
argument_list|,
name|zmask
argument_list|)
specifier|register
name|char
operator|*
name|string
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FONT
modifier|*
name|font
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|strlen
operator|,
name|charpad
operator|,
name|spacepad
operator|,
name|dstx
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|srcpix
decl_stmt|,
name|dsty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CLIP
modifier|*
name|clips
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|clipcount
decl_stmt|,
name|zmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|func
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FontPriv
modifier|*
name|fpriv
init|=
name|FDATA
argument_list|(
name|font
argument_list|)
decl_stmt|;
name|int
name|charsize
init|=
name|BitmapSize
argument_list|(
name|fpriv
operator|->
name|maxwidth
argument_list|,
name|font
operator|->
name|height
argument_list|)
decl_stmt|;
name|u_short
modifier|*
name|charmask
decl_stmt|;
specifier|register
name|charwidth
expr_stmt|;
specifier|register
name|c
expr_stmt|;
specifier|register
name|srcOx
expr_stmt|;
specifier|register
name|nchar
expr_stmt|;
name|int
name|srcCx
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE_X
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In PrintTextMask\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRACE_X
comment|/* 	 * Limit text to one plane 	 */
if|if
condition|(
operator|(
name|zmask
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * While we have more than CH_THRESHOLD characters then we will put 	 * the text into an offscreen buffer then blow it up onto the screen. 	 * When it drops below this threshold then it is no longer efficient 	 * to go to an offscreen buffer and we will go directly to the screen 	 * with bitblt. 	 */
if|if
condition|(
name|fpriv
operator|->
name|offscr
operator|!=
name|NILBITMAP
condition|)
block|{
while|while
condition|(
name|strlen
operator|>
name|CH_THRESHOLD
condition|)
block|{
comment|/* 			 * Clear the offscreen buffer area. 			 */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|txtbm
operator|.
name|data
argument_list|,
operator|(
name|font
operator|->
name|height
operator|*
operator|(
operator|(
name|txtbm
operator|.
name|width
operator|+
literal|15
operator|)
operator|/
literal|16
operator|)
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * Blt as much text as one can into the offscreen 			 * buffer.  Note that offscreen_text returns the source 			 * corner in srcCx. 			 */
name|srcOx
operator|=
name|dstx
operator|&
literal|0xF
expr_stmt|;
if|if
condition|(
operator|(
name|nchar
operator|=
name|OffScreenText
argument_list|(
operator|&
name|txtbm
argument_list|,
name|font
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|,
name|charpad
argument_list|,
name|spacepad
argument_list|,
name|srcOx
argument_list|,
operator|&
name|srcCx
argument_list|,
name|GXcopy
argument_list|)
operator|)
operator|<
literal|1
condition|)
block|{
comment|/* 				 * Check nchar before going on and get out of 				 * the loop if its less than 1. 				 */
break|break;
block|}
comment|/* 			 * Move the string up and the char count down. 			 */
name|string
operator|+=
name|nchar
expr_stmt|;
name|strlen
operator|-=
name|nchar
expr_stmt|;
comment|/* 			 * Put the offscreen buffer back onto the screen using 			 * CopyBits(). 			 * 			 * Make source and destination rectangles. 			 */
name|FillInRect
argument_list|(
operator|(
name|dstx
operator|-
name|srcOx
operator|)
argument_list|,
name|dsty
argument_list|,
name|srcCx
argument_list|,
name|font
operator|->
name|height
argument_list|,
operator|&
name|DstRect
argument_list|)
expr_stmt|;
comment|/* 			 * Using the offscreen bitmap as a mask, copy 			 * the text to the screen. 			 */
name|CopyBits
argument_list|(
operator|(
name|u_short
operator|*
operator|)
name|ConstantTiles
index|[
name|srcpix
operator|&
literal|1
index|]
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|NILRECT
argument_list|,
operator|(
name|u_short
operator|*
operator|)
name|pbm
operator|.
name|data
argument_list|,
name|pbm
operator|.
name|width
argument_list|,
name|pbm
operator|.
name|height
argument_list|,
operator|&
name|DstRect
argument_list|,
operator|(
name|u_short
operator|*
operator|)
name|txtbm
operator|.
name|data
argument_list|,
name|txtbm
operator|.
name|width
argument_list|,
name|font
operator|->
name|height
argument_list|,
name|MAKE_TILE_RULE
argument_list|(
name|func
argument_list|)
argument_list|,
name|clipcount
argument_list|,
name|clips
argument_list|)
expr_stmt|;
comment|/* 			 * Adjust destination address (dstx) 			 */
name|dstx
operator|=
name|DstRect
operator|.
name|corner_x
operator|+
name|charwidth
operator|+
name|charpad
expr_stmt|;
block|}
block|}
comment|/* 	 * Now loop thru the string until we are finished..... 	 */
while|while
condition|(
operator|--
name|strlen
operator|>=
literal|0
condition|)
block|{
comment|/* 		 * Character we are working on 		 */
name|c
operator|=
call|(
name|int
call|)
argument_list|(
operator|*
name|string
operator|++
argument_list|)
expr_stmt|;
comment|/* 		 * Check for legal character. 		 */
if|if
condition|(
name|c
operator|<
name|font
operator|->
name|first
operator|||
name|c
operator|>
name|font
operator|->
name|last
condition|)
continue|continue;
comment|/* 		 * Get width of current character 		 */
if|if
condition|(
operator|(
name|charwidth
operator|=
name|fpriv
operator|->
name|widths
index|[
name|c
index|]
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Use character as clipping mask 			 */
name|charmask
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|fpriv
operator|->
name|chrs
operator|->
name|data
operator|+
name|charsize
operator|*
operator|(
name|c
operator|-
name|font
operator|->
name|first
operator|)
operator|)
expr_stmt|;
comment|/* 			 * Fill in destination rectangle 			 */
name|FillInRect
argument_list|(
name|dstx
argument_list|,
name|dsty
argument_list|,
name|charwidth
argument_list|,
name|font
operator|->
name|height
argument_list|,
operator|&
name|DstRect
argument_list|)
expr_stmt|;
comment|/* 			 * Blt character to frame buffer using font 			 * character as mask 			 */
name|CopyBits
argument_list|(
operator|(
name|u_short
operator|*
operator|)
name|ConstantTiles
index|[
name|srcpix
operator|&
literal|1
index|]
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|NILRECT
argument_list|,
operator|(
name|u_short
operator|*
operator|)
name|pbm
operator|.
name|data
argument_list|,
name|pbm
operator|.
name|width
argument_list|,
name|pbm
operator|.
name|height
argument_list|,
operator|&
name|DstRect
argument_list|,
name|charmask
argument_list|,
name|charwidth
argument_list|,
name|font
operator|->
name|height
argument_list|,
name|MAKE_TILE_RULE
argument_list|(
name|func
argument_list|)
argument_list|,
name|clipcount
argument_list|,
name|clips
argument_list|)
expr_stmt|;
comment|/* 			 * Adjust destination address (dstx) by character 			 * pad amount 			 */
name|dstx
operator|+=
name|charwidth
operator|+
name|charpad
expr_stmt|;
block|}
comment|/* 		 * Adjust destination address by size of space character 		 */
if|if
condition|(
name|c
operator|==
name|font
operator|->
name|space
condition|)
name|dstx
operator|+=
name|spacepad
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Copy text to bitmap  */
end_comment

begin_expr_stmt
name|CopyText
argument_list|(
name|string
argument_list|,
name|strlen
argument_list|,
name|font
argument_list|,
name|bm
argument_list|)
specifier|register
name|char
operator|*
name|string
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|strlen
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FONT
modifier|*
name|font
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BITMAP
modifier|*
name|bm
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FontPriv
modifier|*
name|fpriv
init|=
name|FDATA
argument_list|(
name|font
argument_list|)
decl_stmt|;
name|BITMAP
modifier|*
name|cbm
init|=
name|fpriv
operator|->
name|chrs
decl_stmt|;
specifier|register
name|c
expr_stmt|;
specifier|register
name|charwidth
expr_stmt|;
specifier|register
name|dstx
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE_X
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In CopyText\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRACE_X
comment|/* 	 * loop thru string until we are finished..... 	 */
while|while
condition|(
operator|--
name|strlen
operator|>=
literal|0
condition|)
block|{
comment|/* 		 * Character we are working on 		 */
name|c
operator|=
call|(
name|int
call|)
argument_list|(
operator|*
name|string
operator|++
argument_list|)
expr_stmt|;
comment|/* 		 * Check for legal character. 		 */
if|if
condition|(
name|c
operator|<
name|font
operator|->
name|first
operator|||
name|c
operator|>
name|font
operator|->
name|last
condition|)
continue|continue;
comment|/* 		 * Get width of current character 		 */
if|if
condition|(
operator|(
name|charwidth
operator|=
name|fpriv
operator|->
name|widths
index|[
name|c
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Fill in source and destination rectangles 		 */
name|FillInRect
argument_list|(
literal|0
argument_list|,
name|font
operator|->
name|height
operator|*
operator|(
name|c
operator|-
name|font
operator|->
name|first
operator|)
argument_list|,
name|charwidth
argument_list|,
name|font
operator|->
name|height
argument_list|,
operator|&
name|SrcRect
argument_list|)
expr_stmt|;
name|FillInRect
argument_list|(
name|dstx
argument_list|,
literal|0
argument_list|,
name|charwidth
argument_list|,
name|font
operator|->
name|height
argument_list|,
operator|&
name|DstRect
argument_list|)
expr_stmt|;
comment|/* 		 * Blt character to bitmap 		 */
name|CopyBits
argument_list|(
operator|(
name|u_short
operator|*
operator|)
name|cbm
operator|->
name|data
argument_list|,
name|cbm
operator|->
name|width
argument_list|,
name|cbm
operator|->
name|height
argument_list|,
operator|&
name|SrcRect
argument_list|,
operator|(
name|u_short
operator|*
operator|)
name|bm
operator|->
name|data
argument_list|,
name|bm
operator|->
name|width
argument_list|,
name|bm
operator|->
name|height
argument_list|,
operator|&
name|DstRect
argument_list|,
name|NILMASK
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|GXcopy
argument_list|,
literal|0
argument_list|,
name|NILCLIP
argument_list|)
expr_stmt|;
comment|/* 		 * Adjust destination address (dstx) 		 */
name|dstx
operator|+=
name|charwidth
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Compute width of a piece of text in a font  */
end_comment

begin_function
name|int
name|TextWidth
parameter_list|(
name|string
parameter_list|,
name|strlen
parameter_list|,
name|spacepad
parameter_list|,
name|font
parameter_list|)
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
specifier|register
name|int
name|strlen
decl_stmt|;
name|int
name|spacepad
decl_stmt|;
specifier|register
name|FONT
modifier|*
name|font
decl_stmt|;
block|{
specifier|register
name|u_int
name|c
decl_stmt|;
specifier|register
name|short
modifier|*
name|widths
decl_stmt|;
specifier|register
name|int
name|width
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE_X
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In TextWidth\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRACE_X
if|if
condition|(
name|font
operator|->
name|fixed
condition|)
block|{
comment|/* 		 * Font is fixed width 		 */
comment|/* 		 * Compute total width of text string 		 */
name|width
operator|=
name|strlen
operator|*
name|font
operator|->
name|avg_width
expr_stmt|;
if|if
condition|(
name|spacepad
condition|)
block|{
comment|/* 			 * Add spacepad amount to the total width for each 			 * space character found in text string 			 */
while|while
condition|(
operator|--
name|strlen
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|string
operator|++
operator|==
name|font
operator|->
name|space
condition|)
name|width
operator|+=
name|spacepad
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * Font is variable width 		 */
comment|/* 		 * get pointer to width table 		 */
name|widths
operator|=
name|FDATA
argument_list|(
name|font
argument_list|)
operator|->
name|widths
expr_stmt|;
comment|/* 		 * Loop thru text string 		 */
while|while
condition|(
operator|--
name|strlen
operator|>=
literal|0
condition|)
block|{
comment|/* 			 * Get current character 			 */
name|c
operator|=
operator|*
name|string
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
name|font
operator|->
name|first
operator|&&
name|c
operator|<=
name|font
operator|->
name|last
condition|)
block|{
comment|/* 				 * Valid character 				 */
if|if
condition|(
name|c
operator|==
name|font
operator|->
name|space
condition|)
block|{
comment|/* 					 * Character is a space so add 					 * spacepad amount to total width 					 */
name|width
operator|+=
name|spacepad
expr_stmt|;
block|}
comment|/* 				 * Find width of this character in width 				 * table and add it to total 				 */
name|width
operator|+=
name|widths
index|[
name|c
index|]
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|width
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine width of a character in a font  */
end_comment

begin_function
name|int
name|CharWidth
parameter_list|(
name|c
parameter_list|,
name|font
parameter_list|)
specifier|register
name|u_int
name|c
decl_stmt|;
specifier|register
name|FONT
modifier|*
name|font
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TRACE_X
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In CharWidth\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRACE_X
if|if
condition|(
name|c
operator|<
name|font
operator|->
name|first
operator|||
name|c
operator|>
name|font
operator|->
name|last
condition|)
comment|/* 		 * Character not in font  		 */
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|font
operator|->
name|fixed
condition|)
comment|/* 		 * Font is a fixed width so return the 		 * average character width for the font 		 */
return|return
operator|(
name|font
operator|->
name|avg_width
operator|)
return|;
else|else
comment|/* 		 * Font is variable width so determine 		 * width  of character from font width table 		 */
return|return
operator|(
name|FDATA
argument_list|(
name|font
argument_list|)
operator|->
name|widths
index|[
name|c
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * OffScreenText puts text from "font" into "buf_bm".  It assumes the font  * bitmap * has its characters "left justified".  It returns the rightmost  * X position in "cornerX".  */
end_comment

begin_expr_stmt
specifier|static
name|OffScreenText
argument_list|(
argument|buf_bm
argument_list|,
argument|font
argument_list|,
argument|string
argument_list|,
argument|ch_count
argument_list|,
argument|ch_pad
argument_list|,
argument|sp_pad
argument_list|,
argument|dstX
argument_list|,
argument|cornerX
argument_list|,
argument|func
argument_list|)
name|BITMAP
operator|*
name|buf_bm
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Offscreen buffer bitmap */
end_comment

begin_decl_stmt
name|FONT
modifier|*
name|font
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Font structure */
end_comment

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String of characters to be put up. */
end_comment

begin_decl_stmt
name|int
name|ch_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of characters in the string */
end_comment

begin_decl_stmt
name|int
name|ch_pad
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Space between characters */
end_comment

begin_decl_stmt
name|int
name|sp_pad
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Amount of space a pad character is. */
end_comment

begin_decl_stmt
name|int
name|dstX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The spot in the offscreen buffer where 			   	   the text is to start. */
end_comment

begin_decl_stmt
name|int
modifier|*
name|cornerX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Send the rightmost X position back to the 				   caller for use with the bltter. */
end_comment

begin_decl_stmt
name|int
name|func
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function (or combination rule) to be used 				   with text */
end_comment

begin_block
block|{
specifier|register
name|u_char
modifier|*
name|dst
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|src
decl_stmt|;
specifier|register
name|u_long
name|src_nextline
decl_stmt|,
name|dst_nextline
decl_stmt|;
specifier|register
name|int
name|height
decl_stmt|;
specifier|register
name|u_short
name|leftmask
decl_stmt|,
name|rtmask
decl_stmt|;
name|int
name|c
decl_stmt|,
name|shift
decl_stmt|,
name|ndst_shorts
decl_stmt|,
name|inv_shift
decl_stmt|,
name|i
decl_stmt|,
name|start_dst
decl_stmt|;
name|int
name|dst_nextcol
decl_stmt|,
name|src_nextcol
decl_stmt|,
name|nsrc_shorts
decl_stmt|,
name|ht_plus1
decl_stmt|;
name|short
name|chrs_nshorts
decl_stmt|,
name|buf_nshorts
decl_stmt|;
name|u_long
name|bitptr
decl_stmt|;
name|long
name|maxbitptr
decl_stmt|;
name|int
name|shorts_per_char
decl_stmt|;
name|u_char
modifier|*
name|chrs_data
decl_stmt|;
name|FontPriv
modifier|*
name|fpriv
init|=
name|FDATA
argument_list|(
name|font
argument_list|)
decl_stmt|;
name|short
modifier|*
name|char_widths
init|=
name|fpriv
operator|->
name|widths
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE_X
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In OffScreenText\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRACE_X
comment|/* 	 * Calculate, in shorts, the width of both the chrs and 	 * buffer bitmaps. 	 */
name|chrs_nshorts
operator|=
name|BTOW
argument_list|(
name|fpriv
operator|->
name|maxwidth
argument_list|)
expr_stmt|;
name|maxbitptr
operator|=
name|fpriv
operator|->
name|offscr
operator|->
name|width
expr_stmt|;
name|buf_nshorts
operator|=
name|BTOW
argument_list|(
name|maxbitptr
argument_list|)
expr_stmt|;
comment|/* 	 * Set up to go through the string of characters. 	 */
name|bitptr
operator|=
name|dstX
expr_stmt|;
name|src_nextline
operator|=
name|MUL_2
argument_list|(
name|chrs_nshorts
argument_list|)
expr_stmt|;
name|dst_nextline
operator|=
name|MUL_2
argument_list|(
name|buf_nshorts
argument_list|)
expr_stmt|;
comment|/* 	 * Setup for text blt 	 */
name|ht_plus1
operator|=
name|font
operator|->
name|height
operator|+
literal|1
expr_stmt|;
name|shorts_per_char
operator|=
name|MUL_2
argument_list|(
name|chrs_nshorts
operator|*
name|font
operator|->
name|height
argument_list|)
expr_stmt|;
name|chrs_data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|fpriv
operator|->
name|chrs
operator|->
name|data
expr_stmt|;
comment|/* 	 * Blt text string into offscreen buffer 	 */
switch|switch
condition|(
name|func
condition|)
block|{
case|case
operator|(
name|GXclear
operator|)
case|:
name|CopyText_LOOP
argument_list|(
name|GXclear_MASK
argument_list|,
name|GXclear_OP
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|GXand
operator|)
case|:
name|CopyText_LOOP
argument_list|(
name|GXand_MASK
argument_list|,
name|GXand_OP
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|GXandReverse
operator|)
case|:
name|CopyText_LOOP
argument_list|(
name|GXandReverse_MASK
argument_list|,
name|GXandReverse_OP
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|GXcopy
operator|)
case|:
name|CopyText_LOOP
argument_list|(
name|GXcopy_MASK
argument_list|,
name|GXcopy_OP
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|GXandInverted
operator|)
case|:
name|CopyText_LOOP
argument_list|(
name|GXandInverted_MASK
argument_list|,
name|GXandInverted_OP
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|GXnoop
operator|)
case|:
break|break;
case|case
operator|(
name|GXxor
operator|)
case|:
name|CopyText_LOOP
argument_list|(
name|GXxor_MASK
argument_list|,
name|GXxor_OP
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|GXor
operator|)
case|:
name|CopyText_LOOP
argument_list|(
name|GXor_MASK
argument_list|,
name|GXor_OP
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|GXnor
operator|)
case|:
name|CopyText_LOOP
argument_list|(
name|GXnor_MASK
argument_list|,
name|GXnor_OP
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|GXequiv
operator|)
case|:
name|CopyText_LOOP
argument_list|(
name|GXequiv_MASK
argument_list|,
name|GXequiv_OP
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|GXinvert
operator|)
case|:
name|CopyText_LOOP
argument_list|(
name|GXinvert_MASK
argument_list|,
name|GXinvert_OP
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|GXorReverse
operator|)
case|:
name|CopyText_LOOP
argument_list|(
name|GXorReverse_MASK
argument_list|,
name|GXorReverse_OP
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|GXcopyInverted
operator|)
case|:
name|CopyText_LOOP
argument_list|(
name|GXcopyInverted_MASK
argument_list|,
name|GXcopyInverted_OP
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|GXorInverted
operator|)
case|:
name|CopyText_LOOP
argument_list|(
name|GXorInverted_MASK
argument_list|,
name|GXorInverted_OP
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|GXnand
operator|)
case|:
name|CopyText_LOOP
argument_list|(
name|GXnand_MASK
argument_list|,
name|GXnand_OP
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|GXset
operator|)
case|:
name|CopyText_LOOP
argument_list|(
name|GXset_MASK
argument_list|,
name|GXset_OP
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Remove the last charcter pad added to the last character. 	 */
name|bitptr
operator|-=
name|ch_pad
expr_stmt|;
comment|/* 	 * Return right most X value and character count to caller 	 */
if|if
condition|(
name|bitptr
operator|>
name|dstX
condition|)
operator|*
name|cornerX
operator|=
name|bitptr
expr_stmt|;
else|else
operator|*
name|cornerX
operator|=
name|dstX
expr_stmt|;
return|return
operator|(
name|ch_count
operator|)
return|;
block|}
end_block

begin_if
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
end_if

begin_define
define|#
directive|define
name|DSTBITS
value|((u_short *)DstBits)
end_define

begin_define
define|#
directive|define
name|SRCBITS
value|((u_short *)SrcBits)
end_define

begin_define
define|#
directive|define
name|SIZE_OF_SHORT
value|(sizeof(u_short))
end_define

begin_define
define|#
directive|define
name|SIZE_OF_APA8_SHORT
value|(sizeof(u_short) * 2)
end_define

begin_comment
comment|/*  * Copy shorts off of the screen (pbm) into the destination bitmap.  */
end_comment

begin_expr_stmt
specifier|static
name|CopyScreenBits
argument_list|(
argument|StartX
argument_list|,
argument|StartY
argument_list|,
argument|Width
argument_list|,
argument|Height
argument_list|,
argument|DstBitmap
argument_list|)
name|int
name|StartX
operator|,
name|StartY
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Width
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|Height
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|BITMAP
modifier|*
name|DstBitmap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|nwords
expr_stmt|;
specifier|register
name|char
modifier|*
name|DstBits
decl_stmt|;
specifier|register
name|DstRowBytes
expr_stmt|;
specifier|register
name|SrcRowBytes
expr_stmt|;
specifier|register
name|char
modifier|*
name|SrcBits
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE_X
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In CopyScreenBits\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRACE_X
comment|/* 	 * Check StartX and StartY and offset the destination pointer if 	 * one or both are negative and change the source pointer. 	 */
if|if
condition|(
name|StartX
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Make sure there are words to be taken off the screen. 		 */
if|if
condition|(
operator|(
name|nwords
operator|=
name|BTOW
argument_list|(
name|StartX
operator|+
name|Width
argument_list|)
operator|)
operator|<
literal|1
condition|)
block|{
return|return;
block|}
name|DstRowBytes
operator|=
name|MUL_2
argument_list|(
name|DIV_BPW
argument_list|(
name|DstBitmap
operator|->
name|width
argument_list|)
operator|-
name|nwords
argument_list|)
expr_stmt|;
name|SrcRowBytes
operator|=
name|MUL_4
argument_list|(
name|DIV_BPW
argument_list|(
name|pbm
operator|.
name|width
argument_list|)
argument_list|)
expr_stmt|;
name|DstBits
operator|=
operator|(
name|char
operator|*
operator|)
name|DstBitmap
operator|->
name|data
operator|+
name|MUL_2
argument_list|(
name|DIV_BPW
argument_list|(
operator|-
name|StartX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|StartY
operator|<
literal|0
condition|)
block|{
comment|/* 			 * Figure out the number of scanlines to be copied. 			 */
if|if
condition|(
operator|(
name|Height
operator|+=
name|StartY
operator|)
operator|<
literal|1
condition|)
block|{
return|return;
block|}
name|DstBits
operator|+=
operator|(
operator|-
name|StartY
operator|*
operator|(
name|DstBitmap
operator|->
name|width
operator|>>
literal|3
operator|)
operator|)
expr_stmt|;
name|SrcBits
operator|=
operator|(
name|char
operator|*
operator|)
name|pbm
operator|.
name|data
expr_stmt|;
block|}
else|else
block|{
name|SrcBits
operator|=
operator|(
name|char
operator|*
operator|)
name|pbm
operator|.
name|data
operator|+
operator|(
name|StartY
operator|*
name|SrcRowBytes
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Make sure there are words to be taken off the screen. 		 */
if|if
condition|(
operator|(
name|nwords
operator|=
name|BTOW
argument_list|(
name|StartX
operator|+
name|Width
argument_list|)
operator|-
name|DIV_BPW
argument_list|(
name|StartX
argument_list|)
operator|)
operator|<
literal|1
condition|)
block|{
return|return;
block|}
name|DstRowBytes
operator|=
name|MUL_2
argument_list|(
name|DIV_BPW
argument_list|(
name|DstBitmap
operator|->
name|width
argument_list|)
operator|-
name|nwords
argument_list|)
expr_stmt|;
name|SrcRowBytes
operator|=
name|MUL_4
argument_list|(
name|DIV_BPW
argument_list|(
name|pbm
operator|.
name|width
argument_list|)
argument_list|)
expr_stmt|;
name|DstBits
operator|=
operator|(
name|char
operator|*
operator|)
name|DstBitmap
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|StartY
operator|<
literal|0
condition|)
block|{
comment|/* 			 * Figure out the number of scanlines to be copied. 			 */
if|if
condition|(
operator|(
name|Height
operator|+=
name|StartY
operator|)
operator|<
literal|1
condition|)
block|{
return|return;
block|}
name|DstBits
operator|+=
operator|(
operator|-
name|StartY
operator|*
operator|(
name|DstBitmap
operator|->
name|width
operator|>>
literal|3
operator|)
operator|)
expr_stmt|;
name|SrcBits
operator|=
operator|(
name|char
operator|*
operator|)
name|pbm
operator|.
name|data
operator|+
name|MUL_4
argument_list|(
name|DIV_BPW
argument_list|(
name|StartX
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SrcBits
operator|=
operator|(
name|char
operator|*
operator|)
name|pbm
operator|.
name|data
operator|+
operator|(
name|StartY
operator|*
name|SrcRowBytes
operator|)
operator|+
name|MUL_4
argument_list|(
name|BTOW
argument_list|(
name|StartX
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nwords
operator|>
literal|1
condition|)
block|{
comment|/* more than one short wide */
name|int
name|tmpnWords
init|=
name|nwords
decl_stmt|;
name|SrcRowBytes
operator|-=
name|MUL_4
argument_list|(
name|nwords
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
do|do
block|{
operator|*
name|DSTBITS
operator|=
operator|*
name|SRCBITS
expr_stmt|;
name|DstBits
operator|+=
name|SIZE_OF_SHORT
expr_stmt|;
name|SrcBits
operator|+=
name|SIZE_OF_APA8_SHORT
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|nwords
operator|>
literal|0
condition|)
do|;
if|if
condition|(
operator|--
name|Height
condition|)
block|{
name|DstBits
operator|+=
name|DstRowBytes
expr_stmt|;
name|SrcBits
operator|+=
name|SrcRowBytes
expr_stmt|;
name|nwords
operator|=
name|tmpnWords
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* one short wide */
comment|/* 		 * Should not have subtracted (nwords<< 2) from 		 * DstRowBytes.  So now that we know nwords == 1 we will 		 * add (nwords<< 2) == 4 back to DstRowBytes. 		 */
name|DstRowBytes
operator|+=
literal|4
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
operator|*
name|DSTBITS
operator|=
operator|*
name|SRCBITS
expr_stmt|;
if|if
condition|(
operator|--
name|Height
condition|)
block|{
name|DstBits
operator|+=
name|DstRowBytes
expr_stmt|;
name|SrcBits
operator|+=
name|SrcRowBytes
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DSTBITS
value|((u_long *)DstBits)
end_define

begin_define
define|#
directive|define
name|SRCBITS
value|((u_long *)SrcBits)
end_define

begin_define
define|#
directive|define
name|SIZE_OF_LONG
value|sizeof(u_long)
end_define

begin_comment
comment|/*  * Copy long words off of the screen (pbm) into the destination bitmap.  */
end_comment

begin_expr_stmt
specifier|static
name|CopyScreenBits
argument_list|(
argument|StartX
argument_list|,
argument|StartY
argument_list|,
argument|Width
argument_list|,
argument|Height
argument_list|,
argument|DstBitmap
argument_list|)
name|int
name|StartX
operator|,
name|StartY
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Width
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|Height
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|BITMAP
modifier|*
name|DstBitmap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|nwords
expr_stmt|;
specifier|register
name|char
modifier|*
name|DstBits
decl_stmt|;
specifier|register
name|DstRowBytes
expr_stmt|;
specifier|register
name|SrcRowBytes
expr_stmt|;
specifier|register
name|char
modifier|*
name|SrcBits
decl_stmt|;
if|#
directive|if
operator|(
name|APA16
operator|&&
name|USE_APA16_HDWR
operator|)
name|int
name|tmp
decl_stmt|;
endif|#
directive|endif
endif|(APA16&& USE_APA16_HDWR)
ifdef|#
directive|ifdef
name|TRACE_X
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In CopyScreenBits\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TRACE_X
comment|/* 	 * Check StartX and StartY and offset the destination pointer if 	 * one or both are negative and change the source pointer. 	 */
if|if
condition|(
name|StartX
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Make sure there are words to be taken off the screen. 		 */
if|if
condition|(
operator|(
name|nwords
operator|=
name|BTOL
argument_list|(
name|StartX
operator|+
name|Width
argument_list|)
operator|)
operator|<
literal|1
condition|)
block|{
return|return;
block|}
comment|/* 		 * DstRowBytes and SrcRowBytes are MUL_4'ed so that 		 * they are the number of BYTES the address must be incremented. 		 */
name|DstRowBytes
operator|=
name|MUL_4
argument_list|(
name|DIV_BPL
argument_list|(
name|DstBitmap
operator|->
name|width
argument_list|)
operator|-
name|nwords
argument_list|)
expr_stmt|;
name|SrcRowBytes
operator|=
name|MUL_4
argument_list|(
name|DIV_BPL
argument_list|(
name|pbm
operator|.
name|width
argument_list|)
argument_list|)
expr_stmt|;
name|DstBits
operator|=
operator|(
name|char
operator|*
operator|)
name|DstBitmap
operator|->
name|data
operator|+
name|MUL_4
argument_list|(
name|DIV_BPL
argument_list|(
operator|-
name|StartX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|StartY
operator|<
literal|0
condition|)
block|{
comment|/* 			 * Figure out the number of scanlines to be copied. 			 */
if|if
condition|(
operator|(
name|Height
operator|+=
name|StartY
operator|)
operator|<
literal|1
condition|)
block|{
return|return;
block|}
name|DstBits
operator|+=
operator|(
operator|-
name|StartY
operator|*
operator|(
name|DstBitmap
operator|->
name|width
operator|>>
literal|3
operator|)
operator|)
expr_stmt|;
name|SrcBits
operator|=
operator|(
name|char
operator|*
operator|)
name|pbm
operator|.
name|data
expr_stmt|;
block|}
else|else
block|{
name|SrcBits
operator|=
operator|(
name|char
operator|*
operator|)
name|pbm
operator|.
name|data
operator|+
operator|(
name|StartY
operator|*
name|SrcRowBytes
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Make sure there are words to be taken off the screen. 		 */
if|if
condition|(
operator|(
name|nwords
operator|=
name|BTOL
argument_list|(
name|StartX
operator|+
name|Width
argument_list|)
operator|-
name|DIV_BPL
argument_list|(
name|StartX
argument_list|)
operator|)
operator|<
literal|1
condition|)
block|{
return|return;
block|}
name|DstRowBytes
operator|=
name|MUL_4
argument_list|(
name|DIV_BPL
argument_list|(
name|DstBitmap
operator|->
name|width
argument_list|)
operator|-
name|nwords
argument_list|)
expr_stmt|;
name|SrcRowBytes
operator|=
name|MUL_4
argument_list|(
name|DIV_BPL
argument_list|(
name|pbm
operator|.
name|width
argument_list|)
argument_list|)
expr_stmt|;
name|DstBits
operator|=
operator|(
name|char
operator|*
operator|)
name|DstBitmap
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|StartY
operator|<
literal|0
condition|)
block|{
comment|/* 			 * Figure out the number of scanlines to be copied. 			 */
if|if
condition|(
operator|(
name|Height
operator|+=
name|StartY
operator|)
operator|<
literal|1
condition|)
block|{
return|return;
block|}
name|DstBits
operator|+=
operator|(
operator|-
name|StartY
operator|*
operator|(
name|DstBitmap
operator|->
name|width
operator|>>
literal|3
operator|)
operator|)
expr_stmt|;
name|SrcBits
operator|=
operator|(
name|char
operator|*
operator|)
name|pbm
operator|.
name|data
operator|+
name|MUL_4
argument_list|(
name|DIV_BPL
argument_list|(
name|StartX
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SrcBits
operator|=
operator|(
name|char
operator|*
operator|)
name|pbm
operator|.
name|data
operator|+
operator|(
name|StartY
operator|*
name|SrcRowBytes
operator|)
operator|+
name|MUL_4
argument_list|(
name|DIV_BPL
argument_list|(
name|StartX
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
operator|(
name|APA16
operator|&&
name|USE_APA16_HDWR
operator|)
include|#
directive|include
file|"../bitblt/bitblt_apa16.h"
comment|/* 	 * If we are using the APA-16 hardware then we must wait for the 	 * hardware to be done with the screen. 	 */
name|WAIT_QUE
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|(APA16&& USE_APA16_HDWR)
if|if
condition|(
name|nwords
operator|>
literal|1
condition|)
block|{
comment|/* more than one long wide */
name|int
name|tmpnWords
init|=
name|nwords
decl_stmt|;
name|SrcRowBytes
operator|-=
name|MUL_4
argument_list|(
name|nwords
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
do|do
block|{
operator|*
name|DSTBITS
operator|=
operator|*
name|SRCBITS
expr_stmt|;
name|DstBits
operator|+=
name|SIZE_OF_LONG
expr_stmt|;
name|SrcBits
operator|+=
name|SIZE_OF_LONG
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|nwords
operator|>
literal|0
condition|)
do|;
if|if
condition|(
operator|--
name|Height
condition|)
block|{
name|DstBits
operator|+=
name|DstRowBytes
expr_stmt|;
name|SrcBits
operator|+=
name|SrcRowBytes
expr_stmt|;
name|nwords
operator|=
name|tmpnWords
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* one long wide */
comment|/* 		 * Should not have subtracted MUL_4(nwords) from 		 * DstRowBytes.  So now that we know nwords == 1 we will 		 * add MUL_4(nwords) == 4 back to DstRowBytes. 		 */
name|DstRowBytes
operator|+=
literal|4
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
operator|*
name|DSTBITS
operator|=
operator|*
name|SRCBITS
expr_stmt|;
if|if
condition|(
operator|--
name|Height
condition|)
block|{
name|DstBits
operator|+=
name|DstRowBytes
expr_stmt|;
name|SrcBits
operator|+=
name|SrcRowBytes
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|(APA8 || APA8C)
end_endif

end_unit

