begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_bitblt_c
init|=
literal|"$Header: bitblt.c,v 10.1 86/11/19 10:50:19 jg Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/*  *		Copyright (c) 1986 Brown University  *  * Permission to use, copy, modify and distribute this software and its  * documentation for any purpose and without fee is hereby granted, provided  * that the above copyright notice appear in all copies, and that both  * that copyright notice and this permission notice appear in supporting  * documentation, and that the name of Brown University not be used in  * advertising or publicity pertaining to distribution of the software without  * specific, written prior permission. Brown University makes no  * representations about the suitability of this software for any purpose.  * It is provided "as-is" without express or implied warranty.  *  * Written by Daniel Stone, Brown University/IRIS November 21, 1985 and  * "enhanced" a number of times since.  *  * ABOUT BITBLT.C:  This program and related 'C' files (bitblt_int.h,  * bitblt_subr.c, bitblt_apa16.c, bitblt_apa16.h) were originally written to go  * into the Unix 4.2 kernel as a "bitblt" driver.  Later we were able  * to put in some ifdef's and use it for Smalltalk and X.  Whatever  * version you have, there may be some strange ifdef's that may not  * make any sense at all.  We tried to remove all ifdef's not relevant  * to the system being compiled but then no one's perfect.  * Also some strange things are done to support the APA8, APA8C and the AED  * (viking).  You will encounter ifdef's for all these things.  if you define  * all the screens (-DAED -DAPA8 -DAPA16 ... on the compile line) the bitblt  * routine will work on every screen.  */
end_comment

begin_include
include|#
directive|include
file|"bitblt_int.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_APA16_HDWR
end_ifdef

begin_include
include|#
directive|include
file|"bitblt_apa16.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BLT_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|blt_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MSK_SKEW
value|0x01
end_define

begin_define
define|#
directive|define
name|SRC_SKEW
value|0x02
end_define

begin_decl_stmt
name|Blt_sysdata
name|blt_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* internal variables used by bitblt() */
end_comment

begin_decl_stmt
name|Blt_Rectangle
name|changed_rect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* describes the area changed by the bltter */
end_comment

begin_comment
comment|/*  * Array of short masks used to compute the masks to mask out the edges  * of the destination that should not be affected.  A one means that bit  * in the destination can be changed.  The values in leftMasks are set up   * to be used with the left edge and the values in rightMasks are to be used  * in right edge.   */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|leftMasks
index|[]
init|=
block|{
literal|0xffff
block|,
literal|0x7fff
block|,
literal|0x3fff
block|,
literal|0x1fff
block|,
literal|0x0fff
block|,
literal|0x07ff
block|,
literal|0x03ff
block|,
literal|0x01ff
block|,
literal|0x00ff
block|,
literal|0x007f
block|,
literal|0x003f
block|,
literal|0x001f
block|,
literal|0x000f
block|,
literal|0x0007
block|,
literal|0x0003
block|,
literal|0x0001
block|,
literal|0x0000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|rightMasks
index|[]
init|=
block|{
literal|0xffff
block|,
literal|0x8000
block|,
literal|0xc000
block|,
literal|0xe000
block|,
literal|0xf000
block|,
literal|0xf800
block|,
literal|0xfc00
block|,
literal|0xfe00
block|,
literal|0xff00
block|,
literal|0xff80
block|,
literal|0xffc0
block|,
literal|0xffe0
block|,
literal|0xfff0
block|,
literal|0xfff8
block|,
literal|0xfffc
block|,
literal|0xfffe
block|,
literal|0x0000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Blt_Tile
name|white
init|=
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Blt_Tile
name|black
init|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Defines used to indicate whether 1 or 2 source words are needed to make  * the first destination word.  * NOTE: Changing the value of MUST_PRIME may have bad side effects because  *	 the variable "preload_src" is added to something in calculateOffsets.  *	 THIS IS SEMI-HOOKY BUT IT WORKS.  */
end_comment

begin_define
define|#
directive|define
name|MUST_PRIME
value|1
end_define

begin_define
define|#
directive|define
name|DONT_PRIME
value|0
end_define

begin_define
define|#
directive|define
name|SAVE_LOCATOR
parameter_list|()
value|{						\ 	if (blt_cur_screen.cursortype& SOFT_CURSOR) {			\ 		saved_loc = 0;						\ 		if (IS_SCREEN(u_info->dst_bitmap)) {			\ 			if (sys_info->is_src&& IS_SCREEN(u_info->src_bitmap)){\ 				saved_loc = 1;				\ 				save_cursor(MIN(sys_info->dst.rect.origin_x,  \ 					       sys_info->src.rect.origin_x),  \ 					    MIN(sys_info->dst.rect.origin_y,  \ 					       sys_info->src.rect.origin_y),  \ 					    MAX(sys_info->dst.rect.corner_x,  \ 					       sys_info->src.rect.corner_x)+1,\ 					    MAX(sys_info->dst.rect.corner_y,  \ 					       sys_info->src.rect.corner_y)+1);\ 			}						\ 			else {						\ 				saved_loc = 1;				\ 				save_cursor(sys_info->dst.rect.origin_x,     \ 					    sys_info->dst.rect.origin_y,     \ 					    sys_info->dst.rect.corner_x + 1, \ 					    sys_info->dst.rect.corner_y + 1);\ 			}						\ 		}							\ 		else if (sys_info->is_src&& IS_SCREEN(u_info->src_bitmap)) { \ 			saved_loc = 1;					\ 			save_cursor(sys_info->src.rect.origin_x,	\ 				    sys_info->src.rect.origin_y,	\ 				    sys_info->src.rect.corner_x + 1,	\ 				    sys_info->src.rect.corner_y + 1);	\ 		}							\ 	}								\ }
end_define

begin_define
define|#
directive|define
name|RESTORE_LOCATOR
parameter_list|()
value|{						\ 	if ((blt_cur_screen.cursortype& SOFT_CURSOR)&& saved_loc) {	\ 		restore_cursor();					\ 	}								\ }
end_define

begin_comment
comment|/*  * Macros to calculate the skew and preload flag depending on the direction  * of the blt.  */
end_comment

begin_define
define|#
directive|define
name|computeSkewPos
parameter_list|(
name|SI
parameter_list|)
value|{					\ 	if ((MOD_BPW(SI->dst.rect.origin_x))<(MOD_BPW(SI->src.rect.origin_x))){\ 		SI->skew_src = MOD_BPW(SI->src.rect.origin_x) -	\ 			       MOD_BPW(SI->dst.rect.origin_x);	\ 		SI->preload_src = MUST_PRIME;			\ 	}							\ 	else {							\ 		SI->skew_src = BPW - (MOD_BPW(SI->dst.rect.origin_x) -	\ 			       MOD_BPW(SI->src.rect.origin_x));		\                 SI->preload_src = DONT_PRIME;			\ 	}							\ }
end_define

begin_define
define|#
directive|define
name|computeSkewMskPos
parameter_list|(
name|SI
parameter_list|)
value|{						\ 	if ((MOD_BPW(SI->dst.rect.origin_x))<(MOD_BPW(SI->msk.rect.origin_x))){\ 		SI->skew_msk = MOD_BPW(SI->msk.rect.origin_x) -		\ 			       MOD_BPW(SI->dst.rect.origin_x);		\ 		SI->preload_msk = MUST_PRIME;				\ 	}								\ 	else {								\ 		SI->skew_msk = BPW - (MOD_BPW(SI->dst.rect.origin_x) -	\ 			       MOD_BPW(SI->msk.rect.origin_x));		\                 SI->preload_msk = DONT_PRIME;			   	\ 	}								\ }
end_define

begin_define
define|#
directive|define
name|computeSkewNeg
parameter_list|(
name|SI
parameter_list|)
value|{						\ 	if ((MOD_BPW(SI->dst.rect.corner_x))>(MOD_BPW(SI->src.rect.corner_x))){\ 		SI->skew_src = MOD_BPW(SI->dst.rect.corner_x) -		\ 			       MOD_BPW(SI->src.rect.corner_x);		\ 		    SI->preload_src = MUST_PRIME;			\ 	}								\ 	else {								\ 		SI->skew_src = BPW - (MOD_BPW(SI->src.rect.corner_x) -	\ 			       MOD_BPW(SI->dst.rect.corner_x));		\ 		SI->preload_src = DONT_PRIME;				\ 	}								\ }
end_define

begin_define
define|#
directive|define
name|computeSkewMskNeg
parameter_list|(
name|SI
parameter_list|)
value|{						\ 	if ((MOD_BPW(SI->dst.rect.corner_x))>(MOD_BPW(SI->msk.rect.corner_x))){\ 		SI->skew_msk = MOD_BPW(SI->dst.rect.corner_x) -		\ 			       MOD_BPW(SI->msk.rect.corner_x);		\ 		SI->preload_msk = MUST_PRIME;				\ 	}								\ 	else {								\ 		SI->skew_msk = BPW - (MOD_BPW(SI->msk.rect.corner_x) -	\ 			       MOD_BPW(SI->dst.rect.corner_x));		\ 		SI->preload_msk = DONT_PRIME;				\ 	}								\ }
end_define

begin_comment
comment|/*  * Make a mask for the first and last destination word in each scanline.  * 1's mean those bits can be changed in the destination.  * Combine the masks if only one destination word is effected and set  * BOTH masks equal to it so as not to screw up copyBitNeg.   *  * NOTE: The +1 with dst.rect.corner_x. This is because dst.rect.corner_x was  *       set to the rectangle size -1. (see blt_setup())  */
end_comment

begin_define
define|#
directive|define
name|computeMasks
parameter_list|(
name|SI
parameter_list|)
value|{						\ 	if (SI->nshorts == 1) {						\ 		SI->right_mask = SI->left_mask = 			\ 				 leftMasks[MOD_BPW(SI->dst.rect.origin_x)]&\ 				 rightMasks[MOD_BPW(SI->dst.rect.corner_x+1)];\ 	}								\ 	else {								\ 		SI->left_mask = leftMasks[MOD_BPW(SI->dst.rect.origin_x)];\ 		SI->right_mask = rightMasks[MOD_BPW(SI->dst.rect.corner_x+1)];\ 	}								\ }
end_define

begin_comment
comment|/*  * CheckOverlap checks for overlapping source and destination.   * (See checkOverlap in Smalltalk-80)  It set SI->top_to_bot to  * non-zero if we must copy from bottom to top, right to left  * instead of top to bottom, left to right.  *  * NOTE: The +1 for both src.rect.corner_y and src.rect.corner_x this is because  *       these local variables have "closed" corners. (See blt_setup())  *  * IF the destination and source have the same bitmap  *                        AND   *           TEST AREA 1  OR  TEST AREA 2  * THEN  *             (We must copy from right to left bottom to top)  *  *    TEST AREA 1:  The destination top is GREATER than or EQUAL to the  *                  source top and its less than the source bottom  *            (src.rect.origin_y<= dst.rect.origin_y< src.rect.corner_y+1) AND  *		    the destination left is greater than or equal to  *                  the source left and its less than the source right.  *	      (src.rect.origin_x<= dst.rect.origin_x< src.rect.corner_x+1)  *		    IN OTHER WORDS, the top left corner of the destination  *		    is in the source area.  *  *    TEST AREA 2:  The destination top is GREATER than the source top   *                  and its less than the source bottom:  *                 (src.rect.origin_y< dst.rect.origin_y< src.rect.corner_y+1)  *                  AND the source left is greater than the destination left  *                  and its less than the destination right.  *                 (dst.rect.origin_x< src.rect.origin_x< dst.rect.corner_x+1)  *		    IN OTHER WORDS, the top horizontal line of the destination  *		    intersects the left vertical line of the source, causing  *		    the right top corner of the destination to be in the  *		    source.  *  *			         src.rect.origin_x  *	                         src.rect.origin_y +----------------------------  *   src.rect.origin_y - 1  -----------------------|  *                                                 |  *			      TEST AREA 2	   |    TEST AREA 1  *                                                 |  *                                                 |  *    src.rect.corner_y+1   ------------------------------------------------  */
end_comment

begin_define
define|#
directive|define
name|checkOverlap
parameter_list|(
name|UI
parameter_list|,
name|SI
parameter_list|)
define|\
value|SI->top_to_bot = ((UI->src_bitmap.base == UI->dst_bitmap.base)	\&& (((SI->src.rect.origin_y<= SI->dst.rect.origin_y&&\ 			SI->dst.rect.origin_y< (SI->src.rect.corner_y+1))\&& (SI->src.rect.origin_x<= SI->dst.rect.origin_x&&	\ 			SI->dst.rect.origin_x< (SI->src.rect.corner_x+1)))\ 	          || ((SI->src.rect.origin_y< SI->dst.rect.origin_y&&	\ 			SI->dst.rect.origin_y< (SI->src.rect.corner_y+1))\&& (SI->dst.rect.origin_x< SI->src.rect.origin_x&&	\ 			SI->src.rect.origin_x< (SI->dst.rect.corner_x+1)))))
end_define

begin_comment
comment|/*  * CalculateOffsetDst sets up pointers to a word in the destination and  * possibly to the mask bitmap using the dst_x,dst_y points given.  * It calculates the increment for each pointer from the end of one   * rectangle scanline to the beginning of the next.  */
end_comment

begin_expr_stmt
name|calculateOffsetDst
argument_list|(
name|u_info
argument_list|,
name|s_info
argument_list|,
name|dst_x
argument_list|,
name|dst_y
argument_list|)
specifier|register
name|Blt_userdata
operator|*
name|u_info
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Blt_sysdata
modifier|*
name|s_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|dst_x
decl_stmt|,
name|dst_y
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* top,left or bottom,right */
end_comment

begin_block
block|{
comment|/* 	 * Set up the destination pointer and increment. 	 * NOTE that (dst_y * u_info->dst_bitmap.nshorts) + DIV_BPW(dst_x) 	 * gives the WORD offset to base.  Since we need the byte address 	 * this quantity must be multiplied by 2 (MUL_2). 	 * 	 * Set up destination to point to a word offset from the base address. 	 */
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
if|if
condition|(
name|IS_APA8orAPA8C
argument_list|(
name|u_info
operator|->
name|dst_bitmap
argument_list|)
condition|)
block|{
name|s_info
operator|->
name|dst_plus
operator|=
literal|4
expr_stmt|;
name|s_info
operator|->
name|dst
operator|.
name|data
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|u_info
operator|->
name|dst_bitmap
operator|.
name|base
operator|+
name|MUL_4
argument_list|(
operator|(
name|dst_y
operator|*
name|u_info
operator|->
name|dst_bitmap
operator|.
name|nshorts
operator|)
operator|+
name|DIV_BPW
argument_list|(
name|dst_x
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|s_info
operator|->
name|dst
operator|.
name|nextline
operator|=
name|MUL_4
argument_list|(
name|u_info
operator|->
name|dst_bitmap
operator|.
name|nshorts
operator|-
name|s_info
operator|->
name|nshorts
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_info
operator|->
name|dst_plus
operator|=
literal|2
expr_stmt|;
name|s_info
operator|->
name|dst
operator|.
name|data
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|u_info
operator|->
name|dst_bitmap
operator|.
name|base
operator|+
name|MUL_2
argument_list|(
operator|(
name|dst_y
operator|*
name|u_info
operator|->
name|dst_bitmap
operator|.
name|nshorts
operator|)
operator|+
name|DIV_BPW
argument_list|(
name|dst_x
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|s_info
operator|->
name|dst
operator|.
name|nextline
operator|=
name|MUL_2
argument_list|(
name|u_info
operator|->
name|dst_bitmap
operator|.
name|nshorts
operator|-
name|s_info
operator|->
name|nshorts
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
else|no APA8 stuff
name|s_info
operator|->
name|dst
operator|.
name|data
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|u_info
operator|->
name|dst_bitmap
operator|.
name|base
operator|+
name|MUL_2
argument_list|(
operator|(
name|dst_y
operator|*
name|u_info
operator|->
name|dst_bitmap
operator|.
name|nshorts
operator|)
operator|+
name|DIV_BPW
argument_list|(
name|dst_x
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * NOTE: This increment shows the increment for the number of BYTES. 	 */
name|s_info
operator|->
name|dst
operator|.
name|nextline
operator|=
name|MUL_2
argument_list|(
name|u_info
operator|->
name|dst_bitmap
operator|.
name|nshorts
operator|-
name|s_info
operator|->
name|nshorts
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|APA8
comment|/* 	 * Set up the masking bitmap (if given) to point to a word 	 * offset from the base address. 	 */
if|if
condition|(
name|u_info
operator|->
name|blt_flags
operator|&
name|BLT_MASKON
condition|)
block|{
comment|/* 	      	 * Calculate the shift amount (skew) that is needed 		 * to align a word in the mask bitmap with a word 		 * in the destination. 		 */
if|if
condition|(
name|s_info
operator|->
name|top_to_bot
condition|)
block|{
name|computeSkewMskNeg
argument_list|(
name|s_info
argument_list|)
expr_stmt|;
comment|/* 			 * Calculate the mask pointer. 			 */
name|s_info
operator|->
name|msk
operator|.
name|data
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
call|(
name|long
call|)
argument_list|(
name|u_info
operator|->
name|msk_bitmap
operator|.
name|base
argument_list|)
operator|+
name|MUL_2
argument_list|(
operator|(
name|s_info
operator|->
name|msk
operator|.
name|rect
operator|.
name|corner_y
operator|*
name|u_info
operator|->
name|msk_bitmap
operator|.
name|nshorts
operator|)
operator|+
name|DIV_BPW
argument_list|(
name|s_info
operator|->
name|msk
operator|.
name|rect
operator|.
name|corner_x
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|computeSkewMskPos
argument_list|(
name|s_info
argument_list|)
expr_stmt|;
comment|/* 			 * Calculate the mask pointer. 			 */
name|s_info
operator|->
name|msk
operator|.
name|data
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
call|(
name|long
call|)
argument_list|(
name|u_info
operator|->
name|msk_bitmap
operator|.
name|base
argument_list|)
operator|+
name|MUL_2
argument_list|(
operator|(
name|s_info
operator|->
name|msk
operator|.
name|rect
operator|.
name|origin_y
operator|*
name|u_info
operator|->
name|msk_bitmap
operator|.
name|nshorts
operator|)
operator|+
name|DIV_BPW
argument_list|(
name|s_info
operator|->
name|msk
operator|.
name|rect
operator|.
name|origin_x
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* 		 * Calculate the mask increment. 		 */
name|s_info
operator|->
name|msk
operator|.
name|nextline
operator|=
name|MUL_2
argument_list|(
name|u_info
operator|->
name|msk_bitmap
operator|.
name|nshorts
operator|-
operator|(
name|s_info
operator|->
name|nshorts
operator|+
name|s_info
operator|->
name|preload_msk
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_info
operator|->
name|msk
operator|.
name|data
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
literal|0
expr_stmt|;
name|s_info
operator|->
name|msk
operator|.
name|nextline
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * CalculateOffsetSrcNeg sets up pointers to the last word in the  * source.  It also determines if "priming" must be done.  * (i.e. 2 words of source are needed for the first word of the destination.)  * When going from right to left this happens when for example you have   * 3 bits in the source (at the end of the line) (0-2) and 5 bits to fill  * in the destination (0-4).  One must take those 3 bits from the source  * and put them in 2-4 in the destination and increment the source.  *  * It then calculates the increment for the source.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
end_if

begin_define
define|#
directive|define
name|calculateOffsetSrcNeg
parameter_list|(
name|UI
parameter_list|,
name|SI
parameter_list|)
value|{					\ 	if (IS_APA8orAPA8C(UI->src_bitmap)) {				\ 		SI->src_plus = 4;					\ 		SI->src.data = (unsigned short *)((long)(UI->src_bitmap.base) +\ 			     MUL_4((SI->src.rect.corner_y *	\ 					  UI->src_bitmap.nshorts) +	\ 					 DIV_BPW(SI->src.rect.corner_x)));\ 		SI->src.nextline = MUL_4(UI->src_bitmap.nshorts - 	\ 				         (SI->nshorts+SI->preload_src) + 1);\ 	}								\ 	else {								\ 		SI->src_plus = 2;					\ 		SI->src.data = (unsigned short *)((long)(UI->src_bitmap.base) +\ 	       		    MUL_2((SI->src.rect.corner_y *		\ 				   UI->src_bitmap.nshorts) +		\ 	                           DIV_BPW(SI->src.rect.corner_x)));	\ 		SI->src.nextline = MUL_2(UI->src_bitmap.nshorts -	\ 			           (SI->nshorts + SI->preload_src) + 1);\ 	}								\ }
end_define

begin_else
else|#
directive|else
else|no APA8 stuff
end_else

begin_define
define|#
directive|define
name|calculateOffsetSrcNeg
parameter_list|(
name|UI
parameter_list|,
name|SI
parameter_list|)
value|{					\ 	SI->src.data = (unsigned short *)((long)(UI->src_bitmap.base) +	\                     MUL_2((SI->src.rect.corner_y * UI->src_bitmap.nshorts) +\                           DIV_BPW(SI->src.rect.corner_x)));		\ 	SI->src.nextline = MUL_2(UI->src_bitmap.nshorts -		\ 			   (SI->nshorts+SI->preload_src) + 1);		\ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * CalculateOffsetSrcPos sets up pointers to the first word in the  * source.  It also determines if "priming" must be done. (i.e. 2 words   * of source are needed for the first word of the destination.)  * When going from left to right this happens when for example you have   * 3 bits in the source (13-15) and 5 bits to fill in the destination (11-15).  * One must take those 3 bits from the source and put them in 11-13  * and then increment the source.  *  * It then calculates the increment for the source.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
end_if

begin_define
define|#
directive|define
name|calculateOffsetSrcPos
parameter_list|(
name|UI
parameter_list|,
name|SI
parameter_list|)
value|{					\ 	if (IS_APA8orAPA8C(UI->src_bitmap)) {				\ 		SI->src_plus = 4;					\ 		SI->src.data = (unsigned short *)((long)UI->src_bitmap.base +  \ 	                       MUL_4((SI->src.rect.origin_y *		\ 				      UI->src_bitmap.nshorts) +	\ 	                              DIV_BPW(SI->src.rect.origin_x)));\ 		SI->src.nextline = MUL_4(UI->src_bitmap.nshorts -	\ 			                 (SI->nshorts + SI->preload_src) + 1);\ 	}								\ 	else {								\ 		SI->src_plus = 2;					\ 		SI->src.data = (unsigned short *)((long)UI->src_bitmap.base +\ 	                        MUL_2((SI->src.rect.origin_y *		\ 			  	      UI->src_bitmap.nshorts) +		\ 	                              DIV_BPW(SI->src.rect.origin_x)));	\ 		SI->src.nextline = MUL_2(UI->src_bitmap.nshorts -	\ 			           (SI->nshorts+SI->preload_src) + 1);	\ 	}								\ }
end_define

begin_else
else|#
directive|else
else|no APA8 stuff
end_else

begin_define
define|#
directive|define
name|calculateOffsetSrcPos
parameter_list|(
name|UI
parameter_list|,
name|SI
parameter_list|)
value|{					\ 	SI->src.data = (unsigned short *)((long)UI->src_bitmap.base +	\                     MUL_2((SI->src.rect.origin_y * UI->src_bitmap.nshorts) +\                           DIV_BPW(SI->src.rect.origin_x)));		\ 	SI->src.nextline = MUL_2(UI->src_bitmap.nshorts -		\ 			   (SI->nshorts+SI->preload_src) + 1);		\ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Set up destination offsets.  */
end_comment

begin_define
define|#
directive|define
name|calculateOffsetDstNeg
parameter_list|(
name|UI
parameter_list|,
name|SI
parameter_list|)
value|calculateOffsetDst(UI,SI,		\ 							SI->dst.rect.corner_x,\ 							SI->dst.rect.corner_y)
end_define

begin_define
define|#
directive|define
name|calculateOffsetDstPos
parameter_list|(
name|UI
parameter_list|,
name|SI
parameter_list|)
value|calculateOffsetDst(UI,SI,		\ 							SI->dst.rect.origin_x, \ 							SI->dst.rect.origin_y)
end_define

begin_comment
comment|/*  * If a rule specifies the type of tile to be used then set tile_ptr.  * If tile_ptr has already been set then don't change it.  */
end_comment

begin_define
define|#
directive|define
name|calculateOffsetTile
parameter_list|(
name|UI
parameter_list|,
name|SI
parameter_list|)
value|{				\ 	if (SI->rule == DstClear || SI->rule == TileDstClear) {	\ 		SI->tile_ptr =&white.tile[0];			\ 	}							\ 	else if (SI->rule == DstSet || SI->rule == TileDstSet	\ 		|| SI->rule == NotDstCopy) {			\ 		SI->tile_ptr =&black.tile[0];			\ 	}							\ 	else if (SI->tile_ptr == (unsigned short *)0){		\ 		SI->tile_ptr = (unsigned short *)UI->tile_ptr;	\ 	}							\ }
end_define

begin_comment
comment|/*  * Do the bit block transfer using the information in u_info. Return -1 if  * bad pointers are given, 0 if the area clipped down to a null blt and 1 if  * the "bitblt" was done.  */
end_comment

begin_expr_stmt
name|bitblt
argument_list|(
name|u_info
argument_list|)
specifier|register
name|Blt_userdata
operator|*
name|u_info
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Blt_sysdata
modifier|*
name|sys_info
init|=
operator|&
name|blt_info
decl_stmt|;
specifier|register
name|tmp
expr_stmt|;
specifier|register
name|saved_loc
expr_stmt|;
name|int
name|blt_status
decl_stmt|;
name|DEBUGF
argument_list|(
operator|(
name|blt_debug
operator|>
literal|1
operator|)
argument_list|,
name|printf
argument_list|(
literal|"Enter bitblt.\r\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set up to do this blt.  blt_setup does clipping if necessary, sets 	 * up either the source or tile (depending on the combination rule 	 * being used) and sets the width and height of the blt.  It returns 	 * zero if the blt is to be done. 	 */
if|if
condition|(
operator|(
name|blt_status
operator|=
name|blt_setup
argument_list|(
name|u_info
argument_list|,
name|sys_info
argument_list|)
operator|)
operator|!=
literal|1
condition|)
block|{
comment|/* 		 * Bad pointers or the combination rule was such that nothing 		 * has to be done. 		 */
return|return
operator|(
name|blt_status
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|sys_info
operator|->
name|width
operator|<=
literal|0
operator|||
name|sys_info
operator|->
name|height
operator|<=
literal|0
condition|)
block|{
comment|/* 		 * Nothing to do. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|USE_APA16_HDWR
comment|/* 	 * Are we using hardware??  This is for debugging purposes, we 	 * know the software works so to test the hardware stuff we have this 	 * flag in blt_flags.  However if we are using a mask bitmap then 	 * the hardware can not be used. 	 */
if|if
condition|(
operator|(
name|u_info
operator|->
name|blt_flags
operator|&
name|BLT_MASKON
operator|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|int
name|ret_flag
decl_stmt|;
comment|/* Hardware return flag */
comment|/* 		 * One can only use the hardware assist if the destination 		 * bitmap is the screen. 		 */
name|ret_flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IS_APA16
argument_list|(
name|u_info
operator|->
name|dst_bitmap
argument_list|)
condition|)
block|{
specifier|extern
name|unsigned
name|short
name|execute_cmd
index|[]
decl_stmt|;
comment|/* 			 * Check and see if there is a hardware function 			 * (execute command) for this rule. 			 */
if|if
condition|(
name|execute_cmd
index|[
name|sys_info
operator|->
name|rule
index|]
condition|)
block|{
if|if
condition|(
name|sys_info
operator|->
name|is_src
condition|)
block|{
if|if
condition|(
name|IS_APA16
argument_list|(
name|u_info
operator|->
name|src_bitmap
argument_list|)
condition|)
block|{
comment|/* 						 * Pass in the pointers to 						 * the screen because if they 						 * are greater than the first 						 * byte address in the APA16 						 * buffer things will not 						 * work. 						 */
name|sys_info
operator|->
name|dst
operator|.
name|data
operator|=
name|u_info
operator|->
name|dst_bitmap
operator|.
name|base
expr_stmt|;
name|sys_info
operator|->
name|src
operator|.
name|data
operator|=
name|u_info
operator|->
name|src_bitmap
operator|.
name|base
expr_stmt|;
name|ret_flag
operator|=
name|apa16_StoS
argument_list|(
name|sys_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 						 * The APA-16 does memory to 						 * screen stuff.  But first 						 * The source address and 						 * and the source "nextline" 						 * field must also be 						 * calculated. 						 * 						 * NOT IMPLEMENTED YET. 						 * 						 * computeSkewPos(sys_info); 						 * calculateOffsetSrcPos(u_info, 						 *		      sys_info); 						 * ret_flag = 						 *	   apa16_MtoS(sys_info); 						 */
block|}
block|}
else|else
block|{
comment|/* 					 * The tile ptr has not been set up yet. 					 */
name|sys_info
operator|->
name|tile_ptr
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|u_info
operator|->
name|tile_ptr
expr_stmt|;
name|ret_flag
operator|=
name|apa16_copyTile
argument_list|(
name|sys_info
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Check the status of the hardware blt, if 				 * its 0 then everything was done successfully. 				 */
if|if
condition|(
name|ret_flag
operator|==
literal|0
condition|)
block|{
comment|/* 					 * Indicate that a blt was done. 					 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
block|}
comment|/* 	 * Regardless of the hardware flag, if we get here it means 	 * that we are going to use the software to blt.  If the screen 	 * is to be changed then we must wait for the rasterop engine to finish 	 * with the screen if it is still using the screen. 	 */
if|if
condition|(
operator|*
name|QUE_COUNT_R
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|IS_APA16
argument_list|(
name|u_info
operator|->
name|dst_bitmap
argument_list|)
operator|||
operator|(
name|IS_APA16
argument_list|(
name|u_info
operator|->
name|src_bitmap
argument_list|)
operator|)
condition|)
block|{
name|WAIT_QUE
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|USE_APA16_HDWR
ifdef|#
directive|ifdef
name|AED
comment|/*   	 * If this is a screen to screen blt on the AED have the microcode 	 * make the screen changes while the bltter alters the  	 * offscreen bitmap. 	 */
if|if
condition|(
name|IS_AED
argument_list|(
name|u_info
operator|->
name|src_bitmap
argument_list|)
operator|&&
name|IS_AED
argument_list|(
name|u_info
operator|->
name|dst_bitmap
argument_list|)
operator|&&
operator|(
name|u_info
operator|->
name|blt_flags
operator|&
name|BLT_ECHO
operator|)
condition|)
block|{
name|aed_screen_copy
argument_list|(
name|sys_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_x
argument_list|,
name|sys_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_y
argument_list|,
name|sys_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|origin_x
argument_list|,
name|sys_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|origin_y
argument_list|,
operator|(
name|short
operator|)
name|sys_info
operator|->
name|width
argument_list|,
operator|(
name|short
operator|)
name|sys_info
operator|->
name|height
argument_list|,
name|sys_info
operator|->
name|rule
argument_list|)
expr_stmt|;
name|blt_status
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
endif|AED
comment|/* 	 * Remove the locator from the screen if it is a software locator that 	 * is actually in (on) the source or destination bitmap.  Hardware 	 * locators (as in the APA-16) are not removed. 	 */
name|SAVE_LOCATOR
argument_list|()
expr_stmt|;
comment|/* 	 * Calculate the edge masks for the destination. (See computeMasks 	 * in Smalltalk-80) 	 */
name|computeMasks
argument_list|(
name|sys_info
argument_list|)
expr_stmt|;
comment|/* 	 * If the source is to be used then things will be done differently 	 * than if a tile is used. 	 */
if|if
condition|(
name|sys_info
operator|->
name|is_src
condition|)
block|{
comment|/* 		 * Check for overlapping source and destination. (See 		 * checkOverlap in Smalltalk-80)  Sets sys_info->top_to_bot 		 * non-zero if we must copy from bottom to top, right to 		 * left instead of top to bottom, left to right. 		 */
name|checkOverlap
argument_list|(
name|u_info
argument_list|,
name|sys_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_info
operator|->
name|top_to_bot
condition|)
block|{
comment|/* 			 * Calculate the shift amount (skew) that is needed 			 * to align a word in the source with a word in the 			 * destination. 			 */
name|computeSkewNeg
argument_list|(
name|sys_info
argument_list|)
expr_stmt|;
comment|/* 			 * Set up pointers to the source, destination  			 * and possibly to the mask bitmap. Also set up 			 * shift amounts (skews) for the mask bitmap if needed. 			 * Calculate the increment for each pointer from 			 * the end of one rectangle scanline to the beginning 			 * of the next. 			 */
name|calculateOffsetSrcNeg
argument_list|(
name|u_info
argument_list|,
name|sys_info
argument_list|)
expr_stmt|;
name|calculateOffsetDstNeg
argument_list|(
name|u_info
argument_list|,
name|sys_info
argument_list|)
expr_stmt|;
comment|/* 			 * Do the blt from bottom to top, right to left!! 			 */
if|if
condition|(
name|u_info
operator|->
name|blt_flags
operator|&
name|BLT_MASKON
condition|)
block|{
name|maskBitNeg
argument_list|(
name|sys_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Just copy from source to destination 				 * going bottom to top, right to left. 				 * No mask bitmap to worry about. 				 */
name|copyBitNeg
argument_list|(
name|sys_info
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Calculate the shift amount (skew) that is needed 			 * to align a word in the source with a word in the 			 * destination. 			 */
name|computeSkewPos
argument_list|(
name|sys_info
argument_list|)
expr_stmt|;
comment|/* 			 * Set up pointers to the source, destination  			 * and possibly to the mask bitmap. 			 * Also set up shift amounts (skews) for the mask 			 * bitmap if needed.  Calculate the increment for 			 * each pointer from the end of one rectangle 			 * scanline to the beginning of the next. 			 */
name|calculateOffsetSrcPos
argument_list|(
name|u_info
argument_list|,
name|sys_info
argument_list|)
expr_stmt|;
name|calculateOffsetDstPos
argument_list|(
name|u_info
argument_list|,
name|sys_info
argument_list|)
expr_stmt|;
comment|/* 			 * Do the blt from top to bottom, left to right!! 			 */
if|if
condition|(
name|u_info
operator|->
name|blt_flags
operator|&
name|BLT_MASKON
condition|)
block|{
comment|/* 				 * Copy from source to destination going 				 * top to bottom, left to right. Use the 				 * mask bitmap. 				 */
name|maskBitPos
argument_list|(
name|sys_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Just copy from source to destination 				 * going top to bottom, left to right. 				 */
if|if
condition|(
name|sys_info
operator|->
name|nshorts
operator|<
literal|3
condition|)
block|{
comment|/* 					 * Optimize this very important routine 					 * for one and two shorts in the dst 					 * changed. 					 */
name|smallcopyBitPos
argument_list|(
name|sys_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copyBitPos
argument_list|(
name|sys_info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * We have a TILE rule. 		 */
name|sys_info
operator|->
name|top_to_bot
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Set up pointers to the tile and destination and possibly 		 * to the mask bitmap.  Calculate the increment for 		 * each pointer from the end of one rectangle scanline to 		 * the beginning of the next. 		 * NOTE: The pointer to the tile may have been set in 		 *	 blt_setup. 		 */
name|calculateOffsetTile
argument_list|(
name|u_info
argument_list|,
name|sys_info
argument_list|)
expr_stmt|;
name|calculateOffsetDstPos
argument_list|(
name|u_info
argument_list|,
name|sys_info
argument_list|)
expr_stmt|;
comment|/* 		 * Do the tile blt! 		 */
if|if
condition|(
name|u_info
operator|->
name|blt_flags
operator|&
name|BLT_MASKON
condition|)
block|{
name|maskTile
argument_list|(
name|sys_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copyTile
argument_list|(
name|sys_info
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Restore the locator if the screen was dealt with. 	 */
name|RESTORE_LOCATOR
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|AED
comment|/*   	 * If we are echoing to AED, keep track of bounding 	 * rectangle of the updated screen area. 	 */
if|if
condition|(
name|IS_AED
argument_list|(
name|u_info
operator|->
name|dst_bitmap
argument_list|)
operator|&&
name|blt_status
operator|&&
operator|(
name|u_info
operator|->
name|blt_flags
operator|&
name|BLT_ECHO
operator|)
condition|)
block|{
name|aed_echo_rect
argument_list|(
operator|&
name|changed_rect
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|AED
comment|/* 	 * Indicate that a blt was done. 	 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

end_unit

