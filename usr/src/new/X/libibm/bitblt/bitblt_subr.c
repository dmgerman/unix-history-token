begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid_bitblt_subr_c
init|=
literal|"$Header: bitblt_subr.c,v 10.1 86/11/19 10:51:21 jg Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/*  *		Copyright (c) 1986 Brown University  *  * Permission to use, copy, modify and distribute this software and its  * documentation for any purpose and without fee is hereby granted, provided  * that the above copyright notice appear in all copies, and that both  * that copyright notice and this permission notice appear in supporting  * documentation, and that the name of Brown University not be used in  * advertising or publicity pertaining to distribution of the software without  * specific, written prior permission. Brown University makes no  * representations about the suitability of this software for any purpose.  * It is provided "as-is" without express or implied warranty.  *  * Written by Daniel Stone, Brown University/IRIS  (des@iris)  */
end_comment

begin_comment
comment|/*  * CURRENT HISTORY:  *  * $Log:	bitblt_subr.c,v $  * Revision 10.1  86/11/19  10:51:21  jg  * Device dependent code for IBM displays.  General blitter...  *   * Revision 4.0  86/09/25  10:03:10  des  * Version 4.0. Works with all IBM screens.  *   * Revision 3.6  86/09/22  16:47:44  des  * Added a third argument to blt_init.  *   * Revision 3.5  86/09/22  13:37:29  des  * Version 3.5. Removed all ifdef's that did not pertain to X.  *   * Revision 3.0  86/09/17  10:29:59  des  * Version 3.0.  Works but has ifdef's for all systems.  *   * Revision 7.0  86/07/03  10:40:03  des  * Release 7.0.  *   * Revision 6.1  86/07/03  10:29:10  des  * Replaced certain mask rules.  *   * Revision 6.0  86/06/18  11:19:59  des  * Changed unsigned short pointers to unsigned char pointers for efficiency  * reasons.  This change ment multiplying by 2 every variable added to  * these pointers.  *   * Revision 5.0  86/05/21  14:26:02  des  * Revision 5.0.  No longer uses unsigned short pointers.  *   * Revision 4.7  86/05/15  16:03:45  des  * Latest and faster version of the new copyBitPos loop.  Runs 5% to 7% faster  * than the old loop.  *   * Revision 4.6  86/05/14  10:54:46  des  * Changed smallcopyBitPos_LOOP so that it checks for 1 or 2 words changed  * and branches to that loop.  *   * Revision 4.5  86/05/14  10:31:57  des  * bitblt with NEW_LOOP (needs work.)  *   * Revision 4.0  86/05/09  13:52:25  des  * Revision 4.0.  Apa-16 hardware enhancements Version 0.6.  *   * Revision 3.2  86/04/30  15:34:16  des  * This version has smallcopyBitPos and the old copyBitPos.  The new copyBitPos  * took off .1 second on a 111 second blt. (new: 111.1 old:111.2) so what right?  * The old copyBitPos did not need smallcopyBitPos around so I figured it was  * better.  *   * Revision 2.2  86/04/29  16:31:53  des  * Added the smallcopyBitPos routine for speeding up small blts.  *   * Revision 3.0  86/04/28  16:59:20  des  * Runs with X. Version 0.5.  *   * Revision 2.2  86/04/09  09:36:41  des  * Fixed APA-8 and APA-8C software locator problem.  *   * Revision 2.1  86/04/04  12:19:38  des  * Moved copyBitNeg,copyBitPos,copyTile,maskBitNeg,maskBitPos,maskTile,  * clip_and_maskBitNeg,clip_and_maskBitPos and clip_and_maskTile to  * bitblt_subr.c.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: bitblt_subr.c,v 10.1 86/11/19 10:51:21 jg Exp $ (Brown/IRIS)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bitblt_int.h"
end_include

begin_comment
comment|/*  * Keep track of the first and one beyond the last address of the screen,  * so that current_screen.firstaddr<= some_base< current_screen.lastaddr  * is true if some_base is a pointer to a section of the screen.  */
end_comment

begin_decl_stmt
name|Blt_screen_info
name|blt_cur_screen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Blt_Tile
name|blt_black
init|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Blt_Rectangle
name|changed_rect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* describes the area changed by the bltter */
end_comment

begin_comment
comment|/*  * Set 'ans' to the largest value and set 'diff' equal to the difference  * between 'ans' and 'a'.  */
end_comment

begin_define
define|#
directive|define
name|max_a
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|ans
parameter_list|,
name|diff
parameter_list|)
value|{		\ 	if (a>= b) {			\ 		if (a>= c) {		\ 			diff = 0;	\ 			ans = a;	\ 		}			\ 		else {			\ 			diff = c - a;	\ 			ans = c;	\ 		}			\ 	}				\ 	else if (b> c) {		\ 		diff = b - a;		\ 		ans = b;		\ 	}				\ 	else {				\ 		diff = c - a;		\ 		ans = c;		\ 	}				\ }
end_define

begin_comment
comment|/*  * Set 'ans' to the smallest value and set 'diff' equal to the difference  * between 'ans' and 'a'.  */
end_comment

begin_define
define|#
directive|define
name|min_a
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|ans
parameter_list|,
name|diff
parameter_list|)
value|{		\ 	if (a<= b) {			\ 		if (a<= c) {		\ 			diff = 0;	\ 			ans = a;	\ 		}			\ 		else {			\ 			diff = a - c;	\ 			ans = c;	\ 		}			\ 	}				\ 	else if (b< c) {		\ 		diff = a - b;		\ 		ans = b;		\ 	}				\ 	else {				\ 		diff = a - c;		\ 		ans = c;		\ 	}				\ }
end_define

begin_comment
comment|/*   * Initialize the bitblt so that it knows where in the address space the   * screen is and whether or not it uses a hardware or software cursor.   */
end_comment

begin_macro
name|bitblt_init
argument_list|(
argument|screen_base
argument_list|,
argument|screen_wd
argument_list|,
argument|screen_ht
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|short
modifier|*
name|screen_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The first address of the bitmap */
end_comment

begin_decl_stmt
name|long
name|screen_wd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Screen width in BITS (will round up) */
end_comment

begin_decl_stmt
name|long
name|screen_ht
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Screen height in scan lines */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates the type of cursor on the screen.*/
end_comment

begin_block
block|{
name|blt_cur_screen
operator|.
name|firstaddr
operator|=
name|screen_base
expr_stmt|;
name|blt_cur_screen
operator|.
name|lastaddr
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|screen_base
operator|+
operator|(
operator|(
operator|(
name|screen_wd
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
operator|*
name|screen_ht
operator|)
operator|)
expr_stmt|;
name|blt_cur_screen
operator|.
name|cursortype
operator|=
name|flags
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Blt_setup takes information from the user data and creates data  * to be used internally.  Specificly it creates clipped source rectangle  * if a source combination rule is given, a clipped destination rectangle  * the number of destination words to be changed across a scanline  * (nshorts) and masking bitmap rectangle masking is to be done.  * Finally the width and height and rule are filled in as width,  * height and rule.  *   * If a bad pointer was encountered  (or something else is wrong) then  * blt_setup returns -1. Returns 0 if combination rule was a no-op and  * 1 if blt_setup finished ok.  */
end_comment

begin_expr_stmt
name|blt_setup
argument_list|(
name|u_info
argument_list|,
name|s_info
argument_list|)
specifier|register
name|Blt_userdata
operator|*
name|u_info
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* User bitblt data */
end_comment

begin_decl_stmt
specifier|register
name|Blt_sysdata
modifier|*
name|s_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bitblt internal data (This is modified 				   bitblt user data depending on the clipping 				   to be done. */
end_comment

begin_block
block|{
specifier|register
name|int
name|x_orig
decl_stmt|,
name|y_orig
decl_stmt|;
comment|/* because the destination x,y origin 				      is used so much, it will be put in 				      registers. */
specifier|register
name|int
name|Oxdiff
decl_stmt|,
name|Cxdiff
decl_stmt|;
comment|/* If the destination rectangle is clipped 				      then these variables contain the 				      difference between the destination 				      rectangle and the rectangle used 				      to clip. */
specifier|register
name|int
name|Oydiff
decl_stmt|,
name|Cydiff
decl_stmt|;
comment|/* If the destination rectangle is clipped 				      then these variables contain the 				      difference between the destination 				      rectangle and the rectangle used 				      to clip. */
name|DEBUGF
argument_list|(
operator|(
name|blt_debug
operator|>
literal|1
operator|)
argument_list|,
name|printf
argument_list|(
literal|"Enter blt_setup.0x%x\r\n"
argument_list|,
name|u_info
operator|->
name|blt_flags
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the internal bltters combination rule. 	 */
name|s_info
operator|->
name|rule
operator|=
name|u_info
operator|->
name|comb_rule
expr_stmt|;
comment|/* 	 * Set a flag indicating that the rule uses the source. 	 */
name|s_info
operator|->
name|is_src
operator|=
name|IS_SRC
argument_list|(
name|s_info
operator|->
name|rule
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure s_info->tile_ptr = 0.  	 */
name|s_info
operator|->
name|tile_ptr
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* 	 * Check the bltstruct to make sure every pointer is valid. 	 */
if|if
condition|(
name|u_info
operator|==
operator|(
name|Blt_userdata
operator|*
operator|)
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Error: NULL bltstruct given!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|u_info
operator|->
name|dst_bitmap
operator|.
name|base
operator|==
operator|(
name|unsigned
name|short
operator|*
operator|)
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Error: NULL destination bitmap!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * If a source combination rule was given and no bitmap was given then 	 * we assume the user wants US to assume that the source is infinitely 	 * large and is set to all one's.  This is the same thing as using 	 * the coorisponding tile rule and an all black tile. 	 */
if|if
condition|(
name|s_info
operator|->
name|is_src
operator|&&
name|u_info
operator|->
name|src_bitmap
operator|.
name|base
operator|==
operator|(
name|unsigned
name|short
operator|*
operator|)
literal|0
condition|)
block|{
name|s_info
operator|->
name|is_src
operator|=
literal|0
expr_stmt|;
name|s_info
operator|->
name|rule
operator|+=
name|SRC_TO_TILE
expr_stmt|;
name|s_info
operator|->
name|tile_ptr
operator|=
operator|&
name|blt_black
operator|.
name|tile
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* 	 * Check the rule and if its a no-op then return immediately. 	 */
if|if
condition|(
name|s_info
operator|->
name|rule
operator|==
name|DstCopy
operator|||
name|s_info
operator|->
name|rule
operator|==
name|TileDstCopy
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|u_info
operator|->
name|blt_flags
operator|&
name|BLT_CLIPON
condition|)
block|{
comment|/* DEBUGF(blt_debug,printf("Clip.\r\n")); */
comment|/* 		 * Do some clipping.  We clip to the clipping rectangle, 		 * the destination bitmap's rect and the destination 		 * rectangle.  NOTE that if the destination rectangle 		 * is clipped in any way then the source rectangle must 		 * also be changed, thats why we keep track of the difference 		 * in Oxdiff. 		 * 		 * Set the origin to be a zero based coorinate system. 		 */
name|max_a
argument_list|(
name|u_info
operator|->
name|dst_rect
operator|.
name|origin_x
argument_list|,
name|u_info
operator|->
name|clp_rect
operator|.
name|origin_x
argument_list|,
name|u_info
operator|->
name|dst_bitmap
operator|.
name|rect
operator|.
name|origin_x
argument_list|,
name|x_orig
argument_list|,
name|Oxdiff
argument_list|)
expr_stmt|;
name|x_orig
operator|-=
name|u_info
operator|->
name|dst_bitmap
operator|.
name|rect
operator|.
name|origin_x
expr_stmt|;
comment|/* 		 * Take the min value of the clipping rectangle X corner 		 * coord, bitmap rectangle X corner coord. and the 		 * destination rectangle X corner coord.. Cxdiff 		 * contains the difference between dst_rect.corner_x and 		 * the value returned.  Then convert to a zero based 		 * coordinate system. 		 */
name|min_a
argument_list|(
name|u_info
operator|->
name|dst_rect
operator|.
name|corner_x
argument_list|,
name|u_info
operator|->
name|clp_rect
operator|.
name|corner_x
argument_list|,
name|u_info
operator|->
name|dst_bitmap
operator|.
name|rect
operator|.
name|corner_x
argument_list|,
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_x
argument_list|,
name|Cxdiff
argument_list|)
expr_stmt|;
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_x
operator|-=
name|u_info
operator|->
name|dst_bitmap
operator|.
name|rect
operator|.
name|origin_x
expr_stmt|;
comment|/* 		 * Take the max value of the clipping rectangle Y origin 		 * coord, bitmap rectangle Y origin coord. and the 		 * destination rectangle Y origin coord..  Oydiff 		 * contains the difference between dst_rect.origin_y and 		 * the value returned.  Then convert to a zero based 		 * coordinate system. 		 */
name|max_a
argument_list|(
name|u_info
operator|->
name|dst_rect
operator|.
name|origin_y
argument_list|,
name|u_info
operator|->
name|clp_rect
operator|.
name|origin_y
argument_list|,
name|u_info
operator|->
name|dst_bitmap
operator|.
name|rect
operator|.
name|origin_y
argument_list|,
name|y_orig
argument_list|,
name|Oydiff
argument_list|)
expr_stmt|;
name|y_orig
operator|-=
name|u_info
operator|->
name|dst_bitmap
operator|.
name|rect
operator|.
name|origin_y
expr_stmt|;
comment|/* 		 * Take the min value of the clipping rectangle Y corner 		 * coord, bitmap rectangle Y corner coord. and the 		 * destination rectangle Y corner coord..  Cydiff 		 * contains the difference between dst_rect.corner_y and 		 * the value returned.  Then convert to a zero based 		 * coordinate system. 		 */
name|min_a
argument_list|(
name|u_info
operator|->
name|dst_rect
operator|.
name|corner_y
argument_list|,
name|u_info
operator|->
name|clp_rect
operator|.
name|corner_y
argument_list|,
name|u_info
operator|->
name|dst_bitmap
operator|.
name|rect
operator|.
name|corner_y
argument_list|,
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_y
argument_list|,
name|Cydiff
argument_list|)
expr_stmt|;
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_y
operator|-=
name|u_info
operator|->
name|dst_bitmap
operator|.
name|rect
operator|.
name|origin_y
expr_stmt|;
comment|/*  *		printf("dst:\t%4d,%4d,%4d,%4d\n",x_orig,  *			y_orig,s_info->dst.rect.corner_x,  *			s_info->dst.rect.corner_y);  *		printf("diffs:\t%4d,%4d,%4d,%4d\n",Oxdiff,Oydiff,Cxdiff,Cydiff);  */
comment|/* 		 * Adjust source if necessary. (May only be using a tile.) 		 */
if|if
condition|(
name|s_info
operator|->
name|is_src
condition|)
block|{
comment|/* 			 * We may have done some clipping. If X was clipped 			 * then the section of the source that would have 			 * been mapped to the clipped section of the 			 * destination must also be clipped. 			 *      In other words if one clips the destination one 			 * must also clip the source.  Anyways 'Oxdiff' is set 			 * to the difference.  Then we subtract the rect 			 * of the source bitmap so as to get the source into 			 * the same coordinate system as the destination, 			 * a zero based system. 			 */
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_x
operator|=
name|u_info
operator|->
name|src_rect
operator|.
name|origin_x
operator|+
name|Oxdiff
operator|-
name|u_info
operator|->
name|src_bitmap
operator|.
name|rect
operator|.
name|origin_x
expr_stmt|;
comment|/* 			 * If Y was clipped then the section of source 			 * that would have mapped to the clipped section 			 * of the destination must also be clipped. 			 */
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_y
operator|=
name|u_info
operator|->
name|src_rect
operator|.
name|origin_y
operator|+
name|Oydiff
operator|-
name|u_info
operator|->
name|src_bitmap
operator|.
name|rect
operator|.
name|origin_y
expr_stmt|;
comment|/* 			 * Now clip to the source bitmap's origin which is 			 * now 0,0 because we subtracted its origin above. 			 */
if|if
condition|(
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_x
operator|<
literal|0
condition|)
block|{
comment|/* 				 * The source rectangle has been clipped so 				 * the destination rectangle must also be 				 * clipped. 				 */
name|x_orig
operator|-=
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_x
expr_stmt|;
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_x
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_y
operator|<
literal|0
condition|)
block|{
comment|/* 				 * The source rectangle has been clipped so 				 * the destination rectangle must also be 				 * clipped. 				 */
name|y_orig
operator|-=
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_y
expr_stmt|;
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_y
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * Calculate the source rectangle's corner rect. 			 * NOTE: We are not setting these rect to a zero 			 *       based system yet. 			 */
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|corner_x
operator|=
name|u_info
operator|->
name|src_rect
operator|.
name|corner_x
operator|-
name|Cxdiff
expr_stmt|;
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|corner_y
operator|=
name|u_info
operator|->
name|src_rect
operator|.
name|corner_y
operator|-
name|Cydiff
expr_stmt|;
comment|/* 			 * Clip these rect to the corner of the source 			 * bitmap corner rect. 			 */
if|if
condition|(
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|corner_x
operator|>
name|u_info
operator|->
name|src_bitmap
operator|.
name|rect
operator|.
name|corner_x
condition|)
block|{
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|corner_x
operator|=
name|u_info
operator|->
name|src_bitmap
operator|.
name|rect
operator|.
name|corner_x
expr_stmt|;
block|}
if|if
condition|(
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|corner_y
operator|>
name|u_info
operator|->
name|src_bitmap
operator|.
name|rect
operator|.
name|corner_y
condition|)
block|{
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|corner_y
operator|=
name|u_info
operator|->
name|src_bitmap
operator|.
name|rect
operator|.
name|corner_y
expr_stmt|;
block|}
comment|/* 			 * Now set these rect to a zero based coordinate 			 * system. 			 */
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|corner_x
operator|-=
name|u_info
operator|->
name|src_bitmap
operator|.
name|rect
operator|.
name|origin_x
expr_stmt|;
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|corner_y
operator|-=
name|u_info
operator|->
name|src_bitmap
operator|.
name|rect
operator|.
name|origin_y
expr_stmt|;
comment|/* 			 * Calculate the width in pixels of the blt area 			 * using the smaller of the two widths found in 			 * the source and destination rectangles. 			 */
if|if
condition|(
operator|(
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|corner_x
operator|-
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_x
operator|)
operator|>
operator|(
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_x
operator|-
name|x_orig
operator|)
condition|)
block|{
name|s_info
operator|->
name|width
operator|=
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_x
operator|-
name|x_orig
expr_stmt|;
block|}
else|else
block|{
name|s_info
operator|->
name|width
operator|=
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|corner_x
operator|-
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_x
expr_stmt|;
comment|/* 				 * Must change the destination corner. 				 */
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_x
operator|=
name|x_orig
operator|+
name|s_info
operator|->
name|width
expr_stmt|;
block|}
comment|/* 			 * Calculate the height in scanlines of the blt area 			 * using the smaller of the two heights found in  			 * the source and destination rectangles. 			 */
if|if
condition|(
operator|(
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|corner_y
operator|-
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_y
operator|)
operator|>
operator|(
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_y
operator|-
name|y_orig
operator|)
condition|)
block|{
name|s_info
operator|->
name|height
operator|=
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_y
operator|-
name|y_orig
expr_stmt|;
block|}
else|else
block|{
name|s_info
operator|->
name|height
operator|=
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|corner_y
operator|-
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_y
expr_stmt|;
comment|/* 				 * Must change the destination corner. 				 */
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_y
operator|=
name|y_orig
operator|+
name|s_info
operator|->
name|height
expr_stmt|;
block|}
comment|/* 			 * Set up source corners to BE CLOSED CORNERS. 			 * This is done because alot of -1's are being used in 			 * calculations of pointers when copying bitmaps from 			 * corner_y to origin_y, corner_x to origin_x. 			 * (for copyBitNeg(), see calculateOffsets()) 			 */
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_x
operator|=
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_x
expr_stmt|;
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_y
operator|=
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_y
expr_stmt|;
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|corner_x
operator|=
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_x
operator|+
name|s_info
operator|->
name|width
operator|-
literal|1
expr_stmt|;
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|corner_y
operator|=
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_y
operator|+
name|s_info
operator|->
name|height
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Calculate the width in pixels and the height in 			 * scanlines. 			 */
name|s_info
operator|->
name|width
operator|=
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_x
operator|-
name|x_orig
expr_stmt|;
name|s_info
operator|->
name|height
operator|=
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_y
operator|-
name|y_orig
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Assume that the user has set everything up legally and 		 * all we have to do is set up our bltter (internal) 		 * coordinates. 		 * 		 * Set up the x origin and width. 		 */
name|x_orig
operator|=
name|u_info
operator|->
name|dst_rect
operator|.
name|origin_x
expr_stmt|;
name|s_info
operator|->
name|width
operator|=
name|u_info
operator|->
name|dst_rect
operator|.
name|corner_x
operator|-
name|x_orig
expr_stmt|;
comment|/* 		 * Set up y origin and height. 		 */
name|y_orig
operator|=
name|u_info
operator|->
name|dst_rect
operator|.
name|origin_y
expr_stmt|;
name|s_info
operator|->
name|height
operator|=
name|u_info
operator|->
name|dst_rect
operator|.
name|corner_y
operator|-
name|y_orig
expr_stmt|;
comment|/* 		 * Convert to zero based coordinate system. 		 */
name|x_orig
operator|-=
name|u_info
operator|->
name|dst_bitmap
operator|.
name|rect
operator|.
name|origin_x
expr_stmt|;
name|y_orig
operator|-=
name|u_info
operator|->
name|dst_bitmap
operator|.
name|rect
operator|.
name|origin_y
expr_stmt|;
comment|/* 		 * Set up the destination corners. 		 */
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_x
operator|=
name|x_orig
operator|+
name|s_info
operator|->
name|width
expr_stmt|;
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_y
operator|=
name|y_orig
operator|+
name|s_info
operator|->
name|height
expr_stmt|;
comment|/* 		 * Adjust source if necessary. (May only be using a tile.) 		 */
if|if
condition|(
name|s_info
operator|->
name|is_src
condition|)
block|{
comment|/* 			 * We must have source and destination coordinates 			 * which are in the same coordinate system, a 			 * zero-based coordinate system in this case. 			 */
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_x
operator|=
name|u_info
operator|->
name|src_rect
operator|.
name|origin_x
operator|-
name|u_info
operator|->
name|src_bitmap
operator|.
name|rect
operator|.
name|origin_x
expr_stmt|;
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_y
operator|=
name|u_info
operator|->
name|src_rect
operator|.
name|origin_y
operator|-
name|u_info
operator|->
name|src_bitmap
operator|.
name|rect
operator|.
name|origin_y
expr_stmt|;
comment|/* 			 * Set up source corners to BE CLOSED CORNERS. 			 * This is done because alot of -1's are being used in 			 * calculations of pointers when copying bitmaps from 			 * corner_y to origin_y, corner_x to origin_x. 			 * (for copyBitNeg(), see calculateOffsets()) 			 */
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|corner_x
operator|=
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_x
operator|+
name|s_info
operator|->
name|width
operator|-
literal|1
expr_stmt|;
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|corner_y
operator|=
name|s_info
operator|->
name|src
operator|.
name|rect
operator|.
name|origin_y
operator|+
name|s_info
operator|->
name|height
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Keep the final rectangle for outside use.  (Others can extern 	 * changed_rect.) 	 */
name|changed_rect
operator|.
name|origin_x
operator|=
name|x_orig
expr_stmt|;
name|changed_rect
operator|.
name|origin_y
operator|=
name|y_orig
expr_stmt|;
name|changed_rect
operator|.
name|corner_x
operator|=
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_x
expr_stmt|;
name|changed_rect
operator|.
name|corner_y
operator|=
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_y
expr_stmt|;
comment|/* 	 * Set up destination corners to BE CLOSED CORNERS.  This is done 	 * because alot of -1's are being used in calculations of pointers when  	 * copying bitmaps from corner_y to origin_y, corner_x to 	 * origin_x. (for copyBitNeg(), see calculateOffsets()) 	 */
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_x
operator|-=
literal|1
expr_stmt|;
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_y
operator|-=
literal|1
expr_stmt|;
comment|/* 	 * Set up the number of words across the destination that will be 	 * affected. (Because we subracted one we don't have to subtract one 	 * from dst.rect.corner_x.) 	 */
if|if
condition|(
operator|(
name|s_info
operator|->
name|nshorts
operator|=
operator|(
name|DIV_BPW
argument_list|(
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_x
argument_list|)
operator|-
name|DIV_BPW
argument_list|(
name|x_orig
argument_list|)
operator|)
operator|+
literal|1
operator|)
operator|<
literal|1
condition|)
block|{
comment|/* 		 * nshorts should always be positive. 		 */
name|DEBUGF
argument_list|(
operator|(
name|blt_debug
operator|)
argument_list|,
name|printf
argument_list|(
literal|"dst cx,ox: %d,%d nshorts = %d - %d\n"
argument_list|,
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_x
argument_list|,
name|x_orig
argument_list|,
name|DIV_BPW
argument_list|(
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_x
argument_list|)
argument_list|,
name|DIV_BPW
argument_list|(
name|x_orig
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DEBUGF
argument_list|(
operator|(
name|blt_debug
operator|)
argument_list|,
name|printf
argument_list|(
literal|"dst cx,ox: %d,%d nshorts = %d - %d, (IS %d)\n"
argument_list|,
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_x
argument_list|,
name|x_orig
argument_list|,
name|DIV_BPW
argument_list|(
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|corner_x
argument_list|)
argument_list|,
name|DIV_BPW
argument_list|(
name|x_orig
argument_list|)
argument_list|,
name|s_info
operator|->
name|nshorts
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * NOTE: This program ASSUMES that msk_bitmap's bounds are within 	 *	 the bounds of the msk_bitmap.  If not, bummer. 	 * 	 * Mask bitmap specified?? Set up mask corners. 	 */
if|if
condition|(
name|u_info
operator|->
name|blt_flags
operator|&
name|BLT_MASKON
condition|)
block|{
comment|/* 		 * Currently, the msk_bitmap's rect is in destination 		 * coordinates and msk_bitmap.rect picks out the area of the 		 * mask to be used. 		 *  		 * Align the mask bitmap with the destination rectangle. 		 * Because the x_orig is zero based and the 		 * msk_bitmap box is not we add back the dst_bitmap.rect. 		 * This has the effect of putting the mask corners into 		 * a zero based coordinate system. 		 */
name|s_info
operator|->
name|msk
operator|.
name|rect
operator|.
name|origin_x
operator|=
name|x_orig
operator|+
name|u_info
operator|->
name|dst_bitmap
operator|.
name|rect
operator|.
name|origin_x
operator|-
name|u_info
operator|->
name|msk_bitmap
operator|.
name|rect
operator|.
name|origin_x
expr_stmt|;
name|s_info
operator|->
name|msk
operator|.
name|rect
operator|.
name|corner_x
operator|=
name|s_info
operator|->
name|msk
operator|.
name|rect
operator|.
name|origin_x
operator|+
name|s_info
operator|->
name|width
operator|-
literal|1
expr_stmt|;
name|s_info
operator|->
name|msk
operator|.
name|rect
operator|.
name|origin_y
operator|=
name|y_orig
operator|+
name|u_info
operator|->
name|dst_bitmap
operator|.
name|rect
operator|.
name|origin_y
operator|-
name|u_info
operator|->
name|msk_bitmap
operator|.
name|rect
operator|.
name|origin_y
expr_stmt|;
name|s_info
operator|->
name|msk
operator|.
name|rect
operator|.
name|corner_y
operator|=
name|s_info
operator|->
name|msk
operator|.
name|rect
operator|.
name|origin_y
operator|+
name|s_info
operator|->
name|height
operator|-
literal|1
expr_stmt|;
comment|/* 		 * At some point it may be smart to check the clip flag and 		 * clip this also. 		 * 		 * if (u_info->blt_flags& BLT_CLIPON) { 		 * } 		 */
block|}
comment|/* 	 * Set the temp varibles into the system data structure. 	 */
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|origin_x
operator|=
name|x_orig
expr_stmt|;
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|origin_y
operator|=
name|y_orig
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * This part of this file should be moved to another file someday.  */
end_comment

begin_define
define|#
directive|define
name|MSK_SKEW
value|0x01
end_define

begin_define
define|#
directive|define
name|SRC_SKEW
value|0x02
end_define

begin_comment
comment|/*  * Macros for the operations.  */
end_comment

begin_define
define|#
directive|define
name|SrcCopy_MASK
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					    ((src)& mask)
end_define

begin_comment
comment|/*  * Old SrcOr rule.  * #define SrcOr_MASK(src,dst,mask)      dst = ((dst)& ~(mask)) |  \  *					    (((dst) | (src))& mask)  */
end_comment

begin_define
define|#
directive|define
name|SrcOr_MASK
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst) | ((src)& mask))
end_define

begin_comment
comment|/*  * Old SrcXor rule.  * #define SrcXor_MASK(src,dst,mask)     dst = ((dst)& ~(mask)) |  \  *					    (((dst) ^ (src))& mask)  */
end_comment

begin_define
define|#
directive|define
name|SrcXor_MASK
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst) ^ ((src)& mask))
end_define

begin_define
define|#
directive|define
name|SrcAnd_MASK
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					    (((dst)& (src))& mask)
end_define

begin_define
define|#
directive|define
name|NotSrcCopy_MASK
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					    (~(src)& mask)
end_define

begin_comment
comment|/*  * Old NotSrcOr rule.  * #define NotSrcOr_MASK(src,dst,mask)   dst = ((dst)& ~(mask)) |  \  *					    (((dst) | ~(src))& mask)  */
end_comment

begin_define
define|#
directive|define
name|NotSrcOr_MASK
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst) | (~(src)& mask))
end_define

begin_comment
comment|/*  * Old NotSrcXor rule.  * #define NotSrcXor_MASK(src,dst,mask)  dst = ((dst)& ~(mask)) |  \  *					    (((dst) ^ ~(src))& mask)  */
end_comment

begin_define
define|#
directive|define
name|NotSrcXor_MASK
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst) ^ (~(src)& mask))
end_define

begin_define
define|#
directive|define
name|NotSrcAnd_MASK
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					    (((dst)& ~(src))& mask)
end_define

begin_comment
comment|/*  * DstCopy is a no-op.  */
end_comment

begin_define
define|#
directive|define
name|SrcAndNotDst_MASK
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					      ((~(dst)& (src))& mask)
end_define

begin_define
define|#
directive|define
name|SrcOrNotDst_MASK
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					         ((~(dst) | (src))& mask)
end_define

begin_define
define|#
directive|define
name|NotDstCopy_MASK
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) | \ 						 (~(dst)& (mask))
end_define

begin_define
define|#
directive|define
name|NotSrcAndNotDst_MASK
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					         ((~(dst)& ~(src))& mask)
end_define

begin_define
define|#
directive|define
name|NotSrcOrNotDst_MASK
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					         ((~(dst) | ~(src))& mask)
end_define

begin_define
define|#
directive|define
name|SrcCopy_OP
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
value|dst = (src)
end_define

begin_define
define|#
directive|define
name|SrcOr_OP
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
value|dst = (dst) | (src)
end_define

begin_define
define|#
directive|define
name|SrcXor_OP
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
value|dst = (dst) ^ (src)
end_define

begin_define
define|#
directive|define
name|SrcAnd_OP
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
value|dst = (dst)& (src)
end_define

begin_define
define|#
directive|define
name|NotSrcCopy_OP
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
value|dst = ~(src)
end_define

begin_define
define|#
directive|define
name|NotSrcOr_OP
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
value|dst = (dst) | ~(src)
end_define

begin_define
define|#
directive|define
name|NotSrcXor_OP
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
value|dst = (dst) ^ ~(src)
end_define

begin_define
define|#
directive|define
name|NotSrcAnd_OP
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
value|dst = (dst)& ~(src)
end_define

begin_comment
comment|/*  * DstCopy is a no-op (dst = (dst)).  */
end_comment

begin_define
define|#
directive|define
name|SrcOrNotDst_OP
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
value|dst = (~(dst) | (src))
end_define

begin_define
define|#
directive|define
name|SrcAndNotDst_OP
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
value|dst = (~(dst)& (src))
end_define

begin_define
define|#
directive|define
name|NotDstCopy_OP
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
value|dst = ~(dst)
end_define

begin_define
define|#
directive|define
name|NotSrcOrNotDst_OP
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
value|dst = (~(dst) | ~(src))
end_define

begin_define
define|#
directive|define
name|NotSrcAndNotDst_OP
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
value|dst = (~(dst)& ~(src))
end_define

begin_comment
comment|/*  * Make the mask and operation macros for tiles.  */
end_comment

begin_define
define|#
directive|define
name|TileCopy_MASK
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					      ((tile)& mask)
end_define

begin_define
define|#
directive|define
name|TileOr_MASK
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					      (((dst) | (tile))& mask)
end_define

begin_define
define|#
directive|define
name|TileXor_MASK
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					      (((dst) ^ (tile))& mask)
end_define

begin_define
define|#
directive|define
name|NotTileAnd_MASK
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					      (((dst)& ~(tile))& mask)
end_define

begin_define
define|#
directive|define
name|NotTileCopy_MASK
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					      (~(tile)& mask)
end_define

begin_define
define|#
directive|define
name|NotTileOr_MASK
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					      (((dst) | ~(tile))& mask)
end_define

begin_define
define|#
directive|define
name|NotTileXor_MASK
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					      (((dst) ^ ~(tile))& mask)
end_define

begin_define
define|#
directive|define
name|TileAnd_MASK
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					      (((dst)& (tile))& mask)
end_define

begin_define
define|#
directive|define
name|TileOrNotDst_MASK
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					            ((~(dst) | (tile))& mask)
end_define

begin_define
define|#
directive|define
name|NotTileAndNotDst_MASK
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					            ((~(dst)& ~(tile))& mask)
end_define

begin_define
define|#
directive|define
name|NotTileOrNotDst_MASK
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					            ((~(dst) | ~(tile))& mask)
end_define

begin_define
define|#
directive|define
name|TileAndNotDst_MASK
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|,
name|mask
parameter_list|)
value|dst = ((dst)& ~(mask)) |  \ 					            ((~(dst)& (tile))& mask)
end_define

begin_define
define|#
directive|define
name|TileCopy_OP
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|)
value|dst = (tile)
end_define

begin_define
define|#
directive|define
name|TileOr_OP
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|)
value|dst = (dst) | (tile)
end_define

begin_define
define|#
directive|define
name|TileXor_OP
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|)
value|dst = (dst) ^ (tile)
end_define

begin_define
define|#
directive|define
name|NotTileAnd_OP
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|)
value|dst = (dst)& ~(tile)
end_define

begin_define
define|#
directive|define
name|NotTileCopy_OP
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|)
value|dst = ~(tile)
end_define

begin_define
define|#
directive|define
name|NotTileOr_OP
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|)
value|dst = (dst) | ~(tile)
end_define

begin_define
define|#
directive|define
name|NotTileXor_OP
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|)
value|dst = (dst) ^ ~(tile)
end_define

begin_define
define|#
directive|define
name|TileAnd_OP
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|)
value|dst = (dst)& (tile)
end_define

begin_define
define|#
directive|define
name|TileOrNotDst_OP
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|)
value|dst = ~(dst) | (tile)
end_define

begin_define
define|#
directive|define
name|NotTileAndNotDst_OP
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|)
value|dst = ~(dst)& ~(tile)
end_define

begin_define
define|#
directive|define
name|NotTileOrNotDst_OP
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|)
value|dst = ~(dst) | ~(tile)
end_define

begin_define
define|#
directive|define
name|TileAndNotDst_OP
parameter_list|(
name|tile
parameter_list|,
name|dst
parameter_list|)
value|dst = ~(dst)& (tile)
end_define

begin_if
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
end_if

begin_comment
comment|/*  * Defines for how a pointer is incremented.  This is needed because one must  * increment a pointer to the APA-8 bitmap by 2.  */
end_comment

begin_define
define|#
directive|define
name|DECR_SRC
parameter_list|(
name|src
parameter_list|)
value|src -= src_plus
end_define

begin_define
define|#
directive|define
name|DECR_DST
parameter_list|(
name|dst
parameter_list|)
value|dst -= dst_plus
end_define

begin_define
define|#
directive|define
name|INCR_SRC
parameter_list|(
name|src
parameter_list|)
value|src += src_plus
end_define

begin_define
define|#
directive|define
name|INCR_DST
parameter_list|(
name|dst
parameter_list|)
value|dst += dst_plus
end_define

begin_define
define|#
directive|define
name|MINUS_SRC
parameter_list|(
name|src
parameter_list|)
value|((unsigned short *)(src - src_plus))
end_define

begin_define
define|#
directive|define
name|PLUS_SRC
parameter_list|(
name|src
parameter_list|)
value|((unsigned short *)(src + src_plus))
end_define

begin_else
else|#
directive|else
else|no APA8 stuff
end_else

begin_comment
comment|/*  * Defines for how normal pointers are incremented.  */
end_comment

begin_define
define|#
directive|define
name|DECR_SRC
parameter_list|(
name|src
parameter_list|)
value|(src -= 2)
end_define

begin_define
define|#
directive|define
name|DECR_DST
parameter_list|(
name|dst
parameter_list|)
value|(dst -= 2)
end_define

begin_define
define|#
directive|define
name|INCR_SRC
parameter_list|(
name|src
parameter_list|)
value|(src += 2)
end_define

begin_define
define|#
directive|define
name|INCR_DST
parameter_list|(
name|dst
parameter_list|)
value|(dst += 2)
end_define

begin_define
define|#
directive|define
name|MINUS_SRC
parameter_list|(
name|src
parameter_list|)
value|((unsigned short *)(src - 2))
end_define

begin_define
define|#
directive|define
name|PLUS_SRC
parameter_list|(
name|src
parameter_list|)
value|((unsigned short *)(src + 2))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SRC
value|((unsigned short *)src)
end_define

begin_define
define|#
directive|define
name|DST
value|((unsigned short *)dst)
end_define

begin_define
define|#
directive|define
name|TILE
value|((unsigned short *)tile)
end_define

begin_define
define|#
directive|define
name|MSK
value|((unsigned short *)msk)
end_define

begin_define
define|#
directive|define
name|CLP
value|((unsigned short *)clp)
end_define

begin_define
define|#
directive|define
name|DECR_MSK
parameter_list|(
name|msk
parameter_list|)
value|(msk -= 2)
end_define

begin_define
define|#
directive|define
name|INCR_MSK
parameter_list|(
name|msk
parameter_list|)
value|(msk += 2)
end_define

begin_define
define|#
directive|define
name|MINUS_MSK
parameter_list|(
name|msk
parameter_list|)
value|((unsigned short *)(msk - 2))
end_define

begin_define
define|#
directive|define
name|PLUS_MSK
parameter_list|(
name|msk
parameter_list|)
value|((unsigned short *)(msk + 2))
end_define

begin_define
define|#
directive|define
name|DECR_CLP
parameter_list|(
name|clp
parameter_list|)
value|(clp -= 2)
end_define

begin_define
define|#
directive|define
name|INCR_CLP
parameter_list|(
name|clp
parameter_list|)
value|(clp += 2)
end_define

begin_define
define|#
directive|define
name|MINUS_CLP
parameter_list|(
name|clp
parameter_list|)
value|((unsigned short *)(clp - 2))
end_define

begin_define
define|#
directive|define
name|PLUS_CLP
parameter_list|(
name|clp
parameter_list|)
value|((unsigned short *)(clp + 2))
end_define

begin_comment
comment|/*  * Macro to increment the tile pointer.  If last_ptr is reached then the  * pointer is decremented back to the beginning of the tile struct.  */
end_comment

begin_define
define|#
directive|define
name|INCR_TILE_PTR
parameter_list|(
name|ptr
parameter_list|,
name|last_ptr
parameter_list|)
value|((ptr==last_ptr) ? (ptr -= 30) : (ptr += 2))
end_define

begin_comment
comment|/*  * This loop copies bits from right to left, bottom to top.  It takes as  * arguments 1 of 8 masking macros and the coorisponding generic macro.  * The general scheme is this:  *	Foreach row do  *		Take care of the first word priming if necessary. (Done because  *			the first word uses the RIGHT edge mask.)  *  *		If there is a skew then (Means parts of 2 source words make one  *			destination word.)  *			For each word between the first and last word do  *				Shift the source word and source word -1 and  *					write the word to the destination.  *			endfor  *  *			Take care of the last word. (Done here and not in   *				the loop because the last word uses the   *				LEFT edge mask.)  *   *		else  The skew is zero meaning 1 source word per destination  *		      word.  *   *			For each word between the first and last word do  *				Write the source word into the destination word.  *			endfor  *  *			Take care of the last word. (Done here and not in   *				the loop because the last word uses the   *				LEFT edge mask.)  *		endif  *  *		DECREMENT the source and destination pointers to point to the  *			next row.  *	endfor  *  */
end_comment

begin_define
define|#
directive|define
name|copyBitNeg_LOOP
parameter_list|(
name|EDGE_OP
parameter_list|,
name|OP
parameter_list|)
value|{					\ 	while (--s_info->height) {					\ 		wordnum = s_info->nshorts;				\ 		if (s_info->preload_src) {				\ 			EDGE_OP((*SRC>> skew_src) |			\ 				(*(MINUS_SRC(src))<< (inv_skew_src)),	\ 				*DST,s_info->right_mask);		\ 			DECR_SRC(src);					\ 		}							\ 		else {							\ 			EDGE_OP((*SRC<< (inv_skew_src)),*DST,		\ 				s_info->right_mask);			\ 		}							\ 		if (--wordnum != 0) {					\ 			DECR_DST(dst);					\ 			if (skew_src& 0xf) {				\ 				while (wordnum> 1) {			\ 					OP((*SRC>> skew_src) |		\ 					   (*(MINUS_SRC(src))<<(inv_skew_src)),\ 					   *DST);			\ 					DECR_SRC(src);			\ 					DECR_DST(dst);			\ 					wordnum--;			\ 				}					\ 				EDGE_OP((*SRC>> skew_src) |		\ 					(*(MINUS_SRC(src))<< (inv_skew_src)),\ 					*DST,s_info->left_mask);	\ 				DECR_SRC(src);				\ 			}						\ 			else {						\ 				while (wordnum> 1) {			\ 					DECR_SRC(src);			\ 					OP(*SRC,*DST);			\ 					DECR_DST(dst);			\ 					wordnum--;			\ 				}					\ 				DECR_SRC(src);				\ 				EDGE_OP(*SRC,*DST,s_info->left_mask);	\ 			}						\ 		}							\ 	src -= s_info->src.nextline;					\ 	dst -= s_info->dst.nextline;					\ 	}								\ }
end_define

begin_comment
comment|/*  * Do setup and dereferencing of 5 of the most important Blt_sysdata variables.  * Then do a switch on the combination rule to do the correct loop.  Each loop  * copies from right to left, bottom to top.  */
end_comment

begin_expr_stmt
name|copyBitNeg
argument_list|(
name|s_info
argument_list|)
specifier|register
name|Blt_sysdata
operator|*
name|s_info
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Register pointers are declared as  */
comment|/* unsigned char pointers. This is an */
specifier|register
name|unsigned
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* optimization to get around extra   */
comment|/* addressing in the assembler.       */
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
specifier|register
name|int
name|src_plus
decl_stmt|;
specifier|register
name|int
name|dst_plus
decl_stmt|;
endif|#
directive|endif
specifier|register
name|int
name|wordnum
decl_stmt|;
specifier|register
name|int
name|skew_src
decl_stmt|;
specifier|register
name|int
name|inv_skew_src
decl_stmt|;
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
name|src_plus
operator|=
name|s_info
operator|->
name|src_plus
expr_stmt|;
name|dst_plus
operator|=
name|s_info
operator|->
name|dst_plus
expr_stmt|;
endif|#
directive|endif
name|src
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s_info
operator|->
name|src
operator|.
name|data
expr_stmt|;
name|dst
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s_info
operator|->
name|dst
operator|.
name|data
expr_stmt|;
comment|/* 	 * Set up the inverted skew number which is used to shift stuff the 	 * other direction. 	 */
name|skew_src
operator|=
name|s_info
operator|->
name|skew_src
expr_stmt|;
name|inv_skew_src
operator|=
name|BPW
operator|-
name|skew_src
expr_stmt|;
name|DEBUGF
argument_list|(
name|blt_debug
argument_list|,
name|printf
argument_list|(
literal|"Enter copyBitNeg s:%d,p:%d,ws:%d r:%d\r\n"
argument_list|,
name|s_info
operator|->
name|skew_src
argument_list|,
name|s_info
operator|->
name|preload_src
argument_list|,
name|s_info
operator|->
name|nshorts
argument_list|,
name|s_info
operator|->
name|rule
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Compiler optimization: a pre-decrement in a while loop saves a test 	 * in assembly language for every iteration. 	 */
name|s_info
operator|->
name|height
operator|+=
literal|1
expr_stmt|;
switch|switch
condition|(
name|s_info
operator|->
name|rule
condition|)
block|{
case|case
name|SrcCopy
case|:
name|copyBitNeg_LOOP
argument_list|(
name|SrcCopy_MASK
argument_list|,
name|SrcCopy_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcOr
case|:
name|copyBitNeg_LOOP
argument_list|(
name|SrcOr_MASK
argument_list|,
name|SrcOr_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcXor
case|:
name|copyBitNeg_LOOP
argument_list|(
name|SrcXor_MASK
argument_list|,
name|SrcXor_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcAnd
case|:
name|copyBitNeg_LOOP
argument_list|(
name|NotSrcAnd_MASK
argument_list|,
name|NotSrcAnd_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcCopy
case|:
name|copyBitNeg_LOOP
argument_list|(
name|NotSrcCopy_MASK
argument_list|,
name|NotSrcCopy_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcOr
case|:
name|copyBitNeg_LOOP
argument_list|(
name|NotSrcOr_MASK
argument_list|,
name|NotSrcOr_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcXor
case|:
name|copyBitNeg_LOOP
argument_list|(
name|NotSrcXor_MASK
argument_list|,
name|NotSrcXor_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcAnd
case|:
name|copyBitNeg_LOOP
argument_list|(
name|SrcAnd_MASK
argument_list|,
name|SrcAnd_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcAndNotDst
case|:
name|copyBitNeg_LOOP
argument_list|(
name|SrcAndNotDst_MASK
argument_list|,
name|SrcAndNotDst_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcAndNotDst
case|:
name|copyBitNeg_LOOP
argument_list|(
name|NotSrcAndNotDst_MASK
argument_list|,
name|NotSrcAndNotDst_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcOrNotDst
case|:
name|copyBitNeg_LOOP
argument_list|(
name|SrcOrNotDst_MASK
argument_list|,
name|SrcOrNotDst_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcOrNotDst
case|:
name|copyBitNeg_LOOP
argument_list|(
name|NotSrcOrNotDst_MASK
argument_list|,
name|NotSrcOrNotDst_OP
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_if
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
end_if

begin_define
define|#
directive|define
name|I_SRC
value|src_plus
end_define

begin_define
define|#
directive|define
name|I_DST
value|dst_plus
end_define

begin_else
else|#
directive|else
else|no APA8 stuff
end_else

begin_define
define|#
directive|define
name|I_SRC
value|2
end_define

begin_define
define|#
directive|define
name|I_DST
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This loop copies bits from left to right, top to bottom.  It takes as  * arguments 1 of 8 masking macros and the coorisponding generic macro.  * The general scheme is this:  *	Foreach row do  *		Take care of the first word priming if necessary. (Done because  *			the first word uses the LEFT edge mask.)  *  *		If there is a skew then (Means parts of 2 source words make one  *			destination word.)  *			For each word between the first and last word do  *				Shift the source word and source word +1 and  *					write the word to the destination.  *			endfor  *  *			Take care of the last word. (Done here and not in   *				the loop because the last word uses the   *				RIGHT edge mask.)  *   *		else  The skew is zero meaning 1 source word per destination  *		      word.  *   *			For each word between the first and last word do  *				Write the source word into the destination word  *			endfor  *  *			Take care of the last word. (Done here and not in   *				the loop because the last word uses the   *				RIGHT edge mask.)  *		endif  *  *		INCREMENT the source and destination pointers to point to the  *			next row.  *	endfor  *  */
end_comment

begin_define
define|#
directive|define
name|copyBitPos_LOOP
parameter_list|(
name|EDGE_OP
parameter_list|,
name|OP
parameter_list|)
value|{					\ 	while (--s_info->height) {					\ 		wordnum = s_info->nshorts;				\ 		if (s_info->preload_src) {				\ 			EDGE_OP((*SRC<< skew_src) |			\ 				(*(PLUS_SRC(src))>> (inv_skew_src)),*DST,\ 				s_info->left_mask);			\ 			INCR_SRC(src);					\ 		}							\ 		else {							\ 			EDGE_OP((*SRC>>(inv_skew_src)),*DST,s_info->left_mask);\ 		}							\ 		if (--wordnum != 0) {					\ 			INCR_DST(dst);					\ 			if (skew_src& 0xf) {				\ 				while (wordnum--> 1) {			\ 					OP((*SRC<< skew_src) |		\ 					  (*(PLUS_SRC(src))>> (inv_skew_src)),\ 					   *DST);			\ 					INCR_DST(dst);			\ 					INCR_SRC(src);			\ 				}					\ 				EDGE_OP((*SRC<< skew_src) |		\ 					(*(PLUS_SRC(src))>> (inv_skew_src)),\ 					*DST,s_info->right_mask);	   \ 				INCR_SRC(src);				   \ 			}					   	   \ 			else {			   			   \ 				while (wordnum--> 1) {			   \ 					INCR_SRC(src);			   \ 					OP(*SRC,*DST);			   \ 					INCR_DST(dst);			   \ 				}				   	   \ 				INCR_SRC(src);				   \ 				EDGE_OP(*SRC,*DST,s_info->right_mask);	   \ 			}						   \ 		}							   \ 		src += s_info->src.nextline;				   \ 		dst += s_info->dst.nextline;				   \ 	}								   \ }
end_define

begin_comment
comment|/*  * Do setup and dereferencing of 5 of the most important Blt_sysdata variables.  * Then do a switch on the combination rule to do the correct loop.  Each loop  * copies from left to right, top to bottom .  */
end_comment

begin_expr_stmt
name|copyBitPos
argument_list|(
name|s_info
argument_list|)
specifier|register
name|Blt_sysdata
operator|*
name|s_info
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Register pointers are declared as  */
comment|/* unsigned char pointers. This is an */
specifier|register
name|unsigned
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* optimization to get around extra   */
comment|/* addressing in the assembler.       */
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
specifier|register
name|int
name|src_plus
decl_stmt|;
specifier|register
name|int
name|dst_plus
decl_stmt|;
endif|#
directive|endif
specifier|register
name|int
name|wordnum
decl_stmt|;
specifier|register
name|int
name|skew_src
decl_stmt|;
specifier|register
name|int
name|inv_skew_src
decl_stmt|;
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
name|src_plus
operator|=
name|s_info
operator|->
name|src_plus
expr_stmt|;
name|dst_plus
operator|=
name|s_info
operator|->
name|dst_plus
expr_stmt|;
endif|#
directive|endif
name|src
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s_info
operator|->
name|src
operator|.
name|data
expr_stmt|;
name|dst
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s_info
operator|->
name|dst
operator|.
name|data
expr_stmt|;
name|skew_src
operator|=
name|s_info
operator|->
name|skew_src
expr_stmt|;
name|inv_skew_src
operator|=
name|BPW
operator|-
name|skew_src
expr_stmt|;
name|DEBUGF
argument_list|(
name|blt_debug
argument_list|,
name|printf
argument_list|(
literal|"Enter copyBitPos:%d,%d,%d,%d\r\n"
argument_list|,
name|s_info
operator|->
name|skew_src
argument_list|,
name|inv_skew_src
argument_list|,
name|s_info
operator|->
name|preload_src
argument_list|,
name|s_info
operator|->
name|rule
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * foreach row do. 	 * 	 * Compiler optimization: a pre-decrement in a while loop saves a test 	 * in assembly language for every iteration. 	 */
name|s_info
operator|->
name|height
operator|+=
literal|1
expr_stmt|;
switch|switch
condition|(
name|s_info
operator|->
name|rule
condition|)
block|{
case|case
name|SrcCopy
case|:
name|copyBitPos_LOOP
argument_list|(
name|SrcCopy_MASK
argument_list|,
name|SrcCopy_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcOr
case|:
name|copyBitPos_LOOP
argument_list|(
name|SrcOr_MASK
argument_list|,
name|SrcOr_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcXor
case|:
name|copyBitPos_LOOP
argument_list|(
name|SrcXor_MASK
argument_list|,
name|SrcXor_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcAnd
case|:
name|copyBitPos_LOOP
argument_list|(
name|NotSrcAnd_MASK
argument_list|,
name|NotSrcAnd_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcCopy
case|:
name|copyBitPos_LOOP
argument_list|(
name|NotSrcCopy_MASK
argument_list|,
name|NotSrcCopy_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcOr
case|:
name|copyBitPos_LOOP
argument_list|(
name|NotSrcOr_MASK
argument_list|,
name|NotSrcOr_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcXor
case|:
name|copyBitPos_LOOP
argument_list|(
name|NotSrcXor_MASK
argument_list|,
name|NotSrcXor_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcAnd
case|:
name|copyBitPos_LOOP
argument_list|(
name|SrcAnd_MASK
argument_list|,
name|SrcAnd_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcAndNotDst
case|:
name|copyBitPos_LOOP
argument_list|(
name|SrcAndNotDst_MASK
argument_list|,
name|SrcAndNotDst_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcAndNotDst
case|:
name|copyBitPos_LOOP
argument_list|(
name|NotSrcAndNotDst_MASK
argument_list|,
name|NotSrcAndNotDst_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcOrNotDst
case|:
name|copyBitPos_LOOP
argument_list|(
name|SrcOrNotDst_MASK
argument_list|,
name|SrcOrNotDst_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcOrNotDst
case|:
name|copyBitPos_LOOP
argument_list|(
name|NotSrcOrNotDst_MASK
argument_list|,
name|NotSrcOrNotDst_OP
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|MYDEBUG_PR
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|)
end_define

begin_define
define|#
directive|define
name|smallcopyBitPos_LOOP
parameter_list|(
name|EDGE_OP
parameter_list|,
name|OP
parameter_list|)
value|{				\ 	if (s_info->preload_src) {					\ 		if (s_info->nshorts == 2) {				\ 			MYDEBUG_PR(blt_debug,printf("preload 2\r\n"));	\ 			while (--height) {				\ 				EDGE_OP((*SRC<< skew_src) |		\ 					(*(PLUS_SRC(src))>> (inv_skew_src)),\                                         *DST,s_info->left_mask);	\ 				INCR_SRC(src);				\ 				INCR_DST(dst);				\ 				EDGE_OP((*SRC<< skew_src) |		\ 					(*(PLUS_SRC(src))>> (inv_skew_src)),\ 					*DST,s_info->right_mask);	\ 				src += (s_info->src.nextline + I_SRC);	\ 				dst += s_info->dst.nextline;		\ 			}						\ 		}							\ 		else {							\ 			MYDEBUG_PR(blt_debug,printf("preload 1\r\n"));	\ 			while (--height) {				\ 				EDGE_OP((*SRC<< skew_src) |		\ 					(*(PLUS_SRC(src))>> (inv_skew_src)),\                                         *DST,s_info->left_mask);	\ 				src += (s_info->src.nextline + I_SRC);	\ 				dst += s_info->dst.nextline;		\ 			}						\ 		}							\ 	}								\ 	else if (skew_src& 0xf) {					\ 		if (s_info->nshorts == 2) {				\ 			MYDEBUG_PR(blt_debug,printf("skew_src 2\r\n"));	\ 			while (--height) {				\ 				EDGE_OP((*SRC>>(inv_skew_src)),		\ 					*DST,s_info->left_mask);	\ 				INCR_DST(dst);				\ 				EDGE_OP((*SRC<< skew_src) |		\ 					(*(PLUS_SRC(src))>> (inv_skew_src)),\ 					*DST,s_info->right_mask);	\ 				src += (s_info->src.nextline + I_SRC);	\ 				dst += s_info->dst.nextline;		\ 			}						\ 		}							\ 		else {							\ 			MYDEBUG_PR(blt_debug,printf("skew_src 1\r\n"));	\ 			while (--height) {				\ 				EDGE_OP((*SRC>>(inv_skew_src)),		\ 					*DST,s_info->left_mask);	\ 				src += s_info->src.nextline;		\ 				dst += s_info->dst.nextline;		\ 			}						\ 		}							\ 	}								\ 	else if (s_info->nshorts == 2) {				\ 		MYDEBUG_PR(blt_debug,printf("lines up 2\r\n"));		\ 		while (--height) {					\ 			EDGE_OP(*SRC,*DST,s_info->left_mask);		\ 			INCR_DST(dst);					\ 			INCR_SRC(src);					\ 			EDGE_OP(*SRC,*DST,s_info->right_mask);		\ 			src += s_info->src.nextline;			\ 			dst += s_info->dst.nextline;			\ 		}							\ 	}								\ 	else {								\ 		MYDEBUG_PR(blt_debug,printf("lines up 1\r\n"));		\ 		while (--height) {					\ 			EDGE_OP(*SRC,*DST,s_info->left_mask);		\ 			src += s_info->src.nextline;			\ 			dst += s_info->dst.nextline;			\ 		}							\ 	}								\ }
end_define

begin_comment
comment|/*  * Do setup and dereferencing of 5 of the most important Blt_sysdata variables.  * Then do a switch on the combination rule to do the correct loop.  Each loop  * copies from left to right, top to bottom .  */
end_comment

begin_expr_stmt
name|smallcopyBitPos
argument_list|(
name|s_info
argument_list|)
specifier|register
name|Blt_sysdata
operator|*
name|s_info
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Register pointers are declared as  */
comment|/* unsigned char pointers. This is an */
specifier|register
name|unsigned
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* optimization to get around extra   */
comment|/* addressing in the assembler.       */
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
specifier|register
name|int
name|src_plus
decl_stmt|;
specifier|register
name|int
name|dst_plus
decl_stmt|;
endif|#
directive|endif
specifier|register
name|long
name|height
decl_stmt|;
specifier|register
name|int
name|skew_src
decl_stmt|;
specifier|register
name|int
name|inv_skew_src
decl_stmt|;
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
name|src_plus
operator|=
name|s_info
operator|->
name|src_plus
expr_stmt|;
name|dst_plus
operator|=
name|s_info
operator|->
name|dst_plus
expr_stmt|;
endif|#
directive|endif
name|src
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s_info
operator|->
name|src
operator|.
name|data
expr_stmt|;
name|dst
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s_info
operator|->
name|dst
operator|.
name|data
expr_stmt|;
name|height
operator|=
name|s_info
operator|->
name|height
expr_stmt|;
name|skew_src
operator|=
name|s_info
operator|->
name|skew_src
expr_stmt|;
name|inv_skew_src
operator|=
name|BPW
operator|-
name|skew_src
expr_stmt|;
name|DEBUGF
argument_list|(
name|blt_debug
argument_list|,
name|printf
argument_list|(
literal|"Enter smallcopyBitPos:%d,%d,%d,%d\r\n"
argument_list|,
name|skew_src
argument_list|,
name|inv_skew_src
argument_list|,
name|s_info
operator|->
name|preload_src
argument_list|,
name|s_info
operator|->
name|rule
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * foreach row do. 	 * 	 * Compiler optimization: a pre-decrement in a while loop saves a test 	 * in assembly language for every iteration. 	 */
name|height
operator|+=
literal|1
expr_stmt|;
switch|switch
condition|(
name|s_info
operator|->
name|rule
condition|)
block|{
case|case
name|SrcCopy
case|:
name|smallcopyBitPos_LOOP
argument_list|(
name|SrcCopy_MASK
argument_list|,
name|SrcCopy_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcOr
case|:
name|smallcopyBitPos_LOOP
argument_list|(
name|SrcOr_MASK
argument_list|,
name|SrcOr_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcXor
case|:
name|smallcopyBitPos_LOOP
argument_list|(
name|SrcXor_MASK
argument_list|,
name|SrcXor_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcAnd
case|:
name|smallcopyBitPos_LOOP
argument_list|(
name|NotSrcAnd_MASK
argument_list|,
name|NotSrcAnd_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcCopy
case|:
name|smallcopyBitPos_LOOP
argument_list|(
name|NotSrcCopy_MASK
argument_list|,
name|NotSrcCopy_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcOr
case|:
name|smallcopyBitPos_LOOP
argument_list|(
name|NotSrcOr_MASK
argument_list|,
name|NotSrcOr_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcXor
case|:
name|smallcopyBitPos_LOOP
argument_list|(
name|NotSrcXor_MASK
argument_list|,
name|NotSrcXor_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcAnd
case|:
name|smallcopyBitPos_LOOP
argument_list|(
name|SrcAnd_MASK
argument_list|,
name|SrcAnd_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcAndNotDst
case|:
name|smallcopyBitPos_LOOP
argument_list|(
name|SrcAndNotDst_MASK
argument_list|,
name|SrcAndNotDst_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcAndNotDst
case|:
name|smallcopyBitPos_LOOP
argument_list|(
name|NotSrcAndNotDst_MASK
argument_list|,
name|NotSrcAndNotDst_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcOrNotDst
case|:
name|smallcopyBitPos_LOOP
argument_list|(
name|SrcOrNotDst_MASK
argument_list|,
name|SrcOrNotDst_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcOrNotDst
case|:
name|smallcopyBitPos_LOOP
argument_list|(
name|NotSrcOrNotDst_MASK
argument_list|,
name|NotSrcOrNotDst_OP
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * This loop copies the tile to the destination. It takes as  * arguments 1 of 8 masking tile macros and the coorisponding generic  * tile  macro. The general scheme is this:  *	Foreach row do  *		Copy the tile to the first word using the left edge mask.  *  *		For each word between the first and last word do  *			Copy the tile to the destination word.  *		endfor  *  *		Copy the tile to the first word using the right edge mask.  *  *		INCREMENT the tile and destination pointers to point to the  *			next row.  *	endfor  *  */
end_comment

begin_define
define|#
directive|define
name|copyTile_LOOP
parameter_list|(
name|EDGE_OP
parameter_list|,
name|OP
parameter_list|)
value|{			\ 	while (--height) {				\ 		wordnum = s_info->nshorts;		\ 		EDGE_OP(*TILE,*DST,s_info->left_mask);	\ 		if (--wordnum != 0) {			\ 			INCR_DST(dst);			\ 			while (wordnum> 1) {		\ 				OP(*TILE,*DST);		\ 				INCR_DST(dst);	 	\ 				wordnum--;		\ 			}				\ 			EDGE_OP(*TILE,*DST,s_info->right_mask);\ 		}					\ 		INCR_TILE_PTR(tile,last_tile);		\ 		dst += s_info->dst.nextline;		\ 	}						\ }
end_define

begin_comment
comment|/*  * Tiles the destination.  */
end_comment

begin_expr_stmt
name|copyTile
argument_list|(
name|s_info
argument_list|)
specifier|register
name|Blt_sysdata
operator|*
name|s_info
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* 	 * For optimization, these registers are placed in order of importance. 	 */
specifier|register
name|unsigned
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* All register pointers are declared as */
comment|/* unsigned char pointers. This is an    */
comment|/* optimization to get around extra      */
comment|/* addressing in the assembler.          */
specifier|register
name|unsigned
name|char
modifier|*
name|tile
decl_stmt|;
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
specifier|register
name|int
name|dst_plus
decl_stmt|;
endif|#
directive|endif
specifier|register
name|int
name|wordnum
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|last_tile
decl_stmt|;
specifier|register
name|long
name|height
decl_stmt|;
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
name|DEBUGF
argument_list|(
name|blt_debug
argument_list|,
name|printf
argument_list|(
literal|"Enter copyTile r:%d p:%d, i:%d dw:%d\r\n"
argument_list|,
name|s_info
operator|->
name|rule
argument_list|,
name|s_info
operator|->
name|dst_plus
argument_list|,
name|s_info
operator|->
name|dst
operator|.
name|nextline
argument_list|,
name|s_info
operator|->
name|nshorts
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|DEBUGF
argument_list|(
name|blt_debug
argument_list|,
name|printf
argument_list|(
literal|"Enter copyTile r:%d i:%d dw:%d\r\n"
argument_list|,
name|s_info
operator|->
name|rule
argument_list|,
name|s_info
operator|->
name|dst
operator|.
name|nextline
argument_list|,
name|s_info
operator|->
name|nshorts
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dst
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s_info
operator|->
name|dst
operator|.
name|data
expr_stmt|;
name|tile
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|s_info
operator|->
name|tile_ptr
index|[
name|MOD_BPW
argument_list|(
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|origin_y
argument_list|)
index|]
expr_stmt|;
name|last_tile
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|s_info
operator|->
name|tile_ptr
index|[
literal|15
index|]
expr_stmt|;
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
name|dst_plus
operator|=
name|s_info
operator|->
name|dst_plus
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Compiler optimization: a pre-decrement in a while loop saves a test 	 * in assembly language for every iteration. 	 */
name|height
operator|=
name|s_info
operator|->
name|height
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|s_info
operator|->
name|rule
condition|)
block|{
case|case
name|DstClear
case|:
case|case
name|DstSet
case|:
case|case
name|TileDstClear
case|:
case|case
name|TileDstSet
case|:
case|case
name|TileCopy
case|:
name|copyTile_LOOP
argument_list|(
name|TileCopy_MASK
argument_list|,
name|TileCopy_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|TileOr
case|:
name|copyTile_LOOP
argument_list|(
name|TileOr_MASK
argument_list|,
name|TileOr_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|TileXor
case|:
name|copyTile_LOOP
argument_list|(
name|TileXor_MASK
argument_list|,
name|TileXor_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotTileAnd
case|:
name|copyTile_LOOP
argument_list|(
name|NotTileAnd_MASK
argument_list|,
name|NotTileAnd_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotTileCopy
case|:
name|copyTile_LOOP
argument_list|(
name|NotTileCopy_MASK
argument_list|,
name|NotTileCopy_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotTileOr
case|:
name|copyTile_LOOP
argument_list|(
name|NotTileOr_MASK
argument_list|,
name|NotTileOr_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotTileXor
case|:
name|copyTile_LOOP
argument_list|(
name|NotTileXor_MASK
argument_list|,
name|NotTileXor_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|TileAnd
case|:
name|copyTile_LOOP
argument_list|(
name|TileAnd_MASK
argument_list|,
name|TileAnd_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|TileNotDstCopy
case|:
case|case
name|NotDstCopy
case|:
name|copyTile_LOOP
argument_list|(
name|NotDstCopy_MASK
argument_list|,
name|NotDstCopy_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|TileAndNotDst
case|:
name|copyTile_LOOP
argument_list|(
name|TileAndNotDst_MASK
argument_list|,
name|TileAndNotDst_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotTileAndNotDst
case|:
name|copyTile_LOOP
argument_list|(
name|NotTileAndNotDst_MASK
argument_list|,
name|NotTileAndNotDst_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|TileOrNotDst
case|:
name|copyTile_LOOP
argument_list|(
name|TileOrNotDst_MASK
argument_list|,
name|TileOrNotDst_OP
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotTileOrNotDst
case|:
name|copyTile_LOOP
argument_list|(
name|NotTileOrNotDst_MASK
argument_list|,
name|NotTileOrNotDst_OP
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * This loop copies bits from right to left, bottom to top.  It takes as  * arguments 1 of 8 masking macros.  This loop has the same general structure  * as copyBitNeg_LOOP except that work must be done on the mask bitmap.  * This adds complexity because for optimization purposes, there are 4 loops  * instead of 2.  * The general scheme is this:  *	Foreach row do  *		Calculate the first MASK word priming if necessary.  *  *		Take care of the first word priming if necessary and using  *			the mask just calculated. (Done because  *			the first word uses the RIGHT edge mask.)  *  *		If the source and the MASK is skewed then  *			(Means parts of 2 source words make one  *			destination word and parts of 2 mask words are used  *			to mask this one destination word.)  *  *			For each word between the first and last word do  *				Calculate the MASK word.  *				Shift the source word and source word -1 and  *					write the word to the destination using  *					the mask just calculated.  *			endfor  *  *			Calculate the MASK word.  *			Take care of the last word using the mask and left  * 				edge mask. (Done here and not in   *				the loop because the last word uses the   *				LEFT edge mask.)  *   *		else if the MASK is skewed then  *			For each word between the first and last word do  *				Calculate the MASK word.  *				Write the source word to the destination using  *					the mask just calculated.  *			endfor  *  *			Calculate the MASK word.  *			Take care of the last word using the mask and left  * 				edge mask.  *			  *		else if the source is skewed then  *  *			For each word between the first and last word do  *				Shift the source word and source word -1 and  *					write the word to the destination using  *					the mask.  *			endfor  *  *			Take care of the last word using the mask and left  * 				edge mask.  *  *		else  The source and mask skew are zero meaning 1 source word,  *		      one mask word are used per destination word.  *   *			For each word between the first and last word do  *				Write the source word into the destination  *					using the mask word.  *			endfor  *  *			Take care of the last word using the mask word and  *				the left edge mask.  *		endif  *  *		DECREMENT the source,destination and mask pointers to point  *			to the next row in their respective bitmaps.  *	endfor  *  */
end_comment

begin_define
define|#
directive|define
name|maskBitNeg_LOOP
parameter_list|(
name|MASK_OP
parameter_list|)
value|{					\ 	while (--s_info->height) {					\ 		wordnum = s_info->nshorts;				\ 		if (s_info->preload_msk) {				\ 			mask = (*MSK>> s_info->skew_msk) |		\ 			       (*MINUS_MSK(msk)<< inv_skew_msk);	\ 			DECR_MSK(msk);					\ 		}							\ 		else {							\ 			mask = (*MSK<< inv_skew_msk);			\ 		}							\ 		if (s_info->preload_src) {				\ 			MASK_OP((*SRC>> s_info->skew_src) |		\ 				(*(MINUS_SRC(src))<< (inv_skew_src)),	\ 				*DST,s_info->right_mask& mask);	\ 			DECR_SRC(src);					\ 		}							\ 		else {							\ 			MASK_OP((*SRC<< (inv_skew_src)),*DST,		\ 				s_info->right_mask& mask);		\ 		}							\ 		if (--wordnum != 0) {					\ 			DECR_DST(dst);					\ 			if (write_mode == (MSK_SKEW | SRC_SKEW)) {	\ 				while (wordnum--> 1) {			\ 					mask = (*MSK>> s_info->skew_msk) |\ 					       (*MINUS_MSK(msk)<<inv_skew_msk);\ 					MASK_OP((*SRC>> s_info->skew_src) |\ 					        (*(MINUS_SRC(src))<<	\ 						inv_skew_src),		\ 						*DST,mask);		\ 					DECR_SRC(src); DECR_MSK(msk);	\ 					DECR_DST(dst);			\ 				}					\ 				mask = (*MSK>> s_info->skew_msk) |	\ 				       (*MINUS_MSK(msk)<<inv_skew_msk);	\ 				MASK_OP((*SRC>> s_info->skew_src) |	\ 					(*(MINUS_SRC(src))<<inv_skew_src),\ 					*DST,s_info->left_mask& mask);  \ 				DECR_SRC(src); DECR_MSK(msk);		\ 			}						\ 			else if (write_mode& MSK_SKEW) {		\ 				while (wordnum--> 1) {			\ 					mask = (*MSK>> s_info->skew_msk) |\ 					       (*MINUS_MSK(msk)<<inv_skew_msk);\ 					DECR_SRC(src); DECR_MSK(msk);	\ 					MASK_OP(*SRC,*DST,mask);	\ 					DECR_DST(dst);			\ 				}					\ 				mask = (*MSK>> s_info->skew_msk) |	\ 				       (*MINUS_MSK(msk)<<inv_skew_msk);	\ 				DECR_SRC(src); DECR_MSK(msk);		\ 				MASK_OP(*SRC,*DST,s_info->left_mask&mask);\ 			}						\ 			else if (write_mode& SRC_SKEW) {		\ 				while (wordnum--> 1) {			\ 					DECR_MSK(msk);			\ 		  			MASK_OP((*SRC>> s_info->skew_src) |\ 					        (*(MINUS_SRC(src))<<	\ 						inv_skew_src),		\ 					        *DST,*MSK);		\ 		    			DECR_SRC(src);			\ 					DECR_DST(dst);			\ 				}					\ 				DECR_MSK(msk);				\ 				MASK_OP((*SRC>> s_info->skew_src) |	\ 					(*(MINUS_SRC(src))<<inv_skew_src),\ 					*DST,s_info->left_mask& *MSK);	\ 				DECR_SRC(src);				\ 			}						\ 			else {						\ 				while (wordnum--> 1) {			\ 					DECR_SRC(src); DECR_MSK(msk);	\ 					MASK_OP(*SRC,*DST,*MSK);	\ 					DECR_DST(dst);			\ 				}					\ 				DECR_SRC(src); DECR_MSK(msk);		\ 				MASK_OP(*SRC,*DST,s_info->left_mask& *MSK);\ 			}						\ 		}							\ 		src -= s_info->src.nextline;				\ 		dst -= s_info->dst.nextline;				\ 		msk -= s_info->msk.nextline;				\ 	}								\ }
end_define

begin_comment
comment|/*  * Copies bits from bottom to top, right to left but only changes those bits  * that have corrisponding ones in the mask bitmap.  */
end_comment

begin_expr_stmt
name|maskBitNeg
argument_list|(
name|s_info
argument_list|)
specifier|register
name|Blt_sysdata
operator|*
name|s_info
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Register pointers are declared as  */
comment|/* unsigned char pointers. This is an */
specifier|register
name|unsigned
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* optimization to get around extra   */
comment|/* addressing in the assembler.       */
specifier|register
name|unsigned
name|char
modifier|*
name|msk
decl_stmt|;
comment|/* register pointer to the mask */
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
specifier|register
name|int
name|src_plus
decl_stmt|;
specifier|register
name|int
name|dst_plus
decl_stmt|;
endif|#
directive|endif
specifier|register
name|int
name|wordnum
decl_stmt|;
comment|/* number of shorts per scanline */
specifier|register
name|int
name|inv_skew_src
decl_stmt|;
comment|/* BPW - skew_src */
specifier|register
name|int
name|inv_skew_msk
decl_stmt|;
comment|/* BPW - skew_msk */
specifier|register
name|int
name|write_mode
decl_stmt|;
comment|/* One of 4 modes: 0. no skew. 							1. skew just the msk. 							2. skew just the src. 							3. skew both. */
specifier|register
name|unsigned
name|short
name|mask
decl_stmt|;
comment|/* The local mask produced by shifting 					*MSK and *MINUS_MASK() */
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
name|src_plus
operator|=
name|s_info
operator|->
name|src_plus
expr_stmt|;
name|dst_plus
operator|=
name|s_info
operator|->
name|dst_plus
expr_stmt|;
endif|#
directive|endif
name|DEBUGF
argument_list|(
name|blt_debug
argument_list|,
name|printf
argument_list|(
literal|"Enter maskBitNeg. rule:%d\r\n"
argument_list|,
name|s_info
operator|->
name|rule
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s_info
operator|->
name|src
operator|.
name|data
expr_stmt|;
name|dst
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s_info
operator|->
name|dst
operator|.
name|data
expr_stmt|;
name|msk
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s_info
operator|->
name|msk
operator|.
name|data
expr_stmt|;
name|inv_skew_src
operator|=
name|BPW
operator|-
name|s_info
operator|->
name|skew_src
expr_stmt|;
name|inv_skew_msk
operator|=
name|BPW
operator|-
name|s_info
operator|->
name|skew_msk
expr_stmt|;
comment|/* 	 * Set the write mode so that the correct inner loop is picked. 	 */
name|write_mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s_info
operator|->
name|skew_src
operator|&
literal|0xf
condition|)
name|write_mode
operator||=
name|SRC_SKEW
expr_stmt|;
if|if
condition|(
name|s_info
operator|->
name|skew_msk
operator|&
literal|0xf
condition|)
name|write_mode
operator||=
name|MSK_SKEW
expr_stmt|;
comment|/* 	 * Compiler optimization: a pre-decrement in a while loop saves a test 	 * in assembly language for every iteration. 	 */
name|s_info
operator|->
name|height
operator|+=
literal|1
expr_stmt|;
switch|switch
condition|(
name|s_info
operator|->
name|rule
condition|)
block|{
case|case
name|SrcCopy
case|:
name|maskBitNeg_LOOP
argument_list|(
name|SrcCopy_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcOr
case|:
name|maskBitNeg_LOOP
argument_list|(
name|SrcOr_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcXor
case|:
name|maskBitNeg_LOOP
argument_list|(
name|SrcXor_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcAnd
case|:
name|maskBitNeg_LOOP
argument_list|(
name|NotSrcAnd_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcCopy
case|:
name|maskBitNeg_LOOP
argument_list|(
name|NotSrcCopy_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcOr
case|:
name|maskBitNeg_LOOP
argument_list|(
name|NotSrcOr_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcXor
case|:
name|maskBitNeg_LOOP
argument_list|(
name|NotSrcXor_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcAnd
case|:
name|maskBitNeg_LOOP
argument_list|(
name|SrcAnd_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcAndNotDst
case|:
name|maskBitNeg_LOOP
argument_list|(
name|SrcAndNotDst_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcAndNotDst
case|:
name|maskBitNeg_LOOP
argument_list|(
name|NotSrcAndNotDst_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcOrNotDst
case|:
name|maskBitNeg_LOOP
argument_list|(
name|SrcOrNotDst_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcOrNotDst
case|:
name|maskBitNeg_LOOP
argument_list|(
name|NotSrcOrNotDst_MASK
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * This loop copies bits from left to right, top to bottom.  It takes as  * arguments 1 of 8 masking macros.  This loop has the same general structure  * as copyBitPos_LOOP except that work must be done on the mask bitmap.  * This adds complexity because, for optimization purposes, there are 4 loops  * instead of 2.  * The general scheme is this:  *	Foreach row do  *		Calculate the first MASK word priming if necessary.  *  *		Take care of the first word priming if necessary and using  *			the mask just calculated. (Done because  *			the first word uses the RIGHT edge mask.)  *  *		If the source and the MASK is skewed then  *			(Means parts of 2 source words make one  *			destination word and parts of 2 mask words are used  *			to mask this one destination word.)  *  *			For each word between the first and last word do  *				Calculate the MASK word.  *				Shift the source word and source word -1 and  *					write the word to the destination using  *					the mask just calculated.  *			endfor  *  *			Calculate the MASK word.  *			Take care of the last word using the mask and left  * 				edge mask. (Done here and not in   *				the loop because the last word uses the   *				LEFT edge mask.)  *   *		else if the MASK is skewed then  *			For each word between the first and last word do  *				Calculate the MASK word.  *				Write the source word to the destination using  *					the mask just calculated.  *			endfor  *  *			Calculate the MASK word.  *			Take care of the last word using the mask and left  * 				edge mask.  *			  *		else if the source is skewed then  *  *			For each word between the first and last word do  *				Shift the source word and source word -1 and  *					write the word to the destination using  *					the mask.  *			endfor  *  *			Take care of the last word using the mask and left  * 				edge mask.  *  *		else  The source and mask skew are zero meaning 1 source word,  *		      one mask word are used per destination word.  *   *			For each word between the first and last word do  *				Write the source word into the destination  *					using the mask word.  *			endfor  *  *			Take care of the last word using the mask word and  *				the left edge mask.  *		endif  *  *		INCREMENT the source,destination and mask pointers to point  *			to the next row in their respective bitmaps.  *	endfor  *  */
end_comment

begin_define
define|#
directive|define
name|maskBitPos_LOOP
parameter_list|(
name|MASK_OP
parameter_list|)
value|{					\ 	while (--s_info->height) {					\ 		wordnum = s_info->nshorts;				\ 		if (s_info->preload_msk) {				\ 			mask = (*MSK<< s_info->skew_msk) |		\ 			       (*PLUS_MSK(msk)>> inv_skew_msk);	\ 			INCR_MSK(msk);					\ 		}							\ 		else {							\ 			mask = (*MSK>> inv_skew_msk);			\ 		}							\ 		if (s_info->preload_src) {				\ 			MASK_OP((*SRC<< s_info->skew_src) |		\ 				(*(PLUS_SRC(src))>> (inv_skew_src)),*DST,\ 			        s_info->left_mask& mask);		\ 			INCR_SRC(src);					\ 		}							\ 		else {							\ 			 MASK_OP((*SRC>> (inv_skew_src)),*DST,		\ 				s_info->left_mask& mask);		\ 		}							\ 		if (--wordnum != 0) {					\ 			INCR_DST(dst);					\ 			if (write_mode == (MSK_SKEW | SRC_SKEW)) {	\ 				while (wordnum--> 1) {			\ 					mask = (*MSK<< s_info->skew_msk) |\ 					       (*PLUS_MSK(msk)>>inv_skew_msk);\ 					MASK_OP((*SRC<< s_info->skew_src) |\ 						(*(PLUS_SRC(src))>>	\ 						(inv_skew_src)),	\ 						*DST,mask);		\ 					INCR_SRC(src); INCR_MSK(msk);	\ 					INCR_DST(dst);			\ 				}					\ 				mask = (*MSK<< s_info->skew_msk) |	\ 				       (*PLUS_MSK(msk)>> inv_skew_msk);\ 				MASK_OP((*SRC<< s_info->skew_src) |	\ 					(*(PLUS_SRC(src))>>(inv_skew_src)),\ 					*DST, s_info->right_mask& mask);\ 				INCR_SRC(src); INCR_MSK(msk);		\ 			}						\ 			else if (write_mode& MSK_SKEW) {		\ 				while (wordnum--> 1) {			\ 					mask = (*MSK<< s_info->skew_msk) |\ 					       (*PLUS_MSK(msk)>>	\ 						   inv_skew_msk);	\ 					INCR_SRC(src); INCR_MSK(msk);	\ 					MASK_OP(*SRC,*DST,mask);	\ 					INCR_DST(dst);			\ 				}					\ 				mask = (*MSK<< s_info->skew_msk) |	\ 					  (*PLUS_MSK(msk)>> inv_skew_msk);\ 				INCR_SRC(src); INCR_MSK(msk);		\ 				MASK_OP(*SRC,*DST, s_info->right_mask& mask);\ 			}						\ 			else if (write_mode& SRC_SKEW) {		\ 				while (wordnum--> 1) {			\ 					INCR_MSK(msk);			\ 					MASK_OP((*SRC<< s_info->skew_src) |\ 						(*(PLUS_SRC(src))>>	\ 						(inv_skew_src)),	\ 						*DST,*MSK);		\ 					INCR_SRC(src);			\ 					INCR_DST(dst);			\ 				}					\ 				INCR_MSK(msk);				\ 				MASK_OP((*SRC<< s_info->skew_src) |	\ 					(*(PLUS_SRC(src))>>(inv_skew_src)),\ 					*DST, s_info->right_mask& *MSK);\ 					INCR_SRC(src);			\ 			}						\ 			else {						\ 				while (wordnum--> 1) {			\ 					INCR_SRC(src); INCR_MSK(msk);	\ 			        	MASK_OP(*SRC,*DST,*MSK);	\ 			        	INCR_DST(dst);			\ 				}					\ 				INCR_SRC(src); INCR_MSK(msk);		\ 				MASK_OP(*SRC,*DST,s_info->right_mask& *MSK);\ 			}						\ 		}							\ 		src += s_info->src.nextline;				\ 		dst += s_info->dst.nextline;				\ 		msk += s_info->msk.nextline;				\ 	}								\ }
end_define

begin_comment
comment|/*  * Copies bits from top to bottom , left to right but only changes those bits  * that have corrisponding ones in mask bitmap given.  */
end_comment

begin_expr_stmt
name|maskBitPos
argument_list|(
name|s_info
argument_list|)
specifier|register
name|Blt_sysdata
operator|*
name|s_info
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|src
decl_stmt|;
comment|/* Register pointers are declared as  */
comment|/* unsigned char pointers. This is an */
specifier|register
name|unsigned
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* optimization to get around extra   */
comment|/* addressing in the assembler.       */
specifier|register
name|unsigned
name|char
modifier|*
name|msk
decl_stmt|;
comment|/* register pointer to the mask */
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
specifier|register
name|int
name|src_plus
decl_stmt|;
specifier|register
name|int
name|dst_plus
decl_stmt|;
endif|#
directive|endif
specifier|register
name|int
name|wordnum
decl_stmt|;
comment|/* number of shorts per scanline */
specifier|register
name|int
name|inv_skew_src
decl_stmt|;
comment|/* BPW - skew_src */
specifier|register
name|int
name|inv_skew_msk
decl_stmt|;
comment|/* BPW - skew_msk */
specifier|register
name|int
name|write_mode
decl_stmt|;
comment|/* One of 4 modes: 0. no skew. 							1. skew just the msk. 							2. skew just the src. 							3. skew both. */
specifier|register
name|unsigned
name|short
name|mask
decl_stmt|;
comment|/* The local mask produced by shifting 					*MSK and *PLUS_MASK() */
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
name|src_plus
operator|=
name|s_info
operator|->
name|src_plus
expr_stmt|;
name|dst_plus
operator|=
name|s_info
operator|->
name|dst_plus
expr_stmt|;
endif|#
directive|endif
name|DEBUGF
argument_list|(
name|blt_debug
argument_list|,
name|printf
argument_list|(
literal|"Enter maskBitPos. rule:%d\r\n"
argument_list|,
name|s_info
operator|->
name|rule
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s_info
operator|->
name|src
operator|.
name|data
expr_stmt|;
name|dst
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s_info
operator|->
name|dst
operator|.
name|data
expr_stmt|;
name|msk
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s_info
operator|->
name|msk
operator|.
name|data
expr_stmt|;
name|inv_skew_msk
operator|=
name|BPW
operator|-
name|s_info
operator|->
name|skew_msk
expr_stmt|;
name|inv_skew_src
operator|=
name|BPW
operator|-
name|s_info
operator|->
name|skew_src
expr_stmt|;
comment|/* 	 * Set the write mode so that the correct inner loop is picked. 	 */
name|write_mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s_info
operator|->
name|skew_src
operator|&
literal|0xf
condition|)
name|write_mode
operator||=
name|SRC_SKEW
expr_stmt|;
if|if
condition|(
name|s_info
operator|->
name|skew_msk
operator|&
literal|0xf
condition|)
name|write_mode
operator||=
name|MSK_SKEW
expr_stmt|;
comment|/* 	 * Compiler optimization: a pre-decrement in a while loop saves a test 	 * in assembly language for every iteration. 	 */
name|s_info
operator|->
name|height
operator|+=
literal|1
expr_stmt|;
switch|switch
condition|(
name|s_info
operator|->
name|rule
condition|)
block|{
case|case
name|SrcCopy
case|:
name|maskBitPos_LOOP
argument_list|(
name|SrcCopy_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcOr
case|:
name|maskBitPos_LOOP
argument_list|(
name|SrcOr_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcXor
case|:
name|maskBitPos_LOOP
argument_list|(
name|SrcXor_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcAnd
case|:
name|maskBitPos_LOOP
argument_list|(
name|NotSrcAnd_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcCopy
case|:
name|maskBitPos_LOOP
argument_list|(
name|NotSrcCopy_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcOr
case|:
name|maskBitPos_LOOP
argument_list|(
name|NotSrcOr_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcXor
case|:
name|maskBitPos_LOOP
argument_list|(
name|NotSrcXor_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcAnd
case|:
name|maskBitPos_LOOP
argument_list|(
name|SrcAnd_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcAndNotDst
case|:
name|maskBitPos_LOOP
argument_list|(
name|SrcAndNotDst_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcAndNotDst
case|:
name|maskBitPos_LOOP
argument_list|(
name|NotSrcAndNotDst_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|SrcOrNotDst
case|:
name|maskBitPos_LOOP
argument_list|(
name|SrcOrNotDst_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSrcOrNotDst
case|:
name|maskBitPos_LOOP
argument_list|(
name|NotSrcOrNotDst_MASK
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * This loop copies the tile to the destination only changing those bits  * in the destination that have coorisponding one's in the mask bitmap.  * It takes as arguments 1 of 8 masking tile macros. The general scheme  * is this:  *	Foreach row do  *		Calculate the MASK shifting if necessary.  *		Copy the tile to the first word using the left edge mask and  *		MASK.  *  *		if the MASK is skewed then (2 mask words are needed for one  *			destination word.)  *			For each word between the first and last word do  *				Calculate the MASK.  *				Copy the tile to the destination word using  *					the mask calculated.  *			endfor  *  *		Calculate the MASK.  *		Copy the tile to the first word using the right edge mask and  *			the mask calculated.  *  *		else  *			For each word between the first and last word do  *				Copy the tile to the destination word using  *					the mask.  *			endfor  *  *			Copy the tile to the first word using the  *				right edge mask and the mask.  *		endif  *  *		INCREMENT the tile and destination pointers to point to the  *			next row.  *	endfor  */
end_comment

begin_define
define|#
directive|define
name|maskTile_LOOP
parameter_list|(
name|MASK_OP
parameter_list|)
value|{					\ 	while (--s_info->height) {					\ 		wordnum = s_info->nshorts;				\ 		if (s_info->preload_msk) {				\ 			mask = (*MSK<< s_info->skew_msk) |		\ 			       (*PLUS_MSK(msk)>> inv_skew_msk);	\ 			INCR_MSK(msk);					\ 		}							\ 		else {							\ 			mask = (*MSK>> inv_skew_msk);			\ 		}							\ 		MASK_OP(*TILE,*DST,s_info->left_mask& mask);		\ 		if (--wordnum != 0) {					\ 			INCR_DST(dst);					\ 			if (s_info->skew_msk& 0xf) {			\ 				while (wordnum--> 1) {			\ 					mask = (*MSK<< s_info->skew_msk) |\ 					       (*PLUS_MSK(msk)>>inv_skew_msk);\ 			        	MASK_OP(*TILE,*DST,mask);	\ 					INCR_DST(dst); INCR_MSK(msk);	\ 				}					\ 				mask = (*MSK<< s_info->skew_msk) |	\ 				       (*PLUS_MSK(msk)>> inv_skew_msk);\ 				MASK_OP(*TILE,*DST,			\ 					s_info->right_mask& mask);	\ 				INCR_MSK(msk);				\ 			}						\ 			else {						\ 				while (wordnum--> 1) {			\ 					INCR_MSK(msk);			\ 					MASK_OP(*TILE,*DST,*MSK);	\ 					INCR_DST(dst);			\ 				}					\ 				INCR_MSK(msk);				\ 				MASK_OP(*TILE,*DST,s_info->right_mask& *MSK);\ 			}						\ 		}							\ 		INCR_TILE_PTR(tile,last_tile);				\ 		dst += s_info->dst.nextline;				\ 		msk += s_info->msk.nextline;				\ 	}								\ }
end_define

begin_comment
comment|/*  * Copies a tile to the destination but only changes those bits  * that have corrisponding ones in the mask bitmap given.  */
end_comment

begin_expr_stmt
name|maskTile
argument_list|(
name|s_info
argument_list|)
specifier|register
name|Blt_sysdata
operator|*
name|s_info
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* Register pointers are declared as  */
comment|/* unsigned char pointers. This is an */
specifier|register
name|unsigned
name|char
modifier|*
name|msk
decl_stmt|;
comment|/* optimization to get around extra   */
comment|/* addressing in the assembler.       */
specifier|register
name|unsigned
name|char
modifier|*
name|tile
decl_stmt|;
comment|/* register pointer to the tile */
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
specifier|register
name|int
name|src_plus
decl_stmt|;
specifier|register
name|int
name|dst_plus
decl_stmt|;
endif|#
directive|endif
specifier|register
name|unsigned
name|char
modifier|*
name|last_tile
decl_stmt|;
comment|/* points to the last word in a tile*/
specifier|register
name|int
name|wordnum
decl_stmt|;
comment|/* number of shorts per scanline */
specifier|register
name|int
name|inv_skew_msk
decl_stmt|;
comment|/* BPW - skew_msk */
specifier|register
name|unsigned
name|short
name|mask
decl_stmt|;
comment|/* The local mask produced by shifting 					*MSK and *PLUS_MASK() */
if|#
directive|if
operator|(
name|APA8
operator|||
name|APA8C
operator|)
name|src_plus
operator|=
name|s_info
operator|->
name|src_plus
expr_stmt|;
name|dst_plus
operator|=
name|s_info
operator|->
name|dst_plus
expr_stmt|;
endif|#
directive|endif
name|dst
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s_info
operator|->
name|dst
operator|.
name|data
expr_stmt|;
name|msk
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s_info
operator|->
name|msk
operator|.
name|data
expr_stmt|;
name|tile
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|s_info
operator|->
name|tile_ptr
index|[
name|MOD_BPW
argument_list|(
name|s_info
operator|->
name|dst
operator|.
name|rect
operator|.
name|origin_y
argument_list|)
index|]
expr_stmt|;
name|last_tile
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|&
name|s_info
operator|->
name|tile_ptr
index|[
literal|15
index|]
operator|)
expr_stmt|;
name|inv_skew_msk
operator|=
name|BPW
operator|-
name|s_info
operator|->
name|skew_msk
expr_stmt|;
name|DEBUGF
argument_list|(
name|blt_debug
argument_list|,
name|printf
argument_list|(
literal|"Enter maskTile%d,%d %d %s %d\r\n"
argument_list|,
name|s_info
operator|->
name|skew_msk
argument_list|,
name|inv_skew_msk
argument_list|,
name|s_info
operator|->
name|preload_msk
argument_list|,
operator|(
operator|(
name|s_info
operator|->
name|tile_ptr
index|[
literal|0
index|]
operator|==
literal|0xffff
operator|&&
name|s_info
operator|->
name|tile_ptr
index|[
literal|5
index|]
operator|==
literal|0xffff
operator|)
condition|?
literal|"black"
else|:
literal|"not black"
operator|)
argument_list|,
name|s_info
operator|->
name|rule
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Compiler optimization: a pre-decrement in a while loop saves a test 	 * in assembly language for every iteration. 	 */
name|s_info
operator|->
name|height
operator|+=
literal|1
expr_stmt|;
switch|switch
condition|(
name|s_info
operator|->
name|rule
condition|)
block|{
case|case
name|DstClear
case|:
case|case
name|DstSet
case|:
case|case
name|TileDstClear
case|:
case|case
name|TileDstSet
case|:
case|case
name|TileCopy
case|:
name|maskTile_LOOP
argument_list|(
name|TileCopy_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|TileOr
case|:
name|maskTile_LOOP
argument_list|(
name|TileOr_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|TileXor
case|:
name|maskTile_LOOP
argument_list|(
name|TileXor_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotTileAnd
case|:
name|maskTile_LOOP
argument_list|(
name|NotTileAnd_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotTileCopy
case|:
name|maskTile_LOOP
argument_list|(
name|NotTileCopy_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotTileOr
case|:
name|maskTile_LOOP
argument_list|(
name|NotTileOr_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotTileXor
case|:
name|maskTile_LOOP
argument_list|(
name|NotTileXor_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|TileAnd
case|:
name|maskTile_LOOP
argument_list|(
name|TileAnd_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|TileNotDstCopy
case|:
case|case
name|NotDstCopy
case|:
name|maskTile_LOOP
argument_list|(
name|NotDstCopy_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|TileAndNotDst
case|:
name|maskTile_LOOP
argument_list|(
name|TileAndNotDst_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotTileAndNotDst
case|:
name|maskTile_LOOP
argument_list|(
name|NotTileAndNotDst_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|TileOrNotDst
case|:
name|maskTile_LOOP
argument_list|(
name|TileOrNotDst_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotTileOrNotDst
case|:
name|maskTile_LOOP
argument_list|(
name|NotTileOrNotDst_MASK
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_block

end_unit

