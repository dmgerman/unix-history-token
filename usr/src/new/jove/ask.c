begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_include
include|#
directive|include
file|"mac.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|F_COMPLETION
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_undef
undef|#
directive|undef
name|private
end_undef

begin_define
define|#
directive|define
name|private
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LINT_ARGS
end_ifdef

begin_function_decl
name|private
name|Buffer
modifier|*
name|get_minibuf
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|char
modifier|*
name|real_ask
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|()
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|int
name|f_complete
argument_list|(
name|int
argument_list|)
decl_stmt|,
name|bad_extension
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|,
name|crush_bads
argument_list|(
name|char
operator|*
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|,
name|isdir
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|fill_in
argument_list|(
name|char
operator|*
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|,
name|EVexpand
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function_decl
name|private
name|Buffer
modifier|*
name|get_minibuf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|char
modifier|*
name|real_ask
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|int
name|f_complete
argument_list|()
decl_stmt|,
name|bad_extension
argument_list|()
decl_stmt|,
name|crush_bads
argument_list|()
decl_stmt|,
name|isdir
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|fill_in
argument_list|()
decl_stmt|,
name|EVexpand
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LINT_ARGS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_undef
undef|#
directive|undef
name|private
end_undef

begin_define
define|#
directive|define
name|private
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|AbortChar
init|=
name|CTL
argument_list|(
literal|'G'
argument_list|)
decl_stmt|,
name|DoEVexpand
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* should we expand evironment variables? */
end_comment

begin_decl_stmt
name|int
name|Asking
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Minibuf
index|[
name|LBSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Line
modifier|*
name|CurAskPtr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* points at some line in mini-buffer */
end_comment

begin_decl_stmt
name|private
name|Buffer
modifier|*
name|AskBuffer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Askbuffer points to actual structure */
end_comment

begin_comment
comment|/* The way the mini-buffer works is this:  The first line of the mini-buffer    is where the user does his stuff.  The rest of the buffer contains    strings that the user often wants to use, for instance, file names, or    common search strings, etc.  If he types C-N or C-P while in ask(), we    bump the point up or down a line and extract the contents (we make sure    is somewhere in the mini-buffer). */
end_comment

begin_function
specifier|static
name|Buffer
modifier|*
name|get_minibuf
parameter_list|()
block|{
if|if
condition|(
name|AskBuffer
condition|)
block|{
comment|/* make sure ut still exists */
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|b_next
control|)
if|if
condition|(
name|b
operator|==
name|AskBuffer
condition|)
return|return
name|b
return|;
block|}
name|AskBuffer
operator|=
name|do_select
argument_list|(
operator|(
name|Window
operator|*
operator|)
literal|0
argument_list|,
literal|"*minibuf*"
argument_list|)
expr_stmt|;
name|AskBuffer
operator|->
name|b_type
operator|=
name|B_SCRATCH
expr_stmt|;
return|return
name|AskBuffer
return|;
block|}
end_function

begin_comment
comment|/* Add a string to the mini-buffer. */
end_comment

begin_function
name|void
name|minib_add
parameter_list|(
name|str
parameter_list|,
name|movedown
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|Buffer
modifier|*
name|saveb
init|=
name|curbuf
decl_stmt|;
name|SetBuf
argument_list|(
name|get_minibuf
argument_list|()
argument_list|)
expr_stmt|;
name|LineInsert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ins_str
argument_list|(
name|str
argument_list|,
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|movedown
condition|)
name|CurAskPtr
operator|=
name|curline
expr_stmt|;
name|SetBuf
argument_list|(
name|saveb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* look for any substrings of the form $foo in linebuf, and expand    them according to their value in the environment (if possible) -    this munges all over curchar and linebuf without giving it a second    thought (I must be getting lazy in my old age) */
end_comment

begin_function
name|private
name|void
name|EVexpand
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|lp
init|=
name|linebuf
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|char
name|varname
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|vp
decl_stmt|,
modifier|*
name|lp_start
decl_stmt|;
name|Mark
modifier|*
name|m
init|=
name|MakeMark
argument_list|(
name|curline
argument_list|,
name|curchar
argument_list|,
name|M_FLOATER
argument_list|)
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|lp
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'$'
condition|)
continue|continue;
name|lp_start
operator|=
name|lp
operator|-
literal|1
expr_stmt|;
comment|/* the $ */
name|vp
operator|=
name|varname
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|lp
operator|++
condition|)
block|{
if|if
condition|(
operator|!
name|isword
argument_list|(
name|c
argument_list|)
condition|)
break|break;
operator|*
name|vp
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|vp
operator|=
literal|'\0'
expr_stmt|;
comment|/* if we find an env. variable with the right 		   name, we insert it in linebuf, and then delete 		   the variable name that we're replacing - and  		   then we continue in case there are others ... */
if|if
condition|(
name|ep
operator|=
name|getenv
argument_list|(
name|varname
argument_list|)
condition|)
block|{
name|curchar
operator|=
name|lp_start
operator|-
name|linebuf
expr_stmt|;
name|ins_str
argument_list|(
name|ep
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|del_char
argument_list|(
name|FORWARD
argument_list|,
name|strlen
argument_list|(
name|varname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lp
operator|=
name|linebuf
operator|+
name|curchar
expr_stmt|;
block|}
block|}
name|ToMark
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|DelMark
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|private
name|char
modifier|*
name|real_ask
argument_list|(
name|delim
argument_list|,
name|d_proc
argument_list|,
name|def
argument_list|,
name|prompt
argument_list|)
name|char
modifier|*
name|delim
decl_stmt|,
modifier|*
name|def
decl_stmt|,
modifier|*
name|prompt
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|d_proc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|static
name|int
name|InAsk
init|=
literal|0
decl_stmt|;
name|jmp_buf
name|savejmp
decl_stmt|;
name|int
name|c
decl_stmt|,
name|prompt_len
decl_stmt|;
name|Buffer
modifier|*
name|saveb
init|=
name|curbuf
decl_stmt|;
name|int
name|abort
init|=
literal|0
decl_stmt|,
name|no_typed
init|=
literal|0
decl_stmt|;
name|data_obj
modifier|*
name|push_cmd
init|=
name|LastCmd
decl_stmt|;
name|int
name|o_a_v
init|=
name|arg_value
argument_list|()
decl_stmt|,
name|o_i_an_a
init|=
name|is_an_arg
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|menus_off
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|InAsk
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|push_env
argument_list|(
name|savejmp
argument_list|)
expr_stmt|;
name|InAsk
operator|+=
literal|1
expr_stmt|;
name|SetBuf
argument_list|(
name|get_minibuf
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inlist
argument_list|(
name|AskBuffer
operator|->
name|b_first
argument_list|,
name|CurAskPtr
argument_list|)
condition|)
name|CurAskPtr
operator|=
name|curline
expr_stmt|;
name|prompt_len
operator|=
name|strlen
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|ToFirst
argument_list|()
expr_stmt|;
comment|/* Beginning of buffer. */
name|linebuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|modify
argument_list|()
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|mainjmp
argument_list|)
condition|)
if|if
condition|(
name|InJoverc
condition|)
block|{
comment|/* this is a kludge */
name|abort
operator|=
name|YES
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|clr_arg_value
argument_list|()
expr_stmt|;
name|last_cmd
operator|=
name|this_cmd
expr_stmt|;
name|init_strokes
argument_list|()
expr_stmt|;
name|cont
label|:
name|s_mess
argument_list|(
literal|"%s%s"
argument_list|,
name|prompt
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|Asking
operator|=
name|curchar
operator|+
name|prompt_len
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|EOF
operator|)
operator|||
name|index
argument_list|(
name|delim
argument_list|,
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|DoEVexpand
condition|)
name|EVexpand
argument_list|()
expr_stmt|;
if|if
condition|(
name|d_proc
operator|==
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
operator|||
call|(
modifier|*
name|d_proc
call|)
argument_list|(
name|c
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|cleanup
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|AbortChar
condition|)
block|{
name|message
argument_list|(
literal|"[Aborted]"
argument_list|)
expr_stmt|;
name|abort
operator|=
name|YES
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CTL
argument_list|(
literal|'N'
argument_list|)
case|:
case|case
name|CTL
argument_list|(
literal|'P'
argument_list|)
case|:
if|if
condition|(
name|CurAskPtr
operator|!=
literal|0
condition|)
block|{
name|int
name|n
init|=
operator|(
name|c
operator|==
name|CTL
argument_list|(
literal|'P'
argument_list|)
condition|?
operator|-
name|arg_value
argument_list|()
else|:
name|arg_value
argument_list|()
operator|)
decl_stmt|;
name|CurAskPtr
operator|=
name|next_line
argument_list|(
name|CurAskPtr
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|CurAskPtr
operator|==
name|curbuf
operator|->
name|b_first
operator|&&
name|CurAskPtr
operator|->
name|l_next
operator|!=
literal|0
condition|)
name|CurAskPtr
operator|=
name|CurAskPtr
operator|->
name|l_next
expr_stmt|;
operator|(
name|void
operator|)
name|ltobuf
argument_list|(
name|CurAskPtr
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|modify
argument_list|()
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
name|Eol
argument_list|()
expr_stmt|;
name|this_cmd
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|CTL
argument_list|(
literal|'R'
argument_list|)
case|:
if|if
condition|(
name|def
condition|)
name|ins_str
argument_list|(
name|def
argument_list|,
name|NO
argument_list|)
expr_stmt|;
else|else
name|rbell
argument_list|()
expr_stmt|;
break|break;
default|default:
name|dispatch
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|curbuf
operator|!=
name|AskBuffer
condition|)
name|SetBuf
argument_list|(
name|AskBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|curline
operator|!=
name|curbuf
operator|->
name|b_first
condition|)
block|{
name|CurAskPtr
operator|=
name|curline
expr_stmt|;
name|curline
operator|=
name|curbuf
operator|->
name|b_first
expr_stmt|;
comment|/* with whatever is in linebuf */
block|}
if|if
condition|(
name|this_cmd
operator|==
name|ARG_CMD
condition|)
goto|goto
name|cont
goto|;
block|}
name|cleanup
label|:
name|pop_env
argument_list|(
name|savejmp
argument_list|)
expr_stmt|;
name|LastCmd
operator|=
name|push_cmd
expr_stmt|;
name|set_arg_value
argument_list|(
name|o_a_v
argument_list|)
expr_stmt|;
name|set_is_an_arg
argument_list|(
name|o_i_an_a
argument_list|)
expr_stmt|;
name|no_typed
operator|=
operator|(
name|linebuf
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
expr_stmt|;
name|strcpy
argument_list|(
name|Minibuf
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|saveb
argument_list|)
expr_stmt|;
name|InAsk
operator|=
name|Asking
operator|=
name|Interactive
operator|=
name|NO
expr_stmt|;
if|if
condition|(
operator|!
name|abort
condition|)
block|{
if|if
condition|(
operator|!
name|charp
argument_list|()
condition|)
block|{
name|Placur
argument_list|(
name|ILI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|no_typed
condition|)
return|return
literal|0
return|;
block|}
else|else
name|complain
argument_list|(
name|mesgbuf
argument_list|)
expr_stmt|;
return|return
name|Minibuf
return|;
block|}
end_block

begin_comment
comment|/* VARARGS2 */
end_comment

begin_function
name|char
modifier|*
name|ask
parameter_list|(
name|def
parameter_list|,
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|def
decl_stmt|,
decl|*
name|fmt
decl_stmt|;
end_function

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
name|prompt
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|ans
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|format
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
name|prompt
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ans
operator|=
name|real_ask
argument_list|(
literal|"\r\n"
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
argument_list|,
name|def
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ans
operator|==
literal|0
condition|)
block|{
comment|/* Typed nothing. */
if|if
condition|(
name|def
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"[No default]"
argument_list|)
expr_stmt|;
return|return
name|def
return|;
block|}
return|return
name|ans
return|;
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_decl_stmt
name|char
modifier|*
name|do_ask
argument_list|(
name|delim
argument_list|,
name|d_proc
argument_list|,
name|def
argument_list|,
name|fmt
argument_list|,
name|va_alist
argument_list|)
name|char
modifier|*
name|delim
decl_stmt|,
modifier|*
name|def
decl_stmt|,
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|d_proc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
name|prompt
index|[
literal|128
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|format
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
name|prompt
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|real_ask
argument_list|(
name|delim
argument_list|,
name|d_proc
argument_list|,
name|def
argument_list|,
name|prompt
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_function
name|int
name|yes_or_no_p
parameter_list|(
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
block|{
name|char
name|prompt
index|[
literal|128
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|format
argument_list|(
name|prompt
argument_list|,
sizeof|sizeof
name|prompt
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|message
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|Asking
operator|=
name|strlen
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
comment|/* so redisplay works */
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
name|Asking
operator|=
name|NO
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|AbortChar
condition|)
name|complain
argument_list|(
literal|"[Aborted]"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|CharUpcase
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
literal|'Y'
case|:
return|return
name|YES
return|;
case|case
literal|'N'
case|:
return|return
name|NO
return|;
default|default:
name|add_mess
argument_list|(
literal|"[Type Y or N]"
argument_list|)
expr_stmt|;
name|SitFor
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|F_COMPLETION
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fc_filebase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|DispBadFs
init|=
name|YES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* display bad file names? */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MSDOS
end_ifndef

begin_decl_stmt
name|char
name|BadExtensions
index|[
literal|128
index|]
init|=
literal|".o"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MSDOS */
end_comment

begin_decl_stmt
name|char
name|BadExtensions
index|[
literal|128
index|]
init|=
literal|".obj .exe .com .bak .arc .lib .zoo"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_expr_stmt
specifier|static
name|bad_extension
argument_list|(
argument|name
argument_list|)
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|ip
decl_stmt|,
modifier|*
name|bads
init|=
name|BadExtensions
decl_stmt|;
name|int
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|,
name|ext_len
decl_stmt|,
name|stop
init|=
literal|0
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|ip
operator|=
name|index
argument_list|(
name|bads
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ip
operator|=
name|bads
operator|+
name|strlen
argument_list|(
name|bads
argument_list|)
expr_stmt|;
name|stop
operator|=
name|YES
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ext_len
operator|=
name|ip
operator|-
name|bads
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ext_len
operator|<
name|namelen
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
operator|&
name|name
index|[
name|namelen
operator|-
name|ext_len
index|]
argument_list|,
name|bads
argument_list|,
name|ext_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|YES
return|;
block|}
do|while
condition|(
operator|(
name|bads
operator|=
name|ip
operator|+
literal|1
operator|)
operator|,
operator|!
name|stop
condition|)
do|;
return|return
name|NO
return|;
block|}
end_block

begin_function
name|int
name|f_match
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|fc_filebase
argument_list|)
decl_stmt|;
if|if
condition|(
name|DispBadFs
operator|==
name|NO
condition|)
if|if
condition|(
name|bad_extension
argument_list|(
name|file
argument_list|)
condition|)
return|return
name|NO
return|;
return|return
operator|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
ifdef|#
directive|ifdef
name|MSDOS
operator|(
name|casencmp
argument_list|(
name|file
argument_list|,
name|fc_filebase
argument_list|,
name|strlen
argument_list|(
name|fc_filebase
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
else|#
directive|else
operator|(
name|strncmp
argument_list|(
name|file
argument_list|,
name|fc_filebase
argument_list|,
name|strlen
argument_list|(
name|fc_filebase
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
endif|#
directive|endif
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|isdir
argument_list|(
argument|name
argument_list|)
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
name|char
name|filebuf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|PathParse
argument_list|(
name|name
argument_list|,
name|filebuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|stat
argument_list|(
name|filebuf
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFDIR
operator|)
operator|==
name|S_IFDIR
operator|)
return|;
block|}
end_block

begin_function
name|private
name|void
name|fill_in
parameter_list|(
name|dir_vec
parameter_list|,
name|n
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|dir_vec
decl_stmt|;
block|{
name|int
name|minmatch
init|=
literal|0
decl_stmt|,
name|numfound
init|=
literal|0
decl_stmt|,
name|lastmatch
init|=
operator|-
literal|1
decl_stmt|,
name|i
decl_stmt|,
name|the_same
init|=
name|TRUE
decl_stmt|,
comment|/* After filling in, are we the same 				    as when we were called? */
name|is_ntdir
decl_stmt|;
comment|/* Is Newly Typed Directory name */
name|char
name|bads
index|[
literal|128
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* if it's no, then we have already filtered them out 		   in f_match() so there's no point in doing it again */
if|if
condition|(
name|DispBadFs
operator|==
name|YES
condition|)
block|{
if|if
condition|(
name|bad_extension
argument_list|(
name|dir_vec
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|numfound
condition|)
name|minmatch
operator|=
name|min
argument_list|(
name|minmatch
argument_list|,
name|numcomp
argument_list|(
name|dir_vec
index|[
name|lastmatch
index|]
argument_list|,
name|dir_vec
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|minmatch
operator|=
name|strlen
argument_list|(
name|dir_vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|lastmatch
operator|=
name|i
expr_stmt|;
name|numfound
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Ugh.  Beware--this is hard to get right in a reasonable 	   manner.  Please excuse this code--it's past my bedtime. */
if|if
condition|(
name|numfound
operator|==
literal|0
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
return|return;
block|}
name|Eol
argument_list|()
expr_stmt|;
if|if
condition|(
name|minmatch
operator|>
name|strlen
argument_list|(
name|fc_filebase
argument_list|)
condition|)
block|{
name|the_same
operator|=
name|FALSE
expr_stmt|;
name|null_ncpy
argument_list|(
name|fc_filebase
argument_list|,
name|dir_vec
index|[
name|lastmatch
index|]
argument_list|,
name|minmatch
argument_list|)
expr_stmt|;
name|Eol
argument_list|()
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
block|}
name|is_ntdir
operator|=
operator|(
operator|(
name|numfound
operator|==
literal|1
operator|)
operator|&&
operator|(
name|curchar
operator|>
literal|0
operator|)
operator|&&
operator|(
name|linebuf
index|[
name|curchar
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
name|isdir
argument_list|(
name|linebuf
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|the_same
operator|&&
operator|!
name|is_ntdir
condition|)
block|{
name|add_mess
argument_list|(
operator|(
name|n
operator|==
literal|1
operator|)
condition|?
literal|" [Unique]"
else|:
literal|" [Ambiguous]"
argument_list|)
expr_stmt|;
name|SitFor
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_ntdir
condition|)
name|insert_c
argument_list|(
literal|'/'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|extern
name|int
name|alphacomp
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* called from do_ask() when one of "\r\n ?" is typed.  Does the right    thing, depending on which. */
end_comment

begin_expr_stmt
specifier|static
name|f_complete
argument_list|(
argument|c
argument_list|)
block|{
name|char
name|dir
index|[
name|FILESIZE
index|]
block|,
operator|*
operator|*
name|dir_vec
block|;
name|int
name|nentries
block|,
name|i
block|;
if|if
condition|(
name|c
operator|==
name|CR
operator|||
name|c
operator|==
name|LF
condition|)
return|return
literal|0
return|;
end_expr_stmt

begin_comment
comment|/* tells ask to return now */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MSDOS
end_ifndef

begin_comment
comment|/* kg */
end_comment

begin_if
if|if
condition|(
operator|(
name|fc_filebase
operator|=
name|rindex
argument_list|(
name|linebuf
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
else|#
directive|else
comment|/* MSDOS */
name|fc_filebase
operator|=
name|rindex
argument_list|(
name|linebuf
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc_filebase
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|fc_filebase
operator|=
name|rindex
argument_list|(
name|linebuf
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc_filebase
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|fc_filebase
operator|=
name|rindex
argument_list|(
name|linebuf
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fc_filebase
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
endif|#
directive|endif
comment|/* MSDOS */
name|char
name|tmp
index|[
name|FILESIZE
index|]
decl_stmt|;
name|fc_filebase
operator|+=
literal|1
expr_stmt|;
name|null_ncpy
argument_list|(
name|tmp
argument_list|,
name|linebuf
argument_list|,
operator|(
name|fc_filebase
operator|-
name|linebuf
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|PathParse
argument_list|(
name|tmp
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fc_filebase
operator|=
name|linebuf
expr_stmt|;
name|strcpy
argument_list|(
name|dir
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nentries
operator|=
name|scandir
argument_list|(
name|dir
argument_list|,
operator|&
name|dir_vec
argument_list|,
name|f_match
argument_list|,
name|alphacomp
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|add_mess
argument_list|(
literal|" [Unknown directory: %s]"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|SitFor
argument_list|(
literal|7
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|nentries
operator|==
literal|0
condition|)
block|{
name|add_mess
argument_list|(
literal|" [No match]"
argument_list|)
expr_stmt|;
name|SitFor
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|fill_in
argument_list|(
name|dir_vec
argument_list|,
name|nentries
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* we're a '?' */
name|int
name|maxlen
init|=
literal|0
decl_stmt|,
name|ncols
decl_stmt|,
name|col
decl_stmt|,
name|lines
decl_stmt|,
name|linespercol
decl_stmt|;
name|TOstart
argument_list|(
literal|"Completion"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* false means newline only on request */
name|Typeout
argument_list|(
literal|"(! means file will not be chosen unless typed explicitly)"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"Possible completions (in %s):"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
name|maxlen
operator|=
name|max
argument_list|(
name|strlen
argument_list|(
name|dir_vec
index|[
name|i
index|]
argument_list|)
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
name|maxlen
operator|+=
literal|4
expr_stmt|;
comment|/* pad each column with at least 4 spaces */
name|ncols
operator|=
operator|(
name|CO
operator|-
literal|2
operator|)
operator|/
name|maxlen
expr_stmt|;
name|linespercol
operator|=
literal|1
operator|+
operator|(
name|nentries
operator|/
name|ncols
operator|)
expr_stmt|;
for|for
control|(
name|lines
operator|=
literal|0
init|;
name|lines
operator|<
name|linespercol
condition|;
name|lines
operator|++
control|)
block|{
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|ncols
condition|;
name|col
operator|++
control|)
block|{
name|int
name|isbad
decl_stmt|,
name|which
decl_stmt|;
name|which
operator|=
operator|(
name|col
operator|*
name|linespercol
operator|)
operator|+
name|lines
expr_stmt|;
if|if
condition|(
name|which
operator|>=
name|nentries
condition|)
break|break;
if|if
condition|(
name|DispBadFs
operator|==
name|YES
condition|)
name|isbad
operator|=
name|bad_extension
argument_list|(
name|dir_vec
index|[
name|which
index|]
argument_list|)
expr_stmt|;
else|else
name|isbad
operator|=
name|NO
expr_stmt|;
name|Typeout
argument_list|(
literal|"%s%-*s"
argument_list|,
name|isbad
condition|?
literal|"!"
else|:
name|NullStr
argument_list|,
name|maxlen
operator|-
name|isbad
argument_list|,
name|dir_vec
index|[
name|which
index|]
argument_list|)
expr_stmt|;
block|}
name|Typeout
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|TOstop
argument_list|()
expr_stmt|;
block|}
name|freedir
argument_list|(
operator|&
name|dir_vec
argument_list|,
name|nentries
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
name|ask_file
parameter_list|(
name|prmt
parameter_list|,
name|def
parameter_list|,
name|buf
parameter_list|)
name|char
modifier|*
name|prmt
decl_stmt|,
decl|*
name|def
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|ans
decl_stmt|,
name|prompt
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|pretty_name
init|=
name|pr_name
argument_list|(
name|def
argument_list|,
name|YES
argument_list|)
decl_stmt|;
if|if
condition|(
name|prmt
condition|)
name|sprintf
argument_list|(
name|prompt
argument_list|,
name|prmt
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|def
operator|!=
literal|0
operator|&&
operator|*
name|def
operator|!=
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|prompt
argument_list|,
literal|": %f (default %s) "
argument_list|,
name|pretty_name
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|prompt
argument_list|,
name|ProcFmt
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|F_COMPLETION
name|ans
operator|=
name|real_ask
argument_list|(
literal|"\r\n \t?"
argument_list|,
name|f_complete
argument_list|,
name|pretty_name
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ans
operator|==
literal|0
operator|&&
operator|(
name|ans
operator|=
name|pretty_name
operator|)
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"[No default file name]"
argument_list|)
expr_stmt|;
else|#
directive|else
name|ans
operator|=
name|ask
argument_list|(
name|pretty_name
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PathParse
argument_list|(
name|ans
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_block

end_unit

