begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"re.h"
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPROCS
end_ifdef

begin_function_decl
name|int
name|proc_child
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|PIPEPROCS
end_ifdef

begin_include
include|#
directive|include
file|"iproc-pipes.c"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"iproc-ptys.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|proc_prompt
index|[
literal|128
index|]
init|=
literal|"% "
decl_stmt|;
end_decl_stmt

begin_macro
name|KillProcs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|Process
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|killem
init|=
operator|-
literal|1
decl_stmt|;
comment|/* -1 means undetermined */
specifier|register
name|char
modifier|*
name|yorn
decl_stmt|;
for|for
control|(
name|p
operator|=
name|procs
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|p_next
control|)
if|if
condition|(
operator|!
name|isdead
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|killem
operator|==
operator|-
literal|1
condition|)
block|{
name|yorn
operator|=
name|ask
argument_list|(
literal|"y"
argument_list|,
literal|"Should I kill your i-processes? "
argument_list|)
expr_stmt|;
name|killem
operator|=
operator|(
name|CharUpcase
argument_list|(
operator|*
name|yorn
argument_list|)
operator|==
literal|'Y'
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|killem
condition|)
name|proc_kill
argument_list|(
name|p
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|pbuftiedp
argument_list|(
name|b
argument_list|)
specifier|register
name|Buffer
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Process
modifier|*
name|p
init|=
name|b
operator|->
name|b_process
decl_stmt|;
if|if
condition|(
operator|!
name|isdead
argument_list|(
name|p
argument_list|)
condition|)
name|complain
argument_list|(
literal|"Process %s, attached to %b, is %s."
argument_list|,
name|proc_cmd
argument_list|(
name|p
argument_list|)
argument_list|,
name|b
argument_list|,
name|pstate
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Process receive: receives the characters in buf, and appends them to    the buffer associated with p. */
end_comment

begin_function
name|private
name|proc_rec
parameter_list|(
name|p
parameter_list|,
name|buf
parameter_list|)
specifier|register
name|Process
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|Buffer
modifier|*
name|saveb
init|=
name|curbuf
decl_stmt|;
specifier|register
name|Window
modifier|*
name|w
decl_stmt|;
specifier|register
name|Mark
modifier|*
name|savepoint
decl_stmt|;
name|int
name|sameplace
init|=
name|NO
decl_stmt|,
name|do_disp
init|=
name|NO
decl_stmt|;
if|if
condition|(
name|curwind
operator|->
name|w_bufp
operator|==
name|p
operator|->
name|p_buffer
condition|)
name|w
operator|=
name|curwind
expr_stmt|;
else|else
name|w
operator|=
name|windbp
argument_list|(
name|p
operator|->
name|p_buffer
argument_list|)
expr_stmt|;
comment|/* Is this window visible? */
if|if
condition|(
name|w
operator|!=
literal|0
condition|)
name|do_disp
operator|=
operator|(
name|in_window
argument_list|(
name|w
argument_list|,
name|p
operator|->
name|p_mark
operator|->
name|m_line
argument_list|)
operator|!=
operator|-
literal|1
operator|)
expr_stmt|;
name|SetBuf
argument_list|(
name|p
operator|->
name|p_buffer
argument_list|)
expr_stmt|;
name|savepoint
operator|=
name|MakeMark
argument_list|(
name|curline
argument_list|,
name|curchar
argument_list|,
name|M_FLOATER
argument_list|)
expr_stmt|;
name|ToMark
argument_list|(
name|p
operator|->
name|p_mark
argument_list|)
expr_stmt|;
comment|/* where output last stopped */
if|if
condition|(
name|savepoint
operator|->
name|m_line
operator|==
name|curline
operator|&&
name|savepoint
operator|->
name|m_char
operator|==
name|curchar
condition|)
name|sameplace
operator|=
name|YES
expr_stmt|;
name|ins_str
argument_list|(
name|buf
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|MarkSet
argument_list|(
name|p
operator|->
name|p_mark
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sameplace
condition|)
name|ToMark
argument_list|(
name|savepoint
argument_list|)
expr_stmt|;
comment|/* back to where we were */
name|DelMark
argument_list|(
name|savepoint
argument_list|)
expr_stmt|;
comment|/* redisplay now, instead of right after the ins_str, so that 	   we don't get a bouncing effect if point is not the same as 	   the process output position */
if|if
condition|(
name|do_disp
condition|)
block|{
name|w
operator|->
name|w_line
operator|=
name|curline
expr_stmt|;
name|w
operator|->
name|w_char
operator|=
name|curchar
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
name|SetBuf
argument_list|(
name|saveb
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|proc_kill
argument_list|(
name|p
argument_list|,
name|sig
argument_list|)
specifier|register
name|Process
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|isdead
argument_list|(
name|p
argument_list|)
condition|)
return|return;
if|if
condition|(
name|killpg
argument_list|(
name|p
operator|->
name|p_pid
argument_list|,
name|sig
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|s_mess
argument_list|(
literal|"Cannot kill %s!"
argument_list|,
name|proc_buf
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Free process CHILD.  Do all the necessary cleaning up (closing fd's,    etc.). */
end_comment

begin_macro
name|free_proc
argument_list|(
argument|child
argument_list|)
end_macro

begin_decl_stmt
name|Process
modifier|*
name|child
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Process
modifier|*
name|p
decl_stmt|,
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|isdead
argument_list|(
name|child
argument_list|)
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|procs
init|;
name|p
operator|!=
name|child
condition|;
name|prev
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|p_next
control|)
empty_stmt|;
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|procs
operator|=
name|child
operator|->
name|p_next
expr_stmt|;
else|else
name|prev
operator|->
name|p_next
operator|=
name|child
operator|->
name|p_next
expr_stmt|;
name|proc_close
argument_list|(
name|child
argument_list|)
expr_stmt|;
comment|/* if not already closed */
comment|/* It's possible that the buffer has been given another process 	   between the time CHILD dies and CHILD's death is noticed (via 	   list-processes).  So we only set it the buffer's process to 	   0 if CHILD is still the controlling process. */
if|if
condition|(
name|child
operator|->
name|p_buffer
operator|->
name|b_process
operator|==
name|child
condition|)
block|{
name|child
operator|->
name|p_buffer
operator|->
name|b_process
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|curbuf
operator|==
name|child
operator|->
name|p_buffer
condition|)
name|PopPBs
argument_list|()
expr_stmt|;
block|}
block|{
name|Buffer
modifier|*
name|old
init|=
name|curbuf
decl_stmt|;
name|SetBuf
argument_list|(
name|child
operator|->
name|p_buffer
argument_list|)
expr_stmt|;
name|DelMark
argument_list|(
name|child
operator|->
name|p_mark
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|child
operator|->
name|p_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|child
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ProcList
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|Process
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
literal|"%-15s  %-15s  %-8s %s"
decl_stmt|,
name|pidstr
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|procs
operator|==
literal|0
condition|)
block|{
name|message
argument_list|(
literal|"[No subprocesses]"
argument_list|)
expr_stmt|;
return|return;
block|}
name|TOstart
argument_list|(
literal|"Process list"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
name|fmt
argument_list|,
literal|"Buffer"
argument_list|,
literal|"Status"
argument_list|,
literal|"Pid "
argument_list|,
literal|"Command"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
name|fmt
argument_list|,
literal|"------"
argument_list|,
literal|"------"
argument_list|,
literal|"--- "
argument_list|,
literal|"-------"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|procs
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|p_next
expr_stmt|;
name|sprintf
argument_list|(
name|pidstr
argument_list|,
literal|"%d"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
name|fmt
argument_list|,
name|proc_buf
argument_list|(
name|p
argument_list|)
argument_list|,
name|pstate
argument_list|(
name|p
argument_list|)
argument_list|,
name|pidstr
argument_list|,
name|p
operator|->
name|p_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdead
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|free_proc
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|UpdModLine
operator|=
name|YES
expr_stmt|;
block|}
block|}
name|TOstop
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|ProcNewline
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|ABBREV
name|MaybeAbbrevExpand
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|SendData
argument_list|(
name|YES
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ProcSendData
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|ABBREV
name|MaybeAbbrevExpand
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|SendData
argument_list|(
name|NO
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|private
name|SendData
parameter_list|(
name|newlinep
parameter_list|)
block|{
specifier|register
name|Process
modifier|*
name|p
init|=
name|curbuf
operator|->
name|b_process
decl_stmt|;
specifier|register
name|char
modifier|*
name|lp
decl_stmt|,
modifier|*
name|gp
decl_stmt|;
comment|/* JF fix for better prompt handling */
if|if
condition|(
name|isdead
argument_list|(
name|p
argument_list|)
condition|)
return|return;
comment|/* If the process mark was involved in a big deletion, because 	   the user hit ^W or something, then let's do some magic with 	   the process mark.  Problem is that if the user yanks back the 	   text he deleted, the mark stays at the beginning of the region, 	   and so the next time SendData() is called the entire region 	   will be sent.  That's not good.  So, to deal with that we reset 	   the mark to the last line, after skipping over the prompt, etc. */
if|if
condition|(
name|p
operator|->
name|p_mark
operator|->
name|m_flags
operator|&
name|M_BIG_DELETE
condition|)
block|{
name|Bufpos
name|bp
decl_stmt|;
name|p
operator|->
name|p_mark
operator|->
name|m_flags
operator|&=
operator|~
name|M_BIG_DELETE
expr_stmt|;
name|DOTsave
argument_list|(
operator|&
name|bp
argument_list|)
expr_stmt|;
name|ToLast
argument_list|()
expr_stmt|;
name|Bol
argument_list|()
expr_stmt|;
comment|/* While we're looking at a prompt, and while we're 		   moving forward.  This is for people who accidently 		   set their process-prompt to ">*" which will always 		   match! */
while|while
condition|(
operator|(
name|LookingAt
argument_list|(
name|proc_prompt
argument_list|,
name|linebuf
argument_list|,
name|curchar
argument_list|)
operator|)
operator|&&
operator|(
name|REeom
operator|>
name|curchar
operator|)
condition|)
name|curchar
operator|=
name|REeom
expr_stmt|;
name|MarkSet
argument_list|(
name|p
operator|->
name|p_mark
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lastp
argument_list|(
name|curline
argument_list|)
condition|)
block|{
name|Eol
argument_list|()
expr_stmt|;
if|if
condition|(
name|newlinep
condition|)
name|LineInsert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|do_rtp
argument_list|(
name|p
operator|->
name|p_mark
argument_list|)
expr_stmt|;
name|MarkSet
argument_list|(
name|p
operator|->
name|p_mark
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Either we're looking at a prompt, or we're not, in 		   which case we want to strip off the beginning of the 		   line anything that looks like what the prompt at the 		   end of the file is.  In other words, if "(dbx) stop in 		   ProcessNewline" is the line we're on, and the last 		   line in the buffer is "(dbx) ", then we strip off the 		   leading "(dbx) " from this line, because we know it's 		   part of the prompt.  But this only happens if "(dbx) " 		   isn't one of the process prompts ... follow what I'm 		   saying? */
name|Bol
argument_list|()
expr_stmt|;
if|if
condition|(
name|LookingAt
argument_list|(
name|proc_prompt
argument_list|,
name|linebuf
argument_list|,
name|curchar
argument_list|)
condition|)
block|{
do|do
name|curchar
operator|=
name|REeom
expr_stmt|;
do|while
condition|(
operator|(
name|LookingAt
argument_list|(
name|proc_prompt
argument_list|,
name|linebuf
argument_list|,
name|curchar
argument_list|)
operator|)
operator|&&
operator|(
name|REeom
operator|>
name|curchar
operator|)
condition|)
do|;
name|strcpy
argument_list|(
name|genbuf
argument_list|,
name|linebuf
operator|+
name|curchar
argument_list|)
expr_stmt|;
name|Eof
argument_list|()
expr_stmt|;
name|ins_str
argument_list|(
name|genbuf
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|genbuf
argument_list|,
name|linebuf
operator|+
name|curchar
argument_list|)
expr_stmt|;
name|Eof
argument_list|()
expr_stmt|;
name|gp
operator|=
name|genbuf
expr_stmt|;
name|lp
operator|=
name|linebuf
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|==
operator|*
name|gp
operator|&&
operator|*
name|lp
operator|!=
literal|'\0'
condition|)
block|{
name|lp
operator|+=
literal|1
expr_stmt|;
name|gp
operator|+=
literal|1
expr_stmt|;
block|}
name|ins_str
argument_list|(
name|gp
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_macro
name|ShellProc
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|shbuf
init|=
literal|"*shell*"
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|buf_exists
argument_list|(
name|shbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
operator|||
name|isdead
argument_list|(
name|b
operator|->
name|b_process
argument_list|)
condition|)
name|proc_strt
argument_list|(
name|shbuf
argument_list|,
name|NO
argument_list|,
name|Shell
argument_list|,
literal|"-i"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|pop_wind
argument_list|(
name|shbuf
argument_list|,
name|NO
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|Iprocess
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|char
name|ShcomBuf
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|MakeName
argument_list|()
decl_stmt|;
specifier|register
name|char
modifier|*
name|command
decl_stmt|;
name|char
name|scratch
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|bufname
decl_stmt|;
name|int
name|cnt
init|=
literal|1
decl_stmt|;
name|Buffer
modifier|*
name|bp
decl_stmt|;
name|command
operator|=
name|ask
argument_list|(
name|ShcomBuf
argument_list|,
name|ProcFmt
argument_list|)
expr_stmt|;
name|null_ncpy
argument_list|(
name|ShcomBuf
argument_list|,
name|command
argument_list|,
operator|(
sizeof|sizeof
name|ShcomBuf
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bufname
operator|=
name|MakeName
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|scratch
argument_list|,
name|bufname
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|buf_exists
argument_list|(
name|scratch
argument_list|)
operator|)
operator|&&
operator|!
name|isdead
argument_list|(
name|bp
operator|->
name|b_process
argument_list|)
condition|)
name|sprintf
argument_list|(
name|scratch
argument_list|,
literal|"%s.%d"
argument_list|,
name|bufname
argument_list|,
name|cnt
operator|++
argument_list|)
expr_stmt|;
name|proc_strt
argument_list|(
name|scratch
argument_list|,
name|YES
argument_list|,
name|Shell
argument_list|,
name|ShFlags
argument_list|,
name|command
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|proc_child
argument_list|()
end_macro

begin_block
block|{
name|union
name|wait
name|w
decl_stmt|;
specifier|register
name|int
name|pid
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifndef|#
directive|ifndef
name|BSD4_2
name|pid
operator|=
name|wait2
argument_list|(
operator|&
name|w
operator|.
name|w_status
argument_list|,
operator|(
name|WNOHANG
operator||
name|WUNTRACED
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|wait3
argument_list|(
operator|&
name|w
argument_list|,
operator|(
name|WNOHANG
operator||
name|WUNTRACED
operator|)
argument_list|,
operator|(
expr|struct
name|rusage
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
operator|<=
literal|0
condition|)
break|break;
name|kill_off
argument_list|(
name|pid
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|kill_off
argument_list|(
name|pid
argument_list|,
name|w
argument_list|)
specifier|register
name|int
name|pid
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|union
name|wait
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Process
modifier|*
name|child
decl_stmt|;
if|if
condition|(
operator|(
name|child
operator|=
name|proc_pid
argument_list|(
name|pid
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|UpdModLine
operator|=
name|YES
expr_stmt|;
comment|/* we're changing state ... */
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|w
argument_list|)
condition|)
name|child
operator|->
name|p_state
operator|=
name|STOPPED
expr_stmt|;
else|else
block|{
name|child
operator|->
name|p_state
operator|=
name|DEAD
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|w
argument_list|)
condition|)
name|child
operator|->
name|p_howdied
operator|=
name|EXITED
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|child
operator|->
name|p_reason
operator|=
name|w
operator|.
name|w_termsig
expr_stmt|;
name|child
operator|->
name|p_howdied
operator|=
name|KILLED
expr_stmt|;
block|}
block|{
name|Buffer
modifier|*
name|save
init|=
name|curbuf
decl_stmt|;
name|char
name|mesg
index|[
literal|128
index|]
decl_stmt|;
comment|/* insert status message now */
name|sprintf
argument_list|(
name|mesg
argument_list|,
literal|"[Process %s: %s]\n"
argument_list|,
name|proc_cmd
argument_list|(
name|child
argument_list|)
argument_list|,
name|pstate
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|child
operator|->
name|p_buffer
argument_list|)
expr_stmt|;
name|ins_str
argument_list|(
name|mesg
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|save
argument_list|)
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Push/pod process bindings.  I openly acknowledge that this is a    kludge, but I can't be bothered making it right. */
end_comment

begin_struct
struct|struct
name|proc_bind
block|{
name|int
name|pb_key
decl_stmt|;
name|data_obj
modifier|*
modifier|*
name|pb_map
decl_stmt|;
name|data_obj
modifier|*
name|pb_push
decl_stmt|;
name|data_obj
modifier|*
name|pb_cmd
decl_stmt|;
name|struct
name|proc_bind
modifier|*
name|pb_next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|proc_bind
modifier|*
name|PBinds
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|PopPBs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|proc_bind
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|PBinds
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|pb_next
control|)
name|p
operator|->
name|pb_map
index|[
name|p
operator|->
name|pb_key
index|]
operator|=
name|p
operator|->
name|pb_push
expr_stmt|;
block|}
end_block

begin_macro
name|PushPBs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|proc_bind
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|PBinds
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|pb_next
control|)
block|{
name|p
operator|->
name|pb_push
operator|=
name|p
operator|->
name|pb_map
index|[
name|p
operator|->
name|pb_key
index|]
expr_stmt|;
name|p
operator|->
name|pb_map
index|[
name|p
operator|->
name|pb_key
index|]
operator|=
name|p
operator|->
name|pb_cmd
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* VARARGS0 */
end_comment

begin_macro
name|ProcBind
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|data_obj
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|findcom
argument_list|(
name|ProcFmt
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|s_mess
argument_list|(
literal|": %f %s "
argument_list|,
name|d
operator|->
name|Name
argument_list|)
expr_stmt|;
name|ProcB2
argument_list|(
name|mainmap
argument_list|,
name|EOF
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ProcB2
argument_list|(
argument|map
argument_list|,
argument|lastkey
argument_list|,
argument|cmd
argument_list|)
end_macro

begin_decl_stmt
name|data_obj
modifier|*
modifier|*
name|map
decl_stmt|,
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|proc_bind
modifier|*
name|p
decl_stmt|;
specifier|register
name|data_obj
modifier|*
modifier|*
name|nextmap
decl_stmt|;
name|int
name|c
decl_stmt|;
name|c
operator|=
name|addgetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|lastkey
operator|==
name|EOF
condition|)
name|complain
argument_list|(
literal|"[Empty key sequence]"
argument_list|)
expr_stmt|;
name|complain
argument_list|(
literal|"[Unexpected end-of-line]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nextmap
operator|=
name|IsPrefix
argument_list|(
name|map
index|[
name|c
index|]
argument_list|)
condition|)
name|ProcB2
argument_list|(
name|nextmap
argument_list|,
name|c
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|curbuf
operator|->
name|b_process
condition|)
name|PopPBs
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|PBinds
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|pb_next
control|)
if|if
condition|(
name|p
operator|->
name|pb_key
operator|==
name|c
operator|&&
name|p
operator|->
name|pb_map
operator|==
name|map
condition|)
break|break;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|proc_bind
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|pb_next
operator|=
name|PBinds
expr_stmt|;
name|PBinds
operator|=
name|p
expr_stmt|;
block|}
name|p
operator|->
name|pb_map
operator|=
name|map
expr_stmt|;
name|p
operator|->
name|pb_key
operator|=
name|c
expr_stmt|;
name|p
operator|->
name|pb_cmd
operator|=
name|cmd
expr_stmt|;
if|if
condition|(
name|curbuf
operator|->
name|b_process
condition|)
name|PushPBs
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPROCS */
end_comment

end_unit

