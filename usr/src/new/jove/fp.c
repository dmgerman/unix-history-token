begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_include
include|#
directive|include
file|"mac.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MSDOS
end_ifndef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MSDOS */
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_undef
undef|#
directive|undef
name|private
end_undef

begin_define
define|#
directive|define
name|private
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LINT_ARGS
end_ifdef

begin_function_decl
name|private
name|File
modifier|*
name|f_alloc
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|RAINBOW
end_ifdef

begin_function_decl
name|private
name|int
name|rbwrite
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_function_decl
name|private
name|File
modifier|*
name|f_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|RAINBOW
end_ifdef

begin_function_decl
name|private
name|int
name|rbwrite
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LINT_ARGS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_undef
undef|#
directive|undef
name|private
end_undef

begin_define
define|#
directive|define
name|private
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|L_SET
end_ifndef

begin_define
define|#
directive|define
name|L_SET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAXFILES
value|20
end_define

begin_comment
comment|/* good enough for my purposes */
end_comment

begin_decl_stmt
name|private
name|File
name|_openfiles
index|[
name|MAXFILES
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|File
modifier|*
name|f_alloc
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|,
name|fd
parameter_list|,
name|buffer
parameter_list|,
name|buf_size
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|buffer
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|fp
operator|=
name|_openfiles
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXFILES
condition|;
name|i
operator|++
operator|,
name|fp
operator|++
control|)
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|MAXFILES
condition|)
name|complain
argument_list|(
literal|"[Too many open files!]"
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_bufsize
operator|=
name|buf_size
expr_stmt|;
name|fp
operator|->
name|f_cnt
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|f_fd
operator|=
name|fd
expr_stmt|;
name|fp
operator|->
name|f_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
literal|0
condition|)
block|{
name|buffer
operator|=
name|emalloc
argument_list|(
name|buf_size
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_flags
operator||=
name|F_MYBUF
expr_stmt|;
block|}
name|fp
operator|->
name|f_base
operator|=
name|fp
operator|->
name|f_ptr
operator|=
name|buffer
expr_stmt|;
name|fp
operator|->
name|f_name
operator|=
name|copystr
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
end_block

begin_function
name|void
name|gc_openfiles
parameter_list|()
block|{
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|fp
operator|=
name|_openfiles
init|;
name|fp
operator|<
operator|&
name|_openfiles
index|[
name|MAXFILES
index|]
condition|;
name|fp
operator|++
control|)
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|!=
literal|0
operator|&&
operator|(
name|fp
operator|->
name|f_flags
operator|&
name|F_LOCKED
operator|)
operator|==
literal|0
condition|)
name|f_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|File
modifier|*
name|fd_open
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|,
name|fd
parameter_list|,
name|buffer
parameter_list|,
name|bsize
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|buffer
decl_stmt|;
end_function

begin_block
block|{
return|return
name|f_alloc
argument_list|(
name|name
argument_list|,
name|flags
argument_list|,
name|fd
argument_list|,
name|buffer
argument_list|,
name|bsize
argument_list|)
return|;
block|}
end_block

begin_function
name|File
modifier|*
name|f_open
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|,
name|buffer
parameter_list|,
name|buf_size
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|buffer
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|fd
decl_stmt|;
name|int
name|mode
init|=
name|F_MODE
argument_list|(
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|F_READ
condition|)
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|F_APPEND
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|mode
operator|=
name|F_WRITE
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|F_WRITE
condition|)
name|fd
operator|=
name|creat
argument_list|(
name|name
argument_list|,
name|CreatMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
return|return
name|NIL
return|;
ifdef|#
directive|ifdef
name|MSDOS
else|else
name|setmode
argument_list|(
name|fd
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
return|return
name|f_alloc
argument_list|(
name|name
argument_list|,
name|flags
argument_list|,
name|fd
argument_list|,
name|buffer
argument_list|,
name|buf_size
argument_list|)
return|;
block|}
end_block

begin_function
name|void
name|f_close
parameter_list|(
name|fp
parameter_list|)
name|File
modifier|*
name|fp
decl_stmt|;
block|{
name|flush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD4_2
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
operator|(
name|F_WRITE
operator||
name|F_APPEND
operator|)
condition|)
operator|(
name|void
operator|)
name|fsync
argument_list|(
name|fp
operator|->
name|f_fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
name|fp
operator|->
name|f_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
name|F_MYBUF
condition|)
name|free
argument_list|(
name|fp
operator|->
name|f_base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fp
operator|->
name|f_name
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_flags
operator|=
literal|0
expr_stmt|;
comment|/* indicates that we're available */
block|}
end_function

begin_function
name|int
name|filbuf
parameter_list|(
name|fp
parameter_list|)
name|File
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
operator|(
name|F_EOF
operator||
name|F_ERR
operator|)
condition|)
return|return
name|EOF
return|;
name|fp
operator|->
name|f_ptr
operator|=
name|fp
operator|->
name|f_base
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
do|do
endif|#
directive|endif
comment|/* MSDOS */
name|fp
operator|->
name|f_cnt
operator|=
name|read
argument_list|(
name|fp
operator|->
name|f_fd
argument_list|,
name|fp
operator|->
name|f_base
argument_list|,
name|fp
operator|->
name|f_bufsize
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
do|while
condition|(
name|fp
operator|->
name|f_cnt
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
endif|#
directive|endif
comment|/* MSDOS */
if|if
condition|(
name|fp
operator|->
name|f_cnt
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"[Read error %d]"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_flags
operator||=
name|F_ERR
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|f_cnt
operator|==
literal|0
condition|)
block|{
name|fp
operator|->
name|f_flags
operator||=
name|F_EOF
expr_stmt|;
return|return
name|EOF
return|;
block|}
name|io_chars
operator|+=
name|fp
operator|->
name|f_cnt
expr_stmt|;
return|return
name|getc
argument_list|(
name|fp
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|putstr
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|IBMPC
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* IBMPC */
name|write_emif
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
block|}
end_function

begin_function
name|void
name|fputnchar
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|,
name|fp
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
block|{
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|putc
argument_list|(
operator|*
name|s
operator|++
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|flusho
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|IBMPC
name|_flush
argument_list|(
name|EOF
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
block|}
end_function

begin_function
name|void
name|flush
parameter_list|(
name|fp
parameter_list|)
name|File
modifier|*
name|fp
decl_stmt|;
block|{
name|_flush
argument_list|(
name|EOF
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|f_seek
parameter_list|(
name|fp
parameter_list|,
name|offset
parameter_list|)
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
name|F_WRITE
condition|)
name|flush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_cnt
operator|=
literal|0
expr_stmt|;
comment|/* next read will filbuf(), next write 				   will flush() with no bad effects */
name|lseek
argument_list|(
name|fp
operator|->
name|f_fd
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
comment|/* is void - but for lints sake */
name|_flush
parameter_list|(
name|c
parameter_list|,
name|fp
parameter_list|)
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
operator|(
name|F_READ
operator||
name|F_STRING
operator||
name|F_ERR
operator|)
condition|)
return|return
name|EOF
return|;
if|if
condition|(
operator|(
operator|(
name|n
operator|=
operator|(
name|fp
operator|->
name|f_ptr
operator|-
name|fp
operator|->
name|f_base
operator|)
operator|)
operator|>
literal|0
operator|)
operator|&&
ifndef|#
directive|ifndef
name|RAINBOW
operator|(
name|write
argument_list|(
name|fp
operator|->
name|f_fd
argument_list|,
name|fp
operator|->
name|f_base
argument_list|,
name|n
argument_list|)
operator|!=
name|n
operator|)
operator|&&
else|#
directive|else
operator|(
name|rbwrite
argument_list|(
name|fp
operator|->
name|f_fd
argument_list|,
name|fp
operator|->
name|f_base
argument_list|,
name|n
argument_list|)
operator|!=
name|n
operator|)
operator|&&
endif|#
directive|endif
operator|(
name|fp
operator|!=
name|stdout
operator|)
condition|)
block|{
name|fp
operator|->
name|f_flags
operator||=
name|F_ERR
expr_stmt|;
name|error
argument_list|(
literal|"[I/O error(%d); file = %s, fd = %d]"
argument_list|,
name|errno
argument_list|,
name|fp
operator|->
name|f_name
argument_list|,
name|fp
operator|->
name|f_fd
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|f_cnt
operator|=
name|fp
operator|->
name|f_bufsize
expr_stmt|;
name|fp
operator|->
name|f_ptr
operator|=
name|fp
operator|->
name|f_base
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
return|return
name|putc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|f_gets
parameter_list|(
name|fp
parameter_list|,
name|buf
parameter_list|,
name|max
parameter_list|)
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|endp
init|=
name|buf
operator|+
name|max
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
name|F_EOF
condition|)
return|return
name|EOF
return|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\n'
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
comment|/* possibly different from NULL */
break|break;
comment|/* sorry we don't read nulls */
ifdef|#
directive|ifdef
name|MSDOS
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|'\n'
condition|)
break|break;
else|else
operator|*
name|cp
operator|++
operator|=
literal|'\r'
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MSDOS */
if|if
condition|(
name|cp
operator|>=
name|endp
condition|)
block|{
name|add_mess
argument_list|(
literal|" [Line too long]"
argument_list|)
expr_stmt|;
name|rbell
argument_list|()
expr_stmt|;
return|return
name|EOF
return|;
block|}
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|cp
operator|!=
name|buf
condition|)
name|add_mess
argument_list|(
literal|" [Incomplete last line]"
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_flags
operator||=
name|F_EOF
expr_stmt|;
return|return
name|EOF
return|;
block|}
name|io_lines
operator|+=
literal|1
expr_stmt|;
return|return
literal|0
return|;
comment|/* this means okay */
block|}
end_function

begin_comment
comment|/* skip to beginning of next line, i.e., next read returns first    character of new line */
end_comment

begin_function
name|void
name|f_toNL
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
name|F_EOF
condition|)
return|return;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\n'
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|fp
operator|->
name|f_flags
operator||=
name|F_EOF
expr_stmt|;
block|}
end_function

begin_function
name|void
name|f_readn
parameter_list|(
name|fp
parameter_list|,
name|addr
parameter_list|,
name|n
parameter_list|)
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
specifier|register
name|char
modifier|*
name|addr
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
block|{
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
operator|*
name|addr
operator|++
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|f_getint
parameter_list|(
name|fp
parameter_list|)
name|File
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|n
init|=
literal|0
decl_stmt|,
name|c
decl_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
condition|)
name|n
operator|=
operator|(
name|n
operator|*
literal|10
operator|)
operator|+
name|c
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Deals with output to the terminal, setting up the amount of characters    to be buffered depending on the output baud rate.  Why it's in a     separate file I don't know ... */
end_comment

begin_decl_stmt
name|private
name|char
name|one_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|BufSize
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|File
name|_stdout
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|F_WRITE
block|,
operator|&
name|one_buf
block|,
operator|&
name|one_buf
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|File
modifier|*
name|stdout
init|=
operator|&
name|_stdout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* put a string with padding */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IBMPC
end_ifndef

begin_function
name|void
name|tputc
parameter_list|(
name|c
parameter_list|)
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|putchar
end_undef

begin_comment
comment|/* for files which forget to include io.h, 					   here's a real putchar procedure. */
end_comment

begin_function
name|void
name|putchar
parameter_list|(
name|c
parameter_list|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IBMPC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAC
end_ifndef

begin_function
name|void
name|putpad
parameter_list|(
name|str
parameter_list|,
name|lines
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|IBMPC
if|if
condition|(
name|str
condition|)
name|tputs
argument_list|(
name|str
argument_list|,
name|lines
argument_list|,
name|tputc
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* IBMPC */
name|write_emif
argument_list|(
name|str
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Determine the number of characters to buffer at each baud rate.  The    lower the number, the quicker the response when new input arrives.  Of    course the lower the number, the more prone the program is to stop in    output.  Decide what matters most to you. This sets BufSize to the right    number or chars, and initiaizes `stdout'.  */
end_comment

begin_function
name|void
name|settout
parameter_list|(
name|ttbuf
parameter_list|)
name|char
modifier|*
name|ttbuf
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|MAC
ifndef|#
directive|ifndef
name|MSDOS
specifier|static
name|int
name|speeds
index|[]
init|=
block|{
literal|1
block|,
comment|/* 0	*/
literal|1
block|,
comment|/* 50	*/
literal|1
block|,
comment|/* 75	*/
literal|1
block|,
comment|/* 110	*/
literal|1
block|,
comment|/* 134	*/
literal|1
block|,
comment|/* 150	*/
literal|1
block|,
comment|/* 200	*/
literal|2
block|,
comment|/* 300	*/
literal|4
block|,
comment|/* 600	*/
literal|8
block|,
comment|/* 1200 */
literal|16
block|,
comment|/* 1800	*/
literal|32
block|,
comment|/* 2400	*/
literal|128
block|,
comment|/* 4800	*/
literal|256
block|,
comment|/* 9600	*/
literal|512
block|,
comment|/* EXTA	*/
literal|1024
comment|/* EXT	*/
block|}
decl_stmt|;
name|flusho
argument_list|()
expr_stmt|;
comment|/* flush the one character buffer */
name|BufSize
operator|=
name|min
argument_list|(
name|MAXTTYBUF
argument_list|,
name|speeds
index|[
name|ospeed
index|]
operator|*
name|max
argument_list|(
name|LI
operator|/
literal|24
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|stdout
operator|=
name|fd_open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|F_WRITE
operator||
name|F_LOCKED
argument_list|,
literal|1
argument_list|,
name|ttbuf
argument_list|,
name|BufSize
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MSDOS */
ifndef|#
directive|ifndef
name|IBMPC
name|flusho
argument_list|()
expr_stmt|;
comment|/* flush the one character buffer */
name|BufSize
operator|=
name|BUFSIZ
expr_stmt|;
name|stdout
operator|=
name|fd_open
argument_list|(
literal|"con"
argument_list|,
name|F_WRITE
operator||
name|F_LOCKED
argument_list|,
literal|1
argument_list|,
name|ttbuf
argument_list|,
name|BufSize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
endif|#
directive|endif
comment|/* MSDOS */
endif|#
directive|endif
comment|/* MAC */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|RAINBOW
end_ifdef

begin_comment
comment|/*  * use the Rainbow's video output function  */
end_comment

begin_include
include|#
directive|include
file|<dos.h>
end_include

begin_function
name|private
name|int
name|rbwrite
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|cnt
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|union
name|REGS
name|vr
decl_stmt|;
if|if
condition|(
name|fd
operator|!=
literal|1
condition|)
block|{
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|cnt
operator|--
operator|>
literal|0
condition|)
block|{
name|vr
operator|.
name|x
operator|.
name|ax
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
name|vr
operator|.
name|x
operator|.
name|di
operator|=
literal|0
expr_stmt|;
name|int86
argument_list|(
literal|0x18
argument_list|,
operator|&
name|vr
argument_list|,
operator|&
name|vr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RAINBOW */
end_comment

end_unit

