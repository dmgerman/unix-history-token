begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"re.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_include
include|#
directive|include
file|"mac.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_undef
undef|#
directive|undef
name|private
end_undef

begin_define
define|#
directive|define
name|private
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LINT_ARGS
end_ifdef

begin_function_decl
name|private
name|Bufpos
modifier|*
name|doisearch
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|void
name|IncSearch
argument_list|(
name|int
argument_list|)
decl_stmt|,
name|replace
argument_list|(
name|int
argument_list|,
name|int
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|isearch
argument_list|(
name|int
argument_list|,
name|Bufpos
operator|*
argument_list|)
decl_stmt|,
name|lookup
argument_list|(
name|char
operator|*
argument_list|,
name|char
operator|*
argument_list|,
name|char
operator|*
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|,
name|substitute
argument_list|(
name|int
argument_list|,
name|Line
operator|*
argument_list|,
name|int
argument_list|,
name|Line
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function_decl
name|private
name|Bufpos
modifier|*
name|doisearch
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|private
name|void
name|IncSearch
argument_list|()
decl_stmt|,
name|replace
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|isearch
argument_list|()
decl_stmt|,
name|lookup
argument_list|()
decl_stmt|,
name|substitute
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LINT_ARGS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_undef
undef|#
directive|undef
name|private
end_undef

begin_define
define|#
directive|define
name|private
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|private
name|int
name|substitute
parameter_list|(
name|query
parameter_list|,
name|l1
parameter_list|,
name|char1
parameter_list|,
name|l2
parameter_list|,
name|char2
parameter_list|)
name|Line
modifier|*
name|l1
decl_stmt|,
decl|*
name|l2
decl_stmt|;
end_function

begin_block
block|{
name|Line
modifier|*
name|lp
decl_stmt|;
name|int
name|numdone
init|=
literal|0
decl_stmt|,
name|offset
init|=
name|curchar
decl_stmt|,
name|stop
init|=
name|NO
decl_stmt|;
name|disk_line
name|UNDO_da
init|=
literal|0
decl_stmt|;
name|Line
modifier|*
name|UNDO_lp
init|=
literal|0
decl_stmt|;
name|lsave
argument_list|()
expr_stmt|;
name|REdirection
operator|=
name|FORWARD
expr_stmt|;
name|lp
operator|=
name|l1
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|l1
init|;
operator|(
name|lp
operator|!=
name|l2
operator|->
name|l_next
operator|)
operator|&&
operator|!
name|stop
condition|;
name|lp
operator|=
name|lp
operator|->
name|l_next
control|)
block|{
name|offset
operator|=
operator|(
name|lp
operator|==
name|l1
operator|)
condition|?
name|char1
else|:
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|stop
operator|&&
name|re_lindex
argument_list|(
name|lp
argument_list|,
name|offset
argument_list|,
name|compbuf
argument_list|,
name|alternates
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|lp
operator|==
name|l2
operator|&&
name|REeom
operator|>
name|char2
condition|)
comment|/* nope, leave this alone */
break|break;
name|DotTo
argument_list|(
name|lp
argument_list|,
name|REeom
argument_list|)
expr_stmt|;
name|offset
operator|=
name|curchar
expr_stmt|;
if|if
condition|(
name|query
condition|)
block|{
name|message
argument_list|(
literal|"Replace (Type '?' for help)? "
argument_list|)
expr_stmt|;
name|reswitch
label|:
name|redisplay
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|CharUpcase
argument_list|(
name|getchar
argument_list|()
argument_list|)
condition|)
block|{
case|case
literal|'.'
case|:
name|stop
operator|=
name|YES
expr_stmt|;
comment|/* Fall into ... */
case|case
literal|' '
case|:
case|case
literal|'Y'
case|:
break|break;
case|case
name|BS
case|:
case|case
name|RUBOUT
case|:
case|case
literal|'N'
case|:
if|if
condition|(
name|linebuf
index|[
name|offset
operator|++
index|]
operator|==
literal|'\0'
condition|)
goto|goto
name|nxtline
goto|;
continue|continue;
case|case
name|CTL
argument_list|(
literal|'W'
argument_list|)
case|:
name|re_dosub
argument_list|(
name|linebuf
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|numdone
operator|+=
literal|1
expr_stmt|;
name|offset
operator|=
name|curchar
operator|=
name|REbom
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
comment|/* Fall into ... */
case|case
name|CTL
argument_list|(
literal|'R'
argument_list|)
case|:
case|case
literal|'R'
case|:
name|RErecur
argument_list|()
expr_stmt|;
name|offset
operator|=
name|curchar
expr_stmt|;
name|lp
operator|=
name|curline
expr_stmt|;
continue|continue;
case|case
name|CTL
argument_list|(
literal|'U'
argument_list|)
case|:
case|case
literal|'U'
case|:
if|if
condition|(
name|UNDO_lp
operator|==
literal|0
condition|)
continue|continue;
name|lp
operator|=
name|UNDO_lp
expr_stmt|;
name|lp
operator|->
name|l_dline
operator|=
name|UNDO_da
operator||
name|DIRTY
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|numdone
operator|-=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'P'
case|:
case|case
literal|'!'
case|:
name|query
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CR
case|:
case|case
name|LF
case|:
case|case
literal|'Q'
case|:
goto|goto
name|done
goto|;
case|case
name|CTL
argument_list|(
literal|'L'
argument_list|)
case|:
name|RedrawDisplay
argument_list|()
expr_stmt|;
goto|goto
name|reswitch
goto|;
default|default:
name|rbell
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"Space or Y, Period, Rubout or N, C-R or R, C-W, C-U or U, P or !, Return."
argument_list|)
expr_stmt|;
goto|goto
name|reswitch
goto|;
block|}
block|}
name|re_dosub
argument_list|(
name|linebuf
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|numdone
operator|+=
literal|1
expr_stmt|;
name|modify
argument_list|()
expr_stmt|;
name|offset
operator|=
name|curchar
operator|=
name|REeom
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
condition|)
block|{
name|message
argument_list|(
name|mesgbuf
argument_list|)
expr_stmt|;
comment|/* no blinking */
name|redisplay
argument_list|()
expr_stmt|;
comment|/* show the change */
block|}
name|UNDO_da
operator|=
name|curline
operator|->
name|l_dline
expr_stmt|;
name|UNDO_lp
operator|=
name|curline
expr_stmt|;
if|if
condition|(
name|linebuf
index|[
name|offset
index|]
operator|==
literal|0
condition|)
name|nxtline
label|:
break|break;
block|}
block|}
name|done
label|:
return|return
name|numdone
return|;
block|}
end_block

begin_comment
comment|/* prompt for search and replacement strings and do the substitution */
end_comment

begin_function
name|private
name|void
name|replace
parameter_list|(
name|query
parameter_list|,
name|inreg
parameter_list|)
block|{
name|Mark
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|rep_ptr
decl_stmt|;
name|Line
modifier|*
name|l1
init|=
name|curline
decl_stmt|,
modifier|*
name|l2
init|=
name|curbuf
operator|->
name|b_last
decl_stmt|;
name|int
name|char1
init|=
name|curchar
decl_stmt|,
name|char2
init|=
name|length
argument_list|(
name|curbuf
operator|->
name|b_last
argument_list|)
decl_stmt|,
name|numdone
decl_stmt|;
if|if
condition|(
name|inreg
condition|)
block|{
name|m
operator|=
name|CurMark
argument_list|()
expr_stmt|;
name|l2
operator|=
name|m
operator|->
name|m_line
expr_stmt|;
name|char2
operator|=
name|m
operator|->
name|m_char
expr_stmt|;
operator|(
name|void
operator|)
name|fixorder
argument_list|(
operator|&
name|l1
argument_list|,
operator|&
name|char1
argument_list|,
operator|&
name|l2
argument_list|,
operator|&
name|char2
argument_list|)
expr_stmt|;
block|}
comment|/* get search string */
name|strcpy
argument_list|(
name|rep_search
argument_list|,
name|ask
argument_list|(
name|rep_search
index|[
literal|0
index|]
condition|?
name|rep_search
else|:
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|ProcFmt
argument_list|)
argument_list|)
expr_stmt|;
name|REcompile
argument_list|(
name|rep_search
argument_list|,
name|UseRE
argument_list|,
name|compbuf
argument_list|,
name|alternates
argument_list|)
expr_stmt|;
comment|/* Now the replacement string.  Do_ask() so the user can play with 	   the default (previous) replacement string by typing C-R in ask(), 	   OR, he can just hit Return to replace with nothing. */
name|rep_ptr
operator|=
name|do_ask
argument_list|(
literal|"\r\n"
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
argument_list|,
name|rep_str
argument_list|,
literal|": %f %s with "
argument_list|,
name|rep_search
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep_ptr
operator|==
literal|0
condition|)
name|rep_ptr
operator|=
name|NullStr
expr_stmt|;
name|strcpy
argument_list|(
name|rep_str
argument_list|,
name|rep_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|numdone
operator|=
name|substitute
argument_list|(
name|query
argument_list|,
name|l1
argument_list|,
name|char1
argument_list|,
name|l2
argument_list|,
name|char2
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|inreg
operator|==
name|NO
operator|)
condition|)
block|{
name|do_set_mark
argument_list|(
name|l1
argument_list|,
name|char1
argument_list|)
expr_stmt|;
name|add_mess
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
comment|/* just making things pretty */
block|}
else|else
name|message
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|add_mess
argument_list|(
literal|"(%d substitution%n)"
argument_list|,
name|numdone
argument_list|,
name|numdone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|RegReplace
parameter_list|()
block|{
name|replace
argument_list|(
literal|0
argument_list|,
name|YES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|QRepSearch
parameter_list|()
block|{
name|replace
argument_list|(
literal|1
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|RepSearch
parameter_list|()
block|{
name|replace
argument_list|(
literal|0
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lookup a tag in tag file FILE.  FILE is assumed to be sorted    alphabetically.  The FASTTAGS code, which is implemented with    a binary search, depends on this assumption.  If it's not true    it is possible to comment out the fast tag code (which is clearly    labeled) and everything else will just work. */
end_comment

begin_function
name|private
name|int
name|lookup
parameter_list|(
name|searchbuf
parameter_list|,
name|filebuf
parameter_list|,
name|tag
parameter_list|,
name|file
parameter_list|)
name|char
modifier|*
name|searchbuf
decl_stmt|,
decl|*
name|filebuf
decl_stmt|,
modifier|*
name|tag
decl_stmt|,
modifier|*
name|file
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|taglen
init|=
name|strlen
argument_list|(
name|tag
argument_list|)
decl_stmt|;
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|pattern
index|[
literal|128
index|]
decl_stmt|;
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|int
name|fast
init|=
name|YES
decl_stmt|,
name|success
init|=
name|NO
decl_stmt|;
specifier|register
name|off_t
name|lower
decl_stmt|,
name|upper
decl_stmt|;
name|sprintf
argument_list|(
name|pattern
argument_list|,
literal|"^%s[^\t]*\t*\\([^\t]*\\)\t*[?/]\\([^?/]*\\)[?/]"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|file
argument_list|,
name|iobuff
argument_list|,
name|F_READ
argument_list|,
operator|!
name|COMPLAIN
argument_list|,
name|QUIET
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NIL
condition|)
return|return
literal|0
return|;
comment|/* ********BEGIN FAST TAG CODE******** */
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
name|fast
operator|=
name|NO
expr_stmt|;
else|else
block|{
name|lower
operator|=
literal|0
expr_stmt|;
name|upper
operator|=
name|stbuf
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|upper
operator|-
name|lower
operator|<
name|BUFSIZ
condition|)
name|fast
operator|=
name|NO
expr_stmt|;
block|}
if|if
condition|(
name|fast
operator|==
name|YES
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
name|off_t
name|mid
decl_stmt|;
name|int
name|whichway
decl_stmt|,
name|chars_eq
decl_stmt|;
if|if
condition|(
name|upper
operator|-
name|lower
operator|<
name|BUFSIZ
condition|)
block|{
name|f_seek
argument_list|(
name|fp
argument_list|,
name|lower
argument_list|)
expr_stmt|;
break|break;
comment|/* stop this nonsense */
block|}
name|mid
operator|=
operator|(
name|lower
operator|+
name|upper
operator|)
operator|/
literal|2
expr_stmt|;
name|f_seek
argument_list|(
name|fp
argument_list|,
name|mid
argument_list|)
expr_stmt|;
name|f_toNL
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_gets
argument_list|(
name|fp
argument_list|,
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|)
operator|==
name|EOF
condition|)
break|break;
name|chars_eq
operator|=
name|numcomp
argument_list|(
name|line
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars_eq
operator|==
name|taglen
operator|&&
name|iswhite
argument_list|(
name|line
index|[
name|chars_eq
index|]
argument_list|)
condition|)
goto|goto
name|found
goto|;
name|whichway
operator|=
name|line
index|[
name|chars_eq
index|]
operator|-
name|tag
index|[
name|chars_eq
index|]
expr_stmt|;
if|if
condition|(
name|whichway
operator|<
literal|0
condition|)
block|{
comment|/* line is BEFORE tag */
name|lower
operator|=
name|mid
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|whichway
operator|>
literal|0
condition|)
block|{
comment|/* line is AFTER tag */
name|upper
operator|=
name|mid
expr_stmt|;
continue|continue;
block|}
block|}
name|f_toNL
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* END FAST TAG CODE */
while|while
condition|(
name|f_gets
argument_list|(
name|fp
argument_list|,
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|)
operator|!=
name|EOF
condition|)
block|{
name|int
name|cmp
decl_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|>
operator|*
name|tag
condition|)
break|break;
elseif|else
if|if
condition|(
operator|(
name|cmp
operator|=
name|strncmp
argument_list|(
name|line
argument_list|,
name|tag
argument_list|,
name|taglen
argument_list|)
operator|)
operator|>
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
continue|continue;
comment|/* if we get here, we've found the match */
name|found
label|:
if|if
condition|(
operator|!
name|LookingAt
argument_list|(
name|pattern
argument_list|,
name|line
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|complain
argument_list|(
literal|"I thought I saw it!"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|putmatch
argument_list|(
literal|1
argument_list|,
name|filebuf
argument_list|,
name|FILESIZE
argument_list|)
expr_stmt|;
name|putmatch
argument_list|(
literal|2
argument_list|,
name|searchbuf
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|success
operator|=
name|YES
expr_stmt|;
break|break;
block|}
block|}
name|close_file
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|==
name|NO
condition|)
name|s_mess
argument_list|(
literal|"Can't find tag \"%s\"."
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|MSDOS
end_ifndef

begin_decl_stmt
name|char
name|TagFile
index|[
name|FILESIZE
index|]
init|=
literal|"./tags"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MSDOS */
end_comment

begin_decl_stmt
name|char
name|TagFile
index|[
name|FILESIZE
index|]
init|=
literal|"tags"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_function
name|void
name|find_tag
parameter_list|(
name|tag
parameter_list|,
name|localp
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|char
name|filebuf
index|[
name|FILESIZE
index|]
decl_stmt|,
name|sstr
index|[
literal|100
index|]
decl_stmt|,
name|tfbuf
index|[
name|FILESIZE
index|]
decl_stmt|;
specifier|register
name|Bufpos
modifier|*
name|bp
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|tagfname
decl_stmt|;
if|if
condition|(
operator|!
name|localp
condition|)
block|{
name|char
name|prompt
index|[
literal|128
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|prompt
argument_list|,
literal|"With tag file (%s default): "
argument_list|,
name|TagFile
argument_list|)
expr_stmt|;
name|tagfname
operator|=
name|ask_file
argument_list|(
name|prompt
argument_list|,
name|TagFile
argument_list|,
name|tfbuf
argument_list|)
expr_stmt|;
block|}
else|else
name|tagfname
operator|=
name|TagFile
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|(
name|sstr
argument_list|,
name|filebuf
argument_list|,
name|tag
argument_list|,
name|tagfname
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|set_mark
argument_list|()
expr_stmt|;
name|b
operator|=
name|do_find
argument_list|(
name|curwind
argument_list|,
name|filebuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|curbuf
operator|!=
name|b
condition|)
name|SetABuf
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|dosearch
argument_list|(
name|sstr
argument_list|,
name|BACKWARD
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|bp
operator|=
name|dosearch
argument_list|(
name|sstr
argument_list|,
name|FORWARD
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
name|message
argument_list|(
literal|"Well, I found the file, but the tag is missing."
argument_list|)
expr_stmt|;
else|else
name|SetDot
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|FindTag
parameter_list|()
block|{
name|int
name|localp
init|=
operator|!
name|is_an_arg
argument_list|()
decl_stmt|;
name|char
name|tag
index|[
literal|128
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|tag
argument_list|,
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|ProcFmt
argument_list|)
argument_list|)
expr_stmt|;
name|find_tag
argument_list|(
name|tag
argument_list|,
name|localp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find Tag at Dot. */
end_comment

begin_function
name|void
name|FDotTag
parameter_list|()
block|{
name|int
name|c1
init|=
name|curchar
decl_stmt|,
name|c2
init|=
name|c1
decl_stmt|;
name|char
name|tagname
index|[
literal|50
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ismword
argument_list|(
name|linebuf
index|[
name|curchar
index|]
argument_list|)
condition|)
name|complain
argument_list|(
literal|"Not a tag!"
argument_list|)
expr_stmt|;
while|while
condition|(
name|c1
operator|>
literal|0
operator|&&
name|ismword
argument_list|(
name|linebuf
index|[
name|c1
operator|-
literal|1
index|]
argument_list|)
condition|)
name|c1
operator|-=
literal|1
expr_stmt|;
while|while
condition|(
name|ismword
argument_list|(
name|linebuf
index|[
name|c2
index|]
argument_list|)
condition|)
name|c2
operator|+=
literal|1
expr_stmt|;
name|null_ncpy
argument_list|(
name|tagname
argument_list|,
name|linebuf
operator|+
name|c1
argument_list|,
name|c2
operator|-
name|c1
argument_list|)
expr_stmt|;
name|find_tag
argument_list|(
name|tagname
argument_list|,
operator|!
name|is_an_arg
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* I-search returns a code saying what to do:    STOP:	We found the match, so unwind the stack and leave 		where it is.    DELETE:	Rubout the last command.    BACKUP:	Back up to where the isearch was last NOT failing.     When a character is typed it is appended to the search string, and    then, isearch is called recursively.  When C-S or C-R is typed, isearch    is again called recursively. */
end_comment

begin_define
define|#
directive|define
name|STOP
value|1
end_define

begin_define
define|#
directive|define
name|DELETE
value|2
end_define

begin_define
define|#
directive|define
name|BACKUP
value|3
end_define

begin_define
define|#
directive|define
name|TOSTART
value|4
end_define

begin_decl_stmt
specifier|static
name|char
name|ISbuf
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|incp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|SExitChar
init|=
name|CR
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|cmp_char
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a) == (b) || (CaseIgnore&& (CharUpcase(a) == CharUpcase(b))))
end_define

begin_function
specifier|static
name|Bufpos
modifier|*
name|doisearch
parameter_list|(
name|dir
parameter_list|,
name|c
parameter_list|,
name|failing
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|,
name|dir
decl_stmt|,
name|failing
decl_stmt|;
block|{
specifier|static
name|Bufpos
name|buf
decl_stmt|;
name|Bufpos
modifier|*
name|bp
decl_stmt|;
specifier|extern
name|int
name|okay_wrap
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|CTL
argument_list|(
literal|'S'
argument_list|)
operator|||
name|c
operator|==
name|CTL
argument_list|(
literal|'R'
argument_list|)
condition|)
goto|goto
name|dosrch
goto|;
if|if
condition|(
name|failing
condition|)
return|return
literal|0
return|;
name|DOTsave
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|FORWARD
condition|)
block|{
if|if
condition|(
name|cmp_char
argument_list|(
name|linebuf
index|[
name|curchar
index|]
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|buf
operator|.
name|p_char
operator|=
name|curchar
operator|+
literal|1
expr_stmt|;
return|return
operator|&
name|buf
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|look_at
argument_list|(
name|ISbuf
argument_list|)
condition|)
return|return
operator|&
name|buf
return|;
block|}
name|dosrch
label|:
name|okay_wrap
operator|=
name|YES
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|dosearch
argument_list|(
name|ISbuf
argument_list|,
name|dir
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|rbell
argument_list|()
expr_stmt|;
comment|/* ring the first time there's no match */
name|okay_wrap
operator|=
name|NO
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_function
name|void
name|IncFSearch
parameter_list|()
block|{
name|IncSearch
argument_list|(
name|FORWARD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|IncRSearch
parameter_list|()
block|{
name|IncSearch
argument_list|(
name|BACKWARD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|IncSearch
parameter_list|(
name|dir
parameter_list|)
block|{
name|Bufpos
name|save_env
decl_stmt|;
name|DOTsave
argument_list|(
operator|&
name|save_env
argument_list|)
expr_stmt|;
name|ISbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|incp
operator|=
name|ISbuf
expr_stmt|;
if|if
condition|(
name|isearch
argument_list|(
name|dir
argument_list|,
operator|&
name|save_env
argument_list|)
operator|==
name|TOSTART
condition|)
name|SetDot
argument_list|(
operator|&
name|save_env
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|LineDist
argument_list|(
name|curline
argument_list|,
name|save_env
operator|.
name|p_line
argument_list|)
operator|>=
name|MarkThresh
condition|)
name|do_set_mark
argument_list|(
name|save_env
operator|.
name|p_line
argument_list|,
name|save_env
operator|.
name|p_char
argument_list|)
expr_stmt|;
block|}
name|setsearch
argument_list|(
name|ISbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nicely recursive. */
end_comment

begin_function
name|private
name|int
name|isearch
parameter_list|(
name|dir
parameter_list|,
name|bp
parameter_list|)
name|Bufpos
modifier|*
name|bp
decl_stmt|;
block|{
name|Bufpos
name|pushbp
decl_stmt|;
name|int
name|c
decl_stmt|,
name|ndir
decl_stmt|,
name|failing
decl_stmt|;
name|char
modifier|*
name|orig_incp
decl_stmt|;
if|if
condition|(
name|bp
operator|!=
literal|0
condition|)
block|{
comment|/* Move to the new position. */
name|pushbp
operator|.
name|p_line
operator|=
name|bp
operator|->
name|p_line
expr_stmt|;
name|pushbp
operator|.
name|p_char
operator|=
name|bp
operator|->
name|p_char
expr_stmt|;
name|SetDot
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|failing
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|DOTsave
argument_list|(
operator|&
name|pushbp
argument_list|)
expr_stmt|;
name|failing
operator|=
literal|1
expr_stmt|;
block|}
name|orig_incp
operator|=
name|incp
expr_stmt|;
name|ndir
operator|=
name|dir
expr_stmt|;
comment|/* Same direction as when we got here, unless 				   we change it with C-S or C-R. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|SetDot
argument_list|(
operator|&
name|pushbp
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
if|if
condition|(
name|failing
condition|)
name|add_mess
argument_list|(
literal|"Failing "
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|BACKWARD
condition|)
name|add_mess
argument_list|(
literal|"reverse-"
argument_list|)
expr_stmt|;
name|add_mess
argument_list|(
literal|"I-search: %s"
argument_list|,
name|ISbuf
argument_list|)
expr_stmt|;
name|DrawMesg
argument_list|(
name|NO
argument_list|)
expr_stmt|;
name|add_mess
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
comment|/* tell me this is disgusting ... */
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SExitChar
condition|)
return|return
name|STOP
return|;
if|if
condition|(
name|c
operator|==
name|AbortChar
condition|)
block|{
comment|/* If we're failing, we backup until we're no longer 			   failing or we've reached the beginning; else, we 			   just about the search and go back to the start. */
if|if
condition|(
name|failing
condition|)
return|return
name|BACKUP
return|;
return|return
name|TOSTART
return|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|RUBOUT
case|:
case|case
name|BS
case|:
return|return
name|DELETE
return|;
case|case
name|CTL
argument_list|(
literal|'\\'
argument_list|)
case|:
name|c
operator|=
name|CTL
argument_list|(
literal|'S'
argument_list|)
expr_stmt|;
case|case
name|CTL
argument_list|(
literal|'S'
argument_list|)
case|:
case|case
name|CTL
argument_list|(
literal|'R'
argument_list|)
case|:
comment|/* If this is the first time through and we have a 			   search string left over from last time, use that 			   one now. */
if|if
condition|(
name|incp
operator|==
name|ISbuf
condition|)
block|{
name|strcpy
argument_list|(
name|ISbuf
argument_list|,
name|getsearch
argument_list|()
argument_list|)
expr_stmt|;
name|incp
operator|=
operator|&
name|ISbuf
index|[
name|strlen
argument_list|(
name|ISbuf
argument_list|)
index|]
expr_stmt|;
block|}
name|ndir
operator|=
operator|(
name|c
operator|==
name|CTL
argument_list|(
literal|'S'
argument_list|)
operator|)
condition|?
name|FORWARD
else|:
name|BACKWARD
expr_stmt|;
comment|/* If we're failing and we're not changing our 			   direction, don't recur since there's no way 			   the search can work. */
if|if
condition|(
name|failing
operator|&&
name|ndir
operator|==
name|dir
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|incp
operator|>
operator|&
name|ISbuf
index|[
operator|(
sizeof|sizeof
name|ISbuf
operator|)
operator|-
literal|1
index|]
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
continue|continue;
block|}
operator|*
name|incp
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|add_mess
argument_list|(
literal|"\\"
argument_list|)
expr_stmt|;
comment|/* Fall into ... */
case|case
name|CTL
argument_list|(
literal|'Q'
argument_list|)
case|:
case|case
name|CTL
argument_list|(
literal|'^'
argument_list|)
case|:
name|add_mess
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
operator||
literal|0400
expr_stmt|;
comment|/* Fall into ... */
default|default:
if|if
condition|(
name|c
operator|&
literal|0400
condition|)
name|c
operator|&=
name|CHARMASK
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|IBMPC
if|if
condition|(
name|c
operator|==
name|RUBOUT
operator|||
name|c
operator|==
literal|0xff
operator|||
operator|(
name|c
operator|<
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|c
operator|>
name|RUBOUT
operator|||
operator|(
name|c
operator|<
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|)
condition|)
block|{
endif|#
directive|endif
name|Ungetc
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|STOP
return|;
block|}
block|}
if|if
condition|(
name|incp
operator|>
operator|&
name|ISbuf
index|[
operator|(
sizeof|sizeof
name|ISbuf
operator|)
operator|-
literal|1
index|]
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
continue|continue;
block|}
operator|*
name|incp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|incp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|add_mess
argument_list|(
literal|"%s"
argument_list|,
name|orig_incp
argument_list|)
expr_stmt|;
name|add_mess
argument_list|(
literal|" ..."
argument_list|)
expr_stmt|;
comment|/* so we know what's going on */
name|DrawMesg
argument_list|(
name|NO
argument_list|)
expr_stmt|;
comment|/* do it now */
switch|switch
condition|(
name|isearch
argument_list|(
name|ndir
argument_list|,
name|doisearch
argument_list|(
name|ndir
argument_list|,
name|c
argument_list|,
name|failing
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|TOSTART
case|:
return|return
name|TOSTART
return|;
case|case
name|STOP
case|:
return|return
name|STOP
return|;
case|case
name|BACKUP
case|:
comment|/* If we're not failing, we just continue to to the 			   for loop; otherwise we keep returning to the  			   previous levels until we find one that isn't 			   failing OR we reach the beginning. */
if|if
condition|(
name|failing
condition|)
return|return
name|BACKUP
return|;
comment|/* Fall into ... */
case|case
name|DELETE
case|:
name|incp
operator|=
name|orig_incp
expr_stmt|;
operator|*
name|incp
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
block|}
end_function

end_unit

