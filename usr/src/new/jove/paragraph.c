begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_undef
undef|#
directive|undef
name|private
end_undef

begin_define
define|#
directive|define
name|private
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LINT_ARGS
end_ifdef

begin_function_decl
name|private
name|int
name|get_indent
parameter_list|(
name|Line
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|Line
modifier|*
name|tailrule
parameter_list|(
name|Line
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|private
name|int
name|get_indent
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|private
name|Line
modifier|*
name|tailrule
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_undef
undef|#
directive|undef
name|private
end_undef

begin_define
define|#
directive|define
name|private
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Thanks to Brian Harvey for this paragraph boundery finding algorithm.    It's really quite hairy figuring it out.  This deals with paragraphs that    are seperated by blank lines, lines beginning with a Period (assumed to    be an nroff command), lines beginning with BackSlash (assumed to be Tex    commands).  Also handles paragraphs that are separated by lines of    different indent; and it deals with outdented paragraphs, too.  It's    really quite nice.  Here's Brian's algorithm.     Definitions:        THIS means the line containing the cursor.    PREV means the line above THIS.    NEXT means the line below THIS.        BLANK means empty, empty except for spaces and tabs, starts with a period    or a backslash, or nonexistent (because the edge of the buffer is    reached).  ((BH 12/24/85 A line starting with backslash is blank only if    the following line also starts with backslash.  This is so that \noindent    is part of a paragraph, but long strings of TeX commands don't get    rearranged.  It still isn't perfect but it's better.))     BSBLANK means BLANK or starts with a backslash.  (BH 12/24/85)        HEAD means the first (nonblank) line of the paragraph containing THIS.    BODY means all other (nonblank) lines of the paragraph.    TAIL means the last (nb) line of the paragraph.  (TAIL is part of BODY.)        HEAD INDENT means the indentation of HEAD.  M-J should preserve this.    BODY INDENT means the indentation of BODY.  Ditto.        Subprocedures:        TAILRULE(BODYLINE)    If BODYLINE is BLANK, the paragraph has only one line, and there is no    BODY and therefore no TAIL.  Return.  Otherwise, starting from BODYLINE,    move down until you find a line that either is BSBLANK or has a different    indentation from BODYLINE.  The line above that different line is TAIL.    Return.        Rules:        1.  If THIS is BLANK, which command are you doing?  If M-J or M-[, then go    up to the first non-BLANK line and start over.  (If there is no non-BLANK    line before THIS, ring the bell.)  If M-], then the first non-BLANK line    below THIS is HEAD, and the second consecutive non-BSBLANK line (if any) is    the beginning of BODY.  (If there is no non-BLANK line after THIS, ring    the bell.)  Do TAILRULE(beginning-of-BODY).  Go to rule A.     2.  If PREV is BLANK or THIS is BSBLANK, then THIS is HEAD, and NEXT (if    not BSBLANK) is in BODY.  Do TAILRULE(NEXT).  Go to rule A.     3.  If NEXT is BSBLANK, then THIS is TAIL, therefore part of BODY.  Go to    rule 5 to find HEAD.        4.  If either NEXT or PREV has the same indentation as THIS, then THIS is    part of BODY.  Do TAILRULE(THIS).  Go to rule 5 to find HEAD.  Otherwise,    go to rule 6.        5.  Go up until you find a line that is either BSBLANK or has a different    indentation from THIS.  If that line is BLANK, the line below it is HEAD.    If that line is non-BLANK, then call that new line THIS for what follows.    If (the new) PREV has the same indent as THIS, then (the new) NEXT is    HEAD.  If PREV has a different indent from THIS, then THIS is HEAD.  Go to    rule A.        6.  If you got here, then both NEXT and PREV are nonblank and are    differently indented from THIS.  This is a tricky case and there is no    guarantee that you're going to win.  The most straightforward thing to do    is assume that we are not using hanging indentation.  In that case:    whichever of PREV and THIS is indented further is HEAD.  Do    TAILRULE(HEAD+1).  Go to rule A.        6+.  A more complicated variant would be this: if THIS is indented further    than PREV, we are using regular indentation and rule 6 applies.  If PREV    is indented further than THIS, look at both NEXT and the line after NEXT.    If those two lines are indented equally, and more than THIS, then we are    using hanging indent, THIS is HEAD, and NEXT is the first line of BODY.    Do TAILRULE(NEXT).  Otherwise, rule 6 applies.        A.  You now know where HEAD and TAIL are.  The indentation of HEAD is HEAD    INDENT; the indentation of TAIL is BODY INDENT.        B.  If you are trying to M-J, you are now ready to do it.        C.  If you are trying to M-], leave point after the newline that ends    TAIL.  In other words, leave the cursor at the beginning of the line    after TAIL.  It is not possible for this to leave point where it started    unless it was already at the end of the buffer.        D.  If you are trying to M-[, if the line before HEAD is not BLANK, then    leave point just before HEAD.  That is, leave the cursor at the beginning    of HEAD.  If the line before HEAD is BLANK, then leave the cursor at the    beginning of that line.  If the cursor didn't move, go up to the first    earlier non-BLANK line and start over.      End of Algorithm.  I implemented rule 6+ because it seemed nicer.  */
end_comment

begin_decl_stmt
name|int
name|RMargin
init|=
literal|78
decl_stmt|,
name|LMargin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Line
modifier|*
name|para_head
decl_stmt|,
modifier|*
name|para_tail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|head_indent
decl_stmt|,
name|body_indent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_lmargin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* some defines for paragraph boundery checking */
end_comment

begin_define
define|#
directive|define
name|I_EMPTY
value|-1
end_define

begin_comment
comment|/* line "looks" empty (spaces and tabs) */
end_comment

begin_define
define|#
directive|define
name|I_PERIOD
value|-2
end_define

begin_comment
comment|/* line begins with "." or "\" */
end_comment

begin_define
define|#
directive|define
name|I_BUFEDGE
value|-3
end_define

begin_comment
comment|/* line is nonexistent (edge of buffer) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bslash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if get_indent finds line starting 				   with backslash */
end_comment

begin_function
name|int
name|i_bsblank
parameter_list|(
name|lp
parameter_list|)
name|Line
modifier|*
name|lp
decl_stmt|;
block|{
if|if
condition|(
name|i_blank
argument_list|(
name|lp
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|bslash
return|;
block|}
end_function

begin_function
name|int
name|i_blank
parameter_list|(
name|lp
parameter_list|)
name|Line
modifier|*
name|lp
decl_stmt|;
block|{
return|return
operator|(
name|get_indent
argument_list|(
name|lp
argument_list|)
operator|<
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|private
name|int
name|get_indent
parameter_list|(
name|lp
parameter_list|)
specifier|register
name|Line
modifier|*
name|lp
decl_stmt|;
block|{
name|Bufpos
name|save
decl_stmt|;
specifier|register
name|int
name|indent
decl_stmt|;
name|bslash
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lp
operator|==
literal|0
condition|)
return|return
name|I_BUFEDGE
return|;
name|DOTsave
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
name|SetLine
argument_list|(
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|blnkp
argument_list|(
name|linebuf
argument_list|)
condition|)
name|indent
operator|=
name|I_EMPTY
expr_stmt|;
elseif|else
if|if
condition|(
name|linebuf
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
name|indent
operator|=
name|I_PERIOD
expr_stmt|;
elseif|else
if|if
condition|(
name|linebuf
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
block|{
comment|/* BH 12/24/85.  Backslash is BLANK only if next line 		   also starts with Backslash. */
name|bslash
operator|+=
literal|1
expr_stmt|;
name|SetLine
argument_list|(
name|lp
operator|->
name|l_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuf
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
name|indent
operator|=
name|I_PERIOD
expr_stmt|;
else|else
name|indent
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ToIndent
argument_list|()
expr_stmt|;
name|indent
operator|=
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
name|SetDot
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
return|return
name|indent
return|;
block|}
end_function

begin_function
name|private
name|Line
modifier|*
name|tailrule
parameter_list|(
name|lp
parameter_list|)
specifier|register
name|Line
modifier|*
name|lp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|get_indent
argument_list|(
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
name|lp
return|;
comment|/* one line paragraph */
do|do
block|{
if|if
condition|(
operator|(
name|get_indent
argument_list|(
name|lp
operator|->
name|l_next
argument_list|)
operator|!=
name|i
operator|)
operator|||
name|bslash
condition|)
comment|/* BH line with backslash is head of next para */
break|break;
block|}
do|while
condition|(
operator|(
name|lp
operator|=
name|lp
operator|->
name|l_next
operator|)
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|lp
operator|==
literal|0
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|lp
return|;
block|}
end_function

begin_comment
comment|/* Finds the beginning, end and indent of the current paragraph, and sets    the above global variables.  HOW says how to behave when we're between    paragraphs.  That is, it's either FORWARD or BACKWARD depending on which    way we're favoring. */
end_comment

begin_function
name|void
name|find_para
parameter_list|(
name|how
parameter_list|)
block|{
name|Line
modifier|*
name|this
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|head
init|=
literal|0
decl_stmt|,
modifier|*
name|body
init|=
literal|0
decl_stmt|,
modifier|*
name|tail
init|=
literal|0
decl_stmt|;
name|int
name|this_indent
decl_stmt|;
name|Bufpos
name|orig
decl_stmt|;
comment|/* remember where we were when we started */
name|DOTsave
argument_list|(
operator|&
name|orig
argument_list|)
expr_stmt|;
name|strt
label|:
name|this
operator|=
name|curline
expr_stmt|;
name|prev
operator|=
name|curline
operator|->
name|l_prev
expr_stmt|;
name|next
operator|=
name|curline
operator|->
name|l_next
expr_stmt|;
name|this_indent
operator|=
name|get_indent
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_blank
argument_list|(
name|this
argument_list|)
condition|)
block|{
comment|/* rule 1 */
if|if
condition|(
name|how
operator|==
name|BACKWARD
condition|)
block|{
while|while
condition|(
name|i_blank
argument_list|(
name|curline
argument_list|)
condition|)
if|if
condition|(
name|firstp
argument_list|(
name|curline
argument_list|)
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|line_move
argument_list|(
name|BACKWARD
argument_list|,
literal|1
argument_list|,
name|NO
argument_list|)
expr_stmt|;
goto|goto
name|strt
goto|;
block|}
else|else
block|{
while|while
condition|(
name|i_blank
argument_list|(
name|curline
argument_list|)
condition|)
if|if
condition|(
name|lastp
argument_list|(
name|curline
argument_list|)
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|line_move
argument_list|(
name|FORWARD
argument_list|,
literal|1
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|head
operator|=
name|curline
expr_stmt|;
name|next
operator|=
name|curline
operator|->
name|l_next
expr_stmt|;
if|if
condition|(
operator|!
name|i_bsblank
argument_list|(
name|next
argument_list|)
condition|)
name|body
operator|=
name|next
expr_stmt|;
else|else
name|body
operator|=
name|head
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i_bsblank
argument_list|(
name|this
argument_list|)
operator|||
name|i_blank
argument_list|(
name|prev
argument_list|)
condition|)
block|{
comment|/* rule 2 */
name|head
operator|=
name|this
expr_stmt|;
if|if
condition|(
operator|!
name|i_bsblank
argument_list|(
name|next
argument_list|)
condition|)
name|body
operator|=
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i_bsblank
argument_list|(
name|next
argument_list|)
condition|)
block|{
comment|/* rule 3 */
name|tail
operator|=
name|this
expr_stmt|;
name|body
operator|=
name|this
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|get_indent
argument_list|(
name|next
argument_list|)
operator|==
name|this_indent
operator|)
operator|||
comment|/* rule 4 */
operator|(
name|get_indent
argument_list|(
name|prev
argument_list|)
operator|==
name|this_indent
operator|)
condition|)
name|body
operator|=
name|this
expr_stmt|;
else|else
block|{
comment|/* rule 6+ */
if|if
condition|(
name|get_indent
argument_list|(
name|prev
argument_list|)
operator|>
name|this_indent
condition|)
block|{
comment|/* hanging indent maybe? */
if|if
condition|(
operator|(
name|next
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|get_indent
argument_list|(
name|next
argument_list|)
operator|==
name|get_indent
argument_list|(
name|next
operator|->
name|l_next
argument_list|)
operator|)
condition|)
block|{
name|head
operator|=
name|this
expr_stmt|;
name|body
operator|=
name|next
expr_stmt|;
block|}
block|}
comment|/* Now we handle hanging indent else and the other 		   case of this_indent> get_indent(prev).  That is, 		   if we didn't resolve HEAD in the above if, then 		   we are not a hanging indent. */
if|if
condition|(
name|head
operator|==
literal|0
condition|)
block|{
comment|/* still don't know */
if|if
condition|(
name|this_indent
operator|>
name|get_indent
argument_list|(
name|prev
argument_list|)
condition|)
name|head
operator|=
name|this
expr_stmt|;
else|else
name|head
operator|=
name|prev
expr_stmt|;
name|body
operator|=
name|head
operator|->
name|l_next
expr_stmt|;
block|}
block|}
comment|/* rule 5 -- find the missing parts */
if|if
condition|(
name|head
operator|==
literal|0
condition|)
block|{
comment|/* haven't found head of paragraph so do so now */
name|Line
modifier|*
name|lp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lp
operator|=
name|this
expr_stmt|;
do|do
block|{
name|i
operator|=
name|get_indent
argument_list|(
name|lp
operator|->
name|l_prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
comment|/* is blank */
name|head
operator|=
name|lp
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|!=
name|this_indent
operator|||
name|bslash
condition|)
block|{
name|Line
modifier|*
name|this
init|=
name|lp
operator|->
name|l_prev
decl_stmt|;
if|if
condition|(
name|get_indent
argument_list|(
name|this
operator|->
name|l_prev
argument_list|)
operator|==
name|i
condition|)
name|head
operator|=
name|this
operator|->
name|l_next
expr_stmt|;
else|else
name|head
operator|=
name|this
expr_stmt|;
block|}
block|}
do|while
condition|(
name|head
operator|==
literal|0
operator|&&
operator|(
name|lp
operator|=
name|lp
operator|->
name|l_prev
operator|)
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|lp
operator|==
literal|0
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|body
operator|==
literal|0
condition|)
comment|/* this must be a one line paragraph */
name|body
operator|=
name|head
expr_stmt|;
if|if
condition|(
name|tail
operator|==
literal|0
condition|)
name|tail
operator|=
name|tailrule
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|==
literal|0
operator|||
name|head
operator|==
literal|0
operator|||
name|body
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"BUG! tail(%d),head(%d),body(%d)!"
argument_list|,
name|tail
argument_list|,
name|head
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|para_head
operator|=
name|head
expr_stmt|;
name|para_tail
operator|=
name|tail
expr_stmt|;
name|head_indent
operator|=
name|get_indent
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|body_indent
operator|=
name|get_indent
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
operator|&
name|orig
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Justify
parameter_list|()
block|{
name|use_lmargin
operator|=
name|is_an_arg
argument_list|()
expr_stmt|;
name|find_para
argument_list|(
name|BACKWARD
argument_list|)
expr_stmt|;
name|DoJustify
argument_list|(
name|para_head
argument_list|,
literal|0
argument_list|,
name|para_tail
argument_list|,
name|length
argument_list|(
name|para_tail
argument_list|)
argument_list|,
name|NO
argument_list|,
name|use_lmargin
condition|?
name|LMargin
else|:
name|body_indent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Line
modifier|*
name|max_line
parameter_list|(
name|l1
parameter_list|,
name|l2
parameter_list|)
name|Line
modifier|*
name|l1
decl_stmt|,
decl|*
name|l2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|inorder
argument_list|(
name|l1
argument_list|,
literal|0
argument_list|,
name|l2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|l2
return|;
return|return
name|l1
return|;
block|}
end_block

begin_function
name|Line
modifier|*
name|min_line
parameter_list|(
name|l1
parameter_list|,
name|l2
parameter_list|)
name|Line
modifier|*
name|l1
decl_stmt|,
decl|*
name|l2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|inorder
argument_list|(
name|l1
argument_list|,
literal|0
argument_list|,
name|l2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|l1
return|;
return|return
name|l2
return|;
block|}
end_block

begin_function
name|void
name|RegJustify
parameter_list|()
block|{
name|Mark
modifier|*
name|mp
init|=
name|CurMark
argument_list|()
decl_stmt|,
modifier|*
name|tailmark
decl_stmt|;
name|Line
modifier|*
name|l1
init|=
name|curline
decl_stmt|,
modifier|*
name|l2
init|=
name|mp
operator|->
name|m_line
decl_stmt|;
name|int
name|c1
init|=
name|curchar
decl_stmt|,
name|c2
init|=
name|mp
operator|->
name|m_char
decl_stmt|;
name|Line
modifier|*
name|rl1
decl_stmt|,
modifier|*
name|rl2
decl_stmt|;
name|use_lmargin
operator|=
name|is_an_arg
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fixorder
argument_list|(
operator|&
name|l1
argument_list|,
operator|&
name|c1
argument_list|,
operator|&
name|l2
argument_list|,
operator|&
name|c2
argument_list|)
expr_stmt|;
do|do
block|{
name|DotTo
argument_list|(
name|l1
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|find_para
argument_list|(
name|FORWARD
argument_list|)
expr_stmt|;
name|rl1
operator|=
name|max_line
argument_list|(
name|l1
argument_list|,
name|para_head
argument_list|)
expr_stmt|;
name|rl2
operator|=
name|min_line
argument_list|(
name|l2
argument_list|,
name|para_tail
argument_list|)
expr_stmt|;
name|tailmark
operator|=
name|MakeMark
argument_list|(
name|para_tail
argument_list|,
literal|0
argument_list|,
name|M_FLOATER
argument_list|)
expr_stmt|;
name|DoJustify
argument_list|(
name|rl1
argument_list|,
operator|(
name|rl1
operator|==
name|l1
operator|)
condition|?
name|c1
else|:
literal|0
argument_list|,
name|rl2
argument_list|,
operator|(
name|rl2
operator|==
name|l2
operator|)
condition|?
name|c2
else|:
name|length
argument_list|(
name|rl2
argument_list|)
argument_list|,
name|NO
argument_list|,
name|use_lmargin
condition|?
name|LMargin
else|:
name|body_indent
argument_list|)
expr_stmt|;
name|l1
operator|=
name|tailmark
operator|->
name|m_line
operator|->
name|l_next
expr_stmt|;
name|DelMark
argument_list|(
name|tailmark
argument_list|)
expr_stmt|;
name|c1
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|l1
operator|!=
literal|0
operator|&&
name|l2
operator|!=
name|rl2
condition|)
do|;
block|}
end_function

begin_function
name|void
name|do_rfill
parameter_list|(
name|ulm
parameter_list|)
block|{
name|Mark
modifier|*
name|mp
init|=
name|CurMark
argument_list|()
decl_stmt|;
name|Line
modifier|*
name|l1
init|=
name|curline
decl_stmt|,
modifier|*
name|l2
init|=
name|mp
operator|->
name|m_line
decl_stmt|;
name|int
name|c1
init|=
name|curchar
decl_stmt|,
name|c2
init|=
name|mp
operator|->
name|m_char
decl_stmt|;
name|use_lmargin
operator|=
name|ulm
expr_stmt|;
operator|(
name|void
operator|)
name|fixorder
argument_list|(
operator|&
name|l1
argument_list|,
operator|&
name|c1
argument_list|,
operator|&
name|l2
argument_list|,
operator|&
name|c2
argument_list|)
expr_stmt|;
name|DoJustify
argument_list|(
name|l1
argument_list|,
name|c1
argument_list|,
name|l2
argument_list|,
name|c2
argument_list|,
name|NO
argument_list|,
name|use_lmargin
condition|?
name|LMargin
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_space
parameter_list|()
block|{
name|int
name|c1
init|=
name|curchar
decl_stmt|,
name|c2
init|=
name|c1
decl_stmt|,
name|diff
decl_stmt|,
name|nspace
decl_stmt|;
name|char
name|ch
decl_stmt|;
while|while
condition|(
name|c1
operator|>
literal|0
operator|&&
operator|(
operator|(
name|ch
operator|=
name|linebuf
index|[
name|c1
operator|-
literal|1
index|]
operator|)
operator|==
literal|' '
operator|||
name|ch
operator|==
literal|'\t'
operator|)
condition|)
name|c1
operator|-=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|linebuf
index|[
name|c2
index|]
operator|)
operator|==
literal|' '
operator|||
name|ch
operator|==
literal|'\t'
condition|)
name|c2
operator|+=
literal|1
expr_stmt|;
name|diff
operator|=
operator|(
name|c2
operator|-
name|c1
operator|)
expr_stmt|;
name|curchar
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|c1
operator|>
literal|0
condition|)
block|{
name|int
name|topunct
init|=
name|c1
operator|-
literal|1
decl_stmt|;
name|nspace
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|diff
operator|>=
literal|2
condition|)
block|{
while|while
condition|(
name|index
argument_list|(
literal|"\")]"
argument_list|,
name|linebuf
index|[
name|topunct
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|topunct
operator|==
literal|0
condition|)
break|break;
name|topunct
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|index
argument_list|(
literal|"?!.:"
argument_list|,
name|linebuf
index|[
name|topunct
index|]
argument_list|)
condition|)
name|nspace
operator|=
literal|2
expr_stmt|;
block|}
block|}
else|else
name|nspace
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|diff
operator|>
name|nspace
condition|)
name|del_char
argument_list|(
name|BACKWARD
argument_list|,
operator|(
name|diff
operator|-
name|nspace
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|diff
operator|<
name|nspace
condition|)
name|insert_c
argument_list|(
literal|' '
argument_list|,
operator|(
name|nspace
operator|-
name|diff
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_comment
comment|/*#pragma loop_opt(off) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|DoJustify
parameter_list|(
name|l1
parameter_list|,
name|c1
parameter_list|,
name|l2
parameter_list|,
name|c2
parameter_list|,
name|scrunch
parameter_list|,
name|indent
parameter_list|)
name|Line
modifier|*
name|l1
decl_stmt|,
decl|*
name|l2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|okay_char
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|Mark
modifier|*
name|savedot
init|=
name|MakeMark
argument_list|(
name|curline
argument_list|,
name|curchar
argument_list|,
name|M_FLOATER
argument_list|)
decl_stmt|,
modifier|*
name|endmark
decl_stmt|;
operator|(
name|void
operator|)
name|fixorder
argument_list|(
operator|&
name|l1
argument_list|,
operator|&
name|c1
argument_list|,
operator|&
name|l2
argument_list|,
operator|&
name|c2
argument_list|)
expr_stmt|;
comment|/* l1/c1 will be before l2/c2 */
name|DotTo
argument_list|(
name|l1
argument_list|,
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_indent
argument_list|(
name|l1
argument_list|)
operator|>=
name|c1
condition|)
block|{
if|if
condition|(
name|use_lmargin
condition|)
block|{
name|n_indent
argument_list|(
name|indent
operator|+
operator|(
name|head_indent
operator|-
name|body_indent
operator|)
argument_list|)
expr_stmt|;
name|use_lmargin
operator|=
literal|0
expr_stmt|;
comment|/* turn this off now */
block|}
name|ToIndent
argument_list|()
expr_stmt|;
block|}
name|endmark
operator|=
name|MakeMark
argument_list|(
name|l2
argument_list|,
name|c2
argument_list|,
name|M_FLOATER
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|)
operator|<
name|RMargin
condition|)
block|{
if|if
condition|(
name|curline
operator|==
name|endmark
operator|->
name|m_line
operator|&&
name|curchar
operator|>=
name|endmark
operator|->
name|m_char
condition|)
goto|goto
name|outahere
goto|;
name|okay_char
operator|=
name|curchar
expr_stmt|;
if|if
condition|(
name|eolp
argument_list|()
condition|)
block|{
name|del_char
argument_list|(
name|FORWARD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Delete line separator. */
name|ins_str
argument_list|(
literal|"  "
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|StrIndex
argument_list|(
literal|1
argument_list|,
name|linebuf
argument_list|,
name|curchar
operator|+
literal|1
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
name|Eol
argument_list|()
expr_stmt|;
else|else
name|curchar
operator|=
operator|(
name|cp
operator|-
name|linebuf
operator|)
expr_stmt|;
block|}
name|do_space
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|okay_char
operator|>
literal|0
condition|)
name|curchar
operator|=
name|okay_char
expr_stmt|;
if|if
condition|(
name|curline
operator|==
name|endmark
operator|->
name|m_line
operator|&&
name|curchar
operator|>=
name|endmark
operator|->
name|m_char
condition|)
goto|goto
name|outahere
goto|;
comment|/* Can't fit in small margin, so we do the best we can. */
if|if
condition|(
name|eolp
argument_list|()
condition|)
block|{
name|line_move
argument_list|(
name|FORWARD
argument_list|,
literal|1
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|n_indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DelWtSpace
argument_list|()
expr_stmt|;
name|LineInsert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|scrunch
operator|&&
name|TwoBlank
argument_list|()
condition|)
block|{
name|Eol
argument_list|()
expr_stmt|;
name|del_char
argument_list|(
name|FORWARD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|n_indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
block|}
block|}
name|outahere
label|:
name|ToMark
argument_list|(
name|savedot
argument_list|)
expr_stmt|;
comment|/* Back to where we were */
name|DelMark
argument_list|(
name|endmark
argument_list|)
expr_stmt|;
comment|/* Free up marks */
name|DelMark
argument_list|(
name|savedot
argument_list|)
expr_stmt|;
name|this_cmd
operator|=
name|last_cmd
operator|=
literal|0
expr_stmt|;
comment|/* So everything is under control */
name|f_mess
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_comment
comment|/*#pragma loop_opt() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|Line
modifier|*
name|para_head
decl_stmt|,
modifier|*
name|para_tail
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|DoPara
parameter_list|(
name|dir
parameter_list|)
block|{
specifier|register
name|int
name|num
init|=
name|arg_value
argument_list|()
decl_stmt|,
name|first_time
init|=
name|TRUE
decl_stmt|;
while|while
condition|(
operator|--
name|num
operator|>=
literal|0
condition|)
block|{
name|tryagain
label|:
name|find_para
argument_list|(
name|dir
argument_list|)
expr_stmt|;
comment|/* find paragraph bounderies */
if|if
condition|(
operator|(
name|dir
operator|==
name|BACKWARD
operator|)
operator|&&
operator|(
operator|(
operator|!
name|first_time
operator|)
operator|||
operator|(
operator|(
name|para_head
operator|==
name|curline
operator|)
operator|&&
name|bolp
argument_list|()
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|bobp
argument_list|()
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|b_char
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|first_time
operator|=
operator|!
name|first_time
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
name|SetLine
argument_list|(
operator|(
name|dir
operator|==
name|BACKWARD
operator|)
condition|?
name|para_head
else|:
name|para_tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|BACKWARD
operator|&&
operator|!
name|firstp
argument_list|(
name|curline
argument_list|)
operator|&&
name|i_blank
argument_list|(
name|curline
operator|->
name|l_prev
argument_list|)
condition|)
name|line_move
argument_list|(
name|BACKWARD
argument_list|,
literal|1
argument_list|,
name|NO
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dir
operator|==
name|FORWARD
condition|)
block|{
if|if
condition|(
name|lastp
argument_list|(
name|curline
argument_list|)
condition|)
block|{
name|Eol
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* otherwise */
name|line_move
argument_list|(
name|FORWARD
argument_list|,
literal|1
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|BackPara
parameter_list|()
block|{
name|DoPara
argument_list|(
name|BACKWARD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ForPara
parameter_list|()
block|{
name|DoPara
argument_list|(
name|FORWARD
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

