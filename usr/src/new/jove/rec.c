begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"io.h"
end_include

begin_include
include|#
directive|include
file|"rec.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAC
end_ifndef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|private
name|int
name|rec_fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|recfname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|File
modifier|*
name|rec_out
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|L_SET
end_ifndef

begin_define
define|#
directive|define
name|L_SET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|private
name|struct
name|rec_head
name|Header
decl_stmt|;
end_decl_stmt

begin_macro
name|recinit
argument_list|()
end_macro

begin_block
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|HomeDir
argument_list|,
name|p_tempfile
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|TmpFilePath
argument_list|,
name|p_tempfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|recfname
operator|=
name|copystr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|recfname
operator|=
name|mktemp
argument_list|(
name|recfname
argument_list|)
expr_stmt|;
name|rec_fd
operator|=
name|creat
argument_list|(
name|recfname
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|complain
argument_list|(
literal|"Cannot create \"%s\"; recovery disabled."
argument_list|,
name|recfname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* initialize the record IO */
name|rec_out
operator|=
name|fd_open
argument_list|(
name|recfname
argument_list|,
name|F_WRITE
operator||
name|F_LOCKED
argument_list|,
name|rec_fd
argument_list|,
name|iobuff
argument_list|,
name|LBSIZE
argument_list|)
expr_stmt|;
comment|/* Initialize the record header. */
name|Header
operator|.
name|Uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|Header
operator|.
name|Pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|Header
operator|.
name|UpdTime
operator|=
literal|0L
expr_stmt|;
name|Header
operator|.
name|Nbuffers
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|rec_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|Header
argument_list|,
sizeof|sizeof
name|Header
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|recclose
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|rec_fd
operator|==
operator|-
literal|1
condition|)
return|return;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rec_fd
argument_list|)
expr_stmt|;
name|rec_fd
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|recfname
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|private
name|putaddr
parameter_list|(
name|addr
parameter_list|,
name|p
parameter_list|)
name|disk_line
name|addr
decl_stmt|;
specifier|register
name|File
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
decl_stmt|;
specifier|register
name|int
name|nchars
init|=
sizeof|sizeof
argument_list|(
name|disk_line
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|putc
argument_list|(
operator|*
name|cp
operator|++
operator|&
literal|0377
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|putn
parameter_list|(
name|cp
parameter_list|,
name|nbytes
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|nbytes
decl_stmt|;
block|{
while|while
condition|(
operator|--
name|nbytes
operator|>=
literal|0
condition|)
name|putc
argument_list|(
operator|*
name|cp
operator|++
operator|&
literal|0377
argument_list|,
name|rec_out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out the line pointers for buffer B. */
end_comment

begin_function
name|private
name|dmppntrs
parameter_list|(
name|b
parameter_list|)
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
block|{
specifier|register
name|Line
modifier|*
name|lp
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|b
operator|->
name|b_first
init|;
name|lp
operator|!=
literal|0
condition|;
name|lp
operator|=
name|lp
operator|->
name|l_next
control|)
name|putaddr
argument_list|(
name|lp
operator|->
name|l_dline
argument_list|,
name|rec_out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* dump the buffer info and then the actual line pointers. */
end_comment

begin_function
name|private
name|dmp_buf_header
parameter_list|(
name|b
parameter_list|)
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
block|{
name|struct
name|rec_entry
name|record
decl_stmt|;
specifier|register
name|Line
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|nlines
init|=
literal|0
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|b
operator|->
name|b_first
init|;
name|lp
operator|!=
literal|0
condition|;
name|lp
operator|=
name|lp
operator|->
name|l_next
operator|,
name|nlines
operator|++
control|)
if|if
condition|(
name|lp
operator|==
name|b
operator|->
name|b_dot
condition|)
name|record
operator|.
name|r_dotline
operator|=
name|nlines
expr_stmt|;
name|strcpy
argument_list|(
name|record
operator|.
name|r_fname
argument_list|,
name|b
operator|->
name|b_fname
condition|?
name|b
operator|->
name|b_fname
else|:
name|NullStr
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|record
operator|.
name|r_bname
argument_list|,
name|b
operator|->
name|b_name
argument_list|)
expr_stmt|;
name|record
operator|.
name|r_nlines
operator|=
name|nlines
expr_stmt|;
name|record
operator|.
name|r_dotchar
operator|=
name|b
operator|->
name|b_char
expr_stmt|;
name|putn
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|record
argument_list|,
sizeof|sizeof
name|record
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Goes through all the buffers and syncs them to the disk. */
end_comment

begin_decl_stmt
name|int
name|SyncFreq
init|=
literal|50
decl_stmt|;
end_decl_stmt

begin_macro
name|SyncRec
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|disk_line
name|DFree
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
specifier|static
name|int
name|beenhere
init|=
name|NO
decl_stmt|;
if|if
condition|(
name|beenhere
operator|==
name|NO
condition|)
block|{
name|recinit
argument_list|()
expr_stmt|;
comment|/* Init recover file. */
name|beenhere
operator|=
name|YES
expr_stmt|;
block|}
if|if
condition|(
name|rec_fd
operator|==
operator|-
literal|1
condition|)
return|return;
name|lseek
argument_list|(
name|rec_fd
argument_list|,
literal|0L
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|Header
operator|.
name|UpdTime
argument_list|)
expr_stmt|;
name|Header
operator|.
name|Nbuffers
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|b_next
control|)
if|if
condition|(
name|b
operator|->
name|b_type
operator|==
name|B_SCRATCH
operator|||
operator|!
name|IsModified
argument_list|(
name|b
argument_list|)
condition|)
continue|continue;
else|else
name|Header
operator|.
name|Nbuffers
operator|+=
literal|1
expr_stmt|;
name|Header
operator|.
name|FreePtr
operator|=
name|DFree
expr_stmt|;
name|putn
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|Header
argument_list|,
sizeof|sizeof
name|Header
argument_list|)
expr_stmt|;
if|if
condition|(
name|Header
operator|.
name|Nbuffers
operator|!=
literal|0
condition|)
block|{
name|lsave
argument_list|()
expr_stmt|;
comment|/* this makes things really right */
name|SyncTmp
argument_list|()
expr_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|b_next
control|)
if|if
condition|(
name|b
operator|->
name|b_type
operator|==
name|B_SCRATCH
operator|||
operator|!
name|IsModified
argument_list|(
name|b
argument_list|)
condition|)
continue|continue;
else|else
name|dmp_buf_header
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|b_next
control|)
if|if
condition|(
name|b
operator|->
name|b_type
operator|==
name|B_SCRATCH
operator|||
operator|!
name|IsModified
argument_list|(
name|b
argument_list|)
condition|)
continue|continue;
else|else
name|dmppntrs
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|(
name|rec_out
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Full Recover.  What we have to do is go find the name of the tmp    file data/rec pair and use those instead of the ones we would have    created eventually.  The rec file has a list of buffers, and then    the actual pointers.  Stored for each buffer is the buffer name,    the file name, the number of lines, the current line, the current    character.  The current modes do not need saving as they will be    saved when the file name is set.  If a process was running in a    buffer, it will be lost. */
end_comment

begin_macro
name|FullRecover
argument_list|()
end_macro

begin_block
block|{ }
end_block

end_unit

