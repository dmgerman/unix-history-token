begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_comment
comment|/* Routines to perform all kinds of deletion.  */
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_comment
comment|/* Assumes that either line1 or line2 is actual the current line, so it can    put its result into linebuf. */
end_comment

begin_function
name|void
name|patchup
parameter_list|(
name|line1
parameter_list|,
name|char1
parameter_list|,
name|line2
parameter_list|,
name|char2
parameter_list|)
name|Line
modifier|*
name|line1
decl_stmt|,
decl|*
name|line2
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|char1
decl_stmt|,
name|char2
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|line1
operator|!=
name|line2
condition|)
name|ChkWindows
argument_list|(
name|line1
argument_list|,
name|line2
argument_list|)
expr_stmt|;
name|DotTo
argument_list|(
name|line1
argument_list|,
name|char1
argument_list|)
expr_stmt|;
name|modify
argument_list|()
expr_stmt|;
name|linecopy
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|,
name|lcontents
argument_list|(
name|line2
argument_list|)
operator|+
name|char2
argument_list|)
expr_stmt|;
comment|/* The following is a redisplay optimization. */
if|if
condition|(
name|line1
operator|!=
name|line2
operator|&&
operator|(
name|char1
operator|==
literal|0
operator|&&
name|char2
operator|==
literal|0
operator|)
condition|)
name|line1
operator|->
name|l_dline
operator|=
name|line2
operator|->
name|l_dline
expr_stmt|;
name|DFixMarks
argument_list|(
name|line1
argument_list|,
name|char1
argument_list|,
name|line2
argument_list|,
name|char2
argument_list|)
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Deletes the region by unlinking the lines in the middle,    and patching things up.  The unlinked lines are still in    order.  */
end_comment

begin_function
name|Line
modifier|*
name|reg_delete
parameter_list|(
name|line1
parameter_list|,
name|char1
parameter_list|,
name|line2
parameter_list|,
name|char2
parameter_list|)
name|Line
modifier|*
name|line1
decl_stmt|,
decl|*
name|line2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|Line
modifier|*
name|retline
decl_stmt|;
if|if
condition|(
operator|(
name|line1
operator|==
name|line2
operator|&&
name|char1
operator|==
name|char2
operator|)
operator|||
name|line2
operator|==
literal|0
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fixorder
argument_list|(
operator|&
name|line1
argument_list|,
operator|&
name|char1
argument_list|,
operator|&
name|line2
argument_list|,
operator|&
name|char2
argument_list|)
expr_stmt|;
name|retline
operator|=
name|nbufline
argument_list|()
expr_stmt|;
comment|/* New buffer line */
operator|(
name|void
operator|)
name|ltobuf
argument_list|(
name|line1
argument_list|,
name|genbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|line1
operator|==
name|line2
condition|)
name|genbuf
index|[
name|char2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|retline
operator|->
name|l_prev
operator|=
literal|0
expr_stmt|;
name|retline
operator|->
name|l_dline
operator|=
name|putline
argument_list|(
operator|&
name|genbuf
index|[
name|char1
index|]
argument_list|)
expr_stmt|;
name|patchup
argument_list|(
name|line1
argument_list|,
name|char1
argument_list|,
name|line2
argument_list|,
name|char2
argument_list|)
expr_stmt|;
if|if
condition|(
name|line1
operator|==
name|line2
condition|)
name|retline
operator|->
name|l_next
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|retline
operator|->
name|l_next
operator|=
name|line1
operator|->
name|l_next
expr_stmt|;
operator|(
name|void
operator|)
name|ltobuf
argument_list|(
name|line2
argument_list|,
name|genbuf
argument_list|)
expr_stmt|;
name|genbuf
index|[
name|char2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|line2
operator|->
name|l_dline
operator|=
name|putline
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
comment|/* Shorten this line */
block|}
if|if
condition|(
name|line1
operator|!=
name|line2
condition|)
block|{
name|line1
operator|->
name|l_next
operator|=
name|line2
operator|->
name|l_next
expr_stmt|;
if|if
condition|(
name|line1
operator|->
name|l_next
condition|)
name|line1
operator|->
name|l_next
operator|->
name|l_prev
operator|=
name|line1
expr_stmt|;
else|else
name|curbuf
operator|->
name|b_last
operator|=
name|line1
expr_stmt|;
name|line2
operator|->
name|l_next
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|retline
return|;
block|}
end_block

begin_function
name|void
name|lremove
parameter_list|(
name|line1
parameter_list|,
name|line2
parameter_list|)
specifier|register
name|Line
modifier|*
name|line1
decl_stmt|,
decl|*
name|line2
decl_stmt|;
end_function

begin_block
block|{
name|Line
modifier|*
name|next
init|=
name|line1
operator|->
name|l_next
decl_stmt|;
if|if
condition|(
name|line1
operator|==
name|line2
condition|)
return|return;
name|line1
operator|->
name|l_next
operator|=
name|line2
operator|->
name|l_next
expr_stmt|;
if|if
condition|(
name|line1
operator|->
name|l_next
condition|)
name|line1
operator|->
name|l_next
operator|->
name|l_prev
operator|=
name|line1
expr_stmt|;
else|else
name|curbuf
operator|->
name|b_last
operator|=
name|line1
expr_stmt|;
name|lfreereg
argument_list|(
name|next
argument_list|,
name|line2
argument_list|)
expr_stmt|;
comment|/* Put region at end of free line list. */
block|}
end_block

begin_comment
comment|/* Delete character forward */
end_comment

begin_function
name|void
name|DelNChar
parameter_list|()
block|{
name|del_char
argument_list|(
name|FORWARD
argument_list|,
name|arg_value
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete character backward */
end_comment

begin_function
name|void
name|DelPChar
parameter_list|()
block|{
if|if
condition|(
name|MinorMode
argument_list|(
name|OverWrite
argument_list|)
condition|)
block|{
name|int
name|count
init|=
name|min
argument_list|(
name|arg_value
argument_list|()
argument_list|,
name|curchar
argument_list|)
decl_stmt|;
name|b_char
argument_list|(
name|count
argument_list|)
expr_stmt|;
comment|/* overwrite with spaces */
name|set_arg_value
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|LastKeyStruck
operator|=
literal|' '
expr_stmt|;
name|SelfInsert
argument_list|()
expr_stmt|;
name|b_char
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
else|else
name|del_char
argument_list|(
name|BACKWARD
argument_list|,
name|arg_value
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete some characters.  If deleting forward then call for_char    to the final position otherwise call back_char.  Then delete the    region between the two with patchup(). */
end_comment

begin_function
name|void
name|del_char
parameter_list|(
name|dir
parameter_list|,
name|num
parameter_list|)
block|{
name|Bufpos
name|before
decl_stmt|,
name|after
decl_stmt|;
name|int
name|killp
init|=
operator|(
name|abs
argument_list|(
name|num
argument_list|)
operator|>
literal|1
operator|)
decl_stmt|;
name|DOTsave
argument_list|(
operator|&
name|before
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|FORWARD
condition|)
name|f_char
argument_list|(
name|num
argument_list|)
expr_stmt|;
else|else
name|b_char
argument_list|(
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|before
operator|.
name|p_line
operator|==
name|curline
operator|&&
name|before
operator|.
name|p_char
operator|==
name|curchar
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|killp
condition|)
name|reg_kill
argument_list|(
name|before
operator|.
name|p_line
argument_list|,
name|before
operator|.
name|p_char
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|DOTsave
argument_list|(
operator|&
name|after
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fixorder
argument_list|(
operator|&
name|before
operator|.
name|p_line
argument_list|,
operator|&
name|before
operator|.
name|p_char
argument_list|,
operator|&
name|after
operator|.
name|p_line
argument_list|,
operator|&
name|after
operator|.
name|p_char
argument_list|)
expr_stmt|;
name|patchup
argument_list|(
name|before
operator|.
name|p_line
argument_list|,
name|before
operator|.
name|p_char
argument_list|,
name|after
operator|.
name|p_line
argument_list|,
name|after
operator|.
name|p_char
argument_list|)
expr_stmt|;
name|lremove
argument_list|(
name|before
operator|.
name|p_line
argument_list|,
name|after
operator|.
name|p_line
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This kills a region between point, and line1/char1 and puts it on    the kill-ring.  If the last command was one of the kill commands,    the region is appended (prepended if backwards) to the last entry.  */
end_comment

begin_decl_stmt
name|int
name|killptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Line
modifier|*
name|killbuf
index|[
name|NUMKILLS
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|reg_kill
parameter_list|(
name|line2
parameter_list|,
name|char2
parameter_list|,
name|dot_moved
parameter_list|)
name|Line
modifier|*
name|line2
decl_stmt|;
block|{
name|Line
modifier|*
name|nl
decl_stmt|,
modifier|*
name|line1
init|=
name|curline
decl_stmt|;
name|int
name|char1
init|=
name|curchar
decl_stmt|;
name|int
name|backwards
decl_stmt|;
name|backwards
operator|=
operator|!
name|fixorder
argument_list|(
operator|&
name|line1
argument_list|,
operator|&
name|char1
argument_list|,
operator|&
name|line2
argument_list|,
operator|&
name|char2
argument_list|)
expr_stmt|;
comment|/* This is a kludge!  But it possible for commands that don't 	   know which direction they are deleting in (e.g., delete 	   previous word could have been called with a negative argument 	   in which case, it wouldn't know that it really deleted 	   forward. */
if|if
condition|(
operator|!
name|dot_moved
condition|)
name|backwards
operator|=
operator|!
name|backwards
expr_stmt|;
name|DotTo
argument_list|(
name|line1
argument_list|,
name|char1
argument_list|)
expr_stmt|;
name|nl
operator|=
name|reg_delete
argument_list|(
name|line1
argument_list|,
name|char1
argument_list|,
name|line2
argument_list|,
name|char2
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_cmd
operator|!=
name|KILLCMD
condition|)
block|{
name|killptr
operator|=
operator|(
operator|(
name|killptr
operator|+
literal|1
operator|)
operator|%
name|NUMKILLS
operator|)
expr_stmt|;
name|lfreelist
argument_list|(
name|killbuf
index|[
name|killptr
index|]
argument_list|)
expr_stmt|;
name|killbuf
index|[
name|killptr
index|]
operator|=
name|nl
expr_stmt|;
block|}
else|else
block|{
name|Line
modifier|*
name|lastln
init|=
name|lastline
argument_list|(
name|nl
argument_list|)
decl_stmt|;
if|if
condition|(
name|backwards
condition|)
operator|(
name|void
operator|)
name|DoYank
argument_list|(
name|nl
argument_list|,
literal|0
argument_list|,
name|lastln
argument_list|,
name|length
argument_list|(
name|lastln
argument_list|)
argument_list|,
name|killbuf
index|[
name|killptr
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|Buffer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|Line
modifier|*
name|olastln
init|=
name|lastline
argument_list|(
name|killbuf
index|[
name|killptr
index|]
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|DoYank
argument_list|(
name|nl
argument_list|,
literal|0
argument_list|,
name|lastln
argument_list|,
name|length
argument_list|(
name|lastln
argument_list|)
argument_list|,
name|olastln
argument_list|,
name|length
argument_list|(
name|olastln
argument_list|)
argument_list|,
operator|(
name|Buffer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|this_cmd
operator|=
name|KILLCMD
expr_stmt|;
block|}
end_function

begin_function
name|void
name|DelReg
parameter_list|()
block|{
specifier|register
name|Mark
modifier|*
name|mp
init|=
name|CurMark
argument_list|()
decl_stmt|;
name|reg_kill
argument_list|(
name|mp
operator|->
name|m_line
argument_list|,
name|mp
operator|->
name|m_char
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save a region.  A pretend kill. */
end_comment

begin_function
name|void
name|CopyRegion
parameter_list|()
block|{
specifier|register
name|Line
modifier|*
name|nl
decl_stmt|;
specifier|register
name|Mark
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
name|mp
operator|=
name|CurMark
argument_list|()
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_line
operator|==
name|curline
operator|&&
name|mp
operator|->
name|m_char
operator|==
name|curchar
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|killptr
operator|=
operator|(
operator|(
name|killptr
operator|+
literal|1
operator|)
operator|%
name|NUMKILLS
operator|)
expr_stmt|;
if|if
condition|(
name|killbuf
index|[
name|killptr
index|]
condition|)
name|lfreelist
argument_list|(
name|killbuf
index|[
name|killptr
index|]
argument_list|)
expr_stmt|;
name|nl
operator|=
name|killbuf
index|[
name|killptr
index|]
operator|=
name|nbufline
argument_list|()
expr_stmt|;
name|SavLine
argument_list|(
name|nl
argument_list|,
name|NullStr
argument_list|)
expr_stmt|;
name|nl
operator|->
name|l_next
operator|=
name|nl
operator|->
name|l_prev
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|inorder
argument_list|(
name|mp
operator|->
name|m_line
argument_list|,
name|mp
operator|->
name|m_char
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|status
condition|)
operator|(
name|void
operator|)
name|DoYank
argument_list|(
name|mp
operator|->
name|m_line
argument_list|,
name|mp
operator|->
name|m_char
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|,
name|nl
argument_list|,
literal|0
argument_list|,
operator|(
name|Buffer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|DoYank
argument_list|(
name|curline
argument_list|,
name|curchar
argument_list|,
name|mp
operator|->
name|m_line
argument_list|,
name|mp
operator|->
name|m_char
argument_list|,
name|nl
argument_list|,
literal|0
argument_list|,
operator|(
name|Buffer
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|DelWtSpace
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|ep
init|=
operator|&
name|linebuf
index|[
name|curchar
index|]
decl_stmt|,
modifier|*
name|sp
init|=
operator|&
name|linebuf
index|[
name|curchar
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|ep
operator|==
literal|' '
operator|||
operator|*
name|ep
operator|==
literal|'\t'
condition|)
name|ep
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|sp
operator|>
name|linebuf
operator|&&
operator|*
operator|(
name|sp
operator|-
literal|1
operator|)
operator|==
literal|' '
operator|||
operator|*
operator|(
name|sp
operator|-
literal|1
operator|)
operator|==
literal|'\t'
condition|)
name|sp
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|ep
condition|)
block|{
name|curchar
operator|=
name|sp
operator|-
name|linebuf
expr_stmt|;
name|DFixMarks
argument_list|(
name|curline
argument_list|,
name|curchar
argument_list|,
name|curline
argument_list|,
name|curchar
operator|+
operator|(
name|ep
operator|-
name|sp
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
name|modify
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|DelBlnkLines
parameter_list|()
block|{
specifier|register
name|Mark
modifier|*
name|dot
decl_stmt|;
name|int
name|all
decl_stmt|;
if|if
condition|(
operator|!
name|blnkp
argument_list|(
operator|&
name|linebuf
index|[
name|curchar
index|]
argument_list|)
condition|)
return|return;
name|dot
operator|=
name|MakeMark
argument_list|(
name|curline
argument_list|,
name|curchar
argument_list|,
name|M_FLOATER
argument_list|)
expr_stmt|;
name|all
operator|=
operator|!
name|blnkp
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
while|while
condition|(
name|blnkp
argument_list|(
name|linebuf
argument_list|)
operator|&&
name|curline
operator|->
name|l_prev
condition|)
name|SetLine
argument_list|(
name|curline
operator|->
name|l_prev
argument_list|)
expr_stmt|;
name|all
operator||=
operator|(
name|firstp
argument_list|(
name|curline
argument_list|)
operator|)
expr_stmt|;
name|Eol
argument_list|()
expr_stmt|;
name|DelWtSpace
argument_list|()
expr_stmt|;
name|line_move
argument_list|(
name|FORWARD
argument_list|,
literal|1
argument_list|,
name|NO
argument_list|)
expr_stmt|;
while|while
condition|(
name|blnkp
argument_list|(
name|linebuf
argument_list|)
operator|&&
operator|!
name|eobp
argument_list|()
condition|)
block|{
name|DelWtSpace
argument_list|()
expr_stmt|;
name|del_char
argument_list|(
name|FORWARD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|all
operator|&&
operator|!
name|eobp
argument_list|()
condition|)
name|open_lines
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ToMark
argument_list|(
name|dot
argument_list|)
expr_stmt|;
name|DelMark
argument_list|(
name|dot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|DelNWord
parameter_list|()
block|{
name|dword
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|DelPWord
parameter_list|()
block|{
name|dword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dword
parameter_list|(
name|forward
parameter_list|)
block|{
name|Bufpos
name|savedot
decl_stmt|;
name|DOTsave
argument_list|(
operator|&
name|savedot
argument_list|)
expr_stmt|;
if|if
condition|(
name|forward
condition|)
name|ForWord
argument_list|()
expr_stmt|;
else|else
name|BackWord
argument_list|()
expr_stmt|;
name|reg_kill
argument_list|(
name|savedot
operator|.
name|p_line
argument_list|,
name|savedot
operator|.
name|p_char
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

