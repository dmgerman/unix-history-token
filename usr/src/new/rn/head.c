begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: head.c,v 4.3.1.2 85/05/10 13:47:25 lwall Exp $  *  * $Log:	head.c,v $  * Revision 4.3.1.2  85/05/10  13:47:25  lwall  * Added debugging stuff.  *   * Revision 4.3.1.1  85/05/10  11:32:30  lwall  * Branch for patches.  *   * Revision 4.3  85/05/01  11:38:21  lwall  * Baseline for release with 4.3bsd.  *   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"artio.h"
end_include

begin_include
include|#
directive|include
file|"bits.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"head.h"
end_include

begin_decl_stmt
name|bool
name|first_one
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is this the 1st occurance of this header line? */
end_comment

begin_decl_stmt
specifier|static
name|char
name|htypeix
index|[
literal|26
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|head_init
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|HEAD_FIRST
operator|+
literal|1
init|;
name|i
operator|<
name|HEAD_LAST
condition|;
name|i
operator|++
control|)
name|htypeix
index|[
operator|*
name|htype
index|[
name|i
index|]
operator|.
name|ht_name
operator|-
literal|'a'
index|]
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_macro
name|dumpheader
argument_list|(
argument|where
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|where
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"header: %d %s"
argument_list|,
name|parsed_art
argument_list|,
name|where
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HEAD_LAST
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%15s %4d %4d %03o\n"
argument_list|,
argument|htype[i].ht_name
argument_list|,
argument|htype[i].ht_minpos
argument_list|,
argument|htype[i].ht_maxpos
argument_list|,
argument|htype[i].ht_flags
argument_list|)
name|FLUSH
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|set_line_type
parameter_list|(
name|bufptr
parameter_list|,
name|colon
parameter_list|)
name|char
modifier|*
name|bufptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|colon
decl_stmt|;
block|{
name|char
name|lc
index|[
name|LONGKEY
operator|+
literal|3
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|f
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
for|for
control|(
name|t
operator|=
name|lc
operator|,
name|f
operator|=
name|bufptr
init|;
name|f
operator|<
name|colon
condition|;
name|f
operator|++
operator|,
name|t
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|f
argument_list|)
condition|)
comment|/* guard against space before : */
break|break;
operator|*
name|t
operator|=
name|isupper
argument_list|(
operator|*
name|f
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|f
argument_list|)
else|:
operator|*
name|f
expr_stmt|;
block|}
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|f
operator|=
name|lc
expr_stmt|;
comment|/* get lc into register */
name|len
operator|=
name|t
operator|-
name|f
expr_stmt|;
comment|/* now scan the headtype table, backwards so we don't have to supply an      * extra terminating value, using first letter as index, and length as      * optimization to avoid calling subroutine strEQ unnecessarily.  Hauls.      */
if|if
condition|(
name|islower
argument_list|(
operator|*
name|f
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|htypeix
index|[
operator|*
name|f
operator|-
literal|'a'
index|]
init|;
operator|*
name|htype
index|[
name|i
index|]
operator|.
name|ht_name
operator|==
operator|*
name|f
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|len
operator|==
name|htype
index|[
name|i
index|]
operator|.
name|ht_length
operator|&&
name|strEQ
argument_list|(
name|f
argument_list|,
name|htype
index|[
name|i
index|]
operator|.
name|ht_name
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
block|}
return|return
name|SOME_LINE
return|;
block|}
end_function

begin_function
name|void
name|start_header
parameter_list|(
name|artnum
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
name|dumpheader
argument_list|(
literal|"start_header\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HEAD_LAST
condition|;
name|i
operator|++
control|)
block|{
name|htype
index|[
name|i
index|]
operator|.
name|ht_minpos
operator|=
operator|-
literal|1
expr_stmt|;
name|htype
index|[
name|i
index|]
operator|.
name|ht_maxpos
operator|=
literal|0
expr_stmt|;
block|}
name|in_header
operator|=
name|SOME_LINE
expr_stmt|;
name|first_one
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|ASYNC_PARSE
name|parsed_art
operator|=
name|artnum
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|bool
name|parseline
parameter_list|(
name|art_buf
parameter_list|,
name|newhide
parameter_list|,
name|oldhide
parameter_list|)
name|char
modifier|*
name|art_buf
decl_stmt|;
name|int
name|newhide
decl_stmt|,
name|oldhide
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|art_buf
operator|==
literal|' '
operator|||
operator|*
name|art_buf
operator|==
literal|'\t'
condition|)
comment|/* header continuation line? */
return|return
name|oldhide
return|;
else|else
block|{
comment|/* maybe another header line */
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|first_one
condition|)
block|{
comment|/* did we just pass 1st occurance? */
name|first_one
operator|=
name|FALSE
expr_stmt|;
name|htype
index|[
name|in_header
index|]
operator|.
name|ht_maxpos
operator|=
name|artpos
expr_stmt|;
comment|/* remember where line left off */
block|}
name|s
operator|=
name|index
argument_list|(
name|art_buf
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|Nullch
operator|||
name|s
operator|-
name|art_buf
operator|>
name|LONGKEY
operator|+
literal|2
condition|)
block|{
comment|/* is it the end of the header? */
name|htype
index|[
name|PAST_HEADER
index|]
operator|.
name|ht_minpos
operator|=
operator|(
operator|*
name|art_buf
operator|==
literal|'\n'
operator|)
condition|?
name|ftell
argument_list|(
name|artfp
argument_list|)
else|:
name|artpos
expr_stmt|;
comment|/* remember where body starts */
name|in_header
operator|=
name|PAST_HEADER
expr_stmt|;
block|}
else|else
block|{
comment|/* it is a new header line */
name|in_header
operator|=
name|set_line_type
argument_list|(
name|art_buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|first_one
operator|=
operator|(
name|htype
index|[
name|in_header
index|]
operator|.
name|ht_minpos
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|first_one
condition|)
name|htype
index|[
name|in_header
index|]
operator|.
name|ht_minpos
operator|=
name|artpos
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
name|dumpheader
argument_list|(
name|art_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|htype
index|[
name|in_header
index|]
operator|.
name|ht_flags
operator|&
name|HT_HIDE
condition|)
return|return
name|newhide
return|;
block|}
block|}
return|return
name|FALSE
return|;
comment|/* don't hide this line */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ASYNC_PARSE
end_ifdef

begin_function
name|int
name|parse_maybe
parameter_list|(
name|artnum
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
block|{
name|char
name|tmpbuf
index|[
name|LBUFLEN
index|]
decl_stmt|;
if|if
condition|(
name|parsed_art
operator|==
name|artnum
condition|)
return|return
literal|0
return|;
comment|/* no maybe about it now */
if|if
condition|(
name|artopen
argument_list|(
name|artnum
argument_list|)
operator|==
name|Nullfp
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|start_header
argument_list|(
name|artnum
argument_list|)
expr_stmt|;
while|while
condition|(
name|in_header
condition|)
block|{
name|artpos
operator|=
name|ftell
argument_list|(
name|artfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|tmpbuf
argument_list|,
name|LBUFLEN
argument_list|,
name|artfp
argument_list|)
operator|==
name|Nullch
condition|)
break|break;
name|parseline
argument_list|(
name|tmpbuf
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|in_header
operator|=
name|PAST_HEADER
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* get the subject line for an article */
end_comment

begin_function
name|char
modifier|*
name|fetchsubj
parameter_list|(
name|artnum
parameter_list|,
name|current_subject
parameter_list|,
name|copy
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
comment|/* article to get subject from */
name|bool
name|current_subject
decl_stmt|;
comment|/* is it in a parsed header? */
name|bool
name|copy
decl_stmt|;
comment|/* do you want it savestr()ed? */
block|{
name|char
modifier|*
name|s
init|=
name|Nullch
decl_stmt|,
modifier|*
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|CACHESUBJ
if|if
condition|(
operator|!
name|subj_list
condition|)
block|{
specifier|register
name|ART_NUM
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|lint
name|subj_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|safemalloc
argument_list|(
call|(
name|MEM_SIZE
call|)
argument_list|(
operator|(
name|OFFSET
argument_list|(
name|lastart
argument_list|)
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|lint
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|OFFSET
argument_list|(
name|lastart
argument_list|)
condition|;
name|i
operator|++
control|)
name|subj_list
index|[
name|i
index|]
operator|=
name|Nullch
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|artnum
operator|||
name|artnum
operator|>
name|lastart
condition|)
name|s
operator|=
name|nullstr
expr_stmt|;
else|else
name|s
operator|=
name|subj_list
index|[
name|OFFSET
argument_list|(
name|artnum
argument_list|)
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|s
operator|==
name|Nullch
condition|)
block|{
if|if
condition|(
name|current_subject
condition|)
block|{
name|s
operator|=
name|fetchlines
argument_list|(
name|artnum
argument_list|,
name|SUBJ_LINE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CACHESUBJ
name|subj_list
index|[
name|OFFSET
argument_list|(
name|artnum
argument_list|)
index|]
operator|=
name|s
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|s
operator|=
name|safemalloc
argument_list|(
operator|(
name|MEM_SIZE
operator|)
literal|256
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|artopen
argument_list|(
name|artnum
argument_list|)
operator|!=
name|Nullfp
condition|)
block|{
do|do
block|{
if|if
condition|(
name|fgets
argument_list|(
name|s
argument_list|,
literal|256
argument_list|,
name|artfp
argument_list|)
operator|==
name|Nullch
condition|)
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"Title: \n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|strnNE
argument_list|(
name|s
argument_list|,
literal|"Title:"
argument_list|,
literal|6
argument_list|)
operator|&&
name|strnNE
argument_list|(
name|s
argument_list|,
literal|"Subject:"
argument_list|,
literal|8
argument_list|)
condition|)
do|;
name|s
index|[
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|t
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|==
literal|' '
condition|)
name|t
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|saferealloc
argument_list|(
name|s
argument_list|,
operator|(
name|MEM_SIZE
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CACHESUBJ
name|subj_list
index|[
name|OFFSET
argument_list|(
name|artnum
argument_list|)
index|]
operator|=
name|s
expr_stmt|;
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|CACHESUBJ
if|if
condition|(
name|copy
condition|)
block|{
name|t
operator|=
name|savestr
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
else|else
return|return
name|s
return|;
else|#
directive|else
if|if
condition|(
name|copy
condition|)
return|return
name|s
return|;
else|else
block|{
name|safecpy
argument_list|(
name|cmd_buf
argument_list|,
name|s
argument_list|,
name|CBUFLEN
argument_list|)
expr_stmt|;
comment|/* hope this is okay--we're */
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|cmd_buf
return|;
comment|/* really scraping for space here */
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* get header lines from an article */
end_comment

begin_function
name|char
modifier|*
name|fetchlines
parameter_list|(
name|artnum
parameter_list|,
name|which_line
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
comment|/* article to get line from */
name|int
name|which_line
decl_stmt|;
comment|/* type of line desired */
block|{
name|char
modifier|*
name|newbuf
decl_stmt|,
modifier|*
name|t
decl_stmt|,
name|tmp_buf
index|[
name|LBUFLEN
index|]
decl_stmt|;
specifier|register
name|ART_POS
name|curpos
decl_stmt|;
name|int
name|size
decl_stmt|;
specifier|register
name|ART_POS
name|firstpos
decl_stmt|;
specifier|register
name|ART_POS
name|lastpos
decl_stmt|;
ifdef|#
directive|ifdef
name|ASYNC_PARSE
if|if
condition|(
name|parse_maybe
argument_list|(
name|artnum
argument_list|)
condition|)
name|artnum
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|firstpos
operator|=
name|htype
index|[
name|which_line
index|]
operator|.
name|ht_minpos
expr_stmt|;
name|lastpos
operator|=
name|htype
index|[
name|which_line
index|]
operator|.
name|ht_maxpos
expr_stmt|;
if|if
condition|(
operator|!
name|artnum
operator|||
name|firstpos
operator|<
literal|0
operator|||
name|artopen
argument_list|(
name|artnum
argument_list|)
operator|==
name|Nullfp
condition|)
block|{
name|newbuf
operator|=
name|safemalloc
argument_list|(
operator|(
name|unsigned
name|int
operator|)
literal|1
argument_list|)
expr_stmt|;
operator|*
name|newbuf
operator|=
literal|'\0'
expr_stmt|;
return|return
name|newbuf
return|;
block|}
ifndef|#
directive|ifndef
name|lint
name|size
operator|=
name|lastpos
operator|-
name|firstpos
operator|+
literal|1
expr_stmt|;
else|#
directive|else
name|size
operator|=
name|Null
argument_list|(
name|int
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|lint
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&&
operator|(
name|size
operator|<
literal|1
operator|||
name|size
operator|>
literal|1000
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Firstpos = %ld, lastpos = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|firstpos
argument_list|,
operator|(
name|long
operator|)
name|lastpos
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|tmp_buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|newbuf
operator|=
name|safemalloc
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|size
argument_list|)
expr_stmt|;
operator|*
name|newbuf
operator|=
literal|'\0'
expr_stmt|;
name|fseek
argument_list|(
name|artfp
argument_list|,
name|firstpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|curpos
operator|=
name|firstpos
init|;
name|curpos
operator|<
name|lastpos
condition|;
name|curpos
operator|=
name|ftell
argument_list|(
name|artfp
argument_list|)
control|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|tmp_buf
argument_list|,
name|LBUFLEN
argument_list|,
name|artfp
argument_list|)
operator|==
name|Nullch
condition|)
break|break;
if|if
condition|(
operator|*
name|tmp_buf
operator|==
literal|' '
operator|||
operator|*
name|tmp_buf
operator|==
literal|'\t'
condition|)
name|t
operator|=
name|tmp_buf
expr_stmt|;
else|else
name|t
operator|=
name|index
argument_list|(
name|tmp_buf
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|Nullch
condition|)
break|break;
else|else
block|{
while|while
condition|(
operator|*
name|t
operator|==
literal|' '
operator|||
operator|*
name|t
operator|==
literal|'\t'
condition|)
name|t
operator|++
expr_stmt|;
name|safecat
argument_list|(
name|newbuf
argument_list|,
name|t
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|newbuf
return|;
block|}
end_function

end_unit

