begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|RCSid
index|[]
init|=
literal|"$Header: checktype.c,v 2.1 86/06/06 07:26:32 jqj Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* $Log:	checktype.c,v $  * Revision 2.1  86/06/06  07:26:32  jqj  * many mods for better symbol table management:  added CurrentModule,  *  made check_dependency, make_symbol, check_def set/use/use a symbol  *  table instead of a module name string, etc.  Result is that we can  *  now handle DEPENDS UPON 2 versions of same program.  *   * Revision 2.0  85/11/21  07:21:27  jqj  * 4.3BSD standard release  *   * Revision 1.5  85/11/20  13:01:59  root  * Gould bugfixes, I guess  *   * Revision 1.4  85/05/06  08:12:54  jqj  * Almost Beta-test version.  *   * Revision 1.3  85/03/11  16:38:34  jqj  * Public alpha-test version, released 11 March 1985  *   * Revision 1.2  85/02/21  11:04:43  jqj  * alpha test version  *   * Revision 1.1  85/02/15  13:55:13  jqj  * Initial revision  *   */
end_comment

begin_include
include|#
directive|include
file|"compiler.h"
end_include

begin_function
specifier|static
name|int
name|type_check_list
parameter_list|(
name|typtr
parameter_list|,
name|p
parameter_list|)
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
name|list
name|p
decl_stmt|;
block|{
for|for
control|(
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
operator|!
name|type_check
argument_list|(
name|typtr
argument_list|,
operator|(
expr|struct
name|constant
operator|*
operator|)
name|car
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|type_check_enumeration
parameter_list|(
name|typtr
parameter_list|,
name|value
parameter_list|)
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
name|struct
name|constant
modifier|*
name|value
decl_stmt|;
block|{
name|list
name|p
decl_stmt|;
if|if
condition|(
name|typtr
operator|->
name|type_constr
operator|!=
name|value
operator|->
name|cn_constr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|p
operator|=
name|typtr
operator|->
name|type_list
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|cdr
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|streq
argument_list|(
name|value
operator|->
name|cn_value
argument_list|,
name|enumname_of
argument_list|(
name|caar
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* name_of((struct object *) caar(p)))) */
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|type_check_record
parameter_list|(
name|typtr
parameter_list|,
name|value
parameter_list|)
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
name|struct
name|constant
modifier|*
name|value
decl_stmt|;
block|{
if|if
condition|(
name|typtr
operator|->
name|type_constr
operator|!=
name|value
operator|->
name|cn_constr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ### not yet implemented */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make sure a number is a valid constant for this type.  */
end_comment

begin_function
name|int
name|type_check
parameter_list|(
name|typtr
parameter_list|,
name|value
parameter_list|)
name|struct
name|type
modifier|*
name|typtr
decl_stmt|;
name|struct
name|constant
modifier|*
name|value
decl_stmt|;
block|{
switch|switch
condition|(
name|typtr
operator|->
name|type_constr
condition|)
block|{
case|case
name|C_NUMERIC
case|:
case|case
name|C_BOOLEAN
case|:
case|case
name|C_STRING
case|:
return|return
operator|(
name|typtr
operator|->
name|type_constr
operator|==
name|value
operator|->
name|cn_constr
operator|)
return|;
case|case
name|C_ENUMERATION
case|:
return|return
operator|(
name|type_check_enumeration
argument_list|(
name|typtr
argument_list|,
name|value
argument_list|)
operator|)
return|;
case|case
name|C_ARRAY
case|:
if|if
condition|(
name|value
operator|->
name|cn_constr
operator|==
name|C_RECORD
operator|&&
name|value
operator|->
name|cn_list
operator|==
name|NIL
operator|&&
name|typtr
operator|->
name|type_size
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
operator|(
name|typtr
operator|->
name|type_constr
operator|==
name|value
operator|->
name|cn_constr
operator|)
operator|&&
name|typtr
operator|->
name|type_size
operator|==
name|length
argument_list|(
name|value
operator|->
name|cn_list
argument_list|)
operator|&&
name|type_check_list
argument_list|(
name|typtr
operator|->
name|type_basetype
argument_list|,
name|value
operator|->
name|cn_list
argument_list|)
operator|)
return|;
case|case
name|C_SEQUENCE
case|:
if|if
condition|(
name|value
operator|->
name|cn_constr
operator|==
name|C_ARRAY
condition|)
block|{
name|value
operator|->
name|cn_constr
operator|=
name|C_SEQUENCE
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|->
name|cn_constr
operator|==
name|C_RECORD
operator|&&
name|value
operator|->
name|cn_list
operator|==
name|NIL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
operator|(
name|typtr
operator|->
name|type_constr
operator|==
name|value
operator|->
name|cn_constr
operator|)
operator|&&
name|type_check_list
argument_list|(
name|typtr
operator|->
name|type_basetype
argument_list|,
name|value
operator|->
name|cn_list
argument_list|)
operator|)
return|;
case|case
name|C_RECORD
case|:
return|return
operator|(
name|type_check_record
argument_list|(
name|typtr
argument_list|,
name|value
argument_list|)
operator|)
return|;
case|case
name|C_PROCEDURE
case|:
case|case
name|C_ERROR
case|:
return|return
operator|(
name|value
operator|->
name|cn_constr
operator|==
name|C_NUMERIC
operator|)
return|;
case|case
name|C_CHOICE
case|:
return|return
operator|(
literal|1
operator|)
return|;
comment|/* should do better check here */
block|}
comment|/* oops.  Should be an error here */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

