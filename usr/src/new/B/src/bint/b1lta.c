begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*  * $Header: b1lta.c,v 1.4 85/08/22 16:49:05 timo Exp $  */
end_comment

begin_comment
comment|/* Access and update lists and tables */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|INTEGRATION
end_ifndef

begin_include
include|#
directive|include
file|"b1btr.h"
end_include

begin_include
include|#
directive|include
file|"b1val.h"
end_include

begin_include
include|#
directive|include
file|"b3err.h"
end_include

begin_include
include|#
directive|include
file|"b3scr.h"
end_include

begin_comment
comment|/* For at_nwl */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"b1tlt.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|INTEGRATION
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_define
define|#
directive|define
name|check
parameter_list|(
name|v
parameter_list|,
name|where
parameter_list|)
end_define

begin_comment
comment|/*nothing*/
end_comment

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

begin_define
define|#
directive|define
name|IsInner
parameter_list|(
name|p
parameter_list|)
value|(Flag(p) == Inner)
end_define

begin_define
define|#
directive|define
name|IsBottom
parameter_list|(
name|p
parameter_list|)
value|(Flag(p) == Bottom)
end_define

begin_define
define|#
directive|define
name|_Pxitm
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|,
name|iw
parameter_list|)
value|(IsInner(p) ? Piitm(p, l, iw) : Pbitm(p, l, iw))
end_define

begin_function
name|Hidden
name|itemptr
name|Pxitm
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|,
name|iw
parameter_list|)
name|btreeptr
name|p
decl_stmt|;
name|intlet
name|l
decl_stmt|,
name|iw
decl_stmt|;
block|{
return|return
name|_Pxitm
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
name|iw
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|Inil
value|((itemptr)0)
end_define

begin_define
define|#
directive|define
name|Incr
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
value|((p) += (n))
end_define

begin_decl_stmt
name|Visible
name|width
name|itemwidth
index|[
literal|4
index|]
init|=
block|{
name|Cw
block|,
name|Lw
block|,
name|Tw
block|,
name|Kw
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|btreeptr
name|s_ptr
decl_stmt|;
name|int
name|s_lim
decl_stmt|;
block|}
name|finger
index|[
name|Maxheight
index|]
operator|,
typedef|*
name|fingertip
typedef|;
end_typedef

begin_define
define|#
directive|define
name|Snil
value|((fingertip)0)
end_define

begin_define
define|#
directive|define
name|Push
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|,
name|l
parameter_list|)
value|((s)->s_ptr= (p), ((s)->s_lim= (l)), (s)++)
end_define

begin_define
define|#
directive|define
name|Top
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|,
name|l
parameter_list|)
value|((p)= ((s)-1)->s_ptr, (l)= ((s)-1)->s_lim)
end_define

begin_define
define|#
directive|define
name|Drop
parameter_list|(
name|s
parameter_list|)
value|(--(s))
end_define

begin_define
define|#
directive|define
name|Pop
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|,
name|l
parameter_list|)
value|(--(s), (p)= (s)->s_ptr, (l)= (s)->s_lim)
end_define

begin_comment
comment|/* Pop(s, p, l) is equivalent to Top(s, p, l); Drop(s) */
end_comment

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_function
name|Visible
name|fingertip
name|unzip
parameter_list|(
name|p
parameter_list|,
name|at
parameter_list|,
name|s
parameter_list|)
name|btreeptr
name|p
decl_stmt|;
name|int
name|at
decl_stmt|;
name|fingertip
name|s
decl_stmt|;
block|{
name|int
name|syz
decl_stmt|;
name|intlet
name|l
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|Bnil
condition|)
return|return
name|s
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|at
operator|<=
literal|0
condition|)
name|l
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|at
operator|>=
name|Size
argument_list|(
name|p
argument_list|)
condition|)
name|l
operator|=
name|Lim
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IsInner
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|l
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|at
operator|>
operator|(
name|syz
operator|=
name|Size
argument_list|(
name|Ptr
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
argument_list|)
operator|)
condition|)
block|{
operator|++
name|l
expr_stmt|;
name|at
operator|-=
name|syz
operator|+
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|at
operator|>=
name|Lim
argument_list|(
name|p
argument_list|)
condition|)
name|l
operator|=
name|Lim
argument_list|(
name|p
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* for Irange/Crange */
else|else
name|l
operator|=
name|at
expr_stmt|;
comment|/* Assume Bottom */
name|Push
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IsInner
argument_list|(
name|p
argument_list|)
condition|)
break|break;
name|p
operator|=
name|Ptr
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|cpynptrs
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|n
parameter_list|)
name|btreeptr
modifier|*
name|to
decl_stmt|,
decl|*
name|from
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
operator|*
name|to
operator|=
name|copybtree
argument_list|(
operator|*
name|from
argument_list|)
expr_stmt|;
name|Incr
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Incr
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|Visible
name|int
name|movnptrs
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|n
parameter_list|)
name|btreeptr
modifier|*
name|to
decl_stmt|,
decl|*
name|from
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|syz
init|=
literal|0
decl_stmt|;
comment|/* Collects sum of sizes */
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
operator|*
name|to
operator|=
operator|*
name|from
expr_stmt|;
name|syz
operator|+=
name|Size
argument_list|(
operator|*
name|from
argument_list|)
expr_stmt|;
name|Incr
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Incr
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|syz
return|;
block|}
end_block

begin_comment
comment|/* The following two routines may prove machine-dependent when moving    N pointers is not equivalent to moving N*sizeof(pointer) characters.    Also, the latter may be slower. */
end_comment

begin_function
name|Visible
name|Procedure
name|movnitms
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|n
parameter_list|,
name|iw
parameter_list|)
name|itemptr
name|to
decl_stmt|,
name|from
decl_stmt|;
name|intlet
name|n
decl_stmt|,
name|iw
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|t
init|=
operator|(
name|char
operator|*
operator|)
name|to
decl_stmt|,
modifier|*
name|f
init|=
operator|(
name|char
operator|*
operator|)
name|from
decl_stmt|;
name|n
operator|*=
name|iw
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
operator|*
name|t
operator|++
operator|=
operator|*
name|f
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|shift
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|,
name|iw
parameter_list|)
name|btreeptr
name|p
decl_stmt|;
name|intlet
name|l
decl_stmt|,
name|iw
decl_stmt|;
block|{
comment|/* Move items and pointers from l upwards one to the right */
name|btreeptr
modifier|*
name|to
decl_stmt|,
modifier|*
name|from
decl_stmt|;
name|intlet
name|n
init|=
operator|(
name|Lim
argument_list|(
name|p
argument_list|)
operator|-
name|l
operator|)
operator|*
name|iw
decl_stmt|;
name|bool
name|inner
init|=
name|IsInner
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|char
modifier|*
name|f
init|=
operator|(
name|char
operator|*
operator|)
name|Pxitm
argument_list|(
name|p
argument_list|,
name|Lim
argument_list|(
name|p
argument_list|)
argument_list|,
name|iw
argument_list|)
decl_stmt|;
name|char
modifier|*
name|t
init|=
name|f
operator|+
name|iw
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
operator|*
operator|--
name|t
operator|=
operator|*
operator|--
name|f
expr_stmt|;
if|if
condition|(
name|inner
condition|)
block|{
name|from
operator|=
operator|&
name|Ptr
argument_list|(
name|p
argument_list|,
name|Lim
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|=
name|from
expr_stmt|;
name|Incr
argument_list|(
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
name|Lim
argument_list|(
name|p
argument_list|)
operator|-
name|l
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
operator|*
name|to
operator|=
operator|*
name|from
expr_stmt|;
name|Incr
argument_list|(
name|to
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Incr
argument_list|(
name|from
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|Visible
name|Procedure
name|cpynitms
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|n
parameter_list|,
name|it
parameter_list|)
name|itemptr
name|to
decl_stmt|,
name|from
decl_stmt|;
name|intlet
name|n
decl_stmt|,
name|it
decl_stmt|;
block|{
name|intlet
name|i
decl_stmt|,
name|iw
init|=
name|Itemwidth
argument_list|(
name|it
argument_list|)
decl_stmt|;
name|movnitms
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|n
argument_list|,
name|iw
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|it
condition|)
block|{
case|case
name|Lt
case|:
case|case
name|Kt
case|:
case|case
name|Tt
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|copy
argument_list|(
name|Keyval
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|==
name|Tt
condition|)
name|copy
argument_list|(
name|Ascval
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|it
operator|==
name|Kt
condition|)
name|Ascval
argument_list|(
name|to
argument_list|)
operator|=
name|Vnil
expr_stmt|;
name|to
operator|=
call|(
name|itemptr
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|to
operator|+
name|iw
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* Uflow uses a character array to hold the items.  This may be wrong. */
end_comment

begin_function
name|Visible
name|Procedure
name|uflow
parameter_list|(
name|n
parameter_list|,
name|l
parameter_list|,
name|cbuf
parameter_list|,
name|pbuf
parameter_list|,
name|it
parameter_list|)
name|intlet
name|n
decl_stmt|,
name|l
decl_stmt|;
name|char
name|cbuf
index|[]
decl_stmt|;
name|btreeptr
name|pbuf
index|[]
decl_stmt|;
name|intlet
name|it
decl_stmt|;
block|{
name|char
name|ncbuf
index|[
literal|3
operator|*
name|Maxbottom
operator|*
sizeof|sizeof
argument_list|(
name|item
argument_list|)
index|]
decl_stmt|,
modifier|*
name|cp
init|=
name|ncbuf
decl_stmt|;
name|btreeptr
name|npbuf
index|[
literal|3
operator|*
name|Maxinner
index|]
decl_stmt|,
modifier|*
name|pp
init|=
name|npbuf
decl_stmt|,
name|q
decl_stmt|;
name|intlet
name|iw
init|=
name|Itemwidth
argument_list|(
name|it
argument_list|)
decl_stmt|;
name|bool
name|inner
init|=
name|IsInner
argument_list|(
name|pbuf
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|intlet
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|nn
decl_stmt|,
name|l1
init|=
name|l
operator|>
literal|0
condition|?
name|l
operator|-
literal|1
else|:
name|l
decl_stmt|,
name|l2
init|=
name|l
operator|<
name|n
condition|?
name|l
operator|+
literal|1
else|:
name|l
decl_stmt|;
for|for
control|(
name|i
operator|=
name|l1
init|;
name|i
operator|<=
name|l2
condition|;
operator|++
name|i
control|)
block|{
name|q
operator|=
name|pbuf
index|[
name|i
index|]
expr_stmt|;
name|j
operator|=
name|Lim
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|cpynitms
argument_list|(
operator|(
name|itemptr
operator|)
name|cp
argument_list|,
name|Pxitm
argument_list|(
name|q
argument_list|,
literal|0
argument_list|,
name|iw
argument_list|)
argument_list|,
name|j
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|j
operator|*
name|iw
expr_stmt|;
if|if
condition|(
name|inner
condition|)
block|{
name|cpynptrs
argument_list|(
name|pp
argument_list|,
operator|&
name|Ptr
argument_list|(
name|q
argument_list|,
literal|0
argument_list|)
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Incr
argument_list|(
name|pp
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|l2
condition|)
block|{
name|movnitms
argument_list|(
operator|(
name|itemptr
operator|)
name|cp
argument_list|,
call|(
name|itemptr
call|)
argument_list|(
name|cbuf
operator|+
name|i
operator|*
name|iw
argument_list|)
argument_list|,
literal|1
argument_list|,
name|iw
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|iw
expr_stmt|;
block|}
name|relbtree
argument_list|(
name|q
argument_list|,
name|it
argument_list|)
expr_stmt|;
block|}
name|nn
operator|=
operator|(
name|cp
operator|-
name|ncbuf
operator|)
operator|/
name|iw
expr_stmt|;
name|k
operator|=
name|inner
condition|?
name|Maxinner
else|:
name|Maxbottom
expr_stmt|;
if|if
condition|(
name|nn
operator|<=
name|k
condition|)
name|k
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|nn
operator|<=
literal|2
operator|*
name|k
condition|)
name|k
operator|=
literal|2
expr_stmt|;
else|else
name|k
operator|=
literal|3
expr_stmt|;
comment|/* (k<= l2-l1+1) */
name|cp
operator|=
name|ncbuf
expr_stmt|;
name|pp
operator|=
name|npbuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|movnitms
argument_list|(
call|(
name|itemptr
call|)
argument_list|(
name|cbuf
operator|+
operator|(
name|l1
operator|+
name|i
operator|-
literal|1
operator|)
operator|*
name|iw
argument_list|)
argument_list|,
operator|(
name|itemptr
operator|)
name|cp
argument_list|,
literal|1
argument_list|,
name|iw
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|iw
expr_stmt|;
operator|--
name|nn
expr_stmt|;
block|}
name|pbuf
index|[
name|l1
operator|+
name|i
index|]
operator|=
name|q
operator|=
name|grabbtreenode
argument_list|(
name|inner
condition|?
name|Inner
else|:
name|Bottom
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|Lim
argument_list|(
name|q
argument_list|)
operator|=
name|Size
argument_list|(
name|q
argument_list|)
operator|=
name|j
operator|=
name|nn
operator|/
operator|(
name|k
operator|-
name|i
operator|)
expr_stmt|;
name|nn
operator|-=
name|j
expr_stmt|;
name|movnitms
argument_list|(
name|Pxitm
argument_list|(
name|q
argument_list|,
literal|0
argument_list|,
name|iw
argument_list|)
argument_list|,
operator|(
name|itemptr
operator|)
name|cp
argument_list|,
name|j
argument_list|,
name|iw
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|j
operator|*
name|iw
expr_stmt|;
if|if
condition|(
name|inner
condition|)
block|{
name|Size
argument_list|(
name|q
argument_list|)
operator|+=
name|movnptrs
argument_list|(
operator|&
name|Ptr
argument_list|(
name|q
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pp
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Incr
argument_list|(
name|pp
argument_list|,
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|k
operator|<
name|l2
operator|-
name|l1
operator|+
literal|1
condition|)
block|{
name|movnitms
argument_list|(
call|(
name|itemptr
call|)
argument_list|(
name|cbuf
operator|+
operator|(
name|l1
operator|+
name|k
operator|-
literal|1
operator|)
operator|*
name|iw
argument_list|)
argument_list|,
call|(
name|itemptr
call|)
argument_list|(
name|cbuf
operator|+
name|l2
operator|*
name|iw
argument_list|)
argument_list|,
name|n
operator|-
name|l2
argument_list|,
name|iw
argument_list|)
expr_stmt|;
name|VOID
name|movnptrs
argument_list|(
name|pbuf
operator|+
name|l1
operator|+
name|k
argument_list|,
name|pbuf
operator|+
name|l2
operator|+
literal|1
argument_list|,
name|n
operator|-
name|l2
argument_list|)
decl_stmt|;
name|n
operator|-=
name|l2
operator|-
name|l1
operator|+
literal|1
operator|-
name|k
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* Low level access routines */
end_comment

begin_comment
comment|/* Meaning of 'flags' parameter to searchkey: */
end_comment

begin_define
define|#
directive|define
name|NORMAL
value|0
end_define

begin_define
define|#
directive|define
name|UNIQUE
value|1
end_define

begin_comment
comment|/* uniquify visited nodes */
end_comment

begin_define
define|#
directive|define
name|DYAMAX
value|2
end_define

begin_comment
comment|/* special for dyadic max (= previous element) */
end_comment

begin_define
define|#
directive|define
name|DYAMIN
value|4
end_define

begin_comment
comment|/* special for dyadic min (= next element) */
end_comment

begin_function
name|Hidden
name|bool
name|searchkey
parameter_list|(
name|v
parameter_list|,
name|pw
parameter_list|,
name|flags
parameter_list|,
name|ft
parameter_list|)
name|value
name|v
decl_stmt|,
decl|*
name|pw
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|fingertip
modifier|*
name|ft
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|btreeptr
name|p
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|intlet
name|l
decl_stmt|,
name|mid
decl_stmt|,
name|h
decl_stmt|,
name|it
init|=
name|Itemtype
argument_list|(
operator|*
name|pw
argument_list|)
decl_stmt|,
name|iw
init|=
name|Itemwidth
argument_list|(
name|it
argument_list|)
decl_stmt|;
name|bool
name|inner
decl_stmt|;
name|relation
name|r
decl_stmt|;
name|pp
operator|=
operator|&
name|Root
argument_list|(
operator|*
name|pw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pp
operator|==
name|Bnil
condition|)
return|return
name|No
return|;
if|if
condition|(
name|flags
operator|&
name|UNIQUE
condition|)
block|{
name|killranges
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|uniql
argument_list|(
name|pw
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|&
name|Root
argument_list|(
operator|*
name|pw
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|flags
operator|&
name|UNIQUE
condition|)
name|uniqlbtreenode
argument_list|(
name|pp
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
name|inner
operator|=
name|IsInner
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
name|h
operator|=
name|Lim
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|r
operator|=
literal|1
expr_stmt|;
comment|/* For the (illegal?) case that there are no items */
while|while
condition|(
name|l
operator|<
name|h
condition|)
block|{
comment|/* Binary search in {l..h-1} */
name|mid
operator|=
operator|(
name|l
operator|+
name|h
operator|)
operator|/
literal|2
expr_stmt|;
name|r
operator|=
name|compare
argument_list|(
name|v
argument_list|,
name|Keyval
argument_list|(
name|Pxitm
argument_list|(
name|p
argument_list|,
name|mid
argument_list|,
name|iw
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|comp_ok
condition|)
return|return
name|No
return|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
comment|/* Found it */
if|if
condition|(
name|flags
operator|&
operator|(
name|DYAMIN
operator||
name|DYAMAX
operator|)
condition|)
block|{
comment|/* Pretend not found */
if|if
condition|(
name|flags
operator|&
name|DYAMIN
condition|)
name|r
operator|=
literal|1
expr_stmt|;
else|else
name|r
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Normal case, report success */
name|l
operator|=
name|mid
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|h
operator|=
name|mid
expr_stmt|;
comment|/* Continue in {l..mid-1} */
elseif|else
if|if
condition|(
name|r
operator|>
literal|0
condition|)
name|l
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
comment|/* Cont. in {mid+1..h-i} */
block|}
name|Push
argument_list|(
operator|*
name|ft
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
return|return
name|Yes
return|;
if|if
condition|(
operator|!
name|inner
condition|)
block|{
switch|switch
condition|(
name|Flag
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|Irange
case|:
return|return
name|h
operator|>
literal|0
operator|&&
name|l
operator|<
name|Lim
argument_list|(
name|p
argument_list|)
operator|&&
name|integral
argument_list|(
name|v
argument_list|)
return|;
case|case
name|Crange
case|:
return|return
name|h
operator|>
literal|0
operator|&&
name|l
operator|<
name|Lim
argument_list|(
name|p
argument_list|)
operator|&&
name|character
argument_list|(
name|v
argument_list|)
return|;
default|default:
case|case
name|Bottom
case|:
return|return
name|No
return|;
block|}
block|}
name|pp
operator|=
operator|&
name|Ptr
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|Hidden
name|Procedure
name|killranges
parameter_list|(
name|pv
parameter_list|)
name|value
modifier|*
name|pv
decl_stmt|;
block|{
name|btreeptr
name|p
init|=
name|Root
argument_list|(
operator|*
name|pv
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|Bnil
condition|)
return|return;
switch|switch
condition|(
name|Flag
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|Crange
case|:
name|killCrange
argument_list|(
name|p
argument_list|,
name|pv
argument_list|)
expr_stmt|;
break|break;
case|case
name|Irange
case|:
name|killIrange
argument_list|(
name|p
argument_list|,
name|pv
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|killCrange
parameter_list|(
name|p
parameter_list|,
name|pv
parameter_list|)
name|btreeptr
name|p
decl_stmt|;
name|value
modifier|*
name|pv
decl_stmt|;
block|{
name|value
name|w
decl_stmt|;
name|intlet
name|lwbchar
init|=
name|Lwbchar
argument_list|(
name|p
argument_list|)
decl_stmt|,
name|upbchar
init|=
name|Upbchar
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|release
argument_list|(
operator|*
name|pv
argument_list|)
expr_stmt|;
operator|*
name|pv
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
do|do
block|{
name|w
operator|=
name|mkchar
argument_list|(
name|lwbchar
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|w
argument_list|,
name|pv
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|lwbchar
operator|<=
name|upbchar
condition|)
do|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|killIrange
parameter_list|(
name|p
parameter_list|,
name|pv
parameter_list|)
name|btreeptr
name|p
decl_stmt|;
name|value
modifier|*
name|pv
decl_stmt|;
block|{
name|value
name|w
decl_stmt|,
name|lwb
init|=
name|copy
argument_list|(
name|Lwbval
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|,
name|upb
init|=
name|copy
argument_list|(
name|Upbval
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|release
argument_list|(
operator|*
name|pv
argument_list|)
expr_stmt|;
operator|*
name|pv
operator|=
name|mk_elt
argument_list|()
expr_stmt|;
do|do
block|{
name|insert
argument_list|(
name|lwb
argument_list|,
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
argument_list|(
name|lwb
argument_list|,
name|upb
argument_list|)
operator|>=
literal|0
condition|)
break|break;
name|w
operator|=
name|lwb
expr_stmt|;
name|lwb
operator|=
name|sum
argument_list|(
name|lwb
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|still_ok
condition|)
do|;
name|release
argument_list|(
name|lwb
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|upb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_function
name|Hidden
name|btreeptr
name|rem
parameter_list|(
name|f
parameter_list|,
name|ft
parameter_list|,
name|it
parameter_list|)
name|fingertip
name|f
decl_stmt|,
name|ft
decl_stmt|;
name|intlet
name|it
decl_stmt|;
block|{
name|btreeptr
name|p
decl_stmt|,
name|q
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|itemptr
name|ip
decl_stmt|;
name|intlet
name|l
decl_stmt|,
name|iw
init|=
name|Itemwidth
argument_list|(
name|it
argument_list|)
decl_stmt|;
name|bool
name|inner
decl_stmt|,
name|underflow
decl_stmt|;
name|Pop
argument_list|(
name|ft
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|inner
operator|=
name|IsInner
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inner
condition|)
name|ip
operator|=
name|Pbitm
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
name|iw
argument_list|)
expr_stmt|;
else|else
block|{
name|ip
operator|=
name|Piitm
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
name|iw
argument_list|)
expr_stmt|;
do|do
block|{
name|Push
argument_list|(
name|ft
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|uniqlbtreenode
argument_list|(
name|pp
operator|=
operator|&
name|Ptr
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
name|l
operator|=
name|Lim
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|IsInner
argument_list|(
name|p
argument_list|)
condition|)
do|;
name|inner
operator|=
name|No
expr_stmt|;
name|l
operator|-=
literal|2
expr_stmt|;
comment|/* So the movnitms below works fine */
block|}
name|release
argument_list|(
name|Keyval
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|==
name|Tt
operator|||
name|it
operator|==
name|Kt
condition|)
name|release
argument_list|(
name|Ascval
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|Lim
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|movnitms
argument_list|(
name|ip
argument_list|,
name|Pbitm
argument_list|(
name|p
argument_list|,
name|l
operator|+
literal|1
argument_list|,
name|iw
argument_list|)
argument_list|,
name|Lim
argument_list|(
name|p
argument_list|)
operator|-
name|l
argument_list|,
name|iw
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|underflow
operator|=
name|Lim
argument_list|(
name|p
argument_list|)
operator|<
operator|(
name|inner
condition|?
name|Mininner
else|:
name|Minbottom
operator|)
expr_stmt|;
operator|--
name|Size
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ft
operator|==
name|f
condition|)
break|break;
name|Pop
argument_list|(
name|ft
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|underflow
condition|)
name|Lim
argument_list|(
name|p
argument_list|)
operator|=
name|uflow
argument_list|(
name|Lim
argument_list|(
name|p
argument_list|)
argument_list|,
name|l
argument_list|,
operator|(
name|string
operator|)
name|Piitm
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|iw
argument_list|)
argument_list|,
operator|&
name|Ptr
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|inner
operator|=
name|Yes
expr_stmt|;
block|}
if|if
condition|(
name|Lim
argument_list|(
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Reduce tree level */
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|inner
condition|?
name|copybtree
argument_list|(
name|Ptr
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|Bnil
expr_stmt|;
name|relbtree
argument_list|(
name|q
argument_list|,
name|it
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
name|Hidden
name|btreeptr
name|ins
parameter_list|(
name|ip
parameter_list|,
name|f
parameter_list|,
name|ft
parameter_list|,
name|it
parameter_list|)
name|itemptr
name|ip
decl_stmt|;
name|fingertip
name|f
decl_stmt|,
name|ft
decl_stmt|;
name|intlet
name|it
decl_stmt|;
block|{
name|item
name|new
decl_stmt|,
name|old
decl_stmt|;
name|btreeptr
name|p
decl_stmt|,
name|q
init|=
name|Bnil
decl_stmt|,
name|pq
decl_stmt|,
name|oldq
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|intlet
name|l
decl_stmt|,
name|iw
init|=
name|Itemwidth
argument_list|(
name|it
argument_list|)
decl_stmt|,
name|nn
decl_stmt|,
name|np
decl_stmt|,
name|nq
decl_stmt|;
name|bool
name|inner
decl_stmt|,
name|overflow
decl_stmt|;
if|if
condition|(
name|ft
operator|==
name|f
condition|)
block|{
comment|/* unify with rest? */
name|p
operator|=
name|grabbtreenode
argument_list|(
name|Bottom
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|movnitms
argument_list|(
name|Pbitm
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|iw
argument_list|)
argument_list|,
name|ip
argument_list|,
literal|1
argument_list|,
name|iw
argument_list|)
expr_stmt|;
name|Lim
argument_list|(
name|p
argument_list|)
operator|=
name|Size
argument_list|(
name|p
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|p
return|;
block|}
name|Pop
argument_list|(
name|ft
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
while|while
condition|(
name|IsInner
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|Push
argument_list|(
name|ft
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|uniqlbtreenode
argument_list|(
name|pp
operator|=
operator|&
name|Ptr
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
name|l
operator|=
name|Lim
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|overflow
operator|=
name|Yes
expr_stmt|;
name|inner
operator|=
name|No
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|pq
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|overflow
condition|)
block|{
name|oldq
operator|=
name|q
expr_stmt|;
name|movnitms
argument_list|(
operator|&
name|old
argument_list|,
name|ip
argument_list|,
literal|1
argument_list|,
name|iw
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|&
name|new
expr_stmt|;
name|overflow
operator|=
name|Lim
argument_list|(
name|p
argument_list|)
operator|==
operator|(
name|inner
condition|?
name|Maxinner
else|:
name|Maxbottom
operator|)
expr_stmt|;
if|if
condition|(
name|overflow
condition|)
block|{
name|nn
operator|=
name|Lim
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|np
operator|=
name|nn
operator|/
literal|2
expr_stmt|;
name|nq
operator|=
name|nn
operator|-
name|np
operator|-
literal|1
expr_stmt|;
name|q
operator|=
name|grabbtreenode
argument_list|(
name|inner
condition|?
name|Inner
else|:
name|Bottom
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|Size
argument_list|(
name|q
argument_list|)
operator|=
name|Lim
argument_list|(
name|q
argument_list|)
operator|=
name|nq
expr_stmt|;
name|movnitms
argument_list|(
operator|&
name|new
argument_list|,
name|Pxitm
argument_list|(
name|p
argument_list|,
name|np
argument_list|,
name|iw
argument_list|)
argument_list|,
literal|1
argument_list|,
name|iw
argument_list|)
expr_stmt|;
name|movnitms
argument_list|(
name|Pxitm
argument_list|(
name|q
argument_list|,
literal|0
argument_list|,
name|iw
argument_list|)
argument_list|,
name|Pxitm
argument_list|(
name|p
argument_list|,
name|np
operator|+
literal|1
argument_list|,
name|iw
argument_list|)
argument_list|,
name|nq
argument_list|,
name|iw
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner
condition|)
name|Size
argument_list|(
name|q
argument_list|)
operator|+=
name|movnptrs
argument_list|(
operator|&
name|Ptr
argument_list|(
name|q
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|Ptr
argument_list|(
name|p
argument_list|,
name|np
operator|+
literal|1
argument_list|)
argument_list|,
name|nq
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Lim
argument_list|(
name|p
argument_list|)
operator|=
name|np
expr_stmt|;
name|Size
argument_list|(
name|p
argument_list|)
operator|-=
name|Size
argument_list|(
name|q
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|np
condition|)
block|{
name|l
operator|-=
name|np
operator|+
literal|1
expr_stmt|;
name|pq
operator|=
name|q
expr_stmt|;
block|}
block|}
name|shift
argument_list|(
name|pq
argument_list|,
name|l
argument_list|,
name|iw
argument_list|)
expr_stmt|;
name|movnitms
argument_list|(
name|Pxitm
argument_list|(
name|pq
argument_list|,
name|l
argument_list|,
name|iw
argument_list|)
argument_list|,
operator|&
name|old
argument_list|,
literal|1
argument_list|,
name|iw
argument_list|)
expr_stmt|;
operator|++
name|Lim
argument_list|(
name|pq
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner
condition|)
block|{
name|Size
argument_list|(
name|p
argument_list|)
operator|-=
name|Size
argument_list|(
name|oldq
argument_list|)
expr_stmt|;
name|Size
argument_list|(
name|pq
argument_list|)
operator|+=
name|movnptrs
argument_list|(
operator|&
name|Ptr
argument_list|(
name|pq
argument_list|,
name|l
operator|+
literal|1
argument_list|)
argument_list|,
operator|&
name|oldq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|Size
argument_list|(
name|pq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ft
operator|==
name|f
condition|)
break|break;
name|Pop
argument_list|(
name|ft
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|inner
operator|=
name|Yes
expr_stmt|;
block|}
if|if
condition|(
name|overflow
condition|)
name|p
operator|=
name|mknewroot
argument_list|(
name|p
argument_list|,
name|ip
argument_list|,
name|q
argument_list|,
name|it
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* Tables */
end_comment

begin_function
name|Visible
name|Procedure
name|replace
parameter_list|(
name|a
parameter_list|,
name|pt
parameter_list|,
name|k
parameter_list|)
name|value
name|a
decl_stmt|,
decl|*
name|pt
decl_stmt|,
name|k
decl_stmt|;
end_function

begin_block
block|{
name|item
name|new
decl_stmt|;
name|finger
name|f
decl_stmt|;
name|fingertip
name|ft
init|=
name|f
decl_stmt|;
name|btreeptr
name|p
decl_stmt|;
name|value
modifier|*
name|pp
decl_stmt|;
name|intlet
name|it
decl_stmt|,
name|iw
decl_stmt|,
name|l
decl_stmt|;
name|check
argument_list|(
operator|*
name|pt
argument_list|,
literal|" (replace in)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Is_ELT
argument_list|(
operator|*
name|pt
argument_list|)
condition|)
block|{
operator|(
operator|*
name|pt
operator|)
operator|->
name|type
operator|=
name|Tab
expr_stmt|;
name|Itemtype
argument_list|(
operator|*
name|pt
argument_list|)
operator|=
name|Tt
expr_stmt|;
block|}
name|it
operator|=
name|Itemtype
argument_list|(
operator|*
name|pt
argument_list|)
expr_stmt|;
if|if
condition|(
name|searchkey
argument_list|(
name|k
argument_list|,
name|pt
argument_list|,
name|UNIQUE
argument_list|,
operator|&
name|ft
argument_list|)
condition|)
block|{
name|iw
operator|=
name|Itemwidth
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|Pop
argument_list|(
name|ft
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|&
name|Ascval
argument_list|(
name|Pxitm
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
name|iw
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|copy
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|comp_ok
condition|)
return|return;
name|Keyval
argument_list|(
operator|&
name|new
argument_list|)
operator|=
name|copy
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|Ascval
argument_list|(
operator|&
name|new
argument_list|)
operator|=
name|copy
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|Root
argument_list|(
operator|*
name|pt
argument_list|)
operator|=
name|ins
argument_list|(
operator|&
name|new
argument_list|,
name|f
argument_list|,
name|ft
argument_list|,
name|it
argument_list|)
expr_stmt|;
block|}
name|check
argument_list|(
operator|*
name|pt
argument_list|,
literal|" (replace out)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|Visible
comment|/*bool*/
name|delete
parameter_list|(
name|pt
parameter_list|,
name|k
parameter_list|)
name|value
modifier|*
name|pt
decl_stmt|,
name|k
decl_stmt|;
block|{
name|finger
name|f
decl_stmt|;
name|fingertip
name|ft
init|=
name|f
decl_stmt|;
name|intlet
name|it
init|=
name|Itemtype
argument_list|(
operator|*
name|pt
argument_list|)
decl_stmt|;
name|check
argument_list|(
operator|*
name|pt
argument_list|,
literal|" (delete in)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|searchkey
argument_list|(
name|k
argument_list|,
name|pt
argument_list|,
name|UNIQUE
argument_list|,
operator|&
name|ft
argument_list|)
condition|)
return|return
name|No
return|;
name|Root
argument_list|(
operator|*
name|pt
argument_list|)
operator|=
name|rem
argument_list|(
name|f
argument_list|,
name|ft
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|check
argument_list|(
operator|*
name|pt
argument_list|,
literal|" (delete out)"
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* Lists */
end_comment

begin_function
name|Visible
name|Procedure
name|insert
parameter_list|(
name|v
parameter_list|,
name|pl
parameter_list|)
name|value
name|v
decl_stmt|,
decl|*
name|pl
decl_stmt|;
end_function

begin_block
block|{
name|item
name|new
decl_stmt|;
name|finger
name|f
decl_stmt|;
name|fingertip
name|ft
init|=
name|f
decl_stmt|;
name|intlet
name|it
init|=
name|Itemtype
argument_list|(
operator|*
name|pl
argument_list|)
decl_stmt|;
name|check
argument_list|(
operator|*
name|pl
argument_list|,
literal|" (insert in)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Is_ELT
argument_list|(
operator|*
name|pl
argument_list|)
condition|)
operator|(
operator|*
name|pl
operator|)
operator|->
name|type
operator|=
name|Lis
expr_stmt|;
name|VOID
name|searchkey
argument_list|(
name|v
argument_list|,
name|pl
argument_list|,
name|UNIQUE
argument_list|,
operator|&
name|ft
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|comp_ok
condition|)
return|return;
name|Keyval
argument_list|(
operator|&
name|new
argument_list|)
operator|=
name|copy
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|Ascval
argument_list|(
operator|&
name|new
argument_list|)
operator|=
name|Vnil
expr_stmt|;
name|Root
argument_list|(
operator|*
name|pl
argument_list|)
operator|=
name|ins
argument_list|(
operator|&
name|new
argument_list|,
name|f
argument_list|,
name|ft
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|check
argument_list|(
operator|*
name|pl
argument_list|,
literal|" (insert out)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|Visible
name|Procedure
name|remove
parameter_list|(
name|v
parameter_list|,
name|pl
parameter_list|)
name|value
name|v
decl_stmt|,
decl|*
name|pl
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|!
name|delete
argument_list|(
name|pl
argument_list|,
name|v
argument_list|)
operator|&&
name|still_ok
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|100
argument_list|,
literal|"removing non-existent list entry"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* Miscellaneous accesses */
end_comment

begin_function
name|Hidden
name|itemptr
name|findkey
parameter_list|(
name|key
parameter_list|,
name|pv
parameter_list|,
name|flags
parameter_list|)
name|value
name|key
decl_stmt|,
decl|*
name|pv
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|finger
name|f
decl_stmt|;
name|fingertip
name|ft
init|=
name|f
decl_stmt|;
name|btreeptr
name|p
decl_stmt|;
name|intlet
name|it
init|=
name|Itemtype
argument_list|(
operator|*
name|pv
argument_list|)
decl_stmt|,
name|iw
init|=
name|Itemwidth
argument_list|(
name|it
argument_list|)
decl_stmt|,
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|searchkey
argument_list|(
name|key
argument_list|,
name|pv
argument_list|,
name|flags
argument_list|,
operator|&
name|ft
argument_list|)
condition|)
return|return
name|Inil
return|;
name|Pop
argument_list|(
name|ft
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|Pxitm
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
name|iw
argument_list|)
return|;
block|}
end_block

begin_function
name|Visible
name|value
name|associate
parameter_list|(
name|t
parameter_list|,
name|k
parameter_list|)
name|value
name|t
decl_stmt|,
name|k
decl_stmt|;
block|{
comment|/* t[k] */
name|itemptr
name|ip
decl_stmt|;
if|if
condition|(
operator|!
name|Is_table
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|101
argument_list|,
literal|"in t[k], t is not a table"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
name|ip
operator|=
name|findkey
argument_list|(
name|k
argument_list|,
operator|&
name|t
argument_list|,
name|NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ip
condition|)
block|{
if|if
condition|(
name|still_ok
condition|)
comment|/* Could be type error; then shut up! */
name|error
argument_list|(
name|MESS
argument_list|(
literal|102
argument_list|,
literal|"key not in table"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
return|return
name|copy
argument_list|(
name|Ascval
argument_list|(
name|ip
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
modifier|*
name|adrassoc
parameter_list|(
name|t
parameter_list|,
name|k
parameter_list|)
name|value
name|t
decl_stmt|,
name|k
decl_stmt|;
block|{
comment|/*&t[k] */
name|itemptr
name|ip
init|=
name|findkey
argument_list|(
name|k
argument_list|,
operator|&
name|t
argument_list|,
name|NORMAL
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ip
condition|)
return|return
name|Pnil
return|;
return|return
operator|&
name|Ascval
argument_list|(
name|ip
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|uniq_assoc
parameter_list|(
name|t
parameter_list|,
name|k
parameter_list|)
name|value
name|t
decl_stmt|,
name|k
decl_stmt|;
block|{
comment|/* uniql(&t[k]) */
name|itemptr
name|ip
init|=
name|findkey
argument_list|(
name|k
argument_list|,
operator|&
name|t
argument_list|,
name|UNIQUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|ip
operator|==
name|Inil
condition|)
return|return
name|No
return|;
name|uniql
argument_list|(
operator|&
name|Ascval
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|in_keys
parameter_list|(
name|k
parameter_list|,
name|t
parameter_list|)
name|value
name|k
decl_stmt|,
name|t
decl_stmt|;
block|{
comment|/* k in keys t */
return|return
name|findkey
argument_list|(
name|k
argument_list|,
operator|&
name|t
argument_list|,
name|NORMAL
argument_list|)
operator|!=
name|Inil
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|keys
parameter_list|(
name|t
parameter_list|)
name|value
name|t
decl_stmt|;
block|{
comment|/* keys t */
name|value
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|Is_table
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|103
argument_list|,
literal|"in keys t, t is not a table"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
name|v
operator|=
name|grab_tlt
argument_list|(
name|Lis
argument_list|,
name|Kt
argument_list|)
expr_stmt|;
name|Root
argument_list|(
name|v
argument_list|)
operator|=
name|copybtree
argument_list|(
name|Root
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* WARNING!  The following routine is not reentrant, since (for range lists)    it may return a pointer to static storage. */
end_comment

begin_function
name|Hidden
name|itemptr
name|getkth
parameter_list|(
name|k
parameter_list|,
name|v
parameter_list|)
name|int
name|k
decl_stmt|;
name|value
name|v
decl_stmt|;
block|{
name|finger
name|f
decl_stmt|;
name|fingertip
name|ft
decl_stmt|;
name|btreeptr
name|p
decl_stmt|;
name|intlet
name|it
init|=
name|Itemtype
argument_list|(
name|v
argument_list|)
decl_stmt|,
name|iw
init|=
name|Itemwidth
argument_list|(
name|it
argument_list|)
decl_stmt|,
name|l
decl_stmt|;
specifier|static
name|item
name|baked
decl_stmt|;
name|value
name|vk
decl_stmt|;
if|if
condition|(
name|Root
argument_list|(
name|v
argument_list|)
operator|==
name|Bnil
condition|)
return|return
name|Inil
return|;
name|ft
operator|=
name|unzip
argument_list|(
name|Root
argument_list|(
name|v
argument_list|)
argument_list|,
name|k
argument_list|,
name|f
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ft
operator|==
name|f
condition|)
return|return
name|Inil
return|;
name|Pop
argument_list|(
name|ft
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|l
operator|>=
name|Lim
argument_list|(
name|p
argument_list|)
condition|)
do|;
switch|switch
condition|(
name|Flag
argument_list|(
name|p
argument_list|)
condition|)
block|{
default|default:
case|case
name|Inner
case|:
case|case
name|Bottom
case|:
return|return
name|Pxitm
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
name|iw
argument_list|)
return|;
case|case
name|Irange
case|:
name|release
argument_list|(
name|Keyval
argument_list|(
operator|&
name|baked
argument_list|)
argument_list|)
expr_stmt|;
name|Keyval
argument_list|(
operator|&
name|baked
argument_list|)
operator|=
name|sum
argument_list|(
name|Lwbval
argument_list|(
name|p
argument_list|)
argument_list|,
name|vk
operator|=
name|mk_integer
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|vk
argument_list|)
expr_stmt|;
return|return
operator|&
name|baked
return|;
case|case
name|Crange
case|:
name|release
argument_list|(
name|Keyval
argument_list|(
operator|&
name|baked
argument_list|)
argument_list|)
expr_stmt|;
name|Keyval
argument_list|(
operator|&
name|baked
argument_list|)
operator|=
name|mkchar
argument_list|(
name|Lwbchar
argument_list|(
name|p
argument_list|)
operator|+
name|k
argument_list|)
expr_stmt|;
return|return
operator|&
name|baked
return|;
block|}
block|}
end_function

begin_function
name|Visible
name|value
modifier|*
name|key
parameter_list|(
name|v
parameter_list|,
name|k
parameter_list|)
name|value
name|v
decl_stmt|;
name|intlet
name|k
decl_stmt|;
block|{
comment|/*&(++k th'of keys v) */
name|itemptr
name|ip
init|=
name|getkth
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
decl_stmt|;
return|return
name|ip
condition|?
operator|&
name|Keyval
argument_list|(
name|ip
argument_list|)
else|:
name|Pnil
return|;
block|}
end_function

begin_function
name|Visible
name|value
modifier|*
name|assoc
parameter_list|(
name|v
parameter_list|,
name|k
parameter_list|)
name|value
name|v
decl_stmt|;
name|intlet
name|k
decl_stmt|;
block|{
comment|/*&v[++k th'of keys v] */
name|itemptr
name|ip
init|=
name|getkth
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
decl_stmt|;
return|return
name|ip
condition|?
operator|&
name|Ascval
argument_list|(
name|ip
argument_list|)
else|:
name|Pnil
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|thof
parameter_list|(
name|k
parameter_list|,
name|v
parameter_list|)
name|int
name|k
decl_stmt|;
name|value
name|v
decl_stmt|;
block|{
comment|/* k th'of v */
name|itemptr
name|ip
init|=
name|getkth
argument_list|(
name|k
operator|-
literal|1
argument_list|,
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ip
condition|)
return|return
name|Vnil
return|;
switch|switch
condition|(
name|Type
argument_list|(
name|v
argument_list|)
condition|)
block|{
case|case
name|Tex
case|:
return|return
name|mkchar
argument_list|(
name|Charval
argument_list|(
name|ip
argument_list|)
argument_list|)
return|;
case|case
name|Lis
case|:
return|return
name|copy
argument_list|(
name|Keyval
argument_list|(
name|ip
argument_list|)
argument_list|)
return|;
case|case
name|Tab
case|:
return|return
name|copy
argument_list|(
name|Ascval
argument_list|(
name|ip
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|Vnil
return|;
block|}
block|}
end_function

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* Compare B-trees.  Should use fingers, but to keep things simple    (especially in the presence of range type nodes), doesn't.  This    makes its behaviour O(N log N), where it could be O(N), alas. */
end_comment

begin_comment
comment|/* WARNING!  getkth may return a pointer to static storage (when retrieving    elements from a range list).  Therefore after the second call to getkth,    the return value of the first may be invalid, but only for lists.    So we extract the 'Key' values immediately after the call to getkth. */
end_comment

begin_function
name|Visible
name|relation
name|comp_tlt
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|value
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
name|itemptr
name|up
decl_stmt|,
name|vp
decl_stmt|;
name|int
name|k
decl_stmt|,
name|ulen
decl_stmt|,
name|vlen
decl_stmt|,
name|len
decl_stmt|;
name|relation
name|r
init|=
literal|0
decl_stmt|;
name|bool
name|tex
init|=
name|Is_text
argument_list|(
name|u
argument_list|)
decl_stmt|,
name|tab
init|=
name|Is_table
argument_list|(
name|u
argument_list|)
decl_stmt|;
name|value
name|key_u
decl_stmt|;
name|len
operator|=
name|ulen
operator|=
name|Tltsize
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|vlen
operator|=
name|Tltsize
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlen
operator|<
name|len
condition|)
name|len
operator|=
name|vlen
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|len
condition|;
operator|++
name|k
control|)
block|{
name|up
operator|=
name|getkth
argument_list|(
name|k
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tex
condition|)
name|key_u
operator|=
name|copy
argument_list|(
name|Keyval
argument_list|(
name|up
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|=
name|getkth
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|tex
condition|)
name|r
operator|=
name|Charval
argument_list|(
name|up
argument_list|)
operator|-
name|Charval
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
block|{
name|r
operator|=
name|compare
argument_list|(
name|key_u
argument_list|,
name|Keyval
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|key_u
argument_list|)
expr_stmt|;
if|if
condition|(
name|tab
operator|&&
name|r
operator|==
literal|0
condition|)
name|r
operator|=
name|compare
argument_list|(
name|Ascval
argument_list|(
name|up
argument_list|)
argument_list|,
name|Ascval
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|r
operator|=
name|ulen
operator|-
name|vlen
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Compare texts.  When both texts are bottom nodes, compare with    strncmp(), to speed up the most common use (look-up by the    system of tags in a symbol table).  Otherwise, call comp_tlt(). */
end_comment

begin_function
name|Visible
name|relation
name|comp_text
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|value
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
name|btreeptr
name|p
decl_stmt|,
name|q
decl_stmt|;
name|int
name|len
decl_stmt|;
name|relation
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|Is_text
argument_list|(
name|u
argument_list|)
operator|||
operator|!
name|Is_text
argument_list|(
name|v
argument_list|)
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|104
argument_list|,
literal|"comp_text"
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|Root
argument_list|(
name|u
argument_list|)
operator|,
name|q
operator|=
name|Root
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
name|EQ
name|Bnil
condition|)
return|return
operator|(
name|q
name|EQ
name|Bnil
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
return|;
if|if
condition|(
name|q
name|EQ
name|Bnil
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|Flag
argument_list|(
argument|p
argument_list|)
name|EQ
name|Bottom
operator|&&
name|Flag
argument_list|(
argument|q
argument_list|)
name|EQ
name|Bottom
condition|)
block|{
name|len
operator|=
name|Lim
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lim
argument_list|(
name|q
argument_list|)
operator|<
name|len
condition|)
name|len
operator|=
name|Lim
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|r
operator|=
name|strncmp
argument_list|(
operator|&
name|Bchar
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|Bchar
argument_list|(
name|q
argument_list|,
literal|0
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
name|NE
literal|0
condition|)
return|return
name|r
return|;
return|return
name|Lim
argument_list|(
name|p
argument_list|)
operator|-
name|Lim
argument_list|(
name|q
argument_list|)
return|;
block|}
return|return
name|comp_tlt
argument_list|(
name|u
argument_list|,
name|v
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* Range type nodes */
end_comment

begin_function
name|Visible
name|value
name|mk_numrange
parameter_list|(
name|lwb
parameter_list|,
name|upb
parameter_list|)
name|value
name|lwb
decl_stmt|,
name|upb
decl_stmt|;
block|{
name|value
name|lis
decl_stmt|;
name|btreeptr
name|proot
decl_stmt|;
name|lis
operator|=
name|grab_tlt
argument_list|(
name|Lis
argument_list|,
name|Lt
argument_list|)
expr_stmt|;
if|if
condition|(
name|numcomp
argument_list|(
name|lwb
argument_list|,
name|upb
argument_list|)
operator|>
literal|0
condition|)
name|Root
argument_list|(
name|lis
argument_list|)
operator|=
name|Bnil
expr_stmt|;
else|else
block|{
name|Root
argument_list|(
name|lis
argument_list|)
operator|=
name|proot
operator|=
name|grabbtreenode
argument_list|(
name|Irange
argument_list|,
name|Lt
argument_list|)
expr_stmt|;
name|Lwbval
argument_list|(
name|proot
argument_list|)
operator|=
name|copy
argument_list|(
name|lwb
argument_list|)
expr_stmt|;
name|Upbval
argument_list|(
name|proot
argument_list|)
operator|=
name|copy
argument_list|(
name|upb
argument_list|)
expr_stmt|;
name|set_size_and_lim
argument_list|(
name|proot
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lis
operator|)
return|;
block|}
end_function

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_function
name|Visible
name|value
name|mk_charrange
parameter_list|(
name|lwb
parameter_list|,
name|upb
parameter_list|)
name|value
name|lwb
decl_stmt|,
name|upb
decl_stmt|;
block|{
name|value
name|lis
decl_stmt|;
name|btreeptr
name|proot
decl_stmt|;
name|intlet
name|rsyz
decl_stmt|;
name|lis
operator|=
name|grab_tlt
argument_list|(
name|Lis
argument_list|,
name|Lt
argument_list|)
expr_stmt|;
name|rsyz
operator|=
name|Bchar
argument_list|(
name|Root
argument_list|(
name|upb
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
name|Bchar
argument_list|(
name|Root
argument_list|(
name|lwb
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|rsyz
operator|<=
literal|0
condition|)
name|Root
argument_list|(
name|lis
argument_list|)
operator|=
name|Bnil
expr_stmt|;
else|else
block|{
name|Root
argument_list|(
name|lis
argument_list|)
operator|=
name|proot
operator|=
name|grabbtreenode
argument_list|(
name|Crange
argument_list|,
name|Lt
argument_list|)
expr_stmt|;
name|Size
argument_list|(
name|proot
argument_list|)
operator|=
name|rsyz
expr_stmt|;
name|Lim
argument_list|(
name|proot
argument_list|)
operator|=
name|rsyz
operator|>
literal|1
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|Lwbval
argument_list|(
name|proot
argument_list|)
operator|=
name|copy
argument_list|(
name|lwb
argument_list|)
expr_stmt|;
name|Upbval
argument_list|(
name|proot
argument_list|)
operator|=
name|copy
argument_list|(
name|upb
argument_list|)
expr_stmt|;
block|}
return|return
name|lis
return|;
block|}
end_function

begin_comment
comment|/* set size and lim for integer range node */
end_comment

begin_function
name|Hidden
name|Procedure
name|set_size_and_lim
parameter_list|(
name|pnode
parameter_list|)
name|btreeptr
name|pnode
decl_stmt|;
block|{
name|value
name|uml
decl_stmt|,
name|uml1
decl_stmt|;
name|uml
operator|=
name|diff
argument_list|(
name|Upbval
argument_list|(
name|pnode
argument_list|)
argument_list|,
name|Lwbval
argument_list|(
name|pnode
argument_list|)
argument_list|)
expr_stmt|;
name|uml1
operator|=
name|sum
argument_list|(
name|uml
argument_list|,
name|one
argument_list|)
expr_stmt|;
if|if
condition|(
name|large
argument_list|(
name|uml1
argument_list|)
condition|)
block|{
name|Size
argument_list|(
name|pnode
argument_list|)
operator|=
name|Bigsize
expr_stmt|;
name|Lim
argument_list|(
name|pnode
argument_list|)
operator|=
literal|2
expr_stmt|;
name|error
argument_list|(
name|MESS
argument_list|(
literal|105
argument_list|,
literal|"creating list of too many entries"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Size
argument_list|(
name|pnode
argument_list|)
operator|=
name|intval
argument_list|(
name|uml1
argument_list|)
expr_stmt|;
name|Lim
argument_list|(
name|pnode
argument_list|)
operator|=
name|Size
argument_list|(
name|pnode
argument_list|)
operator|>
literal|1
condition|?
literal|2
else|:
literal|1
expr_stmt|;
block|}
name|release
argument_list|(
name|uml
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|uml1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_comment
comment|/* Dyadic min, max, size of lists */
end_comment

begin_function
name|Visible
name|value
name|l2min
parameter_list|(
name|e
parameter_list|,
name|v
parameter_list|)
name|value
name|e
decl_stmt|,
name|v
decl_stmt|;
block|{
comment|/* e min v */
name|finger
name|f
decl_stmt|;
name|fingertip
name|ft
init|=
name|f
decl_stmt|;
name|btreeptr
name|p
decl_stmt|;
name|intlet
name|it
init|=
name|Itemtype
argument_list|(
name|v
argument_list|)
decl_stmt|,
name|iw
init|=
name|Itemwidth
argument_list|(
name|it
argument_list|)
decl_stmt|,
name|l
decl_stmt|;
name|VOID
name|searchkey
argument_list|(
name|e
argument_list|,
operator|&
name|v
argument_list|,
name|DYAMIN
argument_list|,
operator|&
name|ft
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ft
operator|==
name|f
condition|)
return|return
name|Vnil
return|;
name|Top
argument_list|(
name|ft
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<
name|Lim
argument_list|(
name|p
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|Flag
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|Inner
case|:
return|return
name|copy
argument_list|(
name|Keyval
argument_list|(
name|Piitm
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
name|iw
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|Bottom
case|:
return|return
name|copy
argument_list|(
name|Keyval
argument_list|(
name|Pbitm
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
name|iw
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|Irange
case|:
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
name|copy
argument_list|(
name|Lwbval
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integral
argument_list|(
name|e
argument_list|)
condition|)
return|return
name|sum
argument_list|(
name|e
argument_list|,
name|one
argument_list|)
return|;
return|return
name|ceilf
argument_list|(
name|e
argument_list|)
return|;
case|case
name|Crange
case|:
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
name|copy
argument_list|(
name|Lwbval
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
return|return
name|mkchar
argument_list|(
name|Bchar
argument_list|(
name|Root
argument_list|(
name|e
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
argument_list|)
return|;
block|}
block|}
name|Drop
argument_list|(
name|ft
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Visible
name|value
name|l2max
parameter_list|(
name|e
parameter_list|,
name|v
parameter_list|)
name|value
name|e
decl_stmt|,
name|v
decl_stmt|;
block|{
comment|/* e max v */
name|finger
name|f
decl_stmt|;
name|fingertip
name|ft
init|=
name|f
decl_stmt|;
name|btreeptr
name|p
decl_stmt|;
name|intlet
name|it
init|=
name|Itemtype
argument_list|(
name|v
argument_list|)
decl_stmt|,
name|iw
init|=
name|Itemwidth
argument_list|(
name|it
argument_list|)
decl_stmt|,
name|l
decl_stmt|;
name|VOID
name|searchkey
argument_list|(
name|e
argument_list|,
operator|&
name|v
argument_list|,
name|DYAMAX
argument_list|,
operator|&
name|ft
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ft
operator|==
name|f
condition|)
return|return
name|Vnil
return|;
name|Top
argument_list|(
name|ft
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
operator|--
name|l
expr_stmt|;
if|if
condition|(
name|l
operator|>=
literal|0
condition|)
block|{
switch|switch
condition|(
name|Flag
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|Inner
case|:
return|return
name|copy
argument_list|(
name|Keyval
argument_list|(
name|Piitm
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
name|iw
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|Bottom
case|:
return|return
name|copy
argument_list|(
name|Keyval
argument_list|(
name|Pbitm
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
name|iw
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|Irange
case|:
if|if
condition|(
name|l
operator|==
literal|1
condition|)
return|return
name|copy
argument_list|(
name|Upbval
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|integral
argument_list|(
name|e
argument_list|)
condition|)
return|return
name|diff
argument_list|(
name|e
argument_list|,
name|one
argument_list|)
return|;
return|return
name|floorf
argument_list|(
name|e
argument_list|)
return|;
case|case
name|Crange
case|:
if|if
condition|(
name|l
operator|==
literal|1
condition|)
return|return
name|copy
argument_list|(
name|Upbval
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
return|return
name|mkchar
argument_list|(
name|Bchar
argument_list|(
name|Root
argument_list|(
name|e
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
name|Drop
argument_list|(
name|ft
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Visible
name|int
name|l2size
parameter_list|(
name|e
parameter_list|,
name|v
parameter_list|)
name|value
name|e
decl_stmt|,
name|v
decl_stmt|;
block|{
comment|/* e#v */
name|finger
name|f
decl_stmt|;
name|fingertip
name|ft
init|=
name|f
decl_stmt|;
name|btreeptr
name|p
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|intlet
name|it
init|=
name|Itemtype
argument_list|(
name|v
argument_list|)
decl_stmt|,
name|iw
init|=
name|Itemwidth
argument_list|(
name|it
argument_list|)
decl_stmt|,
name|l
decl_stmt|,
name|r
decl_stmt|;
name|VOID
name|searchkey
argument_list|(
name|e
argument_list|,
operator|&
name|v
argument_list|,
name|DYAMIN
argument_list|,
operator|&
name|ft
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ft
operator|==
name|f
condition|)
return|return
name|count
return|;
name|Pop
argument_list|(
name|ft
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|l
operator|>=
literal|0
condition|)
block|{
name|r
operator|=
name|compare
argument_list|(
name|Keyval
argument_list|(
name|Pxitm
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
name|iw
argument_list|)
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|Flag
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|Irange
case|:
comment|/* See footnote */
if|if
condition|(
name|l
operator|==
literal|0
operator|&&
name|count
operator|==
literal|0
operator|&&
name|integral
argument_list|(
name|e
argument_list|)
condition|)
operator|++
name|count
expr_stmt|;
break|break;
case|case
name|Crange
case|:
comment|/* See footnote */
if|if
condition|(
name|l
operator|==
literal|0
operator|&&
name|count
operator|==
literal|0
operator|&&
operator|!
name|character
argument_list|(
name|e
argument_list|)
condition|)
operator|++
name|count
expr_stmt|;
break|break;
block|}
return|return
name|count
return|;
block|}
operator|++
name|count
expr_stmt|;
while|while
condition|(
name|IsInner
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|Push
argument_list|(
name|ft
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|p
operator|=
name|Ptr
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|Lim
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Clarification of what happens for x#{a..b}:  * Consider these five cases: x<a; x=a; a<x<b; x=b; b<x.  * Only the case a<x<b need be treated specially.  How do we find which  * case we're in?  * Searchkey gives us the following values for l on the stack, respectively:  * 0; 1; 1; 2; 2.  After --l, this becomes -1; 0; 0; 1; 1.  * In cases x=a or x=b, the compare returns 0, and we go another time  * through the loop.  So when the compare returns r!=0, the value of l  * is, respectively: -1; -1; 0; 0; 1.  The -1 cases in fact don't even  * get at the compare, and the correct count is returned automatically.  * So we need to do extra work only if l==0, except if x==b.  * The latter condition is cared for by count==0 (if x==b, count is  * surely>= 1; if a<x<b, count is surely 0).  This works even when  * range nodes may be mixed with other node types in one tree.  */
end_comment

begin_comment
comment|/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* Debug code */
end_comment

begin_function
name|Hidden
name|Procedure
name|check
parameter_list|(
name|v
parameter_list|,
name|whence
parameter_list|)
name|value
name|v
decl_stmt|;
name|string
name|whence
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|still_ok
condition|)
return|return;
switch|switch
condition|(
name|Type
argument_list|(
name|v
argument_list|)
condition|)
block|{
case|case
name|ELT
case|:
return|return;
case|case
name|Lis
case|:
case|case
name|Tab
case|:
break|break;
default|default:
name|error3
argument_list|(
name|MESS
argument_list|(
literal|106
argument_list|,
literal|"value not a list or table"
argument_list|)
argument_list|,
name|Vnil
argument_list|,
name|MESSMAKE
argument_list|(
name|whence
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Root
argument_list|(
name|v
argument_list|)
operator|!=
name|Bnil
condition|)
name|VOID
name|cktree
argument_list|(
name|Inil
argument_list|,
name|Root
argument_list|(
name|v
argument_list|)
argument_list|,
name|Inil
argument_list|,
name|Itemtype
argument_list|(
name|v
argument_list|)
argument_list|,
name|whence
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|still_ok
operator|&&
operator|!
name|interrupted
condition|)
block|{
name|dumptree
argument_list|(
name|Root
argument_list|(
name|v
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Itemtype
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|int
name|cktree
parameter_list|(
name|left
parameter_list|,
name|p
parameter_list|,
name|right
parameter_list|,
name|it
parameter_list|,
name|whence
parameter_list|)
name|itemptr
name|left
decl_stmt|;
name|btreeptr
name|p
decl_stmt|;
name|itemptr
name|right
decl_stmt|;
name|intlet
name|it
decl_stmt|;
name|string
name|whence
decl_stmt|;
block|{
comment|/* returns size of checked subtree */
name|intlet
name|i
decl_stmt|,
name|iw
init|=
name|Itemwidth
argument_list|(
name|it
argument_list|)
decl_stmt|;
name|int
name|sz
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|still_ok
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|p
operator|==
name|Bnil
condition|)
block|{
name|error3
argument_list|(
name|MESS
argument_list|(
literal|107
argument_list|,
literal|"unexpected nil subtree"
argument_list|)
argument_list|,
name|Vnil
argument_list|,
name|MESSMAKE
argument_list|(
name|whence
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|Flag
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|Inner
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Lim
argument_list|(
name|p
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|sz
operator|+=
literal|1
operator|+
name|cktree
argument_list|(
name|left
argument_list|,
name|Ptr
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
argument_list|,
name|Piitm
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|iw
argument_list|)
argument_list|,
name|it
argument_list|,
name|whence
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|still_ok
condition|)
return|return;
name|left
operator|=
name|Piitm
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|iw
argument_list|)
expr_stmt|;
block|}
name|sz
operator|+=
name|cktree
argument_list|(
name|left
argument_list|,
name|Ptr
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
argument_list|,
name|right
argument_list|,
name|it
argument_list|,
name|whence
argument_list|)
expr_stmt|;
if|if
condition|(
name|still_ok
operator|&&
name|sz
operator|!=
name|Size
argument_list|(
name|p
argument_list|)
condition|)
name|error3
argument_list|(
name|MESS
argument_list|(
literal|108
argument_list|,
literal|"size mismatch"
argument_list|)
argument_list|,
name|Vnil
argument_list|,
name|MESSMAKE
argument_list|(
name|whence
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bottom
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Lim
argument_list|(
name|p
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|left
operator|!=
name|Inil
operator|&&
name|compare
argument_list|(
name|Keyval
argument_list|(
name|left
argument_list|)
argument_list|,
name|Keyval
argument_list|(
name|Pbitm
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|iw
argument_list|)
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|error3
argument_list|(
name|MESS
argument_list|(
literal|109
argument_list|,
literal|"bottom items out of order"
argument_list|)
argument_list|,
name|Vnil
argument_list|,
name|MESSMAKE
argument_list|(
name|whence
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|left
operator|=
name|Pbitm
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|iw
argument_list|)
expr_stmt|;
name|sz
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|still_ok
operator|&&
name|right
operator|!=
name|Inil
operator|&&
name|compare
argument_list|(
name|Keyval
argument_list|(
name|left
argument_list|)
argument_list|,
name|Keyval
argument_list|(
name|right
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
name|error3
argument_list|(
name|MESS
argument_list|(
literal|110
argument_list|,
literal|"bottom items out of order"
argument_list|)
argument_list|,
name|Vnil
argument_list|,
name|MESSMAKE
argument_list|(
name|whence
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sz
return|;
case|case
name|Irange
case|:
if|if
condition|(
name|left
operator|!=
name|Inil
operator|&&
name|compare
argument_list|(
name|Keyval
argument_list|(
name|left
argument_list|)
argument_list|,
name|Lwbval
argument_list|(
name|p
argument_list|)
argument_list|)
operator|>
literal|0
operator|||
name|right
operator|!=
name|Inil
operator|&&
name|compare
argument_list|(
name|Upbval
argument_list|(
name|p
argument_list|)
argument_list|,
name|Keyval
argument_list|(
name|right
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
name|error3
argument_list|(
name|MESS
argument_list|(
literal|111
argument_list|,
literal|"irange items out of order"
argument_list|)
argument_list|,
name|Vnil
argument_list|,
name|MESSMAKE
argument_list|(
name|whence
argument_list|)
argument_list|)
expr_stmt|;
name|sz
operator|=
name|Size
argument_list|(
name|p
argument_list|)
expr_stmt|;
default|default:
name|error3
argument_list|(
name|MESS
argument_list|(
literal|112
argument_list|,
literal|"bad node type"
argument_list|)
argument_list|,
name|Vnil
argument_list|,
name|MESSMAKE
argument_list|(
name|whence
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|sz
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NOT_USED
end_ifdef

begin_function
name|Visible
name|Procedure
name|e_dumptree
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|check
argument_list|(
name|v
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|still_ok
condition|)
block|{
if|if
condition|(
operator|!
name|at_nwl
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|dumptree
argument_list|(
name|Root
argument_list|(
name|v
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Itemtype
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|at_nwl
operator|=
name|Yes
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|Hidden
name|Procedure
name|dumptree
parameter_list|(
name|p
parameter_list|,
name|indent
parameter_list|,
name|it
parameter_list|)
name|btreeptr
name|p
decl_stmt|;
name|intlet
name|indent
decl_stmt|,
name|it
decl_stmt|;
block|{
name|intlet
name|i
decl_stmt|,
name|iw
init|=
name|Itemwidth
argument_list|(
name|it
argument_list|)
decl_stmt|;
if|if
condition|(
name|interrupted
condition|)
return|return;
name|printf
argument_list|(
literal|"%*s"
argument_list|,
literal|3
operator|*
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|Bnil
condition|)
block|{
name|printf
argument_list|(
literal|"<nil>"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|Flag
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|Inner
case|:
name|printf
argument_list|(
literal|"(\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|interrupted
operator|&&
name|i
operator|<=
name|Lim
argument_list|(
name|p
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%*s"
argument_list|,
literal|3
operator|*
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|dumpval
argument_list|(
name|Keyval
argument_list|(
name|Piitm
argument_list|(
name|p
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|iw
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|dumptree
argument_list|(
name|Ptr
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
argument_list|,
name|indent
operator|+
literal|1
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%*s"
argument_list|,
literal|3
operator|*
name|indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Bottom
case|:
name|printf
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Lim
argument_list|(
name|p
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|dumpval
argument_list|(
name|Keyval
argument_list|(
name|Pbitm
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|iw
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Irange
case|:
name|printf
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|dumpval
argument_list|(
name|Lwbval
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" .. "
argument_list|)
expr_stmt|;
name|dumpval
argument_list|(
name|Upbval
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"?type='%c'?"
argument_list|,
name|Flag
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|dumpval
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
if|if
condition|(
name|interrupted
condition|)
return|return;
if|if
condition|(
name|v
operator|==
name|Vnil
condition|)
name|printf
argument_list|(
literal|"(nil)"
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|Type
argument_list|(
name|v
argument_list|)
condition|)
block|{
case|case
name|Num
case|:
case|case
name|Tex
case|:
case|case
name|Lis
case|:
case|case
name|Tab
case|:
case|case
name|ELT
case|:
case|case
name|Com
case|:
name|wri
argument_list|(
name|v
argument_list|,
name|No
argument_list|,
name|No
argument_list|,
name|No
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"0x%lx"
argument_list|,
operator|(
name|long
operator|)
name|v
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
else|INTEGRATION
end_else

begin_comment
comment|/* B lists */
end_comment

begin_function
name|Visible
name|value
name|list_elem
parameter_list|(
name|l
parameter_list|,
name|i
parameter_list|)
name|value
name|l
decl_stmt|;
name|intlet
name|i
decl_stmt|;
block|{
return|return
name|List_elem
argument_list|(
name|l
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|insert
parameter_list|(
name|v
parameter_list|,
name|ll
parameter_list|)
name|value
name|v
decl_stmt|,
decl|*
name|ll
decl_stmt|;
end_function

begin_block
block|{
name|intlet
name|len
init|=
name|Length
argument_list|(
operator|*
name|ll
argument_list|)
decl_stmt|;
specifier|register
name|value
modifier|*
name|lp
decl_stmt|,
modifier|*
name|lq
decl_stmt|;
name|intlet
name|k
decl_stmt|;
specifier|register
name|intlet
name|kk
decl_stmt|;
if|if
condition|(
operator|!
name|Is_list
argument_list|(
operator|*
name|ll
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|113
argument_list|,
literal|"inserting in non-list"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|VOID
name|found
argument_list|(
name|list_elem
argument_list|,
operator|*
name|ll
argument_list|,
name|v
argument_list|,
operator|&
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|Unique
argument_list|(
operator|*
name|ll
argument_list|)
operator|&&
operator|!
name|Is_ELT
argument_list|(
operator|*
name|ll
argument_list|)
condition|)
block|{
name|xtndlt
argument_list|(
name|ll
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lq
operator|=
name|Ats
argument_list|(
operator|*
name|ll
argument_list|)
operator|+
name|len
expr_stmt|;
name|lp
operator|=
name|lq
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|kk
operator|=
name|len
init|;
name|kk
operator|>
name|k
condition|;
name|kk
operator|--
control|)
operator|*
name|lq
operator|--
operator|=
operator|*
name|lp
operator|--
expr_stmt|;
operator|*
name|lq
operator|=
name|copy
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lp
operator|=
name|Ats
argument_list|(
operator|*
name|ll
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|*
name|ll
argument_list|)
expr_stmt|;
operator|*
name|ll
operator|=
name|grab_lis
argument_list|(
operator|++
name|len
argument_list|)
expr_stmt|;
name|lq
operator|=
name|Ats
argument_list|(
operator|*
name|ll
argument_list|)
expr_stmt|;
for|for
control|(
name|kk
operator|=
literal|0
init|;
name|kk
operator|<
name|len
condition|;
name|kk
operator|++
control|)
operator|*
name|lq
operator|++
operator|=
name|copy
argument_list|(
name|kk
operator|==
name|k
condition|?
name|v
else|:
operator|*
name|lp
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|Visible
name|remove
parameter_list|(
name|v
parameter_list|,
name|ll
parameter_list|)
name|value
name|v
decl_stmt|;
name|value
modifier|*
name|ll
decl_stmt|;
block|{
specifier|register
name|value
modifier|*
name|lp
decl_stmt|,
modifier|*
name|lq
decl_stmt|;
name|intlet
name|k
decl_stmt|,
name|len
init|=
name|Length
argument_list|(
operator|*
name|ll
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Is_list
argument_list|(
operator|*
name|ll
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|114
argument_list|,
literal|"removing from non-list"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|115
argument_list|,
literal|"removing from empty list"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|found
argument_list|(
name|list_elem
argument_list|,
operator|*
name|ll
argument_list|,
name|v
argument_list|,
operator|&
name|k
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|116
argument_list|,
literal|"removing non-existing list entry"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|lp
operator|=
name|Ats
argument_list|(
operator|*
name|ll
argument_list|)
expr_stmt|;
comment|/* lp[k] = v */
if|if
condition|(
name|Unique
argument_list|(
operator|*
name|ll
argument_list|)
condition|)
block|{
name|release
argument_list|(
operator|*
operator|(
name|lp
operator|+=
name|k
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|k
init|;
name|k
operator|<
name|len
condition|;
name|k
operator|++
control|)
block|{
operator|*
name|lp
operator|=
operator|*
operator|(
name|lp
operator|+
literal|1
operator|)
expr_stmt|;
name|lp
operator|++
expr_stmt|;
block|}
name|xtndlt
argument_list|(
name|ll
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|intlet
name|kk
init|=
name|k
decl_stmt|;
name|lq
operator|=
name|Ats
argument_list|(
operator|*
name|ll
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|*
name|ll
argument_list|)
expr_stmt|;
operator|*
name|ll
operator|=
name|grab_lis
argument_list|(
operator|--
name|len
argument_list|)
expr_stmt|;
name|lp
operator|=
name|Ats
argument_list|(
operator|*
name|ll
argument_list|)
expr_stmt|;
name|Overall
block|{
operator|*
name|lp
operator|++
operator|=
name|copy
argument_list|(
operator|*
name|lq
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|kk
condition|)
name|lq
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|Visible
name|value
name|mk_numrange
parameter_list|(
name|a
parameter_list|,
name|z
parameter_list|)
name|value
name|a
decl_stmt|,
name|z
decl_stmt|;
block|{
name|value
name|l
init|=
name|mk_elt
argument_list|()
decl_stmt|,
name|m
init|=
name|copy
argument_list|(
name|a
argument_list|)
decl_stmt|,
name|n
decl_stmt|;
while|while
condition|(
name|compare
argument_list|(
name|m
argument_list|,
name|z
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|insert
argument_list|(
name|m
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
name|m
operator|=
name|sum
argument_list|(
name|n
operator|=
name|m
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|mk_charrange
parameter_list|(
name|av
parameter_list|,
name|zv
parameter_list|)
name|value
name|av
decl_stmt|,
name|zv
decl_stmt|;
block|{
name|char
name|a
init|=
name|charval
argument_list|(
name|av
argument_list|)
decl_stmt|,
name|z
init|=
name|charval
argument_list|(
name|zv
argument_list|)
decl_stmt|;
name|value
name|l
init|=
name|grab_lis
argument_list|(
call|(
name|intlet
call|)
argument_list|(
name|z
operator|-
name|a
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|value
modifier|*
name|ep
init|=
name|Ats
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|char
name|m
index|[
literal|2
index|]
decl_stmt|;
name|m
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|m
index|[
literal|0
index|]
operator|=
name|a
init|;
name|m
index|[
literal|0
index|]
operator|<=
name|z
condition|;
name|m
index|[
literal|0
index|]
operator|++
control|)
block|{
operator|*
name|ep
operator|++
operator|=
name|mk_text
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************/
end_comment

begin_comment
comment|/* B tables */
end_comment

begin_function
name|Visible
name|value
modifier|*
name|key
parameter_list|(
name|v
parameter_list|,
name|k
parameter_list|)
name|value
name|v
decl_stmt|;
name|intlet
name|k
decl_stmt|;
block|{
comment|/* k in {0..size-1}; no copy */
return|return
name|Key
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
modifier|*
name|assoc
parameter_list|(
name|v
parameter_list|,
name|k
parameter_list|)
name|value
name|v
decl_stmt|;
name|intlet
name|k
decl_stmt|;
block|{
comment|/* k in {0..size-1}; no copy */
return|return
name|Assoc
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|associate
parameter_list|(
name|v
parameter_list|,
name|k
parameter_list|)
name|value
name|v
decl_stmt|;
name|value
name|k
decl_stmt|;
block|{
name|value
modifier|*
name|p
init|=
name|adrassoc
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
return|return
name|copy
argument_list|(
operator|*
name|p
argument_list|)
return|;
name|error
argument_list|(
name|MESS
argument_list|(
literal|117
argument_list|,
literal|"key not in table"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|keys
parameter_list|(
name|ta
parameter_list|)
name|value
name|ta
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|Is_table
argument_list|(
name|ta
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|118
argument_list|,
literal|"in keys t, t is not a table"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|grab_lis
argument_list|(
literal|0
argument_list|)
return|;
block|}
else|else
block|{
name|value
name|li
init|=
name|grab_lis
argument_list|(
name|Length
argument_list|(
name|ta
argument_list|)
argument_list|)
decl_stmt|,
modifier|*
name|le
decl_stmt|,
modifier|*
name|te
init|=
operator|(
name|value
operator|*
operator|)
name|Ats
argument_list|(
name|ta
argument_list|)
decl_stmt|;
name|int
name|k
decl_stmt|,
name|len
init|=
name|Length
argument_list|(
name|ta
argument_list|)
decl_stmt|;
name|le
operator|=
operator|(
name|value
operator|*
operator|)
name|Ats
argument_list|(
name|li
argument_list|)
expr_stmt|;
name|Overall
block|{
operator|*
name|le
operator|++
operator|=
name|copy
argument_list|(
name|Cts
argument_list|(
operator|*
name|te
operator|++
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|li
return|;
block|}
block|}
end_function

begin_function
name|Visible
name|value
name|key_elem
parameter_list|(
name|t
parameter_list|,
name|i
parameter_list|)
name|value
name|t
decl_stmt|;
name|intlet
name|i
decl_stmt|;
block|{
comment|/*The key of the i-th entry*/
return|return
operator|*
name|Key
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* adrassoc returns a pointer to the associate, rather than    the associate itself, so that the caller can decide if a copy    should be taken or not. If the key is not found, Pnil is returned. */
end_comment

begin_function
name|Visible
name|value
modifier|*
name|adrassoc
parameter_list|(
name|t
parameter_list|,
name|ke
parameter_list|)
name|value
name|t
decl_stmt|,
name|ke
decl_stmt|;
block|{
name|intlet
name|where
decl_stmt|;
if|if
condition|(
name|Type
argument_list|(
name|t
argument_list|)
operator|!=
name|Tab
operator|&&
name|Type
argument_list|(
name|t
argument_list|)
operator|!=
name|ELT
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|119
argument_list|,
literal|"selection on non-table"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Pnil
return|;
block|}
return|return
name|found
argument_list|(
name|key_elem
argument_list|,
name|t
argument_list|,
name|ke
argument_list|,
operator|&
name|where
argument_list|)
condition|?
name|Assoc
argument_list|(
name|t
argument_list|,
name|where
argument_list|)
else|:
name|Pnil
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|uniq_assoc
parameter_list|(
name|ta
parameter_list|,
name|ke
parameter_list|)
name|value
name|ta
decl_stmt|,
name|ke
decl_stmt|;
block|{
name|intlet
name|k
decl_stmt|;
if|if
condition|(
name|found
argument_list|(
name|key_elem
argument_list|,
name|ta
argument_list|,
name|ke
argument_list|,
operator|&
name|k
argument_list|)
condition|)
block|{
name|uniql
argument_list|(
name|Ats
argument_list|(
name|ta
argument_list|)
operator|+
name|k
argument_list|)
expr_stmt|;
name|uniql
argument_list|(
name|Assoc
argument_list|(
name|ta
argument_list|,
name|k
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|120
argument_list|,
literal|"uniq_assoc called for non-existent table entry"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|replace
parameter_list|(
name|v
parameter_list|,
name|ta
parameter_list|,
name|ke
parameter_list|)
name|value
modifier|*
name|ta
decl_stmt|,
name|ke
decl_stmt|,
name|v
decl_stmt|;
block|{
name|intlet
name|len
init|=
name|Length
argument_list|(
operator|*
name|ta
argument_list|)
decl_stmt|;
name|value
modifier|*
name|tp
decl_stmt|,
modifier|*
name|tq
decl_stmt|;
name|intlet
name|k
decl_stmt|,
name|kk
decl_stmt|;
name|uniql
argument_list|(
name|ta
argument_list|)
expr_stmt|;
if|if
condition|(
name|Type
argument_list|(
operator|*
name|ta
argument_list|)
operator|==
name|ELT
condition|)
operator|(
operator|*
name|ta
operator|)
operator|->
name|type
operator|=
name|Tab
expr_stmt|;
elseif|else
if|if
condition|(
name|Type
argument_list|(
operator|*
name|ta
argument_list|)
operator|!=
name|Tab
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|121
argument_list|,
literal|"replacing in non-table"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|found
argument_list|(
name|key_elem
argument_list|,
operator|*
name|ta
argument_list|,
name|ke
argument_list|,
operator|&
name|k
argument_list|)
condition|)
block|{
name|value
modifier|*
name|a
decl_stmt|;
name|uniql
argument_list|(
name|Ats
argument_list|(
operator|*
name|ta
argument_list|)
operator|+
name|k
argument_list|)
expr_stmt|;
name|a
operator|=
name|Assoc
argument_list|(
operator|*
name|ta
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|uniql
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|release
argument_list|(
operator|*
name|a
argument_list|)
expr_stmt|;
operator|*
name|a
operator|=
name|copy
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|xtndlt
argument_list|(
name|ta
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tq
operator|=
name|Ats
argument_list|(
operator|*
name|ta
argument_list|)
operator|+
name|len
expr_stmt|;
name|tp
operator|=
name|tq
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|kk
operator|=
name|len
init|;
name|kk
operator|>
name|k
condition|;
name|kk
operator|--
control|)
operator|*
name|tq
operator|--
operator|=
operator|*
name|tp
operator|--
expr_stmt|;
operator|*
name|tq
operator|=
name|grab_com
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|Cts
argument_list|(
operator|*
name|tq
argument_list|)
operator|=
name|copy
argument_list|(
name|ke
argument_list|)
expr_stmt|;
name|Dts
argument_list|(
operator|*
name|tq
argument_list|)
operator|=
name|copy
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Visible
name|bool
name|in_keys
parameter_list|(
name|ke
parameter_list|,
name|tl
parameter_list|)
name|value
name|ke
decl_stmt|,
name|tl
decl_stmt|;
block|{
name|intlet
name|dummy
decl_stmt|;
if|if
condition|(
name|Type
argument_list|(
name|tl
argument_list|)
operator|==
name|ELT
condition|)
return|return
name|No
return|;
if|if
condition|(
name|Type
argument_list|(
name|tl
argument_list|)
operator|!=
name|Tab
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|122
argument_list|,
literal|"in_keys applied to non-table"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|found
argument_list|(
name|key_elem
argument_list|,
name|tl
argument_list|,
name|ke
argument_list|,
operator|&
name|dummy
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|delete
parameter_list|(
name|tl
parameter_list|,
name|ke
parameter_list|)
name|value
modifier|*
name|tl
decl_stmt|,
name|ke
decl_stmt|;
block|{
name|intlet
name|len
decl_stmt|,
name|k
decl_stmt|;
name|value
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|Type
argument_list|(
operator|*
name|tl
argument_list|)
operator|==
name|ELT
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|123
argument_list|,
literal|"deleting table entry from empty table"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Type
argument_list|(
operator|*
name|tl
argument_list|)
operator|!=
name|Tab
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|124
argument_list|,
literal|"deleting table entry from non-table"
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|=
name|Ats
argument_list|(
operator|*
name|tl
argument_list|)
expr_stmt|;
name|len
operator|=
name|Length
argument_list|(
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
argument_list|(
name|key_elem
argument_list|,
operator|*
name|tl
argument_list|,
name|ke
argument_list|,
operator|&
name|k
argument_list|)
condition|)
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|125
argument_list|,
literal|"deleting non-existent table entry"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Unique
argument_list|(
operator|*
name|tl
argument_list|)
condition|)
block|{
name|release
argument_list|(
operator|*
operator|(
name|tp
operator|+=
name|k
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|k
init|;
name|k
operator|<
name|len
condition|;
name|k
operator|++
control|)
block|{
operator|*
name|tp
operator|=
operator|*
operator|(
name|tp
operator|+
literal|1
operator|)
expr_stmt|;
name|tp
operator|++
expr_stmt|;
block|}
name|xtndlt
argument_list|(
name|tl
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|intlet
name|kk
decl_stmt|;
name|value
modifier|*
name|tq
init|=
name|Ats
argument_list|(
operator|*
name|tl
argument_list|)
decl_stmt|;
name|release
argument_list|(
operator|*
name|tl
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|grab_tab
argument_list|(
operator|--
name|len
argument_list|)
expr_stmt|;
name|tp
operator|=
name|Ats
argument_list|(
operator|*
name|tl
argument_list|)
expr_stmt|;
for|for
control|(
name|kk
operator|=
literal|0
init|;
name|kk
operator|<
name|len
condition|;
name|kk
operator|++
control|)
block|{
operator|*
name|tp
operator|++
operator|=
name|copy
argument_list|(
operator|*
name|tq
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|kk
operator|==
name|k
condition|)
name|tq
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
endif|INTEGRATION
end_endif

end_unit

