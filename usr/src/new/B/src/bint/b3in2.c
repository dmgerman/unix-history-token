begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b3in2.c,v 1.4 85/08/22 16:58:21 timo Exp $ */
end_comment

begin_comment
comment|/* B interpreter -- independent subroutines */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b3env.h"
end_include

begin_include
include|#
directive|include
file|"b3in2.h"
end_include

begin_include
include|#
directive|include
file|"b3sem.h"
end_include

begin_include
include|#
directive|include
file|"b3sou.h"
end_include

begin_comment
comment|/* Making ranges */
end_comment

begin_function
name|Hidden
name|value
name|c_range
parameter_list|(
name|lo
parameter_list|,
name|hi
parameter_list|)
name|value
name|lo
decl_stmt|,
name|hi
decl_stmt|;
block|{
name|char
name|a
decl_stmt|,
name|z
decl_stmt|;
if|if
condition|(
operator|!
name|character
argument_list|(
name|lo
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3400
argument_list|,
literal|"in {p..q}, p is a text but not a character"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|Is_text
argument_list|(
name|hi
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3401
argument_list|,
literal|"in {p..q}, p is a text, but q is not"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|character
argument_list|(
name|hi
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3402
argument_list|,
literal|"in {p..q}, q is a text, but not a character"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|a
operator|=
name|charval
argument_list|(
name|lo
argument_list|)
expr_stmt|;
name|z
operator|=
name|charval
argument_list|(
name|hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|<
name|a
operator|-
literal|1
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3403
argument_list|,
literal|"in {p..q}, character q< x< p"
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|mk_charrange
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|)
return|;
block|}
return|return
name|Vnil
return|;
block|}
end_function

begin_function
name|Hidden
name|value
name|i_range
parameter_list|(
name|lo
parameter_list|,
name|hi
parameter_list|)
name|value
name|lo
decl_stmt|,
name|hi
decl_stmt|;
block|{
name|value
name|entries
decl_stmt|,
name|res
init|=
name|Vnil
decl_stmt|;
if|if
condition|(
operator|!
name|integral
argument_list|(
name|lo
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3404
argument_list|,
literal|"in {p..q}, p is a number but not an integer"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|Is_number
argument_list|(
name|hi
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3405
argument_list|,
literal|"in {p..q}, p is a number but q is not"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|integral
argument_list|(
name|hi
argument_list|)
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3406
argument_list|,
literal|"in {p..q}, q is a number but not an integer"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|entries
operator|=
name|diff
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
argument_list|(
name|entries
argument_list|,
name|one
argument_list|)
operator|>
literal|0
condition|)
name|error
argument_list|(
name|MESS
argument_list|(
literal|3407
argument_list|,
literal|"in {p..q}, integer q< x< p"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|mk_numrange
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|mk_range
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
name|value
name|v1
decl_stmt|,
name|v2
decl_stmt|;
block|{
name|value
name|r
init|=
name|Vnil
decl_stmt|;
if|if
condition|(
name|Is_text
argument_list|(
name|v1
argument_list|)
condition|)
name|r
operator|=
name|c_range
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Is_number
argument_list|(
name|v1
argument_list|)
condition|)
name|r
operator|=
name|i_range
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
name|MESS
argument_list|(
literal|3408
argument_list|,
literal|"in {p..q}, p is neither a text nor a number"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Newlines for WRITE /// */
end_comment

begin_function
name|Visible
name|Procedure
name|nl
parameter_list|(
name|n
parameter_list|)
name|value
name|n
decl_stmt|;
block|{
name|value
name|l
init|=
name|size
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|intval
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|release
argument_list|(
name|l
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|--
condition|)
name|newline
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Evaluating basic targets */
end_comment

begin_function
name|Visible
name|value
name|v_local
parameter_list|(
name|name
parameter_list|,
name|number
parameter_list|)
name|value
name|name
decl_stmt|,
name|number
decl_stmt|;
block|{
name|value
modifier|*
name|aa
init|=
name|envassoc
argument_list|(
name|curnv
operator|->
name|tab
argument_list|,
name|number
argument_list|)
decl_stmt|;
if|if
condition|(
name|aa
operator|!=
name|Pnil
operator|&&
operator|*
name|aa
operator|!=
name|Vnil
condition|)
return|return
name|copy
argument_list|(
operator|*
name|aa
argument_list|)
return|;
name|error3
argument_list|(
literal|0
argument_list|,
name|name
argument_list|,
name|MESS
argument_list|(
literal|3409
argument_list|,
literal|" has not yet received a value"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|v_global
parameter_list|(
name|name
parameter_list|)
name|value
name|name
decl_stmt|;
block|{
name|value
modifier|*
name|aa
init|=
name|envassoc
argument_list|(
name|prmnv
operator|->
name|tab
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|aa
operator|!=
name|Pnil
operator|&&
operator|*
name|aa
operator|!=
name|Vnil
condition|)
return|return
name|copy
argument_list|(
name|tarvalue
argument_list|(
name|name
argument_list|,
operator|*
name|aa
argument_list|)
argument_list|)
return|;
name|error3
argument_list|(
literal|0
argument_list|,
name|name
argument_list|,
name|MESS
argument_list|(
literal|3410
argument_list|,
literal|" has not yet received a value"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
end_function

begin_comment
comment|/* Locating mysteries */
end_comment

begin_function
name|Visible
name|loc
name|l_mystery
parameter_list|(
name|name
parameter_list|,
name|number
parameter_list|)
name|value
name|name
decl_stmt|,
name|number
decl_stmt|;
block|{
if|if
condition|(
name|Is_compound
argument_list|(
name|curnv
operator|->
name|tab
argument_list|)
condition|)
return|return
name|local_loc
argument_list|(
operator|(
name|basidf
operator|)
name|number
argument_list|)
return|;
return|return
name|global_loc
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Rangers */
end_comment

begin_comment
comment|/* An IN-ranger is represented on the stack as a compound of three fields:    the last index used, the value of the expression after IN, and its length.    (The latter is redundant, but saves save many calls of 'size()'.)    When first called, there is, of course, no compound on the stack, but only    the value of the expression.  As the expression should always be a text,    list or table, this is recognizable as a special case, and then the    compound is created.    Return value is Yes if a new element was available and assigned, No if not. */
end_comment

begin_function
name|Visible
name|bool
name|in_ranger
parameter_list|(
name|l
parameter_list|,
name|pv
parameter_list|)
name|loc
name|l
decl_stmt|;
name|value
modifier|*
name|pv
decl_stmt|;
block|{
name|value
name|v
init|=
operator|*
name|pv
decl_stmt|,
name|ind
decl_stmt|,
name|tlt
decl_stmt|,
name|len
decl_stmt|,
name|i1
decl_stmt|,
name|val
decl_stmt|;
name|bool
name|res
decl_stmt|;
if|if
condition|(
operator|!
name|Is_compound
argument_list|(
name|v
argument_list|)
operator|||
name|Nfields
argument_list|(
name|v
argument_list|)
operator|!=
literal|3
condition|)
block|{
comment|/* First time */
name|tlt
operator|=
name|v
expr_stmt|;
if|if
condition|(
operator|!
name|Is_tlt
argument_list|(
name|tlt
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|3411
argument_list|,
literal|"in ... i IN e, e is not a text, list or table"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
if|if
condition|(
name|empty
argument_list|(
name|tlt
argument_list|)
condition|)
return|return
name|No
return|;
operator|*
name|pv
operator|=
name|v
operator|=
name|mk_compound
argument_list|(
literal|3
argument_list|)
expr_stmt|;
operator|*
name|Field
argument_list|(
name|v
argument_list|,
literal|0
argument_list|)
operator|=
name|ind
operator|=
name|one
expr_stmt|;
operator|*
name|Field
argument_list|(
name|v
argument_list|,
literal|1
argument_list|)
operator|=
name|tlt
expr_stmt|;
operator|*
name|Field
argument_list|(
name|v
argument_list|,
literal|2
argument_list|)
operator|=
name|len
operator|=
name|size
argument_list|(
name|tlt
argument_list|)
expr_stmt|;
name|bind
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ind
operator|=
operator|*
name|Field
argument_list|(
name|v
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tlt
operator|=
operator|*
name|Field
argument_list|(
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
operator|*
name|Field
argument_list|(
name|v
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|res
operator|=
name|numcomp
argument_list|(
name|ind
argument_list|,
name|len
argument_list|)
operator|<
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
block|{
name|unbind
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
operator|*
name|Field
argument_list|(
name|v
argument_list|,
literal|0
argument_list|)
operator|=
name|ind
operator|=
name|sum
argument_list|(
name|i1
operator|=
name|ind
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|i1
argument_list|)
expr_stmt|;
block|}
name|put
argument_list|(
name|val
operator|=
name|th_of
argument_list|(
name|ind
argument_list|,
name|tlt
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_comment
comment|/* PARSING-rangers are treated similarly to IN-rangers, but here the    compound contains the last parse (i.e., N texts). */
end_comment

begin_function
name|Visible
name|bool
name|pa_ranger
parameter_list|(
name|l
parameter_list|,
name|pv
parameter_list|)
name|loc
name|l
decl_stmt|;
name|value
modifier|*
name|pv
decl_stmt|;
block|{
name|value
name|v
init|=
operator|*
name|pv
decl_stmt|,
name|e
decl_stmt|,
name|f
decl_stmt|;
name|int
name|len
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|Is_compound
argument_list|(
name|v
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|Is_text
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|3412
argument_list|,
literal|"in  ... i PARSING e, e is not a text"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
if|if
condition|(
operator|!
name|Is_compound
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|MESS
argument_list|(
literal|3413
argument_list|,
literal|"in ... i PARSING e, i is not a collateral identifier"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
name|v
operator|=
name|mk_compound
argument_list|(
name|len
operator|=
name|Nfields
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|Field
argument_list|(
name|v
argument_list|,
name|len
operator|-
literal|1
argument_list|)
operator|=
operator|*
name|pv
expr_stmt|;
operator|*
name|Field
argument_list|(
name|v
argument_list|,
literal|0
argument_list|)
operator|=
name|e
operator|=
name|mk_text
argument_list|(
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|len
operator|-
literal|1
condition|;
operator|++
name|k
control|)
operator|*
name|Field
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
operator|=
name|copy
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|*
name|pv
operator|=
name|v
expr_stmt|;
name|bind
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|v
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
name|uniql
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|v
operator|=
operator|*
name|pv
expr_stmt|;
name|len
operator|=
name|Nfields
argument_list|(
name|v
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|len
operator|-
literal|1
init|;
name|k
operator|>
literal|0
condition|;
operator|--
name|k
control|)
block|{
if|if
condition|(
operator|!
name|empty
argument_list|(
name|f
operator|=
operator|*
name|Field
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
argument_list|)
condition|)
block|{
name|value
name|head
decl_stmt|,
name|tail
decl_stmt|,
name|prev
decl_stmt|,
name|newprev
decl_stmt|,
name|two
init|=
name|sum
argument_list|(
name|one
argument_list|,
name|one
argument_list|)
decl_stmt|;
name|head
operator|=
name|curtail
argument_list|(
name|f
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|tail
operator|=
name|behead
argument_list|(
name|f
argument_list|,
name|two
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|newprev
operator|=
name|concat
argument_list|(
name|prev
operator|=
operator|*
name|Field
argument_list|(
name|v
argument_list|,
name|k
operator|-
literal|1
argument_list|)
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|head
argument_list|)
expr_stmt|;
operator|*
name|Field
argument_list|(
name|v
argument_list|,
name|k
operator|-
literal|1
argument_list|)
operator|=
name|newprev
expr_stmt|;
if|if
condition|(
name|k
operator|<
name|len
operator|-
literal|1
condition|)
operator|*
name|Field
argument_list|(
name|v
argument_list|,
name|k
argument_list|)
operator|=
operator|*
name|Field
argument_list|(
name|v
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|Field
argument_list|(
name|v
argument_list|,
name|len
operator|-
literal|1
argument_list|)
operator|=
name|tail
expr_stmt|;
name|put
argument_list|(
name|v
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
block|}
name|unbind
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
end_function

end_unit

