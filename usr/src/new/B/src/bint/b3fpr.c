begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/*   $Header: b3fpr.c,v 1.4 85/08/22 16:58:15 timo Exp $ */
end_comment

begin_comment
comment|/* B formula/predicate invocation */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0fea.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b3err.h"
end_include

begin_include
include|#
directive|include
file|"b3sem.h"
end_include

begin_include
include|#
directive|include
file|"b3sou.h"
end_include

begin_define
define|#
directive|define
name|Other
value|0
end_define

begin_define
define|#
directive|define
name|Nume
value|1
end_define

begin_define
define|#
directive|define
name|In
value|1
end_define

begin_define
define|#
directive|define
name|Not_in
value|2
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|EXT_COMMAND
end_ifdef

begin_define
define|#
directive|define
name|Char_ready
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Table defining all predefined functions (but not propositions).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXT_COMMAND
end_ifdef

begin_function_decl
specifier|extern
name|value
name|e_getchar
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|value
name|e_screensize
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|outcome
name|e_ch_ready
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
endif|EXT_COMMAND
end_endif

begin_struct
struct|struct
name|funtab
block|{
name|string
name|f_name
decl_stmt|;
name|literal
name|f_adic
decl_stmt|,
name|f_kind
decl_stmt|;
name|value
function_decl|(
modifier|*
name|f_fun
function_decl|)
parameter_list|()
function_decl|;
name|bool
name|f_extended
decl_stmt|;
block|}
name|funtab
index|[]
init|=
block|{
block|{
literal|"~"
block|,
name|Mon
block|,
name|Nume
block|,
name|approximate
block|}
block|,
block|{
literal|"+"
block|,
name|Mon
block|,
name|Nume
block|,
name|copy
block|}
block|,
block|{
literal|"+"
block|,
name|Dya
block|,
name|Nume
block|,
name|sum
block|}
block|,
block|{
literal|"-"
block|,
name|Mon
block|,
name|Nume
block|,
name|negated
block|}
block|,
block|{
literal|"-"
block|,
name|Dya
block|,
name|Nume
block|,
name|diff
block|}
block|,
block|{
literal|"*/"
block|,
name|Mon
block|,
name|Nume
block|,
name|numerator
block|}
block|,
block|{
literal|"/*"
block|,
name|Mon
block|,
name|Nume
block|,
name|denominator
block|}
block|,
block|{
literal|"*"
block|,
name|Dya
block|,
name|Nume
block|,
name|prod
block|}
block|,
block|{
literal|"/"
block|,
name|Dya
block|,
name|Nume
block|,
name|quot
block|}
block|,
block|{
literal|"**"
block|,
name|Dya
block|,
name|Nume
block|,
name|power
block|}
block|,
block|{
literal|"^"
block|,
name|Dya
block|,
name|Other
block|,
name|concat
block|}
block|,
block|{
literal|"^^"
block|,
name|Dya
block|,
name|Other
block|,
name|repeat
block|}
block|,
block|{
literal|"<<"
block|,
name|Dya
block|,
name|Other
block|,
name|adjleft
block|}
block|,
block|{
literal|"><"
block|,
name|Dya
block|,
name|Other
block|,
name|centre
block|}
block|,
block|{
literal|">>"
block|,
name|Dya
block|,
name|Other
block|,
name|adjright
block|}
block|,
block|{
literal|"#"
block|,
name|Mon
block|,
name|Other
block|,
name|size
block|}
block|,
block|{
literal|"#"
block|,
name|Dya
block|,
name|Other
block|,
name|size2
block|}
block|,
block|{
literal|"pi"
block|,
name|Zer
block|,
name|Other
block|,
name|pi
block|}
block|,
block|{
literal|"e"
block|,
name|Zer
block|,
name|Other
block|,
name|e
block|}
block|,
block|{
literal|"abs"
block|,
name|Mon
block|,
name|Nume
block|,
name|absval
block|}
block|,
block|{
literal|"sign"
block|,
name|Mon
block|,
name|Nume
block|,
name|signum
block|}
block|,
block|{
literal|"floor"
block|,
name|Mon
block|,
name|Nume
block|,
name|floorf
block|}
block|,
block|{
literal|"ceiling"
block|,
name|Mon
block|,
name|Nume
block|,
name|ceilf
block|}
block|,
block|{
literal|"round"
block|,
name|Mon
block|,
name|Nume
block|,
name|round1
block|}
block|,
block|{
literal|"round"
block|,
name|Dya
block|,
name|Nume
block|,
name|round2
block|}
block|,
block|{
literal|"mod"
block|,
name|Dya
block|,
name|Nume
block|,
name|mod
block|}
block|,
block|{
literal|"root"
block|,
name|Mon
block|,
name|Nume
block|,
name|root1
block|}
block|,
block|{
literal|"root"
block|,
name|Dya
block|,
name|Nume
block|,
name|root2
block|}
block|,
block|{
literal|"sin"
block|,
name|Mon
block|,
name|Nume
block|,
name|sin1
block|}
block|,
block|{
literal|"cos"
block|,
name|Mon
block|,
name|Nume
block|,
name|cos1
block|}
block|,
block|{
literal|"tan"
block|,
name|Mon
block|,
name|Nume
block|,
name|tan1
block|}
block|,
block|{
literal|"atan"
block|,
name|Mon
block|,
name|Nume
block|,
name|atn1
block|}
block|,
block|{
literal|"atan"
block|,
name|Dya
block|,
name|Nume
block|,
name|atn2
block|}
block|,
block|{
literal|"exp"
block|,
name|Mon
block|,
name|Nume
block|,
name|exp1
block|}
block|,
block|{
literal|"log"
block|,
name|Mon
block|,
name|Nume
block|,
name|log1
block|}
block|,
block|{
literal|"log"
block|,
name|Dya
block|,
name|Nume
block|,
name|log2
block|}
block|,
block|{
literal|"keys"
block|,
name|Mon
block|,
name|Other
block|,
name|keys
block|}
block|,
block|{
literal|"th'of"
block|,
name|Dya
block|,
name|Other
block|,
name|th_of
block|}
block|,
block|{
literal|"min"
block|,
name|Mon
block|,
name|Other
block|,
name|min1
block|}
block|,
block|{
literal|"min"
block|,
name|Dya
block|,
name|Other
block|,
name|min2
block|}
block|,
block|{
literal|"max"
block|,
name|Mon
block|,
name|Other
block|,
name|max1
block|}
block|,
block|{
literal|"max"
block|,
name|Dya
block|,
name|Other
block|,
name|max2
block|}
block|,
ifdef|#
directive|ifdef
name|EXT_COMMAND
comment|/* Extended group: */
block|{
literal|"get'char"
block|,
name|Zer
block|,
name|Other
block|,
name|e_getchar
block|,
name|Yes
block|}
block|,
block|{
literal|"screen'size"
block|,
name|Zer
block|,
name|Other
block|,
name|e_screensize
block|,
name|Yes
block|}
block|,
endif|#
directive|endif
block|{
literal|""
block|,
name|Dya
block|,
name|Other
block|,
name|NULL
block|}
comment|/*sentinel*/
block|}
struct|;
end_struct

begin_function
name|Visible
name|Procedure
name|initfpr
parameter_list|()
block|{
name|struct
name|funtab
modifier|*
name|fp
decl_stmt|;
name|value
name|r
decl_stmt|,
name|f
decl_stmt|,
name|pname
decl_stmt|;
specifier|extern
name|bool
name|extcmds
decl_stmt|;
comment|/* Flag set by -E option */
for|for
control|(
name|fp
operator|=
name|funtab
init|;
operator|*
operator|(
name|fp
operator|->
name|f_name
operator|)
operator|!=
literal|'\0'
condition|;
operator|++
name|fp
control|)
block|{
ifdef|#
directive|ifdef
name|EXT_COMMAND
if|if
condition|(
name|fp
operator|->
name|f_extended
operator|&&
operator|!
name|extcmds
condition|)
continue|continue;
endif|#
directive|endif
comment|/* Define function */
name|r
operator|=
name|mk_text
argument_list|(
name|fp
operator|->
name|f_name
argument_list|)
expr_stmt|;
name|f
operator|=
name|mk_fun
argument_list|(
name|fp
operator|->
name|f_adic
argument_list|,
call|(
name|intlet
call|)
argument_list|(
name|fp
operator|-
name|funtab
argument_list|)
argument_list|,
name|NilTree
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
name|pname
operator|=
name|permkey
argument_list|(
name|r
argument_list|,
name|fp
operator|->
name|f_adic
argument_list|)
expr_stmt|;
name|def_unit
argument_list|(
name|pname
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|pname
argument_list|)
expr_stmt|;
block|}
name|defprd
argument_list|(
literal|"in"
argument_list|,
name|Dya
argument_list|,
name|In
argument_list|)
expr_stmt|;
name|defprd
argument_list|(
literal|"not'in"
argument_list|,
name|Dya
argument_list|,
name|Not_in
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXT_COMMAND
if|if
condition|(
name|extcmds
condition|)
name|defprd
argument_list|(
literal|"char'ready"
argument_list|,
name|Zer
argument_list|,
name|Char_ready
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|defprd
parameter_list|(
name|repr
parameter_list|,
name|adic
parameter_list|,
name|pre
parameter_list|)
name|string
name|repr
decl_stmt|;
name|literal
name|adic
decl_stmt|;
name|intlet
name|pre
decl_stmt|;
block|{
name|value
name|r
init|=
name|mk_text
argument_list|(
name|repr
argument_list|)
decl_stmt|,
name|p
init|=
name|mk_prd
argument_list|(
name|adic
argument_list|,
name|pre
argument_list|,
name|NilTree
argument_list|,
name|Yes
argument_list|)
decl_stmt|,
name|pname
decl_stmt|;
name|pname
operator|=
name|permkey
argument_list|(
name|r
argument_list|,
name|adic
argument_list|)
expr_stmt|;
name|def_unit
argument_list|(
name|pname
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|pname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* returns if a given test/yield exists *without faults* */
end_comment

begin_function
name|Hidden
name|bool
name|is_funprd
parameter_list|(
name|t
parameter_list|,
name|f
parameter_list|,
name|adicity
parameter_list|,
name|func
parameter_list|)
name|value
name|t
decl_stmt|,
decl|*
name|f
decl_stmt|;
end_function

begin_decl_stmt
name|literal
name|adicity
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|func
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|value
modifier|*
name|aa
decl_stmt|;
if|if
condition|(
operator|!
name|is_unit
argument_list|(
name|t
argument_list|,
name|adicity
argument_list|,
operator|&
name|aa
argument_list|)
condition|)
return|return
name|No
return|;
if|if
condition|(
name|still_ok
condition|)
block|{
if|if
condition|(
name|func
condition|)
block|{
if|if
condition|(
operator|!
name|Is_function
argument_list|(
operator|*
name|aa
argument_list|)
condition|)
return|return
name|No
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|Is_predicate
argument_list|(
operator|*
name|aa
argument_list|)
condition|)
return|return
name|No
return|;
block|}
operator|*
name|f
operator|=
operator|*
name|aa
expr_stmt|;
return|return
name|Yes
return|;
block|}
else|else
return|return
name|No
return|;
block|}
end_block

begin_function
name|Visible
name|bool
name|is_zerfun
parameter_list|(
name|t
parameter_list|,
name|f
parameter_list|)
name|value
name|t
decl_stmt|,
decl|*
name|f
decl_stmt|;
end_function

begin_block
block|{
return|return
name|is_funprd
argument_list|(
name|t
argument_list|,
name|f
argument_list|,
name|Zer
argument_list|,
name|Yes
argument_list|)
return|;
block|}
end_block

begin_function
name|Visible
name|bool
name|is_monfun
parameter_list|(
name|t
parameter_list|,
name|f
parameter_list|)
name|value
name|t
decl_stmt|,
decl|*
name|f
decl_stmt|;
end_function

begin_block
block|{
return|return
name|is_funprd
argument_list|(
name|t
argument_list|,
name|f
argument_list|,
name|Mon
argument_list|,
name|Yes
argument_list|)
return|;
block|}
end_block

begin_function
name|Visible
name|bool
name|is_dyafun
parameter_list|(
name|t
parameter_list|,
name|f
parameter_list|)
name|value
name|t
decl_stmt|,
decl|*
name|f
decl_stmt|;
end_function

begin_block
block|{
return|return
name|is_funprd
argument_list|(
name|t
argument_list|,
name|f
argument_list|,
name|Dya
argument_list|,
name|Yes
argument_list|)
return|;
block|}
end_block

begin_function
name|Visible
name|bool
name|is_zerprd
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
name|value
name|t
decl_stmt|,
decl|*
name|p
decl_stmt|;
end_function

begin_block
block|{
return|return
name|is_funprd
argument_list|(
name|t
argument_list|,
name|p
argument_list|,
name|Zer
argument_list|,
name|No
argument_list|)
return|;
block|}
end_block

begin_function
name|Visible
name|bool
name|is_monprd
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
name|value
name|t
decl_stmt|,
decl|*
name|p
decl_stmt|;
end_function

begin_block
block|{
return|return
name|is_funprd
argument_list|(
name|t
argument_list|,
name|p
argument_list|,
name|Mon
argument_list|,
name|No
argument_list|)
return|;
block|}
end_block

begin_function
name|Visible
name|bool
name|is_dyaprd
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
name|value
name|t
decl_stmt|,
decl|*
name|p
decl_stmt|;
end_function

begin_block
block|{
return|return
name|is_funprd
argument_list|(
name|t
argument_list|,
name|p
argument_list|,
name|Dya
argument_list|,
name|No
argument_list|)
return|;
block|}
end_block

begin_function
name|Visible
name|value
name|pre_fun
parameter_list|(
name|nd1
parameter_list|,
name|pre
parameter_list|,
name|nd2
parameter_list|)
name|value
name|nd1
decl_stmt|,
name|nd2
decl_stmt|;
name|intlet
name|pre
decl_stmt|;
block|{
name|struct
name|funtab
modifier|*
name|fp
init|=
operator|&
name|funtab
index|[
name|pre
index|]
decl_stmt|;
name|literal
name|adic
init|=
name|fp
operator|->
name|f_adic
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_kind
operator|==
name|Nume
operator|&&
name|adic
operator|!=
name|Zer
condition|)
block|{
comment|/* check types */
if|if
condition|(
name|adic
operator|==
name|Dya
operator|&&
operator|!
name|Is_number
argument_list|(
name|nd1
argument_list|)
condition|)
block|{
name|error3
argument_list|(
name|MESSMAKE
argument_list|(
name|fp
operator|->
name|f_name
argument_list|)
argument_list|,
name|Vnil
argument_list|,
name|MESS
argument_list|(
literal|4500
argument_list|,
literal|" has a non-numeric left operand"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|Is_number
argument_list|(
name|nd2
argument_list|)
condition|)
block|{
name|error3
argument_list|(
name|MESSMAKE
argument_list|(
name|fp
operator|->
name|f_name
argument_list|)
argument_list|,
name|Vnil
argument_list|,
name|MESS
argument_list|(
literal|4501
argument_list|,
literal|" has a non-numeric right operand"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Vnil
return|;
block|}
block|}
switch|switch
condition|(
name|adic
condition|)
block|{
case|case
name|Zer
case|:
return|return
operator|(
call|(
modifier|*
name|fp
operator|->
name|f_fun
call|)
argument_list|()
operator|)
return|;
case|case
name|Mon
case|:
return|return
operator|(
call|(
modifier|*
name|fp
operator|->
name|f_fun
call|)
argument_list|(
name|nd2
argument_list|)
operator|)
return|;
case|case
name|Dya
case|:
return|return
operator|(
call|(
modifier|*
name|fp
operator|->
name|f_fun
call|)
argument_list|(
name|nd1
argument_list|,
name|nd2
argument_list|)
operator|)
return|;
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|3300
argument_list|,
literal|"pre-defined fpr wrong"
argument_list|)
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
end_function

begin_function
name|Visible
name|outcome
name|pre_prop
parameter_list|(
name|nd1
parameter_list|,
name|pre
parameter_list|,
name|nd2
parameter_list|)
name|value
name|nd1
decl_stmt|,
name|nd2
decl_stmt|;
name|intlet
name|pre
decl_stmt|;
block|{
switch|switch
condition|(
name|pre
condition|)
block|{
case|case
name|In
case|:
return|return
name|in
argument_list|(
name|nd1
argument_list|,
name|nd2
argument_list|)
return|;
case|case
name|Not_in
case|:
return|return
operator|!
name|in
argument_list|(
name|nd1
argument_list|,
name|nd2
argument_list|)
return|;
ifdef|#
directive|ifdef
name|EXT_COMMAND
case|case
name|Char_ready
case|:
return|return
name|e_ch_ready
argument_list|()
return|;
endif|#
directive|endif
default|default:
name|syserr
argument_list|(
name|MESS
argument_list|(
literal|3301
argument_list|,
literal|"predicate not covered by proposition"
argument_list|)
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
end_function

end_unit

