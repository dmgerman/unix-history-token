begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_comment
comment|/* $Header: b2fil.c,v 1.1 84/06/28 00:49:11 timo Exp $ */
end_comment

begin_comment
comment|/* Facilities supplied by the file system */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b2fil.h"
end_include

begin_include
include|#
directive|include
file|"b2scr.h"
end_include

begin_comment
comment|/*This file defines the facilities needed for dealing with files,   apart from C's standard I/O facilities which are used throughout the system.    Units are held on files in a 'workspace', which on Unix is modelled   using directories. The function 'f_uname' converts a unit name into a   unique filename. On Unix this is done by prepending a character to the unit   name to indicate the kind of unit (for how'to ', and for tests and yields< for zeroadic, " for monadic and> for dyadic; these have been chosen as   characters that are not usually used in filenames), and truncating the   name if necessary. If the name does have to be truncated, then it is   hashed to produce a character that is appended to the filename, in an attempt   to produce a unique filename. Even so, it is still possible for different   unit names to produce the same filename, and in the unlikely event of this   happening you get an error message that the unit already exists when you   try to create the clashing unit name.    Filenames are at most SAFEFNLEN characters long, which on standard Unix   systems gives you one spare character for making backups or whatever.    It would be better if the B system effectively maintained its own directories   that mapped units onto files in the real file system, as is done for targets.   With operating systems with a more limited file system (eg even shorter   filenames) this is the only possibility.  */
end_comment

begin_define
define|#
directive|define
name|COML
value|60
end_define

begin_decl_stmt
name|char
name|com_line
index|[
name|COML
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|At_eos
parameter_list|(
name|s
parameter_list|)
value|((s)+= strlen(s))
end_define

begin_function
name|Visible
name|Procedure
name|f_edit
parameter_list|(
name|fname
parameter_list|,
name|errline
parameter_list|)
name|value
name|fname
decl_stmt|;
name|intlet
name|errline
decl_stmt|;
block|{
comment|/*The default editor is called with a first parameter of the line number 	  and a second parameter of the file name*/
name|string
name|cl
init|=
name|com_line
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|filtered
condition|)
block|{
name|ignsigs
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\001: +%d %s\n"
argument_list|,
name|errline
argument_list|,
name|strval
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
do|do
block|{
name|c
operator|=
name|fgetc
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
do|;
name|re_sigs
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|getenv
argument_list|(
literal|"BEDITOR"
argument_list|)
operator|==
name|NULL
condition|)
name|strcpy
argument_list|(
name|cl
argument_list|,
name|DEDI
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|cl
argument_list|,
name|getenv
argument_list|(
literal|"BEDITOR"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|cl
operator|+
name|strlen
argument_list|(
name|cl
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|errline
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|At_eos
argument_list|(
name|cl
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
else|else
operator|*
operator|(
name|cl
operator|+
name|strlen
argument_list|(
name|cl
argument_list|)
operator|-
literal|1
operator|)
operator|=
literal|' '
expr_stmt|;
block|}
name|app_fname
argument_list|(
name|At_eos
argument_list|(
name|cl
argument_list|)
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|com_line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|value
name|f_save
parameter_list|(
name|fname
parameter_list|)
name|value
name|fname
decl_stmt|;
block|{
comment|/* saves the file in a temporary file, whose name is returned */
comment|/* Here the OS does the copy: you may have to do this yourself */
name|string
name|cl
decl_stmt|;
name|value
name|sname
init|=
name|mk_text
argument_list|(
name|SAVEFILE
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|cl
operator|=
name|com_line
argument_list|,
literal|"cp"
argument_list|)
expr_stmt|;
name|app_fname
argument_list|(
name|At_eos
argument_list|(
name|cl
argument_list|)
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|app_fname
argument_list|(
name|At_eos
argument_list|(
name|cl
argument_list|)
argument_list|,
name|sname
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|com_line
argument_list|)
expr_stmt|;
return|return
name|sname
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|f_rename
parameter_list|(
name|fname
parameter_list|,
name|nfname
parameter_list|)
name|value
name|fname
decl_stmt|,
name|nfname
decl_stmt|;
block|{
name|string
name|cl
decl_stmt|;
name|strcpy
argument_list|(
name|cl
operator|=
name|com_line
argument_list|,
literal|"mv"
argument_list|)
expr_stmt|;
name|app_fname
argument_list|(
name|At_eos
argument_list|(
name|cl
argument_list|)
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|app_fname
argument_list|(
name|At_eos
argument_list|(
name|cl
argument_list|)
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|com_line
argument_list|)
expr_stmt|;
comment|/* what if mv fails??? */
block|}
end_function

begin_function
name|Visible
name|Procedure
name|f_delete
parameter_list|(
name|fname
parameter_list|)
name|value
name|fname
decl_stmt|;
block|{
name|string
name|cl
decl_stmt|;
name|strcpy
argument_list|(
name|cl
operator|=
name|com_line
argument_list|,
literal|"rm"
argument_list|)
expr_stmt|;
name|app_fname
argument_list|(
name|At_eos
argument_list|(
name|cl
argument_list|)
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|com_line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|bool
name|f_exists
parameter_list|(
name|fname
parameter_list|)
name|value
name|fname
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|strval
argument_list|(
name|fname
argument_list|)
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
name|No
return|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SAFEFNLEN
value|13
end_define

begin_function
name|Hidden
name|double
name|f_hash
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|int
name|len
init|=
name|length
argument_list|(
name|v
argument_list|)
decl_stmt|,
name|k
decl_stmt|;
name|double
name|d
init|=
literal|'"'
operator|+
literal|.404
operator|*
name|len
decl_stmt|;
comment|/*That '"' is strange I know, but it's necessary for compatibility*/
name|value
name|ch
decl_stmt|;
name|k_Over_len
block|{
name|ch
operator|=
name|thof
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|d
operator|=
literal|.987
operator|*
name|d
operator|+
literal|.277
operator|*
name|charval
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
return|return
name|d
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|f_uname
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|value
name|name
decl_stmt|;
name|literal
name|type
decl_stmt|;
block|{
specifier|static
name|char
name|fname
index|[
name|SAFEFNLEN
operator|+
literal|1
index|]
decl_stmt|;
name|string
name|sfn
init|=
name|fname
decl_stmt|;
operator|*
name|sfn
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|length
argument_list|(
name|name
argument_list|)
operator|<
name|SAFEFNLEN
condition|)
name|strcpy
argument_list|(
name|sfn
operator|+
literal|1
argument_list|,
name|strval
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|double
name|hh
init|=
name|f_hash
argument_list|(
name|name
argument_list|)
operator|*
literal|321.987
decl_stmt|;
name|char
name|h
decl_stmt|;
name|strncpy
argument_list|(
name|sfn
operator|+
literal|1
argument_list|,
name|strval
argument_list|(
name|name
argument_list|)
argument_list|,
name|SAFEFNLEN
operator|-
literal|2
argument_list|)
expr_stmt|;
name|hh
operator|=
name|hh
operator|-
name|floor
argument_list|(
name|hh
argument_list|)
expr_stmt|;
name|h
operator|=
operator|(
name|char
operator|)
name|floor
argument_list|(
name|hh
operator|*
literal|29
argument_list|)
operator|+
literal|'!'
expr_stmt|;
if|if
condition|(
name|h
operator|>=
literal|'"'
condition|)
name|h
operator|++
expr_stmt|;
if|if
condition|(
name|h
operator|>=
literal|'\''
condition|)
name|h
operator|++
expr_stmt|;
if|if
condition|(
name|h
operator|>=
literal|'/'
condition|)
name|h
operator|++
expr_stmt|;
if|if
condition|(
name|h
operator|>=
literal|'0'
condition|)
name|h
operator|+=
literal|10
expr_stmt|;
if|if
condition|(
name|h
operator|>=
literal|'A'
condition|)
name|h
operator|+=
literal|26
expr_stmt|;
if|if
condition|(
name|h
operator|>=
literal|'a'
condition|)
name|h
operator|+=
literal|26
expr_stmt|;
operator|*
operator|(
name|sfn
operator|+
name|SAFEFNLEN
operator|-
literal|1
operator|)
operator|=
name|h
expr_stmt|;
operator|*
operator|(
name|sfn
operator|+
name|SAFEFNLEN
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|mk_text
argument_list|(
name|fname
argument_list|)
return|;
block|}
end_function

begin_function
name|Hidden
name|value
name|try
parameter_list|(
name|t
parameter_list|,
name|n
parameter_list|)
name|value
name|t
decl_stmt|;
name|intlet
name|n
decl_stmt|;
block|{
name|value
name|eq
init|=
name|mk_text
argument_list|(
literal|"="
argument_list|)
decl_stmt|,
name|fn
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|;
name|int
name|len
init|=
name|length
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|fn
operator|=
name|concat
argument_list|(
name|eq
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* PUT "="^(n<<1)^t IN fn */
name|fn
operator|=
name|concat
argument_list|(
name|eq
argument_list|,
name|a
operator|=
name|concat
argument_list|(
name|b
operator|=
name|convert
argument_list|(
name|c
operator|=
name|mk_integer
argument_list|(
name|n
argument_list|)
argument_list|,
name|No
argument_list|,
name|No
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|eq
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|SAFEFNLEN
condition|)
block|{
name|fn
operator|=
name|trim
argument_list|(
name|a
operator|=
name|fn
argument_list|,
literal|0
argument_list|,
name|len
operator|-
name|SAFEFNLEN
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fn
operator|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|f_tname
parameter_list|(
name|t
parameter_list|)
name|value
name|t
decl_stmt|;
block|{
name|value
name|fn
init|=
name|try
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|intlet
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|f_exists
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|release
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|fn
operator|=
name|try
argument_list|(
name|t
argument_list|,
operator|++
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fn
operator|)
return|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|app_fname
parameter_list|(
name|ceos
parameter_list|,
name|fname
parameter_list|)
name|string
name|ceos
decl_stmt|;
name|value
name|fname
decl_stmt|;
block|{
name|string
name|fp
init|=
name|strval
argument_list|(
name|fname
argument_list|)
decl_stmt|;
name|intlet
name|k
decl_stmt|,
name|len
init|=
name|strlen
argument_list|(
name|fp
argument_list|)
decl_stmt|;
operator|*
name|ceos
operator|++
operator|=
literal|' '
expr_stmt|;
name|k_Over_len
block|{
operator|*
name|ceos
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|ceos
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
comment|/*should really use charval(thof(...))*/
block|}
operator|*
name|ceos
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|unsigned
name|f_size
parameter_list|(
name|ifile
parameter_list|)
name|FILE
modifier|*
name|ifile
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|ifile
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"can't stat file"
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|sb
operator|.
name|st_size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|f_interactive
parameter_list|(
name|ifile
parameter_list|)
name|FILE
modifier|*
name|ifile
decl_stmt|;
block|{
return|return
name|isatty
argument_list|(
name|fileno
argument_list|(
name|ifile
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|lst_uhds
parameter_list|()
block|{
comment|/*List the headings of the units in this workspace*/
name|system
argument_list|(
literal|"for i in \\'* \\<* \\\"* \\>*; do head -1 $i 2>/dev/null; done"
argument_list|)
expr_stmt|;
comment|/*just for now, you understand*/
block|}
end_function

end_unit

