begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_comment
comment|/* $Header: b2cmd.c,v 1.1 84/06/28 00:49:04 timo Exp $ */
end_comment

begin_comment
comment|/* B commands */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b2env.h"
end_include

begin_include
include|#
directive|include
file|"b2scr.h"
end_include

begin_include
include|#
directive|include
file|"b2err.h"
end_include

begin_include
include|#
directive|include
file|"b2key.h"
end_include

begin_include
include|#
directive|include
file|"b2syn.h"
end_include

begin_include
include|#
directive|include
file|"b2sem.h"
end_include

begin_include
include|#
directive|include
file|"b2typ.h"
end_include

begin_define
define|#
directive|define
name|Nex
value|if (!xeq) {tx= ceol; return Yes;}
end_define

begin_decl_stmt
name|char
name|rdbuf
index|[
name|RDBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|txptr
name|rdbufend
init|=
operator|&
name|rdbuf
index|[
name|RDBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|USE_QUIT
value|"\r*** use QUIT or interrupt to abort READ command\n"
end_define

begin_function
name|Hidden
name|Procedure
name|read_line
parameter_list|(
name|l
parameter_list|,
name|t
parameter_list|,
name|eg
parameter_list|)
name|loc
name|l
decl_stmt|;
name|btype
name|t
decl_stmt|;
name|bool
name|eg
decl_stmt|;
block|{
name|context
name|c
decl_stmt|;
name|txptr
name|tx0
init|=
name|tx
decl_stmt|,
name|rp
decl_stmt|;
name|intlet
name|k
decl_stmt|;
name|value
name|r
decl_stmt|;
name|btype
name|rt
decl_stmt|;
name|envtab
name|svprmnvtab
init|=
name|Vnil
decl_stmt|;
name|bool
name|must_sv
init|=
name|eg
decl_stmt|,
name|got
decl_stmt|;
name|sv_context
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_reads
operator|>=
name|MAX_NMB_ACT_READS
condition|)
name|error
argument_list|(
literal|"too many READs simultaneously active"
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|reading
index|[
name|active_reads
operator|++
index|]
argument_list|)
operator|!=
literal|0
condition|)
comment|/* long jump occurred */
name|set_context
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|cntxt
operator|!=
name|In_read
condition|)
name|sv_context
argument_list|(
operator|&
name|read_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|must_sv
condition|)
name|svprmnvtab
operator|=
name|prmnvtab
operator|==
name|Vnil
condition|?
name|Vnil
else|:
name|prmnv
operator|->
name|tab
expr_stmt|;
comment|/* save scratch-pad copy because of following setprmnv() */
if|if
condition|(
name|eg
condition|)
name|setprmnv
argument_list|()
expr_stmt|;
name|must_sv
operator|=
name|No
expr_stmt|;
name|cntxt
operator|=
name|In_read
expr_stmt|;
name|got
operator|=
name|No
expr_stmt|;
while|while
condition|(
operator|!
name|got
condition|)
block|{
name|tx
operator|=
name|rp
operator|=
name|rdbuf
expr_stmt|;
if|if
condition|(
name|read_interactive
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|eg
condition|?
name|eg_prompt
else|:
name|raw_prompt
argument_list|)
expr_stmt|;
block|}
name|got
operator|=
name|Yes
expr_stmt|;
while|while
condition|(
operator|(
name|k
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|k
operator|!=
literal|'\n'
condition|)
block|{
operator|*
name|rp
operator|++
operator|=
name|k
expr_stmt|;
if|if
condition|(
name|rp
operator|>
name|rdbufend
operator|-
literal|1
condition|)
name|syserr
argument_list|(
literal|"read buffer overflow"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|read_interactive
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|USE_QUIT
argument_list|)
expr_stmt|;
name|CLEAR_EOF
expr_stmt|;
if|if
condition|(
name|outeractive
condition|)
name|at_nwl
operator|=
name|Yes
expr_stmt|;
name|got
operator|=
name|No
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"End of file encountered during READ command"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|read_interactive
operator|&&
name|outeractive
operator|&&
name|k
operator|==
literal|'\n'
condition|)
name|at_nwl
operator|=
name|Yes
expr_stmt|;
operator|*
name|rp
operator|=
literal|'\n'
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|atkw
argument_list|(
name|QUIT
argument_list|)
condition|)
name|int_signal
argument_list|(
name|Yes
argument_list|)
expr_stmt|;
if|if
condition|(
name|eg
condition|)
block|{
name|r
operator|=
name|expr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|rt
operator|=
name|valtype
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|svprmnvtab
operator|!=
name|Vnil
condition|)
block|{
name|prmnvtab
operator|=
name|prmnv
operator|->
name|tab
expr_stmt|;
name|prmnv
operator|->
name|tab
operator|=
name|svprmnvtab
expr_stmt|;
block|}
name|must_sv
operator|=
name|Yes
expr_stmt|;
name|set_context
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|must_agree
argument_list|(
name|t
argument_list|,
name|rt
argument_list|,
literal|"type of expression does not agree with that of EG sample"
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|rp
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|=
name|mk_text
argument_list|(
name|rdbuf
argument_list|)
expr_stmt|;
name|set_context
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
name|put
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|active_reads
operator|--
expr_stmt|;
name|release
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|tx
operator|=
name|tx0
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|check
parameter_list|(
name|o
parameter_list|)
name|outcome
name|o
decl_stmt|;
block|{
if|if
condition|(
name|o
operator|==
name|Fail
condition|)
name|checkerr
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|bool
name|sim_com
parameter_list|()
block|{
name|txptr
name|ftx
decl_stmt|,
name|ttx
decl_stmt|;
switch|switch
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
condition|)
block|{
case|case
literal|'C'
case|:
if|if
condition|(
name|atkw
argument_list|(
name|CHECK
argument_list|)
condition|)
block|{
name|env
name|e0
init|=
name|curnv
decl_stmt|;
name|outcome
name|o
decl_stmt|;
name|Nex
expr_stmt|;
name|o
operator|=
name|test
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
block|{
name|check
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|restore_env
argument_list|(
name|e0
argument_list|)
expr_stmt|;
block|}
return|return
name|Yes
return|;
block|}
elseif|else
if|if
condition|(
name|atkw
argument_list|(
name|CHOOSE
argument_list|)
condition|)
block|{
name|loc
name|l
decl_stmt|;
name|value
name|v
decl_stmt|;
name|reqkw
argument_list|(
name|FROM_choose
argument_list|,
operator|&
name|ftx
argument_list|,
operator|&
name|ttx
argument_list|)
expr_stmt|;
name|Nex
expr_stmt|;
name|l
operator|=
name|targ
argument_list|(
name|ftx
argument_list|)
expr_stmt|;
name|tx
operator|=
name|ttx
expr_stmt|;
name|v
operator|=
name|expr
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
name|choose
argument_list|(
name|l
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
case|case
literal|'D'
case|:
if|if
condition|(
name|atkw
argument_list|(
name|DELETE
argument_list|)
condition|)
block|{
name|loc
name|l
decl_stmt|;
name|Nex
expr_stmt|;
name|l
operator|=
name|targ
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
name|l_delete
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
elseif|else
if|if
condition|(
name|atkw
argument_list|(
name|DRAW
argument_list|)
condition|)
block|{
name|loc
name|l
decl_stmt|;
name|Nex
expr_stmt|;
name|l
operator|=
name|targ
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
name|draw
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
case|case
literal|'E'
case|:
if|if
condition|(
name|atkw
argument_list|(
name|ELSE
argument_list|)
condition|)
block|{
name|pprerr
argument_list|(
literal|"ELSE only allowed as alternative test after SELECT"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
name|No
return|;
case|case
literal|'I'
case|:
if|if
condition|(
name|atkw
argument_list|(
name|INSERT
argument_list|)
condition|)
block|{
name|value
name|v
decl_stmt|;
name|loc
name|l
decl_stmt|;
name|reqkw
argument_list|(
name|IN_insert
argument_list|,
operator|&
name|ftx
argument_list|,
operator|&
name|ttx
argument_list|)
expr_stmt|;
name|Nex
expr_stmt|;
name|v
operator|=
name|expr
argument_list|(
name|ftx
argument_list|)
expr_stmt|;
name|tx
operator|=
name|ttx
expr_stmt|;
name|l
operator|=
name|targ
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
name|l_insert
argument_list|(
name|v
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
case|case
literal|'P'
case|:
if|if
condition|(
name|atkw
argument_list|(
name|PUT
argument_list|)
condition|)
block|{
name|value
name|v
decl_stmt|;
name|loc
name|l
decl_stmt|;
name|reqkw
argument_list|(
name|IN_put
argument_list|,
operator|&
name|ftx
argument_list|,
operator|&
name|ttx
argument_list|)
expr_stmt|;
name|Nex
expr_stmt|;
name|v
operator|=
name|expr
argument_list|(
name|ftx
argument_list|)
expr_stmt|;
name|tx
operator|=
name|ttx
expr_stmt|;
name|l
operator|=
name|targ
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
name|put
argument_list|(
name|v
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
case|case
literal|'R'
case|:
if|if
condition|(
name|atkw
argument_list|(
name|READ
argument_list|)
condition|)
block|{
name|value
name|v
decl_stmt|;
name|loc
name|l
decl_stmt|;
name|btype
name|vt
decl_stmt|,
name|lt
decl_stmt|;
name|bool
name|eg
init|=
name|Yes
decl_stmt|;
if|if
condition|(
name|find
argument_list|(
name|RAW
argument_list|,
name|ceol
argument_list|,
operator|&
name|ftx
argument_list|,
operator|&
name|ttx
argument_list|)
condition|)
block|{
name|eg
operator|=
name|No
expr_stmt|;
name|vt
operator|=
name|mk_text
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|reqkw
argument_list|(
name|EG
argument_list|,
operator|&
name|ftx
argument_list|,
operator|&
name|ttx
argument_list|)
expr_stmt|;
name|Nex
expr_stmt|;
name|l
operator|=
name|targ
argument_list|(
name|ftx
argument_list|)
expr_stmt|;
name|lt
operator|=
name|loctype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|tx
operator|=
name|ttx
expr_stmt|;
if|if
condition|(
name|eg
condition|)
block|{
name|v
operator|=
name|expr
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
name|vt
operator|=
name|valtype
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|must_agree
argument_list|(
name|vt
argument_list|,
name|lt
argument_list|,
name|eg
condition|?
literal|"this sample could not lawfully be put in the target"
else|:
literal|"in READ x RAW, x must be a simple textual target"
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|lt
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
name|read_line
argument_list|(
name|l
argument_list|,
name|vt
argument_list|,
name|eg
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|vt
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
elseif|else
if|if
condition|(
name|atkw
argument_list|(
name|REMOVE
argument_list|)
condition|)
block|{
name|value
name|v
decl_stmt|;
name|loc
name|l
decl_stmt|;
name|reqkw
argument_list|(
name|FROM_remove
argument_list|,
operator|&
name|ftx
argument_list|,
operator|&
name|ttx
argument_list|)
expr_stmt|;
name|Nex
expr_stmt|;
name|v
operator|=
name|expr
argument_list|(
name|ftx
argument_list|)
expr_stmt|;
name|tx
operator|=
name|ttx
expr_stmt|;
name|l
operator|=
name|targ
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
name|l_remove
argument_list|(
name|v
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
case|case
literal|'S'
case|:
if|if
condition|(
name|atkw
argument_list|(
name|SET_RANDOM
argument_list|)
condition|)
block|{
name|value
name|v
decl_stmt|;
name|Nex
expr_stmt|;
name|v
operator|=
name|expr
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
name|set_random
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
elseif|else
if|if
condition|(
name|atkw
argument_list|(
name|SHARE
argument_list|)
condition|)
name|pprerr
argument_list|(
literal|"SHARE only allowed following HOW'TO-, YIELD- or TEST-heading"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|No
return|;
case|case
literal|'W'
case|:
if|if
condition|(
name|atkw
argument_list|(
name|WRITE
argument_list|)
condition|)
block|{
name|txptr
name|tx0
decl_stmt|;
name|value
name|v
decl_stmt|;
name|intlet
name|nwlc
decl_stmt|;
name|Nex
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
while|while
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'/'
operator|&&
operator|(
name|Char
argument_list|(
name|tx
operator|+
literal|1
argument_list|)
operator|==
literal|'/'
operator|)
condition|)
block|{
if|if
condition|(
name|xeq
condition|)
name|newline
argument_list|()
expr_stmt|;
name|tx
operator|++
expr_stmt|;
block|}
name|tx0
operator|=
name|tx
expr_stmt|;
name|loop
label|:
if|if
condition|(
name|Char
argument_list|(
name|tx
operator|++
argument_list|)
operator|!=
literal|'/'
condition|)
block|{
name|tx
operator|=
name|tx0
expr_stmt|;
goto|goto
name|postnl
goto|;
block|}
if|if
condition|(
name|Char
argument_list|(
name|tx
operator|++
argument_list|)
operator|==
literal|'*'
condition|)
goto|goto
name|loop
goto|;
if|if
condition|(
name|xeq
condition|)
name|newline
argument_list|()
expr_stmt|;
name|tx
operator|=
name|tx0
operator|+
literal|1
expr_stmt|;
name|postnl
label|:
name|ftx
operator|=
name|ceol
expr_stmt|;
while|while
condition|(
name|Space
argument_list|(
name|Char
argument_list|(
name|ftx
operator|-
literal|1
argument_list|)
argument_list|)
condition|)
name|ftx
operator|--
expr_stmt|;
name|nwlc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ftx
operator|>
name|tx
operator|&&
name|Char
argument_list|(
name|ftx
operator|-
literal|1
argument_list|)
operator|==
literal|'/'
condition|)
block|{
name|nwlc
operator|++
expr_stmt|;
name|ftx
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ftx
operator|>
name|tx
condition|)
block|{
name|v
operator|=
name|expr
argument_list|(
name|ftx
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
name|writ
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|nwlc
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|xeq
condition|)
name|newline
argument_list|()
expr_stmt|;
block|}
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
default|default:
return|return
name|No
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|Reqcol
value|{req(":", ceol,&utx,&vtx); \ 		if (!xeq) {tx= vtx; comm_suite(); return Yes;}}
end_define

begin_define
define|#
directive|define
name|Resetx
parameter_list|(
name|tx0
parameter_list|)
value|{tx= (tx0); lino= lino0; cur_ilev= cil;}
end_define

begin_function
name|Hidden
name|bool
name|con_com
parameter_list|()
block|{
name|intlet
name|lino0
init|=
name|lino
decl_stmt|,
name|cil
init|=
name|cur_ilev
decl_stmt|;
name|txptr
name|ftx
decl_stmt|,
name|ttx
decl_stmt|,
name|utx
decl_stmt|,
name|vtx
decl_stmt|;
switch|switch
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
condition|)
block|{
case|case
literal|'I'
case|:
if|if
condition|(
name|atkw
argument_list|(
name|IF
argument_list|)
condition|)
block|{
name|env
name|e0
init|=
name|curnv
decl_stmt|;
name|bool
name|xeq0
init|=
name|xeq
decl_stmt|;
name|outcome
name|o
decl_stmt|;
name|Reqcol
expr_stmt|;
name|o
operator|=
name|test
argument_list|(
name|utx
argument_list|)
expr_stmt|;
name|xeq
operator|=
name|o
operator|==
name|Succ
expr_stmt|;
name|tx
operator|=
name|vtx
expr_stmt|;
name|comm_suite
argument_list|()
expr_stmt|;
name|xeq
operator|=
name|xeq0
expr_stmt|;
name|restore_env
argument_list|(
name|e0
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
case|case
literal|'S'
case|:
if|if
condition|(
name|atkw
argument_list|(
name|SELECT
argument_list|)
condition|)
block|{
name|need
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|upto
argument_list|(
name|ceol
argument_list|,
literal|"SELECT:"
argument_list|)
expr_stmt|;
name|alt_suite
argument_list|()
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
case|case
literal|'W'
case|:
if|if
condition|(
name|atkw
argument_list|(
name|WHILE
argument_list|)
condition|)
block|{
name|env
name|e0
init|=
name|curnv
decl_stmt|;
name|bool
name|xeq0
init|=
name|xeq
decl_stmt|;
name|txptr
name|tx0
init|=
name|tx
decl_stmt|;
name|outcome
name|o
decl_stmt|;
name|Reqcol
expr_stmt|;
name|loop
label|:
name|o
operator|=
name|test
argument_list|(
name|utx
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq0
condition|)
name|xeq
operator|=
name|o
operator|==
name|Succ
expr_stmt|;
name|tx
operator|=
name|vtx
expr_stmt|;
name|comm_suite
argument_list|()
expr_stmt|;
name|xeq
operator|=
name|xeq0
expr_stmt|;
name|restore_env
argument_list|(
name|e0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
operator|&&
name|o
operator|==
name|Succ
operator|&&
operator|!
name|terminated
condition|)
block|{
name|Resetx
argument_list|(
name|tx0
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
case|case
literal|'F'
case|:
if|if
condition|(
name|atkw
argument_list|(
name|FOR
argument_list|)
condition|)
block|{
name|env
name|e0
init|=
name|curnv
decl_stmt|;
name|bool
name|xeq0
init|=
name|xeq
decl_stmt|;
name|loc
name|l
decl_stmt|;
name|value
name|v
decl_stmt|,
name|w
decl_stmt|;
name|Reqcol
expr_stmt|;
if|if
condition|(
name|find
argument_list|(
name|PARSING
argument_list|,
name|utx
argument_list|,
operator|&
name|ftx
argument_list|,
operator|&
name|ttx
argument_list|)
condition|)
block|{
name|tx
operator|=
name|ttx
expr_stmt|;
name|pprerr
argument_list|(
literal|"PARSING not allowed in FOR ..."
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|reqkw
argument_list|(
name|IN_for
argument_list|,
operator|&
name|ftx
argument_list|,
operator|&
name|ttx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttx
operator|>
name|ceol
condition|)
block|{
name|tx
operator|=
name|ceol
expr_stmt|;
name|parerr
argument_list|(
literal|"IN after colon"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|targ
argument_list|(
name|ftx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Is_simploc
argument_list|(
name|l
argument_list|)
operator|&&
operator|!
name|Is_compound
argument_list|(
name|l
argument_list|)
condition|)
comment|/*to bloc.c?*/
name|pprerr
argument_list|(
literal|"inappropriate identifier after FOR"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|bind
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|tx
operator|=
name|ttx
expr_stmt|;
name|v
operator|=
name|expr
argument_list|(
name|utx
argument_list|)
expr_stmt|;
block|{
name|value
name|k
decl_stmt|,
name|k1
decl_stmt|,
name|len
init|=
name|xeq
condition|?
name|size
argument_list|(
name|v
argument_list|)
else|:
name|copy
argument_list|(
name|one
argument_list|)
decl_stmt|;
if|if
condition|(
name|compare
argument_list|(
name|len
argument_list|,
name|zero
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xeq
operator|=
name|No
expr_stmt|;
name|release
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
name|copy
argument_list|(
name|one
argument_list|)
expr_stmt|;
block|}
name|k
operator|=
name|copy
argument_list|(
name|one
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|terminated
operator|&&
name|compare
argument_list|(
name|k
argument_list|,
name|len
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|Resetx
argument_list|(
name|utx
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
block|{
name|w
operator|=
name|th_of
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|w
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
name|k
operator|=
name|sum
argument_list|(
name|k1
operator|=
name|k
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|k1
argument_list|)
expr_stmt|;
name|tx
operator|=
name|vtx
expr_stmt|;
name|comm_suite
argument_list|()
expr_stmt|;
block|}
name|release
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
name|xeq
operator|=
name|xeq0
expr_stmt|;
name|restore_env
argument_list|(
name|e0
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
default|default:
return|return
name|No
return|;
block|}
block|}
end_function

begin_function
name|Hidden
name|bool
name|term_com
parameter_list|()
block|{
switch|switch
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
condition|)
block|{
case|case
literal|'F'
case|:
if|if
condition|(
name|atkw
argument_list|(
name|FAIL
argument_list|)
condition|)
block|{
name|upto
argument_list|(
name|ceol
argument_list|,
literal|"FAIL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
block|{
name|chckvtc
argument_list|(
name|Rep
argument_list|)
expr_stmt|;
name|resout
operator|=
name|Fail
expr_stmt|;
name|terminated
operator|=
name|Yes
expr_stmt|;
block|}
else|else
name|tx
operator|=
name|ceol
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
case|case
literal|'Q'
case|:
if|if
condition|(
name|atkw
argument_list|(
name|QUIT
argument_list|)
condition|)
block|{
name|upto
argument_list|(
name|ceol
argument_list|,
literal|"QUIT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
block|{
if|if
condition|(
name|cur_ilev
operator|==
literal|0
condition|)
name|bye
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|chckvtc
argument_list|(
name|Voi
argument_list|)
expr_stmt|;
name|terminated
operator|=
name|Yes
expr_stmt|;
block|}
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
case|case
literal|'R'
case|:
if|if
condition|(
name|atkw
argument_list|(
name|RETURN
argument_list|)
condition|)
block|{
if|if
condition|(
name|xeq
condition|)
block|{
name|chckvtc
argument_list|(
name|Ret
argument_list|)
expr_stmt|;
name|resval
operator|=
name|expr
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
name|terminated
operator|=
name|Yes
expr_stmt|;
block|}
else|else
name|tx
operator|=
name|ceol
expr_stmt|;
return|return
name|Yes
return|;
block|}
elseif|else
if|if
condition|(
name|atkw
argument_list|(
name|REPORT
argument_list|)
condition|)
block|{
if|if
condition|(
name|xeq
condition|)
block|{
name|chckvtc
argument_list|(
name|Rep
argument_list|)
expr_stmt|;
name|resout
operator|=
name|test
argument_list|(
name|ceol
argument_list|)
expr_stmt|;
name|terminated
operator|=
name|Yes
expr_stmt|;
block|}
else|else
name|tx
operator|=
name|ceol
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
case|case
literal|'S'
case|:
if|if
condition|(
name|atkw
argument_list|(
name|SUCCEED
argument_list|)
condition|)
block|{
name|upto
argument_list|(
name|ceol
argument_list|,
literal|"SUCCEED"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
block|{
name|chckvtc
argument_list|(
name|Rep
argument_list|)
expr_stmt|;
name|resout
operator|=
name|Succ
expr_stmt|;
name|terminated
operator|=
name|Yes
expr_stmt|;
block|}
else|else
name|tx
operator|=
name|ceol
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
default|default:
return|return
name|No
return|;
block|}
block|}
end_function

begin_function
name|Hidden
name|bool
name|secret_com
parameter_list|()
block|{
switch|switch
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
condition|)
block|{
case|case
literal|'D'
case|:
if|if
condition|(
name|atkw
argument_list|(
literal|"DEBUG"
argument_list|)
condition|)
block|{
name|Nex
expr_stmt|;
name|bugs
operator|=
name|Yes
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
case|case
literal|'G'
case|:
if|if
condition|(
name|atkw
argument_list|(
literal|"GR"
argument_list|)
condition|)
block|{
name|Nex
expr_stmt|;
name|prgr
argument_list|()
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
case|case
literal|'N'
case|:
if|if
condition|(
name|atkw
argument_list|(
literal|"NO'DEBUG"
argument_list|)
condition|)
block|{
name|Nex
expr_stmt|;
name|bugs
operator|=
name|No
expr_stmt|;
return|return
name|Yes
return|;
block|}
elseif|else
if|if
condition|(
name|atkw
argument_list|(
literal|"NO'TRACE"
argument_list|)
condition|)
block|{
name|Nex
expr_stmt|;
name|tracing
operator|=
name|No
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
case|case
literal|'T'
case|:
if|if
condition|(
name|atkw
argument_list|(
literal|"TRACE"
argument_list|)
condition|)
block|{
name|Nex
expr_stmt|;
name|tracing
operator|=
name|Yes
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
default|default:
return|return
name|No
return|;
block|}
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|chckvtc
parameter_list|(
name|re
parameter_list|)
name|literal
name|re
decl_stmt|;
block|{
if|if
condition|(
name|cntxt
operator|!=
name|In_unit
operator|||
name|resexp
operator|==
name|Voi
condition|)
block|{
if|if
condition|(
name|re
operator|==
name|Ret
condition|)
name|pprerr
argument_list|(
literal|"RETURN e only allowed inside YIELD-unit or\n"
argument_list|,
literal|"    expression-refinement"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|re
operator|==
name|Rep
condition|)
name|pprerr
argument_list|(
literal|"REPORT t only allowed inside TEST-unit"
argument_list|,
literal|" or test-refinement"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|re
operator|!=
name|resexp
condition|)
block|{
if|if
condition|(
name|resexp
operator|==
name|Ret
condition|)
name|pprerr
argument_list|(
literal|"RETURN e must terminate YIELD-unit or expression-refinement"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|resexp
operator|==
name|Rep
condition|)
name|pprerr
argument_list|(
literal|"REPORT t must terminate TEST-unit or test-refinement"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Hidden
name|bool
name|expr_s
parameter_list|()
block|{
name|char
name|c
decl_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|>=
name|ceol
condition|)
return|return
name|No
return|;
name|c
operator|=
name|Char
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
name|Letter
argument_list|(
name|c
argument_list|)
operator|||
name|Montormark
argument_list|(
name|c
argument_list|)
operator|||
name|Dig
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'E'
operator|||
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|'{'
operator|||
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
return|;
block|}
end_function

begin_decl_stmt
name|intlet
name|comcnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|Visible
name|Procedure
name|command
parameter_list|()
block|{
if|if
condition|(
operator|++
name|comcnt
operator|>
literal|10000
condition|)
block|{
name|putprmnv
argument_list|()
expr_stmt|;
name|comcnt
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
name|Eotc
condition|)
name|getline
argument_list|()
expr_stmt|;
name|debug
argument_list|(
literal|"analyzing command"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracing
condition|)
name|trace
argument_list|()
expr_stmt|;
if|if
condition|(
name|Ceol
argument_list|(
name|tx
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|sim_com
argument_list|()
operator|||
name|con_com
argument_list|()
operator|||
name|unit
argument_list|()
operator|||
name|term_com
argument_list|()
operator|||
name|ref_com
argument_list|()
operator|||
name|udc
argument_list|()
operator|||
name|secret_com
argument_list|()
condition|)
name|skipping
operator|=
name|No
expr_stmt|;
elseif|else
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|':'
operator|||
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'='
operator|||
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
operator|!
name|interactive
condition|)
name|parerr
argument_list|(
literal|"special commands only interactively"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cntxt
operator|==
name|In_command
operator|&&
name|cur_ilev
operator|==
literal|0
operator|)
condition|)
name|parerr
argument_list|(
literal|"special commands only on outermost level (no indentation)"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|special
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cntxt
operator|==
name|In_command
operator|&&
name|cur_ilev
operator|==
literal|0
operator|&&
name|expr_s
argument_list|()
condition|)
block|{
name|value
name|w
init|=
name|expr
argument_list|(
name|ceol
argument_list|)
decl_stmt|;
name|wri
argument_list|(
name|w
argument_list|,
name|Yes
argument_list|,
name|No
argument_list|,
name|No
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|txptr
name|tx0
init|=
name|tx
decl_stmt|;
name|value
name|uc
init|=
name|keyword
argument_list|(
name|ceol
argument_list|)
decl_stmt|;
name|tx
operator|=
name|tx0
expr_stmt|;
name|parerr
argument_list|(
literal|"you have not told me HOW'TO "
argument_list|,
name|strval
argument_list|(
name|uc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|To_eol
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"command treated"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|comm_suite
parameter_list|()
block|{
name|intlet
name|cil
init|=
name|cur_ilev
decl_stmt|;
if|if
condition|(
name|ateol
argument_list|()
condition|)
block|{
name|txptr
name|tx0
init|=
name|tx
decl_stmt|;
name|bool
name|xeq0
init|=
name|xeq
decl_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
operator|+
literal|1
argument_list|)
operator|==
name|Eotc
condition|)
name|xeq
operator|=
name|No
expr_stmt|;
while|while
condition|(
name|ilev
argument_list|(
name|No
argument_list|)
operator|>
name|cil
condition|)
block|{
name|findceol
argument_list|()
expr_stmt|;
name|command
argument_list|()
expr_stmt|;
if|if
condition|(
name|terminated
condition|)
return|return;
if|if
condition|(
name|cur_ilev
operator|<=
name|cil
condition|)
goto|goto
name|brk1
goto|;
block|}
name|veli
argument_list|()
expr_stmt|;
name|brk1
label|:
if|if
condition|(
name|xeq0
operator|&&
operator|!
name|xeq
condition|)
block|{
name|tx
operator|=
name|tx0
expr_stmt|;
name|xeq
operator|=
name|Yes
expr_stmt|;
name|cur_ilev
operator|=
name|cil
expr_stmt|;
while|while
condition|(
name|ilev
argument_list|(
name|No
argument_list|)
operator|>
name|cil
condition|)
block|{
name|findceol
argument_list|()
expr_stmt|;
name|command
argument_list|()
expr_stmt|;
if|if
condition|(
name|terminated
condition|)
return|return;
if|if
condition|(
name|cur_ilev
operator|<=
name|cil
condition|)
goto|goto
name|brk2
goto|;
block|}
name|veli
argument_list|()
expr_stmt|;
name|brk2
label|:
empty_stmt|;
block|}
block|}
else|else
name|command
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|alt_suite
parameter_list|()
block|{
name|intlet
name|cil
init|=
name|cur_ilev
decl_stmt|;
name|env
name|e0
init|=
name|curnv
decl_stmt|;
name|txptr
name|utx
decl_stmt|,
name|vtx
decl_stmt|;
name|bool
name|xeq0
init|=
name|xeq
decl_stmt|,
name|succ
init|=
operator|!
name|xeq
decl_stmt|,
name|Else
init|=
name|No
decl_stmt|;
if|if
condition|(
operator|!
name|ateol
argument_list|()
condition|)
name|syserr
argument_list|(
literal|"alt_suite not at end of line"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ilev
argument_list|(
name|No
argument_list|)
operator|>
name|cil
condition|)
block|{
name|findceol
argument_list|()
expr_stmt|;
if|if
condition|(
name|Else
condition|)
name|parerr
argument_list|(
literal|"after ELSE: ... no more alternatives are allowed"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|req
argument_list|(
literal|":"
argument_list|,
name|ceol
argument_list|,
operator|&
name|utx
argument_list|,
operator|&
name|vtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|atkw
argument_list|(
name|ELSE
argument_list|)
condition|)
block|{
name|succ
operator|=
name|Else
operator|=
name|Yes
expr_stmt|;
name|upto
argument_list|(
name|utx
argument_list|,
literal|"ELSE"
argument_list|)
expr_stmt|;
name|tx
operator|=
name|vtx
expr_stmt|;
name|comm_suite
argument_list|()
expr_stmt|;
if|if
condition|(
name|terminated
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
name|xeq
condition|)
name|succ
operator|=
name|test
argument_list|(
name|utx
argument_list|)
operator|==
name|Succ
expr_stmt|;
name|xeq
operator|=
name|xeq
operator|&&
name|succ
expr_stmt|;
name|tx
operator|=
name|vtx
expr_stmt|;
name|comm_suite
argument_list|()
expr_stmt|;
if|if
condition|(
name|terminated
condition|)
return|return;
name|xeq
operator|=
operator|!
name|succ
expr_stmt|;
block|}
if|if
condition|(
name|cur_ilev
operator|<=
name|cil
condition|)
goto|goto
name|brk
goto|;
block|}
name|veli
argument_list|()
expr_stmt|;
name|brk
label|:
if|if
condition|(
operator|!
name|succ
condition|)
name|error
argument_list|(
literal|"none of the alternative tests of SELECT succeeds"
argument_list|)
expr_stmt|;
name|xeq
operator|=
name|xeq0
expr_stmt|;
if|if
condition|(
name|xeq
condition|)
name|restore_env
argument_list|(
name|e0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

