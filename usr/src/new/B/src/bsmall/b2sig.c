begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_comment
comment|/* $Header: b2sig.c,v 1.1 84/06/28 00:49:19 timo Exp $ */
end_comment

begin_comment
comment|/*Handle interrupts and signals*/
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_include
include|#
directive|include
file|"b2scr.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"b2err.h"
end_include

begin_include
include|#
directive|include
file|"b2env.h"
end_include

begin_comment
comment|/*The operating system provides a function signal(s,f)   that associates function f with the signal s, and returns   a pointer to the previous function associated with s.   Then, when signal s occurs, f is called and the function associated with s   may or may not be reset. Thus f may need to call signal(s,f) again to.   The code here doesn't depend on either interpretation, always being explicit   about which handler to use.    There are two signals that can come from the user: quit and interrupt.   Interrupt should just stop the interpreter and return to B command level;   quit should stop the B system completely and produce a dump.   All other signals are caused by errors (eg memory exhausted)   or come from outside the program, and are therefore fatal.    SIG_IGN is the system supplied routine to ignore a signal.   SIG_DFL is the system supplied default for a signal.   kill(getpid(), signal) kills the program according to 'signal' */
end_comment

begin_function
name|Visible
name|Procedure
name|dump
parameter_list|()
block|{
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGQUIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|oops
parameter_list|(
name|sig
parameter_list|,
name|m
parameter_list|)
name|int
name|sig
decl_stmt|;
name|string
name|m
decl_stmt|;
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"*** Oops, %s\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|cntxt
operator|!=
name|In_prmnv
condition|)
name|putprmnv
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|burp
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|oops
argument_list|(
name|sig
argument_list|,
literal|"I feel suddenly (BURP!) indisposed. I'll call it a day. Sorry."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|aog
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|oops
argument_list|(
name|sig
argument_list|,
literal|"an act of God has occurred compelling me to discontinue service."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|fpe_signal
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|signal
argument_list|(
name|sig
comment|/* == SIGFPE*/
argument_list|,
name|fpe_signal
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"arithmetic overflow"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|intsig
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
comment|/*sig==SIGINT*/
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|int_signal
argument_list|(
name|No
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|accept_int
parameter_list|()
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
argument_list|(
operator|*
name|si
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|sq
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|sawi
init|=
name|No
decl_stmt|,
name|sawq
init|=
name|No
decl_stmt|;
end_decl_stmt

begin_function
name|Hidden
name|Procedure
name|signote
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
comment|/*Note but otherwise ignore a quit or interrupt*/
name|signal
argument_list|(
name|sig
argument_list|,
name|signote
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Just a moment\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|==
name|SIGINT
condition|)
name|sawi
operator|=
name|Yes
expr_stmt|;
elseif|else
if|if
condition|(
name|sig
operator|==
name|SIGQUIT
condition|)
name|sawq
operator|=
name|Yes
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|Hidden
name|int
argument_list|(
operator|*
name|setsig
argument_list|(
name|sig
argument_list|,
name|func
argument_list|)
argument_list|)
argument_list|()
name|int
name|sig
decl_stmt|,
argument_list|(
operator|*
name|func
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*Set a signal, unless it's being ignored*/
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
init|=
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_IGN
argument_list|)
function_decl|;
if|if
condition|(
name|f
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|sig
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_block

begin_function
name|Visible
name|Procedure
name|ignsigs
parameter_list|()
block|{
comment|/*Henceforth only note quits and interrupts*/
name|si
operator|=
name|setsig
argument_list|(
name|filtered
condition|?
name|SIGTRAP
else|:
name|SIGINT
argument_list|,
name|signote
argument_list|)
expr_stmt|;
name|sq
operator|=
name|setsig
argument_list|(
name|SIGQUIT
argument_list|,
name|signote
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|re_sigs
parameter_list|()
block|{
comment|/*Start processing quits and interrupts again*/
name|signal
argument_list|(
name|filtered
condition|?
name|SIGTRAP
else|:
name|SIGINT
argument_list|,
name|si
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|sq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sawi
condition|)
block|{
name|sawi
operator|=
name|sawq
operator|=
name|No
expr_stmt|;
if|if
condition|(
name|si
operator|!=
name|SIG_IGN
operator|&&
name|si
operator|!=
name|SIG_DFL
condition|)
call|(
modifier|*
name|si
call|)
argument_list|(
name|filtered
condition|?
name|SIGTRAP
else|:
name|SIGINT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sawq
condition|)
block|{
name|sawq
operator|=
name|No
expr_stmt|;
if|if
condition|(
name|sq
operator|!=
name|SIG_IGN
operator|&&
name|sq
operator|!=
name|SIG_DFL
condition|)
call|(
modifier|*
name|sq
call|)
argument_list|(
name|SIGQUIT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Visible
name|Procedure
name|inisigs
parameter_list|()
block|{
if|if
condition|(
name|filtered
condition|)
block|{
name|VOID
name|setsig
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
name|VOID
name|setsig
argument_list|(
name|SIGTRAP
argument_list|,
name|intsig
argument_list|)
decl_stmt|;
block|}
else|else
block|{
name|VOID
name|setsig
argument_list|(
name|SIGINT
argument_list|,
name|intsig
argument_list|)
decl_stmt|;
name|VOID
name|setsig
argument_list|(
name|SIGTRAP
argument_list|,
name|burp
argument_list|)
decl_stmt|;
block|}
name|VOID
name|setsig
argument_list|(
name|SIGQUIT
argument_list|,
name|aog
argument_list|)
decl_stmt|;
name|VOID
name|setsig
argument_list|(
name|SIGILL
argument_list|,
name|burp
argument_list|)
decl_stmt|;
name|VOID
name|setsig
argument_list|(
name|SIGIOT
argument_list|,
name|burp
argument_list|)
decl_stmt|;
name|VOID
name|setsig
argument_list|(
name|SIGEMT
argument_list|,
name|burp
argument_list|)
decl_stmt|;
name|VOID
name|setsig
argument_list|(
name|SIGFPE
argument_list|,
name|fpe_signal
argument_list|)
decl_stmt|;
name|VOID
name|setsig
argument_list|(
name|SIGBUS
argument_list|,
name|burp
argument_list|)
decl_stmt|;
name|VOID
name|setsig
argument_list|(
name|SIGSEGV
argument_list|,
name|burp
argument_list|)
decl_stmt|;
name|VOID
name|setsig
argument_list|(
name|SIGSYS
argument_list|,
name|burp
argument_list|)
decl_stmt|;
name|VOID
name|setsig
argument_list|(
name|SIGPIPE
argument_list|,
name|aog
argument_list|)
decl_stmt|;
name|VOID
name|setsig
argument_list|(
name|SIGALRM
argument_list|,
name|burp
argument_list|)
decl_stmt|;
name|VOID
name|setsig
argument_list|(
name|SIGTERM
argument_list|,
name|burp
argument_list|)
decl_stmt|;
block|}
end_function

end_unit

