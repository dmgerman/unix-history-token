begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_comment
comment|/* $Header: B1fun.c,v 1.1 84/06/28 00:48:54 timo Exp $ */
end_comment

begin_comment
comment|/* B functions */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b2sem.h"
end_include

begin_include
include|#
directive|include
file|"B1num.h"
end_include

begin_define
define|#
directive|define
name|Maxlen
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(Length(x)> Length(y) ? Length(x) : Length(y))
end_define

begin_define
define|#
directive|define
name|Sumlen
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(Length(x) + Length(y))
end_define

begin_function
name|value
name|sum
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|register
name|value
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|value
name|r
decl_stmt|,
name|z
decl_stmt|;
name|Checknum
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|Checknum
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Exact
argument_list|(
name|x
argument_list|)
operator|||
operator|!
name|Exact
argument_list|(
name|y
argument_list|)
condition|)
return|return
name|mk_approx
argument_list|(
name|Numval
argument_list|(
name|x
argument_list|)
operator|+
name|Numval
argument_list|(
name|y
argument_list|)
argument_list|)
return|;
name|z
operator|=
name|mk_exact
argument_list|(
name|Denominator
argument_list|(
name|x
argument_list|)
argument_list|,
name|Denominator
argument_list|(
name|y
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|mk_exact
argument_list|(
name|Numerator
argument_list|(
name|x
argument_list|)
operator|*
name|Denominator
argument_list|(
name|z
argument_list|)
operator|+
name|Numerator
argument_list|(
name|y
argument_list|)
operator|*
name|Numerator
argument_list|(
name|z
argument_list|)
argument_list|,
name|Denominator
argument_list|(
name|x
argument_list|)
operator|*
name|Denominator
argument_list|(
name|z
argument_list|)
argument_list|,
name|Maxlen
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|z
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|value
name|negated
parameter_list|(
name|x
parameter_list|)
specifier|register
name|value
name|x
decl_stmt|;
block|{
name|Checknum
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Exact
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|mk_approx
argument_list|(
operator|-
name|Numval
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
return|return
name|mk_exact
argument_list|(
operator|-
name|Numerator
argument_list|(
name|x
argument_list|)
argument_list|,
name|Denominator
argument_list|(
name|x
argument_list|)
argument_list|,
name|Length
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|diff
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|register
name|value
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|value
name|r
decl_stmt|,
name|my
decl_stmt|;
name|r
operator|=
name|sum
argument_list|(
name|x
argument_list|,
name|my
operator|=
name|negated
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|my
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|value
name|inverse
parameter_list|(
name|x
parameter_list|)
name|value
name|x
decl_stmt|;
block|{
name|Checknum
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|Numval
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"in x/y, y is zero"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Exact
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|mk_approx
argument_list|(
literal|1.0
operator|/
name|Numval
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
return|return
name|mk_exact
argument_list|(
name|Denominator
argument_list|(
name|x
argument_list|)
argument_list|,
name|Numerator
argument_list|(
name|x
argument_list|)
argument_list|,
name|Length
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|prod
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|register
name|value
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|value
name|a
decl_stmt|,
name|b
decl_stmt|,
name|r
decl_stmt|;
name|Checknum
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|Checknum
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Exact
argument_list|(
name|x
argument_list|)
operator|||
operator|!
name|Exact
argument_list|(
name|y
argument_list|)
condition|)
return|return
name|mk_approx
argument_list|(
name|Numval
argument_list|(
name|x
argument_list|)
operator|*
name|Numval
argument_list|(
name|y
argument_list|)
argument_list|)
return|;
name|a
operator|=
name|mk_exact
argument_list|(
name|Numerator
argument_list|(
name|x
argument_list|)
argument_list|,
name|Denominator
argument_list|(
name|y
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|b
operator|=
name|mk_exact
argument_list|(
name|Numerator
argument_list|(
name|y
argument_list|)
argument_list|,
name|Denominator
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|mk_exact
argument_list|(
name|Numerator
argument_list|(
name|a
argument_list|)
operator|*
name|Numerator
argument_list|(
name|b
argument_list|)
argument_list|,
name|Denominator
argument_list|(
name|a
argument_list|)
operator|*
name|Denominator
argument_list|(
name|b
argument_list|)
argument_list|,
name|Sumlen
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|value
name|quot
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|register
name|value
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|value
name|r
decl_stmt|,
name|iy
decl_stmt|;
name|r
operator|=
name|prod
argument_list|(
name|x
argument_list|,
name|iy
operator|=
name|inverse
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|iy
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_define
define|#
directive|define
name|Even
parameter_list|(
name|x
parameter_list|)
value|((x) == Two*floor((x)/Two))
end_define

begin_function
name|value
name|power
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
specifier|register
name|value
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|Checknum
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|Checknum
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|Exact
argument_list|(
name|y
argument_list|)
condition|)
block|{
name|integer
name|py
init|=
name|Numerator
argument_list|(
name|y
argument_list|)
decl_stmt|,
name|qy
init|=
name|Denominator
argument_list|(
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|Integral
argument_list|(
name|y
argument_list|)
operator|&&
name|Exact
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|integer
name|px
decl_stmt|,
name|qx
decl_stmt|,
name|ppx
decl_stmt|,
name|pqx
decl_stmt|,
name|Ppx
decl_stmt|,
name|Pqx
decl_stmt|;
if|if
condition|(
name|py
operator|==
name|Zero
condition|)
return|return
name|mk_int
argument_list|(
name|One
argument_list|)
return|;
if|if
condition|(
name|py
operator|>
name|Zero
condition|)
block|{
name|px
operator|=
name|Numerator
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|qx
operator|=
name|Denominator
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|py
operator|=
operator|-
name|py
expr_stmt|;
name|px
operator|=
name|Denominator
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|qx
operator|=
name|Numerator
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|ppx
operator|=
name|pqx
operator|=
name|One
expr_stmt|;
name|Ppx
operator|=
name|px
expr_stmt|;
name|Pqx
operator|=
name|qx
expr_stmt|;
while|while
condition|(
name|py
operator|>=
name|Two
condition|)
block|{
if|if
condition|(
operator|!
name|Even
argument_list|(
name|py
argument_list|)
condition|)
block|{
name|ppx
operator|*=
name|Ppx
expr_stmt|;
name|pqx
operator|*=
name|Pqx
expr_stmt|;
block|}
name|Ppx
operator|*=
name|Ppx
expr_stmt|;
name|Pqx
operator|*=
name|Pqx
expr_stmt|;
name|py
operator|=
name|floor
argument_list|(
name|py
operator|/
name|Two
argument_list|)
expr_stmt|;
block|}
name|ppx
operator|*=
name|Ppx
expr_stmt|;
name|pqx
operator|*=
name|Pqx
expr_stmt|;
return|return
name|mk_exact
argument_list|(
name|ppx
argument_list|,
name|pqx
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/* END Integral(y)&& Exact(x) */
else|else
block|{
name|double
name|vx
init|=
name|Numval
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|short
name|sx
init|=
name|vx
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
name|vx
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
decl_stmt|;
if|if
condition|(
name|sx
operator|<
literal|0
operator|&&
name|Even
argument_list|(
name|qy
argument_list|)
condition|)
name|error
argument_list|(
literal|"in x**(p/q), x is negative and q is even"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx
operator|==
literal|0
operator|&&
name|py
operator|<
name|Zero
condition|)
name|error
argument_list|(
literal|"0**y with negative y"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx
operator|<
literal|0
operator|&&
name|Even
argument_list|(
name|py
argument_list|)
condition|)
name|sx
operator|=
literal|1
expr_stmt|;
return|return
name|mk_approx
argument_list|(
name|sx
operator|*
name|pow
argument_list|(
name|fabs
argument_list|(
name|vx
argument_list|)
argument_list|,
name|py
operator|/
name|qy
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* END Exact(y) */
else|else
block|{
name|double
name|vx
init|=
name|Numval
argument_list|(
name|x
argument_list|)
decl_stmt|,
name|vy
init|=
name|Approxval
argument_list|(
name|y
argument_list|)
decl_stmt|;
if|if
condition|(
name|vy
operator|==
literal|0
condition|)
return|return
name|mk_approx
argument_list|(
literal|1.0
argument_list|)
return|;
if|if
condition|(
name|vx
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"in x**y, x is negative and y is not exact"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vx
operator|==
literal|0
operator|&&
name|vy
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"0E0**y with negative y"
argument_list|)
expr_stmt|;
return|return
name|mk_approx
argument_list|(
name|pow
argument_list|(
name|vx
argument_list|,
name|vy
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|value
name|root2
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
specifier|register
name|value
name|n
decl_stmt|,
name|x
decl_stmt|;
block|{
name|value
name|r
decl_stmt|,
name|in
decl_stmt|;
name|Checknum
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|Numval
argument_list|(
name|n
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"in x root y, x is zero"
argument_list|)
expr_stmt|;
name|r
operator|=
name|power
argument_list|(
name|x
argument_list|,
name|in
operator|=
name|inverse
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|value
name|absval
parameter_list|(
name|x
parameter_list|)
specifier|register
name|value
name|x
decl_stmt|;
block|{
name|Checknum
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Exact
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|mk_approx
argument_list|(
name|fabs
argument_list|(
name|Numval
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|mk_exact
argument_list|(
operator|(
name|integer
operator|)
name|fabs
argument_list|(
operator|(
name|double
operator|)
name|Numerator
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|Denominator
argument_list|(
name|x
argument_list|)
argument_list|,
name|Length
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|signum
parameter_list|(
name|x
parameter_list|)
specifier|register
name|value
name|x
decl_stmt|;
block|{
name|double
name|v
init|=
name|numval
argument_list|(
name|x
argument_list|)
decl_stmt|;
return|return
name|mk_int
argument_list|(
name|v
operator|<
literal|0
condition|?
operator|-
name|One
else|:
name|v
operator|==
literal|0
condition|?
name|Zero
else|:
name|One
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|floorf
parameter_list|(
name|x
parameter_list|)
specifier|register
name|value
name|x
decl_stmt|;
block|{
return|return
name|mk_int
argument_list|(
name|floor
argument_list|(
name|numval
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|ceilf
parameter_list|(
name|x
parameter_list|)
specifier|register
name|value
name|x
decl_stmt|;
block|{
return|return
name|mk_int
argument_list|(
name|ceil
argument_list|(
name|numval
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|round1
parameter_list|(
name|x
parameter_list|)
specifier|register
name|value
name|x
decl_stmt|;
block|{
return|return
name|mk_int
argument_list|(
name|floor
argument_list|(
name|numval
argument_list|(
name|x
argument_list|)
operator|+
literal|.5
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|round2
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
specifier|register
name|value
name|n
decl_stmt|,
name|x
decl_stmt|;
block|{
name|value
name|ten
decl_stmt|,
name|tenp
decl_stmt|,
name|xtenp
decl_stmt|,
name|r0
decl_stmt|,
name|r
decl_stmt|;
name|Checknum
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Integral
argument_list|(
name|n
argument_list|)
condition|)
name|error
argument_list|(
literal|"in n round x, n is not an integer"
argument_list|)
expr_stmt|;
name|ten
operator|=
name|mk_integer
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|tenp
operator|=
name|power
argument_list|(
name|ten
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|xtenp
operator|=
name|prod
argument_list|(
name|x
argument_list|,
name|tenp
argument_list|)
expr_stmt|;
name|r0
operator|=
name|round1
argument_list|(
name|xtenp
argument_list|)
expr_stmt|;
name|r
operator|=
name|mk_exact
argument_list|(
name|Numerator
argument_list|(
name|r0
argument_list|)
argument_list|,
name|Numerator
argument_list|(
name|tenp
argument_list|)
argument_list|,
name|propintlet
argument_list|(
operator|(
name|int
operator|)
name|Numerator
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|ten
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|tenp
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|xtenp
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|r0
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|value
name|mod
parameter_list|(
name|a
parameter_list|,
name|n
parameter_list|)
specifier|register
name|value
name|a
decl_stmt|,
name|n
decl_stmt|;
block|{
name|value
name|f
decl_stmt|,
name|p
decl_stmt|,
name|d
decl_stmt|;
name|Checknum
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|Checknum
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|f
operator|=
name|mk_int
argument_list|(
name|floor
argument_list|(
name|Numval
argument_list|(
name|a
argument_list|)
operator|/
name|Numval
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|prod
argument_list|(
name|n
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|d
operator|=
name|diff
argument_list|(
name|a
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_decl_stmt
name|double
name|lastran
decl_stmt|;
end_decl_stmt

begin_macro
name|setran
argument_list|(
argument|seed
argument_list|)
end_macro

begin_decl_stmt
name|double
name|seed
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|x
decl_stmt|;
name|x
operator|=
name|seed
operator|>=
literal|0
condition|?
name|seed
else|:
operator|-
name|seed
expr_stmt|;
while|while
condition|(
name|x
operator|>=
literal|1
condition|)
name|x
operator|/=
literal|10
expr_stmt|;
name|lastran
operator|=
name|floor
argument_list|(
literal|67108864.0
operator|*
name|x
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|set_random
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|value
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|setran
argument_list|(
operator|(
name|double
operator|)
name|hash
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|value
name|random
parameter_list|()
comment|/* 0<= r< 1 */
block|{
name|double
name|p
decl_stmt|;
name|p
operator|=
literal|26353589.0
operator|*
name|lastran
operator|+
literal|1
expr_stmt|;
name|lastran
operator|=
name|p
operator|-
literal|67108864.0
operator|*
name|floor
argument_list|(
name|p
operator|/
literal|67108864.0
argument_list|)
expr_stmt|;
return|return
name|mk_approx
argument_list|(
name|lastran
operator|/
literal|67108864.0
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|root1
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
name|value
name|two
init|=
name|mk_integer
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|v
operator|=
name|root2
argument_list|(
name|two
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|two
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_function
name|value
name|pi
parameter_list|()
block|{
return|return
name|mk_approx
argument_list|(
literal|3.141592653589793238462
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|e
parameter_list|()
block|{
return|return
name|mk_approx
argument_list|(
name|exp
argument_list|(
literal|1.0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|sin1
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
return|return
name|mk_approx
argument_list|(
name|sin
argument_list|(
name|numval
argument_list|(
name|v
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|cos1
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
return|return
name|mk_approx
argument_list|(
name|cos
argument_list|(
name|numval
argument_list|(
name|v
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|tan1
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
return|return
name|mk_approx
argument_list|(
name|tan
argument_list|(
name|numval
argument_list|(
name|v
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|atn1
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
return|return
name|mk_approx
argument_list|(
name|atan
argument_list|(
name|numval
argument_list|(
name|v
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|exp1
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
return|return
name|mk_approx
argument_list|(
name|exp
argument_list|(
name|numval
argument_list|(
name|v
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|log1
parameter_list|(
name|v
parameter_list|)
name|value
name|v
decl_stmt|;
block|{
return|return
name|mk_approx
argument_list|(
name|log
argument_list|(
name|numval
argument_list|(
name|v
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|log2
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|value
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
return|return
name|mk_approx
argument_list|(
name|log
argument_list|(
name|numval
argument_list|(
name|v
argument_list|)
argument_list|)
operator|/
name|log
argument_list|(
name|numval
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|atn2
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|)
name|value
name|u
decl_stmt|,
name|v
decl_stmt|;
block|{
return|return
name|mk_approx
argument_list|(
name|atan2
argument_list|(
name|numval
argument_list|(
name|v
argument_list|)
argument_list|,
name|numval
argument_list|(
name|u
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

end_unit

