begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_comment
comment|/* $Header: b2tes.c,v 1.2 84/07/05 15:01:46 timo Exp $ */
end_comment

begin_comment
comment|/* B test testing */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b2key.h"
end_include

begin_include
include|#
directive|include
file|"b2env.h"
end_include

begin_include
include|#
directive|include
file|"b2syn.h"
end_include

begin_include
include|#
directive|include
file|"b2sem.h"
end_include

begin_define
define|#
directive|define
name|Tnil
value|((string) 0)
end_define

begin_decl_stmt
name|Forward
name|outcome
name|ttest
argument_list|()
decl_stmt|,
name|stest
argument_list|()
decl_stmt|,
name|comparison
argument_list|()
decl_stmt|,
name|quant
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|Visible
name|outcome
name|test
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
return|return
name|ttest
argument_list|(
name|q
argument_list|,
name|Tnil
argument_list|)
return|;
block|}
end_function

begin_function
name|Hidden
name|outcome
name|ttest
parameter_list|(
name|q
parameter_list|,
name|ti
parameter_list|)
name|txptr
name|q
decl_stmt|;
name|string
name|ti
decl_stmt|;
block|{
name|txptr
name|fa
decl_stmt|,
name|ta
decl_stmt|,
name|fo
decl_stmt|,
name|to
decl_stmt|;
name|bool
name|a
init|=
name|find
argument_list|(
name|AND
argument_list|,
name|q
argument_list|,
operator|&
name|fa
argument_list|,
operator|&
name|ta
argument_list|)
decl_stmt|,
name|o
init|=
name|find
argument_list|(
name|OR
argument_list|,
name|q
argument_list|,
operator|&
name|fo
argument_list|,
operator|&
name|to
argument_list|)
decl_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|!=
name|Tnil
operator|&&
operator|(
name|a
operator|||
name|o
operator|)
condition|)
name|pprerr
argument_list|(
literal|"use ( and ) to make AND and/or OR unambiguous after "
argument_list|,
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|&&
name|o
condition|)
name|parerr
argument_list|(
literal|"AND and OR intermixed, use ( and )"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|atkw
argument_list|(
name|NOT
argument_list|)
condition|)
return|return
operator|!
name|ttest
argument_list|(
name|q
argument_list|,
literal|"NOT"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|atkw
argument_list|(
name|SOME
argument_list|)
condition|)
return|return
name|quant
argument_list|(
name|q
argument_list|,
name|No
argument_list|,
name|No
argument_list|,
literal|"SOME"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|atkw
argument_list|(
name|EACH
argument_list|)
condition|)
return|return
name|quant
argument_list|(
name|q
argument_list|,
name|Yes
argument_list|,
name|Yes
argument_list|,
literal|"EACH"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|atkw
argument_list|(
name|NO
argument_list|)
condition|)
return|return
name|quant
argument_list|(
name|q
argument_list|,
name|Yes
argument_list|,
name|No
argument_list|,
literal|"NO"
argument_list|)
return|;
elseif|else
if|if
condition|(
name|a
condition|)
block|{
name|testa
label|:
if|if
condition|(
operator|!
name|stest
argument_list|(
name|fa
argument_list|)
condition|)
return|return
name|No
return|;
name|tx
operator|=
name|ta
expr_stmt|;
if|if
condition|(
name|find
argument_list|(
name|AND
argument_list|,
name|q
argument_list|,
operator|&
name|fa
argument_list|,
operator|&
name|ta
argument_list|)
condition|)
goto|goto
name|testa
goto|;
return|return
name|ttest
argument_list|(
name|q
argument_list|,
name|Tnil
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|o
condition|)
block|{
name|testo
label|:
if|if
condition|(
name|stest
argument_list|(
name|fo
argument_list|)
condition|)
return|return
name|Yes
return|;
name|tx
operator|=
name|to
expr_stmt|;
if|if
condition|(
name|find
argument_list|(
name|AND
argument_list|,
name|q
argument_list|,
operator|&
name|fo
argument_list|,
operator|&
name|to
argument_list|)
condition|)
goto|goto
name|testo
goto|;
return|return
name|ttest
argument_list|(
name|q
argument_list|,
name|Tnil
argument_list|)
return|;
block|}
return|return
name|stest
argument_list|(
name|q
argument_list|)
return|;
block|}
end_function

begin_function
name|Hidden
name|outcome
name|stest
parameter_list|(
name|q
parameter_list|)
name|txptr
name|q
decl_stmt|;
block|{
name|bool
name|o
decl_stmt|,
name|lt
decl_stmt|,
name|eq
decl_stmt|,
name|gt
decl_stmt|;
name|txptr
name|tx0
decl_stmt|;
name|value
name|v
decl_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|tx0
operator|=
name|tx
expr_stmt|;
name|nothing
argument_list|(
name|q
argument_list|,
literal|"test"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'('
condition|)
block|{
name|txptr
name|tx1
init|=
operator|++
name|tx
decl_stmt|,
name|f
decl_stmt|,
name|t
decl_stmt|;
name|req
argument_list|(
literal|")"
argument_list|,
name|q
argument_list|,
operator|&
name|f
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|tx
operator|=
name|t
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|<
name|q
condition|)
block|{
name|tx
operator|=
name|tx0
expr_stmt|;
goto|goto
name|exex
goto|;
block|}
name|tx
operator|=
name|tx1
expr_stmt|;
name|o
operator|=
name|test
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|tx
operator|=
name|t
expr_stmt|;
return|return
name|o
return|;
block|}
if|if
condition|(
name|Letter
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
name|value
name|t
init|=
name|tag
argument_list|()
decl_stmt|;
name|prd
name|p
decl_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|==
name|q
condition|)
comment|/* test consists of tag */
block|{
name|value
modifier|*
name|aa
init|=
name|lookup
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|aa
operator|!=
name|Pnil
operator|&&
name|Is_refinement
argument_list|(
operator|*
name|aa
argument_list|)
condition|)
block|{
name|release
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ref_et
argument_list|(
operator|*
name|aa
argument_list|,
name|Rep
argument_list|)
expr_stmt|;
name|o
operator|=
name|resout
expr_stmt|;
name|resout
operator|=
name|Und
expr_stmt|;
return|return
name|o
return|;
block|}
elseif|else
if|if
condition|(
name|is_zerprd
argument_list|(
name|t
argument_list|,
operator|&
name|p
argument_list|)
condition|)
block|{
name|release
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|upto
argument_list|(
name|q
argument_list|,
literal|"zeroadic test"
argument_list|)
expr_stmt|;
return|return
name|proposition
argument_list|(
name|Vnil
argument_list|,
name|p
argument_list|,
name|Vnil
argument_list|)
return|;
block|}
else|else
name|pprerr
argument_list|(
literal|"tag is neither refined-test nor zeroadic-predicate"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_monprd
argument_list|(
name|t
argument_list|,
operator|&
name|p
argument_list|)
condition|)
block|{
name|release
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|obasexpr
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|upto
argument_list|(
name|q
argument_list|,
literal|"monadic test"
argument_list|)
expr_stmt|;
name|o
operator|=
name|proposition
argument_list|(
name|Vnil
argument_list|,
name|p
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
name|release
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tx
operator|=
name|tx0
expr_stmt|;
block|}
name|exex
label|:
name|v
operator|=
name|obasexpr
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|relop
argument_list|(
operator|&
name|lt
argument_list|,
operator|&
name|eq
argument_list|,
operator|&
name|gt
argument_list|)
condition|)
block|{
name|value
name|w
decl_stmt|;
name|nextv
label|:
name|w
operator|=
name|obasexpr
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|comparison
argument_list|(
name|v
argument_list|,
name|w
argument_list|,
name|lt
argument_list|,
name|eq
argument_list|,
name|gt
argument_list|)
condition|)
block|{
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
name|No
return|;
block|}
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|w
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|relop
argument_list|(
operator|&
name|lt
argument_list|,
operator|&
name|eq
argument_list|,
operator|&
name|gt
argument_list|)
condition|)
goto|goto
name|nextv
goto|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|upto
argument_list|(
name|q
argument_list|,
literal|"comparison"
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
if|if
condition|(
name|Letter
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
name|value
name|t
init|=
name|tag
argument_list|()
decl_stmt|;
name|prd
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|is_dyaprd
argument_list|(
name|t
argument_list|,
operator|&
name|p
argument_list|)
condition|)
name|pprerr
argument_list|(
literal|"tag following expression is not a predicate"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|obasexpr
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|upto
argument_list|(
name|q
argument_list|,
literal|"dyadic test"
argument_list|)
expr_stmt|;
name|o
operator|=
name|proposition
argument_list|(
name|v
argument_list|,
name|p
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
name|parerr
argument_list|(
literal|"something unexpected following expression in test"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|bool
operator|)
name|Dummy
return|;
block|}
end_function

begin_function
name|Visible
name|bool
name|relop
parameter_list|(
name|lt
parameter_list|,
name|eq
parameter_list|,
name|gt
parameter_list|)
name|bool
modifier|*
name|lt
decl_stmt|,
decl|*
name|eq
decl_stmt|,
modifier|*
name|gt
decl_stmt|;
end_function

begin_block
block|{
name|txptr
name|tx0
init|=
name|tx
decl_stmt|;
operator|*
name|lt
operator|=
operator|*
name|eq
operator|=
operator|*
name|gt
operator|=
name|No
expr_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Char
argument_list|(
name|tx
operator|++
argument_list|)
condition|)
block|{
case|case
literal|'<'
case|:
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'<'
condition|)
break|break;
operator|*
name|lt
operator|=
name|Yes
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'='
condition|)
block|{
name|tx
operator|++
expr_stmt|;
operator|*
name|eq
operator|=
name|Yes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'>'
condition|)
block|{
name|tx
operator|++
expr_stmt|;
operator|*
name|gt
operator|=
name|Yes
expr_stmt|;
block|}
break|break;
case|case
literal|'='
case|:
operator|*
name|eq
operator|=
name|Yes
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'<'
operator|||
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'>'
condition|)
break|break;
operator|*
name|gt
operator|=
name|Yes
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'='
condition|)
block|{
name|tx
operator|++
expr_stmt|;
operator|*
name|eq
operator|=
name|Yes
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|*
name|lt
operator|||
operator|*
name|eq
operator|||
operator|*
name|gt
condition|)
return|return
name|Yes
return|;
name|tx
operator|=
name|tx0
expr_stmt|;
return|return
name|No
return|;
block|}
end_block

begin_function
name|Visible
name|outcome
name|comparison
parameter_list|(
name|v
parameter_list|,
name|w
parameter_list|,
name|lt
parameter_list|,
name|eq
parameter_list|,
name|gt
parameter_list|)
name|value
name|v
decl_stmt|,
name|w
decl_stmt|;
name|bool
name|lt
decl_stmt|,
name|eq
decl_stmt|,
name|gt
decl_stmt|;
block|{
name|relation
name|c
init|=
name|compare
argument_list|(
name|v
argument_list|,
name|w
argument_list|)
decl_stmt|;
return|return
name|c
operator|<
literal|0
condition|?
name|lt
else|:
name|c
operator|==
literal|0
condition|?
name|eq
else|:
name|gt
return|;
block|}
end_function

begin_function
name|Hidden
name|outcome
name|quant
parameter_list|(
name|q
parameter_list|,
name|all
parameter_list|,
name|each
parameter_list|,
name|qt
parameter_list|)
name|txptr
name|q
decl_stmt|;
name|bool
name|all
decl_stmt|,
name|each
decl_stmt|;
name|string
name|qt
decl_stmt|;
block|{
comment|/* it is assumed that xeq == Yes */
name|env
name|e0
init|=
name|curnv
decl_stmt|;
name|bool
name|in
init|=
name|No
decl_stmt|,
name|par
init|=
name|No
decl_stmt|,
name|go_on
init|=
name|Yes
decl_stmt|;
name|loc
name|l
decl_stmt|;
name|value
name|v
decl_stmt|,
name|w
decl_stmt|;
name|txptr
name|ftx
decl_stmt|,
name|ttx
decl_stmt|,
name|utx
decl_stmt|,
name|vtx
decl_stmt|;
name|reqkw
argument_list|(
name|HAS
argument_list|,
operator|&
name|utx
argument_list|,
operator|&
name|vtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtx
operator|>
name|q
condition|)
name|parerr
argument_list|(
literal|"HAS follows colon"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* as in: SOME i IN x: SHOW i HAS a */
if|if
condition|(
name|find
argument_list|(
name|IN_quant
argument_list|,
name|vtx
argument_list|,
operator|&
name|ftx
argument_list|,
operator|&
name|ttx
argument_list|)
condition|)
name|in
operator|=
name|Yes
expr_stmt|;
if|if
condition|(
name|find
argument_list|(
name|PARSING
argument_list|,
name|vtx
argument_list|,
operator|&
name|ftx
argument_list|,
operator|&
name|ttx
argument_list|)
condition|)
name|par
operator|=
name|Yes
expr_stmt|;
if|if
condition|(
operator|!
name|in
operator|&&
operator|!
name|par
condition|)
name|parerr
argument_list|(
literal|"neither IN nor PARSING found"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|&&
name|par
condition|)
name|parerr
argument_list|(
literal|"you're kidding; both IN and PARSING"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|l
operator|=
name|targ
argument_list|(
name|ftx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Is_simploc
argument_list|(
name|l
argument_list|)
operator|&&
operator|!
name|par
operator|||
name|Is_compound
argument_list|(
name|l
argument_list|)
operator|)
condition|)
name|pprerr
argument_list|(
literal|"inappropriate identifier after "
argument_list|,
name|qt
argument_list|)
expr_stmt|;
name|bind
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|tx
operator|=
name|ttx
expr_stmt|;
name|v
operator|=
name|expr
argument_list|(
name|utx
argument_list|)
expr_stmt|;
if|if
condition|(
name|par
condition|)
block|{
if|if
condition|(
operator|!
name|Is_text
argument_list|(
name|v
argument_list|)
condition|)
name|error
argument_list|(
literal|"in i1, ... , in PARSING t, t is not a text"
argument_list|)
expr_stmt|;
name|part
argument_list|(
name|Length
argument_list|(
name|l
argument_list|)
argument_list|,
name|l
argument_list|,
literal|0
argument_list|,
name|v
argument_list|,
literal|0
argument_list|,
name|utx
argument_list|,
name|vtx
argument_list|,
operator|&
name|go_on
argument_list|,
name|each
argument_list|,
name|q
argument_list|,
name|qt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
name|k
decl_stmt|,
name|k1
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|Is_tlt
argument_list|(
name|v
argument_list|)
condition|)
name|error
argument_list|(
literal|"in SOME/EACH/NO i IN t, t is not a text, list or table"
argument_list|)
expr_stmt|;
name|len
operator|=
name|size
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|k
operator|=
name|copy
argument_list|(
name|one
argument_list|)
expr_stmt|;
while|while
condition|(
name|go_on
operator|&&
name|compare
argument_list|(
name|k
argument_list|,
name|len
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|tx
operator|=
name|utx
expr_stmt|;
name|w
operator|=
name|th_of
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|w
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|tx
operator|=
name|vtx
expr_stmt|;
name|go_on
operator|=
name|each
operator|==
operator|(
name|ttest
argument_list|(
name|q
argument_list|,
name|qt
argument_list|)
operator|==
name|Succ
operator|)
expr_stmt|;
name|k
operator|=
name|sum
argument_list|(
name|k1
operator|=
name|k
argument_list|,
name|one
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|k1
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
name|release
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|restore_env
argument_list|(
name|e0
argument_list|)
expr_stmt|;
return|return
name|go_on
operator|==
name|all
condition|?
name|Succ
else|:
name|Fail
return|;
block|}
end_function

begin_function
name|Hidden
name|part
parameter_list|(
name|n
parameter_list|,
name|l
parameter_list|,
name|f
parameter_list|,
name|v
parameter_list|,
name|B
parameter_list|,
name|utx
parameter_list|,
name|vtx
parameter_list|,
name|go_on
parameter_list|,
name|each
parameter_list|,
name|q
parameter_list|,
name|qt
parameter_list|)
name|intlet
name|n
decl_stmt|;
name|loc
name|l
decl_stmt|,
name|v
decl_stmt|;
name|intlet
name|f
decl_stmt|,
name|B
decl_stmt|;
name|txptr
name|utx
decl_stmt|,
name|vtx
decl_stmt|;
name|bool
modifier|*
name|go_on
decl_stmt|,
name|each
decl_stmt|;
name|txptr
name|q
decl_stmt|;
name|string
name|qt
decl_stmt|;
block|{
name|intlet
name|r
init|=
name|length
argument_list|(
name|v
argument_list|)
operator|-
name|B
decl_stmt|,
name|k
decl_stmt|;
name|value
name|w
decl_stmt|;
for|for
control|(
name|k
operator|=
name|n
operator|==
literal|1
condition|?
name|r
else|:
literal|0
init|;
operator|*
name|go_on
operator|&&
name|k
operator|<=
name|r
condition|;
name|k
operator|++
control|)
block|{
name|tx
operator|=
name|utx
expr_stmt|;
name|w
operator|=
name|trim
argument_list|(
name|v
argument_list|,
name|B
argument_list|,
name|r
operator|-
name|k
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|w
argument_list|,
operator|*
name|field
argument_list|(
name|l
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|release
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
name|tx
operator|=
name|vtx
expr_stmt|;
operator|*
name|go_on
operator|=
name|each
operator|==
operator|(
name|ttest
argument_list|(
name|q
argument_list|,
name|qt
argument_list|)
operator|==
name|Succ
operator|)
expr_stmt|;
block|}
else|else
name|part
argument_list|(
name|n
operator|-
literal|1
argument_list|,
name|l
argument_list|,
name|f
operator|+
literal|1
argument_list|,
name|v
argument_list|,
name|B
operator|+
name|k
argument_list|,
name|utx
argument_list|,
name|vtx
argument_list|,
name|go_on
argument_list|,
name|each
argument_list|,
name|q
argument_list|,
name|qt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

