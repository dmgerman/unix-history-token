begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1984. */
end_comment

begin_comment
comment|/* $Header: b2syn.c,v 1.1 84/06/28 00:49:21 timo Exp $ */
end_comment

begin_comment
comment|/* General parsing routines for B interpreter */
end_comment

begin_include
include|#
directive|include
file|"b.h"
end_include

begin_include
include|#
directive|include
file|"b1obj.h"
end_include

begin_include
include|#
directive|include
file|"b0con.h"
end_include

begin_comment
comment|/*for CLEAR_EOF*/
end_comment

begin_include
include|#
directive|include
file|"b2env.h"
end_include

begin_include
include|#
directive|include
file|"b2scr.h"
end_include

begin_include
include|#
directive|include
file|"b2syn.h"
end_include

begin_function
name|Visible
name|Procedure
name|upto
parameter_list|(
name|q
parameter_list|,
name|ff
parameter_list|)
name|txptr
name|q
decl_stmt|;
name|string
name|ff
decl_stmt|;
block|{
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|<
name|q
condition|)
name|parerr
argument_list|(
literal|"something unexpected following "
argument_list|,
name|ff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|nothing
parameter_list|(
name|q
parameter_list|,
name|xp
parameter_list|)
name|txptr
name|q
decl_stmt|;
name|string
name|xp
decl_stmt|;
block|{
if|if
condition|(
name|tx
operator|>=
name|q
condition|)
block|{
if|if
condition|(
name|Char
argument_list|(
name|tx
operator|-
literal|1
argument_list|)
operator|==
literal|' '
condition|)
name|tx
operator|--
expr_stmt|;
name|parerr
argument_list|(
literal|"nothing instead of expected "
argument_list|,
name|xp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Visible
name|bool
name|ateol
parameter_list|()
block|{
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ceol
argument_list|(
name|tx
argument_list|)
condition|)
block|{
name|To_eol
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
name|Yes
return|;
block|}
return|return
name|No
return|;
block|}
end_function

begin_define
define|#
directive|define
name|Where_inside
parameter_list|(
name|r
parameter_list|,
name|t
parameter_list|)
define|\
value|register txptr ttx= tx; char lc= '+', q; \ 	register intlet parcnt= 0; register bool outs= Yes; bool kw= No; \ 	while (r) \ 	if (outs) { \ 		if (parcnt == 0&& (t))
end_define

begin_define
define|#
directive|define
name|Otherwise
define|\
value|if (Char(ttx) == '(' || Char(ttx) == '[' || Char(ttx) == '{') \ 			parcnt++; \ 		else if (Char(ttx) == ')' || Char(ttx) == ']' || Char(ttx) == '}') { \ 			if (parcnt> 0) parcnt--; \ 		} else if ((Char(ttx) == '\'' || Char(ttx) == '"')&& !Keytagmark(lc)) { \ 			outs= No; q= Char(ttx); \ 		} \ 		lc= Char(ttx++); kw= kw ? Keymark(lc) : Cap(lc); \ 	} else { \ 		if (Char(ttx) == q) { \ 			outs= Yes; kw= No; lc= '+'; \ 		} else if (!outs&& Char(ttx) == '`') { \ 			txptr tx0= tx, yx, zx; \ 			tx= ttx+1; \ 			req("`", lcol(),&yx,&zx); \ 			ttx= yx; tx= tx0; \ 		} \ 		ttx++; \ 	}
end_define

begin_function
name|Visible
name|Procedure
name|findceol
parameter_list|()
block|{
name|Where_inside
argument_list|(
argument|!Eol(ttx)
argument_list|,
argument|Char(ttx) ==
literal|'\\'
argument_list|)
block|{
name|ceol
operator|=
name|ttx
expr_stmt|;
return|return;
block|}
name|Otherwise
name|ceol
init|=
name|ttx
decl_stmt|;
block|}
end_function

begin_function
name|Visible
name|bool
name|atkw
parameter_list|(
name|ss
parameter_list|)
specifier|register
name|string
name|ss
decl_stmt|;
block|{
specifier|register
name|txptr
name|tp
init|=
name|tx
decl_stmt|;
while|while
condition|(
operator|*
name|ss
condition|)
if|if
condition|(
operator|*
name|ss
operator|++
operator|!=
name|Char
argument_list|(
name|tp
operator|++
argument_list|)
condition|)
return|return
name|No
return|;
if|if
condition|(
name|Keymark
argument_list|(
name|Char
argument_list|(
name|tp
argument_list|)
argument_list|)
condition|)
return|return
name|No
return|;
name|tx
operator|=
name|tp
expr_stmt|;
return|return
name|Yes
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|need
parameter_list|(
name|ss
parameter_list|)
name|string
name|ss
decl_stmt|;
block|{
specifier|register
name|string
name|sp
init|=
name|ss
decl_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
if|if
condition|(
operator|*
name|sp
operator|++
operator|!=
name|Char
argument_list|(
name|tx
operator|++
argument_list|)
condition|)
name|pprerr
argument_list|(
literal|"according to the syntax I expected "
argument_list|,
name|ss
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|thought
parameter_list|(
name|c
parameter_list|)
specifier|register
name|char
name|c
decl_stmt|;
block|{
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
operator|++
argument_list|)
operator|!=
name|c
condition|)
name|syserr
argument_list|(
literal|"I'm confused; can't trust me own eyes"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|reqkw
parameter_list|(
name|ss
parameter_list|,
name|ptx
parameter_list|,
name|qtx
parameter_list|)
name|string
name|ss
decl_stmt|;
name|txptr
modifier|*
name|ptx
decl_stmt|,
decl|*
name|qtx
decl_stmt|;
end_function

begin_block
block|{
name|Where_inside
argument_list|(
argument|!Eol(ttx)
argument_list|,
argument|Char(ttx) == *ss&& !kw
argument_list|)
block|{
name|string
name|sp
init|=
name|ss
operator|+
literal|1
decl_stmt|;
operator|*
name|qtx
operator|=
operator|(
operator|*
name|ptx
operator|=
name|ttx
operator|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
if|if
condition|(
operator|*
name|sp
operator|++
operator|!=
name|Char
argument_list|(
operator|(
operator|*
name|qtx
operator|)
operator|++
argument_list|)
condition|)
goto|goto
name|isnt
goto|;
if|if
condition|(
name|Keymark
argument_list|(
name|Char
argument_list|(
operator|*
name|qtx
argument_list|)
argument_list|)
condition|)
goto|goto
name|isnt
goto|;
return|return;
block|}
name|isnt
label|:
name|Otherwise
name|parerr
argument_list|(
literal|"cannot find expected "
argument_list|,
name|ss
argument_list|)
decl_stmt|;
block|}
end_block

begin_function
name|Visible
name|Procedure
name|req
parameter_list|(
name|ss
parameter_list|,
name|utx
parameter_list|,
name|ptx
parameter_list|,
name|qtx
parameter_list|)
name|string
name|ss
decl_stmt|;
name|txptr
name|utx
decl_stmt|,
decl|*
name|ptx
decl_stmt|,
modifier|*
name|qtx
decl_stmt|;
end_function

begin_block
block|{
name|Where_inside
argument_list|(
argument|ttx< utx&& !Eol(ttx)
argument_list|,
argument|Char(ttx) == *ss
argument_list|)
block|{
name|string
name|sp
init|=
name|ss
operator|+
literal|1
decl_stmt|;
operator|*
name|qtx
operator|=
operator|(
operator|*
name|ptx
operator|=
name|ttx
operator|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|&&
operator|*
name|qtx
operator|<
name|utx
condition|)
if|if
condition|(
operator|*
name|sp
operator|++
operator|!=
name|Char
argument_list|(
operator|(
operator|*
name|qtx
operator|)
operator|++
argument_list|)
condition|)
goto|goto
name|isnt
goto|;
return|return;
block|}
name|isnt
label|:
name|Otherwise
name|parerr
argument_list|(
literal|"cannot find expected "
argument_list|,
name|ss
argument_list|)
decl_stmt|;
block|}
end_block

begin_function
name|Visible
name|bool
name|find
parameter_list|(
name|ss
parameter_list|,
name|utx
parameter_list|,
name|ptx
parameter_list|,
name|qtx
parameter_list|)
name|string
name|ss
decl_stmt|;
name|txptr
name|utx
decl_stmt|,
decl|*
name|ptx
decl_stmt|,
modifier|*
name|qtx
decl_stmt|;
end_function

begin_block
block|{
name|Where_inside
argument_list|(
argument|ttx< utx
argument_list|,
argument|Char(ttx) == *ss&& !(kw&& Cap(*ss))
argument_list|)
block|{
name|string
name|sp
init|=
name|ss
operator|+
literal|1
decl_stmt|;
operator|*
name|qtx
operator|=
operator|(
operator|*
name|ptx
operator|=
name|ttx
operator|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|&&
operator|*
name|qtx
operator|<
name|utx
condition|)
if|if
condition|(
operator|*
name|sp
operator|++
operator|!=
name|Char
argument_list|(
operator|(
operator|*
name|qtx
operator|)
operator|++
argument_list|)
condition|)
goto|goto
name|isnt
goto|;
if|if
condition|(
name|Cap
argument_list|(
operator|*
name|ss
argument_list|)
operator|&&
name|Keymark
argument_list|(
name|Char
argument_list|(
operator|*
name|qtx
argument_list|)
argument_list|)
condition|)
goto|goto
name|isnt
goto|;
return|return
name|Yes
return|;
block|}
name|isnt
label|:
name|Otherwise
return|return
name|No
return|;
block|}
end_block

begin_function
name|Visible
name|intlet
name|count
parameter_list|(
name|ss
parameter_list|,
name|utx
parameter_list|)
name|string
name|ss
decl_stmt|;
name|txptr
name|utx
decl_stmt|;
block|{
name|intlet
name|cnt
init|=
literal|0
decl_stmt|;
name|Where_inside
argument_list|(
argument|ttx< utx
argument_list|,
argument|Char(ttx) == *ss
argument_list|)
block|{
name|string
name|sp
init|=
name|ss
operator|+
literal|1
decl_stmt|;
name|txptr
name|tp
init|=
name|ttx
operator|+
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|sp
operator|&&
name|tp
operator|<
name|utx
condition|)
if|if
condition|(
operator|*
name|sp
operator|++
operator|!=
name|Char
argument_list|(
name|tp
operator|++
argument_list|)
condition|)
goto|goto
name|isnt
goto|;
name|cnt
operator|++
expr_stmt|;
block|}
name|isnt
label|:
name|Otherwise
return|return
name|cnt
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TAGBUFSIZE
value|100
end_define

begin_decl_stmt
name|char
name|tagbuf
index|[
name|TAGBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|txptr
name|tagbufend
init|=
operator|&
name|tagbuf
index|[
name|TAGBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|Visible
name|value
name|tag
parameter_list|()
block|{
name|txptr
name|tp
init|=
name|tagbuf
decl_stmt|;
name|value
name|res
init|=
name|Vnil
decl_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Letter
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
return|return
name|Vnil
return|;
while|while
condition|(
name|Tagmark
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|tp
operator|++
operator|=
name|Char
argument_list|(
name|tx
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|+
literal|1
operator|>=
name|tagbufend
condition|)
block|{
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
name|concat_to
argument_list|(
operator|&
name|res
argument_list|,
name|tagbuf
argument_list|)
expr_stmt|;
name|tp
operator|=
name|tagbuf
expr_stmt|;
block|}
block|}
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
name|concat_to
argument_list|(
operator|&
name|res
argument_list|,
name|tagbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|Visible
name|value
name|findkw
parameter_list|(
name|u
parameter_list|,
name|f
parameter_list|,
name|t
parameter_list|)
name|txptr
name|u
decl_stmt|,
decl|*
name|f
decl_stmt|,
modifier|*
name|t
decl_stmt|;
end_function

begin_block
block|{
name|txptr
name|sp
init|=
name|tx
decl_stmt|,
name|kp
init|=
name|tagbuf
decl_stmt|;
name|value
name|word
init|=
name|Vnil
decl_stmt|;
while|while
condition|(
name|sp
operator|<
name|u
operator|&&
operator|!
name|Cap
argument_list|(
name|Char
argument_list|(
name|sp
argument_list|)
argument_list|)
condition|)
name|sp
operator|++
expr_stmt|;
operator|*
name|f
operator|=
name|sp
expr_stmt|;
while|while
condition|(
name|sp
operator|<
name|u
operator|&&
name|Keymark
argument_list|(
name|Char
argument_list|(
name|sp
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|kp
operator|++
operator|=
name|Char
argument_list|(
name|sp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|kp
operator|+
literal|1
operator|>=
name|tagbufend
condition|)
block|{
operator|*
name|kp
operator|=
literal|'\0'
expr_stmt|;
name|concat_to
argument_list|(
operator|&
name|word
argument_list|,
name|tagbuf
argument_list|)
expr_stmt|;
name|kp
operator|=
name|tagbuf
expr_stmt|;
block|}
block|}
operator|*
name|kp
operator|=
literal|'\0'
expr_stmt|;
name|concat_to
argument_list|(
operator|&
name|word
argument_list|,
name|tagbuf
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
name|sp
expr_stmt|;
comment|/* if no keyword is found, f and t are set to u */
return|return
operator|(
name|word
operator|)
return|;
block|}
end_block

begin_function
name|Visible
name|value
name|keyword
parameter_list|(
name|u
parameter_list|)
name|txptr
name|u
decl_stmt|;
block|{
name|txptr
name|f
decl_stmt|;
name|Skipsp
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Cap
argument_list|(
name|Char
argument_list|(
name|tx
argument_list|)
argument_list|)
condition|)
name|parerr
argument_list|(
literal|"no keyword where expected"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|findkw
argument_list|(
name|u
argument_list|,
operator|&
name|f
argument_list|,
operator|&
name|tx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Stream handling */
end_comment

begin_comment
comment|/* Txbuf holds streams of incoming characters from a file or the keyboard */
end_comment

begin_comment
comment|/* The current stream is marked by txstart and txend,			  */
end_comment

begin_comment
comment|/* with tx pointing somewhere in the middle				  */
end_comment

begin_comment
comment|/* The main stream is for immediate commands, but new ones are created	  */
end_comment

begin_comment
comment|/* for reading units, and for the read command (when this is implemented) */
end_comment

begin_define
define|#
directive|define
name|TXBUFSIZE
value|(1<<13)
end_define

begin_decl_stmt
name|char
name|txbuf
index|[
name|TXBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|txptr
name|txbufstart
init|=
operator|&
name|txbuf
index|[
literal|1
index|]
decl_stmt|,
name|txstart
decl_stmt|,
name|txend
decl_stmt|,
name|txbufend
init|=
operator|&
name|txbuf
index|[
name|TXBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|intlet
name|alino
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|Interactive
value|(interactive&& sv_ifile == ifile)
end_define

begin_function
name|Visible
name|txptr
name|fcol
parameter_list|()
block|{
comment|/* the first position of the current line */
name|txptr
name|ax
init|=
name|tx
decl_stmt|;
while|while
condition|(
operator|!
name|Eol
argument_list|(
name|ax
operator|-
literal|1
argument_list|)
operator|&&
name|Char
argument_list|(
name|ax
operator|-
literal|1
argument_list|)
operator|!=
name|Eotc
condition|)
name|ax
operator|--
expr_stmt|;
return|return
operator|(
name|ax
operator|)
return|;
block|}
end_function

begin_function
name|Visible
name|txptr
name|lcol
parameter_list|()
block|{
comment|/* the position beyond the last character of the line */
name|txptr
name|ax
init|=
name|tx
decl_stmt|;
while|while
condition|(
operator|!
name|Eol
argument_list|(
name|ax
argument_list|)
condition|)
name|ax
operator|++
expr_stmt|;
return|return
operator|(
name|ax
operator|)
return|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|getline
parameter_list|()
block|{
name|intlet
name|k
decl_stmt|;
name|bool
name|got
decl_stmt|;
if|if
condition|(
name|Eof0
condition|)
block|{
operator|*
name|txend
operator|++
operator|=
name|Eouc
expr_stmt|;
operator|*
name|txend
operator|=
name|Eotc
expr_stmt|;
name|Eof
operator|=
name|Yes
expr_stmt|;
return|return;
block|}
name|alino
operator|++
expr_stmt|;
name|got
operator|=
name|No
expr_stmt|;
while|while
condition|(
operator|!
name|got
condition|)
block|{
if|if
condition|(
name|Interactive
condition|)
block|{
if|if
condition|(
name|outeractive
condition|)
block|{
name|line
argument_list|()
expr_stmt|;
name|at_nwl
operator|=
name|No
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|cmd_prompt
argument_list|)
expr_stmt|;
block|}
name|got
operator|=
name|Yes
expr_stmt|;
while|while
condition|(
operator|(
name|k
operator|=
name|getc
argument_list|(
name|ifile
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|k
operator|!=
literal|'\n'
condition|)
block|{
operator|*
name|txend
operator|++
operator|=
name|k
expr_stmt|;
if|if
condition|(
name|txend
operator|>
name|txbufend
operator|-
literal|5
condition|)
name|syserr
argument_list|(
literal|"text buffer overflow"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|==
name|EOF
operator|&&
name|Interactive
condition|)
block|{
if|if
condition|(
name|filtered
condition|)
name|bye
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Editor has died */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\r*** use QUIT to end session\n"
argument_list|)
expr_stmt|;
name|CLEAR_EOF
expr_stmt|;
if|if
condition|(
name|outeractive
condition|)
name|at_nwl
operator|=
name|Yes
expr_stmt|;
name|got
operator|=
name|No
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Interactive
operator|&&
name|outeractive
operator|&&
name|k
operator|==
literal|'\n'
condition|)
name|at_nwl
operator|=
name|Yes
expr_stmt|;
operator|*
name|txend
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|txend
operator|=
name|Eotc
expr_stmt|;
name|Eof0
operator|=
name|k
operator|==
name|EOF
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|intlet
name|ilev
parameter_list|(
name|new
parameter_list|)
name|bool
name|new
decl_stmt|;
block|{
specifier|register
name|intlet
name|i
decl_stmt|;
name|lino
operator|++
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
name|Eouc
condition|)
block|{
operator|++
name|tx
expr_stmt|;
comment|/* veli() */
if|if
condition|(
operator|!
name|new
condition|)
name|debug
argument_list|(
literal|"ilev saw Eouc and returns since new == No"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
return|return
name|cur_ilev
operator|=
literal|0
return|;
name|debug
argument_list|(
literal|"ilev saw Eouc but proceeds since new == Yes"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Char
argument_list|(
name|tx
operator|++
argument_list|)
operator|!=
literal|'\n'
condition|)
name|syserr
argument_list|(
literal|"ilev called when not at end of line"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
operator|-
literal|1
argument_list|)
operator|!=
name|Eouc
condition|)
name|debug
argument_list|(
literal|"ilev saw no Eouc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
name|Eotc
condition|)
name|getline
argument_list|()
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|' '
operator|||
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'\t'
condition|)
block|{
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|' '
condition|)
name|i
operator|++
expr_stmt|;
else|else
name|i
operator|=
operator|(
name|i
operator|/
literal|4
operator|+
literal|1
operator|)
operator|*
literal|4
expr_stmt|;
name|tx
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Char
argument_list|(
name|tx
argument_list|)
operator|==
literal|'\n'
condition|)
return|return
name|cur_ilev
operator|=
literal|0
return|;
if|if
condition|(
name|i
operator|%
literal|4
operator|==
literal|2
condition|)
name|parerr
argument_list|(
literal|"cannot make out indentation; use tab to indent"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|cur_ilev
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|/
literal|4
return|;
comment|/* small deviation accepted */
block|}
end_function

begin_function
name|Visible
name|Procedure
name|veli
parameter_list|()
block|{
comment|/* resets tx after look-ahead call of ilev */
name|debug
argument_list|(
literal|"calling veli"
argument_list|)
expr_stmt|;
while|while
condition|(
name|Char
argument_list|(
operator|--
name|tx
argument_list|)
operator|!=
literal|'\n'
operator|&&
name|Char
argument_list|(
name|tx
argument_list|)
operator|!=
name|Eouc
condition|)
empty_stmt|;
name|lino
operator|--
expr_stmt|;
name|debug
argument_list|(
literal|"leaving veli"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|inistreams
parameter_list|()
block|{
name|txstart
operator|=
name|txbufstart
expr_stmt|;
name|start_stream
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|re_streams
parameter_list|()
block|{
if|if
condition|(
name|Char
argument_list|(
name|tx
operator|+
literal|1
argument_list|)
operator|==
name|Eotc
condition|)
name|inistreams
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|open_stream
parameter_list|()
block|{
name|txstart
operator|=
name|txend
operator|+
literal|2
expr_stmt|;
name|start_stream
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|Hidden
name|Procedure
name|start_stream
parameter_list|()
block|{
operator|*
operator|(
name|txend
operator|=
name|txstart
operator|)
operator|=
name|Eotc
expr_stmt|;
name|tx
operator|=
name|txend
operator|-
literal|1
expr_stmt|;
operator|*
name|tx
operator|=
name|Eouc
expr_stmt|;
block|}
end_function

begin_function
name|Visible
name|Procedure
name|close_stream
parameter_list|(
name|otx
parameter_list|,
name|otxstart
parameter_list|)
name|txptr
name|otx
decl_stmt|,
name|otxstart
decl_stmt|;
block|{
name|txend
operator|=
name|txstart
operator|-
literal|2
expr_stmt|;
name|tx
operator|=
name|otx
expr_stmt|;
name|txstart
operator|=
name|otxstart
expr_stmt|;
block|}
end_function

end_unit

