begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
end_comment

begin_comment
comment|/* $Header: convert.c,v 1.1 85/08/22 14:33:43 timo Exp $ */
end_comment

begin_comment
comment|/*  * Utility to recover the contents of a B workspace.  *  * Call as: convert [\'\"\<\>=]?* (this should be done by a shell script).  *  * It constructs a completely new ".b_perm" file with references to all files  * mentioned (if they exist).  * Files whose name starts with '=' and files with an extension of ".tar"  * or ".TAR" are taken to be targets; all others are assumed to contain  * units (if they contain garbage, they are ignored).  (".tar" and ".TAR"  * are used on the IBM-PC.)  * For units, the name, type and adicity are extracted from the source;  * for targets, the target name is taken to be the file name with all  * illegal characters removed (upper case converted to lowercase).  *  * BUGS:  * - should augment the old ".b_perm" file instead of just overwriting it;  * - target names can get truncated when the original target name was longer  *   than what fits in a legal file name.  * - doesn't detect multiple files defining the same name  * - on the IBM-PC, the file name expansion should be in the program for it to  *   be of any use, because the MS-DOS "shell" doesn't expand * in file names  *  * $Log:	convert.c,v $  * Revision 1.1  85/08/22  14:33:43  timo  * Initial revision  *   * Revision 1.3.2.1  85/06/04  13:36:04  guido  * Create consistent branch 1.3.2.  *   * Revision 1.3  85/06/04  13:35:33  guido  * Added MS-DOS support.  *   * Revision 1.2  85/04/12  22:33:33  guido  * added treatment of targets; added warning and fatal error messages.  *   * Revision 1.1  85/01/29  12:48:09  guido  * used given file names instead of constructing file names from unit names.  *  * Revision --- frank  * created.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_define
define|#
directive|define
name|BPERMFILE
value|"PERM.BIF"
end_define

begin_define
define|#
directive|define
name|DELIM
value|'\\'
end_define

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_define
define|#
directive|define
name|rindex
value|strrchr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|unix
end_ifdef

begin_define
define|#
directive|define
name|BPERMFILE
value|".b_perm"
end_define

begin_define
define|#
directive|define
name|DELIM
value|'/'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|rindex
argument_list|()
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|defargv
index|[]
init|=
block|{
literal|"convert"
block|,
literal|"*.how"
block|,
literal|"*.zer"
block|,
literal|"*.mon"
block|,
literal|"*.dya"
block|,
literal|"*.tar"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|defargc
value|(sizeof defargv/sizeof defargv[0] - 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|FILE
modifier|*
name|ofile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pbuf
decl_stmt|,
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|,
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|progname
init|=
literal|"convert"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|status
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|Oputc
parameter_list|(
name|c
parameter_list|)
value|putc(c, ofile)
end_define

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|warning
argument_list|(
argument|fmt
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|status
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** %s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*VARARGS2*/
end_comment

begin_macro
name|quit
argument_list|(
argument|sts
argument_list|,
argument|msg
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|warning
argument_list|(
name|msg
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|sts
condition|?
name|sts
else|:
name|status
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|MSDOS
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|quit
argument_list|(
literal|2
argument_list|,
literal|"Usage: %s file ..."
argument_list|,
name|progname
argument_list|)
expr_stmt|;
comment|/* Don't do this under MSDOS -- program name is always 'c'... */
name|progname
operator|=
name|rindex
argument_list|(
operator|*
name|argv
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|progname
condition|)
operator|++
name|progname
expr_stmt|;
else|else
name|progname
operator|=
operator|*
name|argv
expr_stmt|;
endif|#
directive|endif
name|ofile
operator|=
name|fopen
argument_list|(
name|BPERMFILE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ofile
condition|)
name|quit
argument_list|(
literal|2
argument_list|,
literal|"%s: can't create %s"
argument_list|,
name|progname
argument_list|,
name|BPERMFILE
argument_list|)
expr_stmt|;
name|Oputc
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|defargc
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
block|{
name|argv
operator|=
name|defargv
expr_stmt|;
name|argc
operator|=
name|defargc
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
name|treat_file
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
name|Oputc
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
name|Oputc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ofile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|treat_file
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|ifile
decl_stmt|;
specifier|static
name|int
name|recursive
init|=
literal|0
decl_stmt|;
name|ifile
operator|=
name|fopen
argument_list|(
name|filename
operator|=
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifile
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
name|filename
argument_list|,
literal|'*'
argument_list|)
operator|&&
operator|!
name|recursive
condition|)
block|{
comment|/* Assume failed '*' expansion */
comment|/* Ignore on UNIX, expand on MSDOS */
ifdef|#
directive|ifdef
name|MSDOS
name|char
modifier|*
modifier|*
name|list
init|=
name|getfiles
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
condition|)
block|{
name|recursive
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
operator|*
name|list
condition|;
operator|++
name|list
control|)
name|treat_file
argument_list|(
operator|*
name|list
argument_list|)
expr_stmt|;
name|recursive
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
name|warning
argument_list|(
literal|"%s: can't read"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|buffer
argument_list|,
name|BUFSIZ
argument_list|,
name|ifile
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%s: empty file"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_target
argument_list|(
name|filename
argument_list|)
condition|)
name|treat_target
argument_list|()
expr_stmt|;
else|else
name|treat_line
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|CapLetter
value|('A'<= *pbuf&& *pbuf<= 'Z')
end_define

begin_define
define|#
directive|define
name|Letter
value|('a'<= *pbuf&& *pbuf<= 'z')
end_define

begin_define
define|#
directive|define
name|Digit
value|('0'<= *pbuf&& *pbuf<= '9')
end_define

begin_define
define|#
directive|define
name|Quote
value|(*pbuf == '\'' || *pbuf == '"')
end_define

begin_define
define|#
directive|define
name|Colon
value|(*pbuf == ':')
end_define

begin_define
define|#
directive|define
name|Open
value|(*pbuf == '(')
end_define

begin_define
define|#
directive|define
name|Close
value|(*pbuf == ')')
end_define

begin_define
define|#
directive|define
name|Space
value|(*pbuf == ' ' || *pbuf == '\t')
end_define

begin_define
define|#
directive|define
name|Tagmark
value|(Letter || Digit || Quote)
end_define

begin_define
define|#
directive|define
name|Keymark
value|(CapLetter || Digit || Quote)
end_define

begin_define
define|#
directive|define
name|ToLower
parameter_list|(
name|c
parameter_list|)
value|((c) - 'A' + 'a')
end_define

begin_macro
name|skip_tag
argument_list|()
end_macro

begin_block
block|{
name|first
operator|=
name|pbuf
expr_stmt|;
while|while
condition|(
name|Tagmark
condition|)
name|pbuf
operator|++
expr_stmt|;
name|last
operator|=
name|pbuf
expr_stmt|;
block|}
end_block

begin_macro
name|skip_keyword
argument_list|()
end_macro

begin_block
block|{
name|first
operator|=
name|pbuf
expr_stmt|;
while|while
condition|(
name|Keymark
condition|)
name|pbuf
operator|++
expr_stmt|;
name|last
operator|=
name|pbuf
expr_stmt|;
block|}
end_block

begin_macro
name|skip_space
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|Space
condition|)
name|pbuf
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|skip_open_close
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|Open
condition|)
block|{
name|skip_to_close
argument_list|()
expr_stmt|;
name|pbuf
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|skip_to_close
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
operator|++
name|pbuf
operator|,
operator|!
name|Close
condition|)
if|if
condition|(
name|Open
condition|)
name|skip_to_close
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|treat_line
argument_list|()
end_macro

begin_block
block|{
name|pbuf
operator|=
name|buffer
expr_stmt|;
switch|switch
condition|(
operator|*
name|pbuf
condition|)
block|{
case|case
literal|'H'
case|:
name|howto_unit
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
case|case
literal|'T'
case|:
name|funprd_unit
argument_list|()
expr_stmt|;
break|break;
default|default:
name|warning
argument_list|(
literal|"%s: not a valid B unit"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|Zer
value|0
end_define

begin_define
define|#
directive|define
name|Mon
value|1
end_define

begin_define
define|#
directive|define
name|Dya
value|2
end_define

begin_define
define|#
directive|define
name|How
value|3
end_define

begin_define
define|#
directive|define
name|Tar
value|4
end_define

begin_macro
name|howto_unit
argument_list|()
end_macro

begin_block
block|{
name|skip_keyword
argument_list|()
expr_stmt|;
name|skip_space
argument_list|()
expr_stmt|;
name|skip_keyword
argument_list|()
expr_stmt|;
name|put_entry
argument_list|(
name|How
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|funprd_unit
argument_list|()
end_macro

begin_block
block|{
name|skip_keyword
argument_list|()
expr_stmt|;
name|skip_space
argument_list|()
expr_stmt|;
if|if
condition|(
name|Letter
condition|)
block|{
name|skip_tag
argument_list|()
expr_stmt|;
name|skip_space
argument_list|()
expr_stmt|;
if|if
condition|(
name|Colon
condition|)
name|put_entry
argument_list|(
name|Zer
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|Letter
condition|)
name|put_entry
argument_list|(
name|Mon
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|sv_first
init|=
name|first
decl_stmt|,
modifier|*
name|sv_last
init|=
name|last
decl_stmt|;
name|skip_tag
argument_list|()
expr_stmt|;
name|skip_space
argument_list|()
expr_stmt|;
if|if
condition|(
name|Colon
condition|)
block|{
name|first
operator|=
name|sv_first
expr_stmt|;
name|last
operator|=
name|sv_last
expr_stmt|;
name|put_entry
argument_list|(
name|Mon
argument_list|)
expr_stmt|;
block|}
else|else
name|put_entry
argument_list|(
name|Dya
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|skip_open_close
argument_list|()
expr_stmt|;
name|skip_space
argument_list|()
expr_stmt|;
name|skip_tag
argument_list|()
expr_stmt|;
name|put_entry
argument_list|(
name|Dya
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|treat_target
argument_list|()
end_macro

begin_block
block|{
name|pbuf
operator|=
name|filename
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
if|if
condition|(
name|index
argument_list|(
name|pbuf
argument_list|,
literal|':'
argument_list|)
condition|)
name|pbuf
operator|=
name|index
argument_list|(
name|pbuf
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rindex
argument_list|(
name|pbuf
argument_list|,
name|DELIM
argument_list|)
condition|)
name|pbuf
operator|=
name|index
argument_list|(
name|pbuf
argument_list|,
name|DELIM
argument_list|)
operator|+
literal|1
expr_stmt|;
name|first
operator|=
name|last
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
operator|*
name|pbuf
operator|&&
operator|!
name|Letter
operator|&&
operator|!
name|CapLetter
condition|)
operator|++
name|pbuf
expr_stmt|;
for|for
control|(
init|;
operator|*
name|pbuf
condition|;
operator|++
name|pbuf
control|)
block|{
if|if
condition|(
name|CapLetter
condition|)
operator|*
name|last
operator|++
operator|=
name|ToLower
argument_list|(
operator|*
name|pbuf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Letter
operator|||
name|Digit
operator|||
name|Quote
condition|)
operator|*
name|last
operator|++
operator|=
operator|*
name|pbuf
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|pbuf
operator|==
literal|'.'
condition|)
break|break;
comment|/* Stop before extension ".tar" or ".TAR" */
block|}
if|if
condition|(
name|last
operator|==
name|first
condition|)
name|warning
argument_list|(
literal|"%s: cannot deduce target name"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
else|else
name|put_entry
argument_list|(
name|Tar
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|put_entry
argument_list|(
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|first_elem
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|first_elem
condition|)
name|Oputc
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
else|else
name|first_elem
operator|=
literal|0
expr_stmt|;
name|Oputc
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|put_key
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|Oputc
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|Oputc
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|put_assoc
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|Text_quote
value|'"'
end_define

begin_define
define|#
directive|define
name|Back_quote
value|'`'
end_define

begin_define
define|#
directive|define
name|Double
parameter_list|(
name|c
parameter_list|)
value|if ((c) == Text_quote || (c) == Back_quote) Oputc(c)
end_define

begin_macro
name|put_key
argument_list|(
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p
init|=
name|first
decl_stmt|;
name|Oputc
argument_list|(
name|Text_quote
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Zer
case|:
name|Oputc
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
break|break;
case|case
name|Mon
case|:
name|Oputc
argument_list|(
literal|'1'
argument_list|)
expr_stmt|;
break|break;
case|case
name|Dya
case|:
name|Oputc
argument_list|(
literal|'2'
argument_list|)
expr_stmt|;
break|break;
case|case
name|How
case|:
name|Oputc
argument_list|(
literal|'3'
argument_list|)
expr_stmt|;
break|break;
case|case
name|Tar
case|:
name|Oputc
argument_list|(
literal|'4'
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
while|while
condition|(
name|p
operator|<
name|last
condition|)
block|{
name|Double
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|Oputc
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
name|Oputc
argument_list|(
name|Text_quote
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|put_assoc
argument_list|(
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p
init|=
name|filename
decl_stmt|;
name|Oputc
argument_list|(
name|Text_quote
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|Double
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|Oputc
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
name|Oputc
argument_list|(
name|Text_quote
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|is_target
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|name
operator|==
literal|'='
condition|)
return|return
literal|1
return|;
name|name
operator|=
name|rindex
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
literal|0
return|;
return|return
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".TAR"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".tar"
argument_list|)
operator|==
literal|0
return|;
block|}
end_block

end_unit

