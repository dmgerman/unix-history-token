begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|MAINLINE
end_define

begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_include
include|#
directive|include
file|"newsgate.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: newsinput.c,v 1.7.0.6 85/10/01 23:06:08 notes Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|RCSIDENT
end_endif

begin_comment
comment|/*  *	newsinput  *  *	A total re-coding of the original.  Makes use of the  *	work that Lou Salkind and Tw Cook have done.  Lou rearranged  *	a bunch of stuff and Tw put the notes headers into the  *	news header.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|title
index|[
name|TITLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hold titles */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|fromsys
index|[
name|SYSSZ
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gave it to us */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|when_f
name|entered
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* date written */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|origsys
index|[
name|SYSSZ
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* originator */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|authname
index|[
name|NAMESZ
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* author */
end_comment

begin_decl_stmt
specifier|static
name|int
name|has_suffix
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* had -(nf) suffix */
end_comment

begin_define
define|#
directive|define
name|dprintf
value|if (0) printf
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|FILE
modifier|*
name|rawnews
decl_stmt|;
name|FILE
modifier|*
name|body
decl_stmt|;
name|char
name|pathname
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|io_f
name|io
decl_stmt|;
name|struct
name|hbuf
name|header
decl_stmt|;
name|char
name|nf
index|[
name|WDLEN
index|]
decl_stmt|;
name|struct
name|nflist_f
modifier|*
name|nfptr
decl_stmt|;
comment|/* expand newsgroups */
name|int
name|c
decl_stmt|;
name|int
name|onechar
decl_stmt|;
name|char
modifier|*
name|tail
decl_stmt|;
name|int
name|fid
decl_stmt|;
comment|/* for close */
name|setuid
argument_list|(
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* force to "notes" */
name|startup
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* comon init */
name|rawnews
operator|=
name|stdin
expr_stmt|;
comment|/* usually here */
for|for
control|(
name|fid
operator|=
literal|3
init|;
name|fid
operator|<
literal|20
condition|;
name|fid
operator|++
control|)
comment|/* close all extras */
name|close
argument_list|(
name|fid
argument_list|)
expr_stmt|;
comment|/*  *	Parse the Header.  Follow all the USENET standards  *	for doing this.  Result is left in a fun little  *	structure.  *	Internalize some of the information to help us figure out  *	some things quickly.  */
if|if
condition|(
operator|!
name|newsheader
argument_list|(
operator|&
name|header
argument_list|,
name|rawnews
argument_list|,
name|TRUE
argument_list|)
condition|)
comment|/* read the headers */
block|{
name|printf
argument_list|(
literal|"Incoming News mangled more than usual\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
comment|/*  *	Parse things like origsys, fromsys, author, date written  */
name|parsepath
argument_list|(
name|header
operator|.
name|path
argument_list|,
name|header
operator|.
name|from
argument_list|)
expr_stmt|;
comment|/* systems, authors */
name|parsetime
argument_list|(
name|header
operator|.
name|subdate
argument_list|,
operator|&
name|entered
argument_list|)
expr_stmt|;
comment|/* submitted */
name|sprintf
argument_list|(
name|pathname
argument_list|,
literal|"/tmp/nfxx%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"Origsys: %s\n"
argument_list|,
name|origsys
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"fromsys: %s\n"
argument_list|,
name|fromsys
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"Date Written:"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|prdate
argument_list|(
operator|&
name|entered
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dprintf
argument_list|(
literal|"\nauthor: %s\n"
argument_list|,
name|authname
argument_list|)
expr_stmt|;
comment|/*  *	See if this might be a control message. Notes readers don't  *	care to see these.  *  *	News code also recognizes titles with first 5 characters set   *	to "cmsg " as control messages. We should clean them up too.  */
if|if
condition|(
name|header
operator|.
name|ctlmsg
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
comment|/* is control */
block|{
name|printf
argument_list|(
literal|"Control message (ignored): %s\n"
argument_list|,
name|header
operator|.
name|ctlmsg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* "success" */
block|}
comment|/*  *	Save the body of the article somewhere safe (like not in  *	memory).  */
if|if
condition|(
operator|(
name|body
operator|=
name|fopen
argument_list|(
name|pathname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* failed */
block|{
name|printf
argument_list|(
literal|"Had problems creating/opening file %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
comment|/* die */
block|}
while|while
condition|(
operator|(
name|onechar
operator|=
name|getc
argument_list|(
name|rawnews
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
comment|/* save it */
name|putc
argument_list|(
name|onechar
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|body
argument_list|)
expr_stmt|;
comment|/* make sure */
name|fclose
argument_list|(
name|body
argument_list|)
expr_stmt|;
comment|/* and close it */
comment|/*  *	Now run through the specified list of newsgroups,  *	re-scan the body and such each time.  */
name|expand
argument_list|(
name|header
operator|.
name|nbuf
argument_list|)
expr_stmt|;
comment|/* expand groups */
while|while
condition|(
operator|(
name|nfptr
operator|=
name|nextgroup
argument_list|()
operator|)
operator|!=
operator|(
expr|struct
name|nflist_f
operator|*
operator|)
name|NULL
condition|)
block|{
name|newsgroup
argument_list|(
name|nfptr
operator|->
name|nf_name
argument_list|,
name|nf
argument_list|,
name|NEWSNF
argument_list|)
expr_stmt|;
comment|/* map it */
name|dprintf
argument_list|(
literal|"Newsgroup %s maps to notesfile %s\n"
argument_list|,
name|nfptr
operator|->
name|nf_name
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|tail
operator|=
name|rindex
argument_list|(
name|nfptr
operator|->
name|nf_name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
comment|/* catch ctl msgs */
if|if
condition|(
name|tail
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|tail
argument_list|,
name|CTL
argument_list|)
condition|)
comment|/* it is one */
block|{
name|char
name|pbuf
index|[
literal|256
index|]
decl_stmt|;
comment|/* for title fixing */
name|strcpy
argument_list|(
name|nf
argument_list|,
name|NFMAINT
argument_list|)
expr_stmt|;
comment|/* map it */
name|dprintf
argument_list|(
literal|"Control newsgroup %s mapped to %s\n"
argument_list|,
name|nfptr
operator|->
name|nf_name
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pbuf
argument_list|,
literal|"%s:%s"
argument_list|,
name|nfptr
operator|->
name|nf_name
argument_list|,
name|header
operator|.
name|title
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|header
operator|.
name|title
argument_list|,
name|pbuf
argument_list|,
name|BUFLEN
argument_list|)
expr_stmt|;
comment|/* prefix title */
name|header
operator|.
name|title
index|[
name|BUFLEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* ensure terminater */
block|}
if|if
condition|(
operator|(
name|body
operator|=
name|fopen
argument_list|(
name|pathname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|failed
goto|;
comment|/* shit */
block|}
if|if
condition|(
name|init
argument_list|(
operator|&
name|io
argument_list|,
name|nf
argument_list|)
operator|<
literal|0
condition|)
comment|/* open the nf */
block|{
name|char
name|pbuf
index|[
literal|512
index|]
decl_stmt|;
name|char
name|tbuf
index|[
literal|128
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|AUTOCREATE
name|sprintf
argument_list|(
name|pbuf
argument_list|,
literal|"Notesfile: %s\nNewsgroup: %s\n\nCreated by newsinput\n"
argument_list|,
name|nf
argument_list|,
name|nfptr
operator|->
name|nf_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"New NF: %s"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|nfcomment
argument_list|(
name|NFMAINT
argument_list|,
name|pbuf
argument_list|,
name|tbuf
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buildnf
argument_list|(
name|nf
argument_list|,
name|Mstdir
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* open and networked */
name|x
argument_list|(
name|init
argument_list|(
operator|&
name|io
argument_list|,
name|nf
argument_list|)
operator|<
literal|0
argument_list|,
literal|"newsinput: open newly created notesfile"
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|pbuf
argument_list|,
literal|"Notesfile: %s, newsgroup %s\n"
argument_list|,
name|nf
argument_list|,
name|nfptr
operator|->
name|nf_name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"New newsgroup %s"
argument_list|,
name|nfptr
operator|->
name|nf_name
argument_list|)
expr_stmt|;
name|nfcomment
argument_list|(
name|NFMAINT
argument_list|,
name|pbuf
argument_list|,
name|tbuf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Inserting into %s\n"
argument_list|,
name|NEWNEWS
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|nf
argument_list|,
name|NEWNEWS
argument_list|)
expr_stmt|;
comment|/* Change newsgroup */
if|if
condition|(
name|init
argument_list|(
operator|&
name|io
argument_list|,
name|nf
argument_list|)
operator|<
literal|0
condition|)
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
comment|/* Give up */
name|printf
argument_list|(
literal|"Open of %s suceeded\n"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|AUTOCREATE
block|}
if|if
condition|(
name|nfgen
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|header
argument_list|,
name|body
argument_list|,
name|pathname
argument_list|)
operator|<
literal|0
condition|)
comment|/* not from notes */
block|{
name|dprintf
argument_list|(
literal|"Nfgen returns failure\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|body
argument_list|)
expr_stmt|;
comment|/* give bnewsgen */
name|body
operator|=
name|fopen
argument_list|(
name|pathname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* a clean copy */
if|if
condition|(
name|bnewsgen
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|header
argument_list|,
name|body
argument_list|)
operator|<
literal|0
condition|)
comment|/* or news */
block|{
name|dprintf
argument_list|(
literal|"bnewsgen returns failure\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
comment|/* drop out */
block|}
block|}
name|fclose
argument_list|(
name|body
argument_list|)
expr_stmt|;
comment|/* ready for loop */
name|finish
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
block|}
name|unlink
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|GOOD
argument_list|)
expr_stmt|;
comment|/*  *	jump here on totally screwed up article.  */
name|failed
label|:
name|dprintf
argument_list|(
literal|"Jumped to failed\n"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
comment|/* body of article */
name|exit
argument_list|(
name|BAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	nfgen(&io,&header,&FILE,pathname)  *  *	parse a notesfile-generated article.  Check the fields of  *	header and look for # lines in the body of the article to  *	determine if it came from notes.  *	  *	returns:	0 no permission for author  *> 0 signifies note or response where it wound up  *			-1 if the article wasn't generated by notes  */
end_comment

begin_macro
name|nfgen
argument_list|(
argument|io
argument_list|,
argument|header
argument_list|,
argument|body
argument_list|,
argument|pathname
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hbuf
modifier|*
name|header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|body
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pathname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|note_f
name|note
decl_stmt|;
name|struct
name|note_f
name|note2
decl_stmt|;
name|struct
name|id_f
name|respid
decl_stmt|;
name|struct
name|daddr_f
name|where
decl_stmt|;
name|struct
name|when_f
name|whentime
decl_stmt|;
name|struct
name|auth_f
name|auth
decl_stmt|;
comment|/* author */
name|int
name|oldstyle
init|=
literal|0
decl_stmt|;
name|int
name|found
decl_stmt|;
name|char
name|line
index|[
name|CMDLEN
index|]
decl_stmt|;
comment|/* scratch */
name|char
modifier|*
name|suffix
decl_stmt|;
name|int
name|notenum
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|fosterstat
decl_stmt|;
comment|/* for foster parents */
name|int
name|count
decl_stmt|;
name|char
name|hline1
index|[
name|BUFLEN
index|]
decl_stmt|;
comment|/* in-text header */
name|char
name|hline2
index|[
name|BUFLEN
index|]
decl_stmt|;
comment|/* in-text header 2 */
name|int
name|onechar
decl_stmt|;
comment|/* scratch character */
name|char
name|field1
index|[
literal|100
index|]
decl_stmt|,
comment|/* scanf tmps */
name|field2
index|[
literal|100
index|]
decl_stmt|;
comment|/*   * Check for titles ending in "- nf".  * We always remove these.  */
name|suffix
operator|=
name|rindex
argument_list|(
name|header
operator|->
name|title
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
comment|/* find last */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|suffix
argument_list|,
name|NFSUFFIX
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|suffix
argument_list|,
name|OLDSUFFIX
argument_list|)
condition|)
block|{
if|if
condition|(
operator|--
name|suffix
operator|>
name|header
operator|->
name|title
condition|)
comment|/* if we can */
operator|*
name|suffix
operator|=
literal|'\0'
expr_stmt|;
comment|/* strip "- (nf)" */
name|has_suffix
operator|++
expr_stmt|;
comment|/* flag it */
block|}
comment|/*  *	at this point we should check for embodied #N.... lines and  *	remove them.  This is conditional on having a "- (nf)" in the  *	title of the note.  */
name|strcpy
argument_list|(
name|hline1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* empty these */
name|strcpy
argument_list|(
name|hline2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_suffix
condition|)
comment|/* look for embedded */
block|{
name|long
name|position
decl_stmt|,
comment|/* place marker */
name|ftell
argument_list|()
decl_stmt|;
comment|/* for types */
name|position
operator|=
name|ftell
argument_list|(
name|body
argument_list|)
expr_stmt|;
comment|/* save it */
while|while
condition|(
name|fgets
argument_list|(
name|hline1
argument_list|,
sizeof|sizeof
name|hline1
argument_list|,
name|body
argument_list|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|hline1
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
break|break;
comment|/* found one */
if|if
condition|(
name|hline1
index|[
literal|0
index|]
operator|!=
literal|'#'
condition|)
comment|/* actually didn't */
block|{
name|fseek
argument_list|(
name|body
argument_list|,
name|position
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* rewind */
name|strcpy
argument_list|(
name|hline1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* empty it */
block|}
else|else
block|{
comment|/* grab line 2 */
name|fgets
argument_list|(
name|hline2
argument_list|,
sizeof|sizeof
name|hline2
argument_list|,
name|body
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|onechar
operator|=
name|getc
argument_list|(
name|body
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|onechar
operator|!=
name|EOF
condition|)
empty_stmt|;
comment|/* zap separator line */
block|}
block|}
if|if
condition|(
name|strlen
argument_list|(
name|header
operator|->
name|nline1
argument_list|)
operator|==
literal|0
condition|)
comment|/* no new headers */
block|{
comment|/*  	 * No notes header in the B news article header... 	 * If title ends with "- nf", look for the 	 * header in the body of the text. 	 * (for backwards compatability) 	 */
if|if
condition|(
name|has_suffix
operator|==
literal|0
condition|)
comment|/* not from notes */
block|{
name|dprintf
argument_list|(
literal|"No NFSUFFIX and no header lines\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|oldstyle
operator|=
literal|1
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hline1
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
comment|/* got them earlier */
block|{
name|strcpy
argument_list|(
name|header
operator|->
name|nline1
argument_list|,
name|hline1
argument_list|)
expr_stmt|;
comment|/* first line */
name|strcpy
argument_list|(
name|header
operator|->
name|nline2
argument_list|,
name|hline2
argument_list|)
expr_stmt|;
comment|/* second line */
name|found
operator|++
expr_stmt|;
comment|/* and mark it */
block|}
while|while
condition|(
operator|!
name|found
operator|&&
comment|/* search body */
name|fgets
argument_list|(
name|header
operator|->
name|nline1
argument_list|,
sizeof|sizeof
name|header
operator|->
name|nline1
argument_list|,
name|body
argument_list|)
condition|)
block|{
if|if
condition|(
name|header
operator|->
name|nline1
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
comment|/* bingo */
block|{
name|found
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
operator|||
name|fgets
argument_list|(
name|header
operator|->
name|nline2
argument_list|,
sizeof|sizeof
name|header
operator|->
name|nline2
argument_list|,
name|body
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|"no header lines in text body\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* not from notes */
block|}
block|}
comment|/*   * We now have the header lines.  * Check validity and do the appropriate action.  */
if|if
condition|(
name|header
operator|->
name|nline1
index|[
literal|0
index|]
operator|!=
literal|'#'
condition|)
block|{
name|dprintf
argument_list|(
literal|"Invalid first header line\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dprintf
argument_list|(
literal|"First line is: %s\n"
argument_list|,
name|header
operator|->
name|nline1
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"Second line is: %s\n"
argument_list|,
name|header
operator|->
name|nline2
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|title
argument_list|,
name|header
operator|->
name|title
argument_list|,
name|TITLEN
argument_list|)
expr_stmt|;
comment|/* get title */
name|title
index|[
name|TITLEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate for sure */
switch|switch
condition|(
name|header
operator|->
name|nline1
index|[
literal|1
index|]
condition|)
comment|/* parse it */
block|{
case|case
literal|'N'
case|:
comment|/* base note */
if|if
condition|(
name|sscanf
argument_list|(
name|header
operator|->
name|nline1
argument_list|,
literal|"#N:%99[^:]:%ld:%o:%d"
argument_list|,
name|field1
argument_list|,
operator|&
name|note
operator|.
name|n_id
operator|.
name|uniqid
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
literal|4
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* no good */
block|}
name|strncpy
argument_list|(
name|note
operator|.
name|n_id
operator|.
name|sys
argument_list|,
name|field1
argument_list|,
name|SYSSZ
argument_list|)
expr_stmt|;
comment|/* copy */
name|note
operator|.
name|n_id
operator|.
name|sys
index|[
name|SYSSZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* and terminate */
name|status
operator||=
name|FRMNEWS
expr_stmt|;
comment|/* it's been there */
comment|/*  	     * parse the second header line 	     */
name|p
operator|=
name|header
operator|->
name|nline2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|HOMESYSSZ
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'!'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
operator|)
condition|;
name|i
operator|++
control|)
name|auth
operator|.
name|asystem
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* get the author */
name|auth
operator|.
name|asystem
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'!'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* skip to end of system */
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* skip the ! */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|NAMESZ
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
operator|)
condition|;
name|i
operator|++
control|)
name|auth
operator|.
name|aname
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* get the author */
name|auth
operator|.
name|aname
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate */
name|auth
operator|.
name|aid
operator|=
name|Anonuid
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
comment|/* drop rest of author */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
comment|/* find the date */
name|p
operator|++
expr_stmt|;
name|parsetime
argument_list|(
name|p
argument_list|,
operator|&
name|note
operator|.
name|n_date
argument_list|)
expr_stmt|;
comment|/* and parse it */
name|getperms
argument_list|(
name|io
argument_list|,
literal|1
argument_list|,
name|note
operator|.
name|n_id
operator|.
name|sys
argument_list|)
expr_stmt|;
comment|/* check permissions */
if|if
condition|(
name|allow
argument_list|(
name|io
argument_list|,
name|WRITOK
argument_list|)
operator|==
literal|0
condition|)
comment|/* not a chance */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* sort of success */
name|locknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* MUTEX */
if|if
condition|(
operator|(
name|notenum
operator|=
name|chknote
argument_list|(
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_id
argument_list|,
operator|&
name|note2
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* not in data base */
name|pagein
argument_list|(
name|io
argument_list|,
name|body
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
comment|/* grab text */
name|status
operator||=
name|FRMNEWS
expr_stmt|;
comment|/* through news */
name|strcpy
argument_list|(
name|note
operator|.
name|n_from
argument_list|,
name|fromsys
argument_list|)
expr_stmt|;
comment|/* who gave it to us */
name|i
operator|=
name|putnote
argument_list|(
name|io
argument_list|,
operator|&
name|where
argument_list|,
name|title
argument_list|,
name|status
argument_list|,
operator|&
name|note
argument_list|,
operator|&
name|auth
argument_list|,
name|NOPOLICY
argument_list|,
name|NOLOCKIT
argument_list|,
name|NOADDID
argument_list|,
name|fromsys
argument_list|,
name|ADDTIME
argument_list|)
expr_stmt|;
name|io
operator|->
name|nnotrcvd
operator|++
expr_stmt|;
comment|/* count it */
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* MUTEX done */
return|return
operator|(
name|i
operator|)
return|;
comment|/* return notenum */
block|}
if|if
condition|(
operator|(
name|note2
operator|.
name|n_stat
operator|&
name|ORPHND
operator|)
operator|&&
operator|(
name|status
operator|&
name|ORPHND
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* replace foster */
comment|/* with true parent */
name|pagein
argument_list|(
name|io
argument_list|,
name|body
argument_list|,
operator|&
name|note2
operator|.
name|n_addr
argument_list|)
expr_stmt|;
comment|/* the text */
name|gettime
argument_list|(
operator|&
name|note2
operator|.
name|n_rcvd
argument_list|)
expr_stmt|;
comment|/* update timestamp */
name|gettime
argument_list|(
operator|&
name|note2
operator|.
name|n_lmod
argument_list|)
expr_stmt|;
comment|/* time stamp it */
name|copyauth
argument_list|(
operator|&
name|auth
argument_list|,
operator|&
name|note2
operator|.
name|n_auth
argument_list|)
expr_stmt|;
comment|/* correct author */
name|note2
operator|.
name|n_stat
operator|=
name|status
operator||
name|FRMNEWS
expr_stmt|;
comment|/* and status bits */
name|strncpy
argument_list|(
name|note2
operator|.
name|ntitle
argument_list|,
name|title
argument_list|,
name|TITLEN
argument_list|)
expr_stmt|;
name|note2
operator|.
name|n_date
operator|=
name|entered
expr_stmt|;
name|strcpy
argument_list|(
name|note2
operator|.
name|n_from
argument_list|,
name|fromsys
argument_list|)
expr_stmt|;
name|putnrec
argument_list|(
name|io
argument_list|,
name|notenum
argument_list|,
operator|&
name|note2
argument_list|)
expr_stmt|;
comment|/* and replace */
name|io
operator|->
name|adopted
operator|++
expr_stmt|;
comment|/* count adoption */
name|io
operator|->
name|nnotrcvd
operator|++
expr_stmt|;
comment|/* count in */
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Orphaned response chain adopted\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|notenum
operator|)
return|;
comment|/* note number */
block|}
else|else
name|printf
argument_list|(
literal|"Duplicate note handed back by news\n"
argument_list|)
expr_stmt|;
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* mark resolved */
case|case
literal|'R'
case|:
comment|/* response */
if|if
condition|(
name|sscanf
argument_list|(
name|header
operator|->
name|nline1
argument_list|,
literal|"#R:%99[^:]:%ld:%99[^:]:%ld:%o:%d"
argument_list|,
name|field1
argument_list|,
operator|&
name|note
operator|.
name|n_id
operator|.
name|uniqid
argument_list|,
name|field2
argument_list|,
operator|&
name|respid
operator|.
name|uniqid
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
literal|6
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* no good */
block|}
name|strncpy
argument_list|(
name|note
operator|.
name|n_id
operator|.
name|sys
argument_list|,
name|field1
argument_list|,
name|SYSSZ
argument_list|)
expr_stmt|;
comment|/* copy them */
name|strncpy
argument_list|(
name|respid
operator|.
name|sys
argument_list|,
name|field2
argument_list|,
name|SYSSZ
argument_list|)
expr_stmt|;
comment|/* both and */
name|note
operator|.
name|n_id
operator|.
name|sys
index|[
name|SYSSZ
operator|-
literal|1
index|]
operator|=
name|respid
operator|.
name|sys
index|[
name|SYSSZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* stop */
name|status
operator||=
name|FRMNEWS
expr_stmt|;
comment|/* it's been there */
name|getperms
argument_list|(
name|io
argument_list|,
literal|1
argument_list|,
name|respid
operator|.
name|sys
argument_list|)
expr_stmt|;
comment|/* check modes */
if|if
condition|(
name|allow
argument_list|(
name|io
argument_list|,
name|RESPOK
argument_list|)
operator|==
literal|0
condition|)
comment|/* not a chance */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* resolved */
name|p
operator|=
name|header
operator|->
name|nline2
expr_stmt|;
comment|/* second line */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|HOMESYSSZ
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'!'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
operator|)
condition|;
name|i
operator|++
control|)
name|auth
operator|.
name|asystem
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* get the author */
name|auth
operator|.
name|asystem
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'!'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* skip to end of system */
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* skip the ! */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|NAMESZ
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
operator|)
condition|;
name|i
operator|++
control|)
name|auth
operator|.
name|aname
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* parse author */
name|auth
operator|.
name|aname
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate */
name|auth
operator|.
name|aid
operator|=
name|Anonuid
expr_stmt|;
comment|/* default */
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
comment|/* rest of author */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
comment|/* find the date */
name|p
operator|++
expr_stmt|;
name|parsetime
argument_list|(
name|p
argument_list|,
operator|&
name|entered
argument_list|)
expr_stmt|;
comment|/* and parse it */
name|locknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* MUTEX */
name|notenum
operator|=
name|chknote
argument_list|(
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_id
argument_list|,
operator|&
name|note2
argument_list|)
expr_stmt|;
if|if
condition|(
name|notenum
operator|==
literal|0
condition|)
comment|/* found parent? */
block|{
comment|/* build foster */
name|printf
argument_list|(
literal|"Orphaned response handed in by news\n"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|note
operator|.
name|n_from
argument_list|,
name|fromsys
argument_list|)
expr_stmt|;
comment|/* make basic info */
name|note
operator|.
name|n_nresp
operator|=
literal|0
expr_stmt|;
name|note
operator|.
name|n_auth
operator|.
name|aid
operator|=
name|Anonuid
expr_stmt|;
name|strcpy
argument_list|(
name|note
operator|.
name|n_auth
operator|.
name|aname
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|note
operator|.
name|n_auth
operator|.
name|asystem
argument_list|,
name|note
operator|.
name|n_id
operator|.
name|sys
argument_list|)
expr_stmt|;
comment|/* system */
name|note
operator|.
name|n_date
operator|=
name|entered
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|whentime
argument_list|)
expr_stmt|;
comment|/* current time */
name|fosterstat
operator|=
name|ORPHND
operator||
name|FRMNEWS
expr_stmt|;
comment|/* combo there */
ifdef|#
directive|ifdef
name|notdef
name|strcpy
argument_list|(
name|note
operator|.
name|ntitle
argument_list|,
literal|"(Orphan) "
argument_list|)
expr_stmt|;
comment|/* prefix */
else|#
directive|else
name|strcpy
argument_list|(
name|note
operator|.
name|ntitle
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* empty */
endif|#
directive|endif
name|i
operator|=
name|strlen
argument_list|(
name|note
operator|.
name|ntitle
argument_list|)
expr_stmt|;
comment|/* index */
for|for
control|(
name|p
operator|=
name|header
operator|->
name|title
init|;
name|i
operator|<
name|TITLEN
operator|&&
operator|*
name|p
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
comment|/* rest of title */
name|note
operator|.
name|ntitle
index|[
name|i
index|]
operator|=
operator|*
name|p
expr_stmt|;
comment|/* basic title */
if|if
condition|(
name|i
operator|<
name|TITLEN
condition|)
name|note
operator|.
name|ntitle
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* null it */
else|else
name|note
operator|.
name|ntitle
index|[
name|TITLEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* null */
name|where
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
comment|/* no text */
name|where
operator|.
name|textlen
operator|=
literal|0
expr_stmt|;
comment|/* still no text */
name|notenum
operator|=
name|putnote
argument_list|(
name|io
argument_list|,
operator|&
name|where
argument_list|,
name|note
operator|.
name|ntitle
argument_list|,
name|fosterstat
argument_list|,
operator|&
name|note
argument_list|,
operator|&
name|note
operator|.
name|n_auth
argument_list|,
name|NOPOLICY
argument_list|,
name|NOLOCKIT
argument_list|,
name|NOADDID
argument_list|,
name|fromsys
argument_list|,
name|ADDTIME
argument_list|)
expr_stmt|;
comment|/* insert him */
name|io
operator|->
name|norphans
operator|++
expr_stmt|;
comment|/* orphan census */
name|getnrec
argument_list|(
name|io
argument_list|,
name|notenum
argument_list|,
operator|&
name|note2
argument_list|)
expr_stmt|;
comment|/* get good one */
block|}
comment|/*  *	At this point we know we have a parent because if there wasn't  *	one before, we built a foster parent.  */
if|if
condition|(
name|chkresp
argument_list|(
name|io
argument_list|,
operator|&
name|respid
argument_list|,
operator|&
name|note2
argument_list|,
name|notenum
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* none, insert it */
name|status
operator||=
name|FRMNEWS
expr_stmt|;
name|pagein
argument_list|(
name|io
argument_list|,
name|body
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|i
operator|=
name|putresp
argument_list|(
name|io
argument_list|,
operator|&
name|where
argument_list|,
name|status
argument_list|,
name|notenum
argument_list|,
operator|&
name|entered
argument_list|,
operator|&
name|auth
argument_list|,
operator|&
name|note
argument_list|,
name|NOLOCKIT
argument_list|,
operator|&
name|respid
argument_list|,
name|NOADDID
argument_list|,
name|fromsys
argument_list|,
name|ADDTIME
argument_list|,
operator|&
name|whentime
argument_list|)
expr_stmt|;
name|io
operator|->
name|nrsprcvd
operator|++
expr_stmt|;
comment|/* count him in */
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* UNMUTEX */
return|return
operator|(
name|i
operator|)
return|;
comment|/* resp number */
block|}
else|else
name|printf
argument_list|(
literal|"Duplicate response handed back by news\n"
argument_list|)
expr_stmt|;
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* resolved */
default|default:
comment|/* bad news */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* NOTREACHED */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	bnewsgen(&io,&header,&FILE)  *  *	parse an article that came through B-news.  We've already  *	checked to see if it was a notesfile generated article  *	so all we have to do is decide if it's a note/response  *	and put it in the appropriate place.  */
end_comment

begin_macro
name|bnewsgen
argument_list|(
argument|io
argument_list|,
argument|header
argument_list|,
argument|body
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hbuf
modifier|*
name|header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|body
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|note_f
name|note
decl_stmt|;
name|struct
name|note_f
name|note2
decl_stmt|;
name|struct
name|when_f
name|whentime
decl_stmt|;
name|struct
name|daddr_f
name|where
decl_stmt|;
name|int
name|notenum
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
name|pbuf
index|[
name|BUFLEN
index|]
decl_stmt|;
comment|/* scratch */
name|long
name|newsseq
decl_stmt|;
name|char
name|newssys
index|[
name|SYSSZ
index|]
decl_stmt|;
name|struct
name|id_f
name|newsid
decl_stmt|;
name|struct
name|auth_f
name|auth
decl_stmt|;
name|char
modifier|*
name|lead
decl_stmt|,
modifier|*
name|trail
decl_stmt|;
comment|/* references */
name|char
name|basesys
index|[
name|SYSSZ
index|]
decl_stmt|;
comment|/* references */
name|long
name|baseseq
decl_stmt|;
comment|/* ditto */
name|struct
name|id_f
name|baseid
decl_stmt|;
comment|/* ditto ditto */
name|char
name|field1
index|[
literal|100
index|]
decl_stmt|,
comment|/* scanf tmps */
name|field2
index|[
literal|100
index|]
decl_stmt|;
name|getperms
argument_list|(
name|io
argument_list|,
literal|1
argument_list|,
name|origsys
argument_list|)
expr_stmt|;
if|if
condition|(
name|allow
argument_list|(
name|io
argument_list|,
name|WRITOK
argument_list|)
operator|==
literal|0
condition|)
comment|/* let him* */
block|{
name|printf
argument_list|(
literal|"System %s not allowed to write notes\n"
argument_list|,
name|origsys
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* NO! */
block|}
name|i
operator|=
name|sscanf
argument_list|(
name|header
operator|->
name|ident
argument_list|,
literal|"<%ld@%99[^>]>"
argument_list|,
operator|&
name|newsseq
argument_list|,
name|field1
argument_list|,
name|pbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|2
condition|)
comment|/* try old */
block|{
name|i
operator|=
name|sscanf
argument_list|(
name|header
operator|->
name|ident
argument_list|,
literal|"%99[^.].%ld"
argument_list|,
name|field1
argument_list|,
operator|&
name|newsseq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|2
condition|)
comment|/* no id */
block|{
ifdef|#
directive|ifdef
name|NFMAINT
name|char
name|pbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|pbuf
argument_list|,
literal|"Message-ID: %s\nPath: %s\nFrom: %s\nNewsgroups: %s\n"
argument_list|,
name|header
operator|->
name|ident
argument_list|,
name|header
operator|->
name|path
argument_list|,
name|header
operator|->
name|from
argument_list|,
name|header
operator|->
name|nbuf
argument_list|)
expr_stmt|;
name|nfcomment
argument_list|(
name|NFMAINT
argument_list|,
name|pbuf
argument_list|,
literal|"Unfathomable Article ID"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NFMAINT
name|dprintf
argument_list|(
literal|"can't fathom article ID: %s\n"
argument_list|,
name|header
operator|->
name|ident
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* mark bogus */
block|}
name|strncpy
argument_list|(
name|newssys
argument_list|,
name|field1
argument_list|,
name|SYSSZ
argument_list|)
expr_stmt|;
comment|/* copy */
name|newssys
index|[
name|SYSSZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* and truncate */
name|note
operator|.
name|n_date
operator|=
name|entered
expr_stmt|;
name|strcpy
argument_list|(
name|note
operator|.
name|n_from
argument_list|,
name|fromsys
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|auth
operator|.
name|aname
argument_list|,
name|authname
argument_list|,
name|NAMESZ
argument_list|)
expr_stmt|;
comment|/* fill in author */
name|strncpy
argument_list|(
name|auth
operator|.
name|asystem
argument_list|,
name|origsys
argument_list|,
name|HOMESYSSZ
argument_list|)
expr_stmt|;
comment|/* system */
name|auth
operator|.
name|asystem
index|[
name|HOMESYSSZ
operator|-
literal|1
index|]
operator|=
name|auth
operator|.
name|aname
index|[
name|NAMESZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|auth
operator|.
name|aid
operator|=
name|Anonuid
expr_stmt|;
name|status
operator|=
name|FRMNEWS
expr_stmt|;
comment|/* came through news */
name|strncpy
argument_list|(
name|title
argument_list|,
name|header
operator|->
name|title
argument_list|,
name|TITLEN
argument_list|)
expr_stmt|;
comment|/* move new title */
name|title
index|[
name|TITLEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* sure it stops */
name|locknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* MUTEX */
comment|/*  *	first thing is to see if it's a base note somewhere.  */
name|strcpy
argument_list|(
name|newsid
operator|.
name|sys
argument_list|,
name|newssys
argument_list|)
expr_stmt|;
comment|/* build uniq id */
name|strcpy
argument_list|(
name|note
operator|.
name|n_id
operator|.
name|sys
argument_list|,
name|newssys
argument_list|)
expr_stmt|;
comment|/* build descriptor */
name|note
operator|.
name|n_id
operator|.
name|uniqid
operator|=
name|newsid
operator|.
name|uniqid
operator|=
name|newsseq
expr_stmt|;
name|notenum
operator|=
name|chknote
argument_list|(
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_id
argument_list|,
operator|&
name|note2
argument_list|)
expr_stmt|;
comment|/* try normal */
if|if
condition|(
name|notenum
operator|==
literal|0
condition|)
comment|/* try -100 trick */
block|{
name|note
operator|.
name|n_id
operator|.
name|uniqid
operator|=
name|newsid
operator|.
name|uniqid
operator|=
name|newsseq
operator|*
operator|-
literal|100
expr_stmt|;
name|notenum
operator|=
name|chknote
argument_list|(
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_id
argument_list|,
operator|&
name|note2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|notenum
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|note2
operator|.
name|n_stat
operator|&
name|ORPHND
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Duplicate news article received\n"
argument_list|)
expr_stmt|;
name|io
operator|->
name|nnotdrop
operator|++
expr_stmt|;
comment|/* count as dropped */
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* done with it */
block|}
comment|/*  	 *	 replace foster parent 	 */
name|pagein
argument_list|(
name|io
argument_list|,
name|body
argument_list|,
operator|&
name|note2
operator|.
name|n_addr
argument_list|)
expr_stmt|;
comment|/* collect text */
name|gettime
argument_list|(
operator|&
name|note2
operator|.
name|n_rcvd
argument_list|)
expr_stmt|;
comment|/* current tod */
name|gettime
argument_list|(
operator|&
name|note2
operator|.
name|n_lmod
argument_list|)
expr_stmt|;
comment|/* last touched */
name|copyauth
argument_list|(
operator|&
name|auth
argument_list|,
name|note2
operator|.
name|n_auth
argument_list|)
expr_stmt|;
comment|/* fill in author */
name|note2
operator|.
name|n_stat
operator||=
name|FRMNEWS
expr_stmt|;
comment|/* brand it */
name|strncpy
argument_list|(
name|note2
operator|.
name|ntitle
argument_list|,
name|title
argument_list|,
name|TITLEN
argument_list|)
expr_stmt|;
comment|/* move title */
name|note2
operator|.
name|n_date
operator|=
name|entered
expr_stmt|;
name|strcpy
argument_list|(
name|note2
operator|.
name|n_from
argument_list|,
name|fromsys
argument_list|)
expr_stmt|;
comment|/* who sent it to us */
name|putnrec
argument_list|(
name|io
argument_list|,
name|notenum
argument_list|,
operator|&
name|note2
argument_list|)
expr_stmt|;
comment|/* and replace */
name|io
operator|->
name|adopted
operator|++
expr_stmt|;
comment|/* count it */
name|io
operator|->
name|nnotrcvd
operator|++
expr_stmt|;
comment|/* count in */
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Orphaned Response Chain adopted\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|notenum
operator|)
return|;
comment|/* correctly placed */
block|}
comment|/*  *	See if we can turn this into a response to some base note.  *	First priority is to match it to any of the articles listed  *	in a References field if there is one.  */
name|notenum
operator|=
literal|0
expr_stmt|;
comment|/* init to not found */
if|if
condition|(
name|header
operator|->
name|followid
index|[
literal|0
index|]
condition|)
comment|/* references */
block|{
name|trail
operator|=
name|header
operator|->
name|followid
expr_stmt|;
while|while
condition|(
operator|(
name|lead
operator|=
name|index
argument_list|(
name|trail
argument_list|,
literal|'<'
argument_list|)
operator|)
operator|&&
operator|(
name|trail
operator|=
name|index
argument_list|(
name|lead
argument_list|,
literal|'>'
argument_list|)
operator|)
condition|)
block|{
comment|/* delimited id */
name|i
operator|=
name|sscanf
argument_list|(
name|lead
argument_list|,
literal|"<%ld@%99[^>]>"
argument_list|,
operator|&
name|baseseq
argument_list|,
name|field1
argument_list|,
name|pbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|2
condition|)
comment|/* try old format */
name|i
operator|=
name|sscanf
argument_list|(
name|lead
argument_list|,
literal|"%99[^.].%ld"
argument_list|,
name|field1
argument_list|,
operator|&
name|baseseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|2
condition|)
continue|continue;
comment|/* try next one */
name|strncpy
argument_list|(
name|basesys
argument_list|,
name|field1
argument_list|,
name|SYSSZ
argument_list|)
expr_stmt|;
name|basesys
index|[
name|SYSSZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* and truncate */
name|strcpy
argument_list|(
name|baseid
operator|.
name|sys
argument_list|,
name|basesys
argument_list|)
expr_stmt|;
comment|/* build goal */
name|baseid
operator|.
name|uniqid
operator|=
name|baseseq
expr_stmt|;
comment|/* try notes source */
if|if
condition|(
operator|(
name|notenum
operator|=
name|chknote
argument_list|(
name|io
argument_list|,
operator|&
name|baseid
argument_list|,
operator|&
name|note2
argument_list|)
operator|)
condition|)
comment|/* WANT ASSIGN */
break|break;
comment|/* yes! */
name|baseid
operator|.
name|uniqid
operator|=
name|baseseq
operator|*
operator|-
literal|100
expr_stmt|;
comment|/* try news source */
if|if
condition|(
operator|(
name|notenum
operator|=
name|chknote
argument_list|(
name|io
argument_list|,
operator|&
name|baseid
argument_list|,
operator|&
name|note2
argument_list|)
operator|)
condition|)
comment|/* WANT ASSIGN */
break|break;
comment|/* yes! */
name|notenum
operator|=
literal|0
expr_stmt|;
comment|/* ensure "unfound" */
block|}
block|}
comment|/*  *	If References did any good, "notenum" is positive non-zero.  *	Otherwise it didn't help out at all and we have to resort to  *	parsing the title for "re:" prefixes  *	If we can find a base title, use the title search code to  *	scan for it.  */
if|if
condition|(
name|notenum
operator|==
literal|0
operator|&&
comment|/* not found */
operator|!
name|strncmp
argument_list|(
name|header
operator|->
name|title
argument_list|,
literal|"re: "
argument_list|,
literal|4
argument_list|)
operator|||
comment|/* and looks like */
operator|!
name|strncmp
argument_list|(
name|header
operator|->
name|title
argument_list|,
literal|"Re: "
argument_list|,
literal|4
argument_list|)
operator|||
comment|/* a response */
operator|!
name|strncmp
argument_list|(
name|header
operator|->
name|title
argument_list|,
literal|"RE: "
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|"Looking at titles\n"
argument_list|)
expr_stmt|;
name|p
operator|=
name|header
operator|->
name|title
expr_stmt|;
do|do
block|{
for|for
control|(
name|p
operator|+=
literal|3
init|;
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|;
name|p
operator|++
control|)
empty_stmt|;
comment|/* drop spaces */
block|}
do|while
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"re: "
argument_list|,
literal|4
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"Re: "
argument_list|,
literal|4
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"RE: "
argument_list|,
literal|4
argument_list|)
condition|)
do|;
name|strncpy
argument_list|(
name|io
operator|->
name|xstring
argument_list|,
name|p
argument_list|,
name|TITLEN
argument_list|)
expr_stmt|;
comment|/* load it */
name|io
operator|->
name|xstring
index|[
name|TITLEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* and terminate it */
name|notenum
operator|=
name|findtitle
argument_list|(
name|io
argument_list|,
name|io
operator|->
name|descr
operator|.
name|d_nnote
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* start at back */
if|if
condition|(
name|notenum
operator|>
literal|0
condition|)
comment|/* found one */
name|getnrec
argument_list|(
name|io
argument_list|,
name|notenum
argument_list|,
operator|&
name|note2
argument_list|)
expr_stmt|;
comment|/* get a ptr to it */
block|}
comment|/*  *	OK. By now, we have a "notenum" if the article can be pegged  *	as a response to one of our notes.  *	Otherwise, notenum==0 and we'll have to turn it into  *	a base note.  */
if|if
condition|(
name|notenum
operator|>
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|"Looking in response chain for note %d\n"
argument_list|,
name|notenum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chkresp
argument_list|(
name|io
argument_list|,
operator|&
name|newsid
argument_list|,
operator|&
name|note2
argument_list|,
name|notenum
argument_list|)
condition|)
block|{
comment|/* no copy here */
name|pagein
argument_list|(
name|io
argument_list|,
name|body
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|whentime
argument_list|)
expr_stmt|;
name|i
operator|=
name|putresp
argument_list|(
name|io
argument_list|,
operator|&
name|where
argument_list|,
name|status
argument_list|,
name|notenum
argument_list|,
operator|&
name|entered
argument_list|,
operator|&
name|auth
argument_list|,
operator|&
name|note
argument_list|,
name|NOLOCKIT
argument_list|,
operator|&
name|newsid
argument_list|,
name|NOADDID
argument_list|,
name|fromsys
argument_list|,
name|ADDTIME
argument_list|,
operator|&
name|whentime
argument_list|)
expr_stmt|;
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* un-MUTEX */
return|return
operator|(
name|i
operator|)
return|;
block|}
else|else
block|{
comment|/* copy there */
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* all done */
name|printf
argument_list|(
literal|"Duplicate Response handed back by news\n"
argument_list|)
expr_stmt|;
name|io
operator|->
name|nrspdrop
operator|++
expr_stmt|;
comment|/* bong it */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* count as done */
block|}
block|}
comment|/*  *	If we are going to do things this way, here is the point  *	where we should check about turning a news-generated   *	article into an orphaned response.  *  *	Basically, look for a non-empty references line and  *	make a foster parent with the first article id on that  *	line.  */
comment|/*  *	by this point, it's obvious that we can't turn the note into  *	a response.  We can skip the check to see if it is already  *	there because we did that at the very top of this loop  *	and since we've locked the notesfile up while we're doing this,  *	we know that nobody added a note.  */
name|dprintf
argument_list|(
literal|"Processing article as a base note\n"
argument_list|)
expr_stmt|;
name|pagein
argument_list|(
name|io
argument_list|,
name|body
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|notenum
operator|=
name|putnote
argument_list|(
name|io
argument_list|,
operator|&
name|where
argument_list|,
name|title
argument_list|,
name|status
argument_list|,
operator|&
name|note
argument_list|,
operator|&
name|auth
argument_list|,
name|NOPOLICY
argument_list|,
name|NOLOCKIT
argument_list|,
name|NOADDID
argument_list|,
name|fromsys
argument_list|,
name|ADDTIME
argument_list|)
expr_stmt|;
name|io
operator|->
name|nnotrcvd
operator|++
expr_stmt|;
comment|/* count it */
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
return|return
operator|(
name|notenum
operator|)
return|;
block|}
end_block

end_unit

