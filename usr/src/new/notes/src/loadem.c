begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: loadem.c,v 1.7.0.1 85/04/11 09:23:51 notes Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|RCSIDENT
end_endif

begin_comment
comment|/*  *	load a file of generic notes.  *	This routine will read the file supplied ( as an fid )     *	and place it into the notefile.  *	locking is supressed if the lockit flag is false  *	uids are mapped to zero if the system that the note came from  *	does not match the local system.  *  *	Original coding:	Ray Essick	December 1981  *	Recoding:		Ray Essick	March 1984  *				Streamlining, prepare for alternate protocols  */
end_comment

begin_comment
comment|/*  *	routines for loading notes and responses  */
end_comment

begin_function_decl
specifier|extern
name|int
name|loadnote
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* proto 0 note */
end_comment

begin_function_decl
specifier|extern
name|int
name|loadresp
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* proto 0 resp */
end_comment

begin_function_decl
specifier|extern
name|int
name|ldnote1
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* proto 1 note */
end_comment

begin_function_decl
specifier|extern
name|int
name|ldresp1
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* proto 1 resp */
end_comment

begin_comment
comment|/*  *	jump tables pointing to the proper routines to parse  *	notes and responses in the assorted protocols  */
end_comment

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|noteproto
index|[]
function_decl|)
parameter_list|()
init|=
comment|/* notes */
block|{
name|loadnote
block|}
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|respproto
index|[]
function_decl|)
parameter_list|()
init|=
comment|/* responses */
block|{
name|loadresp
block|}
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|nproto
init|=
sizeof|sizeof
name|noteproto
operator|/
sizeof|sizeof
name|noteproto
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rproto
init|=
sizeof|sizeof
name|respproto
operator|/
sizeof|sizeof
name|respproto
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|loadem
argument_list|(
argument|io
argument_list|,
argument|infile
argument_list|,
argument|lockit
argument_list|,
argument|whofrom
argument_list|,
argument|extensive
argument_list|,
argument|articles
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|infile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|whofrom
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|oneline
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* hold a line */
name|char
name|articletype
index|[
literal|32
index|]
decl_stmt|;
comment|/* proto switching */
name|int
name|proto
decl_stmt|;
comment|/* dynamic protocol */
name|int
name|loaded
decl_stmt|;
comment|/* article count */
name|loaded
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|loaded
operator|!=
name|articles
operator|&&
comment|/* if want more */
name|fgets
argument_list|(
name|oneline
argument_list|,
sizeof|sizeof
argument_list|(
name|oneline
argument_list|)
operator|-
literal|1
argument_list|,
name|infile
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
switch|switch
condition|(
name|oneline
index|[
literal|0
index|]
condition|)
comment|/* what is it */
block|{
case|case
literal|'N'
case|:
comment|/* proto 1 note */
name|loadnote
argument_list|(
name|io
argument_list|,
name|oneline
argument_list|,
name|whofrom
argument_list|,
name|extensive
argument_list|,
name|lockit
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|loaded
operator|++
expr_stmt|;
comment|/* count it */
break|break;
case|case
literal|'R'
case|:
comment|/* proto 1 response */
name|loadresp
argument_list|(
name|io
argument_list|,
name|oneline
argument_list|,
name|whofrom
argument_list|,
name|extensive
argument_list|,
name|lockit
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|loaded
operator|++
expr_stmt|;
comment|/* count */
break|break;
comment|/*  *	Code to catch later protocols.  This is currently unimplemented  */
case|case
literal|'P'
case|:
comment|/* newer protocol */
name|sscanf
argument_list|(
name|oneline
argument_list|,
literal|"Protocol: %d %s"
argument_list|,
operator|&
name|proto
argument_list|,
name|articletype
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|==
literal|0
condition|)
comment|/* old protocol */
break|break;
comment|/* to while() loop */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|articletype
argument_list|,
literal|"Note"
argument_list|)
condition|)
block|{
if|if
condition|(
name|proto
operator|<
name|nproto
condition|)
comment|/* exists */
call|(
modifier|*
name|noteproto
index|[
name|proto
index|]
call|)
argument_list|(
name|io
argument_list|,
name|whofrom
argument_list|,
name|extensive
argument_list|,
name|lockit
argument_list|,
name|infile
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Unsupported note protocol %d\n"
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* assume response */
block|{
if|if
condition|(
name|proto
operator|<
name|rproto
condition|)
comment|/* exists */
call|(
modifier|*
name|respproto
index|[
name|proto
index|]
call|)
argument_list|(
name|io
argument_list|,
name|whofrom
argument_list|,
name|extensive
argument_list|,
name|lockit
argument_list|,
name|infile
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Unsupported response protocol %d\n"
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
default|default:
comment|/* bong it */
name|x
argument_list|(
literal|1
argument_list|,
literal|"loadem: Bad generic format"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  *	loadnote(line,infile)  *  *	Load a note in protocol 1. line points to the first line  *	of the article's header.  */
end_comment

begin_macro
name|loadnote
argument_list|(
argument|io
argument_list|,
argument|firstline
argument_list|,
argument|whofrom
argument_list|,
argument|extensive
argument_list|,
argument|lockit
argument_list|,
argument|infile
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|firstline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|whofrom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|infile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|oneline
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* hold lines */
name|long
name|count
decl_stmt|;
name|long
name|count2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|title
index|[
name|TITLEN
index|]
decl_stmt|;
name|struct
name|note_f
name|note
decl_stmt|,
name|note2
decl_stmt|;
name|struct
name|id_f
name|noteid
decl_stmt|;
name|struct
name|daddr_f
name|where
decl_stmt|;
name|struct
name|auth_f
name|auth
decl_stmt|;
name|int
name|posit
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|fields
decl_stmt|;
comment|/* scanf retcodes */
name|char
name|field1
index|[
literal|101
index|]
decl_stmt|,
comment|/* scanf temps */
name|field2
index|[
literal|100
index|]
decl_stmt|;
comment|/*  *	grab unique id (sys,integer). Ignore "number of responses"  */
name|sscanf
argument_list|(
name|firstline
argument_list|,
literal|"N:%99[^:]:%ld"
argument_list|,
name|field1
argument_list|,
operator|&
name|noteid
operator|.
name|uniqid
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|noteid
operator|.
name|sys
argument_list|,
name|field1
argument_list|,
name|SYSSZ
argument_list|)
expr_stmt|;
name|noteid
operator|.
name|sys
index|[
name|SYSSZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate */
name|fgets
argument_list|(
name|oneline
argument_list|,
sizeof|sizeof
argument_list|(
name|oneline
argument_list|)
operator|-
literal|1
argument_list|,
name|infile
argument_list|)
expr_stmt|;
comment|/* title */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|TITLEN
operator|)
operator|&&
name|oneline
index|[
name|i
index|]
operator|&&
operator|(
name|oneline
index|[
name|i
index|]
operator|!=
literal|'\n'
operator|)
condition|;
name|i
operator|++
control|)
name|title
index|[
name|i
index|]
operator|=
name|oneline
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|TITLEN
condition|)
name|title
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|title
index|[
name|TITLEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* make sure it stops */
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|title
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
name|title
index|[
name|i
index|]
operator|==
literal|' '
condition|;
name|i
operator|--
control|)
name|title
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* chop trailing spaces */
name|fgets
argument_list|(
name|oneline
argument_list|,
sizeof|sizeof
argument_list|(
name|oneline
argument_list|)
operator|-
literal|1
argument_list|,
name|infile
argument_list|)
expr_stmt|;
comment|/* author */
name|fields
operator|=
name|sscanf
argument_list|(
name|oneline
argument_list|,
literal|"%99[^:]:%d:%99[^:]:"
argument_list|,
name|field1
argument_list|,
operator|&
name|auth
operator|.
name|aid
argument_list|,
name|field2
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|auth
operator|.
name|aname
argument_list|,
name|field1
argument_list|,
name|NAMESZ
argument_list|)
expr_stmt|;
name|auth
operator|.
name|aname
index|[
name|NAMESZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* shift name */
if|if
condition|(
name|fields
operator|<
literal|3
condition|)
comment|/* no home system -- */
block|{
name|strcpy
argument_list|(
name|auth
operator|.
name|asystem
argument_list|,
name|noteid
operator|.
name|sys
argument_list|)
expr_stmt|;
comment|/* use unique id */
block|}
else|else
block|{
name|strncpy
argument_list|(
name|auth
operator|.
name|asystem
argument_list|,
name|field2
argument_list|,
name|HOMESYSSZ
argument_list|)
expr_stmt|;
name|auth
operator|.
name|asystem
index|[
name|HOMESYSSZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate */
block|}
name|auth
operator|.
name|aid
operator|&=
name|UIDMASK
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|System
argument_list|,
name|noteid
operator|.
name|sys
argument_list|)
operator|!=
literal|0
condition|)
comment|/* map non-local to */
name|auth
operator|.
name|aid
operator|=
name|Anonuid
expr_stmt|;
comment|/* local anonymous */
name|fgets
argument_list|(
name|oneline
argument_list|,
sizeof|sizeof
argument_list|(
name|oneline
argument_list|)
operator|-
literal|1
argument_list|,
name|infile
argument_list|)
expr_stmt|;
comment|/* time written */
name|timein
argument_list|(
name|oneline
argument_list|,
operator|&
name|note
operator|.
name|n_date
argument_list|)
expr_stmt|;
comment|/* fills in if bad */
if|if
condition|(
name|extensive
condition|)
comment|/* if reloading */
block|{
name|fgets
argument_list|(
name|oneline
argument_list|,
sizeof|sizeof
argument_list|(
name|oneline
argument_list|)
operator|-
literal|1
argument_list|,
name|infile
argument_list|)
expr_stmt|;
comment|/* received */
name|timein
argument_list|(
name|oneline
argument_list|,
operator|&
name|note
operator|.
name|n_rcvd
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|oneline
argument_list|,
sizeof|sizeof
argument_list|(
name|oneline
argument_list|)
operator|-
literal|1
argument_list|,
name|infile
argument_list|)
expr_stmt|;
comment|/* last modified */
name|timein
argument_list|(
name|oneline
argument_list|,
operator|&
name|note
operator|.
name|n_lmod
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|oneline
argument_list|,
sizeof|sizeof
argument_list|(
name|oneline
argument_list|)
operator|-
literal|1
argument_list|,
name|infile
argument_list|)
expr_stmt|;
comment|/* from */
name|sscanf
argument_list|(
name|oneline
argument_list|,
literal|"%s"
argument_list|,
name|field1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|note
operator|.
name|n_from
argument_list|,
name|field1
argument_list|,
name|SYSSZ
argument_list|)
expr_stmt|;
name|note
operator|.
name|n_from
index|[
name|SYSSZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* make sure */
block|}
else|else
block|{
name|strcpy
argument_list|(
name|note
operator|.
name|n_from
argument_list|,
name|whofrom
argument_list|)
expr_stmt|;
comment|/* who gave it to us */
block|}
do|do
block|{
name|fgets
argument_list|(
name|oneline
argument_list|,
sizeof|sizeof
argument_list|(
name|oneline
argument_list|)
operator|-
literal|1
argument_list|,
name|infile
argument_list|)
expr_stmt|;
comment|/* status */
comment|/*  	 * old code forgot that fgets keeps the newline and didn't 	 * remove it before a strcpy. result is that we have a bunch 	 * of notesfiles with "\n" in the n_from field. This 	 * lets a nfdump/nfload cycle clear them up for us. 	 */
block|}
do|while
condition|(
name|oneline
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
do|;
comment|/* fix old bug */
name|sscanf
argument_list|(
name|oneline
argument_list|,
literal|"%o:%ld"
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|extensive
operator|==
literal|0
condition|)
comment|/* if not reloading */
block|{
name|getperms
argument_list|(
name|io
argument_list|,
literal|1
argument_list|,
name|noteid
operator|.
name|sys
argument_list|)
expr_stmt|;
comment|/* check permission */
if|if
condition|(
operator|!
name|allow
argument_list|(
name|io
argument_list|,
name|WRITOK
argument_list|)
condition|)
comment|/* not allowed */
block|{
name|io
operator|->
name|nnotdrop
operator|++
expr_stmt|;
comment|/* drop it */
for|for
control|(
name|count2
operator|=
literal|0
init|;
name|count2
operator|<
name|count
condition|;
name|count2
operator|++
control|)
comment|/* drop message */
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* ignore the character */
return|return;
comment|/* back for another */
block|}
block|}
if|if
condition|(
name|lockit
condition|)
name|locknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* lock us up now */
name|posit
operator|=
name|chknote
argument_list|(
name|io
argument_list|,
operator|&
name|noteid
argument_list|,
operator|&
name|note2
argument_list|)
expr_stmt|;
comment|/* see if here */
if|if
condition|(
name|posit
operator|==
literal|0
condition|)
comment|/* not in data base */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYSSZ
condition|;
name|i
operator|++
control|)
name|note
operator|.
name|n_id
operator|.
name|sys
index|[
name|i
index|]
operator|=
name|noteid
operator|.
name|sys
index|[
name|i
index|]
expr_stmt|;
name|note
operator|.
name|n_id
operator|.
name|uniqid
operator|=
name|noteid
operator|.
name|uniqid
expr_stmt|;
comment|/* copy unique id in */
name|puttrec
argument_list|(
name|io
argument_list|,
name|infile
argument_list|,
operator|&
name|where
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* suck text */
name|putnote
argument_list|(
name|io
argument_list|,
operator|&
name|where
argument_list|,
name|title
argument_list|,
name|status
argument_list|,
operator|&
name|note
argument_list|,
operator|&
name|auth
argument_list|,
name|NOPOLICY
argument_list|,
name|NOLOCKIT
argument_list|,
name|NOADDID
argument_list|,
name|note
operator|.
name|n_from
argument_list|,
operator|(
name|extensive
operator|==
name|NODETAIL
operator|)
argument_list|)
expr_stmt|;
name|io
operator|->
name|nnotrcvd
operator|++
expr_stmt|;
comment|/* count as a recieved */
block|}
else|else
block|{
comment|/*  *	A copy exists. See if the one here is an orphan and possibly  *	replace it  */
if|if
condition|(
operator|(
name|note2
operator|.
name|n_stat
operator|&
name|ORPHND
operator|)
operator|&&
name|NOT
argument_list|(
name|status
operator|&
name|ORPHND
argument_list|)
condition|)
block|{
comment|/* extant is orphan */
comment|/* new one isn't */
name|puttrec
argument_list|(
name|io
argument_list|,
name|infile
argument_list|,
operator|&
name|note2
operator|.
name|n_addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* suck text */
name|gettime
argument_list|(
operator|&
name|note2
operator|.
name|n_rcvd
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|note2
operator|.
name|n_lmod
argument_list|)
expr_stmt|;
comment|/* time stamp it */
name|copyauth
argument_list|(
operator|&
name|auth
argument_list|,
operator|&
name|note2
operator|.
name|n_auth
argument_list|)
expr_stmt|;
comment|/* load author */
name|note2
operator|.
name|n_stat
operator|=
name|status
expr_stmt|;
comment|/* correct status */
name|strncpy
argument_list|(
name|note2
operator|.
name|ntitle
argument_list|,
name|title
argument_list|,
name|TITLEN
argument_list|)
expr_stmt|;
name|copydate
argument_list|(
operator|&
name|note
operator|.
name|n_date
argument_list|,
operator|&
name|note2
operator|.
name|n_date
argument_list|)
expr_stmt|;
name|strmove
argument_list|(
name|note
operator|.
name|n_from
argument_list|,
name|note2
operator|.
name|n_from
argument_list|)
expr_stmt|;
name|putnrec
argument_list|(
name|io
argument_list|,
name|posit
argument_list|,
operator|&
name|note2
argument_list|)
expr_stmt|;
comment|/* and replace */
name|io
operator|->
name|adopted
operator|++
expr_stmt|;
comment|/* orphan adopted */
name|printf
argument_list|(
literal|"Foster Parent Replaced. Id=%ld@%s\n"
argument_list|,
name|noteid
operator|.
name|uniqid
argument_list|,
name|noteid
operator|.
name|sys
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|count2
operator|=
literal|0
init|;
name|count2
operator|<
name|count
condition|;
name|count2
operator|++
control|)
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* skip text */
name|printf
argument_list|(
literal|"Duplicate note recieved id=%ld@%s\n"
argument_list|,
name|noteid
operator|.
name|uniqid
argument_list|,
name|noteid
operator|.
name|sys
argument_list|)
expr_stmt|;
name|io
operator|->
name|nnotdrop
operator|++
expr_stmt|;
comment|/* count a dropped */
block|}
block|}
if|if
condition|(
name|lockit
condition|)
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* release lock */
block|}
end_block

begin_comment
comment|/*  *	loadresp(firstline,infile)  *  *	load a protocol 1 response  */
end_comment

begin_macro
name|loadresp
argument_list|(
argument|io
argument_list|,
argument|firstline
argument_list|,
argument|whofrom
argument_list|,
argument|extensive
argument_list|,
argument|lockit
argument_list|,
argument|infile
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|firstline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|whofrom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|infile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|oneline
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|long
name|count
decl_stmt|;
name|long
name|count2
decl_stmt|;
name|struct
name|note_f
name|note
decl_stmt|;
name|struct
name|id_f
name|noteid
decl_stmt|,
name|respid
decl_stmt|;
name|struct
name|auth_f
name|auth
decl_stmt|;
name|struct
name|daddr_f
name|where
decl_stmt|;
name|struct
name|when_f
name|ztime
decl_stmt|,
name|ztime2
decl_stmt|;
name|char
name|zfrom
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* usually<10 */
name|int
name|status
decl_stmt|;
name|int
name|fosterstat
decl_stmt|;
name|int
name|posit
decl_stmt|;
name|int
name|fields
decl_stmt|;
comment|/* scanf return codes */
name|char
name|field1
index|[
literal|100
index|]
decl_stmt|,
comment|/* scanf temps */
name|field2
index|[
literal|100
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/*  *	parse the parent id and the response id.  */
name|sscanf
argument_list|(
name|firstline
argument_list|,
literal|"R:%99[^:]:%ld:%99[^:]:%ld"
argument_list|,
name|field1
argument_list|,
operator|&
name|noteid
operator|.
name|uniqid
argument_list|,
name|field2
argument_list|,
operator|&
name|respid
operator|.
name|uniqid
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|noteid
operator|.
name|sys
argument_list|,
name|field1
argument_list|,
name|SYSSZ
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|respid
operator|.
name|sys
argument_list|,
name|field2
argument_list|,
name|SYSSZ
argument_list|)
expr_stmt|;
name|noteid
operator|.
name|sys
index|[
name|SYSSZ
operator|-
literal|1
index|]
operator|=
name|respid
operator|.
name|sys
index|[
name|SYSSZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fgets
argument_list|(
name|oneline
argument_list|,
sizeof|sizeof
argument_list|(
name|oneline
argument_list|)
operator|-
literal|1
argument_list|,
name|infile
argument_list|)
expr_stmt|;
comment|/* author */
name|fields
operator|=
name|sscanf
argument_list|(
name|oneline
argument_list|,
literal|"%99[^:]:%d:%99[^:]:"
argument_list|,
name|field1
argument_list|,
operator|&
name|auth
operator|.
name|aid
argument_list|,
name|field2
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|auth
operator|.
name|aname
argument_list|,
name|field1
argument_list|,
name|NAMESZ
argument_list|)
expr_stmt|;
comment|/* shift and */
name|auth
operator|.
name|aname
index|[
name|NAMESZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate */
if|if
condition|(
name|fields
operator|<
literal|3
condition|)
comment|/* no home system */
block|{
name|strcpy
argument_list|(
name|auth
operator|.
name|asystem
argument_list|,
name|respid
operator|.
name|sys
argument_list|)
expr_stmt|;
comment|/* use unique id */
block|}
else|else
block|{
name|strncpy
argument_list|(
name|auth
operator|.
name|asystem
argument_list|,
name|field2
argument_list|,
name|HOMESYSSZ
argument_list|)
expr_stmt|;
name|auth
operator|.
name|asystem
index|[
name|HOMESYSSZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|auth
operator|.
name|aid
operator|&=
name|UIDMASK
expr_stmt|;
comment|/* mask appropriately */
if|if
condition|(
name|strcmp
argument_list|(
name|System
argument_list|,
name|note
operator|.
name|n_id
operator|.
name|sys
argument_list|)
operator|!=
literal|0
condition|)
comment|/* map non-local to */
name|auth
operator|.
name|aid
operator|=
name|Anonuid
expr_stmt|;
comment|/* local anonymous */
name|fgets
argument_list|(
name|oneline
argument_list|,
sizeof|sizeof
argument_list|(
name|oneline
argument_list|)
operator|-
literal|1
argument_list|,
name|infile
argument_list|)
expr_stmt|;
comment|/* date written */
name|timein
argument_list|(
name|oneline
argument_list|,
operator|&
name|ztime
argument_list|)
expr_stmt|;
if|if
condition|(
name|extensive
condition|)
comment|/* if reloading */
block|{
name|fgets
argument_list|(
name|oneline
argument_list|,
sizeof|sizeof
argument_list|(
name|oneline
argument_list|)
operator|-
literal|1
argument_list|,
name|infile
argument_list|)
expr_stmt|;
comment|/* date received */
name|timein
argument_list|(
name|oneline
argument_list|,
operator|&
name|ztime2
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|oneline
argument_list|,
sizeof|sizeof
argument_list|(
name|oneline
argument_list|)
operator|-
literal|1
argument_list|,
name|infile
argument_list|)
expr_stmt|;
comment|/* received from */
name|sscanf
argument_list|(
name|oneline
argument_list|,
literal|"%s"
argument_list|,
name|field1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|zfrom
argument_list|,
name|field1
argument_list|,
name|SYSSZ
argument_list|)
expr_stmt|;
name|zfrom
index|[
name|SYSSZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* make sure */
block|}
else|else
block|{
name|strcpy
argument_list|(
name|zfrom
argument_list|,
name|whofrom
argument_list|)
expr_stmt|;
comment|/* who gave it to us */
block|}
do|do
block|{
name|fgets
argument_list|(
name|oneline
argument_list|,
sizeof|sizeof
argument_list|(
name|oneline
argument_list|)
operator|-
literal|1
argument_list|,
name|infile
argument_list|)
expr_stmt|;
comment|/* status */
comment|/*  	 * old code forgot that fgets keeps the newline and didn't 	 * remove it before a strcpy. result is that we have a bunch 	 * of notesfiles with "\n" in the n_from field. This 	 * lets a nfdump/nfload cycle clear them up for us. 	 */
block|}
do|while
condition|(
name|oneline
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
do|;
comment|/* fix old bug */
name|sscanf
argument_list|(
name|oneline
argument_list|,
literal|"%o:%ld"
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockit
condition|)
name|locknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* CRITICAL SECTION */
name|posit
operator|=
name|chknote
argument_list|(
name|io
argument_list|,
operator|&
name|noteid
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* look for daddy */
if|if
condition|(
name|posit
operator|==
literal|0
condition|)
comment|/* no daddy */
block|{
comment|/* build foster parent */
name|strcpy
argument_list|(
name|note
operator|.
name|n_id
operator|.
name|sys
argument_list|,
name|noteid
operator|.
name|sys
argument_list|)
expr_stmt|;
name|note
operator|.
name|n_id
operator|.
name|uniqid
operator|=
name|noteid
operator|.
name|uniqid
expr_stmt|;
name|note
operator|.
name|n_nresp
operator|=
literal|0
expr_stmt|;
name|note
operator|.
name|n_auth
operator|.
name|aid
operator|=
name|Anonuid
expr_stmt|;
name|strcpy
argument_list|(
name|note
operator|.
name|n_auth
operator|.
name|aname
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|note
operator|.
name|n_auth
operator|.
name|asystem
argument_list|,
name|note
operator|.
name|n_id
operator|.
name|sys
argument_list|)
expr_stmt|;
comment|/* use unique id */
name|copydate
argument_list|(
operator|&
name|ztime
argument_list|,
operator|&
name|note
operator|.
name|n_date
argument_list|)
expr_stmt|;
name|fosterstat
operator|=
name|ORPHND
expr_stmt|;
comment|/* mark as foster */
name|strcpy
argument_list|(
name|note
operator|.
name|ntitle
argument_list|,
literal|"Orphaned Response"
argument_list|)
expr_stmt|;
name|where
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
comment|/* no text */
name|where
operator|.
name|textlen
operator|=
literal|0
expr_stmt|;
name|posit
operator|=
name|putnote
argument_list|(
name|io
argument_list|,
operator|&
name|where
argument_list|,
name|note
operator|.
name|ntitle
argument_list|,
name|fosterstat
argument_list|,
operator|&
name|note
argument_list|,
operator|&
name|note
operator|.
name|n_auth
argument_list|,
name|NOPOLICY
argument_list|,
name|NOLOCKIT
argument_list|,
name|NOADDID
argument_list|,
name|whofrom
argument_list|,
name|ADDTIME
argument_list|)
expr_stmt|;
name|io
operator|->
name|norphans
operator|++
expr_stmt|;
comment|/* count orphans */
name|printf
argument_list|(
literal|"Response Id=%ld@%s is an orphan of note Id=%ld@%s\n"
argument_list|,
name|respid
operator|.
name|uniqid
argument_list|,
name|respid
operator|.
name|sys
argument_list|,
name|noteid
operator|.
name|uniqid
argument_list|,
name|noteid
operator|.
name|sys
argument_list|)
expr_stmt|;
block|}
comment|/*  *	we definitely have a parent here, since we either found one  *	or created one  */
if|if
condition|(
name|chkresp
argument_list|(
name|io
argument_list|,
operator|&
name|respid
argument_list|,
operator|&
name|note
argument_list|,
name|posit
argument_list|)
operator|==
literal|0
condition|)
comment|/* response here */
block|{
if|if
condition|(
name|extensive
operator|==
literal|0
condition|)
comment|/* if not reloading */
name|getperms
argument_list|(
name|io
argument_list|,
literal|1
argument_list|,
name|respid
operator|.
name|sys
argument_list|)
expr_stmt|;
comment|/* can he? */
if|if
condition|(
name|allow
argument_list|(
name|io
argument_list|,
name|RESPOK
argument_list|)
operator|||
name|extensive
condition|)
block|{
name|puttrec
argument_list|(
name|io
argument_list|,
name|infile
argument_list|,
operator|&
name|where
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* read text */
name|putresp
argument_list|(
name|io
argument_list|,
operator|&
name|where
argument_list|,
name|status
argument_list|,
name|posit
argument_list|,
operator|&
name|ztime
argument_list|,
operator|&
name|auth
argument_list|,
operator|&
name|note
argument_list|,
literal|0
argument_list|,
operator|&
name|respid
argument_list|,
literal|0
argument_list|,
name|zfrom
argument_list|,
operator|(
name|extensive
operator|==
name|NODETAIL
operator|)
argument_list|,
operator|&
name|ztime2
argument_list|)
expr_stmt|;
name|io
operator|->
name|nrsprcvd
operator|++
expr_stmt|;
comment|/* he is a rcvd ! */
block|}
else|else
block|{
comment|/* no permission */
name|io
operator|->
name|nrspdrop
operator|++
expr_stmt|;
comment|/* dropped */
for|for
control|(
name|count2
operator|=
literal|0
init|;
name|count2
operator|<
name|count
condition|;
name|count2
operator|++
control|)
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* skip text */
block|}
block|}
else|else
block|{
comment|/* copy already here */
name|io
operator|->
name|nrspdrop
operator|++
expr_stmt|;
comment|/* on the floor */
for|for
control|(
name|count2
operator|=
literal|0
init|;
name|count2
operator|<
name|count
condition|;
name|count2
operator|++
control|)
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* skip text */
name|printf
argument_list|(
literal|"Duplicate response id=%ld@%s to note id=%ld@%s\n"
argument_list|,
name|respid
operator|.
name|uniqid
argument_list|,
name|respid
operator|.
name|sys
argument_list|,
name|noteid
operator|.
name|uniqid
argument_list|,
name|noteid
operator|.
name|sys
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lockit
condition|)
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* no longer critical */
block|}
end_block

end_unit

