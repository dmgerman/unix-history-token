begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FASTSEQ
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
endif|FASTSEQ
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: control.c,v 1.7 85/01/18 15:07:18 notes Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|RCSIDENT
end_endif

begin_comment
comment|/*  *	Code in this module ( control.c) is designed to process  *	a single notefile. Its paramters include the name of  *	the notefile to process and whether to use the sequencer.  *  *	Original author: Rob Kolstad	Winter, 1980.  *	Modifications:	Ray Essick	December, 1981.  *  */
end_comment

begin_macro
name|control
argument_list|(
argument|nfname
argument_list|,
argument|seqon
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|nfname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|io_f
name|io
decl_stmt|;
name|struct
name|note_f
name|note
decl_stmt|;
name|struct
name|when_f
name|entered
decl_stmt|;
comment|/* entry time */
name|int
name|firstdis
decl_stmt|,
name|lastdis
decl_stmt|;
comment|/* display counters */
name|int
name|readnum
decl_stmt|;
comment|/* start reading */
name|int
name|respnum
decl_stmt|;
comment|/* response to be on */
comment|/* currently 0 always */
if|if
condition|(
name|nfname
operator|==
name|NULL
operator|||
name|nfname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* a name? */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* silly boy */
if|if
condition|(
name|intflag
condition|)
comment|/* did he hit DEL? */
return|return
operator|(
name|QUITFAST
operator|)
return|;
comment|/* prejudiced quit */
ifdef|#
directive|ifdef
name|FASTSEQ
if|if
condition|(
name|seqon
operator|!=
name|NOSEQ
operator|&&
name|seqon
operator|!=
name|EXTSEQ
condition|)
comment|/* if sequencing */
block|{
name|struct
name|when_f
name|whenvec
decl_stmt|;
name|char
name|NoteFile
index|[
name|WDLEN
index|]
decl_stmt|;
name|struct
name|stat
name|StatBuf
decl_stmt|;
if|if
condition|(
name|nfname
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
comment|/* absolute pathname */
block|{
name|getlast
argument_list|(
operator|&
name|io
operator|.
name|stime
argument_list|,
name|rindex
argument_list|(
name|nfname
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|,
name|seqon
argument_list|,
name|Seqname
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|NoteFile
argument_list|,
literal|"%s/%s"
argument_list|,
name|nfname
argument_list|,
name|TEXT
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* relative to Mstdir */
block|{
name|getlast
argument_list|(
operator|&
name|io
operator|.
name|stime
argument_list|,
name|nfname
argument_list|,
name|seqon
argument_list|,
name|Seqname
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|NoteFile
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|Mstdir
argument_list|,
name|nfname
argument_list|,
name|TEXT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|NoteFile
argument_list|,
operator|&
name|StatBuf
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|maketime
argument_list|(
operator|&
name|whenvec
argument_list|,
operator|(
name|long
operator|)
name|StatBuf
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|inorder
argument_list|(
operator|&
name|whenvec
argument_list|,
operator|&
name|io
operator|.
name|stime
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
comment|/* from Brian Redman */
name|ceol
argument_list|()
expr_stmt|;
comment|/* ... harpo!ber */
name|printf
argument_list|(
literal|"%s..."
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
endif|#
directive|endif
endif|FASTSEQ
name|gettime
argument_list|(
operator|&
name|entered
argument_list|)
expr_stmt|;
comment|/* get the entry time */
if|if
condition|(
name|init
argument_list|(
operator|&
name|io
argument_list|,
name|nfname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* get it out */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* let him read it */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|allow
argument_list|(
operator|&
name|io
argument_list|,
name|READOK
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|seqon
operator|==
name|NOSEQ
condition|)
comment|/* skip if sequencing */
block|{
name|printf
argument_list|(
literal|"You aren't allowed to read %s\n"
argument_list|,
name|io
operator|.
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|io
operator|.
name|descr
operator|.
name|d_plcy
condition|)
block|{
if|if
condition|(
name|askyn
argument_list|(
literal|"Do you wish to see the policy note (y/n)? "
argument_list|)
operator|==
literal|'y'
condition|)
block|{
name|getnrec
argument_list|(
operator|&
name|io
argument_list|,
literal|0
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* show the policy */
name|dspnote
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"There is no policy note"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allow
argument_list|(
operator|&
name|io
argument_list|,
name|WRITOK
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nYou may leave a note in the notefile\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|askyn
argument_list|(
literal|"Do you wish to leave a note (y/n) ?"
argument_list|)
operator|==
literal|'y'
condition|)
block|{
if|if
condition|(
name|addnote
argument_list|(
operator|&
name|io
argument_list|,
name|NULL
argument_list|,
literal|"Edit Note Text:"
argument_list|,
literal|"Note title: "
argument_list|,
name|NULL
argument_list|,
name|EDIT
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"Your note has been registered\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\nHit any key to continue"
argument_list|)
expr_stmt|;
name|gchar
argument_list|()
expr_stmt|;
comment|/* grab and drop it */
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* let him read it */
block|}
block|}
name|finish
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|io
operator|.
name|descr
operator|.
name|d_stat
operator|&
name|OPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Notefile %s is closed\n"
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|io
operator|.
name|descr
operator|.
name|d_stat
operator|&
name|OPEN
operator|||
name|allow
argument_list|(
operator|&
name|io
argument_list|,
name|DRCTOK
argument_list|)
condition|)
block|{
name|getlast
argument_list|(
operator|&
name|io
operator|.
name|stime
argument_list|,
name|io
operator|.
name|nf
argument_list|,
name|seqon
argument_list|,
name|Seqname
argument_list|)
expr_stmt|;
comment|/* last time here */
name|firstdis
operator|=
name|io
operator|.
name|descr
operator|.
name|d_nnote
operator|-
name|Nindex
operator|+
literal|1
expr_stmt|;
name|respnum
operator|=
literal|0
expr_stmt|;
comment|/* go to base note */
if|if
condition|(
name|inorder
argument_list|(
operator|&
name|io
operator|.
name|descr
operator|.
name|d_lastm
argument_list|,
operator|&
name|io
operator|.
name|stime
argument_list|)
operator|&&
operator|(
name|seqon
operator|!=
name|EXTSEQ
operator|)
condition|)
comment|/* always enter mode */
comment|/*	    if sequencer is off, stime is jan 1 1970, so will enter notefile */
block|{
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
comment|/* from Brian Redman */
name|ceol
argument_list|()
expr_stmt|;
comment|/* ... harpo!ber */
name|printf
argument_list|(
literal|"%s..."
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* force it out */
ifdef|#
directive|ifdef
name|FASTSEQ
comment|/*  *	Update his timestamp here so that he will fall through the  *	fast processing loop next time. Thanks to Rob Kolstad for  *	thinking this through.  */
name|fixlast
argument_list|(
operator|&
name|entered
argument_list|,
name|io
operator|.
name|nf
argument_list|,
name|seqon
argument_list|,
name|Seqname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|FASTSEQ
name|closenf
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
comment|/* close nicely */
return|return
literal|0
return|;
comment|/* "normal" quit */
block|}
else|else
comment|/* enter the notesfile */
block|{
if|if
condition|(
name|seqon
operator|!=
name|INDXSEQ
operator|&&
name|seqon
operator|!=
name|NOSEQ
condition|)
comment|/* if to note */
block|{
if|if
condition|(
operator|(
name|readnum
operator|=
name|nxtnote
argument_list|(
operator|&
name|io
argument_list|,
literal|0
argument_list|,
operator|&
name|io
operator|.
name|stime
argument_list|)
operator|)
operator|>
literal|0
condition|)
goto|goto
name|seqenter
goto|;
block|}
comment|/* else to index */
while|while
condition|(
literal|1
condition|)
block|{
name|prntind
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|firstdis
argument_list|,
operator|&
name|lastdis
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|readnum
operator|=
name|indx
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|firstdis
argument_list|,
operator|&
name|lastdis
argument_list|,
operator|&
name|respnum
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|readnum
operator|<
operator|-
literal|1
condition|)
break|break;
name|seqenter
label|:
comment|/* entry point if sequencer on */
name|readnum
operator|=
name|readem
argument_list|(
operator|&
name|io
argument_list|,
name|readnum
argument_list|,
operator|&
name|firstdis
argument_list|,
name|respnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|readnum
operator|<
operator|-
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|readnum
operator|==
name|QUITSEQ
operator|||
name|readnum
operator|==
name|QUITUPD
condition|)
comment|/* fix his timestamp */
name|fixlast
argument_list|(
operator|&
name|entered
argument_list|,
name|io
operator|.
name|nf
argument_list|,
name|seqon
argument_list|,
name|Seqname
argument_list|)
expr_stmt|;
name|intflag
operator|=
literal|0
expr_stmt|;
comment|/* clean for next */
block|}
block|}
name|finish
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
return|return
name|readnum
return|;
comment|/* supplied value */
block|}
end_block

end_unit

