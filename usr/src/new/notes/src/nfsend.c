begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_include
include|#
directive|include
file|"net.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FASTSEQ
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
endif|FASTSEQ
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: nfsend.c,v 1.7.0.1 85/08/04 12:16:32 notes Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|RCSIDENT
end_endif

begin_comment
comment|/*  *	nfsend will send the notes/responses to a new site that  *	that site has not seen (at least as far as we are concerned)  *	This means that we send them the ones that we recieved later  *	then the last time we sent them, and also that were not  *	written there nor were routed through there.  *  *	Also, a logfile is maintained of the network transmissions made.  *  *	Returns:	-1 if the notefile is not a networked notefile  *			else count of articles sent  *  *	Original Coding:	Ray Essick	December 1981  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|io_f
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|note_f
name|note
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|resp_f
name|rsprec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ncount
decl_stmt|,
name|rcount
decl_stmt|,
comment|/* how many of each sent */
name|num
decl_stmt|,
name|rrecnum
decl_stmt|,
name|roffset
decl_stmt|,
name|respnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|log
decl_stmt|,
modifier|*
name|zfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* logfile stuff */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|when_f
name|entered
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|line
index|[
name|DATELEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* formatted date */
end_comment

begin_decl_stmt
specifier|static
name|char
name|fn
index|[
name|WDLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* network log */
end_comment

begin_decl_stmt
specifier|static
name|char
name|scrfile
index|[
name|WDLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scratch file */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sendtime
index|[
name|DATELEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current time */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|when_f
name|xsendtime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* raw current time */
end_comment

begin_decl_stmt
specifier|static
name|int
name|traffic
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if new traffic */
end_comment

begin_decl_stmt
specifier|static
name|int
name|opened
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for FASTSEQ */
end_comment

begin_macro
name|nfsend
argument_list|(
argument|tosite
argument_list|,
argument|nfname
argument_list|,
argument|dmpfile
argument_list|,
argument|usetime
argument_list|,
argument|sendhim
argument_list|,
argument|proto
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|tosite
decl_stmt|,
comment|/* destination site */
modifier|*
name|nfname
decl_stmt|,
comment|/* notefile sending */
modifier|*
name|dmpfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temp file */
end_comment

begin_block
block|{
name|traffic
operator|=
literal|0
expr_stmt|;
comment|/* idle */
name|opened
operator|=
literal|0
expr_stmt|;
comment|/* FASTSEQ idle */
name|strcpy
argument_list|(
name|scrfile
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* mark as unused */
name|rcount
operator|=
name|ncount
operator|=
literal|0
expr_stmt|;
comment|/* count sent */
name|gettime
argument_list|(
operator|&
name|xsendtime
argument_list|)
expr_stmt|;
name|sprdate
argument_list|(
operator|&
name|xsendtime
argument_list|,
name|sendtime
argument_list|)
expr_stmt|;
comment|/* format xmit time */
name|sprintf
argument_list|(
name|Seqname
argument_list|,
literal|"Sy:%s"
argument_list|,
name|tosite
argument_list|)
expr_stmt|;
comment|/* sequencer name */
ifdef|#
directive|ifdef
name|FASTSEQ
block|{
name|struct
name|when_f
name|whenvec
decl_stmt|;
name|char
name|NoteFile
index|[
name|WDLEN
index|]
decl_stmt|;
name|struct
name|stat
name|StatBuf
decl_stmt|;
if|if
condition|(
name|nfname
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
comment|/* absolute pathname */
block|{
name|getlast
argument_list|(
operator|&
name|io
operator|.
name|stime
argument_list|,
name|rindex
argument_list|(
name|nfname
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|,
name|usetime
argument_list|,
name|Seqname
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|NoteFile
argument_list|,
literal|"%s/%s"
argument_list|,
name|nfname
argument_list|,
name|TEXT
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* relative to Mstdir */
block|{
name|getlast
argument_list|(
operator|&
name|io
operator|.
name|stime
argument_list|,
name|nfname
argument_list|,
name|usetime
argument_list|,
name|Seqname
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|NoteFile
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|Mstdir
argument_list|,
name|nfname
argument_list|,
name|TEXT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|NoteFile
argument_list|,
operator|&
name|StatBuf
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|maketime
argument_list|(
operator|&
name|whenvec
argument_list|,
operator|(
name|long
operator|)
name|StatBuf
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|inorder
argument_list|(
operator|&
name|whenvec
argument_list|,
operator|&
name|io
operator|.
name|stime
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* nothing new */
block|}
block|}
block|}
endif|#
directive|endif
endif|FASTSEQ
if|if
condition|(
name|init
argument_list|(
operator|&
name|io
argument_list|,
name|nfname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Couldn't open %s, try again later\n"
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|opened
operator|++
expr_stmt|;
comment|/* nfsenddone will close */
name|getperms
argument_list|(
operator|&
name|io
argument_list|,
literal|1
argument_list|,
name|tosite
argument_list|)
expr_stmt|;
comment|/* grab system name */
if|if
condition|(
operator|!
name|allow
argument_list|(
operator|&
name|io
argument_list|,
name|READOK
argument_list|)
condition|)
comment|/* read permission? */
block|{
name|printf
argument_list|(
literal|"Site %s has no read permission for %s\n"
argument_list|,
name|tosite
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* and go back */
block|}
if|if
condition|(
operator|(
name|io
operator|.
name|descr
operator|.
name|d_stat
operator|&
name|NETWRKD
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Notefile %s is not networked\n"
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|gettime
argument_list|(
operator|&
name|entered
argument_list|)
expr_stmt|;
comment|/* for seq. update */
name|getlast
argument_list|(
operator|&
name|io
operator|.
name|stime
argument_list|,
name|io
operator|.
name|nf
argument_list|,
name|usetime
argument_list|,
name|Seqname
argument_list|)
expr_stmt|;
comment|/* grab the time */
if|if
condition|(
operator|!
name|inorder
argument_list|(
operator|&
name|io
operator|.
name|stime
argument_list|,
operator|&
name|io
operator|.
name|descr
operator|.
name|d_lastm
argument_list|)
condition|)
comment|/* something new */
block|{
comment|/* idle notesfile */
ifdef|#
directive|ifdef
name|FASTSEQ
comment|/*  *	update the sequencer so the next pass through will be   *	caught by the FASTSEQ test which just stats the file.  */
name|fixlast
argument_list|(
operator|&
name|entered
argument_list|,
name|io
operator|.
name|nf
argument_list|,
name|NORMSEQ
argument_list|,
name|Seqname
argument_list|)
expr_stmt|;
comment|/* update sequencer */
endif|#
directive|endif
endif|FASTSEQ
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  *	reach here only if we have potential traffic  *	and permission to send it.  */
name|traffic
operator|++
expr_stmt|;
comment|/* forces seq update */
name|x
argument_list|(
operator|(
name|zfile
operator|=
name|fopen
argument_list|(
name|dmpfile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"nfsend: scratch"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|scrfile
argument_list|,
name|dmpfile
argument_list|)
expr_stmt|;
comment|/* save scratch name */
name|num
operator|=
literal|0
expr_stmt|;
comment|/* start at the beginning */
while|while
condition|(
operator|(
name|num
operator|=
name|nxtnote
argument_list|(
operator|&
name|io
argument_list|,
name|num
argument_list|,
operator|&
name|io
operator|.
name|stime
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|getnrec
argument_list|(
operator|&
name|io
argument_list|,
name|num
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* grab the header */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|note
operator|.
name|n_from
argument_list|,
name|tosite
argument_list|)
operator|&&
operator|!
operator|(
name|sendhim
operator|&
name|SENDHIS
operator|)
condition|)
goto|goto
name|doresps
goto|;
comment|/* they sent it to us */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|note
operator|.
name|n_id
operator|.
name|sys
argument_list|,
name|tosite
argument_list|)
operator|&&
operator|!
operator|(
name|sendhim
operator|&
name|SENDHIS
operator|)
condition|)
goto|goto
name|doresps
goto|;
comment|/* written there */
if|if
condition|(
name|inorder
argument_list|(
operator|&
name|io
operator|.
name|stime
argument_list|,
operator|&
name|note
operator|.
name|n_rcvd
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|doresps
goto|;
comment|/* only modified */
if|if
condition|(
operator|(
name|note
operator|.
name|n_stat
operator|&
name|FRMNEWS
operator|)
operator|&&
operator|!
operator|(
name|sendhim
operator|&
name|SENDNEWS
operator|)
condition|)
comment|/* DO NOT send news */
goto|goto
name|doresps
goto|;
comment|/* causes uniqid probs */
ifdef|#
directive|ifdef
name|notdef
comment|/*  	 * we want to send foster parents so they will have a title on 	 * the remote end. 	 */
if|if
condition|(
name|note
operator|.
name|n_stat
operator|&
name|ORPHND
condition|)
comment|/* no foster parents */
goto|goto
name|doresps
goto|;
comment|/* should have copy */
endif|#
directive|endif
endif|notdef
name|dmpnote
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|note
argument_list|,
name|num
argument_list|,
name|zfile
argument_list|,
name|NODETAIL
argument_list|,
name|proto
argument_list|)
expr_stmt|;
comment|/* dump to output */
name|ncount
operator|++
expr_stmt|;
comment|/* bump count of sent articles */
name|io
operator|.
name|nnotxmit
operator|++
expr_stmt|;
comment|/* and global stats */
name|doresps
label|:
comment|/* process the responses */
name|respnum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|respnum
operator|=
name|nxtresp
argument_list|(
operator|&
name|io
argument_list|,
name|num
argument_list|,
name|respnum
argument_list|,
operator|&
name|io
operator|.
name|stime
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|lrsp
argument_list|(
operator|&
name|io
argument_list|,
name|num
argument_list|,
name|respnum
argument_list|,
operator|&
name|rsprec
argument_list|,
operator|&
name|roffset
argument_list|,
operator|&
name|rrecnum
argument_list|)
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* no response */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rsprec
operator|.
name|r_id
index|[
name|roffset
index|]
operator|.
name|sys
argument_list|,
name|tosite
argument_list|)
operator|&&
operator|!
operator|(
name|sendhim
operator|&
name|SENDHIS
operator|)
condition|)
continue|continue;
comment|/* written there */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|rsprec
operator|.
name|r_from
index|[
name|roffset
index|]
argument_list|,
name|tosite
argument_list|)
operator|&&
operator|!
operator|(
name|sendhim
operator|&
name|SENDHIS
operator|)
condition|)
continue|continue;
comment|/* came through there */
if|if
condition|(
operator|(
name|rsprec
operator|.
name|r_stat
index|[
name|roffset
index|]
operator|&
name|FRMNEWS
operator|)
operator|&&
operator|!
operator|(
name|sendhim
operator|&
name|SENDNEWS
operator|)
condition|)
continue|continue;
comment|/* never forward NEWS(I) stuff */
name|dmprsp
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|note
argument_list|,
name|num
argument_list|,
name|zfile
argument_list|,
name|respnum
argument_list|,
name|NODETAIL
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|rcount
operator|++
expr_stmt|;
name|io
operator|.
name|nrspxmit
operator|++
expr_stmt|;
comment|/* and global stats */
block|}
block|}
name|fclose
argument_list|(
name|zfile
argument_list|)
expr_stmt|;
comment|/* and the dumping file */
return|return
operator|(
name|ncount
operator|+
name|rcount
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	nfsendone fixes up the sequencer entry for the system/notesfile  *	pair. The sequencer is only updated if the transmission  *	was successful (as determined by the retval parameter.  *  *	Thanks to Malcolm Slaney for this one.  */
end_comment

begin_macro
name|nfsendone
argument_list|(
argument|nfname
argument_list|,
argument|tosite
argument_list|,
argument|queuestat
argument_list|,
argument|sendstat
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|tosite
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of site */
end_comment

begin_decl_stmt
name|char
modifier|*
name|nfname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of notesfile */
end_comment

begin_decl_stmt
name|int
name|queuestat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Unix return value */
end_comment

begin_block
block|{
comment|/*  *	Traffic is non-zero if something happened in that notesfile  *	If nothing at all happened, we save the bother of updating  *	since it doesn't save us any scanning time later.  *	(and not updating does save us a little time now)  *  *	We check queuestat because we don't want to update the  *	sequencer file if we know that the transmission failed.  */
if|if
condition|(
name|traffic
operator|&&
operator|(
operator|!
name|queuestat
operator|)
condition|)
comment|/* only if non-idle */
block|{
name|fixlast
argument_list|(
operator|&
name|entered
argument_list|,
name|io
operator|.
name|nf
argument_list|,
name|NORMSEQ
argument_list|,
name|Seqname
argument_list|)
expr_stmt|;
comment|/* update sequencer */
block|}
comment|/*  *	Update statistics only on successful non-empty transmissions.  *	We don't do any statistics for empty transmissions  */
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
operator|(
operator|!
name|queuestat
operator|)
operator|&&
operator|(
name|sendstat
operator|>
literal|0
operator|)
condition|)
comment|/* if it worked */
block|{
comment|/* and sent */
name|locknf
argument_list|(
operator|&
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
name|getdscr
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|io
operator|.
name|descr
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|io
operator|.
name|descr
operator|.
name|d_lstxmit
argument_list|)
expr_stmt|;
comment|/* mark as sent now */
if|if
condition|(
name|ncount
operator|+
name|rcount
operator|>
literal|0
condition|)
comment|/* only if sent stuff */
name|io
operator|.
name|descr
operator|.
name|netwrkouts
operator|++
expr_stmt|;
comment|/* increment xmits */
name|putdscr
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|io
operator|.
name|descr
argument_list|)
expr_stmt|;
name|unlocknf
argument_list|(
operator|&
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|STATS
if|if
condition|(
name|opened
condition|)
comment|/* did init(&io,nf) */
name|finish
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
comment|/* so close it */
comment|/*  *	Now log everything that happened  */
name|sprdate
argument_list|(
operator|&
name|io
operator|.
name|stime
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fn
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|Mstdir
argument_list|,
name|UTILITY
argument_list|,
name|NETLOG
argument_list|)
expr_stmt|;
comment|/* logging */
if|if
condition|(
name|sendstat
operator|>=
literal|0
condition|)
comment|/* no bizarre errors */
block|{
if|if
condition|(
name|ncount
operator|+
name|rcount
condition|)
comment|/* log only if sending */
block|{
name|x
argument_list|(
operator|(
name|log
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"nfsend: bad net log file"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log
argument_list|,
literal|"%s: %s send (%3d,%3d) to %-10s at %s\n"
argument_list|,
name|nfname
argument_list|,
name|queuestat
condition|?
literal|"Fail"
else|:
literal|"Did"
argument_list|,
name|ncount
argument_list|,
name|rcount
argument_list|,
name|tosite
argument_list|,
name|sendtime
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|fclose
argument_list|(
name|log
argument_list|)
operator|==
name|EOF
argument_list|,
literal|"nfsend: trouble fclosing log file"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-14s: %4s send (%3d,%3d) to %s since %s\n"
argument_list|,
name|nfname
argument_list|,
name|queuestat
condition|?
literal|"Fail"
else|:
literal|"Did"
argument_list|,
name|ncount
argument_list|,
name|rcount
argument_list|,
name|tosite
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%-14s: No new notes since %s\n"
argument_list|,
name|nfname
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* force it out */
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|scrfile
argument_list|,
literal|""
argument_list|)
operator|!=
literal|0
condition|)
comment|/* contains a name */
block|{
name|unlink
argument_list|(
name|scrfile
argument_list|)
expr_stmt|;
comment|/* don't leave droppings */
block|}
block|}
end_block

end_unit

