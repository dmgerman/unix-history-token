begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: archiver.c,v 1.7.0.4 85/06/05 14:16:24 notes Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|RCSIDENT
end_endif

begin_comment
comment|/*  *	archiver - archives a notesfile. Takes all articles older  *	than 'daysold' days and places them, in generic format, in  *	a sub-directory in the archie directory. The files are marked  *	by the time that they were created.   *	The deleteonly parameter is normally zero. If it is non-zero,  *	no archive is taken; the old notes are merely thrown away.  *  *	Ray Essick			March 1982  *  *	modified so that could also toggle on the director message.  *	in addition to the days untouched.  *				Ray Essick	June 1982  *  *	Now grabs an expiration threshold and a "working set size"  *	from the notesfile itself.  If zero, the values passed  *	in as paramaters are used.  */
end_comment

begin_macro
name|archiver
argument_list|(
argument|nfname
argument_list|,
argument|daysold
argument_list|,
argument|worksetsize
argument_list|,
argument|deleteonly
argument_list|,
argument|dirmsgflag
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|nfname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|daysold
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|worksetsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|deleteonly
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dirmsgflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|io_f
name|io
decl_stmt|,
name|archio
decl_stmt|;
name|struct
name|when_f
name|zaptime
decl_stmt|;
comment|/* boundary time */
name|struct
name|note_f
name|note
decl_stmt|;
name|struct
name|note_f
name|note2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ncount
decl_stmt|,
name|rcount
decl_stmt|;
name|int
name|dnotes
decl_stmt|,
comment|/* duplicates */
name|dresps
decl_stmt|,
comment|/* in the archive */
name|adopts
decl_stmt|;
comment|/* and adoptions */
name|int
name|deletable
decl_stmt|;
comment|/* how many can zap */
name|int
name|presps
decl_stmt|;
name|char
name|line
index|[
name|WDLEN
index|]
decl_stmt|;
name|char
name|archdest
index|[
name|WDLEN
index|]
decl_stmt|;
comment|/* target notesfile */
name|char
name|archbase
index|[
name|WDLEN
index|]
decl_stmt|;
comment|/* target directory */
name|char
name|archend
index|[
name|WDLEN
index|]
decl_stmt|;
comment|/* and nf name */
name|char
name|timeline
index|[
name|DATELEN
index|]
decl_stmt|;
name|char
modifier|*
name|endname
decl_stmt|;
name|FILE
modifier|*
name|log
decl_stmt|;
name|int
name|wasopen
decl_stmt|;
name|int
name|locktarget
decl_stmt|;
comment|/* whether to */
name|struct
name|daddr_f
name|where
decl_stmt|;
name|int
name|rnum
decl_stmt|;
comment|/* copy responses */
name|int
name|newnum
decl_stmt|;
comment|/* note place in arch */
name|int
name|rblock
decl_stmt|,
name|roffset
decl_stmt|;
name|struct
name|resp_f
name|resp
decl_stmt|;
name|FILE
modifier|*
name|txtfile
decl_stmt|;
comment|/* for saving text */
name|char
name|txtfn
index|[
name|WDLEN
index|]
decl_stmt|;
comment|/* its name */
name|int
name|dup_place
decl_stmt|;
comment|/* is in archive? */
name|int
name|dup_resp
decl_stmt|;
comment|/* dup supression */
if|if
condition|(
name|init
argument_list|(
operator|&
name|io
argument_list|,
name|nfname
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* no notesfile */
if|if
condition|(
name|allow
argument_list|(
operator|&
name|io
argument_list|,
name|DRCTOK
argument_list|)
operator|==
literal|0
operator|&&
name|globuid
operator|!=
name|Notesuid
condition|)
block|{
name|closenf
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Archiver: %s: You don't have permission to archive\n"
argument_list|,
name|io
operator|.
name|fullname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|io
operator|.
name|descr
operator|.
name|d_stat
operator|&
name|ISARCH
condition|)
comment|/* can't archive an archive */
block|{
name|closenf
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Archiver: %s: You can't archive an archive\n"
argument_list|,
name|io
operator|.
name|fullname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  *	select the archive name  */
switch|switch
condition|(
name|nfalias
argument_list|(
name|io
operator|.
name|fullname
argument_list|,
name|archdest
argument_list|,
name|ARCHALIAS
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* no file */
case|case
literal|0
case|:
comment|/* no match */
if|if
condition|(
operator|*
name|nfname
operator|==
literal|'/'
condition|)
comment|/* absolute path name */
block|{
name|strcpy
argument_list|(
name|archend
argument_list|,
name|io
operator|.
name|nf
argument_list|)
expr_stmt|;
comment|/* get nf */
name|strcpy
argument_list|(
name|archbase
argument_list|,
name|ARCHDIR
argument_list|)
expr_stmt|;
comment|/* base directory */
name|printf
argument_list|(
literal|"Archiver: WARNING: possible naming conflict in %s (%s)\n"
argument_list|,
name|nfname
argument_list|,
name|io
operator|.
name|fullname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|archend
argument_list|,
name|io
operator|.
name|nf
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|archbase
argument_list|,
name|ARCHDIR
argument_list|)
expr_stmt|;
comment|/* base directory */
block|}
break|break;
case|case
literal|1
case|:
comment|/* an alias! */
if|if
condition|(
name|archdest
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
comment|/* expand it */
block|{
name|strcpy
argument_list|(
name|archbase
argument_list|,
name|ARCHDIR
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|archend
argument_list|,
name|archdest
argument_list|)
expr_stmt|;
comment|/* hold it */
block|}
else|else
block|{
name|endname
operator|=
name|rindex
argument_list|(
name|archdest
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
operator|*
name|endname
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* split */
name|strcpy
argument_list|(
name|archbase
argument_list|,
name|archdest
argument_list|)
expr_stmt|;
comment|/* directory */
name|strcpy
argument_list|(
name|archend
argument_list|,
name|endname
argument_list|)
expr_stmt|;
comment|/* and nf */
block|}
break|break;
block|}
name|sprintf
argument_list|(
name|archdest
argument_list|,
literal|"%s/%s"
argument_list|,
name|archbase
argument_list|,
name|archend
argument_list|)
expr_stmt|;
comment|/* full name */
name|sprintf
argument_list|(
name|txtfn
argument_list|,
literal|"/tmp/nfa%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* hold texts */
name|ncount
operator|=
name|rcount
operator|=
literal|0
expr_stmt|;
comment|/* count archived */
name|dnotes
operator|=
name|dresps
operator|=
name|adopts
operator|=
literal|0
expr_stmt|;
comment|/* duplicates */
name|locktarget
operator|=
literal|0
expr_stmt|;
comment|/* changed if should */
comment|/*  *	check notesfile specific thresholds, sizes and other options  */
if|if
condition|(
name|io
operator|.
name|descr
operator|.
name|d_archtime
operator|==
name|NEVER
condition|)
comment|/* don't archive */
block|{
name|printf
argument_list|(
literal|"Archiver: %s has archive threshold of `never'\n"
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
goto|goto
name|docompress
goto|;
comment|/* compress anyway */
block|}
if|if
condition|(
name|io
operator|.
name|descr
operator|.
name|d_archtime
operator|!=
literal|0
condition|)
comment|/* non-default */
block|{
name|daysold
operator|=
operator|(
name|int
operator|)
name|io
operator|.
name|descr
operator|.
name|d_archtime
expr_stmt|;
comment|/* use this one */
name|printf
argument_list|(
literal|"Archiver: %s specifies threshold of %d days\n"
argument_list|,
name|nfname
argument_list|,
name|daysold
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|io
operator|.
name|descr
operator|.
name|d_workset
operator|!=
literal|0
condition|)
block|{
name|worksetsize
operator|=
operator|(
name|int
operator|)
name|io
operator|.
name|descr
operator|.
name|d_workset
expr_stmt|;
name|printf
argument_list|(
literal|"Archiver: %s specifies working set size of %d\n"
argument_list|,
name|nfname
argument_list|,
name|worksetsize
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|io
operator|.
name|descr
operator|.
name|d_dmesgstat
operator|!=
name|DIRDFLT
condition|)
comment|/* specific */
block|{
name|dirmsgflag
operator|=
operator|(
name|int
operator|)
name|io
operator|.
name|descr
operator|.
name|d_dmesgstat
expr_stmt|;
comment|/* set it */
name|printf
argument_list|(
literal|"Archiver: %s specifies dirmsg status of %s for expiring\n"
argument_list|,
name|nfname
argument_list|,
name|dirmsgflag
operator|==
name|DIRON
condition|?
literal|"ON"
else|:
name|dirmsgflag
operator|==
name|DIROFF
condition|?
literal|"OFF"
else|:
literal|"NOCARE"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|io
operator|.
name|descr
operator|.
name|d_archkeep
operator|!=
name|KEEPDFLT
condition|)
comment|/* keep/delete */
block|{
if|if
condition|(
name|io
operator|.
name|descr
operator|.
name|d_archkeep
operator|==
name|KEEPYES
condition|)
name|deleteonly
operator|=
literal|0
expr_stmt|;
else|else
name|deleteonly
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"Archiver: %s specifies %s expired notes\n"
argument_list|,
name|nfname
argument_list|,
name|deleteonly
condition|?
literal|"deleting"
else|:
literal|"archiving"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|deletable
operator|=
operator|(
operator|(
name|int
operator|)
name|io
operator|.
name|descr
operator|.
name|d_nnote
operator|)
operator|-
operator|(
operator|(
name|int
operator|)
name|io
operator|.
name|descr
operator|.
name|d_delnote
operator|)
operator|-
name|worksetsize
expr_stmt|;
if|if
condition|(
name|deletable
operator|<=
literal|0
condition|)
comment|/* candidates? */
block|{
if|if
condition|(
name|io
operator|.
name|descr
operator|.
name|d_nnote
operator|-
name|io
operator|.
name|descr
operator|.
name|d_delnote
operator|>
literal|0
condition|)
comment|/* only if non-empty */
block|{
name|printf
argument_list|(
literal|"Archiver: %s: %d notes<= working set size of %d\n"
argument_list|,
name|nfname
argument_list|,
name|io
operator|.
name|descr
operator|.
name|d_nnote
operator|-
name|io
operator|.
name|descr
operator|.
name|d_delnote
argument_list|,
name|worksetsize
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
goto|goto
name|docompress
goto|;
block|}
name|gettime
argument_list|(
operator|&
name|zaptime
argument_list|)
expr_stmt|;
comment|/* threshold */
name|zaptime
operator|.
name|w_gmttime
operator|-=
literal|60L
operator|*
literal|60L
operator|*
literal|24L
operator|*
operator|(
operator|(
name|long
operator|)
name|daysold
operator|)
expr_stmt|;
comment|/* internal */
name|maketime
argument_list|(
operator|&
name|zaptime
argument_list|,
name|zaptime
operator|.
name|w_gmttime
argument_list|)
expr_stmt|;
comment|/* re-format */
if|if
condition|(
operator|!
name|deleteonly
condition|)
block|{
if|if
condition|(
name|init
argument_list|(
operator|&
name|archio
argument_list|,
name|archdest
argument_list|)
operator|<
literal|0
condition|)
comment|/* not already */
block|{
name|printf
argument_list|(
literal|"Archiver creating archive notesfile %s\n"
argument_list|,
name|archdest
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|buildnf
argument_list|(
name|archend
argument_list|,
name|archbase
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
comment|/* make one */
block|{
name|printf
argument_list|(
literal|"Archiver: Problems creating %s for archival\n"
argument_list|,
name|archdest
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
goto|goto
name|docompress
goto|;
block|}
if|if
condition|(
name|init
argument_list|(
operator|&
name|archio
argument_list|,
name|archdest
argument_list|)
operator|<
literal|0
condition|)
comment|/* and open it */
block|{
name|printf
argument_list|(
literal|"Archiver: Problems opening %s for archival\n"
argument_list|,
name|archdest
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
goto|goto
name|docompress
goto|;
block|}
name|locknf
argument_list|(
operator|&
name|archio
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* watch conflicts */
name|getdscr
argument_list|(
operator|&
name|archio
argument_list|,
operator|&
name|archio
operator|.
name|descr
argument_list|)
expr_stmt|;
name|archio
operator|.
name|descr
operator|.
name|d_stat
operator||=
name|ISARCH
operator|+
name|OPEN
expr_stmt|;
name|putdscr
argument_list|(
operator|&
name|archio
argument_list|,
operator|&
name|archio
operator|.
name|descr
argument_list|)
expr_stmt|;
name|unlocknf
argument_list|(
operator|&
name|archio
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/*  	     *	Copy the active notesfile's access list to 	     *	the archive notesfile. 	     */
block|{
ifdef|#
directive|ifdef
name|FASTFORK
name|char
name|old
index|[
name|WDLEN
index|]
decl_stmt|;
name|char
name|new
index|[
name|WDLEN
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|old
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|io
operator|.
name|basedir
argument_list|,
name|io
operator|.
name|nf
argument_list|,
name|ACCESS
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|archio
operator|.
name|basedir
argument_list|,
name|archio
operator|.
name|nf
argument_list|,
name|ACCESS
argument_list|)
expr_stmt|;
name|dounix
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"/bin/cp"
argument_list|,
name|old
argument_list|,
name|new
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
else|! FASTFORK
name|char
name|cmdline
index|[
name|WDLEN
operator|+
name|WDLEN
operator|+
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|cmdline
argument_list|,
literal|"%s %s/%s/%s %s/%s/%s"
argument_list|,
literal|"/bin/cp"
argument_list|,
name|io
operator|.
name|basedir
argument_list|,
name|io
operator|.
name|nf
argument_list|,
name|ACCESS
argument_list|,
name|archio
operator|.
name|basedir
argument_list|,
name|archio
operator|.
name|nf
argument_list|,
name|ACCESS
argument_list|)
expr_stmt|;
name|dounix
argument_list|(
name|cmdline
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|! FASTFORK
block|}
block|}
name|locktarget
operator|=
name|strcmp
argument_list|(
name|io
operator|.
name|nf
argument_list|,
name|archio
operator|.
name|nf
argument_list|)
expr_stmt|;
comment|/* lock if differ */
if|if
condition|(
operator|!
operator|(
name|archio
operator|.
name|descr
operator|.
name|d_stat
operator|&
name|ISARCH
operator|)
condition|)
comment|/* into archive? */
block|{
name|printf
argument_list|(
literal|"Archiver: %s: Target %s is not an archive\n"
argument_list|,
name|nfname
argument_list|,
name|archdest
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|closenf
argument_list|(
operator|&
name|archio
argument_list|)
expr_stmt|;
comment|/* close that */
goto|goto
name|docompress
goto|;
comment|/* compress him anyway */
block|}
block|}
ifdef|#
directive|ifdef
name|OLDGROUP
comment|/*  *	This code looks at the directory to see if the notesfile  *	has been idle long enough to be deleted.  *  *	This code hasn't been tested by me. It works in the   *	Salkind/Spickelmier version.  *  *	Should stuff a "wait-till-expire" in the master descriptor  *	of each notesfile so "junk" ones can expire faster or  *	something like that.  Essentially we want the age at which  *	the notesfile is deleted to be grabbed from the notesfile  *	itself.  *  *	My personal opinion is that they shouldn't disappear  *	auto-magically  *		NOTE: this probably no longer works with the   *		changes I've made to archiving.   (Dec '83)  *  *	N.B. Need some locking in here  */
comment|/* delete inactive groups - RLS 1/8/83 */
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s/%s"
argument_list|,
name|MSTDIR
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|line
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|current
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|-
name|buf
operator|.
name|st_mtime
operator|>
literal|60
operator|*
literal|60
operator|*
literal|24
operator|*
operator|(
name|OLDGROUP
operator|-
name|daysold
operator|)
condition|)
block|{
name|finish
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"/bin/rm -rf %s/%s"
argument_list|,
name|MSTDIR
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|zaptime
argument_list|)
expr_stmt|;
name|sprdate
argument_list|(
operator|&
name|zaptime
argument_list|,
name|timeline
argument_list|)
expr_stmt|;
comment|/* message in nfmaint */
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"Archiver: removed %s\n"
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
name|nfcomment
argument_list|(
name|NOSUCHWARN
argument_list|,
name|line
argument_list|,
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|MSTDIR
argument_list|,
name|UTILITY
argument_list|,
name|NETLOG
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|log
operator|=
name|fopen
argument_list|(
name|line
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"archiver: no logfile"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log
argument_list|,
literal|"Archiver: deleted %s at %s\n"
argument_list|,
name|nfname
argument_list|,
name|timeline
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Archiver: deleted %s at %s\n"
argument_list|,
name|nfname
argument_list|,
name|timeline
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
endif|OLDGROUP
name|locknf
argument_list|(
operator|&
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* MUTEX */
if|if
condition|(
name|locktarget
condition|)
comment|/* and target */
name|locknf
argument_list|(
operator|&
name|archio
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
name|getdscr
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|io
operator|.
name|descr
argument_list|)
expr_stmt|;
name|wasopen
operator|=
name|io
operator|.
name|descr
operator|.
name|d_stat
operator|&
name|OPEN
expr_stmt|;
comment|/* hold this */
name|io
operator|.
name|descr
operator|.
name|d_stat
operator|&=
name|NOT
name|OPEN
expr_stmt|;
comment|/* privacy */
name|putdscr
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|io
operator|.
name|descr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|io
operator|.
name|descr
operator|.
name|d_nnote
operator|&&
name|deletable
condition|;
name|i
operator|++
control|)
block|{
name|getnrec
argument_list|(
operator|&
name|io
argument_list|,
name|i
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|.
name|n_stat
operator|&
name|DELETED
condition|)
continue|continue;
comment|/* gone already */
if|if
condition|(
name|dirmsgflag
operator|==
name|DIROFF
operator|&&
operator|(
name|note
operator|.
name|n_stat
operator|&
name|DIRMES
operator|)
condition|)
continue|continue;
comment|/* don't if dir on */
if|if
condition|(
name|dirmsgflag
operator|==
name|DIRON
operator|&&
operator|(
name|note
operator|.
name|n_stat
operator|&
name|DIRMES
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* don't if dir off */
if|if
condition|(
name|inorder
argument_list|(
operator|&
name|zaptime
argument_list|,
operator|&
name|note
operator|.
name|n_lmod
argument_list|)
condition|)
continue|continue;
comment|/* too recent */
name|presps
operator|=
name|note
operator|.
name|n_nresp
expr_stmt|;
comment|/* response count */
if|if
condition|(
operator|!
name|deleteonly
condition|)
comment|/* save it? */
block|{
comment|/*  	     * check to see if this one is already in the archive 	     */
name|dup_place
operator|=
name|chknote
argument_list|(
operator|&
name|archio
argument_list|,
operator|&
name|note
operator|.
name|n_id
argument_list|,
operator|&
name|note2
argument_list|)
expr_stmt|;
comment|/* already there? */
if|if
condition|(
name|dup_place
operator|==
literal|0
condition|)
comment|/* not there */
block|{
comment|/*  		 *	This code copied almost verbatim from compression routines 		 */
ifdef|#
directive|ifdef
name|notdef
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|txtfn
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"archiver:bad txt"
argument_list|)
expr_stmt|;
name|pageout
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|,
name|txtfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|txtfn
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"archiver: txt read"
argument_list|)
expr_stmt|;
name|pagein
argument_list|(
operator|&
name|archio
argument_list|,
name|txtfile
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
else|#
directive|else
name|pagemove
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|,
operator|&
name|archio
argument_list|,
operator|&
name|where
argument_list|,
name|LOCKIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|newnum
operator|=
name|putnote
argument_list|(
operator|&
name|archio
argument_list|,
operator|&
name|where
argument_list|,
name|note
operator|.
name|ntitle
argument_list|,
name|note
operator|.
name|n_stat
argument_list|,
operator|&
name|note
argument_list|,
operator|&
name|note
operator|.
name|n_auth
argument_list|,
name|NOPOLICY
argument_list|,
name|NOLOCKIT
argument_list|,
name|NOADDID
argument_list|,
name|note
operator|.
name|n_from
argument_list|,
name|NOADDTIME
argument_list|)
expr_stmt|;
name|getnrec
argument_list|(
operator|&
name|archio
argument_list|,
name|newnum
argument_list|,
operator|&
name|note2
argument_list|)
expr_stmt|;
comment|/* get copy */
block|}
else|else
block|{
if|if
condition|(
operator|(
name|note2
operator|.
name|n_stat
operator|&
name|ORPHND
operator|)
operator|&&
comment|/* archived is foster */
operator|!
operator|(
name|note
operator|.
name|n_stat
operator|&
name|ORPHND
operator|)
condition|)
comment|/* and active isn't */
block|{
ifdef|#
directive|ifdef
name|notdef
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|txtfn
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"archiver:bad txt"
argument_list|)
expr_stmt|;
name|pageout
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|,
name|txtfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|txtfn
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"archiver: txt read"
argument_list|)
expr_stmt|;
name|pagein
argument_list|(
operator|&
name|archio
argument_list|,
name|txtfile
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
else|#
directive|else
name|pagemove
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|,
operator|&
name|archio
argument_list|,
operator|&
name|where
argument_list|,
name|LOCKIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|note
operator|.
name|n_nresp
operator|=
name|note2
operator|.
name|n_nresp
expr_stmt|;
comment|/* save resp chain */
name|note
operator|.
name|n_rindx
operator|=
name|note2
operator|.
name|n_rindx
expr_stmt|;
name|note
operator|.
name|n_addr
operator|=
name|where
expr_stmt|;
comment|/* get text pointer */
name|putnrec
argument_list|(
operator|&
name|archio
argument_list|,
name|dup_place
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* replace descriptor */
name|note2
operator|=
name|note
expr_stmt|;
comment|/* save good copy */
name|adopts
operator|++
expr_stmt|;
comment|/* count 'em */
block|}
else|else
block|{
name|dnotes
operator|++
expr_stmt|;
comment|/* count duplicate */
block|}
name|newnum
operator|=
name|dup_place
expr_stmt|;
comment|/* for linking resps */
block|}
for|for
control|(
name|rnum
operator|=
literal|1
init|;
name|rnum
operator|<=
name|presps
condition|;
name|rnum
operator|++
control|)
comment|/* process responses */
block|{
if|if
condition|(
name|lrsp
argument_list|(
operator|&
name|io
argument_list|,
name|i
argument_list|,
name|rnum
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|roffset
argument_list|,
operator|&
name|rblock
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* bad response chain - drop rest */
if|if
condition|(
name|dup_place
condition|)
comment|/* better check... */
block|{
name|dup_resp
operator|=
name|chkresp
argument_list|(
operator|&
name|archio
argument_list|,
operator|&
name|resp
operator|.
name|r_id
index|[
name|roffset
index|]
argument_list|,
operator|&
name|note2
argument_list|,
name|newnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup_resp
condition|)
comment|/* already there */
block|{
name|dresps
operator|++
expr_stmt|;
comment|/* count doubles */
continue|continue;
comment|/* skip this response */
block|}
block|}
ifdef|#
directive|ifdef
name|notdef
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|txtfn
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"compress:bad txt"
argument_list|)
expr_stmt|;
name|pageout
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|resp
operator|.
name|r_addr
index|[
name|roffset
index|]
argument_list|,
name|txtfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|txtfn
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"compress: bad txt read"
argument_list|)
expr_stmt|;
name|pagein
argument_list|(
operator|&
name|archio
argument_list|,
name|txtfile
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
else|#
directive|else
name|pagemove
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|resp
operator|.
name|r_addr
index|[
name|roffset
index|]
argument_list|,
operator|&
name|archio
argument_list|,
operator|&
name|where
argument_list|,
name|LOCKIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|putresp
argument_list|(
operator|&
name|archio
argument_list|,
operator|&
name|where
argument_list|,
name|resp
operator|.
name|r_stat
index|[
name|roffset
index|]
argument_list|,
name|newnum
argument_list|,
operator|&
name|resp
operator|.
name|r_when
index|[
name|roffset
index|]
argument_list|,
operator|&
name|resp
operator|.
name|r_auth
index|[
name|roffset
index|]
argument_list|,
operator|&
name|note
argument_list|,
name|NOLOCKIT
argument_list|,
operator|&
name|resp
operator|.
name|r_id
index|[
name|roffset
index|]
argument_list|,
name|NOADDID
argument_list|,
name|resp
operator|.
name|r_from
index|[
name|roffset
index|]
argument_list|,
name|NOADDTIME
argument_list|,
operator|&
name|resp
operator|.
name|r_rcvd
index|[
name|roffset
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|delnote
argument_list|(
operator|&
name|io
argument_list|,
name|i
argument_list|,
name|NOLOCKIT
argument_list|)
expr_stmt|;
comment|/* delete entry */
name|ncount
operator|++
expr_stmt|;
name|rcount
operator|+=
name|presps
expr_stmt|;
comment|/* and responses */
name|deletable
operator|--
expr_stmt|;
comment|/* one down */
block|}
name|unlocknf
argument_list|(
operator|&
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* Un MUTEX */
if|if
condition|(
name|locktarget
condition|)
comment|/* and the target */
name|unlocknf
argument_list|(
operator|&
name|archio
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|deleteonly
condition|)
block|{
name|finish
argument_list|(
operator|&
name|archio
argument_list|)
expr_stmt|;
comment|/* close target */
name|unlink
argument_list|(
name|txtfn
argument_list|)
expr_stmt|;
comment|/* don't litter */
block|}
comment|/*  *	Time to compress the notesfile and eliminate those  *	unsightly holes in the data structure.  */
name|docompress
label|:
name|locknf
argument_list|(
operator|&
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* MUTEX */
if|if
condition|(
name|io
operator|.
name|descr
operator|.
name|d_nnote
operator|!=
literal|0
condition|)
comment|/* non-empty */
block|{
if|if
condition|(
name|io
operator|.
name|descr
operator|.
name|d_delnote
operator|!=
literal|0
operator|||
name|io
operator|.
name|descr
operator|.
name|d_delresp
operator|!=
literal|0
condition|)
block|{
comment|/* has holes */
name|int
name|nnote
decl_stmt|,
name|nresp
decl_stmt|;
name|compress
argument_list|(
operator|&
name|io
argument_list|,
name|NOLOCKIT
argument_list|,
literal|0
argument_list|,
operator|&
name|nnote
argument_list|,
operator|&
name|nresp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Archiver: %s contains (%d,%d) after compress\n"
argument_list|,
name|nfname
argument_list|,
name|nnote
argument_list|,
name|nresp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* no holes so */
block|{
comment|/* don't compress */
name|printf
argument_list|(
literal|"Archiver: %s already compressed\n"
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* nothing there to */
block|{
comment|/* compress */
name|printf
argument_list|(
literal|"Archiver: %s is empty.\n"
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wasopen
condition|)
comment|/* if it was already */
block|{
name|getdscr
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|io
operator|.
name|descr
argument_list|)
expr_stmt|;
comment|/* open season */
name|io
operator|.
name|descr
operator|.
name|d_stat
operator||=
name|OPEN
expr_stmt|;
name|putdscr
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|io
operator|.
name|descr
argument_list|)
expr_stmt|;
comment|/* replace in file */
block|}
name|unlocknf
argument_list|(
operator|&
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* all done with this */
name|finish
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
comment|/* and close the notesfile */
name|gettime
argument_list|(
operator|&
name|zaptime
argument_list|)
expr_stmt|;
name|sprdate
argument_list|(
operator|&
name|zaptime
argument_list|,
name|timeline
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncount
condition|)
comment|/* log only if did somethine */
block|{
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|Mstdir
argument_list|,
name|UTILITY
argument_list|,
name|NETLOG
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|log
operator|=
name|fopen
argument_list|(
name|line
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"archiver: no logfile"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|deleteonly
condition|)
name|fprintf
argument_list|(
name|log
argument_list|,
literal|"%s: archived (%d,%d) [%d,%d dups, %d adopted] into %s at %s\n"
argument_list|,
name|nfname
argument_list|,
name|ncount
argument_list|,
name|rcount
argument_list|,
name|dnotes
argument_list|,
name|dresps
argument_list|,
name|adopts
argument_list|,
name|archdest
argument_list|,
name|timeline
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|log
argument_list|,
literal|"%s: Archiver deleted (%d,%d) at %s\n"
argument_list|,
name|nfname
argument_list|,
name|ncount
argument_list|,
name|rcount
argument_list|,
name|timeline
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|deleteonly
condition|)
block|{
if|if
condition|(
name|ncount
condition|)
name|printf
argument_list|(
literal|"Archiver: %s: (%d,%d) [%d,%d dups, %d adoptions] into %s at %s\n"
argument_list|,
name|nfname
argument_list|,
name|ncount
argument_list|,
name|rcount
argument_list|,
name|dnotes
argument_list|,
name|dresps
argument_list|,
name|adopts
argument_list|,
name|archdest
argument_list|,
name|timeline
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Archiver: %s: no notes archived\n"
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"Archiver: %s: deleted (%d,%d) at %s\n"
argument_list|,
name|nfname
argument_list|,
name|ncount
argument_list|,
name|rcount
argument_list|,
name|timeline
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* and return */
block|}
end_block

end_unit

