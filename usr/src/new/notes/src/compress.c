begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: compress.c,v 1.7.0.2 85/03/19 13:02:07 notes Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|RCSIDENT
end_endif

begin_comment
comment|/*  *	compress(io) struct io_f  *	compresses the notefile specified. All wasted space  *	reclaimed. The process is a simple one which, like dcheck,  *	does not work so well on active file systems.  *	As a consequence, the director options (which call this)  *	require the notefile to be closed before allowing compression  *	to take place.   *	The code generates 3 scratch files, corresponding with the  *	two index files and the text file. These are made to  *	represent a virgin notefile. The descriptor is copied over  *	with the appropriate fields zapped, and then we go through  *	a cycle of (read note; write note; (read resp; write resp))  *	until all the notes and responses are moved over.  *	the new files are then copied back into place.  *	  *	Returns:	0 - all successful  *			otherwise will core dump with the notefile  *			in a shambles from the users view point,  *			but still recoverable by a hotshot-pro.  *  *	Original Coding:	Ray Essick	January 1981  */
end_comment

begin_macro
name|compress
argument_list|(
argument|io
argument_list|,
argument|lockflag
argument_list|,
argument|verbosity
argument_list|,
argument|numnotes
argument_list|,
argument|numresps
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lockflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to lock or not */
end_comment

begin_decl_stmt
name|int
name|verbosity
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* verbosity 	== 0	silent  *		else	print dots as go& do totals  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|numnotes
decl_stmt|,
comment|/* remaining notes when done */
modifier|*
name|numresps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ditto for responses */
end_comment

begin_block
block|{
name|struct
name|io_f
name|tmpio
decl_stmt|;
comment|/* scratch notefile */
name|struct
name|note_f
name|note
decl_stmt|;
comment|/* hold a note record */
name|struct
name|resp_f
name|resp
decl_stmt|;
comment|/* hold the response format */
name|char
name|fn1
index|[
name|WDLEN
index|]
decl_stmt|,
name|fn2
index|[
name|WDLEN
index|]
decl_stmt|,
name|fn3
index|[
name|WDLEN
index|]
decl_stmt|,
name|on1
index|[
name|WDLEN
index|]
decl_stmt|,
name|on2
index|[
name|WDLEN
index|]
decl_stmt|,
name|on3
index|[
name|WDLEN
index|]
decl_stmt|,
name|txtfn
index|[
name|WDLEN
index|]
decl_stmt|;
comment|/* hold text going between files */
name|struct
name|daddr_f
name|where
decl_stmt|;
name|FILE
modifier|*
name|txtfile
decl_stmt|;
name|int
name|nnotes
decl_stmt|,
name|nresps
decl_stmt|,
name|dint
decl_stmt|,
name|roffset
decl_stmt|,
name|num
decl_stmt|,
name|rblock
decl_stmt|;
specifier|register
name|int
name|newnum
decl_stmt|,
name|presps
decl_stmt|,
name|rnum
decl_stmt|;
name|struct
name|daddr_f
name|daddr
decl_stmt|;
name|int
name|old_umask
decl_stmt|;
comment|/* save it */
comment|/*  *	build names of files - in notefile directory  */
comment|/* new files */
name|sprintf
argument_list|(
name|fn1
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|io
operator|->
name|basedir
argument_list|,
name|io
operator|->
name|nf
argument_list|,
name|COMPRESS
argument_list|,
name|INDEXN
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fn2
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|io
operator|->
name|basedir
argument_list|,
name|io
operator|->
name|nf
argument_list|,
name|COMPRESS
argument_list|,
name|INDEXR
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fn3
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|io
operator|->
name|basedir
argument_list|,
name|io
operator|->
name|nf
argument_list|,
name|COMPRESS
argument_list|,
name|TEXT
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|on1
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|io
operator|->
name|basedir
argument_list|,
name|io
operator|->
name|nf
argument_list|,
name|INDEXN
argument_list|)
expr_stmt|;
comment|/* old files */
name|sprintf
argument_list|(
name|on2
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|io
operator|->
name|basedir
argument_list|,
name|io
operator|->
name|nf
argument_list|,
name|INDEXR
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|on3
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|io
operator|->
name|basedir
argument_list|,
name|io
operator|->
name|nf
argument_list|,
name|TEXT
argument_list|)
expr_stmt|;
name|old_umask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* wide open */
name|x
argument_list|(
operator|(
name|tmpio
operator|.
name|fidndx
operator|=
name|creat
argument_list|(
name|fn1
argument_list|,
literal|0660
argument_list|)
operator|)
operator|<
literal|0
argument_list|,
literal|"compress: create nindex"
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|tmpio
operator|.
name|fidrdx
operator|=
name|creat
argument_list|(
name|fn2
argument_list|,
literal|0660
argument_list|)
operator|)
operator|<
literal|0
argument_list|,
literal|"compress: create rindex"
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|tmpio
operator|.
name|fidtxt
operator|=
name|creat
argument_list|(
name|fn3
argument_list|,
literal|0660
argument_list|)
operator|)
operator|<
literal|0
argument_list|,
literal|"compress: create txt"
argument_list|)
expr_stmt|;
name|dint
operator|=
literal|0
expr_stmt|;
comment|/* resp index free pointer */
name|daddr
operator|.
name|addr
operator|=
sizeof|sizeof
name|daddr
expr_stmt|;
comment|/* and for text file */
name|x
argument_list|(
name|write
argument_list|(
name|tmpio
operator|.
name|fidrdx
argument_list|,
operator|&
name|dint
argument_list|,
sizeof|sizeof
name|dint
argument_list|)
operator|!=
sizeof|sizeof
name|dint
argument_list|,
literal|"compress: resp ptr"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|write
argument_list|(
name|tmpio
operator|.
name|fidtxt
argument_list|,
operator|&
name|daddr
argument_list|,
sizeof|sizeof
name|daddr
argument_list|)
operator|!=
sizeof|sizeof
name|daddr
argument_list|,
literal|"Compress: text ptr"
argument_list|)
expr_stmt|;
name|closenf
argument_list|(
operator|&
name|tmpio
argument_list|)
expr_stmt|;
comment|/* close them up */
name|x
argument_list|(
operator|(
name|tmpio
operator|.
name|fidndx
operator|=
name|open
argument_list|(
name|fn1
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
argument_list|,
literal|"compress: reopen 1"
argument_list|)
expr_stmt|;
comment|/* open R/W */
name|x
argument_list|(
operator|(
name|tmpio
operator|.
name|fidrdx
operator|=
name|open
argument_list|(
name|fn2
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
argument_list|,
literal|"compress: reopen 2"
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|tmpio
operator|.
name|fidtxt
operator|=
name|open
argument_list|(
name|fn3
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
argument_list|,
literal|"compress: reopen 3"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmpio
operator|.
name|nf
argument_list|,
name|io
operator|->
name|nf
argument_list|)
expr_stmt|;
comment|/* notesfile name */
name|strcpy
argument_list|(
name|tmpio
operator|.
name|basedir
argument_list|,
name|io
operator|->
name|basedir
argument_list|)
expr_stmt|;
comment|/* and directory */
name|nnotes
operator|=
name|nresps
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|txtfn
argument_list|,
literal|"/tmp/nf%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* scratch for text */
if|if
condition|(
name|lockflag
condition|)
name|locknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* lock up the notefile */
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|tmpio
operator|.
name|descr
argument_list|)
expr_stmt|;
comment|/* grab descriptor */
if|if
condition|(
name|io
operator|->
name|descr
operator|.
name|d_stat
operator|&
name|NFINVALID
condition|)
block|{
name|printf
argument_list|(
literal|"Notesfile compressed behind your back"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockflag
condition|)
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
name|closenf
argument_list|(
operator|&
name|tmpio
argument_list|)
expr_stmt|;
comment|/* clean up mess */
name|x
argument_list|(
name|unlink
argument_list|(
name|fn1
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: unlink tmp1"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|unlink
argument_list|(
name|fn2
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: unlink tmp2"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|unlink
argument_list|(
name|fn3
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: unlink tmp3"
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|old_umask
argument_list|)
expr_stmt|;
comment|/* restore */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|locknf
argument_list|(
name|io
argument_list|,
name|TXTLOCK
argument_list|)
expr_stmt|;
comment|/* always */
name|tmpio
operator|.
name|descr
operator|.
name|d_nnote
operator|=
literal|0
expr_stmt|;
comment|/* reset note count */
name|tmpio
operator|.
name|descr
operator|.
name|d_delnote
operator|=
literal|0
expr_stmt|;
comment|/* no holes */
name|tmpio
operator|.
name|descr
operator|.
name|d_delresp
operator|=
literal|0
expr_stmt|;
name|putdscr
argument_list|(
operator|&
name|tmpio
argument_list|,
operator|&
name|tmpio
operator|.
name|descr
argument_list|)
expr_stmt|;
comment|/* place it into the file */
if|if
condition|(
name|io
operator|->
name|descr
operator|.
name|d_plcy
condition|)
comment|/* copy the policy note over */
block|{
name|getnrec
argument_list|(
name|io
argument_list|,
literal|0
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* descriptor */
ifdef|#
directive|ifdef
name|notdef
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|txtfn
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"compress:bad txt"
argument_list|)
expr_stmt|;
name|pageout
argument_list|(
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|,
name|txtfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|txtfn
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"compress: bad txt read"
argument_list|)
expr_stmt|;
name|pagein
argument_list|(
operator|&
name|tmpio
argument_list|,
name|txtfile
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
else|#
directive|else
name|pagemove
argument_list|(
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|,
operator|&
name|tmpio
argument_list|,
operator|&
name|where
argument_list|,
name|NOLOCKIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FIXTIMES
name|fixtime
argument_list|(
operator|&
name|note
operator|.
name|n_rcvd
argument_list|)
expr_stmt|;
name|fixtime
argument_list|(
operator|&
name|note
operator|.
name|n_lmod
argument_list|)
expr_stmt|;
name|fixtime
argument_list|(
operator|&
name|note
operator|.
name|n_date
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|FIXTIME
name|putnote
argument_list|(
operator|&
name|tmpio
argument_list|,
operator|&
name|where
argument_list|,
name|note
operator|.
name|ntitle
argument_list|,
name|note
operator|.
name|n_stat
argument_list|,
operator|&
name|note
argument_list|,
operator|&
name|note
operator|.
name|n_auth
argument_list|,
name|POLICY
argument_list|,
name|NOLOCKIT
argument_list|,
name|NOADDID
argument_list|,
name|note
operator|.
name|n_from
argument_list|,
name|NOADDTIME
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|num
operator|=
literal|1
init|;
name|num
operator|<=
name|io
operator|->
name|descr
operator|.
name|d_nnote
condition|;
name|num
operator|++
control|)
block|{
if|if
condition|(
name|verbosity
condition|)
comment|/* if being noisy */
block|{
name|putchar
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* so he see action */
block|}
name|getnrec
argument_list|(
name|io
argument_list|,
name|num
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|.
name|n_stat
operator|&
name|DELETED
condition|)
continue|continue;
comment|/* deleted - we throw away */
ifdef|#
directive|ifdef
name|notdef
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|txtfn
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"compress:bad txt"
argument_list|)
expr_stmt|;
name|pageout
argument_list|(
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|,
name|txtfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|txtfn
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"compress: bad txt read"
argument_list|)
expr_stmt|;
name|pagein
argument_list|(
operator|&
name|tmpio
argument_list|,
name|txtfile
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
else|#
directive|else
name|pagemove
argument_list|(
name|io
argument_list|,
operator|&
name|note
operator|.
name|n_addr
argument_list|,
operator|&
name|tmpio
argument_list|,
operator|&
name|where
argument_list|,
name|NOLOCKIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|presps
operator|=
name|note
operator|.
name|n_nresp
expr_stmt|;
comment|/* save max number of responses */
ifdef|#
directive|ifdef
name|FIXTIMES
name|fixtime
argument_list|(
operator|&
name|note
operator|.
name|n_rcvd
argument_list|)
expr_stmt|;
name|fixtime
argument_list|(
operator|&
name|note
operator|.
name|n_lmod
argument_list|)
expr_stmt|;
name|fixtime
argument_list|(
operator|&
name|note
operator|.
name|n_date
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|FIXTIME
name|newnum
operator|=
name|putnote
argument_list|(
operator|&
name|tmpio
argument_list|,
operator|&
name|where
argument_list|,
name|note
operator|.
name|ntitle
argument_list|,
name|note
operator|.
name|n_stat
argument_list|,
operator|&
name|note
argument_list|,
operator|&
name|note
operator|.
name|n_auth
argument_list|,
name|NOPOLICY
argument_list|,
name|NOLOCKIT
argument_list|,
name|NOADDID
argument_list|,
name|note
operator|.
name|n_from
argument_list|,
name|NOADDTIME
argument_list|)
expr_stmt|;
name|nnotes
operator|++
expr_stmt|;
comment|/* add a note */
for|for
control|(
name|rnum
operator|=
literal|1
init|;
name|rnum
operator|<=
name|presps
condition|;
name|rnum
operator|++
control|)
comment|/* process responses */
block|{
if|if
condition|(
name|lrsp
argument_list|(
name|io
argument_list|,
name|num
argument_list|,
name|rnum
argument_list|,
operator|&
name|resp
argument_list|,
operator|&
name|roffset
argument_list|,
operator|&
name|rblock
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* bad response chain - drop rest */
ifdef|#
directive|ifdef
name|notdef
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|txtfn
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"compress:bad txt"
argument_list|)
expr_stmt|;
name|pageout
argument_list|(
name|io
argument_list|,
operator|&
name|resp
operator|.
name|r_addr
index|[
name|roffset
index|]
argument_list|,
name|txtfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|txtfile
operator|=
name|fopen
argument_list|(
name|txtfn
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"compress: bad txt read"
argument_list|)
expr_stmt|;
name|pagein
argument_list|(
operator|&
name|tmpio
argument_list|,
name|txtfile
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfile
argument_list|)
expr_stmt|;
else|#
directive|else
name|pagemove
argument_list|(
name|io
argument_list|,
operator|&
name|resp
operator|.
name|r_addr
index|[
name|roffset
index|]
argument_list|,
operator|&
name|tmpio
argument_list|,
operator|&
name|where
argument_list|,
name|NOLOCKIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FIXTIMES
name|fixtime
argument_list|(
operator|&
name|resp
operator|.
name|r_when
index|[
name|roffset
index|]
argument_list|)
expr_stmt|;
name|fixtime
argument_list|(
operator|&
name|resp
operator|.
name|r_rcvd
index|[
name|roffset
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|FIXTIMES
name|putresp
argument_list|(
operator|&
name|tmpio
argument_list|,
operator|&
name|where
argument_list|,
name|resp
operator|.
name|r_stat
index|[
name|roffset
index|]
argument_list|,
name|newnum
argument_list|,
operator|&
name|resp
operator|.
name|r_when
index|[
name|roffset
index|]
argument_list|,
operator|&
name|resp
operator|.
name|r_auth
index|[
name|roffset
index|]
argument_list|,
operator|&
name|note
argument_list|,
name|NOLOCKIT
argument_list|,
operator|&
name|resp
operator|.
name|r_id
index|[
name|roffset
index|]
argument_list|,
name|NOADDID
argument_list|,
name|resp
operator|.
name|r_from
index|[
name|roffset
index|]
argument_list|,
name|NOADDTIME
argument_list|,
operator|&
name|resp
operator|.
name|r_rcvd
index|[
name|roffset
index|]
argument_list|)
expr_stmt|;
name|nresps
operator|++
expr_stmt|;
comment|/* count responses */
block|}
block|}
comment|/*	well, we have now copied the entire notefile over, so the time  *	has come to move it back into the correct file names - we will  *	do this by   */
name|closenf
argument_list|(
operator|&
name|tmpio
argument_list|)
expr_stmt|;
comment|/* close the new one */
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
name|io
operator|->
name|descr
operator|.
name|d_stat
operator||=
name|NFINVALID
expr_stmt|;
comment|/* mark it bad */
name|putdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
name|closenf
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|/* close the old one */
name|x
argument_list|(
name|unlink
argument_list|(
name|on1
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: remove old 1"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|link
argument_list|(
name|fn1
argument_list|,
name|on1
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: link new 1"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|unlink
argument_list|(
name|fn1
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: remove tmp 1"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|unlink
argument_list|(
name|on2
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: remove old 2"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|link
argument_list|(
name|fn2
argument_list|,
name|on2
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: link new 2"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|unlink
argument_list|(
name|fn2
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: remove tmp 2"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|unlink
argument_list|(
name|on3
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: remove old 3"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|link
argument_list|(
name|fn3
argument_list|,
name|on3
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: link new 3"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|unlink
argument_list|(
name|fn3
argument_list|)
operator|<
literal|0
argument_list|,
literal|"compress: remove tmp 3"
argument_list|)
expr_stmt|;
name|opennf
argument_list|(
name|io
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* relink to new one */
name|getdscr
argument_list|(
name|io
argument_list|,
operator|&
name|io
operator|->
name|descr
argument_list|)
expr_stmt|;
comment|/* get new descr */
if|if
condition|(
name|lockflag
condition|)
name|unlocknf
argument_list|(
name|io
argument_list|,
name|DSCRLOCK
argument_list|)
expr_stmt|;
comment|/* release the locks */
name|unlocknf
argument_list|(
name|io
argument_list|,
name|TXTLOCK
argument_list|)
expr_stmt|;
comment|/* always text lock */
ifdef|#
directive|ifdef
name|notdef
name|unlink
argument_list|(
name|txtfn
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|numnotes
operator|=
name|nnotes
expr_stmt|;
comment|/* fill in callers values */
operator|*
name|numresps
operator|=
name|nresps
expr_stmt|;
name|umask
argument_list|(
name|old_umask
argument_list|)
expr_stmt|;
comment|/* restore */
return|return
literal|0
return|;
comment|/* return ok */
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|FIXTIMES
end_ifdef

begin_expr_stmt
specifier|static
name|fixtime
argument_list|(
argument|when
argument_list|)
expr|struct
name|when_f
operator|*
name|when
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|when_f
name|built
decl_stmt|;
if|if
condition|(
name|when
operator|->
name|w_gmttime
operator|==
literal|0
condition|)
return|return;
comment|/* already ok */
if|if
condition|(
name|when
operator|->
name|w_gmttime
operator|<
literal|0
condition|)
block|{
name|when
operator|->
name|w_gmttime
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|maketime
argument_list|(
operator|&
name|built
argument_list|,
name|when
operator|->
name|w_gmttime
argument_list|)
expr_stmt|;
if|if
condition|(
name|built
operator|.
name|w_year
operator|!=
name|when
operator|->
name|w_year
operator|||
name|built
operator|.
name|w_month
operator|!=
name|when
operator|->
name|w_month
operator|||
name|built
operator|.
name|w_day
operator|!=
name|when
operator|->
name|w_day
operator|||
name|built
operator|.
name|w_hours
operator|!=
name|when
operator|->
name|w_hours
operator|||
name|built
operator|.
name|w_mins
operator|!=
name|when
operator|->
name|w_mins
condition|)
name|when
operator|->
name|w_gmttime
operator|=
literal|0
expr_stmt|;
comment|/* zero it */
block|}
end_block

begin_endif
endif|#
directive|endif
endif|FIXTIMES
end_endif

end_unit

