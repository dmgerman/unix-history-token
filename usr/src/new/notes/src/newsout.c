begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_include
include|#
directive|include
file|"newsgate.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FASTSEQ
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
endif|FASTSEQ
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: newsout.c,v 1.7.0.2 85/03/22 10:53:59 notes Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|RCSIDENT
end_endif

begin_comment
comment|/*  *	newsoutput - process a particular notesfile for updates  *	out to the news system.  *  *  *	Original Coding:	Ray Essick	April 1982  *	Modified to handle gateing for multiple systems better  *				Ray Essick	September 1982  */
end_comment

begin_macro
name|newsout
argument_list|(
argument|nfname
argument_list|,
argument|backwards
argument_list|,
argument|usetime
argument_list|,
argument|verbosity
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|nfname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|io_f
name|io
decl_stmt|;
name|struct
name|note_f
name|note
decl_stmt|;
name|struct
name|resp_f
name|rsprec
decl_stmt|;
name|struct
name|when_f
name|whendump
decl_stmt|;
comment|/* when we did this */
name|int
name|notenum
decl_stmt|,
name|respnum
decl_stmt|,
name|rdumped
decl_stmt|,
name|ndumped
decl_stmt|,
comment|/* number dumped */
name|roffset
decl_stmt|,
name|rblock
decl_stmt|;
name|char
name|basengroup
index|[
name|NNLEN
index|]
decl_stmt|;
comment|/* hold newsgroup */
name|char
name|respngroup
index|[
name|NNLEN
index|]
decl_stmt|;
comment|/* hold newsgroup */
name|FILE
modifier|*
name|log
decl_stmt|;
name|char
name|buf
index|[
name|CMDLEN
index|]
decl_stmt|;
name|char
name|ztime
index|[
name|DATELEN
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|FASTSEQ
block|{
name|struct
name|when_f
name|whenvec
decl_stmt|;
name|char
name|NoteFile
index|[
name|WDLEN
index|]
decl_stmt|;
name|struct
name|stat
name|StatBuf
decl_stmt|;
if|if
condition|(
name|nfname
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
comment|/* absolute pathname */
block|{
name|getlast
argument_list|(
operator|&
name|io
operator|.
name|stime
argument_list|,
name|rindex
argument_list|(
name|nfname
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|,
name|usetime
argument_list|,
name|Seqname
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|NoteFile
argument_list|,
literal|"%s/%s"
argument_list|,
name|nfname
argument_list|,
name|TEXT
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* from Mstdir */
block|{
name|getlast
argument_list|(
operator|&
name|io
operator|.
name|stime
argument_list|,
name|nfname
argument_list|,
name|usetime
argument_list|,
name|Seqname
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|NoteFile
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|Mstdir
argument_list|,
name|nfname
argument_list|,
name|TEXT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|NoteFile
argument_list|,
operator|&
name|StatBuf
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|maketime
argument_list|(
operator|&
name|whenvec
argument_list|,
operator|(
name|long
operator|)
name|StatBuf
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|inorder
argument_list|(
operator|&
name|whenvec
argument_list|,
operator|&
name|io
operator|.
name|stime
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
endif|#
directive|endif
endif|FASTSEQ
if|if
condition|(
name|init
argument_list|(
operator|&
name|io
argument_list|,
name|nfname
argument_list|)
operator|<
literal|0
condition|)
comment|/* open the bugger */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|io
operator|.
name|descr
operator|.
name|d_stat
operator|&
name|NETWRKD
operator|)
operator|==
literal|0
condition|)
comment|/* can we gate? */
block|{
name|closenf
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s must be networked to go to news!\n"
argument_list|,
name|nfname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|gettime
argument_list|(
operator|&
name|whendump
argument_list|)
expr_stmt|;
comment|/* for seq. update */
name|getlast
argument_list|(
operator|&
name|io
operator|.
name|stime
argument_list|,
name|io
operator|.
name|nf
argument_list|,
name|usetime
argument_list|,
name|Seqname
argument_list|)
expr_stmt|;
comment|/* grab last time */
name|newsgroup
argument_list|(
name|io
operator|.
name|nf
argument_list|,
name|basengroup
argument_list|,
name|NFBASENEWS
argument_list|)
expr_stmt|;
comment|/* alias base notes */
name|newsgroup
argument_list|(
name|io
operator|.
name|nf
argument_list|,
name|respngroup
argument_list|,
name|NFRESPNEWS
argument_list|)
expr_stmt|;
comment|/* and responses */
if|if
condition|(
name|inorder
argument_list|(
operator|&
name|io
operator|.
name|descr
operator|.
name|d_lastm
argument_list|,
operator|&
name|io
operator|.
name|stime
argument_list|)
condition|)
comment|/* no traffic */
block|{
ifdef|#
directive|ifdef
name|FASTSEQ
comment|/*  *	Update the timestamp so the next scan will catch the idle  *	notesfile in the FASTSEQ code.  */
name|fixlast
argument_list|(
operator|&
name|whendump
argument_list|,
name|io
operator|.
name|nf
argument_list|,
name|NORMSEQ
argument_list|,
name|Seqname
argument_list|)
expr_stmt|;
comment|/* update sequencer */
endif|#
directive|endif
endif|FASTSEQ
name|closenf
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
comment|/* cheap no-stats exit */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* and out of here */
block|}
name|ndumped
operator|=
name|rdumped
operator|=
literal|0
expr_stmt|;
name|notenum
operator|=
literal|0
expr_stmt|;
comment|/* start at the top */
while|while
condition|(
operator|(
name|notenum
operator|=
name|nxtnote
argument_list|(
operator|&
name|io
argument_list|,
name|notenum
argument_list|,
operator|&
name|io
operator|.
name|stime
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|getnrec
argument_list|(
operator|&
name|io
argument_list|,
name|notenum
argument_list|,
operator|&
name|note
argument_list|)
expr_stmt|;
comment|/* get descriptor */
name|respnum
operator|=
literal|0
expr_stmt|;
comment|/* response chain */
if|if
condition|(
name|inorder
argument_list|(
operator|&
name|io
operator|.
name|stime
argument_list|,
operator|&
name|note
operator|.
name|n_rcvd
argument_list|)
operator|==
literal|0
condition|)
comment|/* been dumped */
goto|goto
name|doresps
goto|;
if|if
condition|(
operator|(
name|note
operator|.
name|n_stat
operator|&
name|FRMNEWS
operator|)
operator|!=
literal|0
condition|)
comment|/* it's been in news */
goto|goto
name|doresps
goto|;
comment|/* dont send back! */
if|if
condition|(
operator|(
name|note
operator|.
name|n_stat
operator|&
name|ORPHND
operator|)
operator|!=
literal|0
condition|)
comment|/* no foster parents */
goto|goto
name|doresps
goto|;
comment|/* go out */
if|if
condition|(
operator|!
name|cansend
argument_list|(
name|note
operator|.
name|n_id
operator|.
name|sys
argument_list|,
name|sendclass
argument_list|)
condition|)
comment|/* can't send it */
goto|goto
name|doresps
goto|;
comment|/* don't dump it */
if|if
condition|(
name|newsnote
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|note
argument_list|,
name|notenum
argument_list|,
name|basengroup
argument_list|,
name|backwards
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|Mstdir
argument_list|,
name|UTILITY
argument_list|,
name|NETLOG
argument_list|)
expr_stmt|;
name|sprdate
argument_list|(
operator|&
name|whendump
argument_list|,
name|ztime
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|log
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"newsout: no log file"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log
argument_list|,
literal|"%s: Failed dumping note to NEWS for %s at %s\n"
argument_list|,
name|nfname
argument_list|,
name|note
operator|.
name|n_id
operator|.
name|sys
argument_list|,
name|ztime
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Failed dumping note to NEWS for %s at %s\n"
argument_list|,
name|nfname
argument_list|,
name|note
operator|.
name|n_id
operator|.
name|sys
argument_list|,
name|ztime
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* dump it */
name|ndumped
operator|++
expr_stmt|;
comment|/* count */
name|doresps
label|:
comment|/* process responses */
while|while
condition|(
operator|(
name|respnum
operator|=
name|nxtresp
argument_list|(
operator|&
name|io
argument_list|,
name|notenum
argument_list|,
name|respnum
argument_list|,
operator|&
name|io
operator|.
name|stime
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|lrsp
argument_list|(
operator|&
name|io
argument_list|,
name|notenum
argument_list|,
name|respnum
argument_list|,
operator|&
name|rsprec
argument_list|,
operator|&
name|roffset
argument_list|,
operator|&
name|rblock
argument_list|)
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* bad chain */
if|if
condition|(
name|rsprec
operator|.
name|r_stat
index|[
name|roffset
index|]
operator|&
name|FRMNEWS
condition|)
comment|/* its from there */
continue|continue;
comment|/* dont go back */
if|if
condition|(
operator|!
name|cansend
argument_list|(
name|rsprec
operator|.
name|r_id
index|[
name|roffset
index|]
operator|.
name|sys
argument_list|,
name|sendclass
argument_list|)
condition|)
comment|/* if can't then */
continue|continue;
comment|/* don't send it */
if|if
condition|(
name|newsresp
argument_list|(
operator|&
name|io
argument_list|,
operator|&
name|note
argument_list|,
name|notenum
argument_list|,
operator|&
name|rsprec
argument_list|,
name|roffset
argument_list|,
name|respnum
argument_list|,
name|respngroup
argument_list|,
name|backwards
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|Mstdir
argument_list|,
name|UTILITY
argument_list|,
name|NETLOG
argument_list|)
expr_stmt|;
name|sprdate
argument_list|(
operator|&
name|whendump
argument_list|,
name|ztime
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|log
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"newsout: no log file"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log
argument_list|,
literal|"%s: Failed dumping note to NEWS for %s at %s\n"
argument_list|,
name|nfname
argument_list|,
name|rsprec
operator|.
name|r_id
index|[
name|roffset
index|]
operator|.
name|sys
argument_list|,
name|ztime
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Failed dumping note to NEWS for %s at %s\n"
argument_list|,
name|nfname
argument_list|,
name|rsprec
operator|.
name|r_id
index|[
name|roffset
index|]
operator|.
name|sys
argument_list|,
name|ztime
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|rdumped
operator|++
expr_stmt|;
block|}
block|}
comment|/*  *	update the sequencer always.  This is fine if we did send  *	something for the system (and what we want to happen).  *	By updating even when we don't send news, we avoid having  *	to rescan those candidates we just looked at the next time.  *	Eg: Running newsoutput for a usually quiet site could get  *	very expensive if we didn't update this timestamp.  *  *	We catch the "idle notesfile" case earlier and leave  *	without scanning or updating if nothing of potential  *	interest has happened since the last run.  */
name|fixlast
argument_list|(
operator|&
name|whendump
argument_list|,
name|io
operator|.
name|nf
argument_list|,
name|NORMSEQ
argument_list|,
name|Seqname
argument_list|)
expr_stmt|;
comment|/* update sequencer */
if|if
condition|(
name|ndumped
operator|+
name|rdumped
condition|)
comment|/* log dump */
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|Mstdir
argument_list|,
name|UTILITY
argument_list|,
name|NETLOG
argument_list|)
expr_stmt|;
name|sprdate
argument_list|(
operator|&
name|whendump
argument_list|,
name|ztime
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|log
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"newsout: missing log file"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log
argument_list|,
literal|"%s: Send (%d,%d) to NEWS at %s\n"
argument_list|,
name|nfname
argument_list|,
name|ndumped
argument_list|,
name|rdumped
argument_list|,
name|ztime
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Send (%d,%d) to NEWS (%s and %s) at %s\n"
argument_list|,
name|nfname
argument_list|,
name|ndumped
argument_list|,
name|rdumped
argument_list|,
name|basengroup
argument_list|,
name|respngroup
argument_list|,
name|ztime
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|finish
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
comment|/* close shop here */
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  *	cansend(system,sendclass)  *  *	check if we are gatewaying articles for the system named  *	in "whichsys".  Use the "sendclass" variable to check  *	against sending anyone (NEWS_ALLSEND bit)  *	If that doesn't qualify us, look through a list of  *	sitenames in the gatesysname[] array.  */
end_comment

begin_macro
name|cansend
argument_list|(
argument|sysname
argument_list|,
argument|class
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sysname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|class
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
specifier|extern
name|int
name|gatesyscount
decl_stmt|;
comment|/* size of array */
specifier|extern
name|char
modifier|*
name|gatesysnames
index|[
name|GATEMAX
index|]
decl_stmt|;
comment|/* actual data */
if|if
condition|(
name|class
operator|&
name|NEWS_ALLSEND
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* sending any articles */
comment|/*       * This list should be sorted and we should do a binary search      * on the bugger....      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gatesyscount
condition|;
name|i
operator|++
control|)
comment|/* look through table */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sysname
argument_list|,
name|gatesysnames
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* find and dandy */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* anything else is nogo */
block|}
end_block

end_unit

