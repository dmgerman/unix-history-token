begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1982 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)canfield.c 4.1 %G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The canfield program  *  * Authors:  *	Originally written: Steve Levine  *	Converted to use curses and debugged: Steve Feldman  *	Card counting: Kirk McKusick and Mikey Olson  */
end_comment

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_define
define|#
directive|define
name|decksize
value|52
end_define

begin_define
define|#
directive|define
name|originrow
value|0
end_define

begin_define
define|#
directive|define
name|origincol
value|0
end_define

begin_define
define|#
directive|define
name|basecol
value|1
end_define

begin_define
define|#
directive|define
name|boxcol
value|42
end_define

begin_define
define|#
directive|define
name|tboxrow
value|2
end_define

begin_define
define|#
directive|define
name|bboxrow
value|16
end_define

begin_define
define|#
directive|define
name|movecol
value|43
end_define

begin_define
define|#
directive|define
name|moverow
value|15
end_define

begin_define
define|#
directive|define
name|msgcol
value|43
end_define

begin_define
define|#
directive|define
name|msgrow
value|14
end_define

begin_define
define|#
directive|define
name|titlecol
value|30
end_define

begin_define
define|#
directive|define
name|titlerow
value|0
end_define

begin_define
define|#
directive|define
name|sidecol
value|1
end_define

begin_define
define|#
directive|define
name|ottlrow
value|6
end_define

begin_define
define|#
directive|define
name|foundcol
value|11
end_define

begin_define
define|#
directive|define
name|foundrow
value|3
end_define

begin_define
define|#
directive|define
name|stockcol
value|2
end_define

begin_define
define|#
directive|define
name|stockrow
value|8
end_define

begin_define
define|#
directive|define
name|fttlcol
value|10
end_define

begin_define
define|#
directive|define
name|fttlrow
value|1
end_define

begin_define
define|#
directive|define
name|taloncol
value|2
end_define

begin_define
define|#
directive|define
name|talonrow
value|13
end_define

begin_define
define|#
directive|define
name|tabrow
value|8
end_define

begin_define
define|#
directive|define
name|ctoprow
value|21
end_define

begin_define
define|#
directive|define
name|cbotrow
value|23
end_define

begin_define
define|#
directive|define
name|cinitcol
value|14
end_define

begin_define
define|#
directive|define
name|cheightcol
value|1
end_define

begin_define
define|#
directive|define
name|cwidthcol
value|4
end_define

begin_define
define|#
directive|define
name|handstatrow
value|21
end_define

begin_define
define|#
directive|define
name|handstatcol
value|7
end_define

begin_define
define|#
directive|define
name|talonstatrow
value|22
end_define

begin_define
define|#
directive|define
name|talonstatcol
value|7
end_define

begin_define
define|#
directive|define
name|stockstatrow
value|23
end_define

begin_define
define|#
directive|define
name|stockstatcol
value|7
end_define

begin_define
define|#
directive|define
name|Ace
value|1
end_define

begin_define
define|#
directive|define
name|Jack
value|11
end_define

begin_define
define|#
directive|define
name|Queen
value|12
end_define

begin_define
define|#
directive|define
name|King
value|13
end_define

begin_define
define|#
directive|define
name|atabcol
value|11
end_define

begin_define
define|#
directive|define
name|btabcol
value|18
end_define

begin_define
define|#
directive|define
name|ctabcol
value|25
end_define

begin_define
define|#
directive|define
name|dtabcol
value|32
end_define

begin_define
define|#
directive|define
name|spades
value|'s'
end_define

begin_define
define|#
directive|define
name|clubs
value|'c'
end_define

begin_define
define|#
directive|define
name|hearts
value|'h'
end_define

begin_define
define|#
directive|define
name|diamonds
value|'d'
end_define

begin_define
define|#
directive|define
name|black
value|'b'
end_define

begin_define
define|#
directive|define
name|red
value|'r'
end_define

begin_define
define|#
directive|define
name|stk
value|1
end_define

begin_define
define|#
directive|define
name|tal
value|2
end_define

begin_define
define|#
directive|define
name|tab
value|3
end_define

begin_define
define|#
directive|define
name|INCRHAND
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|)
value|{\ 	row -= cheightcol;\ 	if (row< ctoprow) {\ 		row = cbotrow;\ 		col += cwidthcol;\ 	}\ }
end_define

begin_define
define|#
directive|define
name|DECRHAND
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|)
value|{\ 	row += cheightcol;\ 	if (row> cbotrow) {\ 		row = ctoprow;\ 		col -= cwidthcol;\ 	}\ }
end_define

begin_struct
struct|struct
name|cardtype
block|{
name|char
name|suit
decl_stmt|;
name|char
name|color
decl_stmt|;
name|bool
name|visible
decl_stmt|;
name|int
name|rank
decl_stmt|;
name|struct
name|cardtype
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NIL
value|((struct cardtype *) -1)
end_define

begin_decl_stmt
name|struct
name|cardtype
modifier|*
name|deck
index|[
name|decksize
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cardtype
name|cards
index|[
name|decksize
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cardtype
modifier|*
name|bottom
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|found
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|tableau
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cardtype
modifier|*
name|talon
decl_stmt|,
modifier|*
name|hand
decl_stmt|,
modifier|*
name|stock
decl_stmt|,
modifier|*
name|basecard
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cardsoff
decl_stmt|,
name|base
decl_stmt|,
name|cinhand
decl_stmt|,
name|taloncnt
decl_stmt|,
name|stockcnt
decl_stmt|,
name|timesthru
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|suitmap
index|[
literal|4
index|]
init|=
block|{
name|spades
block|,
name|clubs
block|,
name|hearts
block|,
name|diamonds
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|colormap
index|[
literal|4
index|]
init|=
block|{
name|black
block|,
name|black
block|,
name|red
block|,
name|red
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|pilemap
index|[
literal|4
index|]
init|=
block|{
name|atabcol
block|,
name|btabcol
block|,
name|ctabcol
block|,
name|dtabcol
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|srcpile
decl_stmt|,
name|destpile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mtforigin
decl_stmt|,
name|tempbase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|coldcol
decl_stmt|,
name|cnewcol
decl_stmt|,
name|coldrow
decl_stmt|,
name|cnewrow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|errmsg
decl_stmt|,
name|done
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|mtfdone
decl_stmt|,
name|Cflag
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  * The following procedures print the board onto the screen using the  * addressible cursor. The end of these procedures will also be  * separated from the rest of the program.  */
end_comment

begin_comment
comment|/* procedure to set the move command box */
end_comment

begin_macro
name|movebox
argument_list|()
end_macro

begin_block
block|{
name|move
argument_list|(
name|tboxrow
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"*--------------------------*"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|1
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|         MOVES            |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|2
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|s# = stock to tableau     |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|3
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|sf = stock to foundation  |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|4
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|t# = talon to tableau     |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|5
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|tf = talon to foundation  |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|6
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|## = tableau to tableau   |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|7
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|#f = tableau to foundation|"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|8
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|ht = hand to talon        |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|9
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|c = toggle card counting  |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|10
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|q = quit to end the game  |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tboxrow
operator|+
literal|11
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|==========================|"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|moverow
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|                          |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|msgrow
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|                          |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|bboxrow
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|Replace the # with the    |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|bboxrow
operator|+
literal|1
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|number of the tableau you |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|bboxrow
operator|+
literal|2
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|want, 1, 2, 3, or 4.      |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|bboxrow
operator|+
literal|3
argument_list|,
name|boxcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"*--------------------------*"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* procedure to put the board on the screen using addressable cursor */
end_comment

begin_macro
name|makeboard
argument_list|()
end_macro

begin_block
block|{
name|clear
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|move
argument_list|(
name|titlerow
argument_list|,
name|titlecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=-> CANFIELD<-="
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|fttlrow
argument_list|,
name|fttlcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"foundation"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|foundrow
operator|-
literal|1
argument_list|,
name|fttlcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---=  =---=  =---=  =---="
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|foundrow
argument_list|,
name|fttlcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|   |  |   |  |   |  |   |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|foundrow
operator|+
literal|1
argument_list|,
name|fttlcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---=  =---=  =---=  =---="
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|ottlrow
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"stock     tableau"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|stockrow
operator|-
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---="
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|stockrow
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|   |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|stockrow
operator|+
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---="
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
operator|-
literal|2
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"talon"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
operator|-
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---="
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|   |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
operator|+
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---="
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|tabrow
operator|-
literal|1
argument_list|,
name|atabcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"-1-    -2-    -3-    -4-"
argument_list|)
expr_stmt|;
name|movebox
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
end_comment

begin_comment
comment|/* clean up the board for another game */
end_comment

begin_macro
name|cleanupboard
argument_list|()
end_macro

begin_block
block|{
name|int
name|cnt
decl_stmt|,
name|row
decl_stmt|,
name|col
decl_stmt|;
name|struct
name|cardtype
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|Cflag
condition|)
block|{
name|clearstat
argument_list|()
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|stock
operator|,
name|row
operator|=
name|stockrow
init|;
name|ptr
operator|!=
name|NIL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
operator|,
name|row
operator|++
control|)
block|{
name|move
argument_list|(
name|row
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
block|}
name|move
argument_list|(
name|row
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|stockrow
operator|+
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---="
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
operator|-
literal|2
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"talon"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
operator|-
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---="
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
operator|+
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---="
argument_list|)
expr_stmt|;
block|}
name|move
argument_list|(
name|stockrow
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|   |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|   |"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|foundrow
argument_list|,
name|fttlcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|   |  |   |  |   |  |   |"
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|4
condition|;
name|cnt
operator|++
control|)
block|{
switch|switch
condition|(
name|cnt
condition|)
block|{
case|case
literal|0
case|:
name|col
operator|=
name|atabcol
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|col
operator|=
name|btabcol
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|col
operator|=
name|ctabcol
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|col
operator|=
name|dtabcol
expr_stmt|;
break|break;
block|}
for|for
control|(
name|ptr
operator|=
name|tableau
index|[
name|cnt
index|]
operator|,
name|row
operator|=
name|tabrow
init|;
name|ptr
operator|!=
name|NIL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
operator|,
name|row
operator|++
control|)
name|removecard
argument_list|(
name|col
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* procedure to create a deck of cards */
end_comment

begin_macro
name|initdeck
argument_list|(
argument|deck
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|cardtype
modifier|*
name|deck
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|scnt
decl_stmt|;
name|char
name|s
decl_stmt|;
name|int
name|r
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|scnt
operator|=
literal|0
init|;
name|scnt
operator|<
literal|4
condition|;
name|scnt
operator|++
control|)
block|{
name|s
operator|=
name|suitmap
index|[
name|scnt
index|]
expr_stmt|;
for|for
control|(
name|r
operator|=
name|Ace
init|;
name|r
operator|<=
name|King
condition|;
name|r
operator|++
control|)
block|{
name|deck
index|[
name|i
index|]
operator|=
operator|&
name|cards
index|[
name|i
index|]
expr_stmt|;
name|cards
index|[
name|i
index|]
operator|.
name|rank
operator|=
name|r
expr_stmt|;
name|cards
index|[
name|i
index|]
operator|.
name|suit
operator|=
name|s
expr_stmt|;
name|cards
index|[
name|i
index|]
operator|.
name|color
operator|=
name|colormap
index|[
name|scnt
index|]
expr_stmt|;
name|cards
index|[
name|i
index|]
operator|.
name|next
operator|=
name|NIL
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* procedure to shuffle the deck */
end_comment

begin_macro
name|shuffle
argument_list|(
argument|deck
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|cardtype
modifier|*
name|deck
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|cardtype
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|decksize
condition|;
name|i
operator|++
control|)
name|deck
index|[
name|i
index|]
operator|->
name|visible
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
name|decksize
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|j
operator|=
name|rand
argument_list|()
operator|%
name|decksize
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|j
condition|)
block|{
name|temp
operator|=
name|deck
index|[
name|i
index|]
expr_stmt|;
name|deck
index|[
name|i
index|]
operator|=
name|deck
index|[
name|j
index|]
expr_stmt|;
name|deck
index|[
name|j
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* procedure to remove the card from the board */
end_comment

begin_macro
name|removecard
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_block
block|{
name|move
argument_list|(
name|b
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* procedure to print the cards on the board */
end_comment

begin_macro
name|printrank
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|cardtype
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|move
argument_list|(
name|b
argument_list|,
name|a
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|rank
condition|)
block|{
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
case|case
literal|8
case|:
case|case
literal|9
case|:
case|case
literal|10
case|:
name|printw
argument_list|(
literal|"%2d"
argument_list|,
name|cp
operator|->
name|rank
argument_list|)
expr_stmt|;
break|break;
case|case
name|Ace
case|:
name|printw
argument_list|(
literal|" A"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Jack
case|:
name|printw
argument_list|(
literal|" J"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Queen
case|:
name|printw
argument_list|(
literal|" Q"
argument_list|)
expr_stmt|;
break|break;
case|case
name|King
case|:
name|printw
argument_list|(
literal|" K"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|printcard
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cardtype
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|cp
operator|==
name|NIL
condition|)
name|removecard
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|->
name|visible
operator|==
name|FALSE
condition|)
block|{
name|move
argument_list|(
name|b
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|" ? "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printrank
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|cp
operator|->
name|suit
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * procedure to move the top card from one location to the top   * of another location. The pointers always point to the top  * of the piles.  */
end_comment

begin_macro
name|transit
argument_list|(
argument|source
argument_list|,
argument|dest
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|cardtype
modifier|*
modifier|*
name|source
decl_stmt|,
modifier|*
modifier|*
name|dest
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|cardtype
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|*
name|source
expr_stmt|;
operator|*
name|source
operator|=
operator|(
operator|*
name|source
operator|)
operator|->
name|next
expr_stmt|;
name|temp
operator|->
name|next
operator|=
operator|*
name|dest
expr_stmt|;
operator|*
name|dest
operator|=
name|temp
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Procedure to set the cards on the foundation base when available.  * Note that it is only called on a foundation pile at the beginning of  * the game, so the pile will have exactly one card in it.  */
end_comment

begin_macro
name|fndbase
argument_list|(
argument|cp
argument_list|,
argument|column
argument_list|,
argument|row
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|cardtype
modifier|*
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bool
name|nomore
decl_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
name|NIL
condition|)
do|do
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|)
operator|->
name|rank
operator|==
name|basecard
operator|->
name|rank
condition|)
block|{
name|base
operator|++
expr_stmt|;
name|printcard
argument_list|(
name|pilemap
index|[
name|base
index|]
argument_list|,
name|foundrow
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
name|tableau
index|[
literal|0
index|]
condition|)
name|length
index|[
literal|0
index|]
operator|=
name|length
index|[
literal|0
index|]
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
name|tableau
index|[
literal|1
index|]
condition|)
name|length
index|[
literal|1
index|]
operator|=
name|length
index|[
literal|1
index|]
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
name|tableau
index|[
literal|2
index|]
condition|)
name|length
index|[
literal|2
index|]
operator|=
name|length
index|[
literal|2
index|]
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
name|tableau
index|[
literal|3
index|]
condition|)
name|length
index|[
literal|3
index|]
operator|=
name|length
index|[
literal|3
index|]
operator|-
literal|1
expr_stmt|;
name|transit
argument_list|(
name|cp
argument_list|,
operator|&
name|found
index|[
name|base
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|&
name|talon
condition|)
name|usedtalon
argument_list|()
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|&
name|stock
condition|)
name|usedstock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
name|NIL
condition|)
block|{
name|printcard
argument_list|(
name|column
argument_list|,
name|row
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
name|nomore
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|removecard
argument_list|(
name|column
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|nomore
operator|=
name|TRUE
expr_stmt|;
block|}
name|cardsoff
operator|++
expr_stmt|;
block|}
else|else
name|nomore
operator|=
name|TRUE
expr_stmt|;
block|}
do|while
condition|(
name|nomore
operator|==
name|FALSE
condition|)
do|;
block|}
end_block

begin_comment
comment|/* procedure to initialize the things necessary for the game */
end_comment

begin_macro
name|initgame
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|18
condition|;
name|i
operator|++
control|)
name|deck
index|[
name|i
index|]
operator|->
name|visible
operator|=
name|TRUE
expr_stmt|;
name|stockcnt
operator|=
literal|13
expr_stmt|;
name|stock
operator|=
name|deck
index|[
literal|12
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|12
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
name|deck
index|[
name|i
index|]
operator|->
name|next
operator|=
name|deck
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|deck
index|[
literal|0
index|]
operator|->
name|next
operator|=
name|NIL
expr_stmt|;
name|found
index|[
literal|0
index|]
operator|=
name|deck
index|[
literal|13
index|]
expr_stmt|;
name|deck
index|[
literal|13
index|]
operator|->
name|next
operator|=
name|NIL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|found
index|[
name|i
index|]
operator|=
name|NIL
expr_stmt|;
name|basecard
operator|=
name|found
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|14
init|;
name|i
operator|<
literal|18
condition|;
name|i
operator|++
control|)
block|{
name|tableau
index|[
name|i
operator|-
literal|14
index|]
operator|=
name|deck
index|[
name|i
index|]
expr_stmt|;
name|deck
index|[
name|i
index|]
operator|->
name|next
operator|=
name|NIL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|bottom
index|[
name|i
index|]
operator|=
name|tableau
index|[
name|i
index|]
expr_stmt|;
name|length
index|[
name|i
index|]
operator|=
name|tabrow
expr_stmt|;
block|}
name|hand
operator|=
name|deck
index|[
literal|18
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|18
init|;
name|i
operator|<
name|decksize
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|deck
index|[
name|i
index|]
operator|->
name|next
operator|=
name|deck
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|deck
index|[
name|decksize
operator|-
literal|1
index|]
operator|->
name|next
operator|=
name|NIL
expr_stmt|;
name|talon
operator|=
name|NIL
expr_stmt|;
name|base
operator|=
literal|0
expr_stmt|;
name|cinhand
operator|=
literal|34
expr_stmt|;
name|taloncnt
operator|=
literal|0
expr_stmt|;
name|timesthru
operator|=
literal|0
expr_stmt|;
name|cardsoff
operator|=
literal|1
expr_stmt|;
name|coldrow
operator|=
name|ctoprow
expr_stmt|;
name|coldcol
operator|=
name|cinitcol
expr_stmt|;
name|cnewrow
operator|=
name|ctoprow
expr_stmt|;
name|cnewcol
operator|=
name|cinitcol
operator|+
name|cwidthcol
expr_stmt|;
block|}
end_block

begin_comment
comment|/* procedure to print the beginning cards and to start each game */
end_comment

begin_macro
name|startgame
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|shuffle
argument_list|(
name|deck
argument_list|)
expr_stmt|;
name|initgame
argument_list|()
expr_stmt|;
name|printcard
argument_list|(
name|foundcol
argument_list|,
name|foundrow
argument_list|,
name|found
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|stockcol
argument_list|,
name|stockrow
argument_list|,
name|stock
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|atabcol
argument_list|,
name|tabrow
argument_list|,
name|tableau
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|btabcol
argument_list|,
name|tabrow
argument_list|,
name|tableau
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|ctabcol
argument_list|,
name|tabrow
argument_list|,
name|tableau
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|dtabcol
argument_list|,
name|tabrow
argument_list|,
name|tableau
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|taloncol
argument_list|,
name|talonrow
argument_list|,
name|talon
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|foundrow
operator|-
literal|2
argument_list|,
name|basecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Base"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|foundrow
operator|-
literal|1
argument_list|,
name|basecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Rank"
argument_list|)
expr_stmt|;
name|printrank
argument_list|(
name|basecol
argument_list|,
name|foundrow
argument_list|,
name|found
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|3
condition|;
name|j
operator|++
control|)
name|fndbase
argument_list|(
operator|&
name|tableau
index|[
name|j
index|]
argument_list|,
name|pilemap
index|[
name|j
index|]
argument_list|,
name|tabrow
argument_list|)
expr_stmt|;
name|fndbase
argument_list|(
operator|&
name|stock
argument_list|,
name|stockcol
argument_list|,
name|stockrow
argument_list|)
expr_stmt|;
name|showstat
argument_list|()
expr_stmt|;
comment|/* show card counting info to cheaters */
block|}
end_block

begin_comment
comment|/* procedure to clear the message printed from an error */
end_comment

begin_macro
name|clearmsg
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|errmsg
operator|==
name|TRUE
condition|)
block|{
name|errmsg
operator|=
name|FALSE
expr_stmt|;
name|move
argument_list|(
name|msgrow
argument_list|,
name|msgcol
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|25
condition|;
name|i
operator|++
control|)
name|addch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* procedure to print an error message if the move is not listed */
end_comment

begin_macro
name|dumberror
argument_list|()
end_macro

begin_block
block|{
name|errmsg
operator|=
name|TRUE
expr_stmt|;
name|move
argument_list|(
name|msgrow
argument_list|,
name|msgcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Not a proper move       "
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* procedure to print an error message if the move is not possible */
end_comment

begin_macro
name|destinerror
argument_list|()
end_macro

begin_block
block|{
name|errmsg
operator|=
name|TRUE
expr_stmt|;
name|move
argument_list|(
name|msgrow
argument_list|,
name|msgcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Error: Can't move there"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* function to see if the source has cards in it */
end_comment

begin_function
name|bool
name|notempty
parameter_list|(
name|cp
parameter_list|)
name|struct
name|cardtype
modifier|*
name|cp
decl_stmt|;
block|{
if|if
condition|(
name|cp
operator|==
name|NIL
condition|)
block|{
name|errmsg
operator|=
name|TRUE
expr_stmt|;
name|move
argument_list|(
name|msgrow
argument_list|,
name|msgcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Error: no cards to move"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|else
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* function to see if the rank of one card is less than another */
end_comment

begin_function
name|bool
name|ranklower
parameter_list|(
name|cp1
parameter_list|,
name|cp2
parameter_list|)
name|struct
name|cardtype
modifier|*
name|cp1
decl_stmt|,
decl|*
name|cp2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|cp2
operator|->
name|rank
operator|==
name|Ace
condition|)
if|if
condition|(
name|cp1
operator|->
name|rank
operator|==
name|King
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
elseif|else
if|if
condition|(
name|cp1
operator|->
name|rank
operator|+
literal|1
operator|==
name|cp2
operator|->
name|rank
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_comment
comment|/* function to check the cardcolor for moving to a tableau */
end_comment

begin_function
name|bool
name|diffcolor
parameter_list|(
name|cp1
parameter_list|,
name|cp2
parameter_list|)
name|struct
name|cardtype
modifier|*
name|cp1
decl_stmt|,
decl|*
name|cp2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|cp1
operator|->
name|color
operator|==
name|cp2
operator|->
name|color
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
else|else
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/* function to see if the card can move to the tableau */
end_comment

begin_function
name|bool
name|tabok
parameter_list|(
name|cp
parameter_list|,
name|des
parameter_list|)
name|struct
name|cardtype
modifier|*
name|cp
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|cp
operator|==
name|stock
operator|)
operator|&&
operator|(
name|tableau
index|[
name|des
index|]
operator|==
name|NIL
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
elseif|else
if|if
condition|(
name|tableau
index|[
name|des
index|]
operator|==
name|NIL
condition|)
if|if
condition|(
name|stock
operator|==
name|NIL
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
elseif|else
if|if
condition|(
name|ranklower
argument_list|(
name|cp
argument_list|,
name|tableau
index|[
name|des
index|]
argument_list|)
operator|&&
name|diffcolor
argument_list|(
name|cp
argument_list|,
name|tableau
index|[
name|des
index|]
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* procedure to turn the cards onto the talon from the deck */
end_comment

begin_macro
name|movetotalon
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|fin
decl_stmt|;
if|if
condition|(
name|cinhand
operator|>=
literal|3
condition|)
name|fin
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|cinhand
operator|>
literal|0
condition|)
name|fin
operator|=
name|cinhand
expr_stmt|;
elseif|else
if|if
condition|(
name|talon
operator|!=
name|NIL
condition|)
block|{
name|timesthru
operator|++
expr_stmt|;
name|errmsg
operator|=
name|TRUE
expr_stmt|;
name|move
argument_list|(
name|msgrow
argument_list|,
name|msgcol
argument_list|)
expr_stmt|;
if|if
condition|(
name|timesthru
operator|!=
literal|4
condition|)
block|{
name|printw
argument_list|(
literal|"Talon is now the new hand"
argument_list|)
expr_stmt|;
while|while
condition|(
name|talon
operator|!=
name|NIL
condition|)
block|{
name|transit
argument_list|(
operator|&
name|talon
argument_list|,
operator|&
name|hand
argument_list|)
expr_stmt|;
name|cinhand
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cinhand
operator|>=
literal|3
condition|)
name|fin
operator|=
literal|3
expr_stmt|;
else|else
name|fin
operator|=
name|cinhand
expr_stmt|;
name|taloncnt
operator|=
literal|0
expr_stmt|;
name|coldrow
operator|=
name|ctoprow
expr_stmt|;
name|coldcol
operator|=
name|cinitcol
expr_stmt|;
name|cnewrow
operator|=
name|ctoprow
expr_stmt|;
name|cnewcol
operator|=
name|cinitcol
operator|+
name|cwidthcol
expr_stmt|;
name|clearstat
argument_list|()
expr_stmt|;
name|showstat
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fin
operator|=
literal|0
expr_stmt|;
name|done
operator|=
name|TRUE
expr_stmt|;
name|printw
argument_list|(
literal|"I believe you have lost"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|errmsg
operator|=
name|TRUE
expr_stmt|;
name|move
argument_list|(
name|msgrow
argument_list|,
name|msgcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Talon and hand are empty"
argument_list|)
expr_stmt|;
name|fin
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fin
condition|;
name|i
operator|++
control|)
block|{
name|transit
argument_list|(
operator|&
name|hand
argument_list|,
operator|&
name|talon
argument_list|)
expr_stmt|;
name|INCRHAND
argument_list|(
name|cnewrow
argument_list|,
name|cnewcol
argument_list|)
expr_stmt|;
name|INCRHAND
argument_list|(
name|coldrow
argument_list|,
name|coldcol
argument_list|)
expr_stmt|;
name|removecard
argument_list|(
name|cnewcol
argument_list|,
name|cnewrow
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|fin
operator|-
literal|1
condition|)
name|talon
operator|->
name|visible
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
name|printcard
argument_list|(
name|coldcol
argument_list|,
name|coldrow
argument_list|,
name|talon
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fin
operator|!=
literal|0
condition|)
block|{
name|printcard
argument_list|(
name|taloncol
argument_list|,
name|talonrow
argument_list|,
name|talon
argument_list|)
expr_stmt|;
name|cinhand
operator|-=
name|fin
expr_stmt|;
name|taloncnt
operator|+=
name|fin
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
block|{
name|move
argument_list|(
name|handstatrow
argument_list|,
name|handstatcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%3d"
argument_list|,
name|cinhand
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonstatrow
argument_list|,
name|talonstatcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%3d"
argument_list|,
name|taloncnt
argument_list|)
expr_stmt|;
block|}
name|fndbase
argument_list|(
operator|&
name|talon
argument_list|,
name|taloncol
argument_list|,
name|talonrow
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* procedure to print card counting info on screen */
end_comment

begin_macro
name|showstat
argument_list|()
end_macro

begin_block
block|{
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
specifier|register
name|struct
name|cardtype
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|Cflag
condition|)
block|{
name|move
argument_list|(
name|talonstatrow
argument_list|,
name|talonstatcol
operator|-
literal|7
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Talon: %3d"
argument_list|,
name|taloncnt
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|handstatrow
argument_list|,
name|handstatcol
operator|-
literal|7
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Hand:  %3d"
argument_list|,
name|cinhand
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|stockstatrow
argument_list|,
name|stockstatcol
operator|-
literal|7
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Stock: %3d"
argument_list|,
name|stockcnt
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
name|coldrow
operator|,
name|col
operator|=
name|coldcol
operator|,
name|ptr
operator|=
name|talon
init|;
name|ptr
operator|!=
name|NIL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|printcard
argument_list|(
name|col
argument_list|,
name|row
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|DECRHAND
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|row
operator|=
name|cnewrow
operator|,
name|col
operator|=
name|cnewcol
operator|,
name|ptr
operator|=
name|hand
init|;
name|ptr
operator|!=
name|NIL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|INCRHAND
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|col
argument_list|,
name|row
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* procedure to clear card counting info from screen */
end_comment

begin_macro
name|clearstat
argument_list|()
end_macro

begin_block
block|{
name|int
name|row
decl_stmt|;
name|move
argument_list|(
name|talonstatrow
argument_list|,
name|talonstatcol
operator|-
literal|7
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"          "
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|handstatrow
argument_list|,
name|handstatcol
operator|-
literal|7
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"          "
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|stockstatrow
argument_list|,
name|stockstatcol
operator|-
literal|7
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"          "
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
name|ctoprow
init|;
name|row
operator|<=
name|cbotrow
condition|;
name|row
operator|++
control|)
block|{
name|move
argument_list|(
name|row
argument_list|,
name|cinitcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%56s"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* procedure to update card counting base */
end_comment

begin_macro
name|usedtalon
argument_list|()
end_macro

begin_block
block|{
name|removecard
argument_list|(
name|coldcol
argument_list|,
name|coldrow
argument_list|)
expr_stmt|;
name|DECRHAND
argument_list|(
name|coldrow
argument_list|,
name|coldcol
argument_list|)
expr_stmt|;
if|if
condition|(
name|talon
operator|!=
name|NIL
operator|&&
operator|(
name|talon
operator|->
name|visible
operator|==
name|FALSE
operator|)
condition|)
block|{
name|talon
operator|->
name|visible
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
name|printcard
argument_list|(
name|coldcol
argument_list|,
name|coldrow
argument_list|,
name|talon
argument_list|)
expr_stmt|;
block|}
name|taloncnt
operator|--
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
block|{
name|move
argument_list|(
name|talonstatrow
argument_list|,
name|talonstatcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%3d"
argument_list|,
name|taloncnt
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* procedure to update stock card counting base */
end_comment

begin_macro
name|usedstock
argument_list|()
end_macro

begin_block
block|{
name|stockcnt
operator|--
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
block|{
name|move
argument_list|(
name|stockstatrow
argument_list|,
name|stockstatcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%3d"
argument_list|,
name|stockcnt
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* let 'em know how they lost! */
end_comment

begin_macro
name|showcards
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|cardtype
modifier|*
name|ptr
decl_stmt|;
name|int
name|row
decl_stmt|;
if|if
condition|(
operator|!
name|Cflag
condition|)
return|return;
for|for
control|(
name|ptr
operator|=
name|talon
init|;
name|ptr
operator|!=
name|NIL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|ptr
operator|->
name|visible
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|hand
init|;
name|ptr
operator|!=
name|NIL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|ptr
operator|->
name|visible
operator|=
name|TRUE
expr_stmt|;
name|showstat
argument_list|()
expr_stmt|;
name|move
argument_list|(
name|stockrow
operator|+
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
operator|-
literal|2
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
operator|-
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|talonrow
operator|+
literal|1
argument_list|,
name|sidecol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|stock
operator|,
name|row
operator|=
name|stockrow
init|;
name|ptr
operator|!=
name|NIL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
operator|,
name|row
operator|++
control|)
block|{
name|move
argument_list|(
name|row
argument_list|,
name|stockcol
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|   |"
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|stockcol
argument_list|,
name|row
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stock
operator|==
name|NIL
condition|)
block|{
name|move
argument_list|(
name|row
argument_list|,
name|stockcol
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|   |"
argument_list|)
expr_stmt|;
name|row
operator|++
expr_stmt|;
block|}
name|move
argument_list|(
name|handstatrow
argument_list|,
name|handstatcol
operator|-
literal|7
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"          "
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|row
argument_list|,
name|stockcol
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"=---="
argument_list|)
expr_stmt|;
name|getcmd
argument_list|(
name|moverow
argument_list|,
name|movecol
argument_list|,
literal|"Hit return to exit"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* procedure to move a card from the stock or talon to the tableau */
end_comment

begin_macro
name|simpletableau
argument_list|(
argument|cp
argument_list|,
argument|des
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|cardtype
modifier|*
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|origin
decl_stmt|;
if|if
condition|(
name|notempty
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
name|tabok
argument_list|(
operator|*
name|cp
argument_list|,
name|des
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
name|stock
condition|)
name|origin
operator|=
name|stk
expr_stmt|;
else|else
name|origin
operator|=
name|tal
expr_stmt|;
if|if
condition|(
name|tableau
index|[
name|des
index|]
operator|==
name|NIL
condition|)
name|bottom
index|[
name|des
index|]
operator|=
operator|*
name|cp
expr_stmt|;
name|transit
argument_list|(
name|cp
argument_list|,
operator|&
name|tableau
index|[
name|des
index|]
argument_list|)
expr_stmt|;
name|length
index|[
name|des
index|]
operator|++
expr_stmt|;
name|printcard
argument_list|(
name|pilemap
index|[
name|des
index|]
argument_list|,
name|length
index|[
name|des
index|]
argument_list|,
name|tableau
index|[
name|des
index|]
argument_list|)
expr_stmt|;
name|timesthru
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|origin
operator|==
name|stk
condition|)
block|{
name|usedstock
argument_list|()
expr_stmt|;
name|printcard
argument_list|(
name|stockcol
argument_list|,
name|stockrow
argument_list|,
name|stock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usedtalon
argument_list|()
expr_stmt|;
name|printcard
argument_list|(
name|taloncol
argument_list|,
name|talonrow
argument_list|,
name|talon
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|destinerror
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|tabprint
argument_list|(
argument|sour
argument_list|,
argument|des
argument_list|)
end_macro

begin_block
block|{
name|int
name|dlength
decl_stmt|,
name|slength
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|cardtype
modifier|*
name|tempcard
decl_stmt|;
for|for
control|(
name|i
operator|=
name|tabrow
init|;
name|i
operator|<=
name|length
index|[
name|sour
index|]
condition|;
name|i
operator|++
control|)
name|removecard
argument_list|(
name|pilemap
index|[
name|sour
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dlength
operator|=
name|length
index|[
name|des
index|]
operator|+
literal|1
expr_stmt|;
name|slength
operator|=
name|length
index|[
name|sour
index|]
expr_stmt|;
if|if
condition|(
name|slength
operator|==
name|tabrow
condition|)
name|printcard
argument_list|(
name|pilemap
index|[
name|des
index|]
argument_list|,
name|dlength
argument_list|,
name|tableau
index|[
name|sour
index|]
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|slength
operator|!=
name|tabrow
operator|-
literal|1
condition|)
block|{
name|tempcard
operator|=
name|tableau
index|[
name|sour
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|slength
operator|-
name|tabrow
condition|;
name|i
operator|++
control|)
name|tempcard
operator|=
name|tempcard
operator|->
name|next
expr_stmt|;
name|printcard
argument_list|(
name|pilemap
index|[
name|des
index|]
argument_list|,
name|dlength
argument_list|,
name|tempcard
argument_list|)
expr_stmt|;
name|slength
operator|--
expr_stmt|;
name|dlength
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* procedure to move from the tableau to the tableau */
end_comment

begin_macro
name|tabtotab
argument_list|(
argument|sour
argument_list|,
argument|des
argument_list|)
end_macro

begin_block
block|{
name|struct
name|cardtype
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|notempty
argument_list|(
name|tableau
index|[
name|sour
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|tabok
argument_list|(
name|bottom
index|[
name|sour
index|]
argument_list|,
name|des
argument_list|)
condition|)
block|{
name|tabprint
argument_list|(
name|sour
argument_list|,
name|des
argument_list|)
expr_stmt|;
name|temp
operator|=
name|bottom
index|[
name|sour
index|]
expr_stmt|;
name|bottom
index|[
name|sour
index|]
operator|=
name|NIL
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|tableau
index|[
name|des
index|]
expr_stmt|;
name|tableau
index|[
name|des
index|]
operator|=
name|tableau
index|[
name|sour
index|]
expr_stmt|;
name|tableau
index|[
name|sour
index|]
operator|=
name|NIL
expr_stmt|;
name|length
index|[
name|des
index|]
operator|=
name|length
index|[
name|des
index|]
operator|+
operator|(
name|length
index|[
name|sour
index|]
operator|-
operator|(
name|tabrow
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|length
index|[
name|sour
index|]
operator|=
name|tabrow
operator|-
literal|1
expr_stmt|;
name|timesthru
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|destinerror
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* functions to see if the card can go onto the foundation */
end_comment

begin_function
name|bool
name|rankhigher
parameter_list|(
name|cp
parameter_list|,
name|let
parameter_list|)
name|struct
name|cardtype
modifier|*
name|cp
decl_stmt|;
block|{
if|if
condition|(
name|found
index|[
name|let
index|]
operator|->
name|rank
operator|==
name|King
condition|)
if|if
condition|(
name|cp
operator|->
name|rank
operator|==
name|Ace
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
elseif|else
if|if
condition|(
name|cp
operator|->
name|rank
operator|-
literal|1
operator|==
name|found
index|[
name|let
index|]
operator|->
name|rank
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_macro
name|samesuit
argument_list|(
argument|cp
argument_list|,
argument|let
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|cardtype
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|cp
operator|->
name|suit
operator|==
name|found
index|[
name|let
index|]
operator|->
name|suit
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_comment
comment|/* procedure to move a card to the correct foundation pile */
end_comment

begin_macro
name|movetofound
argument_list|(
argument|cp
argument_list|,
argument|source
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|cardtype
modifier|*
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tempbase
operator|=
literal|0
expr_stmt|;
name|mtfdone
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|notempty
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
do|do
block|{
if|if
condition|(
name|found
index|[
name|tempbase
index|]
operator|!=
name|NIL
condition|)
if|if
condition|(
name|rankhigher
argument_list|(
operator|*
name|cp
argument_list|,
name|tempbase
argument_list|)
operator|&&
name|samesuit
argument_list|(
operator|*
name|cp
argument_list|,
name|tempbase
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
name|stock
condition|)
name|mtforigin
operator|=
name|stk
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
name|talon
condition|)
name|mtforigin
operator|=
name|tal
expr_stmt|;
else|else
name|mtforigin
operator|=
name|tab
expr_stmt|;
name|transit
argument_list|(
name|cp
argument_list|,
operator|&
name|found
index|[
name|tempbase
index|]
argument_list|)
expr_stmt|;
name|printcard
argument_list|(
name|pilemap
index|[
name|tempbase
index|]
argument_list|,
name|foundrow
argument_list|,
name|found
index|[
name|tempbase
index|]
argument_list|)
expr_stmt|;
name|timesthru
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mtforigin
operator|==
name|stk
condition|)
block|{
name|usedstock
argument_list|()
expr_stmt|;
name|printcard
argument_list|(
name|stockcol
argument_list|,
name|stockrow
argument_list|,
name|stock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mtforigin
operator|==
name|tal
condition|)
block|{
name|usedtalon
argument_list|()
expr_stmt|;
name|printcard
argument_list|(
name|taloncol
argument_list|,
name|talonrow
argument_list|,
name|talon
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|removecard
argument_list|(
name|pilemap
index|[
name|source
index|]
argument_list|,
name|length
index|[
name|source
index|]
argument_list|)
expr_stmt|;
name|length
index|[
name|source
index|]
operator|--
expr_stmt|;
block|}
name|cardsoff
operator|++
expr_stmt|;
name|mtfdone
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|tempbase
operator|++
expr_stmt|;
else|else
name|tempbase
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|tempbase
operator|!=
literal|4
operator|)
operator|&&
operator|!
name|mtfdone
condition|)
do|;
if|if
condition|(
operator|!
name|mtfdone
condition|)
name|destinerror
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* procedure to get a command */
end_comment

begin_macro
name|getcmd
argument_list|(
argument|row
argument_list|,
argument|col
argument_list|,
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|cmd
index|[
literal|2
index|]
decl_stmt|,
name|ch
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|move
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%-24s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
do|do
block|{
name|ch
operator|=
name|getch
argument_list|()
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
condition|)
name|ch
operator|+=
operator|(
literal|'a'
operator|-
literal|'A'
operator|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\f'
condition|)
block|{
name|wrefresh
argument_list|(
name|curscr
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
literal|2
operator|&&
name|ch
operator|!=
name|_tty
operator|.
name|sg_erase
operator|&&
name|ch
operator|!=
name|_tty
operator|.
name|sg_kill
condition|)
block|{
if|if
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
literal|'\r'
operator|&&
name|ch
operator|!=
literal|' '
condition|)
name|write
argument_list|(
literal|1
argument_list|,
literal|"\007"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|_tty
operator|.
name|sg_erase
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|printw
argument_list|(
literal|"\b \b"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|_tty
operator|.
name|sg_kill
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|printw
argument_list|(
literal|"\b \b"
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
name|refresh
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\032'
condition|)
block|{
comment|/* Control-Z */
name|suspend
argument_list|()
expr_stmt|;
name|move
argument_list|(
name|row
argument_list|,
name|col
operator|+
name|i
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|cmd
index|[
name|i
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|addch
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
literal|'\r'
operator|&&
name|ch
operator|!=
literal|' '
condition|)
do|;
name|srcpile
operator|=
name|cmd
index|[
literal|0
index|]
expr_stmt|;
name|destpile
operator|=
name|cmd
index|[
literal|1
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Suspend the game (shell escape if no process control on system) */
end_comment

begin_macro
name|suspend
argument_list|()
end_macro

begin_block
block|{
ifndef|#
directive|ifndef
name|SIGTSTP
name|char
modifier|*
name|sh
decl_stmt|;
endif|#
directive|endif
name|move
argument_list|(
literal|21
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
else|#
directive|else
name|sh
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|==
name|NULL
condition|)
name|sh
operator|=
literal|"/bin/sh"
expr_stmt|;
name|system
argument_list|(
name|sh
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|raw
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* procedure to evaluate and make the specific moves */
end_comment

begin_macro
name|movecard
argument_list|()
end_macro

begin_block
block|{
name|int
name|source
decl_stmt|,
name|dest
decl_stmt|;
name|done
operator|=
name|FALSE
expr_stmt|;
name|errmsg
operator|=
name|FALSE
expr_stmt|;
do|do
block|{
if|if
condition|(
name|cardsoff
operator|==
literal|52
condition|)
block|{
name|refresh
argument_list|()
expr_stmt|;
name|srcpile
operator|=
literal|'q'
expr_stmt|;
block|}
else|else
name|getcmd
argument_list|(
name|moverow
argument_list|,
name|movecol
argument_list|,
literal|"Move:"
argument_list|)
expr_stmt|;
name|clearmsg
argument_list|()
expr_stmt|;
if|if
condition|(
name|srcpile
operator|>=
literal|'1'
operator|&&
name|srcpile
operator|<=
literal|'4'
condition|)
name|source
operator|=
call|(
name|int
call|)
argument_list|(
name|srcpile
operator|-
literal|'1'
argument_list|)
expr_stmt|;
if|if
condition|(
name|destpile
operator|>=
literal|'1'
operator|&&
name|destpile
operator|<=
literal|'4'
condition|)
name|dest
operator|=
call|(
name|int
call|)
argument_list|(
name|destpile
operator|-
literal|'1'
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|srcpile
condition|)
block|{
case|case
literal|'t'
case|:
if|if
condition|(
name|destpile
operator|==
literal|'f'
operator|||
name|destpile
operator|==
literal|'F'
condition|)
name|movetofound
argument_list|(
operator|&
name|talon
argument_list|,
name|source
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|destpile
operator|>=
literal|'1'
operator|&&
name|destpile
operator|<=
literal|'4'
condition|)
name|simpletableau
argument_list|(
operator|&
name|talon
argument_list|,
name|dest
argument_list|)
expr_stmt|;
else|else
name|dumberror
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|destpile
operator|==
literal|'f'
operator|||
name|destpile
operator|==
literal|'F'
condition|)
name|movetofound
argument_list|(
operator|&
name|stock
argument_list|,
name|source
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|destpile
operator|>=
literal|'1'
operator|&&
name|destpile
operator|<=
literal|'4'
condition|)
name|simpletableau
argument_list|(
operator|&
name|stock
argument_list|,
name|dest
argument_list|)
expr_stmt|;
else|else
name|dumberror
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
name|destpile
operator|==
literal|'t'
operator|||
name|destpile
operator|==
literal|'T'
condition|)
name|movetotalon
argument_list|()
expr_stmt|;
else|else
name|dumberror
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|showcards
argument_list|()
expr_stmt|;
name|done
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|Cflag
operator|=
operator|!
name|Cflag
expr_stmt|;
if|if
condition|(
name|Cflag
condition|)
name|showstat
argument_list|()
expr_stmt|;
else|else
name|clearstat
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
if|if
condition|(
name|destpile
operator|==
literal|'f'
operator|||
name|destpile
operator|==
literal|'F'
condition|)
name|movetofound
argument_list|(
operator|&
name|tableau
index|[
name|source
index|]
argument_list|,
name|source
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|destpile
operator|>=
literal|'1'
operator|&&
name|destpile
operator|<=
literal|'4'
condition|)
name|tabtotab
argument_list|(
name|source
argument_list|,
name|dest
argument_list|)
expr_stmt|;
else|else
name|dumberror
argument_list|()
expr_stmt|;
break|break;
default|default:
name|dumberror
argument_list|()
expr_stmt|;
block|}
name|fndbase
argument_list|(
operator|&
name|stock
argument_list|,
name|stockcol
argument_list|,
name|stockrow
argument_list|)
expr_stmt|;
name|fndbase
argument_list|(
operator|&
name|talon
argument_list|,
name|taloncol
argument_list|,
name|talonrow
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
block|}
end_block

begin_comment
comment|/* procedure to printout instructions */
end_comment

begin_macro
name|instruct
argument_list|()
end_macro

begin_block
block|{
name|move
argument_list|(
name|originrow
argument_list|,
name|origincol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"This is the game of solitaire called Canfield.  Do\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"you want instructions for the game?"
argument_list|)
expr_stmt|;
do|do
block|{
name|getcmd
argument_list|(
name|originrow
operator|+
literal|3
argument_list|,
name|origincol
argument_list|,
literal|"y or n?"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|srcpile
operator|!=
literal|'y'
operator|&&
name|srcpile
operator|!=
literal|'n'
condition|)
do|;
if|if
condition|(
name|srcpile
operator|==
literal|'y'
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|printw
argument_list|(
literal|"Here are brief instuctions to the game of Canfield:\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"     If you have never played solitaire before, it is recom-\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"mended  that  you  consult  a solitaire instruction book. In\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Canfield, tableau cards may be built on each other  downward\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"in  alternate colors. An entire pile must be moved as a unit\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"in building. Top cards of the piles are available to be able\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"to be played on foundations, but never into empty spaces.\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"     Spaces must be filled from the stock. The top  card  of\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"the  stock  also is available to be played on foundations or\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"built on tableau piles. After the stock  is  exhausted,  ta-\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"bleau spaces may be filled from the talon and the player may\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"keep them open until he wishes to use them.\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"     Cards are dealt from the hand to the  talon  by  threes\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"and  this  repeats until there are no more cards in the hand\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"or the player quits. To have cards dealt onto the talon  the\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"player  types  'ht'  for his move. Foundation base cards are\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"also automatically moved to the foundation when they  become\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"available.\n\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"push any key when you are finished: "
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|getch
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* procedure to initialize the game */
end_comment

begin_macro
name|initall
argument_list|()
end_macro

begin_block
block|{
name|srand
argument_list|(
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|initdeck
argument_list|(
name|deck
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* procedure to end the game */
end_comment

begin_function
name|bool
name|finish
parameter_list|()
block|{
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
if|if
condition|(
name|cardsoff
operator|==
literal|52
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|move
argument_list|(
name|originrow
argument_list|,
name|origincol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"CONGRATULATIONS!\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"You won the game. That is a feat to be proud of.\n"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|originrow
operator|+
literal|4
argument_list|,
name|origincol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Wish to play again?     "
argument_list|)
expr_stmt|;
name|row
operator|=
name|originrow
operator|+
literal|5
expr_stmt|;
name|col
operator|=
name|origincol
expr_stmt|;
block|}
else|else
block|{
name|move
argument_list|(
name|msgrow
argument_list|,
name|msgcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"You got %d card"
argument_list|,
name|cardsoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|cardsoff
operator|>
literal|1
condition|)
name|printw
argument_list|(
literal|"s"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|" off    "
argument_list|)
expr_stmt|;
name|getcmd
argument_list|(
name|moverow
argument_list|,
name|movecol
argument_list|,
literal|"Hit return to continue"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|msgrow
argument_list|,
name|msgcol
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Wish to play again?     "
argument_list|)
expr_stmt|;
name|row
operator|=
name|moverow
expr_stmt|;
name|col
operator|=
name|movecol
expr_stmt|;
block|}
do|do
block|{
name|getcmd
argument_list|(
name|row
argument_list|,
name|col
argument_list|,
literal|"y or n?"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|srcpile
operator|!=
literal|'y'
operator|&&
name|srcpile
operator|!=
literal|'n'
condition|)
do|;
name|errmsg
operator|=
name|TRUE
expr_stmt|;
name|clearmsg
argument_list|()
expr_stmt|;
if|if
condition|(
name|srcpile
operator|==
literal|'y'
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
else|else
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|MAXLOAD
name|double
name|vec
index|[
literal|3
index|]
decl_stmt|;
name|loadav
argument_list|(
name|vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|vec
index|[
literal|2
index|]
operator|>=
name|MAXLOAD
condition|)
block|{
name|puts
argument_list|(
literal|"The system load is too high.  Try again later."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|initscr
argument_list|()
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|initall
argument_list|()
expr_stmt|;
name|instruct
argument_list|()
expr_stmt|;
name|makeboard
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|startgame
argument_list|()
expr_stmt|;
name|movecard
argument_list|()
expr_stmt|;
if|if
condition|(
name|finish
argument_list|()
condition|)
break|break;
if|if
condition|(
name|cardsoff
operator|==
literal|52
condition|)
name|makeboard
argument_list|()
expr_stmt|;
else|else
name|cleanupboard
argument_list|()
expr_stmt|;
block|}
name|clear
argument_list|()
expr_stmt|;
name|move
argument_list|(
literal|22
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

