begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Chris Torek and Darren F. Provine.  *  * %sccs.include.redist.c%  *  *	@(#)input.c	5.2 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Tetris input.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"tetris.h"
end_include

begin_comment
comment|/* return true iff the given timeval is positive */
end_comment

begin_define
define|#
directive|define
name|TV_POS
parameter_list|(
name|tv
parameter_list|)
define|\
value|((tv)->tv_sec> 0 || ((tv)->tv_sec == 0&& (tv)->tv_usec> 0))
end_define

begin_comment
comment|/* subtract timeval `sub' from `res' */
end_comment

begin_define
define|#
directive|define
name|TV_SUB
parameter_list|(
name|res
parameter_list|,
name|sub
parameter_list|)
define|\
value|(res)->tv_sec -= (sub)->tv_sec; \ 	(res)->tv_usec -= (sub)->tv_usec; \ 	if ((res)->tv_usec< 0) { \ 		(res)->tv_usec += 1000000; \ 		(res)->tv_sec--; \ 	}
end_define

begin_comment
comment|/*  * Do a `read wait': select for reading from stdin, with timeout *tvp.  * On return, modify *tvp to reflect the amount of time spent waiting.  * It will be positive only if input appeared before the time ran out;  * otherwise it will be zero or perhaps negative.  *  * If tvp is nil, wait forever, but return if select is interrupted.  *  * Return 0 => no input, 1 => can read() from stdin  */
end_comment

begin_function
name|int
name|rwait
parameter_list|(
name|tvp
parameter_list|)
specifier|register
name|struct
name|timeval
modifier|*
name|tvp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|timeval
name|starttv
decl_stmt|,
name|endtv
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
define|#
directive|define
name|NILTZ
value|((struct timezone *)0)
comment|/* 	 * Someday, select() will do this for us. 	 * Just in case that day is now, and no one has 	 * changed this, we use a temporary. 	 */
if|if
condition|(
name|tvp
condition|)
block|{
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|starttv
argument_list|,
name|NILTZ
argument_list|)
expr_stmt|;
name|endtv
operator|=
operator|*
name|tvp
expr_stmt|;
name|s
operator|=
operator|&
name|endtv
expr_stmt|;
block|}
else|else
name|s
operator|=
literal|0
expr_stmt|;
name|again
label|:
name|i
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|select
argument_list|(
literal|1
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
operator|&
name|i
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
name|s
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|tvp
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
goto|goto
name|again
goto|;
name|stop
argument_list|(
literal|"select failed, help"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|0
case|:
comment|/* timed out */
name|tvp
operator|->
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tvp
operator|->
name|tv_usec
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|tvp
condition|)
block|{
comment|/* since there is input, we may not have timed out */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|endtv
argument_list|,
name|NILTZ
argument_list|)
expr_stmt|;
name|TV_SUB
argument_list|(
operator|&
name|endtv
argument_list|,
operator|&
name|starttv
argument_list|)
expr_stmt|;
name|TV_SUB
argument_list|(
name|tvp
argument_list|,
operator|&
name|endtv
argument_list|)
expr_stmt|;
comment|/* adjust *tvp by elapsed time */
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * `sleep' for the current turn time (using select).  * Eat any input that might be available.  */
end_comment

begin_function
name|void
name|tsleep
parameter_list|()
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|char
name|c
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|fallrate
expr_stmt|;
while|while
condition|(
name|TV_POS
argument_list|(
operator|&
name|tv
argument_list|)
condition|)
if|if
condition|(
name|rwait
argument_list|(
operator|&
name|tv
argument_list|)
operator|&&
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
break|break;
block|}
end_function

begin_comment
comment|/*  * Eat up any input (used at end of game).  */
end_comment

begin_function
name|void
name|eat_input
parameter_list|()
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|char
name|c
decl_stmt|;
do|do
block|{
name|tv
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|rwait
argument_list|(
operator|&
name|tv
argument_list|)
operator|&&
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * getchar with timeout.  */
end_comment

begin_function
name|int
name|tgetchar
parameter_list|()
block|{
specifier|static
name|struct
name|timeval
name|timeleft
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* 	 * Reset timeleft to fallrate whenever it is not positive. 	 * In any case, wait to see if there is any input.  If so, 	 * take it, and update timeleft so that the next call to 	 * tgetchar() will not wait as long.  If there is no input, 	 * make timeleft zero or negative, and return -1. 	 * 	 * Most of the hard work is done by rwait(). 	 */
if|if
condition|(
operator|!
name|TV_POS
argument_list|(
operator|&
name|timeleft
argument_list|)
condition|)
block|{
name|faster
argument_list|()
expr_stmt|;
comment|/* go faster */
name|timeleft
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeleft
operator|.
name|tv_usec
operator|=
name|fallrate
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rwait
argument_list|(
operator|&
name|timeleft
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
name|stop
argument_list|(
literal|"end of file, help"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|c
operator|)
return|;
block|}
end_function

end_unit

