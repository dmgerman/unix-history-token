begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Chris Torek and Darren F. Provine.  *  * %sccs.include.redist.c%  *  *	@(#)screen.c	5.2 (Berkeley) %G%  */
end_comment

begin_comment
comment|/*  * Tetris screen control.  */
end_comment

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|sigmask
end_ifndef

begin_define
define|#
directive|define
name|sigmask
parameter_list|(
name|s
parameter_list|)
value|(1<< ((s) - 1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"screen.h"
end_include

begin_include
include|#
directive|include
file|"tetris.h"
end_include

begin_comment
comment|/*  * XXX - need a<termcap.h>  */
end_comment

begin_decl_stmt
name|int
name|tgetent
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tgetflag
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tgetnum
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tputs
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cell
name|curscreen
index|[
name|B_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => standout (or otherwise marked) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|curscore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true => terminal is in game mode */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|oldtt
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|tstp
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|tgetstr
argument_list|()
decl_stmt|,
modifier|*
name|tgoto
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Capabilities from TERMCAP.  */
end_comment

begin_decl_stmt
name|char
name|PC
decl_stmt|,
modifier|*
name|BC
decl_stmt|,
modifier|*
name|UP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tgoto requires globals: ugh! */
end_comment

begin_decl_stmt
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bcstr
decl_stmt|,
comment|/* backspace char */
modifier|*
name|CEstr
decl_stmt|,
comment|/* clear to end of line */
modifier|*
name|CLstr
decl_stmt|,
comment|/* clear screen */
modifier|*
name|CMstr
decl_stmt|,
comment|/* cursor motion string */
ifdef|#
directive|ifdef
name|unneeded
modifier|*
name|CRstr
decl_stmt|,
comment|/* "\r" equivalent */
endif|#
directive|endif
modifier|*
name|HOstr
decl_stmt|,
comment|/* cursor home */
modifier|*
name|LLstr
decl_stmt|,
comment|/* last line, first column */
modifier|*
name|pcstr
decl_stmt|,
comment|/* pad character */
modifier|*
name|TEstr
decl_stmt|,
comment|/* end cursor motion mode */
modifier|*
name|TIstr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* begin cursor motion mode */
end_comment

begin_decl_stmt
name|char
modifier|*
name|SEstr
decl_stmt|,
comment|/* end standout mode */
modifier|*
name|SOstr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* begin standout mode */
end_comment

begin_decl_stmt
specifier|static
name|int
name|COnum
decl_stmt|,
comment|/* co# value */
name|LInum
decl_stmt|,
comment|/* li# value */
name|MSflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* can move in standout mode */
end_comment

begin_struct
struct|struct
name|tcsinfo
block|{
comment|/* termcap string info; some abbrevs above */
name|char
name|tcname
index|[
literal|3
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|tcaddr
decl_stmt|;
block|}
name|tcstrings
index|[]
init|=
block|{
literal|"bc"
block|,
operator|&
name|bcstr
block|,
literal|"ce"
block|,
operator|&
name|CEstr
block|,
literal|"cl"
block|,
operator|&
name|CLstr
block|,
literal|"cm"
block|,
operator|&
name|CMstr
block|,
ifdef|#
directive|ifdef
name|unneeded
literal|"cr"
block|,
operator|&
name|CRstr
block|,
endif|#
directive|endif
literal|"le"
block|,
operator|&
name|BC
block|,
comment|/* move cursor left one space */
literal|"pc"
block|,
operator|&
name|pcstr
block|,
literal|"se"
block|,
operator|&
name|SEstr
block|,
literal|"so"
block|,
operator|&
name|SOstr
block|,
literal|"te"
block|,
operator|&
name|TEstr
block|,
literal|"ti"
block|,
operator|&
name|TIstr
block|,
literal|"up"
block|,
operator|&
name|UP
block|,
comment|/* cursor up */
literal|0
block|}
struct|;
end_struct

begin_comment
comment|/* This is where we will actually stuff the information */
end_comment

begin_decl_stmt
specifier|static
name|char
name|combuf
index|[
literal|1024
index|]
decl_stmt|,
name|tbuf
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Routine used by tputs().  */
end_comment

begin_function
name|int
name|put
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
return|return
operator|(
name|putchar
argument_list|(
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * putstr() is for unpadded strings (either as in termcap(5) or  * simply literal strings); putpad() is for padded strings with  * count=1.  (See screen.h for putpad().)  */
end_comment

begin_define
define|#
directive|define
name|putstr
parameter_list|(
name|s
parameter_list|)
value|(void)fputs(s, stdout)
end_define

begin_define
define|#
directive|define
name|moveto
parameter_list|(
name|r
parameter_list|,
name|c
parameter_list|)
value|putpad(tgoto(CMstr, c, r))
end_define

begin_comment
comment|/*  * Set up from termcap.  */
end_comment

begin_function
name|void
name|scr_init
parameter_list|()
block|{
specifier|static
name|int
name|bsflag
decl_stmt|,
name|xsflag
decl_stmt|,
name|sgnum
decl_stmt|;
ifdef|#
directive|ifdef
name|unneeded
specifier|static
name|int
name|ncflag
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|term
decl_stmt|,
modifier|*
name|fill
decl_stmt|;
specifier|static
struct|struct
name|tcninfo
block|{
comment|/* termcap numeric and flag info */
name|char
name|tcname
index|[
literal|3
index|]
decl_stmt|;
name|int
modifier|*
name|tcaddr
decl_stmt|;
block|}
name|tcflags
index|[]
init|=
block|{
literal|"bs"
block|,
operator|&
name|bsflag
block|,
literal|"ms"
block|,
operator|&
name|MSflag
block|,
ifdef|#
directive|ifdef
name|unneeded
literal|"nc"
block|,
operator|&
name|ncflag
block|,
endif|#
directive|endif
literal|"xs"
block|,
operator|&
name|xsflag
block|,
literal|0
block|}
struct|,
name|tcnums
index|[]
init|=
block|{
literal|"co"
block|,
operator|&
name|COnum
block|,
literal|"li"
block|,
operator|&
name|LInum
block|,
literal|"sg"
block|,
operator|&
name|sgnum
block|,
literal|0
block|}
struct|;
if|if
condition|(
operator|(
name|term
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|stop
argument_list|(
literal|"you must set the TERM environment variable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgetent
argument_list|(
name|tbuf
argument_list|,
name|term
argument_list|)
operator|<=
literal|0
condition|)
name|stop
argument_list|(
literal|"cannot find your termcap"
argument_list|)
expr_stmt|;
name|fill
operator|=
name|combuf
expr_stmt|;
block|{
specifier|register
name|struct
name|tcsinfo
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|tcstrings
init|;
name|p
operator|->
name|tcaddr
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|->
name|tcaddr
operator|=
name|tgetstr
argument_list|(
name|p
operator|->
name|tcname
argument_list|,
operator|&
name|fill
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|struct
name|tcninfo
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|tcflags
init|;
name|p
operator|->
name|tcaddr
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|->
name|tcaddr
operator|=
name|tgetflag
argument_list|(
name|p
operator|->
name|tcname
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|tcnums
init|;
name|p
operator|->
name|tcaddr
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|->
name|tcaddr
operator|=
name|tgetnum
argument_list|(
name|p
operator|->
name|tcname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bsflag
condition|)
name|BC
operator|=
literal|"\b"
expr_stmt|;
elseif|else
if|if
condition|(
name|BC
operator|==
name|NULL
operator|&&
name|bcstr
operator|!=
name|NULL
condition|)
name|BC
operator|=
name|bcstr
expr_stmt|;
if|if
condition|(
name|CLstr
operator|==
name|NULL
condition|)
name|stop
argument_list|(
literal|"cannot clear screen"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CMstr
operator|==
name|NULL
operator|||
name|UP
operator|==
name|NULL
operator|||
name|BC
operator|==
name|NULL
condition|)
name|stop
argument_list|(
literal|"cannot do random cursor positioning via tgoto()"
argument_list|)
expr_stmt|;
name|PC
operator|=
name|pcstr
condition|?
operator|*
name|pcstr
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|sgnum
operator|>=
literal|0
operator|||
name|xsflag
condition|)
name|SOstr
operator|=
name|SEstr
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|unneeded
if|if
condition|(
name|ncflag
condition|)
name|CRstr
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|CRstr
operator|==
name|NULL
condition|)
name|CRstr
operator|=
literal|"\r"
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* this foolery is needed to modify tty state `atomically' */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|scr_onstop
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|sigunblock
parameter_list|(
name|mask
parameter_list|)
value|sigsetmask(sigblock(0)& ~(mask))
end_define

begin_function
specifier|static
name|void
name|stopset
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|sig
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigunblock
argument_list|(
name|sigmask
argument_list|(
name|sig
argument_list|)
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|scr_onstop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scr_stop
parameter_list|()
block|{
name|scr_end
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigunblock
argument_list|(
name|sigmask
argument_list|(
name|SIGTSTP
argument_list|)
argument_list|)
expr_stmt|;
name|scr_set
argument_list|()
expr_stmt|;
name|scr_msg
argument_list|(
name|key_msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up screen mode.  */
end_comment

begin_function
name|void
name|scr_set
parameter_list|()
block|{
name|struct
name|winsize
name|ws
decl_stmt|;
name|struct
name|sgttyb
name|newtt
decl_stmt|;
specifier|volatile
name|int
name|omask
decl_stmt|;
name|void
function_decl|(
modifier|*
name|ttou
function_decl|)
parameter_list|()
function_decl|;
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGTSTP
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGTTOU
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tstp
operator|=
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|stopset
argument_list|)
operator|)
operator|==
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ttou
operator|=
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|stopset
argument_list|)
operator|)
operator|==
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* 	 * At last, we are ready to modify the tty state.  If 	 * we stop while at it, stopset() above will longjmp back 	 * to the setjmp here and we will start over. 	 */
operator|(
name|void
operator|)
name|setjmp
argument_list|(
name|scr_onstop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
name|Rows
operator|=
literal|0
operator|,
name|Cols
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Rows
operator|=
name|ws
operator|.
name|ws_row
expr_stmt|;
name|Cols
operator|=
name|ws
operator|.
name|ws_col
expr_stmt|;
block|}
if|if
condition|(
name|Rows
operator|==
literal|0
condition|)
name|Rows
operator|=
name|LInum
expr_stmt|;
if|if
condition|(
name|Cols
operator|==
literal|0
condition|)
name|Cols
operator|=
name|COnum
expr_stmt|;
if|if
condition|(
name|Rows
operator|<
name|MINROWS
operator|||
name|Cols
operator|<
name|MINCOLS
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"the screen is too small: must be at least %d x %d"
argument_list|,
name|MINROWS
argument_list|,
name|MINCOLS
argument_list|)
expr_stmt|;
name|stop
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* stop() supplies \n */
block|}
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|oldtt
argument_list|)
condition|)
name|stop
argument_list|(
literal|"ioctl(TIOCGETP) fails"
argument_list|)
expr_stmt|;
name|newtt
operator|=
name|oldtt
expr_stmt|;
name|newtt
operator|.
name|sg_flags
operator|=
operator|(
name|newtt
operator|.
name|sg_flags
operator||
name|CBREAK
operator|)
operator|&
operator|~
operator|(
name|CRMOD
operator||
name|ECHO
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|newtt
operator|.
name|sg_flags
operator|&
name|TBDELAY
operator|)
operator|==
name|XTABS
condition|)
name|newtt
operator|.
name|sg_flags
operator|&=
operator|~
name|TBDELAY
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|newtt
argument_list|)
condition|)
name|stop
argument_list|(
literal|"ioctl(TIOCSETN) fails"
argument_list|)
expr_stmt|;
name|ospeed
operator|=
name|newtt
operator|.
name|sg_ospeed
expr_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGTSTP
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGTTOU
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We made it.  We are now in screen mode, modulo TIstr 	 * (which we will fix immediately). 	 */
if|if
condition|(
name|TIstr
condition|)
name|putstr
argument_list|(
name|TIstr
argument_list|)
expr_stmt|;
comment|/* termcap(5) says this is not padded */
if|if
condition|(
name|tstp
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|scr_stop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|ttou
argument_list|)
expr_stmt|;
name|isset
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
name|scr_clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * End screen mode.  */
end_comment

begin_function
name|void
name|scr_end
parameter_list|()
block|{
name|int
name|omask
init|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGTSTP
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGTTOU
argument_list|)
argument_list|)
decl_stmt|;
comment|/* move cursor to last line */
if|if
condition|(
name|LLstr
condition|)
name|putstr
argument_list|(
name|LLstr
argument_list|)
expr_stmt|;
comment|/* termcap(5) says this is not padded */
else|else
name|moveto
argument_list|(
name|Rows
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* exit screen mode */
if|if
condition|(
name|TEstr
condition|)
name|putstr
argument_list|(
name|TEstr
argument_list|)
expr_stmt|;
comment|/* termcap(5) says this is not padded */
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|oldtt
argument_list|)
expr_stmt|;
name|isset
operator|=
literal|0
expr_stmt|;
comment|/* restore signals */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|tstp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|stop
parameter_list|(
name|why
parameter_list|)
name|char
modifier|*
name|why
decl_stmt|;
block|{
if|if
condition|(
name|isset
condition|)
name|scr_end
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"aborting: %s\n"
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear the screen, forgetting the current contents in the process.  */
end_comment

begin_function
name|void
name|scr_clear
parameter_list|()
block|{
name|putpad
argument_list|(
name|CLstr
argument_list|)
expr_stmt|;
name|curscore
operator|=
operator|-
literal|1
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|curscreen
argument_list|,
sizeof|sizeof
argument_list|(
name|curscreen
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|vax
operator|&&
operator|!
name|__GNUC__
end_if

begin_typedef
typedef|typedef
name|int
name|regcell
typedef|;
end_typedef

begin_comment
comment|/* pcc is bad at `register char', etc */
end_comment

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|cell
name|regcell
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Update the screen.  */
end_comment

begin_function
name|void
name|scr_update
parameter_list|()
block|{
specifier|register
name|cell
modifier|*
name|bp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
specifier|register
name|regcell
name|so
decl_stmt|,
name|cur_so
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|ccol
decl_stmt|,
name|j
decl_stmt|;
name|int
name|omask
init|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGTSTP
argument_list|)
argument_list|)
decl_stmt|;
comment|/* always leave cursor after last displayed point */
name|curscreen
index|[
name|D_LAST
operator|*
name|B_COLS
operator|-
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|score
operator|!=
name|curscore
condition|)
block|{
if|if
condition|(
name|HOstr
condition|)
name|putpad
argument_list|(
name|HOstr
argument_list|)
expr_stmt|;
else|else
name|moveto
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|score
argument_list|)
expr_stmt|;
name|curscore
operator|=
name|score
expr_stmt|;
block|}
name|bp
operator|=
operator|&
name|board
index|[
name|D_FIRST
operator|*
name|B_COLS
index|]
expr_stmt|;
name|sp
operator|=
operator|&
name|curscreen
index|[
name|D_FIRST
operator|*
name|B_COLS
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|D_FIRST
init|;
name|j
operator|<
name|D_LAST
condition|;
name|j
operator|++
control|)
block|{
name|ccol
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|B_COLS
condition|;
name|bp
operator|++
operator|,
name|sp
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
operator|(
name|so
operator|=
operator|*
name|bp
operator|)
condition|)
continue|continue;
operator|*
name|sp
operator|=
name|so
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|ccol
condition|)
block|{
if|if
condition|(
name|cur_so
operator|&&
name|MSflag
condition|)
block|{
name|putpad
argument_list|(
name|SEstr
argument_list|)
expr_stmt|;
name|cur_so
operator|=
literal|0
expr_stmt|;
block|}
name|moveto
argument_list|(
name|RTOD
argument_list|(
name|j
argument_list|)
argument_list|,
name|CTOD
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SOstr
condition|)
block|{
if|if
condition|(
name|so
operator|!=
name|cur_so
condition|)
block|{
name|putpad
argument_list|(
name|so
condition|?
name|SOstr
else|:
name|SEstr
argument_list|)
expr_stmt|;
name|cur_so
operator|=
name|so
expr_stmt|;
block|}
name|putstr
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
else|else
name|putstr
argument_list|(
name|so
condition|?
literal|"XX"
else|:
literal|"  "
argument_list|)
expr_stmt|;
name|ccol
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* 			 * Look ahead a bit, to avoid extra motion if 			 * we will be redrawing the cell after the next. 			 * Motion probably takes four or more characters, 			 * so we save even if we rewrite two cells 			 * `unnecessarily'.  Skip it all, though, if 			 * the next cell is a different color. 			 */
define|#
directive|define
name|STOP
value|(B_COLS - 3)
if|if
condition|(
name|i
operator|>
name|STOP
operator|||
name|sp
index|[
literal|1
index|]
operator|!=
name|bp
index|[
literal|1
index|]
operator|||
name|so
operator|!=
name|bp
index|[
literal|1
index|]
condition|)
continue|continue;
if|if
condition|(
name|sp
index|[
literal|2
index|]
operator|!=
name|bp
index|[
literal|2
index|]
condition|)
name|sp
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
name|STOP
operator|&&
name|so
operator|==
name|bp
index|[
literal|2
index|]
operator|&&
name|sp
index|[
literal|3
index|]
operator|!=
name|bp
index|[
literal|3
index|]
condition|)
block|{
name|sp
index|[
literal|2
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|sp
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cur_so
condition|)
name|putpad
argument_list|(
name|SEstr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a message (set!=0), or clear the same message (set==0).  * (We need its length in case we have to overwrite with blanks.)  */
end_comment

begin_function
name|void
name|scr_msg
parameter_list|(
name|s
parameter_list|,
name|set
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|set
decl_stmt|;
block|{
if|if
condition|(
name|set
operator|||
name|CEstr
operator|==
name|NULL
condition|)
block|{
specifier|register
name|int
name|l
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|moveto
argument_list|(
name|Rows
operator|-
literal|2
argument_list|,
operator|(
operator|(
name|Cols
operator|-
name|l
operator|)
operator|>>
literal|1
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
name|putstr
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|--
name|l
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|moveto
argument_list|(
name|Rows
operator|-
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|CEstr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

