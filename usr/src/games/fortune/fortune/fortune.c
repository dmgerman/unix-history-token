begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: fortune.c,v 1.40 88/08/18 11:41:50 arnold Exp $ */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"strfile.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_define
define|#
directive|define
name|NO_LOCK
end_define

begin_define
define|#
directive|define
name|REGCMP
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|NO_REGEX
end_ifdef

begin_undef
undef|#
directive|undef
name|NO_REGEX
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_REGEX */
end_comment

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_define
define|#
directive|define
name|rindex
value|strrchr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSV */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_REGEX
end_ifndef

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_REGEX */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_LOCK
end_ifndef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_LOCK */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|F_OK
end_ifndef

begin_comment
comment|/* codes for access() */
end_comment

begin_define
define|#
directive|define
name|F_OK
value|0
end_define

begin_comment
comment|/* does file exist */
end_comment

begin_define
define|#
directive|define
name|X_OK
value|1
end_define

begin_comment
comment|/* is it executable by caller */
end_comment

begin_define
define|#
directive|define
name|W_OK
value|2
end_define

begin_comment
comment|/* writable by caller */
end_comment

begin_define
define|#
directive|define
name|R_OK
value|4
end_define

begin_comment
comment|/* readable by caller */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* F_OK */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|bool
value|short
end_define

begin_define
define|#
directive|define
name|MINW
value|6
end_define

begin_comment
comment|/* minimum wait if desired */
end_comment

begin_define
define|#
directive|define
name|CPERS
value|20
end_define

begin_comment
comment|/* # of chars for each sec */
end_comment

begin_define
define|#
directive|define
name|SLEN
value|160
end_define

begin_comment
comment|/* # of chars in short fortune */
end_comment

begin_define
define|#
directive|define
name|POS_UNKNOWN
value|((unsigned long) -1)
end_define

begin_comment
comment|/* pos for file unknown */
end_comment

begin_define
define|#
directive|define
name|NO_PROB
value|(-1)
end_define

begin_comment
comment|/* no prob specified for file */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FORTDIR
end_ifndef

begin_define
define|#
directive|define
name|FORTDIR
value|"/usr/games/lib/fortune"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FORTDIR */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|l
parameter_list|,
name|x
parameter_list|)
value|if (Debug>= l) fprintf x; else
end_define

begin_undef
undef|#
directive|undef
name|NDEBUG
end_undef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DEBUG */
end_comment

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|l
parameter_list|,
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|NDEBUG
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|fd
block|{
name|int
name|percent
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|datfd
decl_stmt|;
name|unsigned
name|long
name|pos
decl_stmt|;
name|FILE
modifier|*
name|inf
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|datfile
decl_stmt|,
modifier|*
name|posfile
decl_stmt|;
name|bool
name|read_tbl
decl_stmt|;
name|bool
name|was_pos_file
decl_stmt|;
name|STRFILE
name|tbl
decl_stmt|;
name|int
name|num_children
decl_stmt|;
name|struct
name|fd
modifier|*
name|child
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
name|struct
name|fd
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
block|}
name|FILEDESC
typedef|;
end_typedef

begin_decl_stmt
name|bool
name|Found_one
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* did we find a match? */
end_comment

begin_decl_stmt
name|bool
name|Find_files
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* just find a list of proper fortune files */
end_comment

begin_decl_stmt
name|bool
name|Wait
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* wait desired after fortune */
end_comment

begin_decl_stmt
name|bool
name|Short_only
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* short fortune desired */
end_comment

begin_decl_stmt
name|bool
name|Long_only
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* long fortune desired */
end_comment

begin_decl_stmt
name|bool
name|Offend
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* offensive fortunes only */
end_comment

begin_decl_stmt
name|bool
name|All_forts
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* any fortune allowed */
end_comment

begin_decl_stmt
name|bool
name|Equal_probs
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scatter un-allocted prob equally */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_REGEX
end_ifndef

begin_decl_stmt
name|bool
name|Match
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dump fortunes matching a pattern */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|bool
name|Debug
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print debug messages */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|Fortbuf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fortune buffer for -m */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Usage
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|NO_REGEX
literal|"usage:  fortune [ - ] [ -fwsloa ] [ [N%] file/dir/\"all\" ]"
block|,
else|#
directive|else
comment|/* NO_REGEX */
literal|"usage:  fortune [ - ] [ -fwsloai ] [ -m pattern ] [ [N%] file/dir/\"all\" ]"
block|,
endif|#
directive|endif
comment|/* NO_REGEX */
literal|"	- - give this summary of usage"
block|,
literal|"	f - list fortune files"
block|,
literal|"	w - wait after printing message in order to give time to read"
block|,
literal|"	s - short fortunes only"
block|,
literal|"	l - long fortunes only"
block|,
literal|"	o - offensive fortunes only"
block|,
literal|"	a - any fortune, regular or offensive"
block|,
ifndef|#
directive|ifndef
name|NO_REGEX
literal|"	m - print fortunes which match a pattern"
block|,
literal|"	i - ignore case in matching patterns"
block|,
endif|#
directive|endif
comment|/* NO_REGEX */
literal|"		Mail suggested fortunes to \"fortune@berkeley.edu\""
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Fort_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|off_t
name|Seekpts
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* seek pointers to fortunes */
end_comment

begin_decl_stmt
name|FILEDESC
modifier|*
name|File_list
init|=
name|NULL
decl_stmt|,
comment|/* Head of file list */
modifier|*
name|File_tail
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tail of file list */
end_comment

begin_decl_stmt
name|FILEDESC
modifier|*
name|Fortfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fortune file to use */
end_comment

begin_decl_stmt
name|STRFILE
name|Noprob_tbl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sum of data for all no prob files */
end_comment

begin_decl_stmt
name|char
modifier|*
name|do_malloc
argument_list|()
decl_stmt|,
modifier|*
name|copy
argument_list|()
decl_stmt|,
modifier|*
name|off_name
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILEDESC
modifier|*
name|pick_child
argument_list|()
decl_stmt|,
modifier|*
name|new_fp
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|strcat
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|time_t
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|NO_REGEX
end_ifndef

begin_function_decl
name|char
modifier|*
name|conv_pat
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_REGEX
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|REGCMP
end_ifdef

begin_define
define|#
directive|define
name|RE_COMP
parameter_list|(
name|p
parameter_list|)
value|(Re_pat = regcmp(p, NULL))
end_define

begin_define
define|#
directive|define
name|BAD_COMP
parameter_list|(
name|f
parameter_list|)
value|((f) == NULL)
end_define

begin_define
define|#
directive|define
name|RE_EXEC
parameter_list|(
name|p
parameter_list|)
value|regex(Re_pat, (p))
end_define

begin_decl_stmt
name|char
modifier|*
name|Re_pat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|regcmp
argument_list|()
decl_stmt|,
modifier|*
name|regex
argument_list|()
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RE_COMP
parameter_list|(
name|p
parameter_list|)
value|(p = re_comp(p))
end_define

begin_define
define|#
directive|define
name|BAD_COMP
parameter_list|(
name|f
parameter_list|)
value|((f) != NULL)
end_define

begin_define
define|#
directive|define
name|RE_EXEC
parameter_list|(
name|p
parameter_list|)
value|re_exec(p)
end_define

begin_function_decl
name|char
modifier|*
name|re_comp
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_function_decl
name|char
modifier|*
name|re_exec
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|int
name|re_exec
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|getargs
argument_list|(
name|ac
argument_list|,
name|av
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_REGEX
if|if
condition|(
name|Match
condition|)
name|exit
argument_list|(
name|find_matches
argument_list|()
operator|!=
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_prob
argument_list|()
expr_stmt|;
name|srandom
argument_list|(
call|(
name|int
call|)
argument_list|(
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
operator|+
name|getpid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|get_fort
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|Short_only
operator|&&
name|fortlen
argument_list|()
operator|>
name|SLEN
operator|)
operator|||
operator|(
name|Long_only
operator|&&
name|fortlen
argument_list|()
operator|<=
name|SLEN
operator|)
condition|)
do|;
name|open_fp
argument_list|(
name|Fortfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|Fortfile
operator|->
name|inf
argument_list|,
name|Seekpts
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|Fort_len
operator|=
literal|0
init|;
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|,
name|Fortfile
operator|->
name|inf
argument_list|)
operator|!=
name|NULL
operator|&&
operator|!
name|STR_ENDSTRING
argument_list|(
name|line
argument_list|,
name|Fortfile
operator|->
name|tbl
argument_list|)
condition|;
name|Fort_len
operator|++
control|)
name|fputs
argument_list|(
name|line
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|Fortfile
operator|->
name|posfile
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|Fortfile
operator|->
name|posfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LOCK_EX
comment|/* 	 * if we can, we exclusive lock, but since it isn't very 	 * important, we just punt if we don't have easy locking 	 * available. 	 */
operator|(
name|void
operator|)
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_EX
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOCK_EX */
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|Fortfile
operator|->
name|pos
argument_list|,
sizeof|sizeof
name|Fortfile
operator|->
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Fortfile
operator|->
name|was_pos_file
condition|)
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|Fortfile
operator|->
name|path
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCK_EX
operator|(
name|void
operator|)
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_UN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOCK_EX */
if|if
condition|(
name|Wait
condition|)
block|{
if|if
condition|(
name|Fort_len
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fortlen
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|max
argument_list|(
name|Fort_len
operator|/
name|CPERS
argument_list|,
name|MINW
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * fortlen:  *	Return the length of the fortune.  */
end_comment

begin_macro
name|fortlen
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|nchar
decl_stmt|;
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|Fortfile
operator|->
name|tbl
operator|.
name|str_flags
operator|&
operator|(
name|STR_RANDOM
operator||
name|STR_ORDERED
operator|)
operator|)
condition|)
name|nchar
operator|=
operator|(
name|Seekpts
index|[
literal|1
index|]
operator|-
name|Seekpts
index|[
literal|0
index|]
operator|<=
name|SLEN
operator|)
expr_stmt|;
else|else
block|{
name|open_fp
argument_list|(
name|Fortfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|Fortfile
operator|->
name|inf
argument_list|,
name|Seekpts
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nchar
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|,
name|Fortfile
operator|->
name|inf
argument_list|)
operator|!=
name|NULL
operator|&&
operator|!
name|STR_ENDSTRING
argument_list|(
name|line
argument_list|,
name|Fortfile
operator|->
name|tbl
argument_list|)
condition|)
name|nchar
operator|+=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|Fort_len
operator|=
name|nchar
expr_stmt|;
return|return
name|nchar
return|;
block|}
end_block

begin_comment
comment|/*  *	This routine evaluates the arguments on the command line  */
end_comment

begin_expr_stmt
name|getargs
argument_list|(
name|ac
argument_list|,
name|av
argument_list|)
specifier|register
name|int
name|ac
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|av
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|short
name|bad
decl_stmt|;
specifier|register
name|int
name|ignore_case
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_REGEX
specifier|register
name|char
modifier|*
name|pat
decl_stmt|;
endif|#
directive|endif
comment|/* NO_REGEX */
name|ignore_case
operator|=
name|FALSE
expr_stmt|;
name|bad
operator|=
name|FALSE
expr_stmt|;
name|pat
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|av
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
break|break;
elseif|else
if|if
condition|(
name|av
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|Usage
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
name|puts
argument_list|(
name|Usage
index|[
name|j
operator|++
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
else|else
for|for
control|(
name|sp
operator|=
operator|&
name|av
index|[
name|i
index|]
index|[
literal|1
index|]
init|;
operator|*
name|sp
operator|!=
literal|'\0'
condition|;
name|sp
operator|++
control|)
switch|switch
condition|(
operator|*
name|sp
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* find fortune files */
name|Find_files
operator|++
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* give time to read */
name|Wait
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* short ones only */
name|Short_only
operator|++
expr_stmt|;
name|Long_only
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* long ones only */
name|Long_only
operator|++
expr_stmt|;
name|Short_only
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* offensive ones only */
name|Offend
operator|++
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* any fortune */
name|All_forts
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* dump out the fortunes */
ifdef|#
directive|ifdef
name|NO_REGEX
case|case
literal|'i'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't match fortunes on this system (Sorry)\n"
argument_list|)
expr_stmt|;
name|bad
operator|++
expr_stmt|;
else|#
directive|else
comment|/* NO_REGEX */
name|Match
operator|++
expr_stmt|;
if|if
condition|(
name|sp
index|[
literal|1
index|]
condition|)
block|{
name|pat
operator|=
operator|++
name|sp
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
name|sp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|ac
condition|)
name|pat
operator|=
name|av
index|[
operator|++
name|i
index|]
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"must give pattern\n"
argument_list|)
expr_stmt|;
name|bad
operator|++
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'i'
case|:
name|ignore_case
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|Equal_probs
operator|++
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'D'
case|:
name|Debug
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* DEBUG */
endif|#
directive|endif
comment|/* NO_REGEX */
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown flag: '%c'\n"
argument_list|,
operator|*
name|sp
argument_list|)
expr_stmt|;
name|bad
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|bad
operator|&&
operator|!
name|form_file_list
argument_list|(
operator|&
name|av
index|[
name|i
index|]
argument_list|,
name|ac
operator|-
name|i
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* errors printed through form_file_list() */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>=
literal|1
condition|)
name|print_file_list
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|Find_files
condition|)
block|{
name|print_file_list
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_REGEX
if|if
condition|(
name|pat
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ignore_case
condition|)
name|pat
operator|=
name|conv_pat
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|BAD_COMP
argument_list|(
name|RE_COMP
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|REGCMP
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|pat
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* REGCMP */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad pattern: %s\n"
argument_list|,
name|pat
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* REGCMP */
name|bad
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* NO_REGEX */
if|if
condition|(
name|bad
condition|)
block|{
name|printf
argument_list|(
literal|"use \"%s -\" to get usage\n"
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * form_file_list:  *	Form the file list from the file specifications.  */
end_comment

begin_expr_stmt
name|form_file_list
argument_list|(
name|files
argument_list|,
name|file_cnt
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|files
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|file_cnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|percent
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|file_cnt
operator|==
literal|0
condition|)
if|if
condition|(
name|Find_files
condition|)
return|return
name|add_file
argument_list|(
name|NO_PROB
argument_list|,
name|FORTDIR
argument_list|,
name|NULL
argument_list|,
operator|&
name|File_list
argument_list|,
operator|&
name|File_tail
argument_list|,
name|NULL
argument_list|)
return|;
else|else
return|return
name|add_file
argument_list|(
name|NO_PROB
argument_list|,
literal|"fortunes"
argument_list|,
name|FORTDIR
argument_list|,
operator|&
name|File_list
argument_list|,
operator|&
name|File_tail
argument_list|,
name|NULL
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|file_cnt
condition|;
name|i
operator|++
control|)
block|{
name|percent
operator|=
name|NO_PROB
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|files
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
name|sp
operator|=
name|files
index|[
name|i
index|]
expr_stmt|;
else|else
block|{
name|percent
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|files
index|[
name|i
index|]
init|;
name|isdigit
argument_list|(
operator|*
name|sp
argument_list|)
condition|;
name|sp
operator|++
control|)
name|percent
operator|=
name|percent
operator|*
literal|10
operator|+
operator|*
name|sp
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|percent
operator|>
literal|100
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"percentages must be<= 100\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|*
name|sp
operator|==
literal|'.'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"percentages must be integers\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 			 * If the number isn't followed by a '%', then 			 * it was not a percentage, just the first part 			 * of a file name which starts with digits. 			 */
if|if
condition|(
operator|*
name|sp
operator|!=
literal|'%'
condition|)
block|{
name|percent
operator|=
name|NO_PROB
expr_stmt|;
name|sp
operator|=
name|files
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|++
name|sp
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|>=
name|file_cnt
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"percentages must precede files\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|sp
operator|=
name|files
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|sp
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
name|sp
operator|=
name|FORTDIR
expr_stmt|;
if|if
condition|(
operator|!
name|add_file
argument_list|(
name|percent
argument_list|,
name|sp
argument_list|,
name|NULL
argument_list|,
operator|&
name|File_list
argument_list|,
operator|&
name|File_tail
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/*  * add_file:  *	Add a file to the file list.  */
end_comment

begin_macro
name|add_file
argument_list|(
argument|percent
argument_list|,
argument|file
argument_list|,
argument|dir
argument_list|,
argument|head
argument_list|,
argument|tail
argument_list|,
argument|parent
argument_list|)
end_macro

begin_decl_stmt
name|int
name|percent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILEDESC
modifier|*
modifier|*
name|head
decl_stmt|,
modifier|*
modifier|*
name|tail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILEDESC
modifier|*
name|parent
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILEDESC
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|offensive
decl_stmt|;
specifier|register
name|bool
name|was_malloc
decl_stmt|;
specifier|register
name|bool
name|isdir
decl_stmt|;
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
block|{
name|path
operator|=
name|file
expr_stmt|;
name|was_malloc
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|path
operator|=
name|do_malloc
argument_list|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|strcat
argument_list|(
name|strcpy
argument_list|(
name|path
argument_list|,
name|dir
argument_list|)
argument_list|,
literal|"/"
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|was_malloc
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|isdir
operator|=
name|is_dir
argument_list|(
name|path
argument_list|)
operator|)
operator|&&
name|parent
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|was_malloc
condition|)
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
comment|/* don't recurse */
block|}
name|offensive
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|isdir
operator|&&
name|parent
operator|==
name|NULL
operator|&&
operator|(
name|All_forts
operator|||
name|Offend
operator|)
operator|&&
operator|!
name|is_off_name
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|offensive
operator|=
name|off_name
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|was_malloc
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|Offend
condition|)
block|{
if|if
condition|(
name|was_malloc
condition|)
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|offensive
expr_stmt|;
name|file
operator|=
name|off_name
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"adding file \"%s\"\n"
operator|,
name|path
operator|)
argument_list|)
expr_stmt|;
name|over
label|:
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* 		 * This is a sneak.  If the user said -a, and if the 		 * file we're given isn't a file, we check to see if 		 * there is a -o version.  If there is, we treat it as 		 * if *that* were the file given.  We only do this for 		 * individual files -- if we're scanning a directory, 		 * we'll pick up the -o file anyway. 		 */
if|if
condition|(
name|All_forts
operator|&&
name|offensive
operator|!=
name|NULL
condition|)
block|{
name|path
operator|=
name|offensive
expr_stmt|;
if|if
condition|(
name|was_malloc
condition|)
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|offensive
operator|=
name|NULL
expr_stmt|;
name|was_malloc
operator|=
name|TRUE
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"\ttrying \"%s\"\n"
operator|,
name|path
operator|)
argument_list|)
expr_stmt|;
name|file
operator|=
name|off_name
argument_list|(
name|file
argument_list|)
expr_stmt|;
goto|goto
name|over
goto|;
block|}
if|if
condition|(
name|dir
operator|==
name|NULL
operator|&&
name|file
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
return|return
name|add_file
argument_list|(
name|percent
argument_list|,
name|file
argument_list|,
name|FORTDIR
argument_list|,
name|head
argument_list|,
name|tail
argument_list|,
name|parent
argument_list|)
return|;
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
name|perror
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_malloc
condition|)
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|stderr
operator|,
literal|"path = \"%s\"\n"
operator|,
name|path
operator|)
argument_list|)
expr_stmt|;
name|fp
operator|=
name|new_fp
argument_list|()
expr_stmt|;
name|fp
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|fp
operator|->
name|percent
operator|=
name|percent
expr_stmt|;
name|fp
operator|->
name|name
operator|=
name|file
expr_stmt|;
name|fp
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|fp
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
if|if
condition|(
operator|(
name|isdir
operator|&&
operator|!
name|add_dir
argument_list|(
name|fp
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|isdir
operator|&&
operator|!
name|is_fortfile
argument_list|(
name|path
argument_list|,
operator|&
name|fp
operator|->
name|datfile
argument_list|,
operator|&
name|fp
operator|->
name|posfile
argument_list|,
operator|(
name|parent
operator|!=
name|NULL
operator|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fortune:%s not a fortune file or directory\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|was_malloc
condition|)
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|do_free
argument_list|(
name|fp
operator|->
name|datfile
argument_list|)
expr_stmt|;
name|do_free
argument_list|(
name|fp
operator|->
name|posfile
argument_list|)
expr_stmt|;
name|do_free
argument_list|(
name|offensive
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 	 * If the user said -a, we need to make this node a pointer to 	 * both files, if there are two.  We don't need to do this if 	 * we are scanning a directory, since the scan will pick up the 	 * -o file anyway. 	 */
if|if
condition|(
name|All_forts
operator|&&
name|parent
operator|==
name|NULL
operator|&&
operator|!
name|is_off_name
argument_list|(
name|path
argument_list|)
condition|)
name|all_forts
argument_list|(
name|fp
argument_list|,
name|offensive
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|head
operator|==
name|NULL
condition|)
operator|*
name|head
operator|=
operator|*
name|tail
operator|=
name|fp
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|->
name|percent
operator|==
name|NO_PROB
condition|)
block|{
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|=
name|fp
expr_stmt|;
name|fp
operator|->
name|prev
operator|=
operator|*
name|tail
expr_stmt|;
operator|*
name|tail
operator|=
name|fp
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|head
operator|)
operator|->
name|prev
operator|=
name|fp
expr_stmt|;
name|fp
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|fp
expr_stmt|;
block|}
name|fp
operator|->
name|was_pos_file
operator|=
operator|(
name|access
argument_list|(
name|fp
operator|->
name|posfile
argument_list|,
name|W_OK
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/*  * new_fp:  *	Return a pointer to an initialized new FILEDESC.  */
end_comment

begin_function
name|FILEDESC
modifier|*
name|new_fp
parameter_list|()
block|{
specifier|register
name|FILEDESC
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
operator|(
name|FILEDESC
operator|*
operator|)
name|do_malloc
argument_list|(
sizeof|sizeof
expr|*
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|datfd
operator|=
operator|-
literal|1
expr_stmt|;
name|fp
operator|->
name|pos
operator|=
name|POS_UNKNOWN
expr_stmt|;
name|fp
operator|->
name|inf
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|fp
operator|->
name|percent
operator|=
name|NO_PROB
expr_stmt|;
name|fp
operator|->
name|read_tbl
operator|=
name|FALSE
expr_stmt|;
name|fp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|child
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|datfile
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|posfile
operator|=
name|NULL
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/*  * off_name:  *	Return a pointer to the offensive version of a file of this name.  */
end_comment

begin_function
name|char
modifier|*
name|off_name
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|copy
argument_list|(
name|file
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|strcat
argument_list|(
name|new
argument_list|,
literal|"-o"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * is_off_name:  *	Is the file an offensive-style name?  */
end_comment

begin_macro
name|is_off_name
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|len
operator|>=
literal|3
operator|&&
name|file
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'-'
operator|&&
name|file
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'o'
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * all_forts:  *	Modify a FILEDESC element to be the parent of two children if  *	there are two children to be a parent of.  */
end_comment

begin_expr_stmt
name|all_forts
argument_list|(
name|fp
argument_list|,
name|offensive
argument_list|)
specifier|register
name|FILEDESC
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|offensive
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|FILEDESC
modifier|*
name|scene
decl_stmt|,
modifier|*
name|obscene
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
specifier|auto
name|char
modifier|*
name|datfile
decl_stmt|,
modifier|*
name|posfile
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|child
operator|!=
name|NULL
condition|)
comment|/* this is a directory, not a file */
return|return;
if|if
condition|(
operator|!
name|is_fortfile
argument_list|(
name|offensive
argument_list|,
operator|&
name|datfile
argument_list|,
operator|&
name|posfile
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|offensive
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"adding \"%s\" because of -a\n"
operator|,
name|offensive
operator|)
argument_list|)
expr_stmt|;
name|scene
operator|=
name|new_fp
argument_list|()
expr_stmt|;
name|obscene
operator|=
name|new_fp
argument_list|()
expr_stmt|;
operator|*
name|scene
operator|=
operator|*
name|fp
expr_stmt|;
name|fp
operator|->
name|num_children
operator|=
literal|2
expr_stmt|;
name|fp
operator|->
name|child
operator|=
name|scene
expr_stmt|;
name|scene
operator|->
name|next
operator|=
name|obscene
expr_stmt|;
name|obscene
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|scene
operator|->
name|child
operator|=
name|obscene
operator|->
name|child
operator|=
name|NULL
expr_stmt|;
name|scene
operator|->
name|parent
operator|=
name|obscene
operator|->
name|parent
operator|=
name|fp
expr_stmt|;
name|fp
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|scene
operator|->
name|percent
operator|=
name|obscene
operator|->
name|percent
operator|=
name|NO_PROB
expr_stmt|;
name|obscene
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|obscene
operator|->
name|inf
operator|=
name|NULL
expr_stmt|;
name|obscene
operator|->
name|path
operator|=
name|offensive
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|rindex
argument_list|(
name|offensive
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|obscene
operator|->
name|name
operator|=
name|offensive
expr_stmt|;
else|else
name|obscene
operator|->
name|name
operator|=
operator|++
name|sp
expr_stmt|;
name|obscene
operator|->
name|datfile
operator|=
name|datfile
expr_stmt|;
name|obscene
operator|->
name|posfile
operator|=
name|posfile
expr_stmt|;
name|obscene
operator|->
name|read_tbl
operator|=
name|FALSE
expr_stmt|;
name|obscene
operator|->
name|was_pos_file
operator|=
operator|(
name|access
argument_list|(
name|obscene
operator|->
name|posfile
argument_list|,
name|W_OK
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * add_dir:  *	Add the contents of an entire directory.  */
end_comment

begin_expr_stmt
name|add_dir
argument_list|(
name|fp
argument_list|)
specifier|register
name|FILEDESC
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|DIR
modifier|*
name|dir
decl_stmt|;
ifdef|#
directive|ifdef
name|SYSV
specifier|register
name|struct
name|dirent
modifier|*
name|dirent
decl_stmt|;
comment|/* NIH, of course! */
else|#
directive|else
specifier|register
name|struct
name|direct
modifier|*
name|dirent
decl_stmt|;
endif|#
directive|endif
specifier|auto
name|FILEDESC
modifier|*
name|tailp
decl_stmt|;
specifier|auto
name|char
modifier|*
name|name
decl_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fp
operator|->
name|fd
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|dir
operator|=
name|opendir
argument_list|(
name|fp
operator|->
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|fp
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|tailp
operator|=
name|NULL
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"adding dir \"%s\"\n"
operator|,
name|fp
operator|->
name|path
operator|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|num_children
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|dirent
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dirent
operator|->
name|d_namlen
operator|==
literal|0
condition|)
continue|continue;
name|name
operator|=
name|copy
argument_list|(
name|dirent
operator|->
name|d_name
argument_list|,
name|dirent
operator|->
name|d_namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_file
argument_list|(
name|NO_PROB
argument_list|,
name|name
argument_list|,
name|fp
operator|->
name|path
argument_list|,
operator|&
name|fp
operator|->
name|child
argument_list|,
operator|&
name|tailp
argument_list|,
name|fp
argument_list|)
condition|)
name|fp
operator|->
name|num_children
operator|++
expr_stmt|;
else|else
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|num_children
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fortune:%s:No fortune files in directory\n"
argument_list|,
name|fp
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/*  * is_dir:  *	Return TRUE if the file is a directory, FALSE otherwise.  */
end_comment

begin_macro
name|is_dir
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|auto
type|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
name|sbuf
operator|.
name|st_mode
operator|&
name|S_IFDIR
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * is_fortfile:  *	Return TRUE if the file is a fortune database file.  We try and  *	exclude files without reading them if possible to avoid  *	overhead.  Files which start with ".", or which have "illegal"  *	suffixes, as contained in suflist[], are ruled out.  */
end_comment

begin_macro
name|is_fortfile
argument_list|(
argument|file
argument_list|,
argument|datp
argument_list|,
argument|posp
argument_list|,
argument|check_for_offend
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|datp
decl_stmt|,
modifier|*
modifier|*
name|posp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|check_for_offend
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|char
modifier|*
name|datfile
decl_stmt|;
specifier|static
name|char
modifier|*
name|suflist
index|[]
init|=
block|{
comment|/* list of "illegal" suffixes" */
literal|"dat"
block|,
literal|"pos"
block|,
literal|"c"
block|,
literal|"h"
block|,
literal|"p"
block|,
literal|"i"
block|,
literal|"f"
block|,
literal|"pas"
block|,
literal|"ftn"
block|,
literal|"ins.c"
block|,
literal|"ins,pas"
block|,
literal|"ins.ftn"
block|,
literal|"sml"
block|,
name|NULL
block|}
decl_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|stderr
operator|,
literal|"is_fortfile(%s) returns "
operator|,
name|file
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Preclude any -o files for offendable people, and any non -o 	 * files for completely offensive people. 	 */
if|if
condition|(
name|check_for_offend
operator|&&
operator|!
name|All_forts
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|Offend
operator|^
operator|(
name|file
index|[
name|i
operator|-
literal|2
index|]
operator|==
literal|'-'
operator|&&
name|file
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'o'
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|sp
operator|=
name|rindex
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|sp
operator|=
name|file
expr_stmt|;
else|else
name|sp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'.'
condition|)
block|{
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|stderr
operator|,
literal|"FALSE (file starts with '.')\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|sp
operator|=
name|rindex
argument_list|(
name|sp
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|suflist
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|sp
argument_list|,
name|suflist
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|stderr
operator|,
literal|"FALSE (file has suffix \".%s\")\n"
operator|,
name|sp
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|datfile
operator|=
name|copy
argument_list|(
name|file
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* +4 for ".dat" */
name|strcat
argument_list|(
name|datfile
argument_list|,
literal|".dat"
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|datfile
argument_list|,
name|R_OK
argument_list|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|datfile
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|stderr
operator|,
literal|"FALSE (no \".dat\" file)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|datp
operator|!=
name|NULL
condition|)
operator|*
name|datp
operator|=
name|datfile
expr_stmt|;
else|else
name|free
argument_list|(
name|datfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|posp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|posp
operator|=
name|copy
argument_list|(
name|file
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* +4 for ".dat" */
operator|(
name|void
operator|)
name|strcat
argument_list|(
operator|*
name|posp
argument_list|,
literal|".pos"
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|stderr
operator|,
literal|"TRUE\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/*  * copy:  *	Return a malloc()'ed copy of the string  */
end_comment

begin_function
name|char
modifier|*
name|copy
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|new
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|new
operator|=
name|do_malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|=
name|new
expr_stmt|;
do|do
block|{
operator|*
name|sp
operator|++
operator|=
operator|*
name|str
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|str
operator|++
condition|)
do|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*  * do_malloc:  *	Do a malloc, checking for NULL return.  */
end_comment

begin_function
name|char
modifier|*
name|do_malloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fortune:Out of space\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*  * do_free:  *	Free malloc'ed space, if any.  */
end_comment

begin_macro
name|do_free
argument_list|(
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * init_prob:  *	Initialize the fortune probabilities.  */
end_comment

begin_macro
name|init_prob
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|FILEDESC
modifier|*
name|fp
decl_stmt|,
modifier|*
name|last
decl_stmt|;
specifier|register
name|int
name|percent
decl_stmt|,
name|num_noprob
decl_stmt|,
name|frac
decl_stmt|;
comment|/* 	 * Distribute the residual probability (if any) across all 	 * files with unspecified probability (i.e., probability of 0) 	 * (if any). 	 */
name|percent
operator|=
literal|0
expr_stmt|;
name|num_noprob
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|File_tail
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|prev
control|)
if|if
condition|(
name|fp
operator|->
name|percent
operator|==
name|NO_PROB
condition|)
block|{
name|num_noprob
operator|++
expr_stmt|;
if|if
condition|(
name|Equal_probs
condition|)
name|last
operator|=
name|fp
expr_stmt|;
block|}
else|else
name|percent
operator|+=
name|fp
operator|->
name|percent
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"summing probabilities:%d%% with %d NO_PROB's"
operator|,
name|percent
operator|,
name|num_noprob
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|percent
operator|>
literal|100
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fortune:Probabilities sum to %d%%!\n"
argument_list|,
name|percent
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|percent
operator|<
literal|100
operator|&&
name|num_noprob
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fortune:No place to put residual probability (%d%%)\n"
argument_list|,
name|percent
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|percent
operator|==
literal|100
operator|&&
name|num_noprob
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fortune:No probability left to put in residual files\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|percent
operator|=
literal|100
operator|-
name|percent
expr_stmt|;
if|if
condition|(
name|Equal_probs
condition|)
if|if
condition|(
name|num_noprob
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|num_noprob
operator|>
literal|1
condition|)
block|{
name|frac
operator|=
name|percent
operator|/
name|num_noprob
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|", frac = %d%%"
operator|,
name|frac
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|File_list
init|;
name|fp
operator|!=
name|last
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
if|if
condition|(
name|fp
operator|->
name|percent
operator|==
name|NO_PROB
condition|)
block|{
name|fp
operator|->
name|percent
operator|=
name|frac
expr_stmt|;
name|percent
operator|-=
name|frac
expr_stmt|;
block|}
block|}
name|last
operator|->
name|percent
operator|=
name|percent
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|", residual = %d%%"
operator|,
name|percent
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|", %d%% distributed over remaining fortunes\n"
operator|,
name|percent
operator|)
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>=
literal|1
condition|)
name|print_file_list
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * get_fort:  *	Get the fortune data file's seek pointer for the next fortune.  */
end_comment

begin_macro
name|get_fort
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|FILEDESC
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|choice
decl_stmt|;
name|long
name|random
parameter_list|()
function_decl|;
if|if
condition|(
name|File_list
operator|->
name|next
operator|==
name|NULL
operator|||
name|File_list
operator|->
name|percent
operator|==
name|NO_PROB
condition|)
name|fp
operator|=
name|File_list
expr_stmt|;
else|else
block|{
name|choice
operator|=
name|random
argument_list|()
operator|%
literal|100
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"choice = %d\n"
operator|,
name|choice
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|File_list
init|;
name|fp
operator|->
name|percent
operator|!=
name|NO_PROB
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
if|if
condition|(
name|choice
operator|<
name|fp
operator|->
name|percent
condition|)
break|break;
else|else
block|{
name|choice
operator|-=
name|fp
operator|->
name|percent
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"    skip \"%s\", %d%% (choice = %d)\n"
operator|,
name|fp
operator|->
name|name
operator|,
name|fp
operator|->
name|percent
operator|,
name|choice
operator|)
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"using \"%s\", %d%% (choice = %d)\n"
operator|,
name|fp
operator|->
name|name
operator|,
name|fp
operator|->
name|percent
operator|,
name|choice
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|percent
operator|!=
name|NO_PROB
condition|)
name|get_tbl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fp
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|sum_noprobs
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|choice
operator|=
name|random
argument_list|()
operator|%
name|Noprob_tbl
operator|.
name|str_numstr
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"choice = %d (of %d) \n"
operator|,
name|choice
operator|,
name|Noprob_tbl
operator|.
name|str_numstr
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|choice
operator|>=
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
condition|)
block|{
name|choice
operator|-=
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
expr_stmt|;
name|fp
operator|=
name|fp
operator|->
name|next
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"    skip \"%s\", %d (choice = %d)\n"
operator|,
name|fp
operator|->
name|name
operator|,
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
operator|,
name|choice
operator|)
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"using \"%s\", %d\n"
operator|,
name|fp
operator|->
name|name
operator|,
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
operator|)
argument_list|)
expr_stmt|;
block|}
name|get_tbl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"picking child\n"
operator|)
argument_list|)
expr_stmt|;
name|fp
operator|=
name|pick_child
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|Fortfile
operator|=
name|fp
expr_stmt|;
name|get_pos
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|open_dat
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fp
operator|->
name|datfd
argument_list|,
call|(
name|off_t
call|)
argument_list|(
sizeof|sizeof
name|fp
operator|->
name|tbl
operator|+
name|fp
operator|->
name|pos
operator|*
sizeof|sizeof
name|Seekpts
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fp
operator|->
name|datfd
argument_list|,
name|Seekpts
argument_list|,
sizeof|sizeof
name|Seekpts
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * pick_child  *	Pick a child from a chosen parent.  */
end_comment

begin_function
name|FILEDESC
modifier|*
name|pick_child
parameter_list|(
name|parent
parameter_list|)
name|FILEDESC
modifier|*
name|parent
decl_stmt|;
block|{
specifier|register
name|FILEDESC
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|choice
decl_stmt|;
if|if
condition|(
name|Equal_probs
condition|)
block|{
name|choice
operator|=
name|random
argument_list|()
operator|%
name|parent
operator|->
name|num_children
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"    choice = %d (of %d)\n"
operator|,
name|choice
operator|,
name|parent
operator|->
name|num_children
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|parent
operator|->
name|child
init|;
name|choice
operator|--
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
continue|continue;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"    using %s\n"
operator|,
name|fp
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
else|else
block|{
name|get_tbl
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|choice
operator|=
name|random
argument_list|()
operator|%
name|parent
operator|->
name|tbl
operator|.
name|str_numstr
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"    choice = %d (of %d)\n"
operator|,
name|choice
operator|,
name|parent
operator|->
name|tbl
operator|.
name|str_numstr
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|parent
operator|->
name|child
init|;
name|choice
operator|>=
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
block|{
name|choice
operator|-=
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"\tskip %s, %d (choice = %d)\n"
operator|,
name|fp
operator|->
name|name
operator|,
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
operator|,
name|choice
operator|)
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"    using %s, %d\n"
operator|,
name|fp
operator|->
name|name
operator|,
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
operator|)
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * sum_noprobs:  *	Sum up all the noprob probabilities, starting with fp.  */
end_comment

begin_expr_stmt
name|sum_noprobs
argument_list|(
name|fp
argument_list|)
specifier|register
name|FILEDESC
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|bool
name|did_noprobs
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|did_noprobs
condition|)
return|return;
name|zero_tbl
argument_list|(
operator|&
name|Noprob_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|get_tbl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|sum_tbl
argument_list|(
operator|&
name|Noprob_tbl
argument_list|,
operator|&
name|fp
operator|->
name|tbl
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fp
operator|->
name|next
expr_stmt|;
block|}
name|did_noprobs
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|max
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
specifier|register
name|int
name|i
operator|,
name|j
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|i
operator|>=
name|j
condition|?
name|i
else|:
name|j
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * open_fp:  *	Assocatiate a FILE * with the given FILEDESC.  */
end_comment

begin_macro
name|open_fp
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|FILEDESC
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fp
operator|->
name|inf
operator|==
name|NULL
operator|&&
operator|(
name|fp
operator|->
name|inf
operator|=
name|fdopen
argument_list|(
name|fp
operator|->
name|fd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|fp
operator|->
name|path
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * open_dat:  *	Open up the dat file if we need to.  */
end_comment

begin_macro
name|open_dat
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|FILEDESC
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fp
operator|->
name|datfd
operator|<
literal|0
operator|&&
operator|(
name|fp
operator|->
name|datfd
operator|=
name|open
argument_list|(
name|fp
operator|->
name|datfile
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|fp
operator|->
name|datfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * get_pos:  *	Get the position from the pos file, if there is one.  If not,  *	return a random number.  */
end_comment

begin_macro
name|get_pos
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|FILEDESC
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|assert
argument_list|(
name|fp
operator|->
name|read_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|pos
operator|==
name|POS_UNKNOWN
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fp
operator|->
name|posfile
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|fp
operator|->
name|pos
argument_list|,
sizeof|sizeof
name|fp
operator|->
name|pos
argument_list|)
operator|!=
sizeof|sizeof
name|fp
operator|->
name|pos
condition|)
name|fp
operator|->
name|pos
operator|=
name|random
argument_list|()
operator|%
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|->
name|pos
operator|>=
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
condition|)
name|fp
operator|->
name|pos
operator|%=
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
operator|(
name|fp
operator|->
name|pos
operator|)
operator|>=
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
condition|)
name|fp
operator|->
name|pos
operator|-=
name|fp
operator|->
name|tbl
operator|.
name|str_numstr
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"pos for %s is %d\n"
operator|,
name|fp
operator|->
name|name
operator|,
name|fp
operator|->
name|pos
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * get_tbl:  *	Get the tbl data file the datfile.  */
end_comment

begin_macro
name|get_tbl
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|FILEDESC
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|auto
name|int
name|fd
decl_stmt|;
specifier|register
name|FILEDESC
modifier|*
name|child
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|read_tbl
condition|)
return|return;
if|if
condition|(
name|fp
operator|->
name|child
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fp
operator|->
name|datfile
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|fp
operator|->
name|datfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fp
operator|->
name|tbl
argument_list|,
sizeof|sizeof
name|fp
operator|->
name|tbl
argument_list|)
operator|!=
sizeof|sizeof
name|fp
operator|->
name|tbl
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fortune:%s corrupted\n"
argument_list|,
name|fp
operator|->
name|path
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zero_tbl
argument_list|(
operator|&
name|fp
operator|->
name|tbl
argument_list|)
expr_stmt|;
for|for
control|(
name|child
operator|=
name|fp
operator|->
name|child
init|;
name|child
operator|!=
name|NULL
condition|;
name|child
operator|=
name|child
operator|->
name|next
control|)
block|{
name|get_tbl
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|sum_tbl
argument_list|(
operator|&
name|fp
operator|->
name|tbl
argument_list|,
operator|&
name|child
operator|->
name|tbl
argument_list|)
expr_stmt|;
block|}
block|}
name|fp
operator|->
name|read_tbl
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * zero_tbl:  *	Zero out the fields we care about in a tbl structure.  */
end_comment

begin_expr_stmt
name|zero_tbl
argument_list|(
name|tp
argument_list|)
specifier|register
name|STRFILE
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|tp
operator|->
name|str_numstr
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|str_longlen
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|str_shortlen
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * sum_tbl:  *	Merge the tbl data of t2 into t1.  */
end_comment

begin_expr_stmt
name|sum_tbl
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
specifier|register
name|STRFILE
operator|*
name|t1
operator|,
operator|*
name|t2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|t1
operator|->
name|str_numstr
operator|+=
name|t2
operator|->
name|str_numstr
expr_stmt|;
if|if
condition|(
name|t1
operator|->
name|str_longlen
operator|<
name|t2
operator|->
name|str_longlen
condition|)
name|t1
operator|->
name|str_longlen
operator|=
name|t2
operator|->
name|str_longlen
expr_stmt|;
if|if
condition|(
name|t1
operator|->
name|str_shortlen
operator|>
name|t2
operator|->
name|str_shortlen
condition|)
name|t1
operator|->
name|str_shortlen
operator|=
name|t2
operator|->
name|str_shortlen
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|STR
parameter_list|(
name|str
parameter_list|)
value|((str) == NULL ? "NULL" : (str))
end_define

begin_comment
comment|/*  * print_file_list:  *	Print out the file list  */
end_comment

begin_macro
name|print_file_list
argument_list|()
end_macro

begin_block
block|{
name|print_list
argument_list|(
name|File_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * print_list:  *	Print out the actual list, recursively.  */
end_comment

begin_expr_stmt
name|print_list
argument_list|(
name|list
argument_list|,
name|lev
argument_list|)
specifier|register
name|FILEDESC
operator|*
name|list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|lev
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%*s"
argument_list|,
name|lev
operator|*
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|percent
operator|==
name|NO_PROB
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"___%%"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%3d%%"
argument_list|,
name|list
operator|->
name|percent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|STR
argument_list|(
name|list
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|" (%s, %s, %s)\n"
operator|,
name|STR
argument_list|(
name|list
operator|->
name|path
argument_list|)
operator|,
name|STR
argument_list|(
name|list
operator|->
name|datfile
argument_list|)
operator|,
name|STR
argument_list|(
name|list
operator|->
name|posfile
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|child
operator|!=
name|NULL
condition|)
name|print_list
argument_list|(
name|list
operator|->
name|child
argument_list|,
name|lev
operator|+
literal|1
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|NO_REGEX
end_ifndef

begin_comment
comment|/*  * conv_pat:  *	Convert the pattern to an ignore-case equivalent.  */
end_comment

begin_function
name|char
modifier|*
name|conv_pat
parameter_list|(
name|orig
parameter_list|)
specifier|register
name|char
modifier|*
name|orig
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|unsigned
name|int
name|cnt
decl_stmt|;
specifier|register
name|char
modifier|*
name|new
decl_stmt|;
name|cnt
operator|=
literal|1
expr_stmt|;
comment|/* allow for '\0' */
for|for
control|(
name|sp
operator|=
name|orig
init|;
operator|*
name|sp
operator|!=
literal|'\0'
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|sp
argument_list|)
condition|)
name|cnt
operator|+=
literal|4
expr_stmt|;
else|else
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|malloc
argument_list|(
name|cnt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pattern too long for ignoring case\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sp
operator|=
name|new
init|;
operator|*
name|orig
operator|!=
literal|'\0'
condition|;
name|orig
operator|++
control|)
block|{
if|if
condition|(
name|islower
argument_list|(
operator|*
name|orig
argument_list|)
condition|)
block|{
operator|*
name|sp
operator|++
operator|=
literal|'['
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
operator|*
name|orig
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|toupper
argument_list|(
operator|*
name|orig
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
literal|']'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|orig
argument_list|)
condition|)
block|{
operator|*
name|sp
operator|++
operator|=
literal|'['
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
operator|*
name|orig
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|tolower
argument_list|(
operator|*
name|orig
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
literal|']'
expr_stmt|;
block|}
else|else
operator|*
name|sp
operator|++
operator|=
operator|*
name|orig
expr_stmt|;
block|}
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*  * find_matches:  *	Find all the fortunes which match the pattern we've been given.  */
end_comment

begin_macro
name|find_matches
argument_list|()
end_macro

begin_block
block|{
name|Fort_len
operator|=
name|maxlen_in_list
argument_list|(
name|File_list
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|2
argument_list|,
operator|(
name|stderr
operator|,
literal|"Maximum length is %d\n"
operator|,
name|Fort_len
operator|)
argument_list|)
expr_stmt|;
name|Fortbuf
operator|=
name|do_malloc
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|Fort_len
argument_list|)
expr_stmt|;
name|Found_one
operator|=
name|FALSE
expr_stmt|;
name|matches_in_list
argument_list|(
name|File_list
argument_list|)
expr_stmt|;
return|return
name|Found_one
return|;
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*  * maxlen_in_list  *	Return the maximum fortune len in the file list.  */
end_comment

begin_macro
name|maxlen_in_list
argument_list|(
argument|list
argument_list|)
end_macro

begin_decl_stmt
name|FILEDESC
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILEDESC
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|maxlen
decl_stmt|;
name|maxlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|list
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|maxlen_in_list
argument_list|(
name|fp
operator|->
name|child
argument_list|)
operator|)
operator|>
name|maxlen
condition|)
name|maxlen
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|get_tbl
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|tbl
operator|.
name|str_longlen
operator|>
name|maxlen
condition|)
name|maxlen
operator|=
name|fp
operator|->
name|tbl
operator|.
name|str_longlen
expr_stmt|;
block|}
block|}
return|return
name|maxlen
return|;
block|}
end_block

begin_comment
comment|/*  * matches_in_list  *	Print out the matches from the files in the list.  */
end_comment

begin_macro
name|matches_in_list
argument_list|(
argument|list
argument_list|)
end_macro

begin_decl_stmt
name|FILEDESC
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|FILEDESC
modifier|*
name|fp
decl_stmt|;
name|int
name|in_file
decl_stmt|;
for|for
control|(
name|fp
operator|=
name|list
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
name|matches_in_list
argument_list|(
name|fp
operator|->
name|child
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DPRINTF
argument_list|(
literal|1
argument_list|,
operator|(
name|stderr
operator|,
literal|"searching in %s\n"
operator|,
name|fp
operator|->
name|path
operator|)
argument_list|)
expr_stmt|;
name|open_fp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|Fortbuf
expr_stmt|;
name|in_file
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|sp
argument_list|,
name|Fort_len
argument_list|,
name|fp
operator|->
name|inf
argument_list|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|STR_ENDSTRING
argument_list|(
name|sp
argument_list|,
name|fp
operator|->
name|tbl
argument_list|)
condition|)
name|sp
operator|+=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|RE_EXEC
argument_list|(
name|Fortbuf
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%c%c"
argument_list|,
name|fp
operator|->
name|tbl
operator|.
name|str_delim
argument_list|,
name|fp
operator|->
name|tbl
operator|.
name|str_delim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_file
condition|)
block|{
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|fp
operator|->
name|name
argument_list|)
expr_stmt|;
name|Found_one
operator|=
name|TRUE
expr_stmt|;
name|in_file
operator|=
name|TRUE
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|Fortbuf
argument_list|,
literal|1
argument_list|,
operator|(
name|sp
operator|-
name|Fortbuf
operator|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|sp
operator|=
name|Fortbuf
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_REGEX */
end_comment

end_unit

