begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  *	Simulate pdp11 floating point for compatability mode programs.  *	Quick and dirty with no big effort at speed since it takes so  *	much overhead to get here in the first place.  *	I make no claims on the completeness of this simulation.  *	Art Wetzel 3/16/80  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOFPSIM
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* output codes */
end_comment

begin_define
define|#
directive|define
name|NONE
value|0
end_define

begin_define
define|#
directive|define
name|SHORT
value|01
end_define

begin_define
define|#
directive|define
name|LONG
value|02
end_define

begin_define
define|#
directive|define
name|FLOAT
value|04
end_define

begin_define
define|#
directive|define
name|DOUBLE
value|010
end_define

begin_define
define|#
directive|define
name|OUTPUT
value|020
end_define

begin_comment
comment|/* parts of fps */
end_comment

begin_define
define|#
directive|define
name|FD
value|0200
end_define

begin_define
define|#
directive|define
name|FL
value|0100
end_define

begin_define
define|#
directive|define
name|FN
value|010
end_define

begin_define
define|#
directive|define
name|FZ
value|04
end_define

begin_define
define|#
directive|define
name|FV
value|02
end_define

begin_define
define|#
directive|define
name|FC
value|01
end_define

begin_comment
comment|/* fis instructions */
end_comment

begin_define
define|#
directive|define
name|FADD
value|075000
end_define

begin_define
define|#
directive|define
name|FSUB
value|075010
end_define

begin_define
define|#
directive|define
name|FMUL
value|075020
end_define

begin_define
define|#
directive|define
name|FDIV
value|075030
end_define

begin_comment
comment|/* fpu instructions */
end_comment

begin_define
define|#
directive|define
name|ABSD
value|0170600
end_define

begin_define
define|#
directive|define
name|ABSF
value|0170600
end_define

begin_define
define|#
directive|define
name|ADDD
value|0172000
end_define

begin_define
define|#
directive|define
name|ADDF
value|0172000
end_define

begin_define
define|#
directive|define
name|CFCC
value|0170000
end_define

begin_define
define|#
directive|define
name|CLRD
value|0170400
end_define

begin_define
define|#
directive|define
name|CLRF
value|0170400
end_define

begin_define
define|#
directive|define
name|CMPD
value|0173400
end_define

begin_define
define|#
directive|define
name|CMPF
value|0173400
end_define

begin_define
define|#
directive|define
name|DIVD
value|0174400
end_define

begin_define
define|#
directive|define
name|DIVF
value|0174400
end_define

begin_define
define|#
directive|define
name|LDCFD
value|0177400
end_define

begin_define
define|#
directive|define
name|LDCFF
value|0177400
end_define

begin_define
define|#
directive|define
name|LDCLD
value|0177000
end_define

begin_define
define|#
directive|define
name|LDCLF
value|0177000
end_define

begin_define
define|#
directive|define
name|LDCIF
value|0177000
end_define

begin_define
define|#
directive|define
name|LDCID
value|0177000
end_define

begin_define
define|#
directive|define
name|LDEXP
value|0176400
end_define

begin_define
define|#
directive|define
name|LDD
value|0172400
end_define

begin_define
define|#
directive|define
name|LDF
value|0172400
end_define

begin_define
define|#
directive|define
name|LDFPS
value|0170100
end_define

begin_define
define|#
directive|define
name|MODD
value|0171400
end_define

begin_define
define|#
directive|define
name|MODF
value|0171400
end_define

begin_define
define|#
directive|define
name|MULD
value|0171000
end_define

begin_define
define|#
directive|define
name|MULF
value|0171000
end_define

begin_define
define|#
directive|define
name|NEGD
value|0170700
end_define

begin_define
define|#
directive|define
name|NEGF
value|0170700
end_define

begin_define
define|#
directive|define
name|SETF
value|0170001
end_define

begin_define
define|#
directive|define
name|SETD
value|0170011
end_define

begin_define
define|#
directive|define
name|SETI
value|0170002
end_define

begin_define
define|#
directive|define
name|SETL
value|0170012
end_define

begin_define
define|#
directive|define
name|STCDF
value|0176000
end_define

begin_define
define|#
directive|define
name|STCFD
value|0176000
end_define

begin_define
define|#
directive|define
name|STCDL
value|0175400
end_define

begin_define
define|#
directive|define
name|STCDI
value|0175400
end_define

begin_define
define|#
directive|define
name|STCFL
value|0175400
end_define

begin_define
define|#
directive|define
name|STCFI
value|0175400
end_define

begin_define
define|#
directive|define
name|STEXP
value|0175000
end_define

begin_define
define|#
directive|define
name|STD
value|0174000
end_define

begin_define
define|#
directive|define
name|STF
value|0174000
end_define

begin_define
define|#
directive|define
name|STFPS
value|0170200
end_define

begin_define
define|#
directive|define
name|STST
value|0170300
end_define

begin_define
define|#
directive|define
name|SUBD
value|0173000
end_define

begin_define
define|#
directive|define
name|SUBF
value|0173000
end_define

begin_define
define|#
directive|define
name|TSTD
value|0170500
end_define

begin_define
define|#
directive|define
name|TSTF
value|0170500
end_define

begin_union
union|union
name|alltypes
block|{
name|double
name|d
decl_stmt|;
name|float
name|f
decl_stmt|;
name|long
name|l
decl_stmt|;
name|short
name|s
decl_stmt|;
name|unsigned
name|short
name|p
index|[
literal|4
index|]
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* static storage for floating registers */
end_comment

begin_decl_stmt
specifier|static
name|union
name|alltypes
name|fregs
index|[
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|union
name|alltypes
name|srcdst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fps
init|=
name|FD
operator||
name|FL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dbl
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lng
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|dofloat
argument_list|(
argument|instr
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|int
name|instr
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|NOFPSIM
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|#
directive|else
specifier|register
name|unsigned
name|short
modifier|*
name|wptr
decl_stmt|;
specifier|register
name|unsigned
name|int
name|opcode
decl_stmt|,
name|ac
decl_stmt|,
name|mode
decl_stmt|,
name|fac
decl_stmt|,
name|adjust
decl_stmt|,
name|output
decl_stmt|,
name|ccset
decl_stmt|;
name|unsigned
name|short
modifier|*
name|locate
parameter_list|()
function_decl|;
comment|/* indicate what condition codes will be changed by op - assume none */
name|ccset
operator|=
literal|0
expr_stmt|;
comment|/* type of memory output - assume none */
name|output
operator|=
name|NONE
expr_stmt|;
comment|/* default adjust to type */
if|if
condition|(
name|dbl
condition|)
name|adjust
operator|=
name|DOUBLE
expr_stmt|;
else|else
name|adjust
operator|=
name|FLOAT
expr_stmt|;
comment|/* chop up instruction to get relevent parts */
name|opcode
operator|=
name|instr
operator|&
literal|0177700
expr_stmt|;
name|fac
operator|=
operator|(
name|instr
operator|>>
literal|6
operator|)
operator|&
literal|03
expr_stmt|;
name|mode
operator|=
operator|(
name|instr
operator|>>
literal|3
operator|)
operator|&
literal|07
expr_stmt|;
name|ac
operator|=
name|instr
operator|&
literal|07
expr_stmt|;
comment|/* if the instruction uses a src/dst construct ptr and fetch */
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|FADD
case|:
case|case
name|CFCC
case|:
break|break;
default|default:
name|wptr
operator|=
name|locate
argument_list|(
name|mode
argument_list|,
name|ac
argument_list|)
expr_stmt|;
comment|/* special case for mode 0 */
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
switch|switch
condition|(
name|opcode
operator|&
literal|0177400
condition|)
block|{
comment|/* special instructions to use cpu regs */
case|case
name|LDEXP
case|:
case|case
name|STEXP
case|:
name|wptr
operator|=
operator|&
name|regs
index|[
name|ac
index|]
expr_stmt|;
break|break;
case|case
name|STCDL
case|:
name|wptr
operator|=
operator|&
name|regs
index|[
name|ac
index|]
expr_stmt|;
default|default:
break|break;
block|}
if|if
condition|(
name|dbl
condition|)
name|srcdst
operator|.
name|d
operator|=
operator|*
operator|(
name|double
operator|*
operator|)
name|wptr
expr_stmt|;
else|else
name|srcdst
operator|.
name|f
operator|=
operator|*
operator|(
name|float
operator|*
operator|)
name|wptr
expr_stmt|;
comment|/* immediate fetches are 16 bits */
if|if
condition|(
name|ac
operator|==
literal|7
operator|&&
operator|(
name|mode
operator|==
literal|2
operator|)
condition|)
block|{
name|srcdst
operator|.
name|p
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|srcdst
operator|.
name|p
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|srcdst
operator|.
name|p
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pc %o sp %o instr %o srcdst %o mode %o reg %o fac %o\n"
argument_list|,
name|pc
operator|-
literal|1
argument_list|,
name|regs
index|[
literal|6
index|]
argument_list|,
name|instr
argument_list|,
name|srcdst
operator|.
name|s
argument_list|,
name|mode
argument_list|,
name|ac
argument_list|,
name|fac
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|FADD
case|:
comment|/* catches all fis instructions */
comment|/* last 3 bits are stack pointer register */
name|ac
operator|=
name|instr
operator|&
literal|07
expr_stmt|;
comment|/* get pointer to stack words */
name|wptr
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|regs
index|[
name|ac
index|]
expr_stmt|;
comment|/* getch floating value from stack */
name|srcdst
operator|.
name|f
operator|=
operator|*
operator|(
name|float
operator|*
operator|)
name|wptr
expr_stmt|;
comment|/* shorten stack */
name|wptr
operator|+=
literal|2
expr_stmt|;
comment|/* do appropriate operation */
switch|switch
condition|(
name|instr
operator|&
literal|0177770
condition|)
block|{
case|case
name|FADD
case|:
name|srcdst
operator|.
name|f
operator|+=
operator|*
operator|(
name|float
operator|*
operator|)
name|wptr
expr_stmt|;
break|break;
case|case
name|FSUB
case|:
name|srcdst
operator|.
name|f
operator|=
operator|*
operator|(
name|float
operator|*
operator|)
name|wptr
operator|-
name|srcdst
operator|.
name|f
expr_stmt|;
break|break;
case|case
name|FMUL
case|:
name|srcdst
operator|.
name|f
operator|*=
operator|*
operator|(
name|float
operator|*
operator|)
name|wptr
expr_stmt|;
break|break;
case|case
name|FDIV
case|:
name|srcdst
operator|.
name|f
operator|=
operator|*
operator|(
name|float
operator|*
operator|)
name|wptr
operator|/
name|srcdst
operator|.
name|f
expr_stmt|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* copy out result */
operator|*
operator|(
name|float
operator|*
operator|)
name|wptr
operator|=
name|srcdst
operator|.
name|f
expr_stmt|;
comment|/* set up condition codes */
name|psl
operator|&=
operator|~
literal|017
expr_stmt|;
if|if
condition|(
name|srcdst
operator|.
name|f
operator|==
literal|0.
condition|)
name|psl
operator||=
name|FZ
expr_stmt|;
if|if
condition|(
name|srcdst
operator|.
name|f
operator|<
literal|0.
condition|)
name|psl
operator||=
name|FN
expr_stmt|;
comment|/* adjust register to reflect stack change */
name|regs
index|[
name|ac
index|]
operator|=
operator|(
name|unsigned
name|short
operator|)
operator|(
name|int
operator|)
name|wptr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CFCC
case|:
switch|switch
condition|(
name|instr
condition|)
block|{
case|case
name|SETF
case|:
name|dbl
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SETD
case|:
name|dbl
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SETI
case|:
name|lng
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SETL
case|:
name|lng
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CFCC
case|:
name|psl
operator|&=
operator|~
literal|017
expr_stmt|;
name|psl
operator||=
operator|(
name|fps
operator|&
literal|017
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"CFCC %o\n"
argument_list|,
name|psl
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ABSD
case|:
if|if
condition|(
name|srcdst
operator|.
name|d
operator|<
literal|0.0
condition|)
name|srcdst
operator|.
name|d
operator|=
operator|-
name|srcdst
operator|.
name|d
expr_stmt|;
name|ccset
operator|=
name|FZ
expr_stmt|;
if|if
condition|(
name|dbl
condition|)
name|output
operator|=
name|DOUBLE
expr_stmt|;
else|else
name|output
operator|=
name|FLOAT
expr_stmt|;
break|break;
case|case
name|CLRD
case|:
name|srcdst
operator|.
name|d
operator|=
literal|0.0
expr_stmt|;
name|ccset
operator|=
name|FZ
expr_stmt|;
if|if
condition|(
name|dbl
condition|)
name|output
operator|=
name|DOUBLE
expr_stmt|;
else|else
name|output
operator|=
name|FLOAT
expr_stmt|;
break|break;
case|case
name|LDFPS
case|:
name|adjust
operator|=
name|SHORT
expr_stmt|;
name|fps
operator|=
name|srcdst
operator|.
name|s
expr_stmt|;
if|if
condition|(
name|fps
operator|&
name|FD
condition|)
name|dbl
operator|=
literal|1
expr_stmt|;
else|else
name|dbl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fps
operator|&
name|FL
condition|)
name|lng
operator|=
literal|1
expr_stmt|;
else|else
name|lng
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NEGD
case|:
name|srcdst
operator|.
name|d
operator|=
operator|-
name|srcdst
operator|.
name|d
expr_stmt|;
name|ccset
operator|=
name|FZ
operator||
name|FN
expr_stmt|;
if|if
condition|(
name|dbl
condition|)
name|output
operator|=
name|DOUBLE
expr_stmt|;
else|else
name|output
operator|=
name|FLOAT
expr_stmt|;
break|break;
case|case
name|STFPS
case|:
name|srcdst
operator|.
name|s
operator|=
name|fps
expr_stmt|;
name|adjust
operator|=
name|output
operator|=
name|SHORT
expr_stmt|;
break|break;
case|case
name|STST
case|:
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|TSTD
case|:
name|ccset
operator|=
name|FZ
operator||
name|FN
expr_stmt|;
break|break;
default|default:
name|opcode
operator|=
name|instr
operator|&
literal|0177400
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|STD
case|:
name|srcdst
operator|.
name|d
operator|=
name|fregs
index|[
name|fac
index|]
operator|.
name|d
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"STD %o\n"
argument_list|,
name|srcdst
operator|.
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dbl
condition|)
name|output
operator|=
name|DOUBLE
expr_stmt|;
else|else
name|output
operator|=
name|FLOAT
expr_stmt|;
break|break;
case|case
name|LDD
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"LDD %o\n"
argument_list|,
name|srcdst
operator|.
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fregs
index|[
name|fac
index|]
operator|.
name|d
operator|=
name|srcdst
operator|.
name|d
expr_stmt|;
name|ccset
operator|=
name|FZ
operator||
name|FN
expr_stmt|;
break|break;
case|case
name|ADDD
case|:
name|fregs
index|[
name|fac
index|]
operator|.
name|d
operator|+=
name|srcdst
operator|.
name|d
expr_stmt|;
name|ccset
operator|=
name|FZ
operator||
name|FN
expr_stmt|;
break|break;
case|case
name|SUBD
case|:
name|fregs
index|[
name|fac
index|]
operator|.
name|d
operator|-=
name|srcdst
operator|.
name|d
expr_stmt|;
name|ccset
operator|=
name|FZ
operator||
name|FN
expr_stmt|;
break|break;
case|case
name|MULD
case|:
name|fregs
index|[
name|fac
index|]
operator|.
name|d
operator|*=
name|srcdst
operator|.
name|d
expr_stmt|;
name|ccset
operator|=
name|FZ
operator||
name|FN
expr_stmt|;
break|break;
case|case
name|DIVD
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DIVD %f by %f gives "
argument_list|,
name|fregs
index|[
name|fac
index|]
operator|.
name|d
argument_list|,
name|srcdst
operator|.
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fregs
index|[
name|fac
index|]
operator|.
name|d
operator|/=
name|srcdst
operator|.
name|d
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> %f\n"
argument_list|,
name|fregs
index|[
name|fac
index|]
operator|.
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ccset
operator|=
name|FZ
operator||
name|FN
expr_stmt|;
break|break;
case|case
name|STCDF
case|:
name|adjust
operator|=
name|output
operator|=
name|FLOAT
expr_stmt|;
name|ccset
operator|=
name|FZ
operator||
name|FN
expr_stmt|;
break|break;
case|case
name|LDCFD
case|:
name|adjust
operator|=
name|FLOAT
expr_stmt|;
name|ccset
operator|=
name|FZ
operator||
name|FN
expr_stmt|;
break|break;
case|case
name|LDCLD
case|:
if|if
condition|(
name|lng
condition|)
block|{
name|adjust
operator|=
name|LONG
expr_stmt|;
name|srcdst
operator|.
name|d
operator|=
name|srcdst
operator|.
name|l
expr_stmt|;
block|}
else|else
block|{
name|adjust
operator|=
name|SHORT
expr_stmt|;
name|srcdst
operator|.
name|d
operator|=
name|srcdst
operator|.
name|s
expr_stmt|;
block|}
name|ccset
operator|=
name|FZ
operator||
name|FN
expr_stmt|;
break|break;
case|case
name|CMPD
case|:
name|srcdst
operator|.
name|d
operator|-=
name|fregs
index|[
name|fac
index|]
operator|.
name|d
expr_stmt|;
name|ccset
operator|=
name|FZ
operator||
name|FN
expr_stmt|;
break|break;
case|case
name|LDEXP
case|:
name|srcdst
operator|.
name|d
operator|=
literal|0.0
expr_stmt|;
name|srcdst
operator|.
name|s
operator|=
operator|*
name|wptr
expr_stmt|;
name|srcdst
operator|.
name|s
operator|<<=
literal|7
expr_stmt|;
name|srcdst
operator|.
name|s
operator|+=
literal|0200
expr_stmt|;
name|adjust
operator|=
name|SHORT
expr_stmt|;
name|ccset
operator|=
name|FZ
operator||
name|FN
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"LDEXP %o gives %o\n"
argument_list|,
operator|*
name|wptr
argument_list|,
name|srcdst
operator|.
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|MODD
case|:
name|srcdst
operator|.
name|d
operator|*=
name|fregs
index|[
name|fac
index|]
operator|.
name|d
expr_stmt|;
name|fregs
index|[
name|fac
index|]
operator|.
name|d
operator|=
operator|(
name|double
operator|)
operator|(
name|long
operator|)
name|srcdst
operator|.
name|d
expr_stmt|;
if|if
condition|(
operator|~
name|fac
operator|&
literal|1
condition|)
name|fregs
index|[
name|fac
operator|+
literal|1
index|]
operator|.
name|d
operator|=
name|fregs
index|[
name|fac
index|]
operator|.
name|d
expr_stmt|;
name|srcdst
operator|.
name|d
operator|-=
name|fregs
index|[
name|fac
index|]
operator|.
name|d
expr_stmt|;
name|ccset
operator|=
name|FN
operator||
name|FZ
expr_stmt|;
name|fregs
index|[
name|fac
index|]
operator|.
name|d
operator|=
name|srcdst
operator|.
name|d
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"MODD %o %o\n"
argument_list|,
name|fregs
index|[
name|fac
index|]
operator|.
name|s
argument_list|,
name|fregs
index|[
name|fac
operator|+
literal|1
index|]
operator|.
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|STCDL
case|:
if|if
condition|(
name|lng
condition|)
name|adjust
operator|=
name|output
operator|=
name|LONG
expr_stmt|;
else|else
name|adjust
operator|=
name|output
operator|=
name|SHORT
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
name|output
operator|=
name|SHORT
expr_stmt|;
name|srcdst
operator|.
name|l
operator|=
name|fregs
index|[
name|fac
index|]
operator|.
name|d
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"STCDL %o\n"
argument_list|,
name|srcdst
operator|.
name|l
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ccset
operator|=
name|FZ
operator||
name|FN
expr_stmt|;
break|break;
case|case
name|STEXP
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"STEXP of %o gives "
argument_list|,
name|srcdst
operator|.
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|srcdst
operator|.
name|s
operator|&=
literal|077600
expr_stmt|;
name|srcdst
operator|.
name|s
operator|>>=
literal|7
expr_stmt|;
name|srcdst
operator|.
name|s
operator|-=
literal|0200
expr_stmt|;
name|adjust
operator|=
name|output
operator|=
name|SHORT
expr_stmt|;
name|ccset
operator|=
name|FZ
operator||
name|FN
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%o\n"
argument_list|,
name|srcdst
operator|.
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ccset
operator|&
name|FZ
condition|)
block|{
name|fps
operator|&=
operator|~
name|FZ
expr_stmt|;
if|if
condition|(
name|srcdst
operator|.
name|d
operator|==
literal|0.0
condition|)
name|fps
operator||=
name|FZ
expr_stmt|;
if|if
condition|(
operator|!
name|dbl
operator|&&
name|srcdst
operator|.
name|f
operator|==
literal|0.0
condition|)
name|fps
operator||=
name|FZ
expr_stmt|;
block|}
if|if
condition|(
name|ccset
operator|&
name|FN
condition|)
block|{
name|fps
operator|&=
operator|~
name|FN
expr_stmt|;
if|if
condition|(
name|srcdst
operator|.
name|f
operator|<
literal|0.0
condition|)
name|fps
operator||=
name|FN
expr_stmt|;
block|}
switch|switch
condition|(
name|instr
operator|&
literal|0177400
condition|)
block|{
case|case
name|STCDL
case|:
case|case
name|STEXP
case|:
name|psl
operator|&=
operator|~
literal|017
expr_stmt|;
name|psl
operator||=
operator|(
name|fps
operator|&
literal|017
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|output
condition|)
block|{
case|case
name|NONE
case|:
break|break;
case|case
name|SHORT
case|:
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
name|wptr
operator|)
operator|=
name|srcdst
operator|.
name|s
expr_stmt|;
name|srcdst
operator|.
name|d
operator|=
literal|0.0
expr_stmt|;
break|break;
case|case
name|LONG
case|:
if|if
condition|(
name|mode
operator|==
literal|4
condition|)
name|wptr
operator|--
expr_stmt|;
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
name|wptr
operator|)
operator|=
name|longrev
argument_list|(
name|srcdst
operator|.
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
if|if
condition|(
name|mode
operator|==
literal|4
condition|)
name|wptr
operator|--
expr_stmt|;
operator|*
operator|(
operator|(
name|float
operator|*
operator|)
name|wptr
operator|)
operator|=
name|srcdst
operator|.
name|f
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
if|if
condition|(
name|mode
operator|==
literal|4
condition|)
name|wptr
operator|-=
literal|3
expr_stmt|;
operator|*
operator|(
operator|(
name|double
operator|*
operator|)
name|wptr
operator|)
operator|=
name|srcdst
operator|.
name|d
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
switch|switch
condition|(
name|adjust
condition|)
block|{
case|case
name|SHORT
case|:
name|regs
index|[
name|ac
index|]
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|LONG
case|:
case|case
name|FLOAT
case|:
name|regs
index|[
name|ac
index|]
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|regs
index|[
name|ac
index|]
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|NONE
case|:
break|break;
block|}
if|if
condition|(
name|ac
operator|==
literal|7
condition|)
name|pc
operator|++
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|regs
index|[
name|ac
index|]
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ac
operator|==
literal|7
condition|)
name|pc
operator|++
expr_stmt|;
break|break;
case|case
literal|4
case|:
switch|switch
condition|(
name|adjust
condition|)
block|{
case|case
name|SHORT
case|:
name|regs
index|[
name|ac
index|]
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
name|LONG
case|:
case|case
name|FLOAT
case|:
name|regs
index|[
name|ac
index|]
operator|-=
literal|4
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|regs
index|[
name|ac
index|]
operator|-=
literal|8
expr_stmt|;
break|break;
case|case
name|NONE
case|:
break|break;
block|}
break|break;
case|case
literal|5
case|:
name|regs
index|[
name|ac
index|]
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
literal|6
case|:
case|case
literal|7
case|:
name|pc
operator|++
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|NOFPSIM
end_ifndef

begin_function
name|unsigned
name|short
modifier|*
name|locate
parameter_list|(
name|mode
parameter_list|,
name|ac
parameter_list|)
block|{
specifier|register
name|unsigned
name|short
modifier|*
name|wptr
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
comment|/* mode 0 normally implies fregs */
name|wptr
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|&
name|fregs
index|[
name|ac
index|]
expr_stmt|;
break|break;
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
name|wptr
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|int
operator|)
name|regs
index|[
name|ac
index|]
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|wptr
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|regs
index|[
name|ac
index|]
expr_stmt|;
name|wptr
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|*
name|wptr
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|wptr
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|regs
index|[
name|ac
index|]
expr_stmt|;
name|wptr
operator|--
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|wptr
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|regs
index|[
name|ac
index|]
expr_stmt|;
name|wptr
operator|--
expr_stmt|;
name|wptr
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|*
name|wptr
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|wptr
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
operator|(
name|regs
index|[
name|ac
index|]
operator|+
operator|*
name|pc
operator|)
operator|&
literal|0177776
operator|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
literal|7
condition|)
name|wptr
operator|++
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|wptr
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
operator|(
name|regs
index|[
name|ac
index|]
operator|+
operator|*
name|pc
operator|)
operator|&
literal|0177776
operator|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
literal|7
condition|)
name|wptr
operator|++
expr_stmt|;
name|wptr
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|*
name|wptr
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|wptr
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

