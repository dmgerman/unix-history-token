begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)support.c	5.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|"deck.h"
end_include

begin_include
include|#
directive|include
file|"cribbage.h"
end_include

begin_include
include|#
directive|include
file|"cribcur.h"
end_include

begin_define
define|#
directive|define
name|NTV
value|10
end_define

begin_comment
comment|/* number scores to test */
end_comment

begin_comment
comment|/* score to test reachability of, and order to test them in */
end_comment

begin_decl_stmt
name|int
name|tv
index|[
name|NTV
index|]
init|=
block|{
literal|8
block|,
literal|7
block|,
literal|9
block|,
literal|6
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|10
block|,
literal|5
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * computer chooses what to play in pegging...  * only called if no playable card will score points  */
end_comment

begin_macro
name|cchose
argument_list|(
argument|h
argument_list|,
argument|n
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|CARD
name|h
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|l
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|s
operator|<
literal|4
condition|)
block|{
comment|/* try for good value */
if|if
condition|(
operator|(
name|j
operator|=
name|anysumto
argument_list|(
name|h
argument_list|,
name|n
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|j
operator|)
return|;
if|if
condition|(
operator|(
name|j
operator|=
name|anysumto
argument_list|(
name|h
argument_list|,
name|n
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|s
operator|==
literal|0
condition|)
return|return
operator|(
name|j
operator|)
return|;
block|}
if|if
condition|(
name|s
operator|>
literal|0
operator|&&
name|s
operator|<
literal|20
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|10
condition|;
name|i
operator|++
control|)
block|{
comment|/* try for retaliation to 31 */
if|if
condition|(
operator|(
name|j
operator|=
name|anysumto
argument_list|(
name|h
argument_list|,
name|n
argument_list|,
name|s
argument_list|,
literal|21
operator|-
name|i
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|l
operator|=
name|numofval
argument_list|(
name|h
argument_list|,
name|n
argument_list|,
name|i
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|l
operator|>
literal|1
operator|||
name|VAL
argument_list|(
name|h
index|[
name|j
index|]
operator|.
name|rank
argument_list|)
operator|!=
name|i
condition|)
return|return
operator|(
name|j
operator|)
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|s
operator|<
literal|15
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTV
condition|;
name|i
operator|++
control|)
block|{
comment|/* for retaliation after 15 */
if|if
condition|(
operator|(
name|j
operator|=
name|anysumto
argument_list|(
name|h
argument_list|,
name|n
argument_list|,
name|s
argument_list|,
name|tv
index|[
name|i
index|]
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|l
operator|=
name|numofval
argument_list|(
name|h
argument_list|,
name|n
argument_list|,
literal|15
operator|-
name|tv
index|[
name|i
index|]
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|l
operator|>
literal|1
operator|||
name|VAL
argument_list|(
name|h
index|[
name|j
index|]
operator|.
name|rank
argument_list|)
operator|!=
literal|15
operator|-
name|tv
index|[
name|i
index|]
condition|)
return|return
operator|(
name|j
operator|)
return|;
block|}
block|}
block|}
block|}
name|j
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
comment|/* remember: h is sorted */
name|l
operator|=
name|s
operator|+
name|VAL
argument_list|(
name|h
index|[
name|i
index|]
operator|.
name|rank
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|31
condition|)
continue|continue;
if|if
condition|(
name|l
operator|!=
literal|5
operator|&&
name|l
operator|!=
literal|10
operator|&&
name|l
operator|!=
literal|21
condition|)
block|{
name|j
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
return|return
operator|(
name|j
operator|)
return|;
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|l
operator|=
name|s
operator|+
name|VAL
argument_list|(
name|h
index|[
name|i
index|]
operator|.
name|rank
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|31
condition|)
continue|continue;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|j
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|l
operator|!=
literal|5
operator|&&
name|l
operator|!=
literal|21
condition|)
block|{
name|j
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|j
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * plyrhand:  *	Evaluate and score a player hand or crib  */
end_comment

begin_macro
name|plyrhand
argument_list|(
argument|hand
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|CARD
name|hand
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|BOOLEAN
name|win
decl_stmt|;
specifier|static
name|char
name|prompt
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|prhand
argument_list|(
name|hand
argument_list|,
name|CINHAND
argument_list|,
name|Playwin
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|prompt
argument_list|,
literal|"Your %s scores "
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|i
operator|=
name|scorehand
argument_list|(
name|hand
argument_list|,
name|turnover
argument_list|,
name|CINHAND
argument_list|,
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"crib"
argument_list|)
operator|==
literal|0
argument_list|,
name|explain
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|number
argument_list|(
literal|0
argument_list|,
literal|29
argument_list|,
name|prompt
argument_list|)
operator|)
operator|==
literal|19
condition|)
name|j
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|j
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|j
condition|)
block|{
name|win
operator|=
name|chkscr
argument_list|(
operator|&
name|pscore
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|msg
argument_list|(
literal|"It's really only %d points; I get %d"
argument_list|,
name|i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
name|win
operator|=
name|chkscr
argument_list|(
operator|&
name|cscore
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|win
operator|=
name|chkscr
argument_list|(
operator|&
name|pscore
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|msg
argument_list|(
literal|"You should have taken %d, not %d!"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|explain
condition|)
name|msg
argument_list|(
literal|"Explanation: %s"
argument_list|,
name|expl
argument_list|)
expr_stmt|;
name|do_wait
argument_list|()
expr_stmt|;
block|}
else|else
name|win
operator|=
name|chkscr
argument_list|(
operator|&
name|pscore
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|win
return|;
block|}
end_block

begin_comment
comment|/*  * comphand:  *	Handle scoring and displaying the computers hand  */
end_comment

begin_macro
name|comphand
argument_list|(
argument|h
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|CARD
name|h
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|j
operator|=
name|scorehand
argument_list|(
name|h
argument_list|,
name|turnover
argument_list|,
name|CINHAND
argument_list|,
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"crib"
argument_list|)
operator|==
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|prhand
argument_list|(
name|h
argument_list|,
name|CINHAND
argument_list|,
name|Compwin
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|msg
argument_list|(
literal|"My %s scores %d"
argument_list|,
name|s
argument_list|,
operator|(
name|j
operator|==
literal|0
condition|?
literal|19
else|:
name|j
operator|)
argument_list|)
expr_stmt|;
return|return
name|chkscr
argument_list|(
operator|&
name|cscore
argument_list|,
name|j
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * chkscr:  *	Add inc to scr and test for> glimit, printing on the scoring  *	board while we're at it.  */
end_comment

begin_decl_stmt
name|int
name|Lastscore
index|[
literal|2
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|chkscr
argument_list|(
argument|scr
argument_list|,
argument|inc
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|scr
decl_stmt|,
name|inc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BOOLEAN
name|myturn
decl_stmt|;
name|myturn
operator|=
operator|(
name|scr
operator|==
operator|&
name|cscore
operator|)
expr_stmt|;
if|if
condition|(
name|inc
operator|!=
literal|0
condition|)
block|{
name|prpeg
argument_list|(
name|Lastscore
index|[
name|myturn
index|]
argument_list|,
literal|'.'
argument_list|,
name|myturn
argument_list|)
expr_stmt|;
name|Lastscore
index|[
name|myturn
index|]
operator|=
operator|*
name|scr
expr_stmt|;
operator|*
name|scr
operator|+=
name|inc
expr_stmt|;
name|prpeg
argument_list|(
operator|*
name|scr
argument_list|,
name|PEG
argument_list|,
name|myturn
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|scr
operator|>=
name|glimit
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * prpeg:  *	Put out the peg character on the score board and put the  *	score up on the board.  */
end_comment

begin_expr_stmt
name|prpeg
argument_list|(
name|score
argument_list|,
name|peg
argument_list|,
name|myturn
argument_list|)
specifier|register
name|int
name|score
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|peg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BOOLEAN
name|myturn
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|myturn
condition|)
name|y
operator|=
name|SCORE_Y
operator|+
literal|2
expr_stmt|;
else|else
name|y
operator|=
name|SCORE_Y
operator|+
literal|5
expr_stmt|;
if|if
condition|(
name|score
operator|<=
literal|0
operator|||
name|score
operator|>=
name|glimit
condition|)
block|{
if|if
condition|(
name|peg
operator|==
literal|'.'
condition|)
name|peg
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|score
operator|==
literal|0
condition|)
name|x
operator|=
name|SCORE_X
operator|+
literal|2
expr_stmt|;
else|else
block|{
name|x
operator|=
name|SCORE_X
operator|+
literal|2
expr_stmt|;
name|y
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|x
operator|=
operator|(
name|score
operator|-
literal|1
operator|)
operator|%
literal|30
expr_stmt|;
if|if
condition|(
name|score
operator|>
literal|90
operator|||
operator|(
name|score
operator|>
literal|30
operator|&&
name|score
operator|<=
literal|60
operator|)
condition|)
block|{
name|y
operator|++
expr_stmt|;
name|x
operator|=
literal|29
operator|-
name|x
expr_stmt|;
block|}
name|x
operator|+=
name|x
operator|/
literal|5
expr_stmt|;
name|x
operator|+=
name|SCORE_X
operator|+
literal|3
expr_stmt|;
block|}
name|mvaddch
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
name|peg
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
name|SCORE_Y
operator|+
operator|(
name|myturn
condition|?
literal|7
else|:
literal|1
operator|)
argument_list|,
name|SCORE_X
operator|+
literal|10
argument_list|,
literal|"%3d"
argument_list|,
name|score
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * cdiscard -- the computer figures out what is the best discard for  * the crib and puts the best two cards at the end  */
end_comment

begin_macro
name|cdiscard
argument_list|(
argument|mycrib
argument_list|)
end_macro

begin_decl_stmt
name|BOOLEAN
name|mycrib
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|CARD
name|d
index|[
name|CARDS
index|]
decl_stmt|,
name|h
index|[
name|FULLHAND
index|]
decl_stmt|,
name|cb
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|nc
decl_stmt|,
name|ns
decl_stmt|;
name|long
name|sums
index|[
literal|15
index|]
decl_stmt|;
specifier|static
name|int
name|undo1
index|[
literal|15
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|}
decl_stmt|;
specifier|static
name|int
name|undo2
index|[
literal|15
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|}
decl_stmt|;
name|makedeck
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|nc
operator|=
name|CARDS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|knownum
condition|;
name|i
operator|++
control|)
block|{
comment|/* get all other cards */
name|remove
argument_list|(
name|known
index|[
name|i
index|]
argument_list|,
name|d
argument_list|,
name|nc
operator|--
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
name|sums
index|[
name|i
index|]
operator|=
literal|0L
expr_stmt|;
name|ns
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|FULLHAND
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|cb
index|[
literal|0
index|]
operator|=
name|chand
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|FULLHAND
condition|;
name|j
operator|++
control|)
block|{
name|cb
index|[
literal|1
index|]
operator|=
name|chand
index|[
name|j
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|FULLHAND
condition|;
name|k
operator|++
control|)
name|h
index|[
name|k
index|]
operator|=
name|chand
index|[
name|k
index|]
expr_stmt|;
name|remove
argument_list|(
name|chand
index|[
name|i
index|]
argument_list|,
name|h
argument_list|,
name|FULLHAND
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|chand
index|[
name|j
index|]
argument_list|,
name|h
argument_list|,
name|FULLHAND
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nc
condition|;
name|k
operator|++
control|)
block|{
name|sums
index|[
name|ns
index|]
operator|+=
name|scorehand
argument_list|(
name|h
argument_list|,
name|d
index|[
name|k
index|]
argument_list|,
name|CINHAND
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mycrib
condition|)
name|sums
index|[
name|ns
index|]
operator|+=
name|adjust
argument_list|(
name|cb
argument_list|,
name|d
index|[
name|k
index|]
argument_list|)
expr_stmt|;
else|else
name|sums
index|[
name|ns
index|]
operator|-=
name|adjust
argument_list|(
name|cb
argument_list|,
name|d
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
operator|++
name|ns
expr_stmt|;
block|}
block|}
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sums
index|[
name|i
index|]
operator|>
name|sums
index|[
name|j
index|]
condition|)
name|j
operator|=
name|i
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|FULLHAND
condition|;
name|k
operator|++
control|)
name|h
index|[
name|k
index|]
operator|=
name|chand
index|[
name|k
index|]
expr_stmt|;
name|remove
argument_list|(
name|h
index|[
name|undo1
index|[
name|j
index|]
index|]
argument_list|,
name|chand
argument_list|,
name|FULLHAND
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|h
index|[
name|undo2
index|[
name|j
index|]
index|]
argument_list|,
name|chand
argument_list|,
name|FULLHAND
operator|-
literal|1
argument_list|)
expr_stmt|;
name|chand
index|[
literal|4
index|]
operator|=
name|h
index|[
name|undo1
index|[
name|j
index|]
index|]
expr_stmt|;
name|chand
index|[
literal|5
index|]
operator|=
name|h
index|[
name|undo2
index|[
name|j
index|]
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * returns true if some card in hand can be played without exceeding 31  */
end_comment

begin_macro
name|anymove
argument_list|(
argument|hand
argument_list|,
argument|n
argument_list|,
argument|sum
argument_list|)
end_macro

begin_decl_stmt
name|CARD
name|hand
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sum
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|j
operator|=
name|hand
index|[
literal|0
index|]
operator|.
name|rank
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hand
index|[
name|i
index|]
operator|.
name|rank
operator|<
name|j
condition|)
name|j
operator|=
name|hand
index|[
name|i
index|]
operator|.
name|rank
expr_stmt|;
block|}
return|return
operator|(
name|sum
operator|+
name|VAL
argument_list|(
name|j
argument_list|)
operator|<=
literal|31
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * anysumto returns the index (0<= i< n) of the card in hand that brings  * the s up to t, or -1 if there is none  */
end_comment

begin_macro
name|anysumto
argument_list|(
argument|hand
argument_list|,
argument|n
argument_list|,
argument|s
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|CARD
name|hand
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|s
decl_stmt|,
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|+
name|VAL
argument_list|(
name|hand
index|[
name|i
index|]
operator|.
name|rank
argument_list|)
operator|==
name|t
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * return the number of cards in h having the given rank value  */
end_comment

begin_macro
name|numofval
argument_list|(
argument|h
argument_list|,
argument|n
argument_list|,
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|CARD
name|h
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|VAL
argument_list|(
name|h
index|[
name|i
index|]
operator|.
name|rank
argument_list|)
operator|==
name|v
condition|)
operator|++
name|j
expr_stmt|;
block|}
return|return
operator|(
name|j
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * makeknown remembers all n cards in h for future recall  */
end_comment

begin_macro
name|makeknown
argument_list|(
argument|h
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|CARD
name|h
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|known
index|[
name|knownum
operator|++
index|]
operator|=
name|h
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_block

end_unit

