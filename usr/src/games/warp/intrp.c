begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: /usr/src/games/warp/RCS/intrp.c,v 1.2 87/07/03 00:56:37 games Exp $  *  * Revision 7.0.1.2  86/12/12  16:59:04  lwall  * Baseline for net release.  *   * Revision 7.0.1.1  86/10/16  10:51:43  lwall  * Added Damage.  Fixed random bugs.  *   * Revision 7.0  86/10/08  15:12:19  lwall  * Split into separate files.  Added amoebas and pirates.  *   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"warp.h"
end_include

begin_include
include|#
directive|include
file|"sig.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_comment
comment|/* name of this host */
end_comment

begin_decl_stmt
name|char
modifier|*
name|hostname
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TILDENAME
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tildename
init|=
name|Nullch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tildedir
init|=
name|Nullch
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|char
modifier|*
name|dointerp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getrealname
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|CONDSUB
end_ifdef

begin_function_decl
name|char
modifier|*
name|skipinterp
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|abort_interp
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|intrp_init
parameter_list|(
name|tcbuf
parameter_list|)
name|char
modifier|*
name|tcbuf
decl_stmt|;
block|{
name|char
modifier|*
name|getlogin
parameter_list|()
function_decl|;
comment|/* get environmental stuff */
comment|/* get home directory */
name|homedir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|homedir
operator|==
name|Nullch
condition|)
name|homedir
operator|=
name|getenv
argument_list|(
literal|"LOGDIR"
argument_list|)
expr_stmt|;
name|dotdir
operator|=
name|getval
argument_list|(
literal|"DOTDIR"
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
comment|/* get login name */
name|logname
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|logname
operator|==
name|Nullch
condition|)
name|logname
operator|=
name|getenv
argument_list|(
literal|"LOGNAME"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GETLOGIN
if|if
condition|(
name|logname
operator|==
name|Nullch
condition|)
name|logname
operator|=
name|savestr
argument_list|(
name|getlogin
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* get the real name of the person (%N) */
comment|/* Must be done after logname is read in because BERKNAMES uses that */
name|strcpy
argument_list|(
name|tcbuf
argument_list|,
name|getrealname
argument_list|(
name|getuid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|realname
operator|=
name|savestr
argument_list|(
name|tcbuf
argument_list|)
expr_stmt|;
comment|/* name of this host (%H) */
name|gethostname
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|hostname
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|hostname
argument_list|,
literal|'.'
argument_list|)
condition|)
name|hostname
operator|=
name|savestr
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|hname
index|[
literal|128
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|hname
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|hname
argument_list|,
name|MYDOMAIN
argument_list|)
expr_stmt|;
name|hostname
operator|=
name|savestr
argument_list|(
name|hname
argument_list|)
expr_stmt|;
block|}
name|warplib
operator|=
name|savestr
argument_list|(
name|filexp
argument_list|(
name|WARPLIB
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scorespec
condition|)
comment|/* that getwd below takes ~1/3 sec. */
return|return;
comment|/* and we do not need it for -s */
operator|(
name|void
operator|)
name|getwd
argument_list|(
name|tcbuf
argument_list|)
expr_stmt|;
comment|/* find working directory name */
name|origdir
operator|=
name|savestr
argument_list|(
name|tcbuf
argument_list|)
expr_stmt|;
comment|/* and remember it */
block|}
end_function

begin_comment
comment|/* expand filename via %, ~, and $ interpretation */
end_comment

begin_comment
comment|/* returns pointer to static area */
end_comment

begin_comment
comment|/* Note that there is a 1-deep cache of ~name interpretation */
end_comment

begin_function
name|char
modifier|*
name|filexp
parameter_list|(
name|s
parameter_list|)
name|Reg1
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|static
name|char
name|filename
index|[
name|CBUFLEN
index|]
decl_stmt|;
name|char
name|scrbuf
index|[
name|CBUFLEN
index|]
decl_stmt|;
name|Reg2
name|char
modifier|*
name|d
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_FILEXP
condition|)
name|printf
argument_list|(
literal|"< %s\r\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|interp
argument_list|(
name|filename
argument_list|,
operator|(
sizeof|sizeof
name|filename
operator|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* interpret any % escapes */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_FILEXP
condition|)
name|printf
argument_list|(
literal|"%% %s\r\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|filename
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'~'
condition|)
block|{
comment|/* does destination start with ~? */
if|if
condition|(
operator|!
operator|*
operator|(
operator|++
name|s
operator|)
operator|||
operator|*
name|s
operator|==
literal|'/'
condition|)
block|{
name|Sprintf
argument_list|(
name|scrbuf
argument_list|,
literal|"%s%s"
argument_list|,
name|homedir
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* swap $HOME for it */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_FILEXP
condition|)
name|printf
argument_list|(
literal|"~ %s\r\n"
argument_list|,
name|scrbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|filename
argument_list|,
name|scrbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|TILDENAME
for|for
control|(
name|d
operator|=
name|scrbuf
init|;
name|isalnum
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
operator|,
name|d
operator|++
control|)
operator|*
name|d
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tildedir
operator|&&
name|strEQ
argument_list|(
name|tildename
argument_list|,
name|scrbuf
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|scrbuf
argument_list|,
name|tildedir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|scrbuf
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|scrbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_FILEXP
condition|)
name|printf
argument_list|(
literal|"r %s %s\r\n"
argument_list|,
name|tildename
argument_list|,
name|tildedir
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|tildename
condition|)
block|{
name|free
argument_list|(
name|tildename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tildedir
argument_list|)
expr_stmt|;
block|}
name|tildedir
operator|=
name|Nullch
expr_stmt|;
name|tildename
operator|=
name|savestr
argument_list|(
name|scrbuf
argument_list|)
expr_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
name|struct
name|passwd
modifier|*
name|pwd
init|=
name|getpwnam
argument_list|(
name|tildename
argument_list|)
decl_stmt|;
name|Sprintf
argument_list|(
name|scrbuf
argument_list|,
literal|"%s%s"
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|tildedir
operator|=
name|savestr
argument_list|(
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|scrbuf
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* !TILDENAME */
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"~loginname not implemented.\r\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"~login not impl.\r\n"
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
condition|)
block|{
comment|/* starts with some env variable? */
name|d
operator|=
name|scrbuf
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'%'
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'{'
condition|)
name|strcpy
argument_list|(
name|d
argument_list|,
name|s
operator|+
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|d
operator|++
operator|=
literal|'{'
expr_stmt|;
for|for
control|(
name|s
operator|++
init|;
name|isalnum
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
expr_stmt|;
comment|/* skip over token */
operator|*
name|d
operator|++
operator|=
literal|'}'
expr_stmt|;
name|strcpy
argument_list|(
name|d
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_FILEXP
condition|)
name|printf
argument_list|(
literal|"$ %s\r\n"
argument_list|,
name|scrbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|interp
argument_list|(
name|filename
argument_list|,
operator|(
sizeof|sizeof
name|filename
operator|)
argument_list|,
name|scrbuf
argument_list|)
expr_stmt|;
comment|/* this might do some extra '%'s but */
comment|/* that is how the Mercedes Benz */
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_FILEXP
condition|)
name|printf
argument_list|(
literal|"> %s\r\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|filename
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONDSUB
end_ifdef

begin_comment
comment|/* skip interpolations */
end_comment

begin_function
name|char
modifier|*
name|skipinterp
parameter_list|(
name|pattern
parameter_list|,
name|stoppers
parameter_list|)
name|Reg1
name|char
modifier|*
name|pattern
decl_stmt|;
name|char
modifier|*
name|stoppers
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|pattern
operator|&&
operator|(
operator|!
name|stoppers
operator|||
operator|!
name|index
argument_list|(
name|stoppers
argument_list|,
operator|*
name|pattern
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
name|printf
argument_list|(
literal|"skipinterp till %s at %s\r\n"
argument_list|,
name|stoppers
condition|?
name|stoppers
else|:
literal|""
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'%'
operator|&&
name|pattern
index|[
literal|1
index|]
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|pattern
condition|)
block|{
case|case
literal|'{'
case|:
for|for
control|(
name|pattern
operator|++
init|;
operator|*
name|pattern
operator|&&
operator|*
name|pattern
operator|!=
literal|'}'
condition|;
name|pattern
operator|++
control|)
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'\\'
condition|)
name|pattern
operator|++
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|CONDSUB
case|case
literal|'('
case|:
block|{
name|pattern
operator|=
name|skipinterp
argument_list|(
name|pattern
operator|+
literal|1
argument_list|,
literal|"!="
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pattern
condition|)
goto|goto
name|getout
goto|;
for|for
control|(
name|pattern
operator|++
init|;
operator|*
name|pattern
operator|&&
operator|*
name|pattern
operator|!=
literal|'?'
condition|;
name|pattern
operator|++
control|)
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'\\'
condition|)
name|pattern
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pattern
condition|)
goto|goto
name|getout
goto|;
name|pattern
operator|=
name|skipinterp
argument_list|(
name|pattern
operator|+
literal|1
argument_list|,
literal|":)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pattern
operator|==
literal|':'
condition|)
name|pattern
operator|=
name|skipinterp
argument_list|(
name|pattern
operator|+
literal|1
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BACKTICK
case|case
literal|'`'
case|:
block|{
name|pattern
operator|=
name|skipinterp
argument_list|(
name|pattern
operator|+
literal|1
argument_list|,
literal|"`"
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PROMPTTTY
case|case
literal|'"'
case|:
name|pattern
operator|=
name|skipinterp
argument_list|(
name|pattern
operator|+
literal|1
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
name|pattern
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'^'
operator|&&
name|pattern
index|[
literal|1
index|]
condition|)
name|pattern
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'\\'
operator|&&
name|pattern
index|[
literal|1
index|]
condition|)
name|pattern
operator|+=
literal|2
expr_stmt|;
else|else
name|pattern
operator|++
expr_stmt|;
block|}
block|}
name|getout
label|:
return|return
name|pattern
return|;
comment|/* where we left off */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* interpret interpolations */
end_comment

begin_function
name|char
modifier|*
name|dointerp
parameter_list|(
name|dest
parameter_list|,
name|destsize
parameter_list|,
name|pattern
parameter_list|,
name|stoppers
parameter_list|)
name|Reg1
name|char
modifier|*
name|dest
decl_stmt|;
name|Reg2
name|int
name|destsize
decl_stmt|;
name|Reg3
name|char
modifier|*
name|pattern
decl_stmt|;
name|char
modifier|*
name|stoppers
decl_stmt|;
block|{
name|Reg4
name|char
modifier|*
name|s
decl_stmt|;
name|Reg5
name|int
name|i
decl_stmt|;
name|char
name|scrbuf
index|[
literal|512
index|]
decl_stmt|;
name|bool
name|upper
init|=
name|FALSE
decl_stmt|;
name|bool
name|lastcomp
init|=
name|FALSE
decl_stmt|;
name|int
name|metabit
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|pattern
operator|&&
operator|(
operator|!
name|stoppers
operator|||
operator|!
name|index
argument_list|(
name|stoppers
argument_list|,
operator|*
name|pattern
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
name|printf
argument_list|(
literal|"dointerp till %s at %s\r\n"
argument_list|,
name|stoppers
condition|?
name|stoppers
else|:
literal|""
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'%'
operator|&&
name|pattern
index|[
literal|1
index|]
condition|)
block|{
name|upper
operator|=
name|FALSE
expr_stmt|;
name|lastcomp
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|Nullch
init|;
operator|!
name|s
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|pattern
condition|)
block|{
case|case
literal|'^'
case|:
name|upper
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
name|lastcomp
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|pattern
operator|=
name|cpytill
argument_list|(
name|scrbuf
argument_list|,
name|pattern
operator|+
literal|1
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|=
name|index
argument_list|(
name|scrbuf
argument_list|,
literal|'-'
argument_list|)
condition|)
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
else|else
name|s
operator|=
name|nullstr
expr_stmt|;
name|s
operator|=
name|getval
argument_list|(
name|scrbuf
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|CONDSUB
case|case
literal|'('
case|:
block|{
name|char
name|rch
decl_stmt|;
name|bool
name|matched
decl_stmt|;
name|pattern
operator|=
name|dointerp
argument_list|(
name|dest
argument_list|,
name|destsize
argument_list|,
name|pattern
operator|+
literal|1
argument_list|,
literal|"!="
argument_list|)
expr_stmt|;
name|rch
operator|=
operator|*
name|pattern
expr_stmt|;
if|if
condition|(
name|rch
operator|==
literal|'!'
condition|)
name|pattern
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pattern
operator|!=
literal|'='
condition|)
goto|goto
name|getout
goto|;
name|pattern
operator|=
name|cpytill
argument_list|(
name|scrbuf
argument_list|,
name|pattern
operator|+
literal|1
argument_list|,
literal|'?'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pattern
condition|)
goto|goto
name|getout
goto|;
if|if
condition|(
operator|*
name|scrbuf
operator|==
literal|'^'
operator|&&
name|scrbuf
index|[
name|strlen
argument_list|(
name|scrbuf
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'$'
condition|)
block|{
name|scrbuf
index|[
name|strlen
argument_list|(
name|scrbuf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|matched
operator|=
name|strEQ
argument_list|(
name|scrbuf
operator|+
literal|1
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
else|else
name|matched
operator|=
name|instr
argument_list|(
name|dest
argument_list|,
name|scrbuf
argument_list|)
operator|!=
name|Nullch
expr_stmt|;
if|if
condition|(
name|matched
operator|==
operator|(
name|rch
operator|==
literal|'='
operator|)
condition|)
block|{
name|pattern
operator|=
name|dointerp
argument_list|(
name|dest
argument_list|,
name|destsize
argument_list|,
name|pattern
operator|+
literal|1
argument_list|,
literal|":)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pattern
operator|==
literal|':'
condition|)
name|pattern
operator|=
name|skipinterp
argument_list|(
name|pattern
operator|+
literal|1
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pattern
operator|=
name|skipinterp
argument_list|(
name|pattern
operator|+
literal|1
argument_list|,
literal|":)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pattern
operator|==
literal|':'
condition|)
name|pattern
operator|++
expr_stmt|;
name|pattern
operator|=
name|dointerp
argument_list|(
name|dest
argument_list|,
name|destsize
argument_list|,
name|pattern
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|dest
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BACKTICK
case|case
literal|'`'
case|:
block|{
name|FILE
modifier|*
name|pipefp
decl_stmt|,
modifier|*
name|popen
argument_list|()
decl_stmt|;
name|pattern
operator|=
name|dointerp
argument_list|(
name|scrbuf
argument_list|,
operator|(
sizeof|sizeof
name|scrbuf
operator|)
argument_list|,
name|pattern
operator|+
literal|1
argument_list|,
literal|"`"
argument_list|)
expr_stmt|;
name|pipefp
operator|=
name|popen
argument_list|(
name|scrbuf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipefp
operator|!=
name|Nullfp
condition|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|fread
argument_list|(
name|scrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
operator|(
sizeof|sizeof
name|scrbuf
operator|)
operator|-
literal|1
argument_list|,
name|pipefp
argument_list|)
expr_stmt|;
name|scrbuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pclose
argument_list|(
name|pipefp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\r\nCan't run %s\r\n"
argument_list|,
name|scrbuf
argument_list|)
expr_stmt|;
operator|*
name|scrbuf
operator|=
literal|'\0'
expr_stmt|;
block|}
for|for
control|(
name|s
operator|=
name|scrbuf
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
condition|)
operator|*
name|s
operator|=
literal|' '
expr_stmt|;
else|else
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|s
operator|=
name|scrbuf
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PROMPTTTY
case|case
literal|'"'
case|:
name|pattern
operator|=
name|dointerp
argument_list|(
name|scrbuf
argument_list|,
operator|(
sizeof|sizeof
name|scrbuf
operator|)
argument_list|,
name|pattern
operator|+
literal|1
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|scrbuf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|resetty
argument_list|()
expr_stmt|;
name|gets
argument_list|(
name|scrbuf
argument_list|)
expr_stmt|;
name|crmode
argument_list|()
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|nonl
argument_list|()
expr_stmt|;
name|s
operator|=
name|scrbuf
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'~'
case|:
name|s
operator|=
name|homedir
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|s
operator|=
name|dotdir
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|s
operator|=
name|scrbuf
expr_stmt|;
name|Sprintf
argument_list|(
name|s
argument_list|,
literal|"%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* host name */
name|s
operator|=
name|hostname
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* login id */
name|s
operator|=
name|logname
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* full name */
name|s
operator|=
name|getval
argument_list|(
literal|"NAME"
argument_list|,
name|realname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|s
operator|=
name|origdir
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|s
operator|=
name|cwd
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* warp library */
name|s
operator|=
name|warplib
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|--
name|destsize
operator|<=
literal|0
condition|)
name|abort_interp
argument_list|()
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|pattern
operator||
name|metabit
expr_stmt|;
name|s
operator|=
name|nullstr
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|s
condition|)
name|s
operator|=
name|nullstr
expr_stmt|;
name|pattern
operator|++
expr_stmt|;
if|if
condition|(
name|upper
operator|||
name|lastcomp
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|scrbuf
condition|)
block|{
name|Safecpy
argument_list|(
name|scrbuf
argument_list|,
name|s
argument_list|,
operator|(
sizeof|sizeof
name|scrbuf
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|scrbuf
expr_stmt|;
block|}
if|if
condition|(
name|upper
operator|||
operator|!
operator|(
name|t
operator|=
name|rindex
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
name|t
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|&&
operator|!
name|isalpha
argument_list|(
operator|*
name|t
argument_list|)
condition|)
name|t
operator|++
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
operator|*
name|t
argument_list|)
condition|)
operator|*
name|t
operator|=
name|toupper
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|metabit
expr_stmt|;
comment|/* maybe get into register */
if|if
condition|(
name|s
operator|==
name|dest
condition|)
block|{
while|while
condition|(
operator|*
name|dest
condition|)
block|{
if|if
condition|(
operator|--
name|destsize
operator|<=
literal|0
condition|)
name|abort_interp
argument_list|()
expr_stmt|;
operator|*
name|dest
operator|++
operator||=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|--
name|destsize
operator|<=
literal|0
condition|)
name|abort_interp
argument_list|()
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|s
operator|++
operator||
name|i
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|--
name|destsize
operator|<=
literal|0
condition|)
name|abort_interp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'^'
operator|&&
name|pattern
index|[
literal|1
index|]
condition|)
block|{
operator|++
name|pattern
expr_stmt|;
comment|/* skip uparrow */
name|i
operator|=
operator|*
name|pattern
expr_stmt|;
comment|/* get char into a register */
if|if
condition|(
name|i
operator|==
literal|'?'
condition|)
operator|*
name|dest
operator|++
operator|=
literal|'\177'
operator||
name|metabit
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|'('
condition|)
block|{
name|metabit
operator|=
literal|0200
expr_stmt|;
name|destsize
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|')'
condition|)
block|{
name|metabit
operator|=
literal|0
expr_stmt|;
name|destsize
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|dest
operator|++
operator|=
name|i
operator|&
literal|037
operator||
name|metabit
expr_stmt|;
name|pattern
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'\\'
operator|&&
name|pattern
index|[
literal|1
index|]
condition|)
block|{
operator|++
name|pattern
expr_stmt|;
comment|/* skip backslash */
name|i
operator|=
operator|*
name|pattern
expr_stmt|;
comment|/* get char into a register */
comment|/* this used to be a switch but the if may save space */
if|if
condition|(
name|i
operator|>=
literal|'0'
operator|&&
name|i
operator|<=
literal|'7'
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|01000
operator|&&
operator|*
name|pattern
operator|>=
literal|'0'
operator|&&
operator|*
name|pattern
operator|<=
literal|'7'
condition|)
block|{
name|i
operator|<<=
literal|3
expr_stmt|;
name|i
operator|+=
operator|*
name|pattern
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
operator|*
name|dest
operator|++
operator|=
name|i
operator|&
literal|0377
operator||
name|metabit
expr_stmt|;
operator|--
name|pattern
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|'b'
condition|)
operator|*
name|dest
operator|++
operator|=
literal|'\b'
operator||
name|metabit
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|'f'
condition|)
operator|*
name|dest
operator|++
operator|=
literal|'\f'
operator||
name|metabit
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|'n'
condition|)
operator|*
name|dest
operator|++
operator|=
literal|'\n'
operator||
name|metabit
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|'r'
condition|)
operator|*
name|dest
operator|++
operator|=
literal|'\r'
operator||
name|metabit
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|'t'
condition|)
operator|*
name|dest
operator|++
operator|=
literal|'\t'
operator||
name|metabit
expr_stmt|;
else|else
operator|*
name|dest
operator|++
operator|=
name|i
operator||
name|metabit
expr_stmt|;
name|pattern
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|dest
operator|++
operator|=
operator|*
name|pattern
operator|++
operator||
name|metabit
expr_stmt|;
block|}
block|}
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
name|getout
label|:
return|return
name|pattern
return|;
comment|/* where we left off */
block|}
end_function

begin_function
name|void
name|interp
parameter_list|(
name|dest
parameter_list|,
name|destsize
parameter_list|,
name|pattern
parameter_list|)
name|char
modifier|*
name|dest
decl_stmt|;
name|int
name|destsize
decl_stmt|;
name|char
modifier|*
name|pattern
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|dointerp
argument_list|(
name|dest
argument_list|,
name|destsize
argument_list|,
name|pattern
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_FILEXP
condition|)
name|fputs
argument_list|(
name|dest
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* get the person's real name from /etc/passwd */
end_comment

begin_comment
comment|/* (string is overwritten, so it must be copied) */
end_comment

begin_function
name|char
modifier|*
name|getrealname
parameter_list|(
name|uid
parameter_list|)
name|int
name|uid
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|PASSNAMES
name|struct
name|passwd
modifier|*
name|pwd
init|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
decl_stmt|;
name|s
operator|=
name|pwd
operator|->
name|pw_gecos
expr_stmt|;
ifdef|#
directive|ifdef
name|BERKNAMES
ifdef|#
directive|ifdef
name|BERKJUNK
while|while
condition|(
operator|*
name|s
operator|&&
operator|!
name|isalnum
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
operator|!=
literal|'&'
condition|)
name|s
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|c
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
operator|*
name|c
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|';'
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
operator|*
name|c
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|cpytill
argument_list|(
name|buf
argument_list|,
name|s
argument_list|,
literal|'&'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'&'
condition|)
block|{
comment|/* whoever thought this one up was */
name|c
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* in the middle of the night */
name|strcat
argument_list|(
name|c
argument_list|,
name|logname
argument_list|)
expr_stmt|;
comment|/* before the morning after */
name|strcat
argument_list|(
name|c
argument_list|,
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
operator|*
name|c
argument_list|)
condition|)
operator|*
name|c
operator|=
name|toupper
argument_list|(
operator|*
name|c
argument_list|)
expr_stmt|;
comment|/* gack and double gack */
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|c
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|'('
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
operator|*
name|c
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
name|s
operator|=
name|c
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|endpwent
argument_list|()
expr_stmt|;
return|return
name|buf
return|;
comment|/* return something static */
else|#
directive|else
if|if
condition|(
operator|(
name|tmpfp
operator|=
name|fopen
argument_list|(
name|filexp
argument_list|(
name|FULLNAMEFILE
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|Nullfp
condition|)
block|{
name|Fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|tmpfp
argument_list|)
expr_stmt|;
name|Fclose
argument_list|(
name|tmpfp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|resetty
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"What is your name? "
argument_list|)
expr_stmt|;
name|Fgets
argument_list|(
name|buf
argument_list|,
operator|(
sizeof|sizeof
name|buf
operator|)
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|crmode
argument_list|()
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|nonl
argument_list|()
expr_stmt|;
if|if
condition|(
name|fork
argument_list|()
condition|)
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpfp
operator|=
name|fopen
argument_list|(
name|filexp
argument_list|(
name|FULLNAMEFILE
argument_list|)
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tmpfp
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|Fclose
argument_list|(
name|tmpfp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|abort_interp
parameter_list|()
block|{
name|fputs
argument_list|(
literal|"\r\n% interp buffer overflow!\r\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|sig_catcher
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

