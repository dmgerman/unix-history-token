begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Dave Taylor, of Intuitive Systems.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1989, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)wump.c	8.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * A very new version of the age old favorite Hunt-The-Wumpus game that has  * been a part of the BSD distribution of Unix for longer than us old folk  * would care to remember.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_comment
comment|/* some defines to spec out what our wumpus cave should look like */
end_comment

begin_define
define|#
directive|define
name|MAX_ARROW_SHOT_DISTANCE
value|6
end_define

begin_comment
comment|/* +1 for '0' stopper */
end_comment

begin_define
define|#
directive|define
name|MAX_LINKS_IN_ROOM
value|25
end_define

begin_comment
comment|/* a complex cave */
end_comment

begin_define
define|#
directive|define
name|MAX_ROOMS_IN_CAVE
value|250
end_define

begin_define
define|#
directive|define
name|ROOMS_IN_CAVE
value|20
end_define

begin_define
define|#
directive|define
name|MIN_ROOMS_IN_CAVE
value|10
end_define

begin_define
define|#
directive|define
name|LINKS_IN_ROOM
value|3
end_define

begin_define
define|#
directive|define
name|NUMBER_OF_ARROWS
value|5
end_define

begin_define
define|#
directive|define
name|PIT_COUNT
value|3
end_define

begin_define
define|#
directive|define
name|BAT_COUNT
value|3
end_define

begin_define
define|#
directive|define
name|EASY
value|1
end_define

begin_comment
comment|/* levels of play */
end_comment

begin_define
define|#
directive|define
name|HARD
value|2
end_define

begin_comment
comment|/* some macro definitions for cleaner output */
end_comment

begin_define
define|#
directive|define
name|plural
parameter_list|(
name|n
parameter_list|)
value|(n == 1 ? "" : "s")
end_define

begin_comment
comment|/* simple cave data structure; +1 so we can index from '1' not '0' */
end_comment

begin_struct
struct|struct
name|room_record
block|{
name|int
name|tunnel
index|[
name|MAX_LINKS_IN_ROOM
index|]
decl_stmt|;
name|int
name|has_a_pit
decl_stmt|,
name|has_a_bat
decl_stmt|;
block|}
name|cave
index|[
name|MAX_ROOMS_IN_CAVE
operator|+
literal|1
index|]
struct|;
end_struct

begin_comment
comment|/*  * global variables so we can keep track of where the player is, how  * many arrows they still have, where el wumpo is, and so on...  */
end_comment

begin_decl_stmt
name|int
name|player_loc
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* player location */
end_comment

begin_decl_stmt
name|int
name|wumpus_loc
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The Bad Guy location */
end_comment

begin_decl_stmt
name|int
name|level
init|=
name|EASY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* level of play */
end_comment

begin_decl_stmt
name|int
name|arrows_left
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* arrows unshot */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|pit_num
init|=
name|PIT_COUNT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # pits in cave */
end_comment

begin_decl_stmt
name|int
name|bat_num
init|=
name|BAT_COUNT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # bats */
end_comment

begin_decl_stmt
name|int
name|room_num
init|=
name|ROOMS_IN_CAVE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # rooms in cave */
end_comment

begin_decl_stmt
name|int
name|link_num
init|=
name|LINKS_IN_ROOM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* links per room  */
end_comment

begin_decl_stmt
name|int
name|arrow_num
init|=
name|NUMBER_OF_ARROWS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* arrow inventory */
end_comment

begin_decl_stmt
name|char
name|answer
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user input */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:b:hp:r:t:d"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
else|#
directive|else
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:b:hp:r:t:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
endif|#
directive|endif
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|arrow_num
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|bat_num
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'d'
case|:
name|debug
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'h'
case|:
name|level
operator|=
name|HARD
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|pit_num
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|room_num
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|room_num
operator|<
name|MIN_ROOMS_IN_CAVE
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No self-respecting wumpus would live in such a small cave!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|room_num
operator|>
name|MAX_ROOMS_IN_CAVE
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Even wumpii can't furnish caves that large!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|link_num
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_num
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Wumpii like extra doors in their caves!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|link_num
operator|>
name|MAX_LINKS_IN_ROOM
operator|||
name|link_num
operator|>
name|room_num
operator|-
operator|(
name|room_num
operator|/
literal|4
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many tunnels!  The cave collapsed!\n(Fortunately, the wumpus escaped!)\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|level
operator|==
name|HARD
condition|)
block|{
name|bat_num
operator|+=
operator|(
operator|(
name|random
argument_list|()
operator|%
operator|(
name|room_num
operator|/
literal|2
operator|)
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|pit_num
operator|+=
operator|(
operator|(
name|random
argument_list|()
operator|%
operator|(
name|room_num
operator|/
literal|2
operator|)
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|bat_num
operator|>
name|room_num
operator|/
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The wumpus refused to enter the cave, claiming it was too crowded!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pit_num
operator|>
name|room_num
operator|/
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The wumpus refused to enter the cave, claiming it was too dangerous!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|instructions
argument_list|()
expr_stmt|;
name|cave_init
argument_list|()
expr_stmt|;
comment|/* and we're OFF!  da dum, da dum, da dum, da dum... */
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\nYou're in a cave with %d rooms and %d tunnels leading from each room.\n\ There are %d bat%s and %d pit%s scattered throughout the cave, and your\n\ quiver holds %d custom super anti-evil Wumpus arrows.  Good luck.\n"
argument_list|,
name|room_num
argument_list|,
name|link_num
argument_list|,
name|bat_num
argument_list|,
name|plural
argument_list|(
name|bat_num
argument_list|)
argument_list|,
name|pit_num
argument_list|,
name|plural
argument_list|(
name|pit_num
argument_list|)
argument_list|,
name|arrow_num
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|initialize_things_in_cave
argument_list|()
expr_stmt|;
name|arrows_left
operator|=
name|arrow_num
expr_stmt|;
do|do
block|{
name|display_room_stats
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Move or shoot? (m-s) "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|answer
argument_list|,
sizeof|sizeof
argument_list|(
name|answer
argument_list|)
argument_list|,
name|stdin
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
operator|!
name|take_action
argument_list|()
condition|)
do|;
if|if
condition|(
operator|!
name|getans
argument_list|(
literal|"\nCare to play another game? (y-n) "
argument_list|)
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|getans
argument_list|(
literal|"In the same cave? (y-n) "
argument_list|)
condition|)
name|clear_things_in_cave
argument_list|()
expr_stmt|;
else|else
name|cave_init
argument_list|()
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_macro
name|display_room_stats
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Routine will explain what's going on with the current room, as well 	 * as describe whether there are pits, bats,& wumpii nearby.  It's 	 * all pretty mindless, really. 	 */
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\nYou are in room %d of the cave, and have %d arrow%s left.\n"
argument_list|,
name|player_loc
argument_list|,
name|arrows_left
argument_list|,
name|plural
argument_list|(
name|arrows_left
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bats_nearby
argument_list|()
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"*rustle* *rustle* (must be bats nearby)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pit_nearby
argument_list|()
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"*whoosh* (I feel a draft from some pits).\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wump_nearby
argument_list|()
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"*sniff* (I can smell the evil Wumpus nearby!)\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"There are tunnels to rooms %d, "
argument_list|,
name|cave
index|[
name|player_loc
index|]
operator|.
name|tunnel
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|link_num
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cave
index|[
name|player_loc
index|]
operator|.
name|tunnel
index|[
name|i
index|]
operator|<=
name|room_num
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d, "
argument_list|,
name|cave
index|[
name|player_loc
index|]
operator|.
name|tunnel
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"and %d.\n"
argument_list|,
name|cave
index|[
name|player_loc
index|]
operator|.
name|tunnel
index|[
name|link_num
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|take_action
argument_list|()
end_macro

begin_block
block|{
comment|/* 	 * Do the action specified by the player, either 'm'ove, 's'hoot 	 * or something exceptionally bizarre and strange!  Returns 1 	 * iff the player died during this turn, otherwise returns 0. 	 */
switch|switch
condition|(
operator|*
name|answer
condition|)
block|{
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
comment|/* move */
return|return
operator|(
name|move_to
argument_list|(
name|answer
operator|+
literal|1
argument_list|)
operator|)
return|;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
comment|/* shoot */
return|return
operator|(
name|shoot
argument_list|(
name|answer
operator|+
literal|1
argument_list|)
operator|)
return|;
case|case
literal|'Q'
case|:
case|case
literal|'q'
case|:
case|case
literal|'x'
case|:
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'\n'
case|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|random
argument_list|()
operator|%
literal|15
operator|==
literal|1
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Que pasa?\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"I don't understand!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|move_to
argument_list|(
argument|room_number
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|room_number
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|just_moved_by_bats
decl_stmt|,
name|next_room
decl_stmt|,
name|tunnel_available
decl_stmt|;
comment|/* 	 * This is responsible for moving the player into another room in the 	 * cave as per their directions.  If room_number is a null string, 	 * then we'll prompt the user for the next room to go into.   Once 	 * we've moved into the room, we'll check for things like bats, pits, 	 * and so on.  This routine returns 1 if something occurs that kills 	 * the player and 0 otherwise... 	 */
name|tunnel_available
operator|=
name|just_moved_by_bats
operator|=
literal|0
expr_stmt|;
name|next_room
operator|=
name|atoi
argument_list|(
name|room_number
argument_list|)
expr_stmt|;
comment|/* crap for magic tunnels */
if|if
condition|(
name|next_room
operator|==
name|room_num
operator|+
literal|1
operator|&&
name|cave
index|[
name|player_loc
index|]
operator|.
name|tunnel
index|[
name|link_num
operator|-
literal|1
index|]
operator|!=
name|next_room
condition|)
operator|++
name|next_room
expr_stmt|;
while|while
condition|(
name|next_room
operator|<
literal|1
operator|||
name|next_room
operator|>
name|room_num
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|next_room
operator|<
literal|0
operator|&&
name|next_room
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Sorry, but we're constrained to a semi-Euclidean cave!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_room
operator|>
name|room_num
operator|+
literal|1
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"What?  The cave surely isn't quite that big!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_room
operator|==
name|room_num
operator|+
literal|1
operator|&&
name|cave
index|[
name|player_loc
index|]
operator|.
name|tunnel
index|[
name|link_num
operator|-
literal|1
index|]
operator|!=
name|next_room
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"What?  The cave isn't that big!\n"
argument_list|)
expr_stmt|;
operator|++
name|next_room
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"To which room do you wish to move? "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|answer
argument_list|,
sizeof|sizeof
argument_list|(
name|answer
argument_list|)
argument_list|,
name|stdin
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|next_room
operator|=
name|atoi
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
comment|/* now let's see if we can move to that room or not */
name|tunnel_available
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|link_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cave
index|[
name|player_loc
index|]
operator|.
name|tunnel
index|[
name|i
index|]
operator|==
name|next_room
condition|)
name|tunnel_available
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|tunnel_available
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"*Oof!*  (You hit the wall)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|%
literal|6
operator|==
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Your colorful comments awaken the wumpus!\n"
argument_list|)
expr_stmt|;
name|move_wump
argument_list|()
expr_stmt|;
if|if
condition|(
name|wumpus_loc
operator|==
name|player_loc
condition|)
block|{
name|wump_kill
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* now let's move into that room and check it out for dangers */
if|if
condition|(
name|next_room
operator|==
name|room_num
operator|+
literal|1
condition|)
name|jump
argument_list|(
name|next_room
operator|=
operator|(
name|random
argument_list|()
operator|%
name|room_num
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|player_loc
operator|=
name|next_room
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|next_room
operator|==
name|wumpus_loc
condition|)
block|{
comment|/* uh oh... */
name|wump_kill
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cave
index|[
name|next_room
index|]
operator|.
name|has_a_pit
condition|)
if|if
condition|(
name|random
argument_list|()
operator|%
literal|12
operator|<
literal|2
condition|)
block|{
name|pit_survive
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|pit_kill
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cave
index|[
name|next_room
index|]
operator|.
name|has_a_bat
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"*flap*  *flap*  *flap*  (humongous bats pick you up and move you%s!)\n"
argument_list|,
name|just_moved_by_bats
condition|?
literal|" again"
else|:
literal|""
argument_list|)
expr_stmt|;
name|next_room
operator|=
name|player_loc
operator|=
operator|(
name|random
argument_list|()
operator|%
name|room_num
operator|)
operator|+
literal|1
expr_stmt|;
name|just_moved_by_bats
operator|=
literal|1
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|shoot
argument_list|(
argument|room_list
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|room_list
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|chance
decl_stmt|,
name|next
decl_stmt|,
name|roomcnt
decl_stmt|;
name|int
name|j
decl_stmt|,
name|arrow_location
decl_stmt|,
name|link
decl_stmt|,
name|ok
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|strtok
argument_list|()
decl_stmt|;
comment|/* 	 * Implement shooting arrows.  Arrows are shot by the player indicating 	 * a space-separated list of rooms that the arrow should pass through; 	 * if any of the rooms they specify are not accessible via tunnel from 	 * the room the arrow is in, it will instead fly randomly into another 	 * room.  If the player hits the wumpus, this routine will indicate 	 * such.  If it misses, this routine will *move* the wumpus one room. 	 * If it's the last arrow, the player then dies...  Returns 1 if the 	 * player has won or died, 0 if nothing has happened. 	 */
name|arrow_location
operator|=
name|player_loc
expr_stmt|;
for|for
control|(
name|roomcnt
operator|=
literal|1
init|;
condition|;
operator|++
name|roomcnt
operator|,
name|room_list
operator|=
name|NULL
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|room_list
argument_list|,
literal|" \t\n"
argument_list|)
operator|)
condition|)
if|if
condition|(
name|roomcnt
operator|==
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"The arrow falls to the ground at your feet!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
break|break;
if|if
condition|(
name|roomcnt
operator|>
literal|5
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"The arrow wavers in its flight and and can go no further!\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|next
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|ok
operator|=
literal|0
init|;
name|j
operator|<
name|link_num
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|cave
index|[
name|arrow_location
index|]
operator|.
name|tunnel
index|[
name|j
index|]
operator|==
name|next
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|next
operator|>
name|room_num
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"A faint gleam tells you the arrow has gone through a magic tunnel!\n"
argument_list|)
expr_stmt|;
name|arrow_location
operator|=
operator|(
name|random
argument_list|()
operator|%
name|room_num
operator|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|arrow_location
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|link
operator|=
operator|(
name|random
argument_list|()
operator|%
name|link_num
operator|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
name|player_loc
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"*thunk*  The arrow can't find a way from %d to %d and flys back into\n\ your room!\n"
argument_list|,
name|arrow_location
argument_list|,
name|next
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cave
index|[
name|arrow_location
index|]
operator|.
name|tunnel
index|[
name|link
index|]
operator|>
name|room_num
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"*thunk*  The arrow flys randomly into a magic tunnel, thence into\n\ room %d!\n"
argument_list|,
name|cave
index|[
name|arrow_location
index|]
operator|.
name|tunnel
index|[
name|link
index|]
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"*thunk*  The arrow can't find a way from %d to %d and flys randomly\n\ into room %d!\n"
argument_list|,
name|arrow_location
argument_list|,
name|next
argument_list|,
name|cave
index|[
name|arrow_location
index|]
operator|.
name|tunnel
index|[
name|link
index|]
argument_list|)
expr_stmt|;
name|arrow_location
operator|=
name|cave
index|[
name|arrow_location
index|]
operator|.
name|tunnel
index|[
name|link
index|]
expr_stmt|;
break|break;
block|}
name|chance
operator|=
name|random
argument_list|()
operator|%
literal|10
expr_stmt|;
if|if
condition|(
name|roomcnt
operator|==
literal|3
operator|&&
name|chance
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Your bowstring breaks!  *twaaaaaang*\n\ The arrow is weakly shot and can go no further!\n"
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|roomcnt
operator|==
literal|4
operator|&&
name|chance
operator|<
literal|6
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"The arrow wavers in its flight and and can go no further!\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * now we've gotten into the new room let us see if El Wumpo is 	 * in the same room ... if so we've a HIT and the player WON! 	 */
if|if
condition|(
name|arrow_location
operator|==
name|wumpus_loc
condition|)
block|{
name|kill_wump
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|arrow_location
operator|==
name|player_loc
condition|)
block|{
name|shoot_self
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|--
name|arrows_left
condition|)
block|{
name|no_arrows
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|{
comment|/* each time you shoot, it's more likely the wumpus moves */
specifier|static
name|int
name|lastchance
init|=
literal|2
decl_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|%
name|level
operator|==
name|EASY
condition|?
literal|12
else|:
literal|9
operator|<
operator|(
name|lastchance
operator|+=
literal|2
operator|)
condition|)
block|{
name|move_wump
argument_list|()
expr_stmt|;
if|if
condition|(
name|wumpus_loc
operator|==
name|player_loc
condition|)
name|wump_kill
argument_list|()
expr_stmt|;
name|lastchance
operator|=
name|random
argument_list|()
operator|%
literal|3
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|cave_init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|link
decl_stmt|;
name|int
name|delta
decl_stmt|,
name|int_compare
argument_list|()
decl_stmt|;
name|time_t
name|time
parameter_list|()
function_decl|;
comment|/* 	 * This does most of the interesting work in this program actually! 	 * In this routine we'll initialize the Wumpus cave to have all rooms 	 * linking to all others by stepping through our data structure once, 	 * recording all forward links and backwards links too.  The parallel 	 * "linkcount" data structure ensures that no room ends up with more 	 * than three links, regardless of the quality of the random number 	 * generator that we're using. 	 */
name|srandom
argument_list|(
operator|(
name|int
operator|)
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialize the cave first off. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|room_num
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|link_num
condition|;
operator|++
name|j
control|)
name|cave
index|[
name|i
index|]
operator|.
name|tunnel
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* choose a random 'hop' delta for our guaranteed link */
while|while
condition|(
operator|!
operator|(
name|delta
operator|=
name|random
argument_list|()
operator|%
name|room_num
operator|)
condition|)
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|room_num
condition|;
operator|++
name|i
control|)
block|{
name|link
operator|=
operator|(
operator|(
name|i
operator|+
name|delta
operator|)
operator|%
name|room_num
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* connection */
name|cave
index|[
name|i
index|]
operator|.
name|tunnel
index|[
literal|0
index|]
operator|=
name|link
expr_stmt|;
comment|/* forw link */
name|cave
index|[
name|link
index|]
operator|.
name|tunnel
index|[
literal|1
index|]
operator|=
name|i
expr_stmt|;
comment|/* back link */
block|}
comment|/* now fill in the rest of the cave with random connections */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|room_num
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|2
init|;
name|j
operator|<
name|link_num
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|cave
index|[
name|i
index|]
operator|.
name|tunnel
index|[
name|j
index|]
operator|!=
operator|-
literal|1
condition|)
continue|continue;
name|try_again
label|:
name|link
operator|=
operator|(
name|random
argument_list|()
operator|%
name|room_num
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* skip duplicates */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|cave
index|[
name|i
index|]
operator|.
name|tunnel
index|[
name|k
index|]
operator|==
name|link
condition|)
goto|goto
name|try_again
goto|;
name|cave
index|[
name|i
index|]
operator|.
name|tunnel
index|[
name|j
index|]
operator|=
name|link
expr_stmt|;
if|if
condition|(
name|random
argument_list|()
operator|%
literal|2
operator|==
literal|1
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|link_num
condition|;
operator|++
name|k
control|)
block|{
comment|/* if duplicate, skip it */
if|if
condition|(
name|cave
index|[
name|link
index|]
operator|.
name|tunnel
index|[
name|k
index|]
operator|==
name|i
condition|)
name|k
operator|=
name|link_num
expr_stmt|;
comment|/* if open link, use it, force exit */
if|if
condition|(
name|cave
index|[
name|link
index|]
operator|.
name|tunnel
index|[
name|k
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|cave
index|[
name|link
index|]
operator|.
name|tunnel
index|[
name|k
index|]
operator|=
name|i
expr_stmt|;
name|k
operator|=
name|link_num
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * now that we're done, sort the tunnels in each of the rooms to 	 * make it easier on the intrepid adventurer. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|room_num
condition|;
operator|++
name|i
control|)
name|qsort
argument_list|(
name|cave
index|[
name|i
index|]
operator|.
name|tunnel
argument_list|,
operator|(
name|u_int
operator|)
name|link_num
argument_list|,
sizeof|sizeof
argument_list|(
name|cave
index|[
name|i
index|]
operator|.
name|tunnel
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|int_compare
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|room_num
condition|;
operator|++
name|i
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"<room %d  has tunnels to "
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|link_num
condition|;
operator|++
name|j
control|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|cave
index|[
name|i
index|]
operator|.
name|tunnel
index|[
name|j
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|">\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_macro
name|clear_things_in_cave
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * remove bats and pits from the current cave in preparation for us 	 * adding new ones via the initialize_things_in_cave() routines. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|room_num
condition|;
operator|++
name|i
control|)
name|cave
index|[
name|i
index|]
operator|.
name|has_a_bat
operator|=
name|cave
index|[
name|i
index|]
operator|.
name|has_a_pit
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|initialize_things_in_cave
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|loc
decl_stmt|;
comment|/* place some bats, pits, the wumpus, and the player. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bat_num
condition|;
operator|++
name|i
control|)
block|{
do|do
block|{
name|loc
operator|=
operator|(
name|random
argument_list|()
operator|%
name|room_num
operator|)
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|cave
index|[
name|loc
index|]
operator|.
name|has_a_bat
condition|)
do|;
name|cave
index|[
name|loc
index|]
operator|.
name|has_a_bat
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"<bat in room %d>\n"
argument_list|,
name|loc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pit_num
condition|;
operator|++
name|i
control|)
block|{
do|do
block|{
name|loc
operator|=
operator|(
name|random
argument_list|()
operator|%
name|room_num
operator|)
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|cave
index|[
name|loc
index|]
operator|.
name|has_a_pit
operator|&&
name|cave
index|[
name|loc
index|]
operator|.
name|has_a_bat
condition|)
do|;
name|cave
index|[
name|loc
index|]
operator|.
name|has_a_pit
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"<pit in room %d>\n"
argument_list|,
name|loc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|wumpus_loc
operator|=
operator|(
name|random
argument_list|()
operator|%
name|room_num
operator|)
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"<wumpus in room %d>\n"
argument_list|,
name|loc
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|player_loc
operator|=
operator|(
name|random
argument_list|()
operator|%
name|room_num
operator|)
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|player_loc
operator|==
name|wumpus_loc
operator|||
operator|(
name|level
operator|==
name|HARD
condition|?
operator|(
name|link_num
operator|/
name|room_num
operator|<
literal|0.4
condition|?
name|wump_nearby
argument_list|()
else|:
literal|0
operator|)
else|:
literal|0
operator|)
condition|)
do|;
block|}
end_block

begin_macro
name|getans
argument_list|(
argument|prompt
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|prompt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
comment|/* 	 * simple routine to ask the yes/no question specified until the user 	 * answers yes or no, then return 1 if they said 'yes' and 0 if they 	 * answered 'no'. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|stdin
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'N'
operator|||
operator|*
name|buf
operator|==
literal|'n'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'Y'
operator|||
operator|*
name|buf
operator|==
literal|'y'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"I don't understand your answer; please enter 'y' or 'n'!\n"
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_block

begin_macro
name|bats_nearby
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* check for bats in the immediate vicinity */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|link_num
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|cave
index|[
name|cave
index|[
name|player_loc
index|]
operator|.
name|tunnel
index|[
name|i
index|]
index|]
operator|.
name|has_a_bat
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|pit_nearby
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* check for pits in the immediate vicinity */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|link_num
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|cave
index|[
name|cave
index|[
name|player_loc
index|]
operator|.
name|tunnel
index|[
name|i
index|]
index|]
operator|.
name|has_a_pit
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|wump_nearby
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* check for a wumpus within TWO caves of where we are */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|link_num
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|cave
index|[
name|player_loc
index|]
operator|.
name|tunnel
index|[
name|i
index|]
operator|==
name|wumpus_loc
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|link_num
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|cave
index|[
name|cave
index|[
name|player_loc
index|]
operator|.
name|tunnel
index|[
name|i
index|]
index|]
operator|.
name|tunnel
index|[
name|j
index|]
operator|==
name|wumpus_loc
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|move_wump
argument_list|()
end_macro

begin_block
block|{
name|wumpus_loc
operator|=
name|cave
index|[
name|wumpus_loc
index|]
operator|.
name|tunnel
index|[
name|random
argument_list|()
operator|%
name|link_num
index|]
expr_stmt|;
block|}
end_block

begin_macro
name|int_compare
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|*
name|a
operator|<
operator|*
name|b
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|instructions
argument_list|()
end_macro

begin_block
block|{
name|char
name|buf
index|[
literal|120
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|getenv
argument_list|()
decl_stmt|;
comment|/* 	 * read the instructions file, if needed, and show the user how to 	 * play this game! 	 */
if|if
condition|(
operator|!
name|getans
argument_list|(
literal|"Instructions? (y-n) "
argument_list|)
condition|)
return|return;
if|if
condition|(
name|access
argument_list|(
name|_PATH_WUMPINFO
argument_list|,
name|R_OK
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Sorry, but the instruction file seems to have disappeared in a\n\ puff of greasy black smoke! (poof)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|getenv
argument_list|(
literal|"PAGER"
argument_list|)
operator|)
operator|||
name|strlen
argument_list|(
name|p
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|+
name|strlen
argument_list|(
name|_PATH_WUMPINFO
argument_list|)
operator|+
literal|5
condition|)
name|p
operator|=
name|_PATH_PAGER
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s"
argument_list|,
name|p
argument_list|,
name|_PATH_WUMPINFO
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|system
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: wump [-h] [-a arrows] [-b bats] [-p pits] [-r rooms] [-t tunnels]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* messages */
end_comment

begin_macro
name|wump_kill
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"*ROAR* *chomp* *snurfle* *chomp*!\n\ Much to the delight of the Wumpus, you walked right into his mouth,\n\ making you one of the easiest dinners he's ever had!  For you, however,\n\ it's a rather unpleasant death.  The only good thing is that it's been\n\ so long since the evil Wumpus cleaned his teeth that you immediately\n\ passed out from the stench!\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|kill_wump
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"*thwock!* *groan* *crash*\n\n\ A horrible roar fills the cave, and you realize, with a smile, that you\n\ have slain the evil Wumpus and won the game!  You don't want to tarry for\n\ long, however, because not only is the Wumpus famous, but the stench of\n\ dead Wumpus is also quite well known, a stench plenty enough to slay the\n\ mightiest adventurer at a single whiff!!\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|no_arrows
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\nYou turn and look at your quiver, and realize with a sinking feeling\n\ that you've just shot your last arrow (figuratively, too).  Sensing this\n\ with its psychic powers, the evil Wumpus rampagees through the cave, finds\n\ you, and with a mighty *ROAR* eats you alive!\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|shoot_self
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n*Thwack!*  A sudden piercing feeling informs you that the ricochet\n\ of your wild arrow has resulted in it wedging in your side, causing\n\ extreme agony.  The evil Wumpus, with its psychic powers, realizes this\n\ and immediately rushes to your side, not to help, alas, but to EAT YOU!\n\ (*CHOMP*)\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|jump
argument_list|(
argument|where
argument_list|)
end_macro

begin_decl_stmt
name|int
name|where
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\nWith a jaunty step you enter the magic tunnel.  As you do, you\n\ notice that the walls are shimmering and glowing.  Suddenly you feel\n\ a very curious, warm sensation and find yourself in room %d!!\n"
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pit_kill
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"*AAAUUUUGGGGGHHHHHhhhhhhhhhh...*\n\ The whistling sound and updraft as you walked into this room of the\n\ cave apparently wasn't enough to clue you in to the presence of the\n\ bottomless pit.  You have a lot of time to reflect on this error as\n\ you fall many miles to the core of the earth.  Look on the bright side;\n\ you can at least find out if Jules Verne was right...\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pit_survive
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Without conscious thought you grab for the side of the cave and manage\n\ to grasp onto a rocky outcrop.  Beneath your feet stretches the limitless\n\ depths of a bottomless pit!  Rock crumbles beneath your feet!\n"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

