begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Ralph Campbell.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)pickmove.c	8.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|"gomoku.h"
end_include

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|sortcombos
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* combos at higher levels */
end_comment

begin_decl_stmt
name|int
name|combolen
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of combos in sortcombos */
end_comment

begin_decl_stmt
name|int
name|nextcolor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* color of next move */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|pdir
index|[]
decl_stmt|;
end_decl_stmt

begin_macro
name|pickmove
argument_list|(
argument|us
argument_list|)
end_macro

begin_decl_stmt
name|int
name|us
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|,
modifier|*
name|sp1
decl_stmt|,
modifier|*
name|sp2
decl_stmt|;
specifier|register
name|union
name|combo
modifier|*
name|Ocp
decl_stmt|,
modifier|*
name|Tcp
decl_stmt|;
comment|/* first move is easy */
if|if
condition|(
name|movenum
operator|==
literal|1
condition|)
return|return
operator|(
name|PT
argument_list|(
name|K
argument_list|,
literal|10
argument_list|)
operator|)
return|;
comment|/* initialize all the board values */
for|for
control|(
name|sp
operator|=
operator|&
name|board
index|[
name|PT
argument_list|(
name|T
argument_list|,
literal|20
argument_list|)
index|]
init|;
operator|--
name|sp
operator|>=
operator|&
name|board
index|[
name|PT
argument_list|(
name|A
argument_list|,
literal|1
argument_list|)
index|]
condition|;
control|)
block|{
name|sp
operator|->
name|s_combo
index|[
name|BLACK
index|]
operator|.
name|s
operator|=
name|MAXCOMBO
expr_stmt|;
name|sp
operator|->
name|s_combo
index|[
name|WHITE
index|]
operator|.
name|s
operator|=
name|MAXCOMBO
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|BLACK
index|]
operator|=
literal|255
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|WHITE
index|]
operator|=
literal|255
expr_stmt|;
name|sp
operator|->
name|s_nforce
index|[
name|BLACK
index|]
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|s_nforce
index|[
name|WHITE
index|]
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|s_flg
operator|&=
operator|~
operator|(
name|FFLAGALL
operator||
name|MFLAGALL
operator|)
expr_stmt|;
block|}
comment|/* remove old combos */
name|removecombos
argument_list|(
name|BLACK
argument_list|)
expr_stmt|;
name|removecombos
argument_list|(
name|WHITE
argument_list|)
expr_stmt|;
name|removeemptyspots
argument_list|()
expr_stmt|;
comment|/* compute new values */
name|nextcolor
operator|=
name|us
expr_stmt|;
name|scanframes
argument_list|(
name|BLACK
argument_list|)
expr_stmt|;
name|scanframes
argument_list|(
name|WHITE
argument_list|)
expr_stmt|;
comment|/* find the spot with the highest value */
for|for
control|(
name|sp
operator|=
name|sp1
operator|=
name|sp2
operator|=
operator|&
name|board
index|[
name|PT
argument_list|(
name|T
argument_list|,
literal|19
argument_list|)
index|]
init|;
operator|--
name|sp
operator|>=
operator|&
name|board
index|[
name|PT
argument_list|(
name|A
argument_list|,
literal|1
argument_list|)
index|]
condition|;
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_occ
operator|!=
name|EMPTY
condition|)
continue|continue;
if|if
condition|(
name|debug
operator|&&
operator|(
name|sp
operator|->
name|s_combo
index|[
name|BLACK
index|]
operator|.
name|s
operator|<
literal|0x200
operator|||
name|sp
operator|->
name|s_combo
index|[
name|WHITE
index|]
operator|.
name|s
operator|<
literal|0x200
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"- %s %x/%d %d %x/%d %d %d"
argument_list|,
name|stoc
argument_list|(
name|sp
operator|-
name|board
argument_list|)
argument_list|,
name|sp
operator|->
name|s_combo
index|[
name|BLACK
index|]
operator|.
name|s
argument_list|,
name|sp
operator|->
name|s_level
index|[
name|BLACK
index|]
argument_list|,
name|sp
operator|->
name|s_nforce
index|[
name|BLACK
index|]
argument_list|,
name|sp
operator|->
name|s_combo
index|[
name|WHITE
index|]
operator|.
name|s
argument_list|,
name|sp
operator|->
name|s_level
index|[
name|WHITE
index|]
argument_list|,
name|sp
operator|->
name|s_nforce
index|[
name|WHITE
index|]
argument_list|,
name|sp
operator|->
name|s_wval
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
block|}
comment|/* pick the best black move */
if|if
condition|(
name|better
argument_list|(
name|sp
argument_list|,
name|sp1
argument_list|,
name|BLACK
argument_list|)
condition|)
name|sp1
operator|=
name|sp
expr_stmt|;
comment|/* pick the best white move */
if|if
condition|(
name|better
argument_list|(
name|sp
argument_list|,
name|sp2
argument_list|,
name|WHITE
argument_list|)
condition|)
name|sp2
operator|=
name|sp
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
block|{
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"B %s %x/%d %d %x/%d %d %d %d"
argument_list|,
name|stoc
argument_list|(
name|sp1
operator|-
name|board
argument_list|)
argument_list|,
name|sp1
operator|->
name|s_combo
index|[
name|BLACK
index|]
operator|.
name|s
argument_list|,
name|sp1
operator|->
name|s_level
index|[
name|BLACK
index|]
argument_list|,
name|sp1
operator|->
name|s_nforce
index|[
name|BLACK
index|]
argument_list|,
name|sp1
operator|->
name|s_combo
index|[
name|WHITE
index|]
operator|.
name|s
argument_list|,
name|sp1
operator|->
name|s_level
index|[
name|WHITE
index|]
argument_list|,
name|sp1
operator|->
name|s_nforce
index|[
name|WHITE
index|]
argument_list|,
name|sp1
operator|->
name|s_wval
argument_list|,
name|combolen
index|[
name|BLACK
index|]
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"W %s %x/%d %d %x/%d %d %d %d"
argument_list|,
name|stoc
argument_list|(
name|sp2
operator|-
name|board
argument_list|)
argument_list|,
name|sp2
operator|->
name|s_combo
index|[
name|WHITE
index|]
operator|.
name|s
argument_list|,
name|sp2
operator|->
name|s_level
index|[
name|WHITE
index|]
argument_list|,
name|sp2
operator|->
name|s_nforce
index|[
name|WHITE
index|]
argument_list|,
name|sp2
operator|->
name|s_combo
index|[
name|BLACK
index|]
operator|.
name|s
argument_list|,
name|sp2
operator|->
name|s_level
index|[
name|BLACK
index|]
argument_list|,
name|sp2
operator|->
name|s_nforce
index|[
name|BLACK
index|]
argument_list|,
name|sp2
operator|->
name|s_wval
argument_list|,
name|combolen
index|[
name|WHITE
index|]
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|us
operator|==
name|BLACK
condition|)
block|{
name|Ocp
operator|=
operator|&
name|sp1
operator|->
name|s_combo
index|[
name|BLACK
index|]
expr_stmt|;
name|Tcp
operator|=
operator|&
name|sp2
operator|->
name|s_combo
index|[
name|WHITE
index|]
expr_stmt|;
block|}
else|else
block|{
name|Tcp
operator|=
operator|&
name|sp1
operator|->
name|s_combo
index|[
name|BLACK
index|]
expr_stmt|;
name|Ocp
operator|=
operator|&
name|sp2
operator|->
name|s_combo
index|[
name|WHITE
index|]
expr_stmt|;
name|sp
operator|=
name|sp1
expr_stmt|;
name|sp1
operator|=
name|sp2
expr_stmt|;
name|sp2
operator|=
name|sp
expr_stmt|;
block|}
comment|/* 	 * Block their combo only if we have to (i.e., if they are one move 	 * away from completing a force and we don't have a force that 	 * we can complete which takes fewer moves to win). 	 */
if|if
condition|(
name|Tcp
operator|->
name|c
operator|.
name|a
operator|<=
literal|1
operator|&&
operator|(
name|Ocp
operator|->
name|c
operator|.
name|a
operator|>
literal|1
operator|||
name|Tcp
operator|->
name|c
operator|.
name|a
operator|+
name|Tcp
operator|->
name|c
operator|.
name|b
operator|<
name|Ocp
operator|->
name|c
operator|.
name|a
operator|+
name|Ocp
operator|->
name|c
operator|.
name|b
operator|)
condition|)
return|return
operator|(
name|sp2
operator|-
name|board
operator|)
return|;
return|return
operator|(
name|sp1
operator|-
name|board
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Return true if spot 'sp' is better than spot 'sp1' for color 'us'.  */
end_comment

begin_macro
name|better
argument_list|(
argument|sp
argument_list|,
argument|sp1
argument_list|,
argument|us
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|spotstr
modifier|*
name|sp1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|us
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|them
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_combo
index|[
name|us
index|]
operator|.
name|s
operator|<
name|sp1
operator|->
name|s_combo
index|[
name|us
index|]
operator|.
name|s
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_combo
index|[
name|us
index|]
operator|.
name|s
operator|!=
name|sp1
operator|->
name|s_combo
index|[
name|us
index|]
operator|.
name|s
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_level
index|[
name|us
index|]
operator|<
name|sp1
operator|->
name|s_level
index|[
name|us
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_level
index|[
name|us
index|]
operator|!=
name|sp1
operator|->
name|s_level
index|[
name|us
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_nforce
index|[
name|us
index|]
operator|>
name|sp1
operator|->
name|s_nforce
index|[
name|us
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_nforce
index|[
name|us
index|]
operator|!=
name|sp1
operator|->
name|s_nforce
index|[
name|us
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|them
operator|=
operator|!
name|us
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_combo
index|[
name|them
index|]
operator|.
name|s
operator|<
name|sp1
operator|->
name|s_combo
index|[
name|them
index|]
operator|.
name|s
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_combo
index|[
name|them
index|]
operator|.
name|s
operator|!=
name|sp1
operator|->
name|s_combo
index|[
name|them
index|]
operator|.
name|s
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_level
index|[
name|them
index|]
operator|<
name|sp1
operator|->
name|s_level
index|[
name|them
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_level
index|[
name|them
index|]
operator|!=
name|sp1
operator|->
name|s_level
index|[
name|them
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_nforce
index|[
name|them
index|]
operator|>
name|sp1
operator|->
name|s_nforce
index|[
name|them
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_nforce
index|[
name|them
index|]
operator|!=
name|sp1
operator|->
name|s_nforce
index|[
name|them
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_wval
operator|>
name|sp1
operator|->
name|s_wval
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|s_wval
operator|!=
name|sp1
operator|->
name|s_wval
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|SVR4
return|return
operator|(
name|rand
argument_list|()
operator|&
literal|1
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|random
argument_list|()
operator|&
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_block

begin_decl_stmt
name|int
name|curcolor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* implicit parameter to makecombo() */
end_comment

begin_decl_stmt
name|int
name|curlevel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* implicit parameter to makecombo() */
end_comment

begin_comment
comment|/*  * Scan the sorted list of frames and update the minimum combo values.  */
end_comment

begin_macro
name|scanframes
argument_list|(
argument|color
argument_list|)
end_macro

begin_decl_stmt
name|int
name|color
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|ecbp
decl_stmt|;
specifier|register
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|;
specifier|register
name|union
name|combo
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|elist
modifier|*
name|ep
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|r
decl_stmt|,
name|d
decl_stmt|,
name|n
decl_stmt|;
name|union
name|combo
name|cb
decl_stmt|;
name|curcolor
operator|=
name|color
expr_stmt|;
comment|/* check for empty list of frames */
name|cbp
operator|=
name|sortframes
index|[
name|color
index|]
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
operator|(
expr|struct
name|combostr
operator|*
operator|)
literal|0
condition|)
return|return;
comment|/* quick check for four in a row */
name|sp
operator|=
operator|&
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
expr_stmt|;
name|cb
operator|.
name|s
operator|=
name|sp
operator|->
name|s_fval
index|[
name|color
index|]
index|[
name|d
operator|=
name|cbp
operator|->
name|c_dir
index|]
operator|.
name|s
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|s
operator|<
literal|0x101
condition|)
block|{
name|d
operator|=
name|dd
index|[
name|d
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|5
operator|+
name|cb
operator|.
name|c
operator|.
name|b
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|+=
name|d
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_occ
operator|!=
name|EMPTY
condition|)
continue|continue;
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
operator|=
name|cb
operator|.
name|s
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
literal|1
expr_stmt|;
block|}
return|return;
block|}
comment|/* update the minimum combo value for each spot in the frame */
name|n
operator|=
name|combolen
index|[
name|color
index|]
expr_stmt|;
name|ecbp
operator|=
name|cbp
expr_stmt|;
do|do
block|{
name|sp
operator|=
operator|&
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
expr_stmt|;
name|cp
operator|=
operator|&
name|sp
operator|->
name|s_fval
index|[
name|color
index|]
index|[
name|r
operator|=
name|cbp
operator|->
name|c_dir
index|]
expr_stmt|;
name|d
operator|=
name|dd
index|[
name|r
index|]
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|c
operator|.
name|b
condition|)
block|{
name|cb
operator|.
name|c
operator|.
name|a
operator|=
name|cp
operator|->
name|c
operator|.
name|a
operator|+
literal|1
expr_stmt|;
name|cb
operator|.
name|c
operator|.
name|b
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|s
operator|<
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
condition|)
block|{
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
operator|=
name|cb
operator|.
name|s
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|makecombo2
argument_list|(
name|cbp
argument_list|,
name|sp
argument_list|,
name|cb
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|s
operator|!=
literal|0x101
condition|)
name|cb
operator|.
name|s
operator|=
name|cp
operator|->
name|s
expr_stmt|;
name|sp
operator|+=
name|d
expr_stmt|;
name|i
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|.
name|s
operator|=
name|cp
operator|->
name|s
expr_stmt|;
name|i
operator|=
literal|5
expr_stmt|;
block|}
for|for
control|(
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|+=
name|d
control|)
block|{
comment|/* for each spot */
if|if
condition|(
name|sp
operator|->
name|s_occ
operator|!=
name|EMPTY
condition|)
continue|continue;
if|if
condition|(
name|cp
operator|->
name|s
operator|<
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
condition|)
block|{
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
operator|=
name|cp
operator|->
name|s
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|s
operator|==
literal|0x101
condition|)
name|sp
operator|->
name|s_nforce
index|[
name|color
index|]
operator|++
expr_stmt|;
name|makecombo2
argument_list|(
name|cbp
argument_list|,
name|sp
argument_list|,
name|cb
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* mark frame as having been processed */
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
operator|.
name|s_flg
operator||=
name|MFLAG
operator|<<
name|r
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|cbp
operator|=
name|cbp
operator|->
name|c_next
operator|)
operator|!=
name|ecbp
condition|)
do|;
comment|/* try to make new 3rd level combos, 4th level, etc. */
name|d
operator|=
literal|2
expr_stmt|;
while|while
condition|(
name|combolen
index|[
name|color
index|]
operator|>
name|n
condition|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"%cL%d %d"
argument_list|,
literal|"BW"
index|[
name|color
index|]
argument_list|,
name|d
argument_list|,
name|combolen
index|[
name|color
index|]
operator|-
name|n
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
name|n
operator|=
name|combolen
index|[
name|color
index|]
expr_stmt|;
name|addframes
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
comment|/* scan for combos at empty spots */
for|for
control|(
name|sp
operator|=
operator|&
name|board
index|[
name|PT
argument_list|(
name|T
argument_list|,
literal|20
argument_list|)
index|]
init|;
operator|--
name|sp
operator|>=
operator|&
name|board
index|[
name|PT
argument_list|(
name|A
argument_list|,
literal|1
argument_list|)
index|]
condition|;
control|)
block|{
for|for
control|(
name|ep
operator|=
name|sp
operator|->
name|s_empty
index|[
name|color
index|]
init|;
name|ep
condition|;
name|ep
operator|=
name|ep
operator|->
name|e_next
control|)
block|{
name|cbp
operator|=
name|ep
operator|->
name|e_combo
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|c_combo
operator|.
name|s
operator|<
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
condition|)
block|{
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
operator|=
name|cbp
operator|->
name|c_combo
operator|.
name|s
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
name|cbp
operator|->
name|c_nframes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cbp
operator|->
name|c_combo
operator|.
name|s
operator|==
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
operator|&&
name|cbp
operator|->
name|c_nframes
operator|<
name|sp
operator|->
name|s_level
index|[
name|color
index|]
condition|)
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
name|cbp
operator|->
name|c_nframes
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Compute all level 2 combos of frames intersecting spot 'osp'  * within the frame 'ocbp' and combo value 's'.  */
end_comment

begin_macro
name|makecombo2
argument_list|(
argument|ocbp
argument_list|,
argument|osp
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|ocbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|spotstr
modifier|*
name|osp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|,
modifier|*
name|fsp
decl_stmt|;
specifier|register
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|r
decl_stmt|,
name|d
decl_stmt|,
name|c
decl_stmt|;
name|int
name|baseB
decl_stmt|,
name|bmask
decl_stmt|,
name|n
decl_stmt|;
name|union
name|combo
name|ocb
decl_stmt|,
name|fcb
decl_stmt|;
comment|/* try to combine a new frame with those found so far */
name|ocb
operator|.
name|s
operator|=
name|s
expr_stmt|;
name|baseB
operator|=
name|ocb
operator|.
name|c
operator|.
name|a
operator|+
name|ocb
operator|.
name|c
operator|.
name|b
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|4
init|;
operator|--
name|r
operator|>=
literal|0
condition|;
control|)
block|{
comment|/* for each direction */
comment|/* don't include frames that overlap ones already included */
if|if
condition|(
name|r
operator|==
name|ocbp
operator|->
name|c_dir
condition|)
continue|continue;
name|d
operator|=
name|dd
index|[
name|r
index|]
expr_stmt|;
name|bmask
operator|=
operator|(
name|BFLAG
operator||
name|FFLAG
operator||
name|MFLAG
operator|)
operator|<<
name|r
expr_stmt|;
name|fsp
operator|=
name|osp
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|5
init|;
operator|--
name|f
operator|>=
literal|0
condition|;
name|fsp
operator|-=
name|d
control|)
block|{
comment|/* for each frame */
comment|/* 		 * Don't include frames that are blocked or 		 * part of a<1,x> combo. 		 */
if|if
condition|(
name|fsp
operator|->
name|s_occ
operator|==
name|BORDER
condition|)
break|break;
if|if
condition|(
name|fsp
operator|->
name|s_flg
operator|&
name|bmask
condition|)
continue|continue;
comment|/* don't include frames of the wrong color */
name|fcb
operator|.
name|s
operator|=
name|fsp
operator|->
name|s_fval
index|[
name|curcolor
index|]
index|[
name|r
index|]
operator|.
name|s
expr_stmt|;
if|if
condition|(
name|fcb
operator|.
name|c
operator|.
name|a
operator|>=
name|MAXA
condition|)
continue|continue;
comment|/* 		 * Get the combo value for this frame. 		 * If this is the end point of the frame, 		 * use the closed ended value for the frame. 		 */
if|if
condition|(
name|f
operator|==
literal|4
operator|&&
name|fcb
operator|.
name|c
operator|.
name|b
operator|||
name|fcb
operator|.
name|s
operator|==
literal|0x101
condition|)
block|{
name|fcb
operator|.
name|c
operator|.
name|a
operator|++
expr_stmt|;
name|fcb
operator|.
name|c
operator|.
name|b
operator|=
literal|0
expr_stmt|;
block|}
comment|/* compute combo value */
name|c
operator|=
name|fcb
operator|.
name|c
operator|.
name|a
operator|+
name|ocb
operator|.
name|c
operator|.
name|a
operator|-
literal|3
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|3
condition|)
continue|continue;
name|n
operator|=
name|fcb
operator|.
name|c
operator|.
name|a
operator|+
name|fcb
operator|.
name|c
operator|.
name|b
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|baseB
operator|<
name|n
condition|)
name|n
operator|=
name|baseB
expr_stmt|;
comment|/* make a new combo! */
name|cbp
operator|=
operator|(
expr|struct
name|combostr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|combostr
argument_list|)
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|c_combo
operator|.
name|c
operator|.
name|a
operator|=
name|c
expr_stmt|;
name|cbp
operator|->
name|c_combo
operator|.
name|c
operator|.
name|b
operator|=
name|n
expr_stmt|;
name|cbp
operator|->
name|c_link
index|[
literal|0
index|]
operator|=
name|ocbp
expr_stmt|;
name|cbp
operator|->
name|c_link
index|[
literal|1
index|]
operator|=
name|fsp
operator|->
name|s_frame
index|[
name|r
index|]
expr_stmt|;
name|cbp
operator|->
name|c_vertex
operator|=
name|osp
operator|-
name|board
expr_stmt|;
name|cbp
operator|->
name|c_nframes
operator|=
literal|2
expr_stmt|;
name|cbp
operator|->
name|c_dir
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|c_flg
operator|=
literal|0
expr_stmt|;
name|cbp
operator|->
name|c_refcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|1
operator|&&
name|debug
operator|>
literal|1
operator|||
name|debug
operator|>
literal|3
condition|)
block|{
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"%c %s %x/2 r%d f%d %x"
argument_list|,
name|curcolor
operator|==
name|BLACK
condition|?
literal|'b'
else|:
literal|'w'
argument_list|,
name|stoc
argument_list|(
name|osp
operator|-
name|board
argument_list|)
argument_list|,
name|cbp
operator|->
name|c_combo
operator|.
name|s
argument_list|,
name|r
argument_list|,
name|f
argument_list|,
name|ocb
operator|.
name|s
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|markcombo
argument_list|(
name|cbp
argument_list|,
name|curcolor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bdisp
argument_list|()
expr_stmt|;
name|whatsup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clearcombo
argument_list|(
name|cbp
argument_list|,
name|curcolor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|c
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|ocb
operator|.
name|c
operator|.
name|a
operator|>
literal|2
condition|)
name|makeempty
argument_list|(
name|cbp
argument_list|,
name|ocbp
argument_list|,
name|ocb
operator|.
name|c
operator|.
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcb
operator|.
name|c
operator|.
name|a
operator|>
literal|2
condition|)
name|makeempty
argument_list|(
name|cbp
argument_list|,
name|cbp
operator|->
name|c_link
index|[
literal|1
index|]
argument_list|,
name|fcb
operator|.
name|c
operator|.
name|b
argument_list|)
expr_stmt|;
comment|/* add the new combo to the end of the list */
name|appendcombo
argument_list|(
name|cbp
argument_list|,
name|curcolor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|updatecombo
argument_list|(
name|cbp
argument_list|,
name|curcolor
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Scan the sorted list of frames and try to combine into combos.  */
end_comment

begin_macro
name|addframes
argument_list|(
argument|level
argument_list|)
end_macro

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|ecbp
decl_stmt|;
specifier|register
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|,
modifier|*
name|fsp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|r
decl_stmt|,
name|d
decl_stmt|;
name|union
name|combo
name|fcb
decl_stmt|,
name|cb
decl_stmt|;
name|curlevel
operator|=
name|level
expr_stmt|;
comment|/* clear MFLAG for this level */
name|cbp
operator|=
name|ecbp
operator|=
name|sortframes
index|[
name|curcolor
index|]
expr_stmt|;
do|do
block|{
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
operator|.
name|s_flg
operator|&=
operator|~
name|MFLAGALL
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|cbp
operator|=
name|cbp
operator|->
name|c_next
operator|)
operator|!=
name|ecbp
condition|)
do|;
name|cbp
operator|=
name|ecbp
expr_stmt|;
do|do
block|{
name|fsp
operator|=
operator|&
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
expr_stmt|;
name|r
operator|=
name|cbp
operator|->
name|c_dir
expr_stmt|;
comment|/* skip frames that are part of a<1,x> combo */
if|if
condition|(
name|fsp
operator|->
name|s_flg
operator|&
operator|(
name|FFLAG
operator|<<
name|r
operator|)
condition|)
continue|continue;
comment|/* 		 * Don't include<1,x> combo frames, 		 * treat it as a blocked three in a row instead. 		 */
name|fcb
operator|.
name|s
operator|=
name|fsp
operator|->
name|s_fval
index|[
name|curcolor
index|]
index|[
name|r
index|]
operator|.
name|s
expr_stmt|;
if|if
condition|(
name|fcb
operator|.
name|s
operator|==
literal|0x101
condition|)
name|fcb
operator|.
name|s
operator|=
literal|0x200
expr_stmt|;
comment|/* 		 * If this is an open ended frame, use 		 * the combo value with the end closed. 		 */
if|if
condition|(
name|fsp
operator|->
name|s_occ
operator|==
name|EMPTY
condition|)
block|{
if|if
condition|(
name|fcb
operator|.
name|c
operator|.
name|b
condition|)
block|{
name|cb
operator|.
name|c
operator|.
name|a
operator|=
name|fcb
operator|.
name|c
operator|.
name|a
operator|+
literal|1
expr_stmt|;
name|cb
operator|.
name|c
operator|.
name|b
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cb
operator|.
name|s
operator|=
name|fcb
operator|.
name|s
expr_stmt|;
name|makecombo
argument_list|(
name|cbp
argument_list|,
name|fsp
argument_list|,
name|cb
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * The next four spots are handled the same for both 		 * open and closed ended frames. 		 */
name|d
operator|=
name|dd
index|[
name|r
index|]
expr_stmt|;
name|sp
operator|=
name|fsp
operator|+
name|d
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|+=
name|d
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_occ
operator|!=
name|EMPTY
condition|)
continue|continue;
name|makecombo
argument_list|(
name|cbp
argument_list|,
name|sp
argument_list|,
name|fcb
operator|.
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* mark frame as having been processed */
name|fsp
operator|->
name|s_flg
operator||=
name|MFLAG
operator|<<
name|r
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|cbp
operator|=
name|cbp
operator|->
name|c_next
operator|)
operator|!=
name|ecbp
condition|)
do|;
block|}
end_block

begin_comment
comment|/*  * Compute all level N combos of frames intersecting spot 'osp'  * within the frame 'ocbp' and combo value 's'.  */
end_comment

begin_macro
name|makecombo
argument_list|(
argument|ocbp
argument_list|,
argument|osp
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|ocbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|spotstr
modifier|*
name|osp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|ncbp
decl_stmt|;
specifier|register
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|elist
modifier|*
name|ep
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|c
decl_stmt|;
name|struct
name|elist
modifier|*
name|nep
decl_stmt|,
modifier|*
modifier|*
name|epp
decl_stmt|;
name|struct
name|combostr
modifier|*
name|fcbp
decl_stmt|;
name|int
name|baseB
decl_stmt|,
name|verts
decl_stmt|,
name|d
decl_stmt|;
name|union
name|combo
name|ocb
decl_stmt|,
name|cb
decl_stmt|;
name|ocb
operator|.
name|s
operator|=
name|s
expr_stmt|;
name|baseB
operator|=
name|ocb
operator|.
name|c
operator|.
name|a
operator|+
name|ocb
operator|.
name|c
operator|.
name|b
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|osp
operator|->
name|s_empty
index|[
name|curcolor
index|]
init|;
name|ep
condition|;
name|ep
operator|=
name|ep
operator|->
name|e_next
control|)
block|{
comment|/* don't try to combine this combo if it is the wrong level */
name|cbp
operator|=
name|ep
operator|->
name|e_combo
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|c_nframes
operator|>
name|curlevel
condition|)
continue|continue;
if|if
condition|(
name|cbp
operator|->
name|c_nframes
operator|!=
name|curlevel
condition|)
break|break;
comment|/* don't include frames that overlap ones already included */
name|ncbp
operator|=
name|ep
operator|->
name|e_frame
expr_stmt|;
if|if
condition|(
name|ncbp
operator|->
name|c_dir
operator|==
name|ocbp
operator|->
name|c_dir
operator|||
operator|(
name|cbp
operator|->
name|c_flg
operator|&
name|C_LOOP
operator|)
operator|&&
name|cbp
operator|->
name|c_dir
operator|==
name|ocbp
operator|->
name|c_dir
operator|||
operator|(
name|n
operator|=
name|checkframes
argument_list|(
name|cbp
argument_list|,
name|ocbp
argument_list|,
name|osp
operator|-
name|board
argument_list|,
name|ncbp
argument_list|)
operator|)
operator|<
literal|0
condition|)
continue|continue;
comment|/* compute first half of combo value */
name|c
operator|=
name|cbp
operator|->
name|c_combo
operator|.
name|c
operator|.
name|a
operator|+
name|ocb
operator|.
name|c
operator|.
name|a
operator|-
literal|3
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|3
condition|)
continue|continue;
comment|/* check to see if this frame forms a valid loop */
name|verts
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|sp
operator|=
operator|&
name|board
index|[
name|ocbp
operator|->
name|c_vertex
index|]
expr_stmt|;
name|d
operator|=
name|dd
index|[
name|ocbp
operator|->
name|c_dir
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|=
name|ocb
operator|.
name|c
operator|.
name|b
condition|)
name|sp
operator|+=
name|d
expr_stmt|;
for|for
control|(
init|;
name|n
operator|<
literal|5
condition|;
name|n
operator|++
operator|,
name|sp
operator|+=
name|d
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_occ
operator|!=
name|EMPTY
operator|||
name|sp
operator|==
name|osp
condition|)
continue|continue;
for|for
control|(
name|nep
operator|=
name|sp
operator|->
name|s_empty
index|[
name|curcolor
index|]
init|;
name|nep
condition|;
name|nep
operator|=
name|nep
operator|->
name|e_next
control|)
block|{
if|if
condition|(
name|nep
operator|->
name|e_combo
operator|==
name|cbp
condition|)
block|{
name|verts
operator|++
expr_stmt|;
name|fcbp
operator|=
name|nep
operator|->
name|e_frame
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nep
operator|->
name|e_combo
operator|->
name|c_nframes
operator|<
name|cbp
operator|->
name|c_nframes
condition|)
break|break;
block|}
block|}
if|#
directive|if
literal|0
block|{ 		char *str; 		sprintf(fmtbuf, "%c v%d %s%c", 		    curcolor == BLACK ? 'b' : 'w', verts, 		    stoc(ocbp->c_vertex), pdir[ocbp->c_dir]); 		str = fmtbuf + strlen(fmtbuf); 		for (; cbp->c_link[1]; cbp = cbp->c_link[0]) { 		    sprintf(str, " %s%c", stoc(cbp->c_link[1]->c_vertex), 			pdir[cbp->c_link[1]->c_dir]); 		    str += strlen(str); 		} 		sprintf(str, " %s%c", stoc(cbp->c_vertex), pdir[cbp->c_dir]); 		dlog(fmtbuf); 		cbp = ep->e_combo; 		}
endif|#
directive|endif
comment|/* frame overlaps but not at a valid spot */
if|if
condition|(
name|verts
operator|==
literal|0
operator|||
name|ocb
operator|.
name|c
operator|.
name|a
operator|<
literal|3
condition|)
continue|continue;
block|}
comment|/* compute second half of combo value */
name|cb
operator|.
name|s
operator|=
name|board
index|[
name|ncbp
operator|->
name|c_vertex
index|]
operator|.
name|s_fval
index|[
name|curcolor
index|]
index|[
name|ncbp
operator|->
name|c_dir
index|]
operator|.
name|s
expr_stmt|;
name|n
operator|=
name|cb
operator|.
name|c
operator|.
name|a
operator|+
name|cb
operator|.
name|c
operator|.
name|b
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|baseB
operator|<
name|n
condition|)
name|n
operator|=
name|baseB
expr_stmt|;
comment|/* make a new combo! */
name|ncbp
operator|=
operator|(
expr|struct
name|combostr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|combostr
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|-=
name|verts
expr_stmt|;
name|ncbp
operator|->
name|c_combo
operator|.
name|c
operator|.
name|a
operator|=
name|c
expr_stmt|;
name|ncbp
operator|->
name|c_combo
operator|.
name|c
operator|.
name|b
operator|=
name|n
expr_stmt|;
name|ncbp
operator|->
name|c_link
index|[
literal|0
index|]
operator|=
name|cbp
expr_stmt|;
name|ncbp
operator|->
name|c_link
index|[
literal|1
index|]
operator|=
name|ocbp
expr_stmt|;
name|ncbp
operator|->
name|c_vertex
operator|=
name|osp
operator|-
name|board
expr_stmt|;
name|ncbp
operator|->
name|c_nframes
operator|=
name|cbp
operator|->
name|c_nframes
operator|+
literal|1
expr_stmt|;
name|ncbp
operator|->
name|c_refcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|verts
condition|)
block|{
name|ncbp
operator|->
name|c_flg
operator|=
name|C_LOOP
expr_stmt|;
name|ncbp
operator|->
name|c_dir
operator|=
name|fcbp
operator|->
name|c_dir
expr_stmt|;
comment|/* add the combo to the list of empty spots */
name|nep
operator|=
operator|(
expr|struct
name|elist
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|elist
argument_list|)
argument_list|)
expr_stmt|;
name|nep
operator|->
name|e_combo
operator|=
name|ncbp
expr_stmt|;
name|nep
operator|->
name|e_frame
operator|=
name|ocbp
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"e %s"
argument_list|,
name|stoc
argument_list|(
name|ncbp
operator|->
name|c_vertex
argument_list|)
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
block|}
comment|/* sort by the number of frames in the combo */
name|epp
operator|=
operator|&
name|board
index|[
name|ncbp
operator|->
name|c_vertex
index|]
operator|.
name|s_empty
index|[
name|curcolor
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|epp
condition|)
block|{
if|if
condition|(
name|cbp
operator|->
name|c_nframes
operator|>=
operator|(
operator|*
name|epp
operator|)
operator|->
name|e_combo
operator|->
name|c_nframes
condition|)
break|break;
name|epp
operator|=
operator|&
operator|(
operator|*
name|epp
operator|)
operator|->
name|e_next
expr_stmt|;
block|}
name|nep
operator|->
name|e_next
operator|=
operator|*
name|epp
expr_stmt|;
operator|*
name|epp
operator|=
name|nep
expr_stmt|;
block|}
else|else
block|{
name|ncbp
operator|->
name|c_flg
operator|=
literal|0
expr_stmt|;
name|ncbp
operator|->
name|c_dir
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ocb
operator|.
name|c
operator|.
name|a
operator|>
literal|2
condition|)
name|makeempty
argument_list|(
name|ncbp
argument_list|,
name|ocbp
argument_list|,
name|ocb
operator|.
name|c
operator|.
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verts
operator|>
literal|1
operator|&&
name|debug
operator|||
name|c
operator|==
literal|1
operator|&&
name|debug
operator|>
literal|1
operator|||
name|debug
operator|>
literal|2
condition|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"%c %s%c %x v%d %x/%d"
argument_list|,
name|curcolor
operator|==
name|BLACK
condition|?
literal|'b'
else|:
literal|'w'
argument_list|,
name|stoc
argument_list|(
name|osp
operator|-
name|board
argument_list|)
argument_list|,
name|pdir
index|[
name|ocbp
operator|->
name|c_dir
index|]
argument_list|,
name|ocb
operator|.
name|s
argument_list|,
name|verts
argument_list|,
name|ncbp
operator|->
name|c_combo
operator|.
name|s
argument_list|,
name|ncbp
operator|->
name|c_nframes
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
name|str
operator|=
name|fmtbuf
expr_stmt|;
for|for
control|(
name|cbp
operator|=
name|ncbp
init|;
name|cbp
operator|->
name|c_link
index|[
literal|1
index|]
condition|;
name|cbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|0
index|]
control|)
block|{
name|sprintf
argument_list|(
name|str
argument_list|,
literal|" %s%c"
argument_list|,
name|stoc
argument_list|(
name|cbp
operator|->
name|c_link
index|[
literal|1
index|]
operator|->
name|c_vertex
argument_list|)
argument_list|,
name|pdir
index|[
name|cbp
operator|->
name|c_link
index|[
literal|1
index|]
operator|->
name|c_dir
index|]
argument_list|)
expr_stmt|;
name|str
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|str
argument_list|,
literal|" %s%c"
argument_list|,
name|stoc
argument_list|(
name|cbp
operator|->
name|c_vertex
argument_list|)
argument_list|,
name|pdir
index|[
name|cbp
operator|->
name|c_dir
index|]
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|markcombo
argument_list|(
name|ncbp
argument_list|,
name|curcolor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bdisp
argument_list|()
expr_stmt|;
name|whatsup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clearcombo
argument_list|(
name|ncbp
argument_list|,
name|curcolor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|c
operator|>
literal|1
condition|)
block|{
comment|/* add the new combo to the end of the list */
name|appendcombo
argument_list|(
name|ncbp
argument_list|,
name|curcolor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|updatecombo
argument_list|(
name|ncbp
argument_list|,
name|curcolor
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ncbp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Add the combostr 'cbp' to the empty spots list for each empty spot  * in the frame 'fcbp' except for the intersection.  * 's' is zero if 'fcbp' is a closed ended frame, else it is one.  * Return the number of valid intersections with ocbp for detecting loops.  */
end_comment

begin_macro
name|makeempty
argument_list|(
argument|cbp
argument_list|,
argument|fcbp
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|fcbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|,
modifier|*
name|vsp
decl_stmt|;
name|struct
name|elist
modifier|*
name|ep
decl_stmt|,
modifier|*
modifier|*
name|epp
decl_stmt|;
name|int
name|d
decl_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"E %s%c s%d"
argument_list|,
name|stoc
argument_list|(
name|fcbp
operator|->
name|c_vertex
argument_list|)
argument_list|,
name|pdir
index|[
name|fcbp
operator|->
name|c_dir
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fmtbuf
operator|+
name|strlen
argument_list|(
name|fmtbuf
argument_list|)
argument_list|,
literal|" %s"
argument_list|,
name|stoc
argument_list|(
name|cbp
operator|->
name|c_vertex
argument_list|)
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
block|}
name|vsp
operator|=
operator|&
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
expr_stmt|;
name|sp
operator|=
operator|&
name|board
index|[
name|fcbp
operator|->
name|c_vertex
index|]
expr_stmt|;
name|d
operator|=
name|dd
index|[
name|fcbp
operator|->
name|c_dir
index|]
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|sp
operator|+=
name|d
expr_stmt|;
for|for
control|(
init|;
name|s
operator|<
literal|5
condition|;
name|s
operator|++
operator|,
name|sp
operator|+=
name|d
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|s_occ
operator|!=
name|EMPTY
operator|||
name|sp
operator|==
name|vsp
condition|)
continue|continue;
comment|/* add the combo to the list of empty spots */
name|ep
operator|=
operator|(
expr|struct
name|elist
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|elist
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|e_combo
operator|=
name|cbp
expr_stmt|;
name|ep
operator|->
name|e_frame
operator|=
name|fcbp
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
block|{
name|sprintf
argument_list|(
name|fmtbuf
argument_list|,
literal|"e %s"
argument_list|,
name|stoc
argument_list|(
name|sp
operator|-
name|board
argument_list|)
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
name|fmtbuf
argument_list|)
expr_stmt|;
block|}
comment|/* sort by the number of frames in the combo */
name|epp
operator|=
operator|&
name|sp
operator|->
name|s_empty
index|[
name|curcolor
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|epp
condition|)
block|{
if|if
condition|(
name|cbp
operator|->
name|c_nframes
operator|>=
operator|(
operator|*
name|epp
operator|)
operator|->
name|e_combo
operator|->
name|c_nframes
condition|)
break|break;
name|epp
operator|=
operator|&
operator|(
operator|*
name|epp
operator|)
operator|->
name|e_next
expr_stmt|;
block|}
name|ep
operator|->
name|e_next
operator|=
operator|*
name|epp
expr_stmt|;
operator|*
name|epp
operator|=
name|ep
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Update the board value based on the combostr.  * This is called only if 'cbp' is a<1,x> combo.  * We handle things differently depending on whether the next move  * would be trying to "complete" the combo or trying to block it.  */
end_comment

begin_macro
name|updatecombo
argument_list|(
argument|cbp
argument_list|,
argument|color
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|color
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|framestr
modifier|*
name|fp
decl_stmt|;
specifier|register
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|combostr
modifier|*
name|tcbp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|d
decl_stmt|;
name|int
name|nframes
decl_stmt|,
name|vertex
decl_stmt|;
name|union
name|combo
name|cb
decl_stmt|;
for|for
control|(
init|;
name|tcbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|1
index|]
condition|;
name|cbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|0
index|]
control|)
block|{
if|if
condition|(
name|color
operator|==
name|nextcolor
condition|)
block|{
comment|/* update the board value for the vertex */
name|sp
operator|=
operator|&
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
expr_stmt|;
name|sp
operator|->
name|s_nforce
index|[
name|color
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|c_combo
operator|.
name|s
operator|<
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
condition|)
block|{
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
operator|=
name|cbp
operator|->
name|c_combo
operator|.
name|s
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
name|cbp
operator|->
name|c_nframes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cbp
operator|->
name|c_combo
operator|.
name|s
operator|==
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
operator|&&
name|cbp
operator|->
name|c_nframes
operator|<
name|sp
operator|->
name|s_level
index|[
name|color
index|]
condition|)
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
name|cbp
operator|->
name|c_nframes
expr_stmt|;
block|}
else|else
block|{
comment|/* update the board values for each spot in frame */
name|vertex
operator|=
name|cbp
operator|->
name|c_vertex
expr_stmt|;
name|sp
operator|=
operator|&
name|board
index|[
name|tcbp
operator|->
name|c_vertex
index|]
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_fval
index|[
name|color
index|]
index|[
name|tcbp
operator|->
name|c_dir
index|]
operator|.
name|c
operator|.
name|b
operator|&&
name|tcbp
operator|->
name|c_vertex
operator|!=
name|vertex
condition|)
name|i
operator|=
literal|6
expr_stmt|;
else|else
name|i
operator|=
literal|5
expr_stmt|;
name|d
operator|=
name|dd
index|[
name|tcbp
operator|->
name|c_dir
index|]
expr_stmt|;
name|cb
operator|.
name|s
operator|=
name|cbp
operator|->
name|c_combo
operator|.
name|s
expr_stmt|;
name|nframes
operator|=
name|cbp
operator|->
name|c_nframes
expr_stmt|;
for|for
control|(
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|+=
name|d
control|)
block|{
name|sp
operator|->
name|s_nforce
index|[
name|color
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|s
operator|<
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
condition|)
block|{
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
operator|=
name|cb
operator|.
name|s
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
name|nframes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|.
name|s
operator|==
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
operator|&&
name|cbp
operator|->
name|c_nframes
operator|<
name|sp
operator|->
name|s_level
index|[
name|color
index|]
condition|)
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
name|nframes
expr_stmt|;
block|}
block|}
comment|/* mark the frame as being part of a<1,x> combo */
name|board
index|[
name|tcbp
operator|->
name|c_vertex
index|]
operator|.
name|s_flg
operator||=
name|FFLAG
operator|<<
name|tcbp
operator|->
name|c_dir
expr_stmt|;
block|}
if|if
condition|(
name|color
operator|!=
name|nextcolor
condition|)
block|{
comment|/* update the board values for each spot in frame */
name|sp
operator|=
operator|&
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_fval
index|[
name|color
index|]
index|[
name|cbp
operator|->
name|c_dir
index|]
operator|.
name|c
operator|.
name|b
operator|&&
name|cbp
operator|->
name|c_vertex
operator|!=
name|vertex
condition|)
name|i
operator|=
literal|6
expr_stmt|;
else|else
name|i
operator|=
literal|5
expr_stmt|;
name|d
operator|=
name|dd
index|[
name|cbp
operator|->
name|c_dir
index|]
expr_stmt|;
for|for
control|(
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|+=
name|d
control|)
block|{
name|sp
operator|->
name|s_nforce
index|[
name|color
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|.
name|s
operator|<
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
condition|)
block|{
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
operator|=
name|cb
operator|.
name|s
expr_stmt|;
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
name|nframes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|.
name|s
operator|==
name|sp
operator|->
name|s_combo
index|[
name|color
index|]
operator|.
name|s
operator|&&
name|cbp
operator|->
name|c_nframes
operator|<
name|sp
operator|->
name|s_level
index|[
name|color
index|]
condition|)
name|sp
operator|->
name|s_level
index|[
name|color
index|]
operator|=
name|nframes
expr_stmt|;
block|}
block|}
comment|/* mark the frame as being part of a<1,x> combo */
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
operator|.
name|s_flg
operator||=
name|FFLAG
operator|<<
name|cbp
operator|->
name|c_dir
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Free all elist structures.  */
end_comment

begin_macro
name|removeemptyspots
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|elist
modifier|*
name|ep
decl_stmt|,
modifier|*
name|nep
decl_stmt|;
specifier|register
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|sp
operator|=
operator|&
name|board
index|[
name|PT
argument_list|(
name|T
argument_list|,
literal|20
argument_list|)
index|]
init|;
operator|--
name|sp
operator|>=
operator|&
name|board
index|[
name|PT
argument_list|(
name|A
argument_list|,
literal|1
argument_list|)
index|]
condition|;
control|)
block|{
for|for
control|(
name|i
operator|=
name|BLACK
init|;
name|i
operator|<=
name|WHITE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|ep
operator|=
name|sp
operator|->
name|s_empty
index|[
name|i
index|]
init|;
name|ep
condition|;
name|ep
operator|=
name|nep
control|)
block|{
name|nep
operator|=
name|ep
operator|->
name|e_next
expr_stmt|;
name|free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|s_empty
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|elist
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Remove all combo structures.  */
end_comment

begin_macro
name|removecombos
argument_list|(
argument|color
argument_list|)
end_macro

begin_decl_stmt
name|int
name|color
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|ncbp
decl_stmt|,
modifier|*
name|endcbp
decl_stmt|;
comment|/* check the list */
if|if
condition|(
operator|(
name|cbp
operator|=
name|sortcombos
index|[
name|color
index|]
operator|)
operator|==
operator|(
expr|struct
name|combostr
operator|*
operator|)
literal|0
condition|)
return|return;
comment|/* scan the list */
name|endcbp
operator|=
name|cbp
expr_stmt|;
do|do
block|{
name|ncbp
operator|=
name|cbp
operator|->
name|c_next
expr_stmt|;
name|cbp
operator|->
name|c_next
operator|=
operator|(
expr|struct
name|combostr
operator|*
operator|)
literal|0
expr_stmt|;
name|cbp
operator|->
name|c_prev
operator|=
operator|(
expr|struct
name|combostr
operator|*
operator|)
literal|0
expr_stmt|;
name|free
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
name|cbp
operator|=
name|ncbp
expr_stmt|;
block|}
do|while
condition|(
name|cbp
operator|!=
name|endcbp
condition|)
do|;
name|sortcombos
index|[
name|color
index|]
operator|=
operator|(
expr|struct
name|combostr
operator|*
operator|)
literal|0
expr_stmt|;
name|combolen
index|[
name|color
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Add combo to the end of the list.  */
end_comment

begin_macro
name|appendcombo
argument_list|(
argument|cbp
argument_list|,
argument|color
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|color
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|combostr
modifier|*
name|pcbp
decl_stmt|,
modifier|*
name|ncbp
decl_stmt|;
name|combolen
index|[
name|color
index|]
operator|++
expr_stmt|;
name|ncbp
operator|=
name|sortcombos
index|[
name|color
index|]
expr_stmt|;
if|if
condition|(
name|ncbp
operator|==
operator|(
expr|struct
name|combostr
operator|*
operator|)
literal|0
condition|)
block|{
name|sortcombos
index|[
name|color
index|]
operator|=
name|cbp
expr_stmt|;
name|cbp
operator|->
name|c_next
operator|=
name|cbp
expr_stmt|;
name|cbp
operator|->
name|c_prev
operator|=
name|cbp
expr_stmt|;
return|return;
block|}
name|pcbp
operator|=
name|ncbp
operator|->
name|c_prev
expr_stmt|;
name|cbp
operator|->
name|c_next
operator|=
name|ncbp
expr_stmt|;
name|cbp
operator|->
name|c_prev
operator|=
name|pcbp
expr_stmt|;
name|ncbp
operator|->
name|c_prev
operator|=
name|cbp
expr_stmt|;
name|pcbp
operator|->
name|c_next
operator|=
name|cbp
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Return positive if frame 'fcbp' overlaps any of the frames in 'cbp'  * other than the frame 'ecbp'.  * Return -1 if any of the frames in 'cbp' are marked or part of a<1,x> combo.  * Else, return zero.  */
end_comment

begin_macro
name|checkframes
argument_list|(
argument|cbp
argument_list|,
argument|fcbp
argument_list|,
argument|vertex
argument_list|,
argument|ecbp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|fcbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vertex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|ecbp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|combostr
modifier|*
name|tcbp
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|mask
decl_stmt|;
name|short
modifier|*
name|ip
decl_stmt|;
name|n
operator|=
operator|(
name|fcbp
operator|-
name|frames
operator|)
operator|*
name|FAREA
expr_stmt|;
name|str
operator|=
operator|&
name|overlap
index|[
name|n
index|]
expr_stmt|;
name|ip
operator|=
operator|&
name|intersect
index|[
name|n
index|]
expr_stmt|;
name|i
operator|=
name|vertex
operator|==
name|fcbp
operator|->
name|c_vertex
condition|?
literal|2
else|:
literal|0
expr_stmt|;
for|for
control|(
init|;
name|tcbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|1
index|]
condition|;
name|cbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|0
index|]
control|)
block|{
if|#
directive|if
literal|0
block|if (board[tcbp->c_vertex].s_flg& (FFLAG<< tcbp->c_dir)) 			return (-1);
endif|#
directive|endif
name|vertex
operator|=
name|cbp
operator|->
name|c_vertex
expr_stmt|;
if|if
condition|(
name|tcbp
operator|==
name|ecbp
condition|)
continue|continue;
name|n
operator|=
name|tcbp
operator|-
name|frames
expr_stmt|;
if|if
condition|(
name|board
index|[
name|ip
index|[
name|n
index|]
index|]
operator|.
name|s_occ
operator|!=
name|EMPTY
condition|)
continue|continue;
name|mask
operator|=
name|str
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|+
operator|(
name|tcbp
operator|->
name|c_vertex
operator|==
name|vertex
operator|)
operator|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|#
directive|if
literal|0
block|if (board[cbp->c_vertex].s_flg& (FFLAG<< cbp->c_dir)) 		return (-1);
endif|#
directive|endif
if|if
condition|(
name|cbp
operator|==
name|ecbp
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|n
operator|=
name|cbp
operator|-
name|frames
expr_stmt|;
if|if
condition|(
name|board
index|[
name|ip
index|[
name|n
index|]
index|]
operator|.
name|s_occ
operator|!=
name|EMPTY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mask
operator|=
name|str
index|[
name|n
index|]
expr_stmt|;
return|return
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|+
operator|(
name|cbp
operator|->
name|c_vertex
operator|==
name|vertex
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|markcombo
argument_list|(
argument|cbp
argument_list|,
argument|color
argument_list|,
argument|vertex
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vertex
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|;
name|struct
name|combostr
modifier|*
name|tcbp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|d
decl_stmt|,
name|r
decl_stmt|,
name|n
decl_stmt|,
name|mask
decl_stmt|;
for|for
control|(
init|;
name|tcbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|1
index|]
condition|;
name|cbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|0
index|]
control|)
name|markcombo
argument_list|(
name|tcbp
argument_list|,
name|color
argument_list|,
name|vertex
operator|=
name|cbp
operator|->
name|c_vertex
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|&
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
expr_stmt|;
name|d
operator|=
name|dd
index|[
name|r
operator|=
name|cbp
operator|->
name|c_dir
index|]
expr_stmt|;
name|mask
operator|=
operator|(
name|IFLAG
operator||
name|CFLAG
operator|)
operator|<<
name|r
expr_stmt|;
name|n
operator|=
name|sp
operator|->
name|s_fval
index|[
name|color
index|]
index|[
name|r
index|]
operator|.
name|c
operator|.
name|b
operator|&&
name|cbp
operator|->
name|c_vertex
operator|!=
name|vertex
condition|?
literal|6
else|:
literal|5
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
name|d
control|)
block|{
if|if
condition|(
name|n
operator|==
literal|6
operator|&&
operator|(
name|i
operator|==
literal|0
operator|||
name|i
operator|==
literal|5
operator|)
condition|)
name|sp
operator|->
name|s_flg
operator||=
name|CFLAG
operator|<<
name|r
expr_stmt|;
else|else
name|sp
operator|->
name|s_flg
operator||=
name|mask
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|clearcombo
argument_list|(
argument|cbp
argument_list|,
argument|color
argument_list|,
argument|vertex
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|combostr
modifier|*
name|cbp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vertex
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|spotstr
modifier|*
name|sp
decl_stmt|;
name|struct
name|combostr
modifier|*
name|tcbp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|d
decl_stmt|,
name|r
decl_stmt|,
name|n
decl_stmt|,
name|mask
decl_stmt|;
for|for
control|(
init|;
name|tcbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|1
index|]
condition|;
name|cbp
operator|=
name|cbp
operator|->
name|c_link
index|[
literal|0
index|]
control|)
name|clearcombo
argument_list|(
name|tcbp
argument_list|,
name|color
argument_list|,
name|vertex
operator|=
name|cbp
operator|->
name|c_vertex
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|&
name|board
index|[
name|cbp
operator|->
name|c_vertex
index|]
expr_stmt|;
name|d
operator|=
name|dd
index|[
name|r
operator|=
name|cbp
operator|->
name|c_dir
index|]
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
operator|(
name|IFLAG
operator||
name|CFLAG
operator|)
operator|<<
name|r
operator|)
expr_stmt|;
name|n
operator|=
name|sp
operator|->
name|s_fval
index|[
name|color
index|]
index|[
name|r
index|]
operator|.
name|c
operator|.
name|b
operator|&&
name|cbp
operator|->
name|c_vertex
operator|!=
name|vertex
condition|?
literal|6
else|:
literal|5
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
name|d
control|)
name|sp
operator|->
name|s_flg
operator|&=
name|mask
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

end_unit

