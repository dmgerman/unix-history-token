begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Various installation dependent routines  *  * @(#)find.c	4.37 (Berkeley) 5/23/83  */
end_comment

begin_comment
comment|/*  * The various tuneable defines are:  *  *	SCOREFILE	Where/if the score file should live.  *	ALLSCORES	Score file is top ten scores, not top ten  *			players.  This is only useful when only a few  *			people will be playing; otherwise the score file  *			gets hogged by just a few people.  *	NUMSCORES	Number of scores in the score file (default 10).  *	NUMNAME		String version of NUMSCORES (first character  *			should be capitalized) (default "Ten").  *	MAXLOAD		What (if any) the maximum load average should be  *			when people are playing.  Since it is divided  *			by 10, to specify a load limit of 4.0, MAXLOAD  *			should be "40".	 If defined, then  *		LOADAV		Should it use it's own routine to get  *				the load average?  *		NAMELIST	If so, where does the system namelist  *				hide?  *	MAXUSERS	What (if any) the maximum user count should be  *			when people are playing.  If defined, then  *		UCOUNT		Should it use it's own routine to count  *				users?  *		UTMP		If so, where does the user list hide?  *	CHECKTIME	How often/if it should check during the game  *			for high load average.  */
end_comment

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SCOREFILE
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Lockfile
init|=
literal|"/tmp/.fredlock"
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NUMSCORES
end_ifndef

begin_define
define|#
directive|define
name|NUMSCORES
value|10
end_define

begin_define
define|#
directive|define
name|NUMNAME
value|"Ten"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|unsigned
name|int
name|numscores
init|=
name|NUMSCORES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Numname
init|=
name|NUMNAME
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ALLSCORES
end_ifdef

begin_decl_stmt
name|bool
name|Allscore
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
else|ALLSCORES
end_else

begin_decl_stmt
name|bool
name|Allscore
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|ALLSCORES
end_endif

begin_endif
endif|#
directive|endif
endif|SCOREFILE
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CHECKTIME
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|Num_checks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* times we've gone over in checkout() */
end_comment

begin_endif
endif|#
directive|endif
endif|CHECKTIME
end_endif

begin_comment
comment|/*  * init_check:  *	Check out too see if it is proper to play the game now  */
end_comment

begin_macro
name|init_check
argument_list|()
end_macro

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|MAXLOAD
argument_list|)
operator|||
name|defined
argument_list|(
name|MAXUSERS
argument_list|)
if|if
condition|(
name|too_much
argument_list|()
condition|)
block|{
name|printf
argument_list|(
literal|"Sorry, %s, but the system is too loaded now.\n"
argument_list|,
name|Whoami
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Try again later.  Meanwhile, why not enjoy a%s %s?\n"
argument_list|,
name|vowelstr
argument_list|(
name|Fruit
argument_list|)
argument_list|,
name|Fruit
argument_list|)
expr_stmt|;
if|if
condition|(
name|author
argument_list|()
condition|)
name|printf
argument_list|(
literal|"However, since you're a good guy, it's up to you\n"
argument_list|)
expr_stmt|;
else|else
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * open_score:  *	Open up the score file for future use, and then  *	setuid(getuid()) in case we are running setuid.  */
end_comment

begin_macro
name|open_score
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|SCOREFILE
name|Fd
operator|=
name|open
argument_list|(
name|SCOREFILE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|Fd
operator|<
literal|0
condition|)
name|perror
argument_list|(
name|SCOREFILE
argument_list|)
expr_stmt|;
else|#
directive|else
name|Fd
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * setup:  *	Get starting setup for all games  */
end_comment

begin_macro
name|setup
argument_list|()
end_macro

begin_block
block|{
name|int
name|auto_save
argument_list|()
decl_stmt|,
name|quit
argument_list|()
decl_stmt|,
name|endit
argument_list|()
decl_stmt|,
name|tstp
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|CHECKTIME
name|int
name|checkout
parameter_list|()
function_decl|;
endif|#
directive|endif
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|auto_save
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DUMP
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|auto_save
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTRAP
argument_list|,
name|auto_save
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|auto_save
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|auto_save
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|auto_save
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|auto_save
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|auto_save
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|auto_save
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|auto_save
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|quit
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DUMP
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|endit
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CHECKTIME
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|checkout
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|CHECKTIME
operator|*
literal|60
argument_list|)
expr_stmt|;
name|Num_checks
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|crmode
argument_list|()
expr_stmt|;
comment|/* Cbreak mode */
name|noecho
argument_list|()
expr_stmt|;
comment|/* Echo off */
ifdef|#
directive|ifdef
name|TIOCGLTC
name|getltchars
argument_list|()
expr_stmt|;
comment|/* get the local tty chars */
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * getltchars:  *	Get the local tty chars for later use  */
end_comment

begin_macro
name|getltchars
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|TIOCGLTC
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|Ltc
argument_list|)
expr_stmt|;
name|Got_ltc
operator|=
name|TRUE
expr_stmt|;
name|Orig_dsusp
operator|=
name|Ltc
operator|.
name|t_dsuspc
expr_stmt|;
name|Ltc
operator|.
name|t_dsuspc
operator|=
name|Ltc
operator|.
name|t_suspc
expr_stmt|;
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|Ltc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * start_score:  *	Start the scoring sequence  */
end_comment

begin_macro
name|start_score
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|CHECKTIME
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * symlink:  *	See if the file has a symbolic link  */
end_comment

begin_macro
name|symlink
argument_list|(
argument|sp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|S_IFLNK
name|struct
name|stat
name|sbuf2
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|sp
argument_list|,
operator|&
name|sbuf2
argument_list|)
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
else|else
return|return
operator|(
operator|(
name|sbuf2
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
operator|)
return|;
else|#
directive|else
return|return
name|FALSE
return|;
endif|#
directive|endif
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MAXLOAD
argument_list|)
operator|||
name|defined
argument_list|(
name|MAXUSERS
argument_list|)
end_if

begin_comment
comment|/*  * too_much:  *	See if the system is being used too much for this game  */
end_comment

begin_macro
name|too_much
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|MAXLOAD
name|double
name|avec
index|[
literal|3
index|]
decl_stmt|;
else|#
directive|else
specifier|register
name|int
name|cnt
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MAXLOAD
name|loadav
argument_list|(
name|avec
argument_list|)
expr_stmt|;
if|if
condition|(
name|avec
index|[
literal|1
index|]
operator|>
operator|(
name|MAXLOAD
operator|/
literal|10.0
operator|)
condition|)
return|return
name|TRUE
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MAXUSERS
if|if
condition|(
name|ucount
argument_list|()
operator|>
name|MAXUSERS
condition|)
return|return
name|TRUE
return|;
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_block

begin_comment
comment|/*  * author:  *	See if a user is an author of the program  */
end_comment

begin_macro
name|author
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|MASTER
if|if
condition|(
name|Wizard
condition|)
return|return
name|TRUE
return|;
endif|#
directive|endif
switch|switch
condition|(
name|getuid
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
return|return
name|TRUE
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CHECKTIME
end_ifdef

begin_comment
comment|/*  * checkout:  *	Check each CHECKTIME seconds to see if the load is too high  */
end_comment

begin_macro
name|checkout
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|char
modifier|*
name|msgs
index|[]
init|=
block|{
literal|"The load is too high to be playing.  Please leave in %0.1f minutes"
block|,
literal|"Please save your game.  You have %0.1f minutes"
block|,
literal|"Last warning.  You have %0.1f minutes to leave"
block|,     }
decl_stmt|;
name|int
name|checktime
decl_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|checkout
argument_list|)
expr_stmt|;
if|if
condition|(
name|too_much
argument_list|()
condition|)
block|{
if|if
condition|(
name|author
argument_list|()
condition|)
block|{
name|Num_checks
operator|=
literal|1
expr_stmt|;
name|chmsg
argument_list|(
literal|"The load is rather high, O exaulted one"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Num_checks
operator|++
operator|==
literal|3
condition|)
name|fatal
argument_list|(
literal|"Sorry.  You took too long.  You are dead\n"
argument_list|)
expr_stmt|;
name|checktime
operator|=
operator|(
name|CHECKTIME
operator|*
literal|60
operator|)
operator|/
name|Num_checks
expr_stmt|;
name|alarm
argument_list|(
name|checktime
argument_list|)
expr_stmt|;
name|chmsg
argument_list|(
name|msgs
index|[
name|Num_checks
operator|-
literal|1
index|]
argument_list|,
operator|(
operator|(
name|double
operator|)
name|checktime
operator|/
literal|60.0
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Num_checks
condition|)
block|{
name|Num_checks
operator|=
literal|0
expr_stmt|;
name|chmsg
argument_list|(
literal|"The load has dropped back down.  You have a reprieve"
argument_list|)
expr_stmt|;
block|}
name|alarm
argument_list|(
name|CHECKTIME
operator|*
literal|60
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * chmsg:  *	checkout()'s version of msg.  If we are in the middle of a  *	shell, do a printf instead of a msg to avoid the refresh.  */
end_comment

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|chmsg
argument_list|(
argument|fmt
argument_list|,
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|In_shell
condition|)
name|msg
argument_list|(
name|fmt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
name|fmt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LOADAV
end_ifdef

begin_comment
comment|/*  * loadav:  *	Looking up load average in core (for system where the loadav()  *	system call isn't defined  */
end_comment

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_decl_stmt
name|struct
name|nlist
name|avenrun
init|=
block|{
literal|"_avenrun"
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|loadav
argument_list|(
name|avg
argument_list|)
specifier|register
name|double
operator|*
name|avg
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|kmem
decl_stmt|;
if|if
condition|(
operator|(
name|kmem
operator|=
name|open
argument_list|(
literal|"/dev/kmem"
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
name|nlist
argument_list|(
name|NAMELIST
argument_list|,
operator|&
name|avenrun
argument_list|)
expr_stmt|;
if|if
condition|(
name|avenrun
operator|.
name|n_type
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|kmem
argument_list|)
expr_stmt|;
name|bad
label|:
name|avg
index|[
literal|0
index|]
operator|=
literal|0.0
expr_stmt|;
name|avg
index|[
literal|1
index|]
operator|=
literal|0.0
expr_stmt|;
name|avg
index|[
literal|2
index|]
operator|=
literal|0.0
expr_stmt|;
return|return;
block|}
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|avenrun
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
name|avg
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|kmem
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UCOUNT
end_ifdef

begin_comment
comment|/*  * ucount:  *	Count number of users on the system  */
end_comment

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_decl_stmt
name|struct
name|utmp
name|buf
decl_stmt|;
end_decl_stmt

begin_macro
name|ucount
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|utmp
modifier|*
name|up
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|utmp
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
if|if
condition|(
operator|(
name|utmp
operator|=
name|fopen
argument_list|(
name|UTMP
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|up
operator|=
operator|&
name|buf
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fread
argument_list|(
name|up
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|up
argument_list|)
argument_list|,
name|utmp
argument_list|)
operator|>
literal|0
condition|)
if|if
condition|(
name|buf
operator|.
name|ut_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|count
operator|++
expr_stmt|;
name|fclose
argument_list|(
name|utmp
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * lock_sc:  *	lock the score file.  If it takes too long, ask the user if  *	they care to wait.  Return TRUE if the lock is successful.  */
end_comment

begin_macro
name|lock_sc
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|SCOREFILE
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|static
name|struct
name|stat
name|sbuf
decl_stmt|;
name|time_t
name|time
parameter_list|()
function_decl|;
name|over
label|:
name|close
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/* just in case there are no files left */
if|if
condition|(
name|creat
argument_list|(
name|Lockfile
argument_list|,
literal|0000
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|5
condition|;
name|cnt
operator|++
control|)
block|{
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|creat
argument_list|(
name|Lockfile
argument_list|,
literal|0000
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|Lockfile
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|creat
argument_list|(
name|Lockfile
argument_list|,
literal|0000
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|sbuf
operator|.
name|st_mtime
operator|>
literal|10
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|Lockfile
argument_list|)
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
goto|goto
name|over
goto|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"The score file is very busy.  Do you want to wait longer\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"for it to become free so your score can get posted?\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"If so, type \"y\"\n"
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|Prbuf
argument_list|,
name|MAXSTR
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|Prbuf
index|[
literal|0
index|]
operator|==
literal|'y'
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|creat
argument_list|(
name|Lockfile
argument_list|,
literal|0000
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|stat
argument_list|(
name|Lockfile
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|creat
argument_list|(
name|Lockfile
argument_list|,
literal|0000
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|sbuf
operator|.
name|st_mtime
operator|>
literal|10
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|Lockfile
argument_list|)
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|FALSE
return|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * unlock_sc:  *	Unlock the score file  */
end_comment

begin_macro
name|unlock_sc
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|SCOREFILE
name|unlink
argument_list|(
name|Lockfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * flush_type:  *	Flush typeahead for traps, etc.  */
end_comment

begin_macro
name|flush_type
argument_list|()
end_macro

begin_block
block|{
name|crmode
argument_list|()
expr_stmt|;
block|}
end_block

end_unit

