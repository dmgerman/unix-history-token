begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Timothy C. Stoehr.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)machdep.c	5.8 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * machdep.c  *  * This source herein may be modified and/or distributed by anybody who  * so desires, with the following restrictions:  *    1.)  No portion of this notice shall be removed.  *    2.)  Credit shall not be taken for the creation of this source.  *    3.)  This code is not to be traded, sold, or used for personal  *         gain or profit.  *  */
end_comment

begin_comment
comment|/* Included in this file are all system dependent routines.  Extensive use  * of #ifdef's will be used to compile the appropriate code on each system:  *  *    UNIX:        all UNIX systems.  *    UNIX_BSD4_2: UNIX BSD 4.2 and later, UTEK, (4.1 BSD too?)  *    UNIX_SYSV:   UNIX system V  *    UNIX_V7:     UNIX version 7  *  * All UNIX code should be included between the single "#ifdef UNIX" at the  * top of this file, and the "#endif" at the bottom.  *   * To change a routine to include a new UNIX system, simply #ifdef the  * existing routine, as in the following example:  *  *   To make a routine compatible with UNIX system 5, change the first  *   function to the second:  *  *      md_function()  *      {  *         code;  *      }  *  *      md_function()  *      {  *      #ifdef UNIX_SYSV  *         sys5code;  *      #else  *         code;  *      #endif  *      }  *  * Appropriate variations of this are of course acceptible.  * The use of "#elseif" is discouraged because of non-portability.  * If the correct #define doesn't exist, "UNIX_SYSV" in this case, make it up  * and insert it in the list at the top of the file.  Alter the CFLAGS  * in you Makefile appropriately.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX_BSD4_2
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX_SYSV
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"rogue.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_comment
comment|/* md_slurp:  *  * This routine throws away all keyboard input that has not  * yet been read.  It is used to get rid of input that the user may have  * typed-ahead.  *  * This function is not necessary, so it may be stubbed.  The might cause  * message-line output to flash by because the game has continued to read  * input without waiting for the user to read the message.  Not such a  * big deal.  */
end_comment

begin_macro
name|md_slurp
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|fpurge
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* md_control_keyboard():  *  * This routine is much like md_cbreak_no_echo_nonl() below.  It sets up the  * keyboard for appropriate input.  Specifically, it prevents the tty driver  * from stealing characters.  For example, ^Y is needed as a command  * character, but the tty driver intercepts it for another purpose.  Any  * such behavior should be stopped.  This routine could be avoided if  * we used RAW mode instead of CBREAK.  But RAW mode does not allow the  * generation of keyboard signals, which the program uses.  *  * The parameter 'mode' when true, indicates that the keyboard should  * be set up to play rogue.  When false, it should be restored if  * necessary.  *  * This routine is not strictly necessary and may be stubbed.  This may  * cause certain command characters to be unavailable.  */
end_comment

begin_macro
name|md_control_keybord
argument_list|(
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|boolean
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|boolean
name|called_before
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|UNIX_BSD4_2
specifier|static
name|struct
name|ltchars
name|ltc_orig
decl_stmt|;
specifier|static
name|struct
name|tchars
name|tc_orig
decl_stmt|;
name|struct
name|ltchars
name|ltc_temp
decl_stmt|;
name|struct
name|tchars
name|tc_temp
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UNIX_SYSV
specifier|static
name|struct
name|termio
name|_oldtty
decl_stmt|;
name|struct
name|termio
name|_tty
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|called_before
condition|)
block|{
name|called_before
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIX_BSD4_2
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|tc_orig
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|ltc_orig
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UNIX_SYSV
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|_oldtty
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|UNIX_BSD4_2
name|ltc_temp
operator|=
name|ltc_orig
expr_stmt|;
name|tc_temp
operator|=
name|tc_orig
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UNIX_SYSV
name|_tty
operator|=
name|_oldtty
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|mode
condition|)
block|{
ifdef|#
directive|ifdef
name|UNIX_BSD4_2
name|ltc_temp
operator|.
name|t_suspc
operator|=
name|ltc_temp
operator|.
name|t_dsuspc
operator|=
operator|-
literal|1
expr_stmt|;
name|ltc_temp
operator|.
name|t_rprntc
operator|=
name|ltc_temp
operator|.
name|t_flushc
operator|=
operator|-
literal|1
expr_stmt|;
name|ltc_temp
operator|.
name|t_werasc
operator|=
name|ltc_temp
operator|.
name|t_lnextc
operator|=
operator|-
literal|1
expr_stmt|;
name|tc_temp
operator|.
name|t_startc
operator|=
name|tc_temp
operator|.
name|t_stopc
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UNIX_SYSV
name|_tty
operator|.
name|c_cc
index|[
name|VSWTCH
index|]
operator|=
name|CNSWTCH
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|UNIX_BSD4_2
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|tc_temp
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|ltc_temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UNIX_SYSV
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|_tty
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* md_heed_signals():  *  * This routine tells the program to call particular routines when  * certain interrupts/events occur:  *  *      SIGINT: call onintr() to interrupt fight with monster or long rest.  *      SIGQUIT: call byebye() to check for game termination.  *      SIGHUP: call error_save() to save game when terminal hangs up.  *  *		On VMS, SIGINT and SIGQUIT correspond to ^C and ^Y.  *  * This routine is not strictly necessary and can be stubbed.  This will  * mean that the game cannot be interrupted properly with keyboard  * input, this is not usually critical.  */
end_comment

begin_macro
name|md_heed_signals
argument_list|()
end_macro

begin_block
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|byebye
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|error_save
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* md_ignore_signals():  *  * This routine tells the program to completely ignore the events mentioned  * in md_heed_signals() above.  The event handlers will later be turned on  * by a future call to md_heed_signals(), so md_heed_signals() and  * md_ignore_signals() need to work together.  *  * This function should be implemented or the user risks interrupting  * critical sections of code, which could cause score file, or saved-game  * file, corruption.  */
end_comment

begin_macro
name|md_ignore_signals
argument_list|()
end_macro

begin_block
block|{
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* md_get_file_id():  *  * This function returns an integer that uniquely identifies the specified  * file.  It need not check for the file's existence.  In UNIX, the inode  * number is used.  *  * This function is used to identify saved-game files.  */
end_comment

begin_function
name|int
name|md_get_file_id
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|fname
argument_list|,
operator|&
name|sbuf
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|int
operator|)
name|sbuf
operator|.
name|st_ino
operator|)
return|;
block|}
end_function

begin_comment
comment|/* md_link_count():  *  * This routine returns the number of hard links to the specified file.  *  * This function is not strictly necessary.  On systems without hard links  * this routine can be stubbed by just returning 1.  */
end_comment

begin_function
name|int
name|md_link_count
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
name|stat
argument_list|(
name|fname
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|sbuf
operator|.
name|st_nlink
operator|)
return|;
block|}
end_function

begin_comment
comment|/* md_gct(): (Get Current Time)  *  * This function returns the current year, month(1-12), day(1-31), hour(0-23),  * minute(0-59), and second(0-59).  This is used for identifying the time  * at which a game is saved.  *  * This function is not strictly necessary.  It can be stubbed by returning  * zeros instead of the correct year, month, etc.  If your operating  * system doesn't provide all of the time units requested here, then you  * can provide only those that it does, and return zeros for the others.  * If you cannot provide good time values, then users may be able to copy  * saved-game files and play them.    */
end_comment

begin_macro
name|md_gct
argument_list|(
argument|rt_buf
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|rogue_time
modifier|*
name|rt_buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tm
modifier|*
name|t
decl_stmt|,
modifier|*
name|localtime
argument_list|()
decl_stmt|;
name|long
name|seconds
decl_stmt|;
name|time
argument_list|(
operator|&
name|seconds
argument_list|)
expr_stmt|;
name|t
operator|=
name|localtime
argument_list|(
operator|&
name|seconds
argument_list|)
expr_stmt|;
name|rt_buf
operator|->
name|year
operator|=
name|t
operator|->
name|tm_year
expr_stmt|;
name|rt_buf
operator|->
name|month
operator|=
name|t
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
name|rt_buf
operator|->
name|day
operator|=
name|t
operator|->
name|tm_mday
expr_stmt|;
name|rt_buf
operator|->
name|hour
operator|=
name|t
operator|->
name|tm_hour
expr_stmt|;
name|rt_buf
operator|->
name|minute
operator|=
name|t
operator|->
name|tm_min
expr_stmt|;
name|rt_buf
operator|->
name|second
operator|=
name|t
operator|->
name|tm_sec
expr_stmt|;
block|}
end_block

begin_comment
comment|/* md_gfmt: (Get File Modification Time)  *  * This routine returns a file's date of last modification in the same format  * as md_gct() above.  *  * This function is not strictly necessary.  It is used to see if saved-game  * files have been modified since they were saved.  If you have stubbed the  * routine md_gct() above by returning constant values, then you may do  * exactly the same here.  * Or if md_gct() is implemented correctly, but your system does not provide  * file modification dates, you may return some date far in the past so  * that the program will never know that a saved-game file being modified.    * You may also do this if you wish to be able to restore games from  * saved-games that have been modified.  */
end_comment

begin_macro
name|md_gfmt
argument_list|(
argument|fname
argument_list|,
argument|rt_buf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rogue_time
modifier|*
name|rt_buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
name|long
name|seconds
decl_stmt|;
name|struct
name|tm
modifier|*
name|t
decl_stmt|;
name|stat
argument_list|(
name|fname
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
name|seconds
operator|=
operator|(
name|long
operator|)
name|sbuf
operator|.
name|st_mtime
expr_stmt|;
name|t
operator|=
name|localtime
argument_list|(
operator|&
name|seconds
argument_list|)
expr_stmt|;
name|rt_buf
operator|->
name|year
operator|=
name|t
operator|->
name|tm_year
expr_stmt|;
name|rt_buf
operator|->
name|month
operator|=
name|t
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
name|rt_buf
operator|->
name|day
operator|=
name|t
operator|->
name|tm_mday
expr_stmt|;
name|rt_buf
operator|->
name|hour
operator|=
name|t
operator|->
name|tm_hour
expr_stmt|;
name|rt_buf
operator|->
name|minute
operator|=
name|t
operator|->
name|tm_min
expr_stmt|;
name|rt_buf
operator|->
name|second
operator|=
name|t
operator|->
name|tm_sec
expr_stmt|;
block|}
end_block

begin_comment
comment|/* md_df: (Delete File)  *  * This function deletes the specified file, and returns true (1) if the  * operation was successful.  This is used to delete saved-game files  * after restoring games from them.  *  * Again, this function is not strictly necessary, and can be stubbed  * by simply returning 1.  In this case, saved-game files will not be  * deleted and can be replayed.  */
end_comment

begin_function
name|boolean
name|md_df
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
if|if
condition|(
name|unlink
argument_list|(
name|fname
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* md_gln: (Get login name)  *  * This routine returns the login name of the user.  This string is  * used mainly for identifying users in score files.  *  * A dummy string may be returned if you are unable to implement this  * function, but then the score file would only have one name in it.  */
end_comment

begin_function
name|char
modifier|*
name|md_gln
parameter_list|()
block|{
name|struct
name|passwd
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
return|return
operator|(
name|p
operator|->
name|pw_name
operator|)
return|;
block|}
end_function

begin_comment
comment|/* md_sleep:  *  * This routine causes the game to pause for the specified number of  * seconds.  *  * This routine is not particularly necessary at all.  It is used for  * delaying execution, which is useful to this program at some times.  */
end_comment

begin_macro
name|md_sleep
argument_list|(
argument|nsecs
argument_list|)
end_macro

begin_decl_stmt
name|int
name|nsecs
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|sleep
argument_list|(
name|nsecs
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* md_getenv()  *  * This routine gets certain values from the user's environment.  These  * values are strings, and each string is identified by a name.  The names  * of the values needed, and their use, is as follows:  *  *   TERMCAP  *     The name of the users's termcap file, NOT the termcap entries  *     themselves.  This is used ONLY if the program is compiled with  *     CURSES defined (-DCURSES).  Even in this case, the program need  *     not find a string for TERMCAP.  If it does not, it will use the  *     default termcap file as returned by md_gdtcf();  *   TERM  *     The name of the users's terminal.  This is used ONLY if the program  *     is compiled with CURSES defined (-DCURSES).  In this case, the string  *     value for TERM must be found, or the routines in curses.c cannot  *     function, and the program will quit.  *   ROGUEOPTS  *     A string containing the various game options.  This need not be  *     defined.  *   HOME  *     The user's home directory.  This is only used when the user specifies  *     '~' as the first character of a saved-game file.  This string need  *     not be defined.  *   SHELL  *     The user's favorite shell.  If not found, "/bin/sh" is assumed.  *  * If your system does not provide a means of searching for these values,  * you will have to do it yourself.  None of the values above really need  * to be defined except TERM when the program is compiled with CURSES  * defined.  In this case, as a bare minimum, you can check the 'name'  * parameter, and if it is "TERM" find the terminal name and return that,  * else return zero.  If the program is not compiled with CURSES, you can  * get by with simply always returning zero.  Returning zero indicates  * that their is no defined value for the given string.  */
end_comment

begin_function
name|char
modifier|*
name|md_getenv
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|value
operator|=
name|getenv
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* md_malloc()  *  * This routine allocates, and returns a pointer to, the specified number  * of bytes.  This routines absolutely MUST be implemented for your  * particular system or the program will not run at all.  Return zero  * when no more memory can be allocated.  */
end_comment

begin_function
name|char
modifier|*
name|md_malloc
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|char
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/* md_gseed() (Get Seed)  *  * This function returns a seed for the random number generator (RNG).  This  * seed causes the RNG to begin generating numbers at some point in it's  * sequence.  Without a random seed, the RNG will generate the same set  * of numbers, and every game will start out exactly the same way.  A good  * number to use is the process id, given by getpid() on most UNIX systems.  *  * You need to find some single random integer, such as:  *   process id.  *   current time (minutes + seconds) returned from md_gct(), if implemented.  *     * It will not help to return "get_rand()" or "rand()" or the return value of  * any pseudo-RNG.  If you don't have a random number, you can just return 1,  * but this means your games will ALWAYS start the same way, and will play  * exactly the same way given the same input.  */
end_comment

begin_macro
name|md_gseed
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|getpid
argument_list|()
operator|)
return|;
block|}
end_block

begin_comment
comment|/* md_exit():  *  * This function causes the program to discontinue execution and exit.  * This function must be implemented or the program will continue to  * hang when it should quit.  */
end_comment

begin_macro
name|md_exit
argument_list|(
argument|status
argument_list|)
end_macro

begin_decl_stmt
name|int
name|status
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* md_lock():  *  * This function is intended to give the user exclusive access to the score  * file.  It does so by flock'ing the score file.  The full path name of the  * score file should be defined for any particular site in rogue.h.  The  * constants _PATH_SCOREFILE defines this file name.  *  * When the parameter 'l' is non-zero (true), a lock is requested.  Otherwise  * the lock is released.  */
end_comment

begin_macro
name|md_lock
argument_list|(
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|boolean
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|fd
decl_stmt|;
name|short
name|tries
decl_stmt|;
if|if
condition|(
name|l
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|_PATH_SCOREFILE
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|1
condition|)
block|{
name|message
argument_list|(
literal|"cannot lock score file"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|tries
operator|=
literal|0
init|;
name|tries
operator|<
literal|5
condition|;
name|tries
operator|++
control|)
if|if
condition|(
operator|!
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_NB
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* md_shell():  *  * This function spawns a shell for the user to use.  When this shell is  * terminated, the game continues.  Since this program may often be run  * setuid to gain access to privileged files, care is taken that the shell  * is run with the user's REAL user id, and not the effective user id.  * The effective user id is restored after the shell completes.  */
end_comment

begin_macro
name|md_shell
argument_list|(
argument|shell
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|shell
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|w
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|fork
argument_list|()
condition|)
block|{
name|int
name|uid
decl_stmt|;
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|setuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|execl
argument_list|(
name|shell
argument_list|,
name|shell
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|wait
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* If you have a viable curses/termlib library, then use it and don't bother  * implementing the routines below.  And don't compile with -DCURSES.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CURSES
end_ifdef

begin_comment
comment|/* md_cbreak_no_echo_nonl:  *  * This routine sets up some terminal characteristics.  The tty-driver  * must be told to:  *   1.)  Not echo input.  *   2.)  Transmit input characters immediately upon typing. (cbreak mode)  *   3.)  Move the cursor down one line, without changing column, and  *        without generating a carriage-return, when it  *        sees a line-feed.  This is only necessary if line-feed is ever  *        used in the termcap 'do' (cursor down) entry, in which case,  *        your system should must have a way of accomplishing this.  *  * When the parameter 'on' is true, the terminal is set up as specified  * above.  When this parameter is false, the terminal is restored to the  * original state.  *  * Raw mode should not to be used.  Keyboard signals/events/interrupts should  * be sent, although they are not strictly necessary.  See notes in  * md_heed_signals().  *  * This function must be implemented for rogue to run properly if the  * program is compiled with CURSES defined to use the enclosed curses  * emulation package.  If you are not using this, then this routine is  * totally unnecessary.  *   * Notice that information is saved between calls.  This is used to  * restore the terminal to an initial saved state.  *  */
end_comment

begin_macro
name|md_cbreak_no_echo_nonl
argument_list|(
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|boolean
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|UNIX_BSD4_2
specifier|static
name|struct
name|sgttyb
name|tty_buf
decl_stmt|;
specifier|static
name|int
name|tsave_flags
decl_stmt|;
if|if
condition|(
name|on
condition|)
block|{
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|tty_buf
argument_list|)
expr_stmt|;
name|tsave_flags
operator|=
name|tty_buf
operator|.
name|sg_flags
expr_stmt|;
name|tty_buf
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
name|tty_buf
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|CRMOD
operator|)
expr_stmt|;
comment|/* CRMOD: see note 3 above */
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|tty_buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tty_buf
operator|.
name|sg_flags
operator|=
name|tsave_flags
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|tty_buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UNIX_SYSV
name|struct
name|termio
name|tty_buf
decl_stmt|;
specifier|static
name|struct
name|termio
name|tty_save
decl_stmt|;
if|if
condition|(
name|on
condition|)
block|{
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|tty_buf
argument_list|)
expr_stmt|;
name|tty_save
operator|=
name|tty_buf
expr_stmt|;
name|tty_buf
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ICANON
operator||
name|ECHO
operator|)
expr_stmt|;
name|tty_buf
operator|.
name|c_oflag
operator|&=
operator|~
name|ONLCR
expr_stmt|;
name|tty_buf
operator|.
name|c_cc
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
comment|/* MIN */
name|tty_buf
operator|.
name|c_cc
index|[
literal|5
index|]
operator|=
literal|2
expr_stmt|;
comment|/* TIME */
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCSETAF
argument_list|,
operator|&
name|tty_buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCSETAF
argument_list|,
operator|&
name|tty_save
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* md_gdtcf(): (Get Default Termcap File)  *  * This function is called ONLY when the program is compiled with CURSES  * defined.  If you use your system's curses/termlib library, this function  * won't be called.  On most UNIX systems, "/etc/termcap" suffices.  *  * If their is no such termcap file, then return 0, but in that case, you  * must have a TERMCAP file returned from md_getenv("TERMCAP").  The latter  * will override the value returned from md_gdtcf().  If the program is  * compiled with CURSES defined, and md_gdtcf() returns 0, and  * md_getenv("TERMCAP") returns 0, the program will have no terminal  * capability information and will quit.  */
end_comment

begin_function
name|char
modifier|*
name|md_gdtcf
parameter_list|()
block|{
return|return
operator|(
literal|"/etc/termcap"
operator|)
return|;
block|}
end_function

begin_comment
comment|/* md_tstp():  *  * This function puts the game to sleep and returns to the shell.  This  * only applies to UNIX 4.2 and 4.3.  For other systems, the routine should  * be provided as a do-nothing routine.  md_tstp() will only be referenced  * in the code when compiled with CURSES defined.  *  */
end_comment

begin_macro
name|md_tstp
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|UNIX_BSD4_2
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

