begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Timothy C. Stoehr.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)move.c	5.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * move.c  *  * This source herein may be modified and/or distributed by anybody who  * so desires, with the following restrictions:  *    1.)  No portion of this notice shall be removed.  *    2.)  Credit shall not be taken for the creation of this source.  *    3.)  This code is not to be traded, sold, or used for personal  *         gain or profit.  *  */
end_comment

begin_include
include|#
directive|include
file|"rogue.h"
end_include

begin_decl_stmt
name|short
name|m_moves
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|jump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|you_can_move_again
init|=
literal|"you can move again"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|cur_room
decl_stmt|,
name|halluc
decl_stmt|,
name|blind
decl_stmt|,
name|levitate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|cur_level
decl_stmt|,
name|max_level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|bear_trap
decl_stmt|,
name|haste_self
decl_stmt|,
name|confused
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|e_rings
decl_stmt|,
name|regeneration
decl_stmt|,
name|auto_search
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|hunger_str
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|boolean
name|being_held
decl_stmt|,
name|interrupted
decl_stmt|,
name|r_teleport
decl_stmt|,
name|passgo
decl_stmt|;
end_decl_stmt

begin_macro
name|one_move_rogue
argument_list|(
argument|dirch
argument_list|,
argument|pickup
argument_list|)
end_macro

begin_decl_stmt
name|short
name|dirch
decl_stmt|,
name|pickup
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|row
decl_stmt|,
name|col
decl_stmt|;
name|object
modifier|*
name|obj
decl_stmt|;
name|char
name|desc
index|[
name|DCOLS
index|]
decl_stmt|;
name|short
name|n
decl_stmt|,
name|status
decl_stmt|,
name|d
decl_stmt|;
name|row
operator|=
name|rogue
operator|.
name|row
expr_stmt|;
name|col
operator|=
name|rogue
operator|.
name|col
expr_stmt|;
if|if
condition|(
name|confused
condition|)
block|{
name|dirch
operator|=
name|gr_dir
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|is_direction
argument_list|(
name|dirch
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|get_dir_rc
argument_list|(
name|d
argument_list|,
operator|&
name|row
argument_list|,
operator|&
name|col
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|can_move
argument_list|(
name|rogue
operator|.
name|row
argument_list|,
name|rogue
operator|.
name|col
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
condition|)
block|{
return|return
operator|(
name|MOVE_FAILED
operator|)
return|;
block|}
if|if
condition|(
name|being_held
operator|||
name|bear_trap
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dungeon
index|[
name|row
index|]
index|[
name|col
index|]
operator|&
name|MONSTER
operator|)
condition|)
block|{
if|if
condition|(
name|being_held
condition|)
block|{
name|message
argument_list|(
literal|"you are being held"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
literal|"you are still stuck in the bear trap"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|reg_move
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|MOVE_FAILED
operator|)
return|;
block|}
block|}
if|if
condition|(
name|r_teleport
condition|)
block|{
if|if
condition|(
name|rand_percent
argument_list|(
name|R_TELE_PERCENT
argument_list|)
condition|)
block|{
name|tele
argument_list|()
expr_stmt|;
return|return
operator|(
name|STOPPED_ON_SOMETHING
operator|)
return|;
block|}
block|}
if|if
condition|(
name|dungeon
index|[
name|row
index|]
index|[
name|col
index|]
operator|&
name|MONSTER
condition|)
block|{
name|rogue_hit
argument_list|(
name|object_at
argument_list|(
operator|&
name|level_monsters
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|reg_move
argument_list|()
expr_stmt|;
return|return
operator|(
name|MOVE_FAILED
operator|)
return|;
block|}
if|if
condition|(
name|dungeon
index|[
name|row
index|]
index|[
name|col
index|]
operator|&
name|DOOR
condition|)
block|{
if|if
condition|(
name|cur_room
operator|==
name|PASSAGE
condition|)
block|{
name|cur_room
operator|=
name|get_room_number
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|light_up_room
argument_list|(
name|cur_room
argument_list|)
expr_stmt|;
name|wake_room
argument_list|(
name|cur_room
argument_list|,
literal|1
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|light_passage
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|dungeon
index|[
name|rogue
operator|.
name|row
index|]
index|[
name|rogue
operator|.
name|col
index|]
operator|&
name|DOOR
operator|)
operator|&&
operator|(
name|dungeon
index|[
name|row
index|]
index|[
name|col
index|]
operator|&
name|TUNNEL
operator|)
condition|)
block|{
name|light_passage
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|wake_room
argument_list|(
name|cur_room
argument_list|,
literal|0
argument_list|,
name|rogue
operator|.
name|row
argument_list|,
name|rogue
operator|.
name|col
argument_list|)
expr_stmt|;
name|darken_room
argument_list|(
name|cur_room
argument_list|)
expr_stmt|;
name|cur_room
operator|=
name|PASSAGE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dungeon
index|[
name|row
index|]
index|[
name|col
index|]
operator|&
name|TUNNEL
condition|)
block|{
name|light_passage
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
name|mvaddch
argument_list|(
name|rogue
operator|.
name|row
argument_list|,
name|rogue
operator|.
name|col
argument_list|,
name|get_dungeon_char
argument_list|(
name|rogue
operator|.
name|row
argument_list|,
name|rogue
operator|.
name|col
argument_list|)
argument_list|)
expr_stmt|;
name|mvaddch
argument_list|(
name|row
argument_list|,
name|col
argument_list|,
name|rogue
operator|.
name|fchar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|jump
condition|)
block|{
name|refresh
argument_list|()
expr_stmt|;
block|}
name|rogue
operator|.
name|row
operator|=
name|row
expr_stmt|;
name|rogue
operator|.
name|col
operator|=
name|col
expr_stmt|;
if|if
condition|(
name|dungeon
index|[
name|row
index|]
index|[
name|col
index|]
operator|&
name|OBJECT
condition|)
block|{
if|if
condition|(
name|levitate
operator|&&
name|pickup
condition|)
block|{
return|return
operator|(
name|STOPPED_ON_SOMETHING
operator|)
return|;
block|}
if|if
condition|(
name|pickup
operator|&&
operator|!
name|levitate
condition|)
block|{
if|if
condition|(
name|obj
operator|=
name|pick_up
argument_list|(
name|row
argument_list|,
name|col
argument_list|,
operator|&
name|status
argument_list|)
condition|)
block|{
name|get_desc
argument_list|(
name|obj
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|what_is
operator|==
name|GOLD
condition|)
block|{
name|free_object
argument_list|(
name|obj
argument_list|)
expr_stmt|;
goto|goto
name|NOT_IN_PACK
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|status
condition|)
block|{
goto|goto
name|MVED
goto|;
block|}
else|else
block|{
goto|goto
name|MOVE_ON
goto|;
block|}
block|}
else|else
block|{
name|MOVE_ON
label|:
name|obj
operator|=
name|object_at
argument_list|(
operator|&
name|level_objects
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|desc
argument_list|,
literal|"moved onto "
argument_list|)
expr_stmt|;
name|get_desc
argument_list|(
name|obj
argument_list|,
name|desc
operator|+
literal|11
argument_list|)
expr_stmt|;
goto|goto
name|NOT_IN_PACK
goto|;
block|}
name|n
operator|=
name|strlen
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|desc
index|[
name|n
index|]
operator|=
literal|'('
expr_stmt|;
name|desc
index|[
name|n
operator|+
literal|1
index|]
operator|=
name|obj
operator|->
name|ichar
expr_stmt|;
name|desc
index|[
name|n
operator|+
literal|2
index|]
operator|=
literal|')'
expr_stmt|;
name|desc
index|[
name|n
operator|+
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|NOT_IN_PACK
label|:
name|message
argument_list|(
name|desc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|reg_move
argument_list|()
expr_stmt|;
return|return
operator|(
name|STOPPED_ON_SOMETHING
operator|)
return|;
block|}
if|if
condition|(
name|dungeon
index|[
name|row
index|]
index|[
name|col
index|]
operator|&
operator|(
name|DOOR
operator||
name|STAIRS
operator||
name|TRAP
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|levitate
operator|)
operator|&&
operator|(
name|dungeon
index|[
name|row
index|]
index|[
name|col
index|]
operator|&
name|TRAP
operator|)
condition|)
block|{
name|trap_player
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|reg_move
argument_list|()
expr_stmt|;
return|return
operator|(
name|STOPPED_ON_SOMETHING
operator|)
return|;
block|}
name|MVED
label|:
if|if
condition|(
name|reg_move
argument_list|()
condition|)
block|{
comment|/* fainted from hunger */
return|return
operator|(
name|STOPPED_ON_SOMETHING
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|confused
condition|?
name|STOPPED_ON_SOMETHING
else|:
name|MOVED
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|multiple_move_rogue
argument_list|(
argument|dirch
argument_list|)
end_macro

begin_decl_stmt
name|short
name|dirch
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|row
decl_stmt|,
name|col
decl_stmt|;
name|short
name|m
decl_stmt|;
switch|switch
condition|(
name|dirch
condition|)
block|{
case|case
literal|'\010'
case|:
case|case
literal|'\012'
case|:
case|case
literal|'\013'
case|:
case|case
literal|'\014'
case|:
case|case
literal|'\031'
case|:
case|case
literal|'\025'
case|:
case|case
literal|'\016'
case|:
case|case
literal|'\002'
case|:
do|do
block|{
name|row
operator|=
name|rogue
operator|.
name|row
expr_stmt|;
name|col
operator|=
name|rogue
operator|.
name|col
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|m
operator|=
name|one_move_rogue
argument_list|(
operator|(
name|dirch
operator|+
literal|96
operator|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|MOVE_FAILED
operator|)
operator|||
operator|(
name|m
operator|==
name|STOPPED_ON_SOMETHING
operator|)
operator|||
name|interrupted
condition|)
block|{
break|break;
block|}
block|}
do|while
condition|(
operator|!
name|next_to_something
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
condition|)
do|;
if|if
condition|(
operator|(
operator|!
name|interrupted
operator|)
operator|&&
name|passgo
operator|&&
operator|(
name|m
operator|==
name|MOVE_FAILED
operator|)
operator|&&
operator|(
name|dungeon
index|[
name|rogue
operator|.
name|row
index|]
index|[
name|rogue
operator|.
name|col
index|]
operator|&
name|TUNNEL
operator|)
condition|)
block|{
name|turn_passage
argument_list|(
name|dirch
operator|+
literal|96
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'H'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'B'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'U'
case|:
case|case
literal|'N'
case|:
while|while
condition|(
operator|(
operator|!
name|interrupted
operator|)
operator|&&
operator|(
name|one_move_rogue
argument_list|(
operator|(
name|dirch
operator|+
literal|32
operator|)
argument_list|,
literal|1
argument_list|)
operator|==
name|MOVED
operator|)
condition|)
empty_stmt|;
if|if
condition|(
operator|(
operator|!
name|interrupted
operator|)
operator|&&
name|passgo
operator|&&
operator|(
name|dungeon
index|[
name|rogue
operator|.
name|row
index|]
index|[
name|rogue
operator|.
name|col
index|]
operator|&
name|TUNNEL
operator|)
condition|)
block|{
name|turn_passage
argument_list|(
name|dirch
operator|+
literal|32
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_block

begin_expr_stmt
name|is_passable
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
specifier|register
name|row
operator|,
name|col
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|row
operator|<
name|MIN_ROW
operator|)
operator|||
operator|(
name|row
operator|>
operator|(
name|DROWS
operator|-
literal|2
operator|)
operator|)
operator|||
operator|(
name|col
operator|<
literal|0
operator|)
operator|||
operator|(
name|col
operator|>
operator|(
name|DCOLS
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|dungeon
index|[
name|row
index|]
index|[
name|col
index|]
operator|&
name|HIDDEN
condition|)
block|{
return|return
operator|(
operator|(
name|dungeon
index|[
name|row
index|]
index|[
name|col
index|]
operator|&
name|TRAP
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|dungeon
index|[
name|row
index|]
index|[
name|col
index|]
operator|&
operator|(
name|FLOOR
operator||
name|TUNNEL
operator||
name|DOOR
operator||
name|STAIRS
operator||
name|TRAP
operator|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|next_to_something
argument_list|(
name|drow
argument_list|,
name|dcol
argument_list|)
specifier|register
name|drow
operator|,
name|dcol
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|short
name|i
decl_stmt|,
name|j
decl_stmt|,
name|i_end
decl_stmt|,
name|j_end
decl_stmt|,
name|row
decl_stmt|,
name|col
decl_stmt|;
name|short
name|pass_count
init|=
literal|0
decl_stmt|;
name|unsigned
name|short
name|s
decl_stmt|;
if|if
condition|(
name|confused
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|blind
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|i_end
operator|=
operator|(
name|rogue
operator|.
name|row
operator|<
operator|(
name|DROWS
operator|-
literal|2
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|j_end
operator|=
operator|(
name|rogue
operator|.
name|col
operator|<
operator|(
name|DCOLS
operator|-
literal|1
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
operator|(
name|rogue
operator|.
name|row
operator|>
name|MIN_ROW
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
init|;
name|i
operator|<=
name|i_end
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
operator|(
operator|(
name|rogue
operator|.
name|col
operator|>
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
init|;
name|j
operator|<=
name|j_end
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
operator|(
name|j
operator|==
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
operator|(
name|rogue
operator|.
name|row
operator|+
name|i
operator|)
operator|==
name|drow
operator|)
operator|&&
operator|(
operator|(
name|rogue
operator|.
name|col
operator|+
name|j
operator|)
operator|==
name|dcol
operator|)
condition|)
block|{
continue|continue;
block|}
name|row
operator|=
name|rogue
operator|.
name|row
operator|+
name|i
expr_stmt|;
name|col
operator|=
name|rogue
operator|.
name|col
operator|+
name|j
expr_stmt|;
name|s
operator|=
name|dungeon
index|[
name|row
index|]
index|[
name|col
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|&
name|HIDDEN
condition|)
block|{
continue|continue;
block|}
comment|/* If the rogue used to be right, up, left, down, or right of 			 * row,col, and now isn't, then don't stop */
if|if
condition|(
name|s
operator|&
operator|(
name|MONSTER
operator||
name|OBJECT
operator||
name|STAIRS
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|row
operator|==
name|drow
operator|)
operator|||
operator|(
name|col
operator|==
name|dcol
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
operator|(
name|row
operator|==
name|rogue
operator|.
name|row
operator|)
operator|||
operator|(
name|col
operator|==
name|rogue
operator|.
name|col
operator|)
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|s
operator|&
name|TRAP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|s
operator|&
name|HIDDEN
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|row
operator|==
name|drow
operator|)
operator|||
operator|(
name|col
operator|==
name|dcol
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
operator|(
name|row
operator|==
name|rogue
operator|.
name|row
operator|)
operator|||
operator|(
name|col
operator|==
name|rogue
operator|.
name|col
operator|)
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
operator|(
name|i
operator|-
name|j
operator|)
operator|==
literal|1
operator|)
operator|||
operator|(
operator|(
name|i
operator|-
name|j
operator|)
operator|==
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|s
operator|&
name|TUNNEL
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|pass_count
operator|>
literal|1
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|s
operator|&
name|DOOR
operator|)
operator|&&
operator|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|||
operator|(
name|j
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|can_move
argument_list|(
argument|row1
argument_list|,
argument|col1
argument_list|,
argument|row2
argument_list|,
argument|col2
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|is_passable
argument_list|(
name|row2
argument_list|,
name|col2
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|row1
operator|!=
name|row2
operator|)
operator|&&
operator|(
name|col1
operator|!=
name|col2
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|dungeon
index|[
name|row1
index|]
index|[
name|col1
index|]
operator|&
name|DOOR
operator|)
operator|||
operator|(
name|dungeon
index|[
name|row2
index|]
index|[
name|col2
index|]
operator|&
name|DOOR
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|!
name|dungeon
index|[
name|row1
index|]
index|[
name|col2
index|]
operator|)
operator|||
operator|(
operator|!
name|dungeon
index|[
name|row2
index|]
index|[
name|col1
index|]
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|move_onto
argument_list|()
end_macro

begin_block
block|{
name|short
name|ch
decl_stmt|,
name|d
decl_stmt|;
name|boolean
name|first_miss
init|=
literal|1
decl_stmt|;
while|while
condition|(
operator|!
name|is_direction
argument_list|(
name|ch
operator|=
name|rgetchar
argument_list|()
argument_list|,
operator|&
name|d
argument_list|)
condition|)
block|{
name|sound_bell
argument_list|()
expr_stmt|;
if|if
condition|(
name|first_miss
condition|)
block|{
name|message
argument_list|(
literal|"direction? "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|first_miss
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|check_message
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
name|CANCEL
condition|)
block|{
operator|(
name|void
operator|)
name|one_move_rogue
argument_list|(
name|ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|boolean
name|is_direction
parameter_list|(
name|c
parameter_list|,
name|d
parameter_list|)
name|short
name|c
decl_stmt|;
name|short
modifier|*
name|d
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'h'
case|:
operator|*
name|d
operator|=
name|LEFT
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
operator|*
name|d
operator|=
name|DOWN
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
operator|*
name|d
operator|=
name|UPWARD
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
operator|*
name|d
operator|=
name|RIGHT
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|d
operator|=
name|DOWNLEFT
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
operator|*
name|d
operator|=
name|UPLEFT
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
operator|*
name|d
operator|=
name|UPRIGHT
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|d
operator|=
name|DOWNRIGHT
expr_stmt|;
break|break;
case|case
name|CANCEL
case|:
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|boolean
name|check_hunger
parameter_list|(
name|msg_only
parameter_list|)
name|boolean
name|msg_only
decl_stmt|;
block|{
specifier|register
name|short
name|i
decl_stmt|,
name|n
decl_stmt|;
name|boolean
name|fainted
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rogue
operator|.
name|moves_left
operator|==
name|HUNGRY
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hunger_str
argument_list|,
literal|"hungry"
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|hunger_str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_stats
argument_list|(
name|STAT_HUNGER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rogue
operator|.
name|moves_left
operator|==
name|WEAK
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hunger_str
argument_list|,
literal|"weak"
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|hunger_str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|print_stats
argument_list|(
name|STAT_HUNGER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rogue
operator|.
name|moves_left
operator|<=
name|FAINT
condition|)
block|{
if|if
condition|(
name|rogue
operator|.
name|moves_left
operator|==
name|FAINT
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hunger_str
argument_list|,
literal|"faint"
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|hunger_str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|print_stats
argument_list|(
name|STAT_HUNGER
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|get_rand
argument_list|(
literal|0
argument_list|,
operator|(
name|FAINT
operator|-
name|rogue
operator|.
name|moves_left
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|fainted
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rand_percent
argument_list|(
literal|40
argument_list|)
condition|)
block|{
name|rogue
operator|.
name|moves_left
operator|++
expr_stmt|;
block|}
name|message
argument_list|(
literal|"you faint"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|coin_toss
argument_list|()
condition|)
block|{
name|mv_mons
argument_list|()
expr_stmt|;
block|}
block|}
name|message
argument_list|(
name|you_can_move_again
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|msg_only
condition|)
block|{
return|return
operator|(
name|fainted
operator|)
return|;
block|}
if|if
condition|(
name|rogue
operator|.
name|moves_left
operator|<=
name|STARVE
condition|)
block|{
name|killed_by
argument_list|(
operator|(
name|object
operator|*
operator|)
literal|0
argument_list|,
name|STARVATION
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|e_rings
condition|)
block|{
comment|/*case -2: 		Subtract 0, i.e. do nothing. 		break;*/
case|case
operator|-
literal|1
case|:
name|rogue
operator|.
name|moves_left
operator|-=
operator|(
name|rogue
operator|.
name|moves_left
operator|%
literal|2
operator|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|rogue
operator|.
name|moves_left
operator|--
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|rogue
operator|.
name|moves_left
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|check_hunger
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rogue
operator|.
name|moves_left
operator|-=
operator|(
name|rogue
operator|.
name|moves_left
operator|%
literal|2
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|rogue
operator|.
name|moves_left
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|check_hunger
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rogue
operator|.
name|moves_left
operator|--
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|fainted
operator|)
return|;
block|}
end_function

begin_function
name|boolean
name|reg_move
parameter_list|()
block|{
name|boolean
name|fainted
decl_stmt|;
if|if
condition|(
operator|(
name|rogue
operator|.
name|moves_left
operator|<=
name|HUNGRY
operator|)
operator|||
operator|(
name|cur_level
operator|>=
name|max_level
operator|)
condition|)
block|{
name|fainted
operator|=
name|check_hunger
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fainted
operator|=
literal|0
expr_stmt|;
block|}
name|mv_mons
argument_list|()
expr_stmt|;
if|if
condition|(
operator|++
name|m_moves
operator|>=
literal|120
condition|)
block|{
name|m_moves
operator|=
literal|0
expr_stmt|;
name|wanderer
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|halluc
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|--
name|halluc
operator|)
condition|)
block|{
name|unhallucinate
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|hallucinate
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|blind
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|--
name|blind
operator|)
condition|)
block|{
name|unblind
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|confused
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|--
name|confused
operator|)
condition|)
block|{
name|unconfuse
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bear_trap
condition|)
block|{
name|bear_trap
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|levitate
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|--
name|levitate
operator|)
condition|)
block|{
name|message
argument_list|(
literal|"you float gently to the ground"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dungeon
index|[
name|rogue
operator|.
name|row
index|]
index|[
name|rogue
operator|.
name|col
index|]
operator|&
name|TRAP
condition|)
block|{
name|trap_player
argument_list|(
name|rogue
operator|.
name|row
argument_list|,
name|rogue
operator|.
name|col
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|haste_self
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|--
name|haste_self
operator|)
condition|)
block|{
name|message
argument_list|(
literal|"you feel yourself slowing down"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|heal
argument_list|()
expr_stmt|;
if|if
condition|(
name|auto_search
operator|>
literal|0
condition|)
block|{
name|search
argument_list|(
name|auto_search
argument_list|,
name|auto_search
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fainted
operator|)
return|;
block|}
end_function

begin_macro
name|rest
argument_list|(
argument|count
argument_list|)
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|interrupted
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|interrupted
condition|)
block|{
break|break;
block|}
operator|(
name|void
operator|)
name|reg_move
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|gr_dir
argument_list|()
end_macro

begin_block
block|{
name|short
name|d
decl_stmt|;
name|d
operator|=
name|get_rand
argument_list|(
literal|1
argument_list|,
literal|8
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
condition|)
block|{
case|case
literal|1
case|:
name|d
operator|=
literal|'j'
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|d
operator|=
literal|'k'
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|d
operator|=
literal|'l'
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|d
operator|=
literal|'h'
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|d
operator|=
literal|'y'
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|d
operator|=
literal|'u'
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|d
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|d
operator|=
literal|'n'
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|d
operator|)
return|;
block|}
end_block

begin_macro
name|heal
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|short
name|heal_exp
init|=
operator|-
literal|1
decl_stmt|,
name|n
decl_stmt|,
name|c
init|=
literal|0
decl_stmt|;
specifier|static
name|boolean
name|alt
decl_stmt|;
if|if
condition|(
name|rogue
operator|.
name|hp_current
operator|==
name|rogue
operator|.
name|hp_max
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rogue
operator|.
name|exp
operator|!=
name|heal_exp
condition|)
block|{
name|heal_exp
operator|=
name|rogue
operator|.
name|exp
expr_stmt|;
switch|switch
condition|(
name|heal_exp
condition|)
block|{
case|case
literal|1
case|:
name|n
operator|=
literal|20
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|n
operator|=
literal|18
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|n
operator|=
literal|17
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|n
operator|=
literal|14
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|n
operator|=
literal|13
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|n
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|n
operator|=
literal|9
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|n
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|n
operator|=
literal|7
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|n
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|n
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|12
case|:
default|default:
name|n
operator|=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|++
name|c
operator|>=
name|n
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
name|rogue
operator|.
name|hp_current
operator|++
expr_stmt|;
if|if
condition|(
name|alt
operator|=
operator|!
name|alt
condition|)
block|{
name|rogue
operator|.
name|hp_current
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rogue
operator|.
name|hp_current
operator|+=
name|regeneration
operator|)
operator|>
name|rogue
operator|.
name|hp_max
condition|)
block|{
name|rogue
operator|.
name|hp_current
operator|=
name|rogue
operator|.
name|hp_max
expr_stmt|;
block|}
name|print_stats
argument_list|(
name|STAT_HP
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|boolean
name|can_turn
parameter_list|(
name|nrow
parameter_list|,
name|ncol
parameter_list|)
name|short
name|nrow
decl_stmt|,
name|ncol
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|dungeon
index|[
name|nrow
index|]
index|[
name|ncol
index|]
operator|&
name|TUNNEL
operator|)
operator|&&
name|is_passable
argument_list|(
name|nrow
argument_list|,
name|ncol
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|turn_passage
argument_list|(
argument|dir
argument_list|,
argument|fast
argument_list|)
end_macro

begin_decl_stmt
name|short
name|dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|fast
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|crow
init|=
name|rogue
operator|.
name|row
decl_stmt|,
name|ccol
init|=
name|rogue
operator|.
name|col
decl_stmt|,
name|turns
init|=
literal|0
decl_stmt|;
name|short
name|ndir
decl_stmt|;
if|if
condition|(
operator|(
name|dir
operator|!=
literal|'h'
operator|)
operator|&&
name|can_turn
argument_list|(
name|crow
argument_list|,
name|ccol
operator|+
literal|1
argument_list|)
condition|)
block|{
name|turns
operator|++
expr_stmt|;
name|ndir
operator|=
literal|'l'
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dir
operator|!=
literal|'l'
operator|)
operator|&&
name|can_turn
argument_list|(
name|crow
argument_list|,
name|ccol
operator|-
literal|1
argument_list|)
condition|)
block|{
name|turns
operator|++
expr_stmt|;
name|ndir
operator|=
literal|'h'
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dir
operator|!=
literal|'k'
operator|)
operator|&&
name|can_turn
argument_list|(
name|crow
operator|+
literal|1
argument_list|,
name|ccol
argument_list|)
condition|)
block|{
name|turns
operator|++
expr_stmt|;
name|ndir
operator|=
literal|'j'
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dir
operator|!=
literal|'j'
operator|)
operator|&&
name|can_turn
argument_list|(
name|crow
operator|-
literal|1
argument_list|,
name|ccol
argument_list|)
condition|)
block|{
name|turns
operator|++
expr_stmt|;
name|ndir
operator|=
literal|'k'
expr_stmt|;
block|}
if|if
condition|(
name|turns
operator|==
literal|1
condition|)
block|{
name|multiple_move_rogue
argument_list|(
name|ndir
operator|-
operator|(
name|fast
condition|?
literal|32
else|:
literal|96
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

