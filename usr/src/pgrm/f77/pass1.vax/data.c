begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)data.c	5.2 (Berkeley) 1/3/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * data.c  *  * Routines for handling DATA statements, f77 compiler, 4.2 BSD.  *  * University of Utah CS Dept modification history:  *  * Revision 3.1  84/10/13  01:09:50  donn  * Installed Jerry Berkman's version; added UofU comment header.  *   */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"data.h"
end_include

begin_comment
comment|/*  global variables  */
end_comment

begin_decl_stmt
name|flag
name|overlapflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  local variables  */
end_comment

begin_decl_stmt
name|LOCAL
name|char
name|rstatus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|ftnint
name|rvalue
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|dovars
modifier|*
name|dvlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|dataerror
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|vallist
modifier|*
name|grvals
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|datafile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|int
name|chkfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|long
name|base
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  Copied from expr.c  */
end_comment

begin_function
name|LOCAL
name|letter
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|-
literal|'a'
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|vexpr
modifier|*
name|cpdvalue
parameter_list|(
name|dp
parameter_list|)
name|vexpr
modifier|*
name|dp
decl_stmt|;
block|{
specifier|register
name|dvalue
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|tag
operator|!=
name|DVALUE
condition|)
name|badtag
argument_list|(
literal|"cpdvalue"
argument_list|,
name|dp
operator|->
name|tag
argument_list|)
expr_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Dvalue
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|DVALUE
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|dp
operator|->
name|dvalue
operator|.
name|status
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|dp
operator|->
name|dvalue
operator|.
name|value
expr_stmt|;
return|return
operator|(
operator|(
name|vexpr
operator|*
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_expr_stmt
name|frvexpr
argument_list|(
name|vp
argument_list|)
specifier|register
name|vexpr
operator|*
name|vp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|tag
operator|==
name|DNAME
condition|)
name|free
argument_list|(
name|vp
operator|->
name|dname
operator|.
name|repr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vp
operator|->
name|tag
operator|==
name|DEXPR
condition|)
block|{
name|frvexpr
argument_list|(
name|vp
operator|->
name|dexpr
operator|.
name|left
argument_list|)
expr_stmt|;
name|frvexpr
argument_list|(
name|vp
operator|->
name|dexpr
operator|.
name|right
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
name|frvlist
argument_list|(
name|vp
argument_list|)
specifier|register
name|vlist
operator|*
name|vp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|vlist
modifier|*
name|t
decl_stmt|;
while|while
condition|(
name|vp
condition|)
block|{
name|t
operator|=
name|vp
operator|->
name|next
expr_stmt|;
name|frvexpr
argument_list|(
name|vp
operator|->
name|val
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|t
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_escape
end_escape

begin_macro
name|frelist
argument_list|(
argument|ep
argument_list|)
end_macro

begin_decl_stmt
name|elist
modifier|*
name|ep
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|elist
modifier|*
name|p
decl_stmt|;
specifier|register
name|elist
modifier|*
name|t
decl_stmt|;
specifier|register
name|aelt
modifier|*
name|ap
decl_stmt|;
specifier|register
name|dolist
modifier|*
name|dp
decl_stmt|;
name|p
operator|=
name|ep
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|elt
operator|->
name|tag
operator|==
name|SIMPLE
condition|)
block|{
name|ap
operator|=
operator|(
name|aelt
operator|*
operator|)
name|p
operator|->
name|elt
expr_stmt|;
name|frvlist
argument_list|(
name|ap
operator|->
name|subs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|range
operator|!=
name|NULL
condition|)
block|{
name|frvexpr
argument_list|(
name|ap
operator|->
name|range
operator|->
name|low
argument_list|)
expr_stmt|;
name|frvexpr
argument_list|(
name|ap
operator|->
name|range
operator|->
name|high
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ap
operator|->
name|range
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dp
operator|=
operator|(
name|dolist
operator|*
operator|)
name|p
operator|->
name|elt
expr_stmt|;
name|frvexpr
argument_list|(
name|dp
operator|->
name|dovar
argument_list|)
expr_stmt|;
name|frvexpr
argument_list|(
name|dp
operator|->
name|init
argument_list|)
expr_stmt|;
name|frvexpr
argument_list|(
name|dp
operator|->
name|limit
argument_list|)
expr_stmt|;
name|frvexpr
argument_list|(
name|dp
operator|->
name|step
argument_list|)
expr_stmt|;
name|frelist
argument_list|(
name|dp
operator|->
name|elts
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_escape
end_escape

begin_macro
name|frvallist
argument_list|(
argument|vp
argument_list|)
end_macro

begin_decl_stmt
name|vallist
modifier|*
name|vp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|vallist
modifier|*
name|p
decl_stmt|;
specifier|register
name|vallist
modifier|*
name|t
decl_stmt|;
name|p
operator|=
name|vp
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|frexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|p
operator|->
name|value
argument_list|)
expr_stmt|;
name|t
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_escape
end_escape

begin_function
name|elist
modifier|*
name|revelist
parameter_list|(
name|ep
parameter_list|)
specifier|register
name|elist
modifier|*
name|ep
decl_stmt|;
block|{
specifier|register
name|elist
modifier|*
name|next
decl_stmt|;
specifier|register
name|elist
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|ep
operator|->
name|next
expr_stmt|;
name|ep
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|t
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|next
operator|->
name|next
operator|=
name|ep
expr_stmt|;
name|ep
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|t
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ep
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|vlist
modifier|*
name|revvlist
parameter_list|(
name|vp
parameter_list|)
name|vlist
modifier|*
name|vp
decl_stmt|;
block|{
specifier|register
name|vlist
modifier|*
name|p
decl_stmt|;
specifier|register
name|vlist
modifier|*
name|next
decl_stmt|;
specifier|register
name|vlist
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
name|p
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|p
operator|=
name|vp
expr_stmt|;
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|t
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|next
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|t
expr_stmt|;
block|}
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|vallist
modifier|*
name|revrvals
parameter_list|(
name|vp
parameter_list|)
name|vallist
modifier|*
name|vp
decl_stmt|;
block|{
specifier|register
name|vallist
modifier|*
name|p
decl_stmt|;
specifier|register
name|vallist
modifier|*
name|next
decl_stmt|;
specifier|register
name|vallist
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
name|p
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|p
operator|=
name|vp
expr_stmt|;
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|t
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|next
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|t
expr_stmt|;
block|}
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|vlist
modifier|*
name|prepvexpr
parameter_list|(
name|tail
parameter_list|,
name|head
parameter_list|)
name|vlist
modifier|*
name|tail
decl_stmt|;
name|vexpr
modifier|*
name|head
decl_stmt|;
block|{
specifier|register
name|vlist
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Vlist
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|tail
expr_stmt|;
name|p
operator|->
name|val
operator|=
name|head
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|elist
modifier|*
name|preplval
parameter_list|(
name|tail
parameter_list|,
name|head
parameter_list|)
name|elist
modifier|*
name|tail
decl_stmt|;
name|delt
modifier|*
name|head
decl_stmt|;
block|{
specifier|register
name|elist
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Elist
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|tail
expr_stmt|;
name|p
operator|->
name|elt
operator|=
name|head
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|delt
modifier|*
name|mkdlval
parameter_list|(
name|name
parameter_list|,
name|subs
parameter_list|,
name|range
parameter_list|)
name|vexpr
modifier|*
name|name
decl_stmt|;
name|vlist
modifier|*
name|subs
decl_stmt|;
name|rpair
modifier|*
name|range
decl_stmt|;
block|{
specifier|register
name|aelt
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Aelt
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|SIMPLE
expr_stmt|;
name|p
operator|->
name|var
operator|=
name|mkname
argument_list|(
name|name
operator|->
name|dname
operator|.
name|len
argument_list|,
name|name
operator|->
name|dname
operator|.
name|repr
argument_list|)
expr_stmt|;
name|p
operator|->
name|subs
operator|=
name|subs
expr_stmt|;
name|p
operator|->
name|range
operator|=
name|range
expr_stmt|;
return|return
operator|(
operator|(
name|delt
operator|*
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|delt
modifier|*
name|mkdatado
parameter_list|(
name|lvals
parameter_list|,
name|dovar
parameter_list|,
name|params
parameter_list|)
name|elist
modifier|*
name|lvals
decl_stmt|;
name|vexpr
modifier|*
name|dovar
decl_stmt|;
name|vlist
modifier|*
name|params
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|toofew
init|=
literal|"missing loop parameters"
decl_stmt|;
specifier|static
name|char
modifier|*
name|toomany
init|=
literal|"too many loop parameters"
decl_stmt|;
specifier|register
name|dolist
modifier|*
name|p
decl_stmt|;
specifier|register
name|vlist
modifier|*
name|vp
decl_stmt|;
specifier|register
name|int
name|pcnt
decl_stmt|;
specifier|register
name|dvalue
modifier|*
name|one
decl_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|DoList
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|NESTED
expr_stmt|;
name|p
operator|->
name|elts
operator|=
name|revelist
argument_list|(
name|lvals
argument_list|)
expr_stmt|;
name|p
operator|->
name|dovar
operator|=
name|dovar
expr_stmt|;
name|vp
operator|=
name|params
expr_stmt|;
name|pcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|vp
condition|)
block|{
name|pcnt
operator|++
expr_stmt|;
name|vp
operator|=
name|vp
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|pcnt
operator|!=
literal|2
operator|&&
name|pcnt
operator|!=
literal|3
condition|)
block|{
if|if
condition|(
name|pcnt
operator|<
literal|2
condition|)
name|err
argument_list|(
name|toofew
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
name|toomany
argument_list|)
expr_stmt|;
name|p
operator|->
name|init
operator|=
operator|(
name|vexpr
operator|*
operator|)
name|ALLOC
argument_list|(
name|Derror
argument_list|)
expr_stmt|;
name|p
operator|->
name|init
operator|->
name|tag
operator|=
name|DERROR
expr_stmt|;
name|p
operator|->
name|limit
operator|=
operator|(
name|vexpr
operator|*
operator|)
name|ALLOC
argument_list|(
name|Derror
argument_list|)
expr_stmt|;
name|p
operator|->
name|limit
operator|->
name|tag
operator|=
name|DERROR
expr_stmt|;
name|p
operator|->
name|step
operator|=
operator|(
name|vexpr
operator|*
operator|)
name|ALLOC
argument_list|(
name|Derror
argument_list|)
expr_stmt|;
name|p
operator|->
name|step
operator|->
name|tag
operator|=
name|DERROR
expr_stmt|;
block|}
else|else
block|{
name|vp
operator|=
name|params
expr_stmt|;
if|if
condition|(
name|pcnt
operator|==
literal|2
condition|)
block|{
name|one
operator|=
name|ALLOC
argument_list|(
name|Dvalue
argument_list|)
expr_stmt|;
name|one
operator|->
name|tag
operator|=
name|DVALUE
expr_stmt|;
name|one
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|one
operator|->
name|value
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|step
operator|=
operator|(
name|vexpr
operator|*
operator|)
name|one
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|step
operator|=
name|vp
operator|->
name|val
expr_stmt|;
name|vp
operator|->
name|val
operator|=
name|NULL
expr_stmt|;
name|vp
operator|=
name|vp
operator|->
name|next
expr_stmt|;
block|}
name|p
operator|->
name|limit
operator|=
name|vp
operator|->
name|val
expr_stmt|;
name|vp
operator|->
name|val
operator|=
name|NULL
expr_stmt|;
name|vp
operator|=
name|vp
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|init
operator|=
name|vp
operator|->
name|val
expr_stmt|;
name|vp
operator|->
name|val
operator|=
name|NULL
expr_stmt|;
block|}
name|frvlist
argument_list|(
name|params
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|delt
operator|*
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|rpair
modifier|*
name|mkdrange
parameter_list|(
name|lb
parameter_list|,
name|ub
parameter_list|)
name|vexpr
modifier|*
name|lb
decl_stmt|,
decl|*
name|ub
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|rpair
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Rpair
argument_list|)
expr_stmt|;
name|p
operator|->
name|low
operator|=
name|lb
expr_stmt|;
name|p
operator|->
name|high
operator|=
name|ub
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_function
name|vallist
modifier|*
name|mkdrval
parameter_list|(
name|repl
parameter_list|,
name|val
parameter_list|)
name|vexpr
modifier|*
name|repl
decl_stmt|;
name|expptr
name|val
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|badtag
init|=
literal|"bad tag in mkdrval"
decl_stmt|;
specifier|static
name|char
modifier|*
name|negrepl
init|=
literal|"negative replicator"
decl_stmt|;
specifier|static
name|char
modifier|*
name|zerorepl
init|=
literal|"zero replicator"
decl_stmt|;
specifier|static
name|char
modifier|*
name|toobig
init|=
literal|"replicator too large"
decl_stmt|;
specifier|static
name|char
modifier|*
name|nonconst
init|=
literal|"%s is not a constant"
decl_stmt|;
specifier|register
name|vexpr
modifier|*
name|vp
decl_stmt|;
specifier|register
name|vallist
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
specifier|register
name|ftnint
name|value
decl_stmt|;
specifier|register
name|int
name|copied
decl_stmt|;
name|copied
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|repl
operator|->
name|tag
operator|==
name|DNAME
condition|)
block|{
name|vp
operator|=
name|evaldname
argument_list|(
name|repl
argument_list|)
expr_stmt|;
name|copied
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|vp
operator|=
name|repl
expr_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|ValList
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|value
operator|=
operator|(
name|Constp
operator|)
name|val
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|tag
operator|==
name|DVALUE
condition|)
block|{
name|status
operator|=
name|vp
operator|->
name|dvalue
operator|.
name|status
expr_stmt|;
name|value
operator|=
name|vp
operator|->
name|dvalue
operator|.
name|value
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|==
name|NORMAL
operator|&&
name|value
operator|<
literal|0
operator|)
operator|||
name|status
operator|==
name|MINLESS1
condition|)
block|{
name|err
argument_list|(
name|negrepl
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|NORMAL
condition|)
block|{
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|warn
argument_list|(
name|zerorepl
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|p
operator|->
name|repl
operator|=
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|MAXPLUS1
condition|)
block|{
name|err
argument_list|(
name|toobig
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
block|}
else|else
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|tag
operator|==
name|DNAME
condition|)
block|{
name|errnm
argument_list|(
name|nonconst
argument_list|,
name|vp
operator|->
name|dname
operator|.
name|len
argument_list|,
name|vp
operator|->
name|dname
operator|.
name|repr
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|tag
operator|==
name|DERROR
condition|)
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
else|else
name|fatal
argument_list|(
name|badtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|copied
condition|)
name|frvexpr
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Evicon returns the value of the integer constant  */
end_comment

begin_comment
comment|/*  pointed to by token.                              */
end_comment

begin_function
name|vexpr
modifier|*
name|evicon
parameter_list|(
name|len
parameter_list|,
name|token
parameter_list|)
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|token
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|badconst
init|=
literal|"bad integer constant"
decl_stmt|;
specifier|static
name|char
modifier|*
name|overflow
init|=
literal|"integer constant too large"
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|ftnint
name|val
decl_stmt|;
specifier|register
name|int
name|digit
decl_stmt|;
specifier|register
name|dvalue
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
name|badconst
argument_list|)
expr_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Dvalue
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|DVALUE
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|len
condition|)
block|{
if|if
condition|(
name|val
operator|>
name|MAXINT
operator|/
literal|10
condition|)
block|{
name|err
argument_list|(
name|overflow
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|val
operator|=
literal|10
operator|*
name|val
expr_stmt|;
name|digit
operator|=
name|token
index|[
name|i
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|digit
argument_list|)
condition|)
name|fatal
argument_list|(
name|badconst
argument_list|)
expr_stmt|;
name|digit
operator|=
name|digit
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|MAXINT
operator|-
name|val
operator|>=
name|digit
condition|)
name|val
operator|=
name|val
operator|+
name|digit
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|len
operator|&&
name|MAXINT
operator|-
name|val
operator|+
literal|1
operator|==
name|digit
condition|)
block|{
name|p
operator|->
name|status
operator|=
name|MAXPLUS1
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
else|else
block|{
name|err
argument_list|(
name|overflow
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|val
expr_stmt|;
name|ret
label|:
return|return
operator|(
operator|(
name|vexpr
operator|*
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Ivaltoicon converts a dvalue into a constant block.  */
end_comment

begin_function
name|expptr
name|ivaltoicon
parameter_list|(
name|vp
parameter_list|)
specifier|register
name|vexpr
modifier|*
name|vp
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|badtag
init|=
literal|"bad tag in ivaltoicon"
decl_stmt|;
specifier|static
name|char
modifier|*
name|overflow
init|=
literal|"integer constant too large"
decl_stmt|;
specifier|register
name|int
name|vs
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|tag
operator|==
name|DERROR
condition|)
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
elseif|else
if|if
condition|(
name|vp
operator|->
name|tag
operator|!=
name|DVALUE
condition|)
name|fatal
argument_list|(
name|badtag
argument_list|)
expr_stmt|;
name|vs
operator|=
name|vp
operator|->
name|dvalue
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|vs
operator|==
name|NORMAL
condition|)
name|p
operator|=
name|mkintcon
argument_list|(
name|vp
operator|->
name|dvalue
operator|.
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|MAXINT
operator|+
name|MININT
operator|==
operator|-
literal|1
operator|)
operator|&&
name|vs
operator|==
name|MINLESS1
condition|)
name|p
operator|=
name|mkintcon
argument_list|(
name|MININT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vs
operator|==
name|MAXPLUS1
operator|||
name|vs
operator|==
name|MINLESS1
condition|)
block|{
name|err
argument_list|(
name|overflow
argument_list|)
expr_stmt|;
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
block|}
else|else
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Mkdname stores an identifier as a dname  */
end_comment

begin_function
name|vexpr
modifier|*
name|mkdname
parameter_list|(
name|len
parameter_list|,
name|str
parameter_list|)
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|dname
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|ckalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|s
index|[
name|i
index|]
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Dname
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|DNAME
expr_stmt|;
name|p
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|p
operator|->
name|repr
operator|=
name|s
expr_stmt|;
return|return
operator|(
operator|(
name|vexpr
operator|*
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Getname gets the symbol table information associated with  */
end_comment

begin_comment
comment|/*  a name.  Getname differs from mkname in that it will not   */
end_comment

begin_comment
comment|/*  add the name to the symbol table if it is not already      */
end_comment

begin_comment
comment|/*  present.                                                   */
end_comment

begin_function
name|Namep
name|getname
parameter_list|(
name|l
parameter_list|,
name|s
parameter_list|)
name|int
name|l
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|Hashentry
modifier|*
name|hp
decl_stmt|;
name|int
name|hash
decl_stmt|;
specifier|register
name|Namep
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|n
index|[
name|VL
index|]
decl_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|;
operator|++
name|i
control|)
block|{
name|hash
operator|+=
operator|*
name|s
expr_stmt|;
name|n
index|[
name|i
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|VL
condition|)
name|n
index|[
name|i
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|hash
operator|%=
name|maxhash
expr_stmt|;
name|hp
operator|=
name|hashtab
operator|+
name|hash
expr_stmt|;
while|while
condition|(
name|q
operator|=
name|hp
operator|->
name|varp
condition|)
if|if
condition|(
name|hash
operator|==
name|hp
operator|->
name|hashval
operator|&&
name|eqn
argument_list|(
name|VL
argument_list|,
name|n
argument_list|,
name|q
operator|->
name|varname
argument_list|)
condition|)
goto|goto
name|ret
goto|;
elseif|else
if|if
condition|(
operator|++
name|hp
operator|>=
name|lasthash
condition|)
name|hp
operator|=
name|hashtab
expr_stmt|;
name|ret
label|:
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Evparam returns the value of the constant named by name.  */
end_comment

begin_function
name|expptr
name|evparam
parameter_list|(
name|np
parameter_list|)
specifier|register
name|vexpr
modifier|*
name|np
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|badtag
init|=
literal|"bad tag in evparam"
decl_stmt|;
specifier|static
name|char
modifier|*
name|undefined
init|=
literal|"%s is undefined"
decl_stmt|;
specifier|static
name|char
modifier|*
name|nonconst
init|=
literal|"%s is not constant"
decl_stmt|;
specifier|register
name|struct
name|Paramblock
modifier|*
name|tp
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|repr
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|tag
operator|!=
name|DNAME
condition|)
name|fatal
argument_list|(
name|badtag
argument_list|)
expr_stmt|;
name|len
operator|=
name|np
operator|->
name|dname
operator|.
name|len
expr_stmt|;
name|repr
operator|=
name|np
operator|->
name|dname
operator|.
name|repr
expr_stmt|;
name|tp
operator|=
operator|(
expr|struct
name|Paramblock
operator|*
operator|)
name|getname
argument_list|(
name|len
argument_list|,
name|repr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
name|errnm
argument_list|(
name|undefined
argument_list|,
name|len
argument_list|,
name|repr
argument_list|)
expr_stmt|;
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|vclass
operator|!=
name|CLPARAM
operator|||
operator|!
name|ISCONST
argument_list|(
name|tp
operator|->
name|paramval
argument_list|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|paramval
operator|->
name|tag
operator|!=
name|TERROR
condition|)
name|errnm
argument_list|(
name|nonconst
argument_list|,
name|len
argument_list|,
name|repr
argument_list|)
expr_stmt|;
name|p
operator|=
name|errnode
argument_list|()
expr_stmt|;
block|}
else|else
name|p
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|tp
operator|->
name|paramval
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|vexpr
modifier|*
name|evaldname
parameter_list|(
name|dp
parameter_list|)
name|vexpr
modifier|*
name|dp
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|undefined
init|=
literal|"%s is undefined"
decl_stmt|;
specifier|static
name|char
modifier|*
name|nonconst
init|=
literal|"%s is not a constant"
decl_stmt|;
specifier|static
name|char
modifier|*
name|nonint
init|=
literal|"%s is not an integer"
decl_stmt|;
specifier|register
name|dvalue
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|Paramblock
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|repr
decl_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Dvalue
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|DVALUE
expr_stmt|;
name|len
operator|=
name|dp
operator|->
name|dname
operator|.
name|len
expr_stmt|;
name|repr
operator|=
name|dp
operator|->
name|dname
operator|.
name|repr
expr_stmt|;
name|tp
operator|=
operator|(
expr|struct
name|Paramblock
operator|*
operator|)
name|getname
argument_list|(
name|len
argument_list|,
name|repr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
name|errnm
argument_list|(
name|undefined
argument_list|,
name|len
argument_list|,
name|repr
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|vclass
operator|!=
name|CLPARAM
operator|||
operator|!
name|ISCONST
argument_list|(
name|tp
operator|->
name|paramval
argument_list|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|paramval
operator|->
name|tag
operator|!=
name|TERROR
condition|)
name|errnm
argument_list|(
name|nonconst
argument_list|,
name|len
argument_list|,
name|repr
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ISINT
argument_list|(
name|tp
operator|->
name|paramval
operator|->
name|constblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
name|errnm
argument_list|(
name|nonint
argument_list|,
name|len
argument_list|,
name|repr
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|MAXINT
operator|+
name|MININT
operator|==
operator|-
literal|1
operator|)
operator|&&
name|tp
operator|->
name|paramval
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
operator|==
name|MININT
condition|)
name|p
operator|->
name|status
operator|=
name|MINLESS1
expr_stmt|;
else|else
block|{
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|tp
operator|->
name|paramval
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|(
name|vexpr
operator|*
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|vexpr
modifier|*
name|mkdexpr
parameter_list|(
name|op
parameter_list|,
name|l
parameter_list|,
name|r
parameter_list|)
specifier|register
name|int
name|op
decl_stmt|;
specifier|register
name|vexpr
modifier|*
name|l
decl_stmt|;
specifier|register
name|vexpr
modifier|*
name|r
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|badop
init|=
literal|"bad operator in mkdexpr"
decl_stmt|;
specifier|register
name|vexpr
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
default|default:
name|fatal
argument_list|(
name|badop
argument_list|)
expr_stmt|;
case|case
name|OPNEG
case|:
case|case
name|OPPLUS
case|:
case|case
name|OPMINUS
case|:
case|case
name|OPSTAR
case|:
case|case
name|OPSLASH
case|:
case|case
name|OPPOWER
case|:
break|break;
block|}
if|if
condition|(
operator|(
name|l
operator|!=
name|NULL
operator|&&
name|l
operator|->
name|tag
operator|==
name|DERROR
operator|)
operator|||
name|r
operator|->
name|tag
operator|==
name|DERROR
condition|)
block|{
name|frvexpr
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|frvexpr
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|vexpr
operator|*
operator|)
name|ALLOC
argument_list|(
name|Derror
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|DERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|OPNEG
operator|&&
name|r
operator|->
name|tag
operator|==
name|DVALUE
condition|)
block|{
name|p
operator|=
name|negival
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|frvexpr
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|!=
name|OPNEG
operator|&&
name|l
operator|->
name|tag
operator|==
name|DVALUE
operator|&&
name|r
operator|->
name|tag
operator|==
name|DVALUE
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OPPLUS
case|:
name|p
operator|=
name|addivals
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPMINUS
case|:
name|p
operator|=
name|subivals
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPSTAR
case|:
name|p
operator|=
name|mulivals
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPSLASH
case|:
name|p
operator|=
name|divivals
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPPOWER
case|:
name|p
operator|=
name|powivals
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
block|}
name|frvexpr
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|frvexpr
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
operator|(
name|vexpr
operator|*
operator|)
name|ALLOC
argument_list|(
name|Dexpr
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|DEXPR
expr_stmt|;
name|p
operator|->
name|dexpr
operator|.
name|opcode
operator|=
name|op
expr_stmt|;
name|p
operator|->
name|dexpr
operator|.
name|left
operator|=
name|l
expr_stmt|;
name|p
operator|->
name|dexpr
operator|.
name|right
operator|=
name|r
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|vexpr
modifier|*
name|addivals
parameter_list|(
name|l
parameter_list|,
name|r
parameter_list|)
name|vexpr
modifier|*
name|l
decl_stmt|;
name|vexpr
modifier|*
name|r
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|badtag
init|=
literal|"bad tag in addivals"
decl_stmt|;
specifier|static
name|char
modifier|*
name|overflow
init|=
literal|"integer value too large"
decl_stmt|;
specifier|register
name|int
name|ls
decl_stmt|,
name|rs
decl_stmt|;
specifier|register
name|ftnint
name|lv
decl_stmt|,
name|rv
decl_stmt|;
specifier|register
name|dvalue
modifier|*
name|p
decl_stmt|;
specifier|register
name|ftnint
name|k
decl_stmt|;
if|if
condition|(
name|l
operator|->
name|tag
operator|!=
name|DVALUE
operator|||
name|r
operator|->
name|tag
operator|!=
name|DVALUE
condition|)
name|fatal
argument_list|(
name|badtag
argument_list|)
expr_stmt|;
name|ls
operator|=
name|l
operator|->
name|dvalue
operator|.
name|status
expr_stmt|;
name|lv
operator|=
name|l
operator|->
name|dvalue
operator|.
name|value
expr_stmt|;
name|rs
operator|=
name|r
operator|->
name|dvalue
operator|.
name|status
expr_stmt|;
name|rv
operator|=
name|r
operator|->
name|dvalue
operator|.
name|value
expr_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Dvalue
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|DVALUE
expr_stmt|;
if|if
condition|(
name|ls
operator|==
name|ERRVAL
operator|||
name|rs
operator|==
name|ERRVAL
condition|)
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|ls
operator|==
name|NORMAL
operator|&&
name|rs
operator|==
name|NORMAL
condition|)
block|{
name|addints
argument_list|(
name|lv
argument_list|,
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
name|rstatus
operator|==
name|ERRVAL
condition|)
name|err
argument_list|(
name|overflow
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|rstatus
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|rvalue
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rs
operator|==
name|MAXPLUS1
operator|||
name|rs
operator|==
name|MINLESS1
condition|)
block|{
name|rs
operator|=
name|ls
expr_stmt|;
name|rv
operator|=
name|lv
expr_stmt|;
name|ls
operator|=
name|r
operator|->
name|dvalue
operator|.
name|status
expr_stmt|;
block|}
if|if
condition|(
name|rs
operator|==
name|NORMAL
operator|&&
name|rv
operator|==
literal|0
condition|)
name|p
operator|->
name|status
operator|=
name|ls
expr_stmt|;
elseif|else
if|if
condition|(
name|ls
operator|==
name|MAXPLUS1
condition|)
block|{
if|if
condition|(
name|rs
operator|==
name|NORMAL
operator|&&
name|rv
operator|<
literal|0
condition|)
block|{
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|k
operator|=
name|MAXINT
operator|+
name|rv
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|k
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs
operator|==
name|MINLESS1
condition|)
block|{
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|p
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
name|overflow
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|rs
operator|==
name|NORMAL
operator|&&
name|rv
operator|>
literal|0
condition|)
block|{
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|k
operator|=
operator|(
operator|-
name|MAXINT
operator|)
operator|+
name|rv
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|k
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs
operator|==
name|MAXPLUS1
condition|)
block|{
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|p
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
name|overflow
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
operator|(
name|vexpr
operator|*
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|vexpr
modifier|*
name|negival
parameter_list|(
name|vp
parameter_list|)
name|vexpr
modifier|*
name|vp
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|badtag
init|=
literal|"bad tag in negival"
decl_stmt|;
specifier|register
name|int
name|vs
decl_stmt|;
specifier|register
name|dvalue
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|tag
operator|!=
name|DVALUE
condition|)
name|fatal
argument_list|(
name|badtag
argument_list|)
expr_stmt|;
name|vs
operator|=
name|vp
operator|->
name|dvalue
operator|.
name|status
expr_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Dvalue
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|DVALUE
expr_stmt|;
if|if
condition|(
name|vs
operator|==
name|ERRVAL
condition|)
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|vs
operator|==
name|NORMAL
condition|)
block|{
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|p
operator|->
name|value
operator|=
operator|-
operator|(
name|vp
operator|->
name|dvalue
operator|.
name|value
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vs
operator|==
name|MAXPLUS1
condition|)
name|p
operator|->
name|status
operator|=
name|MINLESS1
expr_stmt|;
else|else
name|p
operator|->
name|status
operator|=
name|MAXPLUS1
expr_stmt|;
return|return
operator|(
operator|(
name|vexpr
operator|*
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|vexpr
modifier|*
name|subivals
parameter_list|(
name|l
parameter_list|,
name|r
parameter_list|)
name|vexpr
modifier|*
name|l
decl_stmt|;
name|vexpr
modifier|*
name|r
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|badtag
init|=
literal|"bad tag in subivals"
decl_stmt|;
specifier|register
name|vexpr
modifier|*
name|p
decl_stmt|;
specifier|register
name|vexpr
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|l
operator|->
name|tag
operator|!=
name|DVALUE
operator|||
name|r
operator|->
name|tag
operator|!=
name|DVALUE
condition|)
name|fatal
argument_list|(
name|badtag
argument_list|)
expr_stmt|;
name|t
operator|=
name|negival
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|p
operator|=
name|addivals
argument_list|(
name|l
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|frvexpr
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|vexpr
modifier|*
name|mulivals
parameter_list|(
name|l
parameter_list|,
name|r
parameter_list|)
name|vexpr
modifier|*
name|l
decl_stmt|;
name|vexpr
modifier|*
name|r
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|badtag
init|=
literal|"bad tag in mulivals"
decl_stmt|;
specifier|static
name|char
modifier|*
name|overflow
init|=
literal|"integer value too large"
decl_stmt|;
specifier|register
name|int
name|ls
decl_stmt|,
name|rs
decl_stmt|;
specifier|register
name|ftnint
name|lv
decl_stmt|,
name|rv
decl_stmt|;
specifier|register
name|dvalue
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|l
operator|->
name|tag
operator|!=
name|DVALUE
operator|||
name|r
operator|->
name|tag
operator|!=
name|DVALUE
condition|)
name|fatal
argument_list|(
name|badtag
argument_list|)
expr_stmt|;
name|ls
operator|=
name|l
operator|->
name|dvalue
operator|.
name|status
expr_stmt|;
name|lv
operator|=
name|l
operator|->
name|dvalue
operator|.
name|value
expr_stmt|;
name|rs
operator|=
name|r
operator|->
name|dvalue
operator|.
name|status
expr_stmt|;
name|rv
operator|=
name|r
operator|->
name|dvalue
operator|.
name|value
expr_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Dvalue
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|DVALUE
expr_stmt|;
if|if
condition|(
name|ls
operator|==
name|ERRVAL
operator|||
name|rs
operator|==
name|ERRVAL
condition|)
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|ls
operator|==
name|NORMAL
operator|&&
name|rs
operator|==
name|NORMAL
condition|)
block|{
name|mulints
argument_list|(
name|lv
argument_list|,
name|rv
argument_list|)
expr_stmt|;
if|if
condition|(
name|rstatus
operator|==
name|ERRVAL
condition|)
name|err
argument_list|(
name|overflow
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|rstatus
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|rvalue
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rs
operator|==
name|MAXPLUS1
operator|||
name|rs
operator|==
name|MINLESS1
condition|)
block|{
name|rs
operator|=
name|ls
expr_stmt|;
name|rv
operator|=
name|lv
expr_stmt|;
name|ls
operator|=
name|r
operator|->
name|dvalue
operator|.
name|status
expr_stmt|;
block|}
if|if
condition|(
name|rs
operator|==
name|NORMAL
operator|&&
name|rv
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|p
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs
operator|==
name|NORMAL
operator|&&
name|rv
operator|==
literal|1
condition|)
name|p
operator|->
name|status
operator|=
name|ls
expr_stmt|;
elseif|else
if|if
condition|(
name|rs
operator|==
name|NORMAL
operator|&&
name|rv
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|ls
operator|==
name|MAXPLUS1
condition|)
name|p
operator|->
name|status
operator|=
name|MINLESS1
expr_stmt|;
else|else
name|p
operator|->
name|status
operator|=
name|MAXPLUS1
expr_stmt|;
else|else
block|{
name|err
argument_list|(
name|overflow
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|(
name|vexpr
operator|*
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|vexpr
modifier|*
name|divivals
parameter_list|(
name|l
parameter_list|,
name|r
parameter_list|)
name|vexpr
modifier|*
name|l
decl_stmt|;
name|vexpr
modifier|*
name|r
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|badtag
init|=
literal|"bad tag in divivals"
decl_stmt|;
specifier|static
name|char
modifier|*
name|zerodivide
init|=
literal|"division by zero"
decl_stmt|;
specifier|register
name|int
name|ls
decl_stmt|,
name|rs
decl_stmt|;
specifier|register
name|ftnint
name|lv
decl_stmt|,
name|rv
decl_stmt|;
specifier|register
name|dvalue
modifier|*
name|p
decl_stmt|;
specifier|register
name|ftnint
name|k
decl_stmt|;
specifier|register
name|int
name|sign
decl_stmt|;
if|if
condition|(
name|l
operator|->
name|tag
operator|!=
name|DVALUE
operator|&&
name|r
operator|->
name|tag
operator|!=
name|DVALUE
condition|)
name|fatal
argument_list|(
name|badtag
argument_list|)
expr_stmt|;
name|ls
operator|=
name|l
operator|->
name|dvalue
operator|.
name|status
expr_stmt|;
name|lv
operator|=
name|l
operator|->
name|dvalue
operator|.
name|value
expr_stmt|;
name|rs
operator|=
name|r
operator|->
name|dvalue
operator|.
name|status
expr_stmt|;
name|rv
operator|=
name|r
operator|->
name|dvalue
operator|.
name|value
expr_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Dvalue
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|DVALUE
expr_stmt|;
if|if
condition|(
name|ls
operator|==
name|ERRVAL
operator|||
name|rs
operator|==
name|ERRVAL
condition|)
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|rs
operator|==
name|NORMAL
condition|)
block|{
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
block|{
name|err
argument_list|(
name|zerodivide
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ls
operator|==
name|NORMAL
condition|)
block|{
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|lv
operator|/
name|rv
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rv
operator|==
literal|1
condition|)
name|p
operator|->
name|status
operator|=
name|ls
expr_stmt|;
elseif|else
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|ls
operator|==
name|MAXPLUS1
condition|)
name|p
operator|->
name|status
operator|=
name|MINLESS1
expr_stmt|;
else|else
name|p
operator|->
name|status
operator|=
name|MAXPLUS1
expr_stmt|;
else|else
block|{
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
if|if
condition|(
name|ls
operator|==
name|MAXPLUS1
condition|)
name|sign
operator|=
literal|1
expr_stmt|;
else|else
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|rv
operator|<
literal|0
condition|)
block|{
name|rv
operator|=
operator|-
name|rv
expr_stmt|;
name|sign
operator|=
operator|-
name|sign
expr_stmt|;
block|}
name|k
operator|=
name|MAXINT
operator|-
name|rv
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|sign
operator|*
operator|(
operator|(
name|k
operator|+
literal|1
operator|)
operator|/
name|rv
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
if|if
condition|(
name|ls
operator|==
name|NORMAL
condition|)
name|p
operator|->
name|value
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ls
operator|==
name|MAXPLUS1
operator|&&
name|rs
operator|==
name|MAXPLUS1
operator|)
operator|||
operator|(
name|ls
operator|==
name|MINLESS1
operator|&&
name|rs
operator|==
name|MINLESS1
operator|)
condition|)
name|p
operator|->
name|value
operator|=
literal|1
expr_stmt|;
else|else
name|p
operator|->
name|value
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|vexpr
operator|*
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|vexpr
modifier|*
name|powivals
parameter_list|(
name|l
parameter_list|,
name|r
parameter_list|)
name|vexpr
modifier|*
name|l
decl_stmt|;
name|vexpr
modifier|*
name|r
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|badtag
init|=
literal|"bad tag in powivals"
decl_stmt|;
specifier|static
name|char
modifier|*
name|zerozero
init|=
literal|"zero raised to the zero-th power"
decl_stmt|;
specifier|static
name|char
modifier|*
name|zeroneg
init|=
literal|"zero raised to a negative power"
decl_stmt|;
specifier|static
name|char
modifier|*
name|overflow
init|=
literal|"integer value too large"
decl_stmt|;
specifier|register
name|int
name|ls
decl_stmt|,
name|rs
decl_stmt|;
specifier|register
name|ftnint
name|lv
decl_stmt|,
name|rv
decl_stmt|;
specifier|register
name|dvalue
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|l
operator|->
name|tag
operator|!=
name|DVALUE
operator|||
name|r
operator|->
name|tag
operator|!=
name|DVALUE
condition|)
name|fatal
argument_list|(
name|badtag
argument_list|)
expr_stmt|;
name|ls
operator|=
name|l
operator|->
name|dvalue
operator|.
name|status
expr_stmt|;
name|lv
operator|=
name|l
operator|->
name|dvalue
operator|.
name|value
expr_stmt|;
name|rs
operator|=
name|r
operator|->
name|dvalue
operator|.
name|status
expr_stmt|;
name|rv
operator|=
name|r
operator|->
name|dvalue
operator|.
name|value
expr_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|Dvalue
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|DVALUE
expr_stmt|;
if|if
condition|(
name|ls
operator|==
name|ERRVAL
operator|||
name|rs
operator|==
name|ERRVAL
condition|)
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|ls
operator|==
name|NORMAL
condition|)
block|{
if|if
condition|(
name|lv
operator|==
literal|1
condition|)
block|{
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|p
operator|->
name|value
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lv
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rs
operator|==
name|MAXPLUS1
operator|||
operator|(
name|rs
operator|==
name|NORMAL
operator|&&
name|rv
operator|>
literal|0
operator|)
condition|)
block|{
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|p
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs
operator|==
name|NORMAL
operator|&&
name|rv
operator|==
literal|0
condition|)
block|{
name|warn
argument_list|(
name|zerozero
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|p
operator|->
name|value
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
name|zeroneg
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lv
operator|==
operator|-
literal|1
condition|)
block|{
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
if|if
condition|(
name|rs
operator|==
name|NORMAL
condition|)
block|{
if|if
condition|(
name|rv
operator|<
literal|0
condition|)
name|rv
operator|=
operator|-
name|rv
expr_stmt|;
if|if
condition|(
name|rv
operator|%
literal|2
operator|==
literal|0
condition|)
name|p
operator|->
name|value
operator|=
literal|1
expr_stmt|;
else|else
name|p
operator|->
name|value
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
if|#
directive|if
operator|(
name|MAXINT
operator|%
literal|2
operator|==
literal|1
operator|)
name|p
operator|->
name|value
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|p
operator|->
name|value
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|rs
operator|==
name|NORMAL
operator|&&
name|rv
operator|>
literal|0
condition|)
block|{
name|rstatus
operator|=
name|NORMAL
expr_stmt|;
name|rvalue
operator|=
name|lv
expr_stmt|;
while|while
condition|(
operator|--
name|rv
operator|&&
name|rstatus
operator|==
name|NORMAL
condition|)
name|mulints
argument_list|(
name|rvalue
argument_list|,
name|lv
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
operator|&&
name|rstatus
operator|!=
name|ERRVAL
condition|)
block|{
name|p
operator|->
name|status
operator|=
name|rstatus
expr_stmt|;
name|p
operator|->
name|value
operator|=
name|rvalue
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
name|overflow
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rs
operator|==
name|MAXPLUS1
condition|)
block|{
name|err
argument_list|(
name|overflow
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs
operator|==
name|NORMAL
operator|&&
name|rv
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|p
operator|->
name|value
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|p
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|rs
operator|==
name|MAXPLUS1
operator|||
operator|(
name|rs
operator|==
name|NORMAL
operator|&&
name|rv
operator|>
literal|1
operator|)
condition|)
block|{
name|err
argument_list|(
name|overflow
argument_list|)
expr_stmt|;
name|p
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs
operator|==
name|NORMAL
operator|&&
name|rv
operator|==
literal|1
condition|)
name|p
operator|->
name|status
operator|=
name|ls
expr_stmt|;
elseif|else
if|if
condition|(
name|rs
operator|==
name|NORMAL
operator|&&
name|rv
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|p
operator|->
name|value
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|p
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|(
name|vexpr
operator|*
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Addints adds two integer values.  */
end_comment

begin_expr_stmt
name|addints
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
specifier|register
name|ftnint
name|i
operator|,
name|j
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|ftnint
name|margin
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|rstatus
operator|=
name|NORMAL
expr_stmt|;
name|rvalue
operator|=
name|j
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|margin
operator|=
name|MAXINT
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|j
operator|<=
name|margin
condition|)
block|{
name|rstatus
operator|=
name|NORMAL
expr_stmt|;
name|rvalue
operator|=
name|i
operator|+
name|j
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|==
name|margin
operator|+
literal|1
condition|)
name|rstatus
operator|=
name|MAXPLUS1
expr_stmt|;
else|else
name|rstatus
operator|=
name|ERRVAL
expr_stmt|;
block|}
else|else
block|{
name|margin
operator|=
operator|(
operator|-
name|MAXINT
operator|)
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|margin
condition|)
block|{
name|rstatus
operator|=
name|NORMAL
expr_stmt|;
name|rvalue
operator|=
name|i
operator|+
name|j
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|==
name|margin
operator|-
literal|1
condition|)
name|rstatus
operator|=
name|MINLESS1
expr_stmt|;
else|else
name|rstatus
operator|=
name|ERRVAL
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  Mulints multiplies two integer values  */
end_comment

begin_expr_stmt
name|mulints
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
specifier|register
name|ftnint
name|i
operator|,
name|j
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|ftnint
name|sign
decl_stmt|;
specifier|register
name|ftnint
name|margin
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|j
operator|==
literal|0
condition|)
block|{
name|rstatus
operator|=
name|NORMAL
expr_stmt|;
name|rvalue
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|i
operator|>
literal|0
operator|&&
name|j
operator|>
literal|0
operator|)
operator|||
operator|(
name|i
operator|<
literal|0
operator|&&
name|j
operator|<
literal|0
operator|)
condition|)
name|sign
operator|=
literal|1
expr_stmt|;
else|else
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|j
operator|=
operator|-
name|j
expr_stmt|;
name|margin
operator|=
name|MAXINT
operator|-
name|i
expr_stmt|;
name|margin
operator|=
operator|(
name|margin
operator|+
literal|1
operator|)
operator|/
name|i
expr_stmt|;
if|if
condition|(
name|j
operator|<=
name|margin
condition|)
block|{
name|rstatus
operator|=
name|NORMAL
expr_stmt|;
name|rvalue
operator|=
name|i
operator|*
name|j
operator|*
name|sign
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|-
literal|1
operator|==
name|margin
condition|)
block|{
name|margin
operator|=
name|i
operator|*
name|margin
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|margin
operator|==
name|MAXINT
operator|-
name|i
condition|)
if|if
condition|(
name|sign
operator|>
literal|0
condition|)
name|rstatus
operator|=
name|MAXPLUS1
expr_stmt|;
else|else
name|rstatus
operator|=
name|MINLESS1
expr_stmt|;
else|else
block|{
name|rstatus
operator|=
name|NORMAL
expr_stmt|;
name|rvalue
operator|=
name|i
operator|*
name|j
operator|*
name|sign
expr_stmt|;
block|}
block|}
else|else
name|rstatus
operator|=
name|ERRVAL
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_escape
end_escape

begin_function
name|vexpr
modifier|*
name|evalvexpr
parameter_list|(
name|ep
parameter_list|)
name|vexpr
modifier|*
name|ep
decl_stmt|;
block|{
specifier|register
name|vexpr
modifier|*
name|p
decl_stmt|;
specifier|register
name|vexpr
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|tag
condition|)
block|{
case|case
name|DVALUE
case|:
name|p
operator|=
name|cpdvalue
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVAR
case|:
name|p
operator|=
name|cpdvalue
argument_list|(
operator|(
name|vexpr
operator|*
operator|)
name|ep
operator|->
name|dvar
operator|.
name|valp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNAME
case|:
name|p
operator|=
name|evaldname
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEXPR
case|:
if|if
condition|(
name|ep
operator|->
name|dexpr
operator|.
name|left
operator|==
name|NULL
condition|)
name|l
operator|=
name|NULL
expr_stmt|;
else|else
name|l
operator|=
name|evalvexpr
argument_list|(
name|ep
operator|->
name|dexpr
operator|.
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|dexpr
operator|.
name|right
operator|==
name|NULL
condition|)
name|r
operator|=
name|NULL
expr_stmt|;
else|else
name|r
operator|=
name|evalvexpr
argument_list|(
name|ep
operator|->
name|dexpr
operator|.
name|right
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ep
operator|->
name|dexpr
operator|.
name|opcode
condition|)
block|{
case|case
name|OPNEG
case|:
name|p
operator|=
name|negival
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPPLUS
case|:
name|p
operator|=
name|addivals
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPMINUS
case|:
name|p
operator|=
name|subivals
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPSTAR
case|:
name|p
operator|=
name|mulivals
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPSLASH
case|:
name|p
operator|=
name|divivals
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPPOWER
case|:
name|p
operator|=
name|powivals
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
block|}
name|frvexpr
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|frvexpr
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|DERROR
case|:
name|p
operator|=
operator|(
name|vexpr
operator|*
operator|)
name|ALLOC
argument_list|(
name|Dvalue
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|DVALUE
expr_stmt|;
name|p
operator|->
name|dvalue
operator|.
name|status
operator|=
name|ERRVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|vexpr
modifier|*
name|refrigdname
parameter_list|(
name|vp
parameter_list|)
name|vexpr
modifier|*
name|vp
decl_stmt|;
block|{
specifier|register
name|vexpr
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|repr
decl_stmt|;
specifier|register
name|int
name|found
decl_stmt|;
specifier|register
name|dovars
modifier|*
name|dvp
decl_stmt|;
name|len
operator|=
name|vp
operator|->
name|dname
operator|.
name|len
expr_stmt|;
name|repr
operator|=
name|vp
operator|->
name|dname
operator|.
name|repr
expr_stmt|;
name|found
operator|=
name|NO
expr_stmt|;
name|dvp
operator|=
name|dvlist
expr_stmt|;
while|while
condition|(
name|found
operator|==
name|NO
operator|&&
name|dvp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|len
operator|==
name|dvp
operator|->
name|len
operator|&&
name|eqn
argument_list|(
name|len
argument_list|,
name|repr
argument_list|,
name|dvp
operator|->
name|repr
argument_list|)
condition|)
name|found
operator|=
name|YES
expr_stmt|;
else|else
name|dvp
operator|=
name|dvp
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
name|YES
condition|)
block|{
name|p
operator|=
operator|(
name|vexpr
operator|*
operator|)
name|ALLOC
argument_list|(
name|Dvar
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|DVAR
expr_stmt|;
name|p
operator|->
name|dvar
operator|.
name|valp
operator|=
name|dvp
operator|->
name|valp
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|evaldname
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|dvalue
operator|.
name|status
operator|==
name|ERRVAL
condition|)
name|dataerror
operator|=
name|YES
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|refrigvexpr
argument_list|(
argument|vpp
argument_list|)
end_macro

begin_decl_stmt
name|vexpr
modifier|*
modifier|*
name|vpp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|vexpr
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
operator|*
name|vpp
expr_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|tag
condition|)
block|{
case|case
name|DVALUE
case|:
case|case
name|DVAR
case|:
case|case
name|DERROR
case|:
break|break;
case|case
name|DEXPR
case|:
name|refrigvexpr
argument_list|(
operator|&
operator|(
name|vp
operator|->
name|dexpr
operator|.
name|left
operator|)
argument_list|)
expr_stmt|;
name|refrigvexpr
argument_list|(
operator|&
operator|(
name|vp
operator|->
name|dexpr
operator|.
name|right
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DNAME
case|:
operator|*
operator|(
name|vpp
operator|)
operator|=
name|refrigdname
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|frvexpr
argument_list|(
name|vp
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_block

begin_escape
end_escape

begin_function
name|int
name|chkvar
parameter_list|(
name|np
parameter_list|,
name|sname
parameter_list|)
name|Namep
name|np
decl_stmt|;
name|char
modifier|*
name|sname
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|nonvar
init|=
literal|"%s is not a variable"
decl_stmt|;
specifier|static
name|char
modifier|*
name|arginit
init|=
literal|"attempt to initialize a dummy argument: %s"
decl_stmt|;
specifier|static
name|char
modifier|*
name|autoinit
init|=
literal|"attempt to initialize an automatic variable: %s"
decl_stmt|;
specifier|static
name|char
modifier|*
name|badclass
init|=
literal|"bad class in chkvar"
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
specifier|register
name|struct
name|Dimblock
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|status
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vclass
operator|==
name|CLUNKNOWN
operator|||
operator|(
name|np
operator|->
name|vclass
operator|==
name|CLVAR
operator|&&
operator|!
name|np
operator|->
name|vdcldone
operator|)
condition|)
name|vardcl
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vstg
operator|==
name|STGARG
condition|)
block|{
name|errstr
argument_list|(
name|arginit
argument_list|,
name|sname
argument_list|)
expr_stmt|;
name|dataerror
operator|=
name|YES
expr_stmt|;
name|status
operator|=
name|NO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|np
operator|->
name|vclass
operator|!=
name|CLVAR
condition|)
block|{
name|errstr
argument_list|(
name|nonvar
argument_list|,
name|sname
argument_list|)
expr_stmt|;
name|dataerror
operator|=
name|YES
expr_stmt|;
name|status
operator|=
name|NO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|np
operator|->
name|vstg
operator|==
name|STGAUTO
condition|)
block|{
name|errstr
argument_list|(
name|autoinit
argument_list|,
name|sname
argument_list|)
expr_stmt|;
name|dataerror
operator|=
name|YES
expr_stmt|;
name|status
operator|=
name|NO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|np
operator|->
name|vstg
operator|!=
name|STGBSS
operator|&&
name|np
operator|->
name|vstg
operator|!=
name|STGINIT
operator|&&
name|np
operator|->
name|vstg
operator|!=
name|STGCOMMON
operator|&&
name|np
operator|->
name|vstg
operator|!=
name|STGEQUIV
condition|)
block|{
name|fatal
argument_list|(
name|badclass
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|np
operator|->
name|vtype
condition|)
block|{
case|case
name|TYERROR
case|:
name|status
operator|=
name|NO
expr_stmt|;
name|dataerror
operator|=
name|YES
expr_stmt|;
break|break;
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
case|case
name|TYLOGICAL
case|:
case|case
name|TYCHAR
case|:
name|dp
operator|=
name|np
operator|->
name|vdim
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|nelt
operator|==
name|NULL
operator|||
operator|!
name|ISICON
argument_list|(
name|dp
operator|->
name|nelt
argument_list|)
condition|)
block|{
name|status
operator|=
name|NO
expr_stmt|;
name|dataerror
operator|=
name|YES
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|badtype
argument_list|(
literal|"chkvar"
argument_list|,
name|np
operator|->
name|vtype
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|refrigsubs
argument_list|(
argument|ap
argument_list|,
argument|sname
argument_list|)
end_macro

begin_decl_stmt
name|aelt
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
modifier|*
name|nonarray
init|=
literal|"subscripts on a simple variable:  %s"
decl_stmt|;
specifier|static
name|char
modifier|*
name|toofew
init|=
literal|"not enough subscripts on %s"
decl_stmt|;
specifier|static
name|char
modifier|*
name|toomany
init|=
literal|"too many subscripts on %s"
decl_stmt|;
specifier|register
name|vlist
modifier|*
name|subp
decl_stmt|;
specifier|register
name|int
name|nsubs
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
specifier|register
name|struct
name|Dimblock
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|np
operator|=
name|ap
operator|->
name|var
expr_stmt|;
name|dp
operator|=
name|np
operator|->
name|vdim
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|subs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|vdim
operator|==
name|NULL
condition|)
block|{
name|errstr
argument_list|(
name|nonarray
argument_list|,
name|sname
argument_list|)
expr_stmt|;
name|dataerror
operator|=
name|YES
expr_stmt|;
block|}
else|else
block|{
name|nsubs
operator|=
literal|0
expr_stmt|;
name|subp
operator|=
name|ap
operator|->
name|subs
expr_stmt|;
while|while
condition|(
name|subp
operator|!=
name|NULL
condition|)
block|{
name|nsubs
operator|++
expr_stmt|;
name|refrigvexpr
argument_list|(
operator|&
operator|(
name|subp
operator|->
name|val
operator|)
argument_list|)
expr_stmt|;
name|subp
operator|=
name|subp
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|->
name|ndim
operator|!=
name|nsubs
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|vdim
operator|->
name|ndim
operator|>
name|nsubs
condition|)
name|errstr
argument_list|(
name|toofew
argument_list|,
name|sname
argument_list|)
expr_stmt|;
else|else
name|errstr
argument_list|(
name|toomany
argument_list|,
name|sname
argument_list|)
expr_stmt|;
name|dataerror
operator|=
name|YES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|baseoffset
operator|==
name|NULL
operator|||
operator|!
name|ISICON
argument_list|(
name|dp
operator|->
name|baseoffset
argument_list|)
condition|)
name|dataerror
operator|=
name|YES
expr_stmt|;
else|else
block|{
name|i
operator|=
name|dp
operator|->
name|ndim
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
operator|==
name|NULL
operator|||
operator|!
name|ISICON
argument_list|(
name|dp
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
argument_list|)
condition|)
name|dataerror
operator|=
name|YES
expr_stmt|;
block|}
block|}
block|}
block|}
return|return;
block|}
end_block

begin_escape
end_escape

begin_macro
name|refrigrange
argument_list|(
argument|ap
argument_list|,
argument|sname
argument_list|)
end_macro

begin_decl_stmt
name|aelt
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
modifier|*
name|nonstr
init|=
literal|"substring of a noncharacter variable:  %s"
decl_stmt|;
specifier|static
name|char
modifier|*
name|array
init|=
literal|"substring applied to an array:  %s"
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
specifier|register
name|dvalue
modifier|*
name|t
decl_stmt|;
specifier|register
name|rpair
modifier|*
name|rp
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|range
operator|!=
name|NULL
condition|)
block|{
name|np
operator|=
name|ap
operator|->
name|var
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vtype
operator|!=
name|TYCHAR
condition|)
block|{
name|errstr
argument_list|(
name|nonstr
argument_list|,
name|sname
argument_list|)
expr_stmt|;
name|dataerror
operator|=
name|YES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|subs
operator|==
name|NULL
operator|&&
name|np
operator|->
name|vdim
operator|!=
name|NULL
condition|)
block|{
name|errstr
argument_list|(
name|array
argument_list|,
name|sname
argument_list|)
expr_stmt|;
name|dataerror
operator|=
name|YES
expr_stmt|;
block|}
else|else
block|{
name|rp
operator|=
name|ap
operator|->
name|range
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|low
operator|!=
name|NULL
condition|)
name|refrigvexpr
argument_list|(
operator|&
operator|(
name|rp
operator|->
name|low
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|t
operator|=
name|ALLOC
argument_list|(
name|Dvalue
argument_list|)
expr_stmt|;
name|t
operator|->
name|tag
operator|=
name|DVALUE
expr_stmt|;
name|t
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|t
operator|->
name|value
operator|=
literal|1
expr_stmt|;
name|rp
operator|->
name|low
operator|=
operator|(
name|vexpr
operator|*
operator|)
name|t
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|high
operator|!=
name|NULL
condition|)
name|refrigvexpr
argument_list|(
operator|&
operator|(
name|rp
operator|->
name|high
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|ISICON
argument_list|(
name|np
operator|->
name|vleng
argument_list|)
condition|)
block|{
name|rp
operator|->
name|high
operator|=
operator|(
name|vexpr
operator|*
operator|)
name|ALLOC
argument_list|(
name|Derror
argument_list|)
expr_stmt|;
name|rp
operator|->
name|high
operator|->
name|tag
operator|=
name|DERROR
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|ALLOC
argument_list|(
name|Dvalue
argument_list|)
expr_stmt|;
name|t
operator|->
name|tag
operator|=
name|DVALUE
expr_stmt|;
name|t
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|t
operator|->
name|value
operator|=
name|np
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
name|rp
operator|->
name|high
operator|=
operator|(
name|vexpr
operator|*
operator|)
name|t
expr_stmt|;
block|}
block|}
block|}
block|}
return|return;
block|}
end_block

begin_escape
end_escape

begin_macro
name|refrigaelt
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|aelt
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Namep
name|np
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|char
name|buff
index|[
name|VL
operator|+
literal|1
index|]
decl_stmt|;
name|np
operator|=
name|ap
operator|->
name|var
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|buff
expr_stmt|;
name|sp
operator|=
name|np
operator|->
name|varname
expr_stmt|;
while|while
condition|(
name|len
operator|<
name|VL
operator|&&
operator|*
name|sp
operator|!=
literal|' '
operator|&&
operator|*
name|sp
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|chkvar
argument_list|(
name|np
argument_list|,
name|buff
argument_list|)
condition|)
block|{
name|refrigsubs
argument_list|(
name|ap
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|refrigrange
argument_list|(
name|ap
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_escape
end_escape

begin_macro
name|refrigdo
argument_list|(
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|dolist
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
modifier|*
name|duplicates
init|=
literal|"implied DO variable %s redefined"
decl_stmt|;
specifier|static
name|char
modifier|*
name|nonvar
init|=
literal|"%s is not a variable"
decl_stmt|;
specifier|static
name|char
modifier|*
name|nonint
init|=
literal|"%s is not integer"
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|repr
decl_stmt|;
specifier|register
name|int
name|found
decl_stmt|;
specifier|register
name|dovars
modifier|*
name|dvp
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
specifier|register
name|dovars
modifier|*
name|t
decl_stmt|;
name|refrigvexpr
argument_list|(
operator|&
operator|(
name|dp
operator|->
name|init
operator|)
argument_list|)
expr_stmt|;
name|refrigvexpr
argument_list|(
operator|&
operator|(
name|dp
operator|->
name|limit
operator|)
argument_list|)
expr_stmt|;
name|refrigvexpr
argument_list|(
operator|&
operator|(
name|dp
operator|->
name|step
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|dp
operator|->
name|dovar
operator|->
name|dname
operator|.
name|len
expr_stmt|;
name|repr
operator|=
name|dp
operator|->
name|dovar
operator|->
name|dname
operator|.
name|repr
expr_stmt|;
name|found
operator|=
name|NO
expr_stmt|;
name|dvp
operator|=
name|dvlist
expr_stmt|;
while|while
condition|(
name|found
operator|==
name|NO
operator|&&
name|dvp
operator|!=
name|NULL
condition|)
if|if
condition|(
name|len
operator|==
name|dvp
operator|->
name|len
operator|&&
name|eqn
argument_list|(
name|len
argument_list|,
name|repr
argument_list|,
name|dvp
operator|->
name|repr
argument_list|)
condition|)
name|found
operator|=
name|YES
expr_stmt|;
else|else
name|dvp
operator|=
name|dvp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|YES
condition|)
block|{
name|errnm
argument_list|(
name|duplicates
argument_list|,
name|len
argument_list|,
name|repr
argument_list|)
expr_stmt|;
name|dataerror
operator|=
name|YES
expr_stmt|;
block|}
else|else
block|{
name|np
operator|=
name|getname
argument_list|(
name|len
argument_list|,
name|repr
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|ISINT
argument_list|(
name|impltype
index|[
name|letter
argument_list|(
operator|*
name|repr
argument_list|)
index|]
argument_list|)
condition|)
name|warnnm
argument_list|(
name|nonint
argument_list|,
name|len
argument_list|,
name|repr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|np
operator|->
name|vclass
operator|==
name|CLUNKNOWN
condition|)
name|vardcl
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vclass
operator|!=
name|CLVAR
condition|)
name|warnnm
argument_list|(
name|nonvar
argument_list|,
name|len
argument_list|,
name|repr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ISINT
argument_list|(
name|np
operator|->
name|vtype
argument_list|)
condition|)
name|warnnm
argument_list|(
name|nonint
argument_list|,
name|len
argument_list|,
name|repr
argument_list|)
expr_stmt|;
block|}
block|}
name|t
operator|=
name|ALLOC
argument_list|(
name|DoVars
argument_list|)
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|dvlist
expr_stmt|;
name|t
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|t
operator|->
name|repr
operator|=
name|repr
expr_stmt|;
name|t
operator|->
name|valp
operator|=
name|ALLOC
argument_list|(
name|Dvalue
argument_list|)
expr_stmt|;
name|t
operator|->
name|valp
operator|->
name|tag
operator|=
name|DVALUE
expr_stmt|;
name|dp
operator|->
name|dovar
operator|=
operator|(
name|vexpr
operator|*
operator|)
name|t
operator|->
name|valp
expr_stmt|;
name|dvlist
operator|=
name|t
expr_stmt|;
name|refriglvals
argument_list|(
name|dp
operator|->
name|elts
argument_list|)
expr_stmt|;
name|dvlist
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_escape
end_escape

begin_macro
name|refriglvals
argument_list|(
argument|lvals
argument_list|)
end_macro

begin_decl_stmt
name|elist
modifier|*
name|lvals
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|elist
modifier|*
name|top
decl_stmt|;
name|top
operator|=
name|lvals
expr_stmt|;
while|while
condition|(
name|top
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|top
operator|->
name|elt
operator|->
name|tag
operator|==
name|SIMPLE
condition|)
name|refrigaelt
argument_list|(
operator|(
name|aelt
operator|*
operator|)
name|top
operator|->
name|elt
argument_list|)
expr_stmt|;
else|else
name|refrigdo
argument_list|(
operator|(
name|dolist
operator|*
operator|)
name|top
operator|->
name|elt
argument_list|)
expr_stmt|;
name|top
operator|=
name|top
operator|->
name|next
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  Refrig freezes name/value bindings in the DATA name list  */
end_comment

begin_macro
name|refrig
argument_list|(
argument|lvals
argument_list|)
end_macro

begin_decl_stmt
name|elist
modifier|*
name|lvals
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|dvlist
operator|=
name|NULL
expr_stmt|;
name|refriglvals
argument_list|(
name|lvals
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_escape
end_escape

begin_function
name|ftnint
name|indexer
parameter_list|(
name|ap
parameter_list|)
name|aelt
modifier|*
name|ap
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|badvar
init|=
literal|"bad variable in indexer"
decl_stmt|;
specifier|static
name|char
modifier|*
name|boundserror
init|=
literal|"subscript out of bounds"
decl_stmt|;
specifier|register
name|ftnint
name|index
decl_stmt|;
specifier|register
name|vlist
modifier|*
name|sp
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
specifier|register
name|struct
name|Dimblock
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|dvalue
modifier|*
name|vp
decl_stmt|;
specifier|register
name|ftnint
name|size
decl_stmt|;
name|ftnint
name|sub
index|[
name|MAXDIM
index|]
decl_stmt|;
name|sp
operator|=
name|ap
operator|->
name|subs
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|np
operator|=
name|ap
operator|->
name|var
expr_stmt|;
name|dp
operator|=
name|np
operator|->
name|vdim
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|badvar
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sp
operator|!=
name|NULL
condition|)
block|{
name|vp
operator|=
operator|(
name|dvalue
operator|*
operator|)
name|evalvexpr
argument_list|(
name|sp
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|status
operator|==
name|NORMAL
condition|)
name|sub
index|[
name|i
operator|++
index|]
operator|=
name|vp
operator|->
name|value
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|MININT
operator|+
name|MAXINT
operator|==
operator|-
literal|1
operator|)
operator|&&
name|vp
operator|->
name|status
operator|==
name|MINLESS1
condition|)
name|sub
index|[
name|i
operator|++
index|]
operator|=
name|MININT
expr_stmt|;
else|else
block|{
name|frvexpr
argument_list|(
operator|(
name|vexpr
operator|*
operator|)
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|frvexpr
argument_list|(
operator|(
name|vexpr
operator|*
operator|)
name|vp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|next
expr_stmt|;
block|}
name|index
operator|=
name|sub
index|[
operator|--
name|i
index|]
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|size
operator|=
name|dp
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
name|index
operator|=
name|sub
index|[
name|i
index|]
operator|+
name|index
operator|*
name|size
expr_stmt|;
block|}
name|index
operator|-=
name|dp
operator|->
name|baseoffset
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|dp
operator|->
name|nelt
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
condition|)
block|{
name|err
argument_list|(
name|boundserror
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|index
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|savedata
argument_list|(
argument|lvals
argument_list|,
argument|rvals
argument_list|)
end_macro

begin_decl_stmt
name|elist
modifier|*
name|lvals
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vallist
modifier|*
name|rvals
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
modifier|*
name|toomany
init|=
literal|"more data values than data items"
decl_stmt|;
specifier|register
name|elist
modifier|*
name|top
decl_stmt|;
name|dataerror
operator|=
name|NO
expr_stmt|;
name|badvalue
operator|=
name|NO
expr_stmt|;
name|lvals
operator|=
name|revelist
argument_list|(
name|lvals
argument_list|)
expr_stmt|;
name|grvals
operator|=
name|revrvals
argument_list|(
name|rvals
argument_list|)
expr_stmt|;
name|refrig
argument_list|(
name|lvals
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dataerror
condition|)
name|outdata
argument_list|(
name|lvals
argument_list|)
expr_stmt|;
name|frelist
argument_list|(
name|lvals
argument_list|)
expr_stmt|;
while|while
condition|(
name|grvals
operator|!=
name|NULL
operator|&&
name|dataerror
operator|==
name|NO
condition|)
block|{
if|if
condition|(
name|grvals
operator|->
name|status
operator|!=
name|NORMAL
condition|)
name|dataerror
operator|=
name|YES
expr_stmt|;
elseif|else
if|if
condition|(
name|grvals
operator|->
name|repl
operator|<=
literal|0
condition|)
name|grvals
operator|=
name|grvals
operator|->
name|next
expr_stmt|;
else|else
block|{
name|err
argument_list|(
name|toomany
argument_list|)
expr_stmt|;
name|dataerror
operator|=
name|YES
expr_stmt|;
block|}
block|}
name|frvallist
argument_list|(
name|grvals
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
name|setdfiles
argument_list|(
name|np
argument_list|)
specifier|register
name|Namep
name|np
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|Extsym
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|Equivblock
modifier|*
name|ep
decl_stmt|;
specifier|register
name|int
name|stg
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|;
specifier|register
name|ftnint
name|typelen
decl_stmt|;
specifier|register
name|ftnint
name|nelt
decl_stmt|;
specifier|register
name|ftnint
name|varsize
decl_stmt|;
name|stg
operator|=
name|np
operator|->
name|vstg
expr_stmt|;
if|if
condition|(
name|stg
operator|==
name|STGBSS
operator|||
name|stg
operator|==
name|STGINIT
condition|)
block|{
name|datafile
operator|=
name|vdatafile
expr_stmt|;
name|chkfile
operator|=
name|vchkfile
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|init
operator|==
name|YES
condition|)
name|base
operator|=
name|np
operator|->
name|initoffset
expr_stmt|;
else|else
block|{
name|np
operator|->
name|init
operator|=
name|YES
expr_stmt|;
name|np
operator|->
name|initoffset
operator|=
name|base
operator|=
name|vdatahwm
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vdim
operator|!=
name|NULL
condition|)
name|nelt
operator|=
name|np
operator|->
name|vdim
operator|->
name|nelt
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
else|else
name|nelt
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|np
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
name|typelen
operator|=
name|np
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|TYLOGICAL
condition|)
name|typelen
operator|=
name|typesize
index|[
name|tylogical
index|]
expr_stmt|;
else|else
name|typelen
operator|=
name|typesize
index|[
name|type
index|]
expr_stmt|;
name|varsize
operator|=
name|nelt
operator|*
name|typelen
expr_stmt|;
name|vdatahwm
operator|+=
name|varsize
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|stg
operator|==
name|STGEQUIV
condition|)
block|{
name|datafile
operator|=
name|vdatafile
expr_stmt|;
name|chkfile
operator|=
name|vchkfile
expr_stmt|;
name|ep
operator|=
operator|&
name|eqvclass
index|[
name|np
operator|->
name|vardesc
operator|.
name|varno
index|]
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|init
operator|==
name|YES
condition|)
name|base
operator|=
name|ep
operator|->
name|initoffset
expr_stmt|;
else|else
block|{
name|ep
operator|->
name|init
operator|=
name|YES
expr_stmt|;
name|ep
operator|->
name|initoffset
operator|=
name|base
operator|=
name|vdatahwm
expr_stmt|;
name|vdatahwm
operator|+=
name|ep
operator|->
name|eqvleng
expr_stmt|;
block|}
name|base
operator|+=
name|np
operator|->
name|voffset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stg
operator|==
name|STGCOMMON
condition|)
block|{
name|datafile
operator|=
name|cdatafile
expr_stmt|;
name|chkfile
operator|=
name|cchkfile
expr_stmt|;
name|cp
operator|=
operator|&
name|extsymtab
index|[
name|np
operator|->
name|vardesc
operator|.
name|varno
index|]
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|init
operator|==
name|YES
condition|)
name|base
operator|=
name|cp
operator|->
name|initoffset
expr_stmt|;
else|else
block|{
name|cp
operator|->
name|init
operator|=
name|YES
expr_stmt|;
name|cp
operator|->
name|initoffset
operator|=
name|base
operator|=
name|cdatahwm
expr_stmt|;
name|cdatahwm
operator|+=
name|cp
operator|->
name|maxleng
expr_stmt|;
block|}
name|base
operator|+=
name|np
operator|->
name|voffset
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_escape
end_escape

begin_macro
name|wrtdata
argument_list|(
argument|offset
argument_list|,
argument|repl
argument_list|,
argument|len
argument_list|,
argument|constant
argument_list|)
end_macro

begin_decl_stmt
name|long
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ftnint
name|repl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ftnint
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|constant
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
modifier|*
name|badoffset
init|=
literal|"bad offset in wrtdata"
decl_stmt|;
specifier|static
name|char
modifier|*
name|toomuch
init|=
literal|"too much data"
decl_stmt|;
specifier|static
name|char
modifier|*
name|readerror
init|=
literal|"read error on tmp file"
decl_stmt|;
specifier|static
name|char
modifier|*
name|writeerror
init|=
literal|"write error on tmp file"
decl_stmt|;
specifier|static
name|char
modifier|*
name|seekerror
init|=
literal|"seek error on tmp file"
decl_stmt|;
specifier|register
name|ftnint
name|k
decl_stmt|;
name|long
name|lastbyte
decl_stmt|;
name|int
name|bitpos
decl_stmt|;
name|long
name|chkoff
decl_stmt|;
name|long
name|lastoff
decl_stmt|;
name|long
name|chklen
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|int
name|n
decl_stmt|;
name|ftnint
name|nbytes
decl_stmt|;
name|int
name|mask
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|overlap
decl_stmt|;
name|char
name|allzero
decl_stmt|;
name|char
name|buff
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|fatal
argument_list|(
name|badoffset
argument_list|)
expr_stmt|;
name|overlap
operator|=
name|NO
expr_stmt|;
name|k
operator|=
name|repl
operator|*
name|len
expr_stmt|;
name|lastbyte
operator|=
name|offset
operator|+
name|k
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lastbyte
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
name|toomuch
argument_list|)
expr_stmt|;
name|dataerror
operator|=
name|YES
expr_stmt|;
return|return;
block|}
name|bitpos
operator|=
name|offset
operator|%
name|BYTESIZE
expr_stmt|;
name|chkoff
operator|=
name|offset
operator|/
name|BYTESIZE
expr_stmt|;
name|lastoff
operator|=
name|lastbyte
operator|/
name|BYTESIZE
expr_stmt|;
name|chklen
operator|=
name|lastoff
operator|-
name|chkoff
operator|+
literal|1
expr_stmt|;
name|pos
operator|=
name|lseek
argument_list|(
name|chkfile
argument_list|,
name|chkoff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
name|err
argument_list|(
name|seekerror
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|k
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|chklen
operator|<=
name|BUFSIZ
condition|)
name|n
operator|=
name|chklen
expr_stmt|;
else|else
block|{
name|n
operator|=
name|BUFSIZ
expr_stmt|;
name|chklen
operator|-=
name|BUFSIZ
expr_stmt|;
block|}
name|nbytes
operator|=
name|read
argument_list|(
name|chkfile
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
name|readerror
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
name|buff
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<
name|n
condition|)
name|buff
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bitpos
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|k
operator|>
literal|0
operator|&&
name|bitpos
operator|<
name|BYTESIZE
condition|)
block|{
name|mask
operator|=
literal|1
operator|<<
name|bitpos
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|buff
index|[
literal|0
index|]
condition|)
name|overlap
operator|=
name|YES
expr_stmt|;
else|else
name|buff
index|[
literal|0
index|]
operator||=
name|mask
expr_stmt|;
name|k
operator|--
expr_stmt|;
name|bitpos
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bitpos
operator|==
name|BYTESIZE
condition|)
block|{
name|bitpos
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
while|while
condition|(
name|i
operator|<
name|nbytes
operator|&&
name|overlap
operator|==
name|NO
condition|)
block|{
if|if
condition|(
name|buff
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|k
operator|>=
name|BYTESIZE
condition|)
block|{
name|buff
index|[
name|i
operator|++
index|]
operator|=
name|MAXBYTE
expr_stmt|;
name|k
operator|-=
name|BYTESIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|<
name|BYTESIZE
condition|)
block|{
while|while
condition|(
name|k
operator|--
operator|>
literal|0
condition|)
block|{
name|mask
operator|=
literal|1
operator|<<
name|k
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|buff
index|[
name|i
index|]
condition|)
name|overlap
operator|=
name|YES
expr_stmt|;
else|else
name|buff
index|[
name|i
index|]
operator||=
name|mask
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
name|overlap
operator|=
name|YES
expr_stmt|;
name|buff
index|[
name|i
operator|++
index|]
operator|=
name|MAXBYTE
expr_stmt|;
name|k
operator|-=
name|BYTESIZE
expr_stmt|;
block|}
block|}
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
if|if
condition|(
name|k
operator|>=
name|BYTESIZE
condition|)
block|{
name|buff
index|[
name|i
operator|++
index|]
operator|=
name|MAXBYTE
expr_stmt|;
name|k
operator|-=
name|BYTESIZE
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|k
operator|--
operator|>
literal|0
condition|)
block|{
name|mask
operator|=
literal|1
operator|<<
name|k
expr_stmt|;
name|buff
index|[
name|i
index|]
operator||=
name|mask
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
name|pos
operator|=
name|lseek
argument_list|(
name|chkfile
argument_list|,
operator|-
name|nbytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
name|err
argument_list|(
name|seekerror
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|nbytes
operator|=
name|write
argument_list|(
name|chkfile
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|!=
name|n
condition|)
block|{
name|err
argument_list|(
name|writeerror
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|overlap
operator|==
name|NO
condition|)
block|{
name|allzero
operator|=
name|YES
expr_stmt|;
name|k
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|k
operator|>
literal|0
operator|&&
name|allzero
operator|!=
name|NO
condition|)
if|if
condition|(
name|constant
index|[
operator|--
name|k
index|]
operator|!=
literal|0
condition|)
name|allzero
operator|=
name|NO
expr_stmt|;
if|if
condition|(
name|allzero
operator|==
name|YES
condition|)
return|return;
block|}
name|pos
operator|=
name|lseek
argument_list|(
name|datafile
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
name|err
argument_list|(
name|seekerror
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|k
operator|=
name|repl
expr_stmt|;
while|while
condition|(
name|k
operator|--
operator|>
literal|0
condition|)
block|{
name|nbytes
operator|=
name|write
argument_list|(
name|datafile
argument_list|,
name|constant
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|!=
name|len
condition|)
block|{
name|err
argument_list|(
name|writeerror
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|overlap
condition|)
name|overlapflag
operator|=
name|YES
expr_stmt|;
return|return;
block|}
end_block

begin_escape
end_escape

begin_function
name|Constp
name|getdatum
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|toofew
init|=
literal|"more data items than data values"
decl_stmt|;
specifier|register
name|vallist
modifier|*
name|t
decl_stmt|;
while|while
condition|(
name|grvals
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|grvals
operator|->
name|status
operator|!=
name|NORMAL
condition|)
block|{
name|dataerror
operator|=
name|YES
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|grvals
operator|->
name|repl
operator|>
literal|0
condition|)
block|{
name|grvals
operator|->
name|repl
operator|--
expr_stmt|;
return|return
operator|(
name|grvals
operator|->
name|value
operator|)
return|;
block|}
else|else
block|{
name|badvalue
operator|=
literal|0
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|grvals
operator|->
name|value
argument_list|)
expr_stmt|;
name|t
operator|=
name|grvals
expr_stmt|;
name|grvals
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|err
argument_list|(
name|toofew
argument_list|)
expr_stmt|;
name|dataerror
operator|=
name|YES
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|outdata
argument_list|(
argument|lvals
argument_list|)
end_macro

begin_decl_stmt
name|elist
modifier|*
name|lvals
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|elist
modifier|*
name|top
decl_stmt|;
name|top
operator|=
name|lvals
expr_stmt|;
while|while
condition|(
name|top
operator|!=
name|NULL
operator|&&
name|dataerror
operator|==
name|NO
condition|)
block|{
if|if
condition|(
name|top
operator|->
name|elt
operator|->
name|tag
operator|==
name|SIMPLE
condition|)
name|outaelt
argument_list|(
operator|(
name|aelt
operator|*
operator|)
name|top
operator|->
name|elt
argument_list|)
expr_stmt|;
else|else
name|outdolist
argument_list|(
operator|(
name|dolist
operator|*
operator|)
name|top
operator|->
name|elt
argument_list|)
expr_stmt|;
name|top
operator|=
name|top
operator|->
name|next
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_escape
end_escape

begin_macro
name|outaelt
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|aelt
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
modifier|*
name|toofew
init|=
literal|"more data items than data values"
decl_stmt|;
specifier|static
name|char
modifier|*
name|boundserror
init|=
literal|"substring expression out of bounds"
decl_stmt|;
specifier|static
name|char
modifier|*
name|order
init|=
literal|"substring expressions out of order"
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
specifier|register
name|long
name|soffset
decl_stmt|;
specifier|register
name|dvalue
modifier|*
name|lwb
decl_stmt|;
specifier|register
name|dvalue
modifier|*
name|upb
decl_stmt|;
specifier|register
name|Constp
name|constant
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|vallist
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|;
specifier|register
name|ftnint
name|typelen
decl_stmt|;
specifier|register
name|ftnint
name|repl
decl_stmt|;
specifier|extern
name|char
modifier|*
name|packbytes
parameter_list|()
function_decl|;
name|np
operator|=
name|ap
operator|->
name|var
expr_stmt|;
name|setdfiles
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|type
operator|=
name|np
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
name|typelen
operator|=
name|np
operator|->
name|vleng
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|TYLOGICAL
condition|)
name|typelen
operator|=
name|typesize
index|[
name|tylogical
index|]
expr_stmt|;
else|else
name|typelen
operator|=
name|typesize
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|subs
operator|!=
name|NULL
operator|||
name|np
operator|->
name|vdim
operator|==
name|NULL
condition|)
block|{
name|soffset
operator|=
name|indexer
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|soffset
operator|==
operator|-
literal|1
condition|)
block|{
name|dataerror
operator|=
name|YES
expr_stmt|;
return|return;
block|}
name|soffset
operator|=
name|soffset
operator|*
name|typelen
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|range
operator|!=
name|NULL
condition|)
block|{
name|lwb
operator|=
operator|(
name|dvalue
operator|*
operator|)
name|evalvexpr
argument_list|(
name|ap
operator|->
name|range
operator|->
name|low
argument_list|)
expr_stmt|;
name|upb
operator|=
operator|(
name|dvalue
operator|*
operator|)
name|evalvexpr
argument_list|(
name|ap
operator|->
name|range
operator|->
name|high
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|->
name|status
operator|==
name|ERRVAL
operator|||
name|upb
operator|->
name|status
operator|==
name|ERRVAL
condition|)
block|{
name|frvexpr
argument_list|(
operator|(
name|vexpr
operator|*
operator|)
name|lwb
argument_list|)
expr_stmt|;
name|frvexpr
argument_list|(
operator|(
name|vexpr
operator|*
operator|)
name|upb
argument_list|)
expr_stmt|;
name|dataerror
operator|=
name|YES
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lwb
operator|->
name|status
operator|!=
name|NORMAL
operator|||
name|lwb
operator|->
name|value
operator|<
literal|1
operator|||
name|lwb
operator|->
name|value
operator|>
name|typelen
operator|||
name|upb
operator|->
name|status
operator|!=
name|NORMAL
operator|||
name|upb
operator|->
name|value
operator|<
literal|1
operator|||
name|upb
operator|->
name|value
operator|>
name|typelen
condition|)
block|{
name|err
argument_list|(
name|boundserror
argument_list|)
expr_stmt|;
name|frvexpr
argument_list|(
operator|(
name|vexpr
operator|*
operator|)
name|lwb
argument_list|)
expr_stmt|;
name|frvexpr
argument_list|(
operator|(
name|vexpr
operator|*
operator|)
name|upb
argument_list|)
expr_stmt|;
name|dataerror
operator|=
name|YES
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lwb
operator|->
name|value
operator|>
name|upb
operator|->
name|value
condition|)
block|{
name|err
argument_list|(
name|order
argument_list|)
expr_stmt|;
name|frvexpr
argument_list|(
operator|(
name|vexpr
operator|*
operator|)
name|lwb
argument_list|)
expr_stmt|;
name|frvexpr
argument_list|(
operator|(
name|vexpr
operator|*
operator|)
name|upb
argument_list|)
expr_stmt|;
name|dataerror
operator|=
name|YES
expr_stmt|;
return|return;
block|}
name|soffset
operator|=
name|soffset
operator|+
name|lwb
operator|->
name|value
operator|-
literal|1
expr_stmt|;
name|typelen
operator|=
name|upb
operator|->
name|value
operator|-
name|lwb
operator|->
name|value
operator|+
literal|1
expr_stmt|;
name|frvexpr
argument_list|(
operator|(
name|vexpr
operator|*
operator|)
name|lwb
argument_list|)
expr_stmt|;
name|frvexpr
argument_list|(
operator|(
name|vexpr
operator|*
operator|)
name|upb
argument_list|)
expr_stmt|;
block|}
name|constant
operator|=
name|getdatum
argument_list|()
expr_stmt|;
if|if
condition|(
name|constant
operator|==
name|NULL
operator|||
operator|!
name|ISCONST
argument_list|(
name|constant
argument_list|)
condition|)
return|return;
name|constant
operator|=
operator|(
name|Constp
operator|)
name|convconst
argument_list|(
name|type
argument_list|,
name|typelen
argument_list|,
name|constant
argument_list|)
expr_stmt|;
if|if
condition|(
name|constant
operator|==
name|NULL
operator|||
operator|!
name|ISCONST
argument_list|(
name|constant
argument_list|)
condition|)
block|{
name|frexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|constant
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
name|wrtdata
argument_list|(
name|base
operator|+
name|soffset
argument_list|,
literal|1
argument_list|,
name|typelen
argument_list|,
name|constant
operator|->
name|constant
operator|.
name|ccp
argument_list|)
expr_stmt|;
else|else
name|wrtdata
argument_list|(
name|base
operator|+
name|soffset
argument_list|,
literal|1
argument_list|,
name|typelen
argument_list|,
name|packbytes
argument_list|(
name|constant
argument_list|)
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|constant
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|soffset
operator|=
literal|0
expr_stmt|;
name|k
operator|=
name|np
operator|->
name|vdim
operator|->
name|nelt
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
while|while
condition|(
name|k
operator|>
literal|0
operator|&&
name|dataerror
operator|==
name|NO
condition|)
block|{
if|if
condition|(
name|grvals
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
name|toofew
argument_list|)
expr_stmt|;
name|dataerror
operator|=
name|YES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|grvals
operator|->
name|status
operator|!=
name|NORMAL
condition|)
name|dataerror
operator|=
name|YES
expr_stmt|;
elseif|else
if|if
condition|(
name|grvals
operator|->
name|repl
operator|<=
literal|0
condition|)
block|{
name|badvalue
operator|=
literal|0
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|grvals
operator|->
name|value
argument_list|)
expr_stmt|;
name|t
operator|=
name|grvals
expr_stmt|;
name|grvals
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|constant
operator|=
name|grvals
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|constant
operator|==
name|NULL
operator|||
operator|!
name|ISCONST
argument_list|(
name|constant
argument_list|)
condition|)
block|{
name|dataerror
operator|=
name|YES
expr_stmt|;
block|}
else|else
block|{
name|constant
operator|=
operator|(
name|Constp
operator|)
name|convconst
argument_list|(
name|type
argument_list|,
name|typelen
argument_list|,
name|constant
argument_list|)
expr_stmt|;
if|if
condition|(
name|constant
operator|==
name|NULL
operator|||
operator|!
name|ISCONST
argument_list|(
name|constant
argument_list|)
condition|)
block|{
name|dataerror
operator|=
name|YES
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|constant
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|k
operator|>
name|grvals
operator|->
name|repl
condition|)
name|repl
operator|=
name|grvals
operator|->
name|repl
expr_stmt|;
else|else
name|repl
operator|=
name|k
expr_stmt|;
name|grvals
operator|->
name|repl
operator|-=
name|repl
expr_stmt|;
name|k
operator|-=
name|repl
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
name|wrtdata
argument_list|(
name|base
operator|+
name|soffset
argument_list|,
name|repl
argument_list|,
name|typelen
argument_list|,
name|constant
operator|->
name|constant
operator|.
name|ccp
argument_list|)
expr_stmt|;
else|else
name|wrtdata
argument_list|(
name|base
operator|+
name|soffset
argument_list|,
name|repl
argument_list|,
name|typelen
argument_list|,
name|packbytes
argument_list|(
name|constant
argument_list|)
argument_list|)
expr_stmt|;
name|soffset
operator|=
name|soffset
operator|+
name|repl
operator|*
name|typelen
expr_stmt|;
name|frexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|constant
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return;
block|}
end_block

begin_escape
end_escape

begin_macro
name|outdolist
argument_list|(
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|dolist
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
modifier|*
name|zerostep
init|=
literal|"zero step in implied-DO"
decl_stmt|;
specifier|static
name|char
modifier|*
name|order
init|=
literal|"zero iteration count in implied-DO"
decl_stmt|;
specifier|register
name|dvalue
modifier|*
name|e1
decl_stmt|,
modifier|*
name|e2
decl_stmt|,
modifier|*
name|e3
decl_stmt|;
specifier|register
name|int
name|direction
decl_stmt|;
specifier|register
name|dvalue
modifier|*
name|dv
decl_stmt|;
specifier|register
name|int
name|done
decl_stmt|;
specifier|register
name|int
name|addin
decl_stmt|;
specifier|register
name|int
name|ts
decl_stmt|;
specifier|register
name|ftnint
name|tv
decl_stmt|;
name|e1
operator|=
operator|(
name|dvalue
operator|*
operator|)
name|evalvexpr
argument_list|(
name|dp
operator|->
name|init
argument_list|)
expr_stmt|;
name|e2
operator|=
operator|(
name|dvalue
operator|*
operator|)
name|evalvexpr
argument_list|(
name|dp
operator|->
name|limit
argument_list|)
expr_stmt|;
name|e3
operator|=
operator|(
name|dvalue
operator|*
operator|)
name|evalvexpr
argument_list|(
name|dp
operator|->
name|step
argument_list|)
expr_stmt|;
if|if
condition|(
name|e1
operator|->
name|status
operator|==
name|ERRVAL
operator|||
name|e2
operator|->
name|status
operator|==
name|ERRVAL
operator|||
name|e3
operator|->
name|status
operator|==
name|ERRVAL
condition|)
block|{
name|dataerror
operator|=
name|YES
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|e1
operator|->
name|status
operator|==
name|NORMAL
condition|)
block|{
if|if
condition|(
name|e2
operator|->
name|status
operator|==
name|NORMAL
condition|)
block|{
if|if
condition|(
name|e1
operator|->
name|value
operator|<
name|e2
operator|->
name|value
condition|)
name|direction
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|e1
operator|->
name|value
operator|>
name|e2
operator|->
name|value
condition|)
name|direction
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|direction
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e2
operator|->
name|status
operator|==
name|MAXPLUS1
condition|)
name|direction
operator|=
literal|1
expr_stmt|;
else|else
name|direction
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e1
operator|->
name|status
operator|==
name|MAXPLUS1
condition|)
block|{
if|if
condition|(
name|e2
operator|->
name|status
operator|==
name|MAXPLUS1
condition|)
name|direction
operator|=
literal|0
expr_stmt|;
else|else
name|direction
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|e2
operator|->
name|status
operator|==
name|MINLESS1
condition|)
name|direction
operator|=
literal|0
expr_stmt|;
else|else
name|direction
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|e3
operator|->
name|status
operator|==
name|NORMAL
operator|&&
name|e3
operator|->
name|value
operator|==
literal|0
condition|)
block|{
name|err
argument_list|(
name|zerostep
argument_list|)
expr_stmt|;
name|dataerror
operator|=
name|YES
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
elseif|else
if|if
condition|(
name|e3
operator|->
name|status
operator|==
name|MAXPLUS1
operator|||
operator|(
name|e3
operator|->
name|status
operator|==
name|NORMAL
operator|&&
name|e3
operator|->
name|value
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|direction
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
name|order
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|direction
operator|==
literal|1
condition|)
block|{
name|warn
argument_list|(
name|order
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
name|dv
operator|=
operator|(
name|dvalue
operator|*
operator|)
name|dp
operator|->
name|dovar
expr_stmt|;
name|dv
operator|->
name|status
operator|=
name|e1
operator|->
name|status
expr_stmt|;
name|dv
operator|->
name|value
operator|=
name|e1
operator|->
name|value
expr_stmt|;
name|done
operator|=
name|NO
expr_stmt|;
while|while
condition|(
name|done
operator|==
name|NO
operator|&&
name|dataerror
operator|==
name|NO
condition|)
block|{
name|outdata
argument_list|(
name|dp
operator|->
name|elts
argument_list|)
expr_stmt|;
if|if
condition|(
name|e3
operator|->
name|status
operator|==
name|NORMAL
operator|&&
name|dv
operator|->
name|status
operator|==
name|NORMAL
condition|)
block|{
name|addints
argument_list|(
name|e3
operator|->
name|value
argument_list|,
name|dv
operator|->
name|value
argument_list|)
expr_stmt|;
name|dv
operator|->
name|status
operator|=
name|rstatus
expr_stmt|;
name|dv
operator|->
name|value
operator|=
name|rvalue
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|e3
operator|->
name|status
operator|!=
name|NORMAL
condition|)
block|{
if|if
condition|(
name|e3
operator|->
name|status
operator|==
name|MAXPLUS1
condition|)
name|addin
operator|=
name|MAXPLUS1
expr_stmt|;
else|else
name|addin
operator|=
name|MINLESS1
expr_stmt|;
name|ts
operator|=
name|dv
operator|->
name|status
expr_stmt|;
name|tv
operator|=
name|dv
operator|->
name|value
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dv
operator|->
name|status
operator|==
name|MAXPLUS1
condition|)
name|addin
operator|=
name|MAXPLUS1
expr_stmt|;
else|else
name|addin
operator|=
name|MINLESS1
expr_stmt|;
name|ts
operator|=
name|e3
operator|->
name|status
expr_stmt|;
name|tv
operator|=
name|e3
operator|->
name|value
expr_stmt|;
block|}
if|if
condition|(
name|addin
operator|==
name|MAXPLUS1
condition|)
block|{
if|if
condition|(
name|ts
operator|==
name|MAXPLUS1
operator|||
operator|(
name|ts
operator|==
name|NORMAL
operator|&&
name|tv
operator|>
literal|0
operator|)
condition|)
name|dv
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|ts
operator|==
name|NORMAL
operator|&&
name|tv
operator|==
literal|0
condition|)
name|dv
operator|->
name|status
operator|=
name|MAXPLUS1
expr_stmt|;
elseif|else
if|if
condition|(
name|ts
operator|==
name|NORMAL
condition|)
block|{
name|dv
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|dv
operator|->
name|value
operator|=
name|tv
operator|+
name|MAXINT
expr_stmt|;
name|dv
operator|->
name|value
operator|++
expr_stmt|;
block|}
else|else
block|{
name|dv
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|dv
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ts
operator|==
name|MINLESS1
operator|||
operator|(
name|ts
operator|==
name|NORMAL
operator|&&
name|tv
operator|<
literal|0
operator|)
condition|)
name|dv
operator|->
name|status
operator|=
name|ERRVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|ts
operator|==
name|NORMAL
operator|&&
name|tv
operator|==
literal|0
condition|)
name|dv
operator|->
name|status
operator|=
name|MINLESS1
expr_stmt|;
elseif|else
if|if
condition|(
name|ts
operator|==
name|NORMAL
condition|)
block|{
name|dv
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|dv
operator|->
name|value
operator|=
name|tv
operator|-
name|MAXINT
expr_stmt|;
name|dv
operator|->
name|value
operator|--
expr_stmt|;
block|}
else|else
block|{
name|dv
operator|->
name|status
operator|=
name|NORMAL
expr_stmt|;
name|dv
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dv
operator|->
name|status
operator|==
name|ERRVAL
condition|)
name|done
operator|=
name|YES
expr_stmt|;
elseif|else
if|if
condition|(
name|direction
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|e2
operator|->
name|status
operator|==
name|NORMAL
condition|)
block|{
if|if
condition|(
name|dv
operator|->
name|status
operator|==
name|MAXPLUS1
operator|||
operator|(
name|dv
operator|->
name|status
operator|==
name|NORMAL
operator|&&
name|dv
operator|->
name|value
operator|>
name|e2
operator|->
name|value
operator|)
condition|)
name|done
operator|=
name|YES
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|direction
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|e2
operator|->
name|status
operator|==
name|NORMAL
condition|)
block|{
if|if
condition|(
name|dv
operator|->
name|status
operator|==
name|MINLESS1
operator|||
operator|(
name|dv
operator|->
name|status
operator|==
name|NORMAL
operator|&&
name|dv
operator|->
name|value
operator|<
name|e2
operator|->
name|value
operator|)
condition|)
name|done
operator|=
name|YES
expr_stmt|;
block|}
block|}
else|else
name|done
operator|=
name|YES
expr_stmt|;
block|}
name|ret
label|:
name|frvexpr
argument_list|(
operator|(
name|vexpr
operator|*
operator|)
name|e1
argument_list|)
expr_stmt|;
name|frvexpr
argument_list|(
operator|(
name|vexpr
operator|*
operator|)
name|e2
argument_list|)
expr_stmt|;
name|frvexpr
argument_list|(
operator|(
name|vexpr
operator|*
operator|)
name|e3
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

end_unit

